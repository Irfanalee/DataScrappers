{
  "repo": "scrapy/scrapy",
  "scraped_at": "2026-02-03T13:37:38.023209",
  "stats": {
    "total_comments": 3243,
    "filtered": {
      "no_diff_hunk": 8,
      "too_short": 641,
      "not_python": 913,
      "too_long": 7,
      "skip_pattern:thank you": 3,
      "skip_pattern:looks good": 1,
      "skip_pattern:awesome": 1
    },
    "kept": 1669
  },
  "examples": [
    {
      "repo": "scrapy/scrapy",
      "pr_number": 7199,
      "file_path": "scrapy/utils/asyncio.py",
      "line": 74,
      "side": "RIGHT",
      "diff_hunk": "@@ -57,9 +57,23 @@ def is_asyncio_available() -> bool:\n     but it's possible to await on :class:`~twisted.internet.defer.Deferred`\n     objects.\n     \"\"\"\n-    if not is_reactor_installed():\n+\n+    # Check if there is a running asyncio loop.\n+    # Can't easily check for an installed but not running one, and there could\n+    # be false positives due to some 3rd-party code installing it as a side\n+    # effect.\n+    try:\n+        asyncio.get_running_loop()\n+    except RuntimeError:\n+        pass\n+    else:\n+        return True\n+\n+    # Check if there is an installed asyncio reactor (it doesn't need to be\n+    # running).\n+    if not is_reactor_installed():  # TODO ?",
      "comment": "The TODO comment lacks context about what needs to be resolved. Please clarify what decision or implementation is pending regarding this reactor check.\n```suggestion\n    # If no Twisted reactor is installed, asyncio is not available in Scrapy.\n    if not is_reactor_installed():\n```",
      "comment_id": 2649145733,
      "user": "Copilot",
      "created_at": "2025-12-27T13:46:52Z",
      "url": "https://github.com/scrapy/scrapy/pull/7199#discussion_r2649145733"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 7199,
      "file_path": "scrapy/crawler.py",
      "line": 784,
      "side": "RIGHT",
      "diff_hunk": "@@ -768,6 +780,21 @@ def start(\n         :param bool install_signal_handlers: whether to install the OS signal\n             handlers from Twisted and Scrapy (default: True)\n         \"\"\"\n+\n+        # TODO https://docs.python.org/3/library/asyncio-runner.html#handling-keyboard-interruption",
      "comment": "The TODO comment references keyboard interruption handling but doesn't explain what needs to be implemented. Please add a brief description of the pending work for future maintainers.\n```suggestion\n        # TODO: Implement robust KeyboardInterrupt (Ctrl+C) handling for this asyncio\n        #       event loop branch, following the recommendations in:\n        #       https://docs.python.org/3/library/asyncio-runner.html#handling-keyboard-interruption\n        #       so that pending tasks are cancelled and the loop is shut down cleanly.\n```",
      "comment_id": 2649145737,
      "user": "Copilot",
      "created_at": "2025-12-27T13:46:53Z",
      "url": "https://github.com/scrapy/scrapy/pull/7199#discussion_r2649145737"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 7199,
      "file_path": "scrapy/crawler.py",
      "line": 787,
      "side": "RIGHT",
      "diff_hunk": "@@ -768,6 +780,21 @@ def start(\n         :param bool install_signal_handlers: whether to install the OS signal\n             handlers from Twisted and Scrapy (default: True)\n         \"\"\"\n+\n+        # TODO https://docs.python.org/3/library/asyncio-runner.html#handling-keyboard-interruption\n+\n+        if not self.settings.getbool(\"TWISTED_ENABLED\"):\n+            loop = asyncio.get_event_loop()",
      "comment": "Using `get_event_loop()` is deprecated in favor of `get_running_loop()` when inside an async context. Since this is in the synchronous `start()` method and needs to get or create a loop, consider using `asyncio.new_event_loop()` and `asyncio.set_event_loop()` for explicit loop management to avoid deprecation warnings in Python 3.12+.",
      "comment_id": 2649145738,
      "user": "Copilot",
      "created_at": "2025-12-27T13:46:53Z",
      "url": "https://github.com/scrapy/scrapy/pull/7199#discussion_r2649145738"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 7199,
      "file_path": "scrapy/utils/reactorless.py",
      "line": 21,
      "side": "RIGHT",
      "diff_hunk": "@@ -0,0 +1,47 @@\n+from __future__ import annotations\n+\n+import sys\n+from importlib.abc import MetaPathFinder\n+from typing import TYPE_CHECKING\n+\n+from scrapy.utils.asyncio import is_asyncio_available\n+from scrapy.utils.reactor import is_reactor_installed\n+\n+if TYPE_CHECKING:\n+    from collections.abc import Sequence\n+    from importlib.machinery import ModuleSpec\n+    from types import ModuleType\n+\n+\n+def is_reactorless() -> bool:\n+    \"\"\"Check if we are running in the reactorless mode, i.e. with ``TWISTED_ENABLED=False``.\n+\n+    As this checks the runtime state and not the setting itself, it can be\n+    wrong when executed very early, before the reactor and/or the asyncio event\n+    loop are initiliazed.",
      "comment": "Corrected spelling of 'initiliazed' to 'initialized'.\n```suggestion\n    loop are initialized.\n```",
      "comment_id": 2665791316,
      "user": "Copilot",
      "created_at": "2026-01-06T18:06:43Z",
      "url": "https://github.com/scrapy/scrapy/pull/7199#discussion_r2665791316"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 7199,
      "file_path": "scrapy/utils/reactorless.py",
      "line": 39,
      "side": "RIGHT",
      "diff_hunk": "@@ -0,0 +1,47 @@\n+from __future__ import annotations\n+\n+import sys\n+from importlib.abc import MetaPathFinder\n+from typing import TYPE_CHECKING\n+\n+from scrapy.utils.asyncio import is_asyncio_available\n+from scrapy.utils.reactor import is_reactor_installed\n+\n+if TYPE_CHECKING:\n+    from collections.abc import Sequence\n+    from importlib.machinery import ModuleSpec\n+    from types import ModuleType\n+\n+\n+def is_reactorless() -> bool:\n+    \"\"\"Check if we are running in the reactorless mode, i.e. with ``TWISTED_ENABLED=False``.\n+\n+    As this checks the runtime state and not the setting itself, it can be\n+    wrong when executed very early, before the reactor and/or the asyncio event\n+    loop are initiliazed.\n+\n+    .. versionadded:: VERSION\n+    \"\"\"\n+    return is_asyncio_available() and not is_reactor_installed()\n+\n+\n+class ReactorImportHook(MetaPathFinder):\n+    \"\"\"Hook that prevents importing :mod:`twisted.internet.reactor`.\"\"\"\n+\n+    def find_spec(\n+        self,\n+        fullname: str,\n+        path: Sequence[str] | None,\n+        target: ModuleType | None = None,\n+    ) -> ModuleSpec | None:\n+        if fullname == \"twisted.internet.reactor\":\n+            raise ImportError(\n+                f\"Import of {fullname} is forbidden in the reactorless mode, to avoid silent problems.\"",
      "comment": "The error message should be more specific about what kind of \"silent problems\" could occur. Consider clarifying that importing the reactor module could lead to unexpected behavior when running without a Twisted reactor.\n```suggestion\n                f\"Import of {fullname} is forbidden in the reactorless mode, \"\n                \"because importing the Twisted reactor when running without a Twisted \"\n                \"reactor can lead to unexpected behavior.\"\n```",
      "comment_id": 2665791342,
      "user": "Copilot",
      "created_at": "2026-01-06T18:06:44Z",
      "url": "https://github.com/scrapy/scrapy/pull/7199#discussion_r2665791342"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 7199,
      "file_path": "scrapy/extensions/telnet.py",
      "line": 50,
      "side": "RIGHT",
      "diff_hunk": "@@ -44,6 +44,12 @@ def __init__(self, crawler: Crawler):\n         if not crawler.settings.getbool(\"TELNETCONSOLE_ENABLED\"):\n             raise NotConfigured\n \n+        if not crawler.settings.getbool(\"TWISTED_ENABLED\"):\n+            raise NotConfigured(\n+                \"The TelnetConsole extension requires a Twisted reactor.\"\n+                \" You can set the TELNETCONSOLE_ENABLED setting to False to remove this warning.\"",
      "comment": "The message refers to \"this warning\" but `NotConfigured` is an exception, not a warning. The text should say \"to prevent this error\" or similar.\n```suggestion\n                \" You can set the TELNETCONSOLE_ENABLED setting to False to prevent this error.\"\n```",
      "comment_id": 2665791361,
      "user": "Copilot",
      "created_at": "2026-01-06T18:06:44Z",
      "url": "https://github.com/scrapy/scrapy/pull/7199#discussion_r2665791361"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 7199,
      "file_path": "scrapy/extensions/telnet.py",
      "line": 51,
      "side": "RIGHT",
      "diff_hunk": "@@ -44,6 +44,12 @@ def __init__(self, crawler: Crawler):\n         if not crawler.settings.getbool(\"TELNETCONSOLE_ENABLED\"):\n             raise NotConfigured\n \n+        if not crawler.settings.getbool(\"TWISTED_ENABLED\"):\n+            raise NotConfigured(\n+                \"The TelnetConsole extension requires a Twisted reactor.\"\n+                \" You can set the TELNETCONSOLE_ENABLED setting to False to remove this warning.\"\n+            )",
      "comment": "What do you think if, in addition to this, we change the default value of `TELNETCONSOLE_ENABLED` to match `TWISTED_ENABLED`?\n\nThat is:\n- If the user does not override `TELNETCONSOLE_ENABLED`, setting `TELNET_ENABLED` to `False` automatically disables the telnet console.\n- Only if the user explicitly sets `TELNETCONSOLE_ENABLED` to `True` and `TELNET_ENABLED` to `False` will they get this warning.",
      "comment_id": 2705773782,
      "user": "Gallaecio",
      "created_at": "2026-01-19T18:34:59Z",
      "url": "https://github.com/scrapy/scrapy/pull/7199#discussion_r2705773782"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 7199,
      "file_path": "scrapy/utils/asyncio.py",
      "line": 69,
      "side": "RIGHT",
      "diff_hunk": "@@ -56,10 +57,29 @@ def is_asyncio_available() -> bool:\n     loop or await on :class:`asyncio.Future` objects in Scrapy-related code,\n     but it's possible to await on :class:`~twisted.internet.defer.Deferred`\n     objects.\n+\n+    .. versionchanged:: VERSION\n+        This function now also returns ``True`` if there is a running asyncio\n+        loop, even if no Twisted reactor is installed.\n     \"\"\"\n+\n+    # Check if there is a running asyncio loop.\n+    # Can't easily check for an installed but not running one, and there could\n+    # be false positives due to some 3rd-party code installing it as a side\n+    # effect.",
      "comment": "Is the side effect something we should cover somewhere in the docs? e.g. mention it in the `TWISTED_REACTOR` docs with an example of a known library or similar that could cause this issue? Maybe cover some example run-time error message that can be triggered as a result, to make finding these docs easier?",
      "comment_id": 2705782801,
      "user": "Gallaecio",
      "created_at": "2026-01-19T18:39:48Z",
      "url": "https://github.com/scrapy/scrapy/pull/7199#discussion_r2705782801"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 7199,
      "file_path": "scrapy/utils/asyncio.py",
      "line": 71,
      "side": "RIGHT",
      "diff_hunk": "@@ -56,10 +57,29 @@ def is_asyncio_available() -> bool:\n     loop or await on :class:`asyncio.Future` objects in Scrapy-related code,\n     but it's possible to await on :class:`~twisted.internet.defer.Deferred`\n     objects.\n+\n+    .. versionchanged:: VERSION\n+        This function now also returns ``True`` if there is a running asyncio\n+        loop, even if no Twisted reactor is installed.\n     \"\"\"\n+\n+    # Check if there is a running asyncio loop.\n+    # Can't easily check for an installed but not running one, and there could\n+    # be false positives due to some 3rd-party code installing it as a side\n+    # effect.\n+    try:\n+        asyncio.get_running_loop()",
      "comment": "The [upstream docs](https://docs.python.org/3/library/asyncio-eventloop.html#asyncio.get_running_loop) state:\n\n> This function can only be called from a coroutine or a callback.\n\nShould we mention this in our docstring?",
      "comment_id": 2705787950,
      "user": "Gallaecio",
      "created_at": "2026-01-19T18:42:35Z",
      "url": "https://github.com/scrapy/scrapy/pull/7199#discussion_r2705787950"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 7199,
      "file_path": "scrapy/utils/reactorless.py",
      "line": 24,
      "side": "RIGHT",
      "diff_hunk": "@@ -0,0 +1,48 @@\n+from __future__ import annotations\n+\n+import sys\n+from importlib.abc import MetaPathFinder\n+from typing import TYPE_CHECKING\n+\n+from scrapy.utils.asyncio import is_asyncio_available\n+from scrapy.utils.reactor import is_reactor_installed\n+\n+if TYPE_CHECKING:\n+    from collections.abc import Sequence\n+    from importlib.machinery import ModuleSpec\n+    from types import ModuleType\n+\n+\n+def is_reactorless() -> bool:\n+    \"\"\"Check if we are running in the reactorless mode, i.e. with ``TWISTED_ENABLED=False``.\n+\n+    As this checks the runtime state and not the setting itself, it can be\n+    wrong when executed very early, before the reactor and/or the asyncio event\n+    loop are initialized.\n+\n+    .. versionadded:: VERSION\n+    \"\"\"",
      "comment": "```suggestion\n    \"\"\"Check if we are running in the reactorless mode, i.e. with\n    :setting:`TWISTED_ENABLED` set to ``False``.\n\n    As this checks the runtime state and not the setting itself, it can be\n    wrong when executed very early, before the reactor and/or the asyncio event\n    loop are initialized.\n\n    .. versionadded:: VERSION\n    \"\"\"\n```\n\n(I take it the actual exposing of this docstring in the docs is out of scope for this PR)",
      "comment_id": 2705794121,
      "user": "Gallaecio",
      "created_at": "2026-01-19T18:45:45Z",
      "url": "https://github.com/scrapy/scrapy/pull/7199#discussion_r2705794121"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 7199,
      "file_path": "scrapy/crawler.py",
      "line": 519,
      "side": "RIGHT",
      "diff_hunk": "@@ -499,9 +509,14 @@ def crawl(\n                 \"The crawler_or_spidercls argument cannot be a spider object, \"\n                 \"it must be a spider class (or a Crawler object)\"\n             )\n-        if not is_asyncio_reactor_installed():\n+        if self.settings.getbool(\"TWISTED_ENABLED\"):\n+            if not is_asyncio_reactor_installed():\n+                raise RuntimeError(\n+                    f\"{type(self).__name__} requires AsyncioSelectorReactor when using a reactor.\"\n+                )\n+        elif is_reactor_installed():\n             raise RuntimeError(\n-                f\"{type(self).__name__} requires AsyncioSelectorReactor.\"\n+                \"TWISTED_ENABLED is False but a Twisted reactor is installed.\"",
      "comment": "In a future PR, e.g. the one adding docs, it may be a good idea to try to provide some next steps here to help users figure out how to debug the issue, maybe a link to some new docs section that we can expand with time.",
      "comment_id": 2705806909,
      "user": "Gallaecio",
      "created_at": "2026-01-19T18:52:12Z",
      "url": "https://github.com/scrapy/scrapy/pull/7199#discussion_r2705806909"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 7199,
      "file_path": "scrapy/crawler.py",
      "line": 515,
      "side": "RIGHT",
      "diff_hunk": "@@ -499,9 +509,14 @@ def crawl(\n                 \"The crawler_or_spidercls argument cannot be a spider object, \"\n                 \"it must be a spider class (or a Crawler object)\"\n             )\n-        if not is_asyncio_reactor_installed():\n+        if self.settings.getbool(\"TWISTED_ENABLED\"):\n+            if not is_asyncio_reactor_installed():\n+                raise RuntimeError(\n+                    f\"{type(self).__name__} requires AsyncioSelectorReactor when using a reactor.\"",
      "comment": "Maybe we could word this is more practical/\"code\" terms:\n\n```suggestion\n                    f'When TWISTED_ENABLED is True, {type(self).__name__} '\n                    f'requires TWISTED_REACTOR to be '\n                    f'\"twisted.internet.asyncioreactor.AsyncioSelectorReactor\".'\n```",
      "comment_id": 2705812861,
      "user": "Gallaecio",
      "created_at": "2026-01-19T18:55:24Z",
      "url": "https://github.com/scrapy/scrapy/pull/7199#discussion_r2705812861"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 7199,
      "file_path": "scrapy/extensions/telnet.py",
      "line": 51,
      "side": "RIGHT",
      "diff_hunk": "@@ -44,6 +44,12 @@ def __init__(self, crawler: Crawler):\n         if not crawler.settings.getbool(\"TELNETCONSOLE_ENABLED\"):\n             raise NotConfigured\n \n+        if not crawler.settings.getbool(\"TWISTED_ENABLED\"):\n+            raise NotConfigured(\n+                \"The TelnetConsole extension requires a Twisted reactor.\"\n+                \" You can set the TELNETCONSOLE_ENABLED setting to False to remove this warning.\"\n+            )",
      "comment": "This behavior is indeed an open question that I planned to ask explicitly. As an alternative to this code I also considered simply raising a `NotConfigured` without a warning here. Setting `TELNETCONSOLE_ENABLED=False` when encountering `TWISTED_ENABLED=False` (and so also not producing any warning here) also makes sense, and there is a later question of what should we do with the default download handlers as we may want to have a non-Twisted ones enabled by default in the reactorless mode.\r\n\r\n> Only if the user explicitly sets \r\n\r\nHow would we detect this? Via priorities?",
      "comment_id": 2708939560,
      "user": "wRAR",
      "created_at": "2026-01-20T15:45:11Z",
      "url": "https://github.com/scrapy/scrapy/pull/7199#discussion_r2708939560"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 7199,
      "file_path": "scrapy/extensions/telnet.py",
      "line": 51,
      "side": "RIGHT",
      "diff_hunk": "@@ -44,6 +44,12 @@ def __init__(self, crawler: Crawler):\n         if not crawler.settings.getbool(\"TELNETCONSOLE_ENABLED\"):\n             raise NotConfigured\n \n+        if not crawler.settings.getbool(\"TWISTED_ENABLED\"):\n+            raise NotConfigured(\n+                \"The TelnetConsole extension requires a Twisted reactor.\"\n+                \" You can set the TELNETCONSOLE_ENABLED setting to False to remove this warning.\"\n+            )",
      "comment": "> How would we detect this? Via priorities?\r\n\r\nYes.\r\n\r\nI was hoping to do it at the `default_settings.py` level when I wrote that, but now that I think about it that would not really work. But we may be able to find some place in the code after add-ons have been evaluated, and set the telnet setting to the value of the twisted setting with the basic priority (so it is effectively a no-op if any higher priority has set it).",
      "comment_id": 2709027709,
      "user": "Gallaecio",
      "created_at": "2026-01-20T16:03:46Z",
      "url": "https://github.com/scrapy/scrapy/pull/7199#discussion_r2709027709"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 7199,
      "file_path": "scrapy/crawler.py",
      "line": 515,
      "side": "RIGHT",
      "diff_hunk": "@@ -499,9 +509,14 @@ def crawl(\n                 \"The crawler_or_spidercls argument cannot be a spider object, \"\n                 \"it must be a spider class (or a Crawler object)\"\n             )\n-        if not is_asyncio_reactor_installed():\n+        if self.settings.getbool(\"TWISTED_ENABLED\"):\n+            if not is_asyncio_reactor_installed():\n+                raise RuntimeError(\n+                    f\"{type(self).__name__} requires AsyncioSelectorReactor when using a reactor.\"",
      "comment": "This indeed needs rewording but the context is `AsyncCrawlerRunner` so it's important which reactor is already installed by the user, not the setting.",
      "comment_id": 2749432018,
      "user": "wRAR",
      "created_at": "2026-01-31T11:43:12Z",
      "url": "https://github.com/scrapy/scrapy/pull/7199#discussion_r2749432018"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 7199,
      "file_path": "scrapy/utils/asyncio.py",
      "line": 71,
      "side": "RIGHT",
      "diff_hunk": "@@ -56,10 +57,29 @@ def is_asyncio_available() -> bool:\n     loop or await on :class:`asyncio.Future` objects in Scrapy-related code,\n     but it's possible to await on :class:`~twisted.internet.defer.Deferred`\n     objects.\n+\n+    .. versionchanged:: VERSION\n+        This function now also returns ``True`` if there is a running asyncio\n+        loop, even if no Twisted reactor is installed.\n     \"\"\"\n+\n+    # Check if there is a running asyncio loop.\n+    # Can't easily check for an installed but not running one, and there could\n+    # be false positives due to some 3rd-party code installing it as a side\n+    # effect.\n+    try:\n+        asyncio.get_running_loop()",
      "comment": "I've spent some time trying to write something that doesn't make the user more confused than not having anything, I guess we can also improve this later if needed.",
      "comment_id": 2749538455,
      "user": "wRAR",
      "created_at": "2026-01-31T12:54:55Z",
      "url": "https://github.com/scrapy/scrapy/pull/7199#discussion_r2749538455"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 7199,
      "file_path": "scrapy/utils/asyncio.py",
      "line": 69,
      "side": "RIGHT",
      "diff_hunk": "@@ -56,10 +57,29 @@ def is_asyncio_available() -> bool:\n     loop or await on :class:`asyncio.Future` objects in Scrapy-related code,\n     but it's possible to await on :class:`~twisted.internet.defer.Deferred`\n     objects.\n+\n+    .. versionchanged:: VERSION\n+        This function now also returns ``True`` if there is a running asyncio\n+        loop, even if no Twisted reactor is installed.\n     \"\"\"\n+\n+    # Check if there is a running asyncio loop.\n+    # Can't easily check for an installed but not running one, and there could\n+    # be false positives due to some 3rd-party code installing it as a side\n+    # effect.",
      "comment": "It's about an installed-but-not-running loop so it doesn't apply to the code as implemented, only to one that would check for an installed loop.",
      "comment_id": 2749541321,
      "user": "wRAR",
      "created_at": "2026-01-31T12:57:44Z",
      "url": "https://github.com/scrapy/scrapy/pull/7199#discussion_r2749541321"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 7208,
      "file_path": "scrapy/settings/default_settings.py",
      "line": 461,
      "side": "RIGHT",
      "diff_hunk": "@@ -453,6 +453,11 @@\n \n RETRY_ENABLED = True\n RETRY_EXCEPTIONS = [\n+    \"scrapy.exceptions.CannotResolveHostError\",\n+    \"scrapy.exceptions.DownloadConnectionRefusedError\",\n+    \"scrapy.exceptions.DownloadFailedError\",\n+    \"scrapy.exceptions.DownloadTimeoutError\",\n+    \"scrapy.exceptions.ResponseDataLoss\",\n     \"twisted.internet.defer.TimeoutError\",",
      "comment": "A big question here is whether we want to remove some Twisted ones if we expected them to never be raised directly, but always be wrapped.",
      "comment_id": 2656462997,
      "user": "wRAR",
      "created_at": "2026-01-01T16:13:02Z",
      "url": "https://github.com/scrapy/scrapy/pull/7208#discussion_r2656462997"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 7208,
      "file_path": "tests/test_downloader_handlers_http_base.py",
      "line": 516,
      "side": "RIGHT",
      "diff_hunk": "@@ -497,12 +511,10 @@ async def test_download_chunked_content(self, mockserver: MockServer) -> None:\n     async def test_download_cause_data_loss(\n         self, url: str, mockserver: MockServer\n     ) -> None:\n-        # TODO: this one checks for Twisted-specific exceptions\n         request = Request(mockserver.url(f\"/{url}\", is_secure=self.is_secure))\n         async with self.get_dh() as download_handler:\n-            with pytest.raises(ResponseFailed) as exc_info:\n+            with pytest.raises(ResponseDataLoss):",
      "comment": "The new exception `ResponseDataLoss` is raised in the handler but this test doesn't verify the cause chain. Consider adding an assertion to verify that `exc_info.value.__cause__` is set correctly to maintain the original error information.",
      "comment_id": 2656469596,
      "user": "Copilot",
      "created_at": "2026-01-01T16:20:43Z",
      "url": "https://github.com/scrapy/scrapy/pull/7208#discussion_r2656469596"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 7208,
      "file_path": "scrapy/core/downloader/handlers/http11.py",
      "line": 768,
      "side": "RIGHT",
      "diff_hunk": "@@ -741,4 +763,8 @@ def connectionLost(self, reason: Failure = connectionDone) -> None:\n                 )\n                 self._fail_on_dataloss_warned = True\n \n+            exc = ResponseDataLoss()\n+            exc.__cause__ = reason.value\n+            reason = Failure(exc)",
      "comment": "The manual setting of `__cause__` is unusual. Consider using `raise ... from` pattern consistently with other exception handling in this file. If this pattern is necessary due to Twisted's Failure mechanics, a comment explaining why would be helpful.\n```suggestion\n            try:\n                # Use exception chaining to record the original Twisted failure\n                raise ResponseDataLoss() from reason.value\n            except ResponseDataLoss as exc:\n                reason = Failure(exc)\n```",
      "comment_id": 2656469599,
      "user": "Copilot",
      "created_at": "2026-01-01T16:20:44Z",
      "url": "https://github.com/scrapy/scrapy/pull/7208#discussion_r2656469599"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 7208,
      "file_path": "tests/mockserver/http_resources.py",
      "line": 195,
      "side": "RIGHT",
      "diff_hunk": "@@ -193,10 +193,11 @@ def _delayedRender(self, request):\n         request.write(b\"this connection will be dropped\\n\")\n         tr = request.channel.transport\n         try:",
      "comment": "The null check for `tr` suggests a defensive fix but lacks context. Consider adding a comment explaining when/why `tr` might be None to help future maintainers understand this edge case.\n```suggestion\n        try:\n            # transport may be None if the connection has already been closed\n            # (e.g. by the client or reactor) before this callback runs\n```",
      "comment_id": 2656469601,
      "user": "Copilot",
      "created_at": "2026-01-01T16:20:44Z",
      "url": "https://github.com/scrapy/scrapy/pull/7208#discussion_r2656469601"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 7208,
      "file_path": "tests/test_downloader_handlers_http_base.py",
      "line": 794,
      "side": "RIGHT",
      "diff_hunk": "@@ -734,9 +789,9 @@ async def test_download_with_proxy_https_timeout(\n         domain = \"https://no-such-domain.nosuch\"\n         request = Request(domain, meta={\"proxy\": http_proxy, \"download_timeout\": 0.2})\n         async with self.get_dh() as download_handler:\n-            with pytest.raises(error.TimeoutError) as exc_info:\n+            with pytest.raises(DownloadTimeoutError) as exc_info:\n                 await download_handler.download_request(request)\n-        assert domain in exc_info.value.osError\n+        assert domain in str(exc_info.value)",
      "comment": "The test now checks for domain presence in the error message string but doesn't verify the exception message format or structure. Consider using a more specific assertion like checking for the expected error message pattern to make the test more robust.",
      "comment_id": 2656469605,
      "user": "Copilot",
      "created_at": "2026-01-01T16:20:44Z",
      "url": "https://github.com/scrapy/scrapy/pull/7208#discussion_r2656469605"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 7208,
      "file_path": "scrapy/settings/default_settings.py",
      "line": 461,
      "side": "RIGHT",
      "diff_hunk": "@@ -453,6 +453,11 @@\n \n RETRY_ENABLED = True\n RETRY_EXCEPTIONS = [\n+    \"scrapy.exceptions.CannotResolveHostError\",\n+    \"scrapy.exceptions.DownloadConnectionRefusedError\",\n+    \"scrapy.exceptions.DownloadFailedError\",\n+    \"scrapy.exceptions.DownloadTimeoutError\",\n+    \"scrapy.exceptions.ResponseDataLoss\",\n     \"twisted.internet.defer.TimeoutError\",",
      "comment": "I wonder if keeping them by \"deprecating\" them (deprecation warning when raised?) would make sense or be overkill. I don\u2019t see how they could be raised unless you are doing something weird (inline treq use?). I\u2019m fine with removal if we cannot think of a realistic scenario where they would not be wrapped (if a scenario appears later, we can always release a bug fix that implements the corresponding wrapping).",
      "comment_id": 2657647126,
      "user": "Gallaecio",
      "created_at": "2026-01-02T12:36:07Z",
      "url": "https://github.com/scrapy/scrapy/pull/7208#discussion_r2657647126"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 7164,
      "file_path": "scrapy/core/downloader/handlers/ftp.py",
      "line": 123,
      "side": "LEFT",
      "diff_hunk": "@@ -112,43 +104,23 @@ def download_request(self, request: Request, spider: Spider) -> Deferred[Respons\n         creator = ClientCreator(\n             reactor, FTPClient, user, password, passive=passive_mode\n         )\n-        dfd: Deferred[FTPClient] = creator.connectTCP(\n-            parsed_url.hostname, parsed_url.port or 21\n+        client: FTPClient = await maybe_deferred_to_future(\n+            creator.connectTCP(parsed_url.hostname, parsed_url.port or 21)\n         )\n-        return dfd.addCallback(self.gotClient, request, unquote(parsed_url.path))\n-\n-    def gotClient(\n-        self, client: FTPClient, request: Request, filepath: str\n-    ) -> Deferred[Response]:\n-        self.client = client",
      "comment": "Never used in Scrapy (and changing it on every request makes it not useful).",
      "comment_id": 2572893669,
      "user": "wRAR",
      "created_at": "2025-11-29T08:19:47Z",
      "url": "https://github.com/scrapy/scrapy/pull/7164#discussion_r2572893669"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 7164,
      "file_path": "scrapy/core/downloader/handlers/s3.py",
      "line": 33,
      "side": "LEFT",
      "diff_hunk": "@@ -1,65 +1,35 @@\n from __future__ import annotations\n \n-from typing import TYPE_CHECKING, Any\n+from typing import TYPE_CHECKING\n \n+from scrapy.core.downloader.handlers.base import BaseDownloadHandler\n from scrapy.core.downloader.handlers.http11 import HTTP11DownloadHandler\n from scrapy.exceptions import NotConfigured\n from scrapy.utils.boto import is_botocore_available\n from scrapy.utils.httpobj import urlparse_cached\n from scrapy.utils.misc import build_from_crawler\n \n if TYPE_CHECKING:\n-    from twisted.internet.defer import Deferred\n-\n-    # typing.Self requires Python 3.11\n-    from typing_extensions import Self\n-\n-    from scrapy import Request, Spider\n+    from scrapy import Request\n     from scrapy.crawler import Crawler\n     from scrapy.http import Response\n-    from scrapy.settings import BaseSettings\n \n \n-class S3DownloadHandler:\n-    def __init__(\n-        self,\n-        settings: BaseSettings,\n-        *,\n-        crawler: Crawler,\n-        aws_access_key_id: str | None = None,\n-        aws_secret_access_key: str | None = None,\n-        aws_session_token: str | None = None,\n-        httpdownloadhandler: type[HTTP11DownloadHandler] = HTTP11DownloadHandler,\n-        **kw: Any,",
      "comment": "User code can't pass these extra args. I've studied why were they even added but forgot it again.",
      "comment_id": 2572894529,
      "user": "wRAR",
      "created_at": "2025-11-29T08:21:42Z",
      "url": "https://github.com/scrapy/scrapy/pull/7164#discussion_r2572894529"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 7164,
      "file_path": "scrapy/core/downloader/handlers/s3.py",
      "line": 20,
      "side": "RIGHT",
      "diff_hunk": "@@ -1,65 +1,35 @@\n from __future__ import annotations\n \n-from typing import TYPE_CHECKING, Any\n+from typing import TYPE_CHECKING\n \n+from scrapy.core.downloader.handlers.base import BaseDownloadHandler\n from scrapy.core.downloader.handlers.http11 import HTTP11DownloadHandler\n from scrapy.exceptions import NotConfigured\n from scrapy.utils.boto import is_botocore_available\n from scrapy.utils.httpobj import urlparse_cached\n from scrapy.utils.misc import build_from_crawler\n \n if TYPE_CHECKING:\n-    from twisted.internet.defer import Deferred\n-\n-    # typing.Self requires Python 3.11\n-    from typing_extensions import Self\n-\n-    from scrapy import Request, Spider\n+    from scrapy import Request\n     from scrapy.crawler import Crawler\n     from scrapy.http import Response\n-    from scrapy.settings import BaseSettings\n \n \n-class S3DownloadHandler:\n-    def __init__(\n-        self,\n-        settings: BaseSettings,\n-        *,\n-        crawler: Crawler,\n-        aws_access_key_id: str | None = None,\n-        aws_secret_access_key: str | None = None,\n-        aws_session_token: str | None = None,\n-        httpdownloadhandler: type[HTTP11DownloadHandler] = HTTP11DownloadHandler,\n-        **kw: Any,\n-    ):\n+class S3DownloadHandler(BaseDownloadHandler):\n+    def __init__(self, crawler: Crawler):\n         if not is_botocore_available():",
      "comment": "It became clear after the refactoring that, technically, botocore is not needed for anonymous requests (they are converted into https://s3.amazonaws.com ones), but it may be more confusing to change this.",
      "comment_id": 2572895395,
      "user": "wRAR",
      "created_at": "2025-11-29T08:24:13Z",
      "url": "https://github.com/scrapy/scrapy/pull/7164#discussion_r2572895395"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 7164,
      "file_path": "tests/test_downloader_handler_twisted_ftp.py",
      "line": 28,
      "side": "RIGHT",
      "diff_hunk": "@@ -13,17 +14,18 @@\n from scrapy.core.downloader.handlers.ftp import FTPDownloadHandler\n from scrapy.http import HtmlResponse, Request, Response\n from scrapy.http.response.text import TextResponse\n-from scrapy.utils.defer import deferred_f_from_coro_f, maybe_deferred_to_future\n+from scrapy.utils.defer import deferred_f_from_coro_f\n from scrapy.utils.misc import build_from_crawler\n from scrapy.utils.python import to_bytes\n-from scrapy.utils.spider import DefaultSpider\n from scrapy.utils.test import get_crawler\n \n if TYPE_CHECKING:\n     from collections.abc import AsyncGenerator, Generator\n \n+    from twisted.protocols.ftp import FTPFactory\n \n-class TestFTPBase:\n+\n+class TestFTPBase(ABC):",
      "comment": "This change is unrelated, I've found that `TestFTPBase` methods were also run as test cases.",
      "comment_id": 2572895740,
      "user": "wRAR",
      "created_at": "2025-11-29T08:25:18Z",
      "url": "https://github.com/scrapy/scrapy/pull/7164#discussion_r2572895740"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 7164,
      "file_path": "tests/test_engine_loop.py",
      "line": 88,
      "side": "RIGHT",
      "diff_hunk": "@@ -86,6 +85,7 @@ def track_url(request, spider):\n         expected_urls = [\"data:,a\", \"data:,b\", \"data:,c\", \"data:,d\"]\n         assert actual_urls == expected_urls, f\"{actual_urls=} != {expected_urls=}\"\n \n+    @pytest.mark.skip(reason=\"Hangs\")  # requires changes from #7161",
      "comment": "Both this PR and #7161 introduce more context switch points to, probably, `ExecutionEngine.close_spider_async()` and this test starts to fail, the `ExecutionEngine` workaround is included in that earlier PR and helps with this PR too.",
      "comment_id": 2572897412,
      "user": "wRAR",
      "created_at": "2025-11-29T08:30:26Z",
      "url": "https://github.com/scrapy/scrapy/pull/7164#discussion_r2572897412"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 7164,
      "file_path": "tests/test_downloader_handler_twisted_ftp.py",
      "line": 104,
      "side": "RIGHT",
      "diff_hunk": "@@ -111,8 +99,9 @@ async def test_ftp_download_nonexistent(\n         self, server_url: str, dh: FTPDownloadHandler\n     ) -> None:\n         request = Request(url=server_url + \"nonexistent.txt\", meta=self.req_meta)\n-        r = await self.download_request(dh, request)\n+        r = await dh.download_request(request)\n         assert r.status == 404\n+        assert r.body == b\"['550 nonexistent.txt: No such file or directory.']\"",
      "comment": "The assertion for response body on line 104 was added but there is no corresponding test to verify this assertion fails when the body is incorrect. Consider adding a test case that verifies different error message formats.",
      "comment_id": 2623560964,
      "user": "Copilot",
      "created_at": "2025-12-16T14:40:27Z",
      "url": "https://github.com/scrapy/scrapy/pull/7164#discussion_r2623560964"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 7164,
      "file_path": "scrapy/core/downloader/handlers/ftp.py",
      "line": 115,
      "side": "RIGHT",
      "diff_hunk": "@@ -112,43 +102,23 @@ def download_request(self, request: Request, spider: Spider) -> Deferred[Respons\n         creator = ClientCreator(\n             reactor, FTPClient, user, password, passive=passive_mode\n         )\n-        dfd: Deferred[FTPClient] = creator.connectTCP(\n-            parsed_url.hostname, parsed_url.port or 21\n+        client: FTPClient = await maybe_deferred_to_future(\n+            creator.connectTCP(parsed_url.hostname, parsed_url.port or 21)\n         )\n-        return dfd.addCallback(self.gotClient, request, unquote(parsed_url.path))\n-\n-    def gotClient(\n-        self, client: FTPClient, request: Request, filepath: str\n-    ) -> Deferred[Response]:\n-        self.client = client\n+        filepath = unquote(parsed_url.path)\n         protocol = ReceivedDataProtocol(request.meta.get(\"ftp_local_filename\"))\n-        d = client.retrieveFile(filepath, protocol)\n-        d.addCallback(self._build_response, request, protocol)\n-        d.addErrback(self._failed, request)\n-        return d\n-\n-    def _build_response(\n-        self, result: Any, request: Request, protocol: ReceivedDataProtocol\n-    ) -> Response:\n-        self.result = result\n+        try:\n+            await maybe_deferred_to_future(client.retrieveFile(filepath, protocol))\n+        except CommandFailed as e:\n+            message = str(e)\n+            if m := _CODE_RE.search(message):\n+                ftpcode = m.group()",
      "comment": "The variable name 'm' is ambiguous. Consider renaming it to 'match' or 'code_match' for better clarity.\n```suggestion\n            if match := _CODE_RE.search(message):\n                ftpcode = match.group()\n```",
      "comment_id": 2623561012,
      "user": "Copilot",
      "created_at": "2025-12-16T14:40:28Z",
      "url": "https://github.com/scrapy/scrapy/pull/7164#discussion_r2623561012"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 7164,
      "file_path": "tests/test_downloader_handlers.py",
      "line": 89,
      "side": "RIGHT",
      "diff_hunk": "@@ -61,6 +76,18 @@ def test_not_configured_handler(self):\n         assert \"scheme\" not in dh._handlers\n         assert \"scheme\" in dh._notconfigured\n \n+    def test_buggy_handler(self, caplog: pytest.LogCaptureFixture) -> None:\n+        handlers = {\"scheme\": BuggyDH}\n+        crawler = get_crawler(settings_dict={\"DOWNLOAD_HANDLERS\": handlers})\n+        dh = DownloadHandlers(crawler)\n+        assert \"scheme\" in dh._schemes\n+        assert \"scheme\" not in dh._handlers\n+        assert \"scheme\" in dh._notconfigured\n+        assert (\n+            'Loading \"<class \\'tests.test_downloader_handlers.BuggyDH\\'>\" for scheme \"scheme\"'\n+            in caplog.text\n+        )",
      "comment": "This test verifies logging output but doesn't assert what happens after the exception is caught. Consider adding an assertion to verify the handler is properly marked as not configured.",
      "comment_id": 2623561148,
      "user": "Copilot",
      "created_at": "2025-12-16T14:40:29Z",
      "url": "https://github.com/scrapy/scrapy/pull/7164#discussion_r2623561148"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 6940,
      "file_path": "scrapy/pqueues.py",
      "line": 340,
      "side": "RIGHT",
      "diff_hunk": "@@ -336,6 +336,8 @@ def pop(self) -> Request | None:\n \n     def push(self, request: Request) -> None:\n         slot = self._downloader_interface.get_slot_key(request)\n+        # Handle None slot by converting to string\n+        slot = str(slot)",
      "comment": "This looks wrong, is it needed because of type checks or is it triggered in an actual code path?",
      "comment_id": 2217253349,
      "user": "wRAR",
      "created_at": "2025-07-19T09:21:03Z",
      "url": "https://github.com/scrapy/scrapy/pull/6940#discussion_r2217253349"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 6940,
      "file_path": "scrapy/pqueues.py",
      "line": 340,
      "side": "RIGHT",
      "diff_hunk": "@@ -336,6 +336,8 @@ def pop(self) -> Request | None:\n \n     def push(self, request: Request) -> None:\n         slot = self._downloader_interface.get_slot_key(request)\n+        # Handle None slot by converting to string\n+        slot = str(slot)",
      "comment": "Actually, it's what I said in the description of the PR, there's a call to self._path_safe(slot). \r\nIf the value is None, it break the tests:\r\n\r\n\r\n\"The second issue appeared in tests/test_downloaderslotssettings.py::TestCrawl::test_delay. This test deliberately creates requests with meta={\"download_slot\": None}, which works fine with ScrapyPriorityQueue since it ignores slots entirely. However, DownloaderAwarePriorityQueue organizes requests by slot and calls _path_safe(slot) where slot can be None, causing a TypeError. The difference is that ScrapyPriorityQueue uses self.key + \"/\" + str(priority) for internal queues, while DownloaderAwarePriorityQueue uses self.key + \"/\" + _path_safe(slot). The fix was convert None slots to the string \"None\"\"\r\n\r\n\r\nBut I'm not certain about this",
      "comment_id": 2217404160,
      "user": "thalissonvs",
      "created_at": "2025-07-19T18:18:42Z",
      "url": "https://github.com/scrapy/scrapy/pull/6940#discussion_r2217404160"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 6940,
      "file_path": "scrapy/pqueues.py",
      "line": 340,
      "side": "RIGHT",
      "diff_hunk": "@@ -336,6 +336,8 @@ def pop(self) -> Request | None:\n \n     def push(self, request: Request) -> None:\n         slot = self._downloader_interface.get_slot_key(request)\n+        # Handle None slot by converting to string\n+        slot = str(slot)",
      "comment": "This will treat None as a valid slot. Since `DownloaderAwarePriorityQueue` manages requests by slot, it will simply create a slot named \"None\", which the downloader will accept as valid.\r\nAn alternative would be to treat None as a fallback, using the default hostname-based slot key instead of creating a literal \"None\" slot",
      "comment_id": 2217405376,
      "user": "thalissonvs",
      "created_at": "2025-07-19T18:21:48Z",
      "url": "https://github.com/scrapy/scrapy/pull/6940#discussion_r2217405376"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 6940,
      "file_path": "scrapy/pqueues.py",
      "line": 340,
      "side": "RIGHT",
      "diff_hunk": "@@ -336,6 +336,8 @@ def pop(self) -> Request | None:\n \n     def push(self, request: Request) -> None:\n         slot = self._downloader_interface.get_slot_key(request)\n+        # Handle None slot by converting to string\n+        slot = str(slot)",
      "comment": "> Actually, it's what I said in the description of the PR\r\n\r\nMy bad, I haven't read that before checking the changes :facepalm: \r\n\r\n> This test deliberately creates requests with meta={\"download_slot\": None}\r\n\r\nIndeed. I wonder if the intention was to not set the `\"download_slot\"` key in this case so that `get_slot_key()` uses its default logic. cc @GeorgeA92 \r\n",
      "comment_id": 2224928159,
      "user": "wRAR",
      "created_at": "2025-07-23T09:13:20Z",
      "url": "https://github.com/scrapy/scrapy/pull/6940#discussion_r2224928159"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 6940,
      "file_path": "scrapy/pqueues.py",
      "line": 340,
      "side": "RIGHT",
      "diff_hunk": "@@ -336,6 +336,8 @@ def pop(self) -> Request | None:\n \n     def push(self, request: Request) -> None:\n         slot = self._downloader_interface.get_slot_key(request)\n+        # Handle None slot by converting to string\n+        slot = str(slot)",
      "comment": "Yeah I was not sure how to handle this. Any ideas?",
      "comment_id": 2231955176,
      "user": "thalissonvs",
      "created_at": "2025-07-25T20:29:54Z",
      "url": "https://github.com/scrapy/scrapy/pull/6940#discussion_r2231955176"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 6940,
      "file_path": "scrapy/pqueues.py",
      "line": 340,
      "side": "RIGHT",
      "diff_hunk": "@@ -336,6 +336,8 @@ def pop(self) -> Request | None:\n \n     def push(self, request: Request) -> None:\n         slot = self._downloader_interface.get_slot_key(request)\n+        # Handle None slot by converting to string\n+        slot = str(slot)",
      "comment": "I've rechecked this and I think it's simply an assumption that setting the meta key to None is the same as not setting it, and this assumption is not true: while [the `AutoThrottle` extension behaves in this way](https://github.com/scrapy/scrapy/blob/9bfa58e36ccac20193c2175f3fc55636cd44f585/scrapy/extensions/throttle.py#L99), `Downloader` doesn't, [instead only checking if the key exists](https://github.com/scrapy/scrapy/blob/9bfa58e36ccac20193c2175f3fc55636cd44f585/scrapy/core/downloader/__init__.py#L176).\n\nI think `Downloader` needs to be fixed.",
      "comment_id": 2607894082,
      "user": "wRAR",
      "created_at": "2025-12-10T19:08:51Z",
      "url": "https://github.com/scrapy/scrapy/pull/6940#discussion_r2607894082"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 7161,
      "file_path": "scrapy/utils/signal.py",
      "line": 184,
      "side": "RIGHT",
      "diff_hunk": "@@ -123,9 +143,65 @@ async def send_catch_log_async(\n \n     .. versionadded:: VERSION\n     \"\"\"\n-    return await maybe_deferred_to_future(\n-        send_catch_log_deferred(signal, sender, *arguments, **named)\n+    # note that this returns exceptions instead of Failures in the second tuple member\n+    if is_asyncio_available():\n+        return await _send_catch_log_asyncio(signal, sender, *arguments, **named)\n+    results = await maybe_deferred_to_future(\n+        _send_catch_log_deferred(signal, sender, *arguments, **named)\n     )\n+    return [\n+        (receiver, result.value if isinstance(result, Failure) else result)\n+        for receiver, result in results\n+    ]\n+\n+\n+async def _send_catch_log_asyncio(\n+    signal: TypingAny = Any,\n+    sender: TypingAny = Anonymous,\n+    *arguments: TypingAny,\n+    **named: TypingAny,\n+) -> list[tuple[TypingAny, TypingAny]]:\n+    \"\"\"Like :func:`send_catch_log` but supports :ref:`asynchronous signal handlers\n+    <signal-deferred>`.\n+\n+    Returns a coroutine that completes once all signal handlers have finished.\n+\n+    This function requires\n+    :class:`~twisted.internet.asyncioreactor.AsyncioSelectorReactor` to be\n+    installed.\n+\n+    .. versionadded:: VERSION\n+    \"\"\"\n+    dont_log = named.pop(\"dont_log\", ())\n+    dont_log = tuple(dont_log) if isinstance(dont_log, Sequence) else (dont_log,)\n+    spider = named.get(\"spider\")\n+    handlers: list[Awaitable[TypingAny]] = []\n+    for receiver in liveReceivers(getAllReceivers(sender, signal)):\n+\n+        async def handler(receiver: Callable) -> TypingAny:\n+            result: TypingAny\n+            try:\n+                # TODO _warn",
      "comment": "It is merged now, do you want to address (just remove the comment?) this to-do before merging?",
      "comment_id": 2605874847,
      "user": "Gallaecio",
      "created_at": "2025-12-10T09:30:57Z",
      "url": "https://github.com/scrapy/scrapy/pull/7161#discussion_r2605874847"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 7039,
      "file_path": "scrapy/downloadermiddlewares/redirect.py",
      "line": 157,
      "side": "RIGHT",
      "diff_hunk": "@@ -150,11 +154,17 @@ class RedirectMiddleware(BaseRedirectMiddleware):\n     def process_response(\n         self, request: Request, response: Response, spider: Spider | None = None\n     ) -> Request | Response:\n+        if hasattr(self.crawler.spider, \"handle_httpstatus_list\"):",
      "comment": "This check uses `self.crawler.spider` but there's no guarantee that `self.crawler.spider` exists at this point. The method parameter `spider` should be used instead for consistency with other parts of the codebase.",
      "comment_id": 2317733724,
      "user": "Copilot",
      "created_at": "2025-09-03T04:35:00Z",
      "url": "https://github.com/scrapy/scrapy/pull/7039#discussion_r2317733724"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 7039,
      "file_path": "scrapy/spidermiddlewares/httperror.py",
      "line": 46,
      "side": "RIGHT",
      "diff_hunk": "@@ -40,9 +40,10 @@ class HttpErrorMiddleware:\n \n     def __init__(self, settings: BaseSettings):\n         self.handle_httpstatus_all: bool = settings.getbool(\"HTTPERROR_ALLOW_ALL\")\n-        self.handle_httpstatus_list: list[int] = settings.getlist(\n-            \"HTTPERROR_ALLOWED_CODES\"\n-        )\n+        self.handle_httpstatus_list: list[int] = [\n+            *settings.getlist(\"HTTPERROR_ALLOWED_CODES\"),\n+            *settings.getlist(\"REDIRECT_ALLOWED_HTTP_CODES\"),\n+        ]",
      "comment": "[nitpick] Combining HTTPERROR_ALLOWED_CODES and REDIRECT_ALLOWED_HTTP_CODES into the same list may lead to confusion since these settings serve different purposes. Consider documenting this behavior or keeping them separate to maintain clarity about their distinct roles.\n```suggestion\n        # Only HTTPERROR_ALLOWED_CODES are used here, as this middleware is responsible\n        # for handling HTTP error codes, not redirect codes.\n        self.handle_httpstatus_list: list[int] = settings.getlist(\"HTTPERROR_ALLOWED_CODES\")\n```",
      "comment_id": 2317733732,
      "user": "Copilot",
      "created_at": "2025-09-03T04:35:00Z",
      "url": "https://github.com/scrapy/scrapy/pull/7039#discussion_r2317733732"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 7039,
      "file_path": "scrapy/spidermiddlewares/httperror.py",
      "line": 46,
      "side": "RIGHT",
      "diff_hunk": "@@ -40,9 +40,10 @@ class HttpErrorMiddleware:\n \n     def __init__(self, settings: BaseSettings):\n         self.handle_httpstatus_all: bool = settings.getbool(\"HTTPERROR_ALLOW_ALL\")\n-        self.handle_httpstatus_list: list[int] = settings.getlist(\n-            \"HTTPERROR_ALLOWED_CODES\"\n-        )\n+        self.handle_httpstatus_list: list[int] = [\n+            *settings.getlist(\"HTTPERROR_ALLOWED_CODES\"),\n+            *settings.getlist(\"REDIRECT_ALLOWED_HTTP_CODES\"),\n+        ]",
      "comment": "We already have `HTTPERROR_ALLOWED_CODES` that override `handle_httpstatus_list` but the setting name is not generic `HTTPERROR_`, we could use on `RedirectMiddleware` instead of creating a new setting.",
      "comment_id": 2317735734,
      "user": "Laerte",
      "created_at": "2025-09-03T04:36:47Z",
      "url": "https://github.com/scrapy/scrapy/pull/7039#discussion_r2317735734"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 7039,
      "file_path": "scrapy/downloadermiddlewares/redirect.py",
      "line": 157,
      "side": "RIGHT",
      "diff_hunk": "@@ -150,11 +154,17 @@ class RedirectMiddleware(BaseRedirectMiddleware):\n     def process_response(\n         self, request: Request, response: Response, spider: Spider | None = None\n     ) -> Request | Response:\n+        if hasattr(self.crawler.spider, \"handle_httpstatus_list\"):",
      "comment": "Tbh I was not sure why we not use the `spider` from the function args  on line 165 so I followed what was already used.",
      "comment_id": 2317738177,
      "user": "Laerte",
      "created_at": "2025-09-03T04:38:50Z",
      "url": "https://github.com/scrapy/scrapy/pull/7039#discussion_r2317738177"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 7039,
      "file_path": "scrapy/spidermiddlewares/httperror.py",
      "line": 46,
      "side": "RIGHT",
      "diff_hunk": "@@ -40,9 +40,10 @@ class HttpErrorMiddleware:\n \n     def __init__(self, settings: BaseSettings):\n         self.handle_httpstatus_all: bool = settings.getbool(\"HTTPERROR_ALLOW_ALL\")\n-        self.handle_httpstatus_list: list[int] = settings.getlist(\n-            \"HTTPERROR_ALLOWED_CODES\"\n-        )\n+        self.handle_httpstatus_list: list[int] = [\n+            *settings.getlist(\"HTTPERROR_ALLOWED_CODES\"),\n+            *settings.getlist(\"REDIRECT_ALLOWED_HTTP_CODES\"),\n+        ]",
      "comment": "Right, `handle_httpstatus_list` (the spider attr and the meta key) are mostly for `HttpErrorMiddleware`, `RedirectMiddleware` is their additional user. Similarly for `HTTPERROR_ALLOW_ALL` (the setting) and `handle_httpstatus_all` (the spider attr and the meta key). But out of these `RedirectMiddleware` only uses both meta keys and the `handle_httpstatus_list` spider attr, not using the spider attr and the setting for `all`. This is inconsistent (though I haven't considered what will the spider behavior be if this made consistent).",
      "comment_id": 2318229687,
      "user": "wRAR",
      "created_at": "2025-09-03T08:39:42Z",
      "url": "https://github.com/scrapy/scrapy/pull/7039#discussion_r2318229687"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 7039,
      "file_path": "tests/test_extension_throttle.py",
      "line": 136,
      "side": "LEFT",
      "diff_hunk": "@@ -103,56 +95,6 @@ def test_maxdelay_definition(value, expected):\n     assert at.maxdelay == expected\n \n \n-@pytest.mark.parametrize(\n-    (\"min_spider\", \"min_setting\", \"start_setting\", \"expected\"),\n-    [\n-        (UNSET, UNSET, UNSET, AUTOTHROTTLE_START_DELAY),\n-        (AUTOTHROTTLE_START_DELAY - 1.0, UNSET, UNSET, AUTOTHROTTLE_START_DELAY),\n-        (AUTOTHROTTLE_START_DELAY + 1.0, UNSET, UNSET, AUTOTHROTTLE_START_DELAY + 1.0),\n-        (UNSET, AUTOTHROTTLE_START_DELAY - 1.0, UNSET, AUTOTHROTTLE_START_DELAY),\n-        (UNSET, AUTOTHROTTLE_START_DELAY + 1.0, UNSET, AUTOTHROTTLE_START_DELAY + 1.0),\n-        (UNSET, UNSET, AUTOTHROTTLE_START_DELAY - 1.0, AUTOTHROTTLE_START_DELAY - 1.0),\n-        (UNSET, UNSET, AUTOTHROTTLE_START_DELAY + 1.0, AUTOTHROTTLE_START_DELAY + 1.0),\n-        (\n-            AUTOTHROTTLE_START_DELAY + 1.0,\n-            AUTOTHROTTLE_START_DELAY + 2.0,\n-            UNSET,\n-            AUTOTHROTTLE_START_DELAY + 1.0,\n-        ),\n-        (\n-            AUTOTHROTTLE_START_DELAY + 2.0,\n-            UNSET,\n-            AUTOTHROTTLE_START_DELAY + 1.0,\n-            AUTOTHROTTLE_START_DELAY + 2.0,\n-        ),\n-        (\n-            AUTOTHROTTLE_START_DELAY + 1.0,\n-            UNSET,\n-            AUTOTHROTTLE_START_DELAY + 2.0,\n-            AUTOTHROTTLE_START_DELAY + 2.0,\n-        ),\n-    ],\n-)\n-def test_startdelay_definition(min_spider, min_setting, start_setting, expected):",
      "comment": "Is this test useless/duplicate without `min_spider`?",
      "comment_id": 2347472334,
      "user": "wRAR",
      "created_at": "2025-09-14T18:03:20Z",
      "url": "https://github.com/scrapy/scrapy/pull/7039#discussion_r2347472334"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 7039,
      "file_path": "tests/test_extension_throttle.py",
      "line": 136,
      "side": "LEFT",
      "diff_hunk": "@@ -103,56 +95,6 @@ def test_maxdelay_definition(value, expected):\n     assert at.maxdelay == expected\n \n \n-@pytest.mark.parametrize(\n-    (\"min_spider\", \"min_setting\", \"start_setting\", \"expected\"),\n-    [\n-        (UNSET, UNSET, UNSET, AUTOTHROTTLE_START_DELAY),\n-        (AUTOTHROTTLE_START_DELAY - 1.0, UNSET, UNSET, AUTOTHROTTLE_START_DELAY),\n-        (AUTOTHROTTLE_START_DELAY + 1.0, UNSET, UNSET, AUTOTHROTTLE_START_DELAY + 1.0),\n-        (UNSET, AUTOTHROTTLE_START_DELAY - 1.0, UNSET, AUTOTHROTTLE_START_DELAY),\n-        (UNSET, AUTOTHROTTLE_START_DELAY + 1.0, UNSET, AUTOTHROTTLE_START_DELAY + 1.0),\n-        (UNSET, UNSET, AUTOTHROTTLE_START_DELAY - 1.0, AUTOTHROTTLE_START_DELAY - 1.0),\n-        (UNSET, UNSET, AUTOTHROTTLE_START_DELAY + 1.0, AUTOTHROTTLE_START_DELAY + 1.0),\n-        (\n-            AUTOTHROTTLE_START_DELAY + 1.0,\n-            AUTOTHROTTLE_START_DELAY + 2.0,\n-            UNSET,\n-            AUTOTHROTTLE_START_DELAY + 1.0,\n-        ),\n-        (\n-            AUTOTHROTTLE_START_DELAY + 2.0,\n-            UNSET,\n-            AUTOTHROTTLE_START_DELAY + 1.0,\n-            AUTOTHROTTLE_START_DELAY + 2.0,\n-        ),\n-        (\n-            AUTOTHROTTLE_START_DELAY + 1.0,\n-            UNSET,\n-            AUTOTHROTTLE_START_DELAY + 2.0,\n-            AUTOTHROTTLE_START_DELAY + 2.0,\n-        ),\n-    ],\n-)\n-def test_startdelay_definition(min_spider, min_setting, start_setting, expected):",
      "comment": "It seems, if you see the only assert is: `assert spider.download_delay == expected` lmk if you want to keep and drop the `min_spider` no sure what we would check in this case.",
      "comment_id": 2347492895,
      "user": "Laerte",
      "created_at": "2025-09-14T18:27:50Z",
      "url": "https://github.com/scrapy/scrapy/pull/7039#discussion_r2347492895"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 7039,
      "file_path": "tests/test_extension_throttle.py",
      "line": 136,
      "side": "LEFT",
      "diff_hunk": "@@ -103,56 +95,6 @@ def test_maxdelay_definition(value, expected):\n     assert at.maxdelay == expected\n \n \n-@pytest.mark.parametrize(\n-    (\"min_spider\", \"min_setting\", \"start_setting\", \"expected\"),\n-    [\n-        (UNSET, UNSET, UNSET, AUTOTHROTTLE_START_DELAY),\n-        (AUTOTHROTTLE_START_DELAY - 1.0, UNSET, UNSET, AUTOTHROTTLE_START_DELAY),\n-        (AUTOTHROTTLE_START_DELAY + 1.0, UNSET, UNSET, AUTOTHROTTLE_START_DELAY + 1.0),\n-        (UNSET, AUTOTHROTTLE_START_DELAY - 1.0, UNSET, AUTOTHROTTLE_START_DELAY),\n-        (UNSET, AUTOTHROTTLE_START_DELAY + 1.0, UNSET, AUTOTHROTTLE_START_DELAY + 1.0),\n-        (UNSET, UNSET, AUTOTHROTTLE_START_DELAY - 1.0, AUTOTHROTTLE_START_DELAY - 1.0),\n-        (UNSET, UNSET, AUTOTHROTTLE_START_DELAY + 1.0, AUTOTHROTTLE_START_DELAY + 1.0),\n-        (\n-            AUTOTHROTTLE_START_DELAY + 1.0,\n-            AUTOTHROTTLE_START_DELAY + 2.0,\n-            UNSET,\n-            AUTOTHROTTLE_START_DELAY + 1.0,\n-        ),\n-        (\n-            AUTOTHROTTLE_START_DELAY + 2.0,\n-            UNSET,\n-            AUTOTHROTTLE_START_DELAY + 1.0,\n-            AUTOTHROTTLE_START_DELAY + 2.0,\n-        ),\n-        (\n-            AUTOTHROTTLE_START_DELAY + 1.0,\n-            UNSET,\n-            AUTOTHROTTLE_START_DELAY + 2.0,\n-            AUTOTHROTTLE_START_DELAY + 2.0,\n-        ),\n-    ],\n-)\n-def test_startdelay_definition(min_spider, min_setting, start_setting, expected):",
      "comment": "OK, this is stupid :)\n\nThe extension sets `spider.download_delay` in `_spider_opened()` (based on `AUTOTHROTTLE_START_DELAY`, `DOWNLOAD_DELAY` and the original value of `spider.download_delay`, just like the params of this test), so that the downloader could use it as the start delay value for newly created slots in `scrapy.core.downloader._get_concurrency_delay()`. So if we want to stop using `spider.download_delay` we need this to work in some other way (and I don't think we can change the `DOWNLOAD_DELAY` setting value here).\n\n@Gallaecio thoughts?",
      "comment_id": 2347509223,
      "user": "wRAR",
      "created_at": "2025-09-14T18:57:02Z",
      "url": "https://github.com/scrapy/scrapy/pull/7039#discussion_r2347509223"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 7039,
      "file_path": "scrapy/core/downloader/handlers/http11.py",
      "line": 101,
      "side": "RIGHT",
      "diff_hunk": "@@ -92,6 +93,13 @@ def from_crawler(cls, crawler: Crawler) -> Self:\n \n     def download_request(self, request: Request, spider: Spider) -> Deferred[Response]:\n         \"\"\"Return a deferred for the HTTP download\"\"\"\n+        if hasattr(spider, \"download_maxsize\"):\n+            warn_on_deprecated_spider_attribute(\"download_maxsize\", \"DOWNLOAD_MAXSIZE\")\n+        if hasattr(spider, \"download_warnsize\"):\n+            warn_on_deprecated_spider_attribute(\n+                \"download_warnsize\", \"DOWNLOAD_WARNSIZE\"\n+            )",
      "comment": "I wonder if we should try to find a way to trigger this only once per spider, but no strong opinion. Maybe louder is better :slightly_smiling_face: ",
      "comment_id": 2405773111,
      "user": "Gallaecio",
      "created_at": "2025-10-06T11:18:33Z",
      "url": "https://github.com/scrapy/scrapy/pull/7039#discussion_r2405773111"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 7039,
      "file_path": "scrapy/downloadermiddlewares/redirect.py",
      "line": 167,
      "side": "RIGHT",
      "diff_hunk": "@@ -150,11 +154,17 @@ class RedirectMiddleware(BaseRedirectMiddleware):\n     def process_response(\n         self, request: Request, response: Response, spider: Spider | None = None\n     ) -> Request | Response:\n+        if hasattr(self.crawler.spider, \"handle_httpstatus_list\"):\n+            warn_on_deprecated_spider_attribute(\n+                \"handle_httpstatus_list\", \"REDIRECT_ALLOWED_HTTP_CODES\"\n+            )\n+\n         if (\n             request.meta.get(\"dont_redirect\", False)\n             or response.status\n             in getattr(self.crawler.spider, \"handle_httpstatus_list\", [])\n             or response.status in request.meta.get(\"handle_httpstatus_list\", [])\n+            or response.status in self.handle_httpstatus_list",
      "comment": "I wonder if we should handle this somewhat differently.\r\n\r\ni.e., when both the setting and the spider attribute are defined, the spider attribute, even if deprecated, should be considered an override of the setting value, and the setting value should be ignored.\r\n\r\nIn fact, I wonder if we should also consider the meta value an override of both the setting and the spider attribute, and hence ignore those if the meta value is set. But I am fine with keeping that out of scope here.\r\n\r\nEither way, we should make sure we clarify this in the docs and the release notes.",
      "comment_id": 2405804071,
      "user": "Gallaecio",
      "created_at": "2025-10-06T11:23:52Z",
      "url": "https://github.com/scrapy/scrapy/pull/7039#discussion_r2405804071"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 7039,
      "file_path": "scrapy/spidermiddlewares/httperror.py",
      "line": 46,
      "side": "RIGHT",
      "diff_hunk": "@@ -40,9 +40,10 @@ class HttpErrorMiddleware:\n \n     def __init__(self, settings: BaseSettings):\n         self.handle_httpstatus_all: bool = settings.getbool(\"HTTPERROR_ALLOW_ALL\")\n-        self.handle_httpstatus_list: list[int] = settings.getlist(\n-            \"HTTPERROR_ALLOWED_CODES\"\n-        )\n+        self.handle_httpstatus_list: list[int] = [\n+            *settings.getlist(\"HTTPERROR_ALLOWED_CODES\"),\n+            *settings.getlist(\"REDIRECT_ALLOWED_HTTP_CODES\"),\n+        ]",
      "comment": "I don\u2019t like the HTTP errors middleware reading the `REDIRECT_ALLOWED_HTTP_CODES` setting\u2026\r\n\r\nI wonder if we should take a step back and try to think through what the ideal \u201csettings and meta API\u201d should be, and then try to move towards it in a backward-compatible way with deprecations where needed.\r\n\r\nI feel this should be similar to dont_filter, where you have a generic setting/meta and a specific setting/meta (e.g. allow_offsite). I think the specific should override the generic, i.e. no merging, e.g. if generic is [401] and want to extend with 402 for a specific middleware, you set the specific setting/meta to [401,402], not just [402]. But I am not completely sure.",
      "comment_id": 2405882627,
      "user": "Gallaecio",
      "created_at": "2025-10-06T11:42:08Z",
      "url": "https://github.com/scrapy/scrapy/pull/7039#discussion_r2405882627"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 7039,
      "file_path": "tests/test_extension_throttle.py",
      "line": 136,
      "side": "LEFT",
      "diff_hunk": "@@ -103,56 +95,6 @@ def test_maxdelay_definition(value, expected):\n     assert at.maxdelay == expected\n \n \n-@pytest.mark.parametrize(\n-    (\"min_spider\", \"min_setting\", \"start_setting\", \"expected\"),\n-    [\n-        (UNSET, UNSET, UNSET, AUTOTHROTTLE_START_DELAY),\n-        (AUTOTHROTTLE_START_DELAY - 1.0, UNSET, UNSET, AUTOTHROTTLE_START_DELAY),\n-        (AUTOTHROTTLE_START_DELAY + 1.0, UNSET, UNSET, AUTOTHROTTLE_START_DELAY + 1.0),\n-        (UNSET, AUTOTHROTTLE_START_DELAY - 1.0, UNSET, AUTOTHROTTLE_START_DELAY),\n-        (UNSET, AUTOTHROTTLE_START_DELAY + 1.0, UNSET, AUTOTHROTTLE_START_DELAY + 1.0),\n-        (UNSET, UNSET, AUTOTHROTTLE_START_DELAY - 1.0, AUTOTHROTTLE_START_DELAY - 1.0),\n-        (UNSET, UNSET, AUTOTHROTTLE_START_DELAY + 1.0, AUTOTHROTTLE_START_DELAY + 1.0),\n-        (\n-            AUTOTHROTTLE_START_DELAY + 1.0,\n-            AUTOTHROTTLE_START_DELAY + 2.0,\n-            UNSET,\n-            AUTOTHROTTLE_START_DELAY + 1.0,\n-        ),\n-        (\n-            AUTOTHROTTLE_START_DELAY + 2.0,\n-            UNSET,\n-            AUTOTHROTTLE_START_DELAY + 1.0,\n-            AUTOTHROTTLE_START_DELAY + 2.0,\n-        ),\n-        (\n-            AUTOTHROTTLE_START_DELAY + 1.0,\n-            UNSET,\n-            AUTOTHROTTLE_START_DELAY + 2.0,\n-            AUTOTHROTTLE_START_DELAY + 2.0,\n-        ),\n-    ],\n-)\n-def test_startdelay_definition(min_spider, min_setting, start_setting, expected):",
      "comment": "Maybe we should keep download_delay until https://github.com/scrapy/scrapy/issues/6660 is addressed?",
      "comment_id": 2405896875,
      "user": "Gallaecio",
      "created_at": "2025-10-06T11:47:21Z",
      "url": "https://github.com/scrapy/scrapy/pull/7039#discussion_r2405896875"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 7039,
      "file_path": "tests/test_extension_throttle.py",
      "line": 136,
      "side": "LEFT",
      "diff_hunk": "@@ -103,56 +95,6 @@ def test_maxdelay_definition(value, expected):\n     assert at.maxdelay == expected\n \n \n-@pytest.mark.parametrize(\n-    (\"min_spider\", \"min_setting\", \"start_setting\", \"expected\"),\n-    [\n-        (UNSET, UNSET, UNSET, AUTOTHROTTLE_START_DELAY),\n-        (AUTOTHROTTLE_START_DELAY - 1.0, UNSET, UNSET, AUTOTHROTTLE_START_DELAY),\n-        (AUTOTHROTTLE_START_DELAY + 1.0, UNSET, UNSET, AUTOTHROTTLE_START_DELAY + 1.0),\n-        (UNSET, AUTOTHROTTLE_START_DELAY - 1.0, UNSET, AUTOTHROTTLE_START_DELAY),\n-        (UNSET, AUTOTHROTTLE_START_DELAY + 1.0, UNSET, AUTOTHROTTLE_START_DELAY + 1.0),\n-        (UNSET, UNSET, AUTOTHROTTLE_START_DELAY - 1.0, AUTOTHROTTLE_START_DELAY - 1.0),\n-        (UNSET, UNSET, AUTOTHROTTLE_START_DELAY + 1.0, AUTOTHROTTLE_START_DELAY + 1.0),\n-        (\n-            AUTOTHROTTLE_START_DELAY + 1.0,\n-            AUTOTHROTTLE_START_DELAY + 2.0,\n-            UNSET,\n-            AUTOTHROTTLE_START_DELAY + 1.0,\n-        ),\n-        (\n-            AUTOTHROTTLE_START_DELAY + 2.0,\n-            UNSET,\n-            AUTOTHROTTLE_START_DELAY + 1.0,\n-            AUTOTHROTTLE_START_DELAY + 2.0,\n-        ),\n-        (\n-            AUTOTHROTTLE_START_DELAY + 1.0,\n-            UNSET,\n-            AUTOTHROTTLE_START_DELAY + 2.0,\n-            AUTOTHROTTLE_START_DELAY + 2.0,\n-        ),\n-    ],\n-)\n-def test_startdelay_definition(min_spider, min_setting, start_setting, expected):",
      "comment": "I'm fine with keeping it. Note that we need to revert a part of #6994 before the next release for this: #7117",
      "comment_id": 2405903806,
      "user": "wRAR",
      "created_at": "2025-10-06T11:49:59Z",
      "url": "https://github.com/scrapy/scrapy/pull/7039#discussion_r2405903806"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 7039,
      "file_path": "scrapy/utils/deprecate.py",
      "line": 230,
      "side": "RIGHT",
      "diff_hunk": "@@ -219,3 +219,13 @@ def argument_is_required(func: Callable[..., Any], arg_name: str) -> bool:\n     args = get_func_args_dict(func)\n     param = args.get(arg_name)\n     return param is not None and param.default is inspect.Parameter.empty\n+\n+\n+def warn_on_deprecated_spider_attribute(attribute_name: str, setting_name: str) -> None:\n+    warnings.warn(\n+        f\"The '{attribute_name}' spider attribute is deprecated. \"\n+        \"Use Spider.custom_settings or Spider.update_settings() instead. \"\n+        f\"The corresponding setting name is '{setting_name}'.\",\n+        category=ScrapyDeprecationWarning,\n+        stacklevel=2,",
      "comment": "[nitpick] The hardcoded `stacklevel=2` may not be appropriate for all call sites. Consider making `stacklevel` a parameter with a default value of 2, allowing callers to adjust when the warning is issued from a different depth in the call stack.\n```suggestion\ndef warn_on_deprecated_spider_attribute(attribute_name: str, setting_name: str, stacklevel: int = 2) -> None:\n    warnings.warn(\n        f\"The '{attribute_name}' spider attribute is deprecated. \"\n        \"Use Spider.custom_settings or Spider.update_settings() instead. \"\n        f\"The corresponding setting name is '{setting_name}'.\",\n        category=ScrapyDeprecationWarning,\n        stacklevel=stacklevel,\n```",
      "comment_id": 2574609827,
      "user": "Copilot",
      "created_at": "2025-11-30T19:23:05Z",
      "url": "https://github.com/scrapy/scrapy/pull/7039#discussion_r2574609827"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 7039,
      "file_path": "tests/test_downloader_handlers_http_base.py",
      "line": 508,
      "side": "RIGHT",
      "diff_hunk": "@@ -506,23 +505,23 @@ async def test_download_with_maxsize_per_req(\n             await download_request(download_handler, request)\n \n     @deferred_f_from_coro_f\n-    async def test_download_with_small_maxsize_per_spider(\n-        self, mockserver: MockServer, download_handler: DownloadHandlerProtocol\n+    async def test_download_with_small_maxsize_via_setting(",
      "comment": "[nitpick] The test names changed from `per_spider` to `via_setting`, but these names could be more descriptive. Consider `test_download_maxsize_setting_blocks_small_response` and `test_download_maxsize_setting_allows_large_response` to better convey what each test validates.",
      "comment_id": 2574609842,
      "user": "Copilot",
      "created_at": "2025-11-30T19:23:05Z",
      "url": "https://github.com/scrapy/scrapy/pull/7039#discussion_r2574609842"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 7039,
      "file_path": "tests/test_downloader_handlers_http_base.py",
      "line": 518,
      "side": "RIGHT",
      "diff_hunk": "@@ -506,23 +505,23 @@ async def test_download_with_maxsize_per_req(\n             await download_request(download_handler, request)\n \n     @deferred_f_from_coro_f\n-    async def test_download_with_small_maxsize_per_spider(\n-        self, mockserver: MockServer, download_handler: DownloadHandlerProtocol\n+    async def test_download_with_small_maxsize_via_setting(\n+        self, mockserver: MockServer\n     ) -> None:\n+        crawler = get_crawler(settings_dict={\"DOWNLOAD_MAXSIZE\": 2})\n+        download_handler = build_from_crawler(self.download_handler_cls, crawler)\n         request = Request(mockserver.url(\"/text\", is_secure=self.is_secure))\n         with pytest.raises((defer.CancelledError, error.ConnectionAborted)):\n-            await download_request(\n-                download_handler, request, Spider(\"foo\", download_maxsize=2)\n-            )\n+            await download_request(download_handler, request, Spider(\"foo\"))\n \n     @deferred_f_from_coro_f\n-    async def test_download_with_large_maxsize_per_spider(\n-        self, mockserver: MockServer, download_handler: DownloadHandlerProtocol\n+    async def test_download_with_large_maxsize_via_setting(",
      "comment": "[nitpick] The test names changed from `per_spider` to `via_setting`, but these names could be more descriptive. Consider `test_download_maxsize_setting_blocks_small_response` and `test_download_maxsize_setting_allows_large_response` to better convey what each test validates.",
      "comment_id": 2574609853,
      "user": "Copilot",
      "created_at": "2025-11-30T19:23:06Z",
      "url": "https://github.com/scrapy/scrapy/pull/7039#discussion_r2574609853"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 7134,
      "file_path": "scrapy/downloadermiddlewares/httpcompression.py",
      "line": 37,
      "side": "LEFT",
      "diff_hunk": "@@ -31,14 +31,20 @@\n ACCEPTED_ENCODINGS: list[bytes] = [b\"gzip\", b\"deflate\"]\n \n try:\n-    try:\n-        import brotli  # noqa: F401\n-    except ImportError:\n-        import brotlicffi  # noqa: F401",
      "comment": "I think we can restore brotlicffi compatibility after https://github.com/python-hyper/brotlicffi/pull/207 is released, but it's fine to drop it now.",
      "comment_id": 2522897971,
      "user": "kmike",
      "created_at": "2025-11-13T10:42:00Z",
      "url": "https://github.com/scrapy/scrapy/pull/7134#discussion_r2522897971"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 7134,
      "file_path": "scrapy/utils/_compression.py",
      "line": 69,
      "side": "RIGHT",
      "diff_hunk": "@@ -46,62 +13,64 @@ def _brotli_decompress(decompressor, data):\n \n \n class _DecompressionMaxSizeExceeded(ValueError):\n-    pass\n+    def __init__(self, decompressed_size: int, max_size: int) -> None:\n+        self.decompressed_size = decompressed_size\n+        self.max_size = max_size\n+\n+    def __str__(self) -> str:\n+        return (\n+            f\"The number of bytes decompressed so far \"\n+            f\"({self.decompressed_size} B) exceeded the specified maximum \"\n+            f\"({self.max_size} B).\"\n+        )\n+\n+\n+def _check_max_size(decompressed_size: int, max_size: int) -> None:\n+    if max_size and decompressed_size > max_size:\n+        raise _DecompressionMaxSizeExceeded(decompressed_size, max_size)\n \n \n def _inflate(data: bytes, *, max_size: int = 0) -> bytes:\n     decompressor = zlib.decompressobj()\n-    raw_decompressor = zlib.decompressobj(wbits=-15)\n-    input_stream = BytesIO(data)\n+    try:\n+        first_chunk = decompressor.decompress(data, max_length=_CHUNK_SIZE)\n+    except zlib.error:\n+        # to work with raw deflate content that may be sent by microsoft servers.\n+        decompressor = zlib.decompressobj(wbits=-15)\n+        first_chunk = decompressor.decompress(data, max_length=_CHUNK_SIZE)\n+    decompressed_size = len(first_chunk)\n+    _check_max_size(decompressed_size, max_size)\n     output_stream = BytesIO()\n-    output_chunk = b\".\"\n-    decompressed_size = 0\n-    while output_chunk:\n-        input_chunk = input_stream.read(_CHUNK_SIZE)\n-        try:\n-            output_chunk = decompressor.decompress(input_chunk)\n-        except zlib.error:\n-            if decompressor != raw_decompressor:\n-                # ugly hack to work with raw deflate content that may\n-                # be sent by microsoft servers. For more information, see:\n-                # http://carsten.codimi.de/gzip.yaws/\n-                # http://www.port80software.com/200ok/archive/2005/10/31/868.aspx\n-                # http://www.gzip.org/zlib/zlib_faq.html#faq38\n-                decompressor = raw_decompressor\n-                output_chunk = decompressor.decompress(input_chunk)\n-            else:\n-                raise\n+    output_stream.write(first_chunk)\n+    while decompressor.unconsumed_tail:\n+        output_chunk = decompressor.decompress(\n+            decompressor.unconsumed_tail, max_length=_CHUNK_SIZE\n+        )\n         decompressed_size += len(output_chunk)\n-        if max_size and decompressed_size > max_size:\n-            raise _DecompressionMaxSizeExceeded(\n-                f\"The number of bytes decompressed so far \"\n-                f\"({decompressed_size} B) exceed the specified maximum \"\n-                f\"({max_size} B).\"\n-            )\n+        _check_max_size(decompressed_size, max_size)\n         output_stream.write(output_chunk)\n-    output_stream.seek(0)\n-    return output_stream.read()\n+    if tail := decompressor.flush():\n+        decompressed_size += len(tail)\n+        _check_max_size(decompressed_size, max_size)\n+        output_stream.write(tail)\n+    return output_stream.getvalue()\n \n \n def _unbrotli(data: bytes, *, max_size: int = 0) -> bytes:\n     decompressor = brotli.Decompressor()\n-    input_stream = BytesIO(data)\n+    first_chunk = decompressor.process(data, output_buffer_limit=_CHUNK_SIZE)\n+    decompressed_size = len(first_chunk)\n+    _check_max_size(decompressed_size, max_size)\n     output_stream = BytesIO()\n-    output_chunk = b\".\"\n-    decompressed_size = 0\n-    while output_chunk:\n-        input_chunk = input_stream.read(_CHUNK_SIZE)\n-        output_chunk = _brotli_decompress(decompressor, input_chunk)\n+    output_stream.write(first_chunk)\n+    while not decompressor.is_finished():\n+        output_chunk = decompressor.process(b\"\", output_buffer_limit=_CHUNK_SIZE)\n+        if not output_chunk:\n+            raise ValueError(\"Truncated brotli compressed data\")",
      "comment": "I'm struggling a bit with finding brotli docs; the only link I can find is https://github.com/google/brotli/blob/fa925d0c1559a582d654a9fd2adfd83e317145fa/python/_brotli.c#L143, and it doesn't mention that empty output is an error condition.\r\n\r\nAre there docs or tests which highlight this condition?",
      "comment_id": 2524190084,
      "user": "kmike",
      "created_at": "2025-11-13T16:43:39Z",
      "url": "https://github.com/scrapy/scrapy/pull/7134#discussion_r2524190084"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 7134,
      "file_path": "scrapy/utils/_compression.py",
      "line": 69,
      "side": "RIGHT",
      "diff_hunk": "@@ -46,62 +13,64 @@ def _brotli_decompress(decompressor, data):\n \n \n class _DecompressionMaxSizeExceeded(ValueError):\n-    pass\n+    def __init__(self, decompressed_size: int, max_size: int) -> None:\n+        self.decompressed_size = decompressed_size\n+        self.max_size = max_size\n+\n+    def __str__(self) -> str:\n+        return (\n+            f\"The number of bytes decompressed so far \"\n+            f\"({self.decompressed_size} B) exceeded the specified maximum \"\n+            f\"({self.max_size} B).\"\n+        )\n+\n+\n+def _check_max_size(decompressed_size: int, max_size: int) -> None:\n+    if max_size and decompressed_size > max_size:\n+        raise _DecompressionMaxSizeExceeded(decompressed_size, max_size)\n \n \n def _inflate(data: bytes, *, max_size: int = 0) -> bytes:\n     decompressor = zlib.decompressobj()\n-    raw_decompressor = zlib.decompressobj(wbits=-15)\n-    input_stream = BytesIO(data)\n+    try:\n+        first_chunk = decompressor.decompress(data, max_length=_CHUNK_SIZE)\n+    except zlib.error:\n+        # to work with raw deflate content that may be sent by microsoft servers.\n+        decompressor = zlib.decompressobj(wbits=-15)\n+        first_chunk = decompressor.decompress(data, max_length=_CHUNK_SIZE)\n+    decompressed_size = len(first_chunk)\n+    _check_max_size(decompressed_size, max_size)\n     output_stream = BytesIO()\n-    output_chunk = b\".\"\n-    decompressed_size = 0\n-    while output_chunk:\n-        input_chunk = input_stream.read(_CHUNK_SIZE)\n-        try:\n-            output_chunk = decompressor.decompress(input_chunk)\n-        except zlib.error:\n-            if decompressor != raw_decompressor:\n-                # ugly hack to work with raw deflate content that may\n-                # be sent by microsoft servers. For more information, see:\n-                # http://carsten.codimi.de/gzip.yaws/\n-                # http://www.port80software.com/200ok/archive/2005/10/31/868.aspx\n-                # http://www.gzip.org/zlib/zlib_faq.html#faq38\n-                decompressor = raw_decompressor\n-                output_chunk = decompressor.decompress(input_chunk)\n-            else:\n-                raise\n+    output_stream.write(first_chunk)\n+    while decompressor.unconsumed_tail:\n+        output_chunk = decompressor.decompress(\n+            decompressor.unconsumed_tail, max_length=_CHUNK_SIZE\n+        )\n         decompressed_size += len(output_chunk)\n-        if max_size and decompressed_size > max_size:\n-            raise _DecompressionMaxSizeExceeded(\n-                f\"The number of bytes decompressed so far \"\n-                f\"({decompressed_size} B) exceed the specified maximum \"\n-                f\"({max_size} B).\"\n-            )\n+        _check_max_size(decompressed_size, max_size)\n         output_stream.write(output_chunk)\n-    output_stream.seek(0)\n-    return output_stream.read()\n+    if tail := decompressor.flush():\n+        decompressed_size += len(tail)\n+        _check_max_size(decompressed_size, max_size)\n+        output_stream.write(tail)\n+    return output_stream.getvalue()\n \n \n def _unbrotli(data: bytes, *, max_size: int = 0) -> bytes:\n     decompressor = brotli.Decompressor()\n-    input_stream = BytesIO(data)\n+    first_chunk = decompressor.process(data, output_buffer_limit=_CHUNK_SIZE)\n+    decompressed_size = len(first_chunk)\n+    _check_max_size(decompressed_size, max_size)\n     output_stream = BytesIO()\n-    output_chunk = b\".\"\n-    decompressed_size = 0\n-    while output_chunk:\n-        input_chunk = input_stream.read(_CHUNK_SIZE)\n-        output_chunk = _brotli_decompress(decompressor, input_chunk)\n+    output_stream.write(first_chunk)\n+    while not decompressor.is_finished():\n+        output_chunk = decompressor.process(b\"\", output_buffer_limit=_CHUNK_SIZE)\n+        if not output_chunk:\n+            raise ValueError(\"Truncated brotli compressed data\")",
      "comment": "Apprently coverage shows this condition is not triggered in our tests.",
      "comment_id": 2524229242,
      "user": "kmike",
      "created_at": "2025-11-13T16:55:16Z",
      "url": "https://github.com/scrapy/scrapy/pull/7134#discussion_r2524229242"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 7134,
      "file_path": "scrapy/utils/_compression.py",
      "line": 69,
      "side": "RIGHT",
      "diff_hunk": "@@ -46,62 +13,64 @@ def _brotli_decompress(decompressor, data):\n \n \n class _DecompressionMaxSizeExceeded(ValueError):\n-    pass\n+    def __init__(self, decompressed_size: int, max_size: int) -> None:\n+        self.decompressed_size = decompressed_size\n+        self.max_size = max_size\n+\n+    def __str__(self) -> str:\n+        return (\n+            f\"The number of bytes decompressed so far \"\n+            f\"({self.decompressed_size} B) exceeded the specified maximum \"\n+            f\"({self.max_size} B).\"\n+        )\n+\n+\n+def _check_max_size(decompressed_size: int, max_size: int) -> None:\n+    if max_size and decompressed_size > max_size:\n+        raise _DecompressionMaxSizeExceeded(decompressed_size, max_size)\n \n \n def _inflate(data: bytes, *, max_size: int = 0) -> bytes:\n     decompressor = zlib.decompressobj()\n-    raw_decompressor = zlib.decompressobj(wbits=-15)\n-    input_stream = BytesIO(data)\n+    try:\n+        first_chunk = decompressor.decompress(data, max_length=_CHUNK_SIZE)\n+    except zlib.error:\n+        # to work with raw deflate content that may be sent by microsoft servers.\n+        decompressor = zlib.decompressobj(wbits=-15)\n+        first_chunk = decompressor.decompress(data, max_length=_CHUNK_SIZE)\n+    decompressed_size = len(first_chunk)\n+    _check_max_size(decompressed_size, max_size)\n     output_stream = BytesIO()\n-    output_chunk = b\".\"\n-    decompressed_size = 0\n-    while output_chunk:\n-        input_chunk = input_stream.read(_CHUNK_SIZE)\n-        try:\n-            output_chunk = decompressor.decompress(input_chunk)\n-        except zlib.error:\n-            if decompressor != raw_decompressor:\n-                # ugly hack to work with raw deflate content that may\n-                # be sent by microsoft servers. For more information, see:\n-                # http://carsten.codimi.de/gzip.yaws/\n-                # http://www.port80software.com/200ok/archive/2005/10/31/868.aspx\n-                # http://www.gzip.org/zlib/zlib_faq.html#faq38\n-                decompressor = raw_decompressor\n-                output_chunk = decompressor.decompress(input_chunk)\n-            else:\n-                raise\n+    output_stream.write(first_chunk)\n+    while decompressor.unconsumed_tail:\n+        output_chunk = decompressor.decompress(\n+            decompressor.unconsumed_tail, max_length=_CHUNK_SIZE\n+        )\n         decompressed_size += len(output_chunk)\n-        if max_size and decompressed_size > max_size:\n-            raise _DecompressionMaxSizeExceeded(\n-                f\"The number of bytes decompressed so far \"\n-                f\"({decompressed_size} B) exceed the specified maximum \"\n-                f\"({max_size} B).\"\n-            )\n+        _check_max_size(decompressed_size, max_size)\n         output_stream.write(output_chunk)\n-    output_stream.seek(0)\n-    return output_stream.read()\n+    if tail := decompressor.flush():\n+        decompressed_size += len(tail)\n+        _check_max_size(decompressed_size, max_size)\n+        output_stream.write(tail)\n+    return output_stream.getvalue()\n \n \n def _unbrotli(data: bytes, *, max_size: int = 0) -> bytes:\n     decompressor = brotli.Decompressor()\n-    input_stream = BytesIO(data)\n+    first_chunk = decompressor.process(data, output_buffer_limit=_CHUNK_SIZE)\n+    decompressed_size = len(first_chunk)\n+    _check_max_size(decompressed_size, max_size)\n     output_stream = BytesIO()\n-    output_chunk = b\".\"\n-    decompressed_size = 0\n-    while output_chunk:\n-        input_chunk = input_stream.read(_CHUNK_SIZE)\n-        output_chunk = _brotli_decompress(decompressor, input_chunk)\n+    output_stream.write(first_chunk)\n+    while not decompressor.is_finished():\n+        output_chunk = decompressor.process(b\"\", output_buffer_limit=_CHUNK_SIZE)\n+        if not output_chunk:\n+            raise ValueError(\"Truncated brotli compressed data\")",
      "comment": "It is also unclear to me. I can only assume that empty output here means brotli has processed all of input data and still \"not finished\"... Or it will be impossible to know when to break the loop if input data is truncated brotli compressed data (in which condition `decompressor.is_finished()` always returns False).",
      "comment_id": 2524296194,
      "user": "Cycloctane",
      "created_at": "2025-11-13T17:16:14Z",
      "url": "https://github.com/scrapy/scrapy/pull/7134#discussion_r2524296194"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 7134,
      "file_path": "scrapy/utils/_compression.py",
      "line": 69,
      "side": "RIGHT",
      "diff_hunk": "@@ -46,62 +13,64 @@ def _brotli_decompress(decompressor, data):\n \n \n class _DecompressionMaxSizeExceeded(ValueError):\n-    pass\n+    def __init__(self, decompressed_size: int, max_size: int) -> None:\n+        self.decompressed_size = decompressed_size\n+        self.max_size = max_size\n+\n+    def __str__(self) -> str:\n+        return (\n+            f\"The number of bytes decompressed so far \"\n+            f\"({self.decompressed_size} B) exceeded the specified maximum \"\n+            f\"({self.max_size} B).\"\n+        )\n+\n+\n+def _check_max_size(decompressed_size: int, max_size: int) -> None:\n+    if max_size and decompressed_size > max_size:\n+        raise _DecompressionMaxSizeExceeded(decompressed_size, max_size)\n \n \n def _inflate(data: bytes, *, max_size: int = 0) -> bytes:\n     decompressor = zlib.decompressobj()\n-    raw_decompressor = zlib.decompressobj(wbits=-15)\n-    input_stream = BytesIO(data)\n+    try:\n+        first_chunk = decompressor.decompress(data, max_length=_CHUNK_SIZE)\n+    except zlib.error:\n+        # to work with raw deflate content that may be sent by microsoft servers.\n+        decompressor = zlib.decompressobj(wbits=-15)\n+        first_chunk = decompressor.decompress(data, max_length=_CHUNK_SIZE)\n+    decompressed_size = len(first_chunk)\n+    _check_max_size(decompressed_size, max_size)\n     output_stream = BytesIO()\n-    output_chunk = b\".\"\n-    decompressed_size = 0\n-    while output_chunk:\n-        input_chunk = input_stream.read(_CHUNK_SIZE)\n-        try:\n-            output_chunk = decompressor.decompress(input_chunk)\n-        except zlib.error:\n-            if decompressor != raw_decompressor:\n-                # ugly hack to work with raw deflate content that may\n-                # be sent by microsoft servers. For more information, see:\n-                # http://carsten.codimi.de/gzip.yaws/\n-                # http://www.port80software.com/200ok/archive/2005/10/31/868.aspx\n-                # http://www.gzip.org/zlib/zlib_faq.html#faq38\n-                decompressor = raw_decompressor\n-                output_chunk = decompressor.decompress(input_chunk)\n-            else:\n-                raise\n+    output_stream.write(first_chunk)\n+    while decompressor.unconsumed_tail:\n+        output_chunk = decompressor.decompress(\n+            decompressor.unconsumed_tail, max_length=_CHUNK_SIZE\n+        )\n         decompressed_size += len(output_chunk)\n-        if max_size and decompressed_size > max_size:\n-            raise _DecompressionMaxSizeExceeded(\n-                f\"The number of bytes decompressed so far \"\n-                f\"({decompressed_size} B) exceed the specified maximum \"\n-                f\"({max_size} B).\"\n-            )\n+        _check_max_size(decompressed_size, max_size)\n         output_stream.write(output_chunk)\n-    output_stream.seek(0)\n-    return output_stream.read()\n+    if tail := decompressor.flush():\n+        decompressed_size += len(tail)\n+        _check_max_size(decompressed_size, max_size)\n+        output_stream.write(tail)\n+    return output_stream.getvalue()\n \n \n def _unbrotli(data: bytes, *, max_size: int = 0) -> bytes:\n     decompressor = brotli.Decompressor()\n-    input_stream = BytesIO(data)\n+    first_chunk = decompressor.process(data, output_buffer_limit=_CHUNK_SIZE)\n+    decompressed_size = len(first_chunk)\n+    _check_max_size(decompressed_size, max_size)\n     output_stream = BytesIO()\n-    output_chunk = b\".\"\n-    decompressed_size = 0\n-    while output_chunk:\n-        input_chunk = input_stream.read(_CHUNK_SIZE)\n-        output_chunk = _brotli_decompress(decompressor, input_chunk)\n+    output_stream.write(first_chunk)\n+    while not decompressor.is_finished():\n+        output_chunk = decompressor.process(b\"\", output_buffer_limit=_CHUNK_SIZE)\n+        if not output_chunk:\n+            raise ValueError(\"Truncated brotli compressed data\")",
      "comment": "Or maybe we should change this to `break` here as other decompress methods do not raise errors if input data is truncated.",
      "comment_id": 2524373046,
      "user": "Cycloctane",
      "created_at": "2025-11-13T17:41:48Z",
      "url": "https://github.com/scrapy/scrapy/pull/7134#discussion_r2524373046"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 7134,
      "file_path": "scrapy/utils/_compression.py",
      "line": 69,
      "side": "RIGHT",
      "diff_hunk": "@@ -46,62 +13,64 @@ def _brotli_decompress(decompressor, data):\n \n \n class _DecompressionMaxSizeExceeded(ValueError):\n-    pass\n+    def __init__(self, decompressed_size: int, max_size: int) -> None:\n+        self.decompressed_size = decompressed_size\n+        self.max_size = max_size\n+\n+    def __str__(self) -> str:\n+        return (\n+            f\"The number of bytes decompressed so far \"\n+            f\"({self.decompressed_size} B) exceeded the specified maximum \"\n+            f\"({self.max_size} B).\"\n+        )\n+\n+\n+def _check_max_size(decompressed_size: int, max_size: int) -> None:\n+    if max_size and decompressed_size > max_size:\n+        raise _DecompressionMaxSizeExceeded(decompressed_size, max_size)\n \n \n def _inflate(data: bytes, *, max_size: int = 0) -> bytes:\n     decompressor = zlib.decompressobj()\n-    raw_decompressor = zlib.decompressobj(wbits=-15)\n-    input_stream = BytesIO(data)\n+    try:\n+        first_chunk = decompressor.decompress(data, max_length=_CHUNK_SIZE)\n+    except zlib.error:\n+        # to work with raw deflate content that may be sent by microsoft servers.\n+        decompressor = zlib.decompressobj(wbits=-15)\n+        first_chunk = decompressor.decompress(data, max_length=_CHUNK_SIZE)\n+    decompressed_size = len(first_chunk)\n+    _check_max_size(decompressed_size, max_size)\n     output_stream = BytesIO()\n-    output_chunk = b\".\"\n-    decompressed_size = 0\n-    while output_chunk:\n-        input_chunk = input_stream.read(_CHUNK_SIZE)\n-        try:\n-            output_chunk = decompressor.decompress(input_chunk)\n-        except zlib.error:\n-            if decompressor != raw_decompressor:\n-                # ugly hack to work with raw deflate content that may\n-                # be sent by microsoft servers. For more information, see:\n-                # http://carsten.codimi.de/gzip.yaws/\n-                # http://www.port80software.com/200ok/archive/2005/10/31/868.aspx\n-                # http://www.gzip.org/zlib/zlib_faq.html#faq38\n-                decompressor = raw_decompressor\n-                output_chunk = decompressor.decompress(input_chunk)\n-            else:\n-                raise\n+    output_stream.write(first_chunk)\n+    while decompressor.unconsumed_tail:\n+        output_chunk = decompressor.decompress(\n+            decompressor.unconsumed_tail, max_length=_CHUNK_SIZE\n+        )\n         decompressed_size += len(output_chunk)\n-        if max_size and decompressed_size > max_size:\n-            raise _DecompressionMaxSizeExceeded(\n-                f\"The number of bytes decompressed so far \"\n-                f\"({decompressed_size} B) exceed the specified maximum \"\n-                f\"({max_size} B).\"\n-            )\n+        _check_max_size(decompressed_size, max_size)\n         output_stream.write(output_chunk)\n-    output_stream.seek(0)\n-    return output_stream.read()\n+    if tail := decompressor.flush():\n+        decompressed_size += len(tail)\n+        _check_max_size(decompressed_size, max_size)\n+        output_stream.write(tail)\n+    return output_stream.getvalue()\n \n \n def _unbrotli(data: bytes, *, max_size: int = 0) -> bytes:\n     decompressor = brotli.Decompressor()\n-    input_stream = BytesIO(data)\n+    first_chunk = decompressor.process(data, output_buffer_limit=_CHUNK_SIZE)\n+    decompressed_size = len(first_chunk)\n+    _check_max_size(decompressed_size, max_size)\n     output_stream = BytesIO()\n-    output_chunk = b\".\"\n-    decompressed_size = 0\n-    while output_chunk:\n-        input_chunk = input_stream.read(_CHUNK_SIZE)\n-        output_chunk = _brotli_decompress(decompressor, input_chunk)\n+    output_stream.write(first_chunk)\n+    while not decompressor.is_finished():\n+        output_chunk = decompressor.process(b\"\", output_buffer_limit=_CHUNK_SIZE)\n+        if not output_chunk:\n+            raise ValueError(\"Truncated brotli compressed data\")",
      "comment": "Previously there was no such check at all in the unbrotli code; it's also an option to omit it now, and rely on `decompressor.is_finished()` not to return False if nothing can be output.\r\n\r\nI think it may be considered a bug in brotli if it allows such infinite loop, i.e. decompressor.is_finished returns False, but decompress keep returning empty data. Do you know if this bug exists?",
      "comment_id": 2524388192,
      "user": "kmike",
      "created_at": "2025-11-13T17:47:27Z",
      "url": "https://github.com/scrapy/scrapy/pull/7134#discussion_r2524388192"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 7134,
      "file_path": "scrapy/utils/_compression.py",
      "line": 69,
      "side": "RIGHT",
      "diff_hunk": "@@ -46,62 +13,64 @@ def _brotli_decompress(decompressor, data):\n \n \n class _DecompressionMaxSizeExceeded(ValueError):\n-    pass\n+    def __init__(self, decompressed_size: int, max_size: int) -> None:\n+        self.decompressed_size = decompressed_size\n+        self.max_size = max_size\n+\n+    def __str__(self) -> str:\n+        return (\n+            f\"The number of bytes decompressed so far \"\n+            f\"({self.decompressed_size} B) exceeded the specified maximum \"\n+            f\"({self.max_size} B).\"\n+        )\n+\n+\n+def _check_max_size(decompressed_size: int, max_size: int) -> None:\n+    if max_size and decompressed_size > max_size:\n+        raise _DecompressionMaxSizeExceeded(decompressed_size, max_size)\n \n \n def _inflate(data: bytes, *, max_size: int = 0) -> bytes:\n     decompressor = zlib.decompressobj()\n-    raw_decompressor = zlib.decompressobj(wbits=-15)\n-    input_stream = BytesIO(data)\n+    try:\n+        first_chunk = decompressor.decompress(data, max_length=_CHUNK_SIZE)\n+    except zlib.error:\n+        # to work with raw deflate content that may be sent by microsoft servers.\n+        decompressor = zlib.decompressobj(wbits=-15)\n+        first_chunk = decompressor.decompress(data, max_length=_CHUNK_SIZE)\n+    decompressed_size = len(first_chunk)\n+    _check_max_size(decompressed_size, max_size)\n     output_stream = BytesIO()\n-    output_chunk = b\".\"\n-    decompressed_size = 0\n-    while output_chunk:\n-        input_chunk = input_stream.read(_CHUNK_SIZE)\n-        try:\n-            output_chunk = decompressor.decompress(input_chunk)\n-        except zlib.error:\n-            if decompressor != raw_decompressor:\n-                # ugly hack to work with raw deflate content that may\n-                # be sent by microsoft servers. For more information, see:\n-                # http://carsten.codimi.de/gzip.yaws/\n-                # http://www.port80software.com/200ok/archive/2005/10/31/868.aspx\n-                # http://www.gzip.org/zlib/zlib_faq.html#faq38\n-                decompressor = raw_decompressor\n-                output_chunk = decompressor.decompress(input_chunk)\n-            else:\n-                raise\n+    output_stream.write(first_chunk)\n+    while decompressor.unconsumed_tail:\n+        output_chunk = decompressor.decompress(\n+            decompressor.unconsumed_tail, max_length=_CHUNK_SIZE\n+        )\n         decompressed_size += len(output_chunk)\n-        if max_size and decompressed_size > max_size:\n-            raise _DecompressionMaxSizeExceeded(\n-                f\"The number of bytes decompressed so far \"\n-                f\"({decompressed_size} B) exceed the specified maximum \"\n-                f\"({max_size} B).\"\n-            )\n+        _check_max_size(decompressed_size, max_size)\n         output_stream.write(output_chunk)\n-    output_stream.seek(0)\n-    return output_stream.read()\n+    if tail := decompressor.flush():\n+        decompressed_size += len(tail)\n+        _check_max_size(decompressed_size, max_size)\n+        output_stream.write(tail)\n+    return output_stream.getvalue()\n \n \n def _unbrotli(data: bytes, *, max_size: int = 0) -> bytes:\n     decompressor = brotli.Decompressor()\n-    input_stream = BytesIO(data)\n+    first_chunk = decompressor.process(data, output_buffer_limit=_CHUNK_SIZE)\n+    decompressed_size = len(first_chunk)\n+    _check_max_size(decompressed_size, max_size)\n     output_stream = BytesIO()\n-    output_chunk = b\".\"\n-    decompressed_size = 0\n-    while output_chunk:\n-        input_chunk = input_stream.read(_CHUNK_SIZE)\n-        output_chunk = _brotli_decompress(decompressor, input_chunk)\n+    output_stream.write(first_chunk)\n+    while not decompressor.is_finished():\n+        output_chunk = decompressor.process(b\"\", output_buffer_limit=_CHUNK_SIZE)\n+        if not output_chunk:\n+            raise ValueError(\"Truncated brotli compressed data\")",
      "comment": "That's right. Without this `if` check, the function will run into infinite loop when processing invalid or truncated data.\r\nBrotli does not provide a explicit method to handle this condition.\r\n",
      "comment_id": 2524411302,
      "user": "Cycloctane",
      "created_at": "2025-11-13T17:56:32Z",
      "url": "https://github.com/scrapy/scrapy/pull/7134#discussion_r2524411302"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 7134,
      "file_path": "scrapy/utils/_compression.py",
      "line": 69,
      "side": "RIGHT",
      "diff_hunk": "@@ -46,62 +13,64 @@ def _brotli_decompress(decompressor, data):\n \n \n class _DecompressionMaxSizeExceeded(ValueError):\n-    pass\n+    def __init__(self, decompressed_size: int, max_size: int) -> None:\n+        self.decompressed_size = decompressed_size\n+        self.max_size = max_size\n+\n+    def __str__(self) -> str:\n+        return (\n+            f\"The number of bytes decompressed so far \"\n+            f\"({self.decompressed_size} B) exceeded the specified maximum \"\n+            f\"({self.max_size} B).\"\n+        )\n+\n+\n+def _check_max_size(decompressed_size: int, max_size: int) -> None:\n+    if max_size and decompressed_size > max_size:\n+        raise _DecompressionMaxSizeExceeded(decompressed_size, max_size)\n \n \n def _inflate(data: bytes, *, max_size: int = 0) -> bytes:\n     decompressor = zlib.decompressobj()\n-    raw_decompressor = zlib.decompressobj(wbits=-15)\n-    input_stream = BytesIO(data)\n+    try:\n+        first_chunk = decompressor.decompress(data, max_length=_CHUNK_SIZE)\n+    except zlib.error:\n+        # to work with raw deflate content that may be sent by microsoft servers.\n+        decompressor = zlib.decompressobj(wbits=-15)\n+        first_chunk = decompressor.decompress(data, max_length=_CHUNK_SIZE)\n+    decompressed_size = len(first_chunk)\n+    _check_max_size(decompressed_size, max_size)\n     output_stream = BytesIO()\n-    output_chunk = b\".\"\n-    decompressed_size = 0\n-    while output_chunk:\n-        input_chunk = input_stream.read(_CHUNK_SIZE)\n-        try:\n-            output_chunk = decompressor.decompress(input_chunk)\n-        except zlib.error:\n-            if decompressor != raw_decompressor:\n-                # ugly hack to work with raw deflate content that may\n-                # be sent by microsoft servers. For more information, see:\n-                # http://carsten.codimi.de/gzip.yaws/\n-                # http://www.port80software.com/200ok/archive/2005/10/31/868.aspx\n-                # http://www.gzip.org/zlib/zlib_faq.html#faq38\n-                decompressor = raw_decompressor\n-                output_chunk = decompressor.decompress(input_chunk)\n-            else:\n-                raise\n+    output_stream.write(first_chunk)\n+    while decompressor.unconsumed_tail:\n+        output_chunk = decompressor.decompress(\n+            decompressor.unconsumed_tail, max_length=_CHUNK_SIZE\n+        )\n         decompressed_size += len(output_chunk)\n-        if max_size and decompressed_size > max_size:\n-            raise _DecompressionMaxSizeExceeded(\n-                f\"The number of bytes decompressed so far \"\n-                f\"({decompressed_size} B) exceed the specified maximum \"\n-                f\"({max_size} B).\"\n-            )\n+        _check_max_size(decompressed_size, max_size)\n         output_stream.write(output_chunk)\n-    output_stream.seek(0)\n-    return output_stream.read()\n+    if tail := decompressor.flush():\n+        decompressed_size += len(tail)\n+        _check_max_size(decompressed_size, max_size)\n+        output_stream.write(tail)\n+    return output_stream.getvalue()\n \n \n def _unbrotli(data: bytes, *, max_size: int = 0) -> bytes:\n     decompressor = brotli.Decompressor()\n-    input_stream = BytesIO(data)\n+    first_chunk = decompressor.process(data, output_buffer_limit=_CHUNK_SIZE)\n+    decompressed_size = len(first_chunk)\n+    _check_max_size(decompressed_size, max_size)\n     output_stream = BytesIO()\n-    output_chunk = b\".\"\n-    decompressed_size = 0\n-    while output_chunk:\n-        input_chunk = input_stream.read(_CHUNK_SIZE)\n-        output_chunk = _brotli_decompress(decompressor, input_chunk)\n+    output_stream.write(first_chunk)\n+    while not decompressor.is_finished():\n+        output_chunk = decompressor.process(b\"\", output_buffer_limit=_CHUNK_SIZE)\n+        if not output_chunk:\n+            raise ValueError(\"Truncated brotli compressed data\")",
      "comment": "> This function will run into infinite loop when processing invalid or truncated data without this if check.\r\n\r\nHow do you know this? Is there some documentation about it, or maybe some example? I assumed that in these cases either brotli would raise an error, or `decompressor.is_finished()` would return True, as other behavior looks more like a bug in brotli library.",
      "comment_id": 2524418681,
      "user": "kmike",
      "created_at": "2025-11-13T17:59:03Z",
      "url": "https://github.com/scrapy/scrapy/pull/7134#discussion_r2524418681"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 7134,
      "file_path": "scrapy/utils/_compression.py",
      "line": 69,
      "side": "RIGHT",
      "diff_hunk": "@@ -46,62 +13,64 @@ def _brotli_decompress(decompressor, data):\n \n \n class _DecompressionMaxSizeExceeded(ValueError):\n-    pass\n+    def __init__(self, decompressed_size: int, max_size: int) -> None:\n+        self.decompressed_size = decompressed_size\n+        self.max_size = max_size\n+\n+    def __str__(self) -> str:\n+        return (\n+            f\"The number of bytes decompressed so far \"\n+            f\"({self.decompressed_size} B) exceeded the specified maximum \"\n+            f\"({self.max_size} B).\"\n+        )\n+\n+\n+def _check_max_size(decompressed_size: int, max_size: int) -> None:\n+    if max_size and decompressed_size > max_size:\n+        raise _DecompressionMaxSizeExceeded(decompressed_size, max_size)\n \n \n def _inflate(data: bytes, *, max_size: int = 0) -> bytes:\n     decompressor = zlib.decompressobj()\n-    raw_decompressor = zlib.decompressobj(wbits=-15)\n-    input_stream = BytesIO(data)\n+    try:\n+        first_chunk = decompressor.decompress(data, max_length=_CHUNK_SIZE)\n+    except zlib.error:\n+        # to work with raw deflate content that may be sent by microsoft servers.\n+        decompressor = zlib.decompressobj(wbits=-15)\n+        first_chunk = decompressor.decompress(data, max_length=_CHUNK_SIZE)\n+    decompressed_size = len(first_chunk)\n+    _check_max_size(decompressed_size, max_size)\n     output_stream = BytesIO()\n-    output_chunk = b\".\"\n-    decompressed_size = 0\n-    while output_chunk:\n-        input_chunk = input_stream.read(_CHUNK_SIZE)\n-        try:\n-            output_chunk = decompressor.decompress(input_chunk)\n-        except zlib.error:\n-            if decompressor != raw_decompressor:\n-                # ugly hack to work with raw deflate content that may\n-                # be sent by microsoft servers. For more information, see:\n-                # http://carsten.codimi.de/gzip.yaws/\n-                # http://www.port80software.com/200ok/archive/2005/10/31/868.aspx\n-                # http://www.gzip.org/zlib/zlib_faq.html#faq38\n-                decompressor = raw_decompressor\n-                output_chunk = decompressor.decompress(input_chunk)\n-            else:\n-                raise\n+    output_stream.write(first_chunk)\n+    while decompressor.unconsumed_tail:\n+        output_chunk = decompressor.decompress(\n+            decompressor.unconsumed_tail, max_length=_CHUNK_SIZE\n+        )\n         decompressed_size += len(output_chunk)\n-        if max_size and decompressed_size > max_size:\n-            raise _DecompressionMaxSizeExceeded(\n-                f\"The number of bytes decompressed so far \"\n-                f\"({decompressed_size} B) exceed the specified maximum \"\n-                f\"({max_size} B).\"\n-            )\n+        _check_max_size(decompressed_size, max_size)\n         output_stream.write(output_chunk)\n-    output_stream.seek(0)\n-    return output_stream.read()\n+    if tail := decompressor.flush():\n+        decompressed_size += len(tail)\n+        _check_max_size(decompressed_size, max_size)\n+        output_stream.write(tail)\n+    return output_stream.getvalue()\n \n \n def _unbrotli(data: bytes, *, max_size: int = 0) -> bytes:\n     decompressor = brotli.Decompressor()\n-    input_stream = BytesIO(data)\n+    first_chunk = decompressor.process(data, output_buffer_limit=_CHUNK_SIZE)\n+    decompressed_size = len(first_chunk)\n+    _check_max_size(decompressed_size, max_size)\n     output_stream = BytesIO()\n-    output_chunk = b\".\"\n-    decompressed_size = 0\n-    while output_chunk:\n-        input_chunk = input_stream.read(_CHUNK_SIZE)\n-        output_chunk = _brotli_decompress(decompressor, input_chunk)\n+    output_stream.write(first_chunk)\n+    while not decompressor.is_finished():\n+        output_chunk = decompressor.process(b\"\", output_buffer_limit=_CHUNK_SIZE)\n+        if not output_chunk:\n+            raise ValueError(\"Truncated brotli compressed data\")",
      "comment": "I figured out this problem when testing the patch by myself. That's why I added this if statement in commit <https://github.com/scrapy/scrapy/pull/7134/commits/0fcb3de18882a37b92bba99ac91fb8be105577b4>. min reproduce:\r\n\r\n```python\r\ndef _unbrotli(data: bytes, *, max_size: int = 0) -> bytes:\r\n    decompressor = brotli.Decompressor()\r\n    first_chunk = decompressor.process(data, output_buffer_limit=_CHUNK_SIZE)\r\n    decompressed_size = len(first_chunk)\r\n    _check_max_size(decompressed_size, max_size)\r\n    output_stream = BytesIO()\r\n    output_stream.write(first_chunk)\r\n    while not decompressor.is_finished():\r\n        output_chunk = decompressor.process(b\"\", output_buffer_limit=_CHUNK_SIZE)\r\n        decompressed_size += len(output_chunk)\r\n        _check_max_size(decompressed_size, max_size)\r\n        output_stream.write(output_chunk)\r\n    return output_stream.getvalue()\r\n\r\nprint(len(_unbrotli(brotli.compress(bytes(1024 * 64))[:-4])))\r\n```\r\n",
      "comment_id": 2524444852,
      "user": "Cycloctane",
      "created_at": "2025-11-13T18:08:39Z",
      "url": "https://github.com/scrapy/scrapy/pull/7134#discussion_r2524444852"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 7134,
      "file_path": "scrapy/utils/_compression.py",
      "line": 69,
      "side": "RIGHT",
      "diff_hunk": "@@ -46,62 +13,64 @@ def _brotli_decompress(decompressor, data):\n \n \n class _DecompressionMaxSizeExceeded(ValueError):\n-    pass\n+    def __init__(self, decompressed_size: int, max_size: int) -> None:\n+        self.decompressed_size = decompressed_size\n+        self.max_size = max_size\n+\n+    def __str__(self) -> str:\n+        return (\n+            f\"The number of bytes decompressed so far \"\n+            f\"({self.decompressed_size} B) exceeded the specified maximum \"\n+            f\"({self.max_size} B).\"\n+        )\n+\n+\n+def _check_max_size(decompressed_size: int, max_size: int) -> None:\n+    if max_size and decompressed_size > max_size:\n+        raise _DecompressionMaxSizeExceeded(decompressed_size, max_size)\n \n \n def _inflate(data: bytes, *, max_size: int = 0) -> bytes:\n     decompressor = zlib.decompressobj()\n-    raw_decompressor = zlib.decompressobj(wbits=-15)\n-    input_stream = BytesIO(data)\n+    try:\n+        first_chunk = decompressor.decompress(data, max_length=_CHUNK_SIZE)\n+    except zlib.error:\n+        # to work with raw deflate content that may be sent by microsoft servers.\n+        decompressor = zlib.decompressobj(wbits=-15)\n+        first_chunk = decompressor.decompress(data, max_length=_CHUNK_SIZE)\n+    decompressed_size = len(first_chunk)\n+    _check_max_size(decompressed_size, max_size)\n     output_stream = BytesIO()\n-    output_chunk = b\".\"\n-    decompressed_size = 0\n-    while output_chunk:\n-        input_chunk = input_stream.read(_CHUNK_SIZE)\n-        try:\n-            output_chunk = decompressor.decompress(input_chunk)\n-        except zlib.error:\n-            if decompressor != raw_decompressor:\n-                # ugly hack to work with raw deflate content that may\n-                # be sent by microsoft servers. For more information, see:\n-                # http://carsten.codimi.de/gzip.yaws/\n-                # http://www.port80software.com/200ok/archive/2005/10/31/868.aspx\n-                # http://www.gzip.org/zlib/zlib_faq.html#faq38\n-                decompressor = raw_decompressor\n-                output_chunk = decompressor.decompress(input_chunk)\n-            else:\n-                raise\n+    output_stream.write(first_chunk)\n+    while decompressor.unconsumed_tail:\n+        output_chunk = decompressor.decompress(\n+            decompressor.unconsumed_tail, max_length=_CHUNK_SIZE\n+        )\n         decompressed_size += len(output_chunk)\n-        if max_size and decompressed_size > max_size:\n-            raise _DecompressionMaxSizeExceeded(\n-                f\"The number of bytes decompressed so far \"\n-                f\"({decompressed_size} B) exceed the specified maximum \"\n-                f\"({max_size} B).\"\n-            )\n+        _check_max_size(decompressed_size, max_size)\n         output_stream.write(output_chunk)\n-    output_stream.seek(0)\n-    return output_stream.read()\n+    if tail := decompressor.flush():\n+        decompressed_size += len(tail)\n+        _check_max_size(decompressed_size, max_size)\n+        output_stream.write(tail)\n+    return output_stream.getvalue()\n \n \n def _unbrotli(data: bytes, *, max_size: int = 0) -> bytes:\n     decompressor = brotli.Decompressor()\n-    input_stream = BytesIO(data)\n+    first_chunk = decompressor.process(data, output_buffer_limit=_CHUNK_SIZE)\n+    decompressed_size = len(first_chunk)\n+    _check_max_size(decompressed_size, max_size)\n     output_stream = BytesIO()\n-    output_chunk = b\".\"\n-    decompressed_size = 0\n-    while output_chunk:\n-        input_chunk = input_stream.read(_CHUNK_SIZE)\n-        output_chunk = _brotli_decompress(decompressor, input_chunk)\n+    output_stream.write(first_chunk)\n+    while not decompressor.is_finished():\n+        output_chunk = decompressor.process(b\"\", output_buffer_limit=_CHUNK_SIZE)\n+        if not output_chunk:\n+            raise ValueError(\"Truncated brotli compressed data\")",
      "comment": "Previous `_unbrotli()` implementation is actually checking this by `while output_chunk:`\r\n\r\nhttps://github.com/scrapy/scrapy/blob/426aafddca8182dba12da819046272a8fad41e72/scrapy/utils/_compression.py#L92-L94",
      "comment_id": 2524556292,
      "user": "Cycloctane",
      "created_at": "2025-11-13T18:45:27Z",
      "url": "https://github.com/scrapy/scrapy/pull/7134#discussion_r2524556292"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 7134,
      "file_path": "scrapy/utils/_compression.py",
      "line": 69,
      "side": "RIGHT",
      "diff_hunk": "@@ -46,62 +13,64 @@ def _brotli_decompress(decompressor, data):\n \n \n class _DecompressionMaxSizeExceeded(ValueError):\n-    pass\n+    def __init__(self, decompressed_size: int, max_size: int) -> None:\n+        self.decompressed_size = decompressed_size\n+        self.max_size = max_size\n+\n+    def __str__(self) -> str:\n+        return (\n+            f\"The number of bytes decompressed so far \"\n+            f\"({self.decompressed_size} B) exceeded the specified maximum \"\n+            f\"({self.max_size} B).\"\n+        )\n+\n+\n+def _check_max_size(decompressed_size: int, max_size: int) -> None:\n+    if max_size and decompressed_size > max_size:\n+        raise _DecompressionMaxSizeExceeded(decompressed_size, max_size)\n \n \n def _inflate(data: bytes, *, max_size: int = 0) -> bytes:\n     decompressor = zlib.decompressobj()\n-    raw_decompressor = zlib.decompressobj(wbits=-15)\n-    input_stream = BytesIO(data)\n+    try:\n+        first_chunk = decompressor.decompress(data, max_length=_CHUNK_SIZE)\n+    except zlib.error:\n+        # to work with raw deflate content that may be sent by microsoft servers.\n+        decompressor = zlib.decompressobj(wbits=-15)\n+        first_chunk = decompressor.decompress(data, max_length=_CHUNK_SIZE)\n+    decompressed_size = len(first_chunk)\n+    _check_max_size(decompressed_size, max_size)\n     output_stream = BytesIO()\n-    output_chunk = b\".\"\n-    decompressed_size = 0\n-    while output_chunk:\n-        input_chunk = input_stream.read(_CHUNK_SIZE)\n-        try:\n-            output_chunk = decompressor.decompress(input_chunk)\n-        except zlib.error:\n-            if decompressor != raw_decompressor:\n-                # ugly hack to work with raw deflate content that may\n-                # be sent by microsoft servers. For more information, see:\n-                # http://carsten.codimi.de/gzip.yaws/\n-                # http://www.port80software.com/200ok/archive/2005/10/31/868.aspx\n-                # http://www.gzip.org/zlib/zlib_faq.html#faq38\n-                decompressor = raw_decompressor\n-                output_chunk = decompressor.decompress(input_chunk)\n-            else:\n-                raise\n+    output_stream.write(first_chunk)\n+    while decompressor.unconsumed_tail:\n+        output_chunk = decompressor.decompress(\n+            decompressor.unconsumed_tail, max_length=_CHUNK_SIZE\n+        )\n         decompressed_size += len(output_chunk)\n-        if max_size and decompressed_size > max_size:\n-            raise _DecompressionMaxSizeExceeded(\n-                f\"The number of bytes decompressed so far \"\n-                f\"({decompressed_size} B) exceed the specified maximum \"\n-                f\"({max_size} B).\"\n-            )\n+        _check_max_size(decompressed_size, max_size)\n         output_stream.write(output_chunk)\n-    output_stream.seek(0)\n-    return output_stream.read()\n+    if tail := decompressor.flush():\n+        decompressed_size += len(tail)\n+        _check_max_size(decompressed_size, max_size)\n+        output_stream.write(tail)\n+    return output_stream.getvalue()\n \n \n def _unbrotli(data: bytes, *, max_size: int = 0) -> bytes:\n     decompressor = brotli.Decompressor()\n-    input_stream = BytesIO(data)\n+    first_chunk = decompressor.process(data, output_buffer_limit=_CHUNK_SIZE)\n+    decompressed_size = len(first_chunk)\n+    _check_max_size(decompressed_size, max_size)\n     output_stream = BytesIO()\n-    output_chunk = b\".\"\n-    decompressed_size = 0\n-    while output_chunk:\n-        input_chunk = input_stream.read(_CHUNK_SIZE)\n-        output_chunk = _brotli_decompress(decompressor, input_chunk)\n+    output_stream.write(first_chunk)\n+    while not decompressor.is_finished():\n+        output_chunk = decompressor.process(b\"\", output_buffer_limit=_CHUNK_SIZE)\n+        if not output_chunk:\n+            raise ValueError(\"Truncated brotli compressed data\")",
      "comment": "I managed to make the tests cover this condition. Also use tests to make sure Scrapy codes won't run into infinite loop if input compressed data is truncated.",
      "comment_id": 2525075835,
      "user": "Cycloctane",
      "created_at": "2025-11-13T22:03:05Z",
      "url": "https://github.com/scrapy/scrapy/pull/7134#discussion_r2525075835"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 7134,
      "file_path": "scrapy/utils/_compression.py",
      "line": 69,
      "side": "RIGHT",
      "diff_hunk": "@@ -46,62 +13,64 @@ def _brotli_decompress(decompressor, data):\n \n \n class _DecompressionMaxSizeExceeded(ValueError):\n-    pass\n+    def __init__(self, decompressed_size: int, max_size: int) -> None:\n+        self.decompressed_size = decompressed_size\n+        self.max_size = max_size\n+\n+    def __str__(self) -> str:\n+        return (\n+            f\"The number of bytes decompressed so far \"\n+            f\"({self.decompressed_size} B) exceeded the specified maximum \"\n+            f\"({self.max_size} B).\"\n+        )\n+\n+\n+def _check_max_size(decompressed_size: int, max_size: int) -> None:\n+    if max_size and decompressed_size > max_size:\n+        raise _DecompressionMaxSizeExceeded(decompressed_size, max_size)\n \n \n def _inflate(data: bytes, *, max_size: int = 0) -> bytes:\n     decompressor = zlib.decompressobj()\n-    raw_decompressor = zlib.decompressobj(wbits=-15)\n-    input_stream = BytesIO(data)\n+    try:\n+        first_chunk = decompressor.decompress(data, max_length=_CHUNK_SIZE)\n+    except zlib.error:\n+        # to work with raw deflate content that may be sent by microsoft servers.\n+        decompressor = zlib.decompressobj(wbits=-15)\n+        first_chunk = decompressor.decompress(data, max_length=_CHUNK_SIZE)\n+    decompressed_size = len(first_chunk)\n+    _check_max_size(decompressed_size, max_size)\n     output_stream = BytesIO()\n-    output_chunk = b\".\"\n-    decompressed_size = 0\n-    while output_chunk:\n-        input_chunk = input_stream.read(_CHUNK_SIZE)\n-        try:\n-            output_chunk = decompressor.decompress(input_chunk)\n-        except zlib.error:\n-            if decompressor != raw_decompressor:\n-                # ugly hack to work with raw deflate content that may\n-                # be sent by microsoft servers. For more information, see:\n-                # http://carsten.codimi.de/gzip.yaws/\n-                # http://www.port80software.com/200ok/archive/2005/10/31/868.aspx\n-                # http://www.gzip.org/zlib/zlib_faq.html#faq38\n-                decompressor = raw_decompressor\n-                output_chunk = decompressor.decompress(input_chunk)\n-            else:\n-                raise\n+    output_stream.write(first_chunk)\n+    while decompressor.unconsumed_tail:\n+        output_chunk = decompressor.decompress(\n+            decompressor.unconsumed_tail, max_length=_CHUNK_SIZE\n+        )\n         decompressed_size += len(output_chunk)\n-        if max_size and decompressed_size > max_size:\n-            raise _DecompressionMaxSizeExceeded(\n-                f\"The number of bytes decompressed so far \"\n-                f\"({decompressed_size} B) exceed the specified maximum \"\n-                f\"({max_size} B).\"\n-            )\n+        _check_max_size(decompressed_size, max_size)\n         output_stream.write(output_chunk)\n-    output_stream.seek(0)\n-    return output_stream.read()\n+    if tail := decompressor.flush():\n+        decompressed_size += len(tail)\n+        _check_max_size(decompressed_size, max_size)\n+        output_stream.write(tail)\n+    return output_stream.getvalue()\n \n \n def _unbrotli(data: bytes, *, max_size: int = 0) -> bytes:\n     decompressor = brotli.Decompressor()\n-    input_stream = BytesIO(data)\n+    first_chunk = decompressor.process(data, output_buffer_limit=_CHUNK_SIZE)\n+    decompressed_size = len(first_chunk)\n+    _check_max_size(decompressed_size, max_size)\n     output_stream = BytesIO()\n-    output_chunk = b\".\"\n-    decompressed_size = 0\n-    while output_chunk:\n-        input_chunk = input_stream.read(_CHUNK_SIZE)\n-        output_chunk = _brotli_decompress(decompressor, input_chunk)\n+    output_stream.write(first_chunk)\n+    while not decompressor.is_finished():\n+        output_chunk = decompressor.process(b\"\", output_buffer_limit=_CHUNK_SIZE)\n+        if not output_chunk:\n+            raise ValueError(\"Truncated brotli compressed data\")",
      "comment": "Thanks @Cycloctane for going an extra mile, looks great!",
      "comment_id": 2533096006,
      "user": "kmike",
      "created_at": "2025-11-17T08:13:21Z",
      "url": "https://github.com/scrapy/scrapy/pull/7134#discussion_r2533096006"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 6975,
      "file_path": "tests/test_pipeline_images.py",
      "line": 172,
      "side": "RIGHT",
      "diff_hunk": "@@ -169,7 +169,7 @@ def test_get_images(self):\n \n         path, new_im, new_buf = next(get_images_gen)\n         assert path == \"full/3fd165099d8e71b8a48b2683946e64dbfad8b52d.jpg\"\n-        assert orig_im == new_im\n+        assert orig_im.copy() == new_im",
      "comment": "`orig_im` would be the opened image in the specific class of `JpegImagePlugin` - https://github.com/scrapy/scrapy/actions/runs/16583228546/job/46903534162#step:5:262\r\n\r\nCalling [`copy()`](https://pillow.readthedocs.io/en/stable/reference/Image.html#PIL.Image.Image.copy) turns it into a more general `Image` instance, to match what is returned by [`ImageOps.exif_tranpose()`](https://pillow.readthedocs.io/en/stable/reference/ImageOps.html#PIL.ImageOps.exif_transpose)",
      "comment_id": 2239836303,
      "user": "radarhere",
      "created_at": "2025-07-29T13:27:11Z",
      "url": "https://github.com/scrapy/scrapy/pull/6975#discussion_r2239836303"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 7059,
      "file_path": "tests/mockserver/http_resources.py",
      "line": 313,
      "side": "RIGHT",
      "diff_hunk": "@@ -307,3 +307,13 @@ def render(self, request):\n         if request.method != b\"CONNECT\":\n             return request.uri\n         return b\"\"\n+\n+\n+class ResponseHeadersResource(resource.Resource):",
      "comment": "I wasn't sure if another mock resource that sets http headers on the response already exists somewhere.",
      "comment_id": 2384478717,
      "user": "galbwe",
      "created_at": "2025-09-28T04:30:47Z",
      "url": "https://github.com/scrapy/scrapy/pull/7059#discussion_r2384478717"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 7059,
      "file_path": "tests/test_downloader_handlers_http_base.py",
      "line": 130,
      "side": "RIGHT",
      "diff_hunk": "@@ -93,6 +94,111 @@ async def test_download_head(\n         response = await download_request(download_handler, request)\n         assert response.body == b\"\"\n \n+    @pytest.mark.parametrize(\n+        \"http_status\",\n+        [\n+            pytest.param(http_status, id=f\"status={http_status.value}\")\n+            for http_status in HTTPStatus\n+            if http_status.value == 200 or http_status.value // 100 in (4, 5)\n+        ],\n+    )\n+    @deferred_f_from_coro_f\n+    async def test_download_has_correct_http_status_code(\n+        self,\n+        mockserver: MockServer,\n+        download_handler: DownloadHandlerProtocol,\n+        http_status: HTTPStatus,\n+    ) -> None:\n+        request = Request(mockserver.url(f\"/status?n={http_status.value}\"))\n+        response = await download_request(download_handler, request)\n+        assert response.status == http_status.value\n+\n+    @deferred_f_from_coro_f\n+    async def test_server_receives_correct_request_headers(\n+        self,\n+        mockserver: MockServer,\n+        download_handler: DownloadHandlerProtocol,\n+    ) -> None:\n+        request_headers = {\n+            # common request headers\n+            \"Accept\": \"text/html\",\n+            \"Accept-Charset\": \"utf-8\",\n+            \"Accept-Datetime\": \"Thu, 31 May 2007 20:35:00 GMT\",\n+            \"Accept-Encoding\": \"gzip, deflate\",",
      "comment": "Happy to extend this dictionary of request headers if the approach seems okay.",
      "comment_id": 2384478914,
      "user": "galbwe",
      "created_at": "2025-09-28T04:31:30Z",
      "url": "https://github.com/scrapy/scrapy/pull/7059#discussion_r2384478914"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 7059,
      "file_path": "tests/test_downloader_handlers_http_base.py",
      "line": 185,
      "side": "RIGHT",
      "diff_hunk": "@@ -93,6 +94,111 @@ async def test_download_head(\n         response = await download_request(download_handler, request)\n         assert response.body == b\"\"\n \n+    @pytest.mark.parametrize(\n+        \"http_status\",\n+        [\n+            pytest.param(http_status, id=f\"status={http_status.value}\")\n+            for http_status in HTTPStatus\n+            if http_status.value == 200 or http_status.value // 100 in (4, 5)\n+        ],\n+    )\n+    @deferred_f_from_coro_f\n+    async def test_download_has_correct_http_status_code(\n+        self,\n+        mockserver: MockServer,\n+        download_handler: DownloadHandlerProtocol,\n+        http_status: HTTPStatus,\n+    ) -> None:\n+        request = Request(mockserver.url(f\"/status?n={http_status.value}\"))\n+        response = await download_request(download_handler, request)\n+        assert response.status == http_status.value\n+\n+    @deferred_f_from_coro_f\n+    async def test_server_receives_correct_request_headers(\n+        self,\n+        mockserver: MockServer,\n+        download_handler: DownloadHandlerProtocol,\n+    ) -> None:\n+        request_headers = {\n+            # common request headers\n+            \"Accept\": \"text/html\",\n+            \"Accept-Charset\": \"utf-8\",\n+            \"Accept-Datetime\": \"Thu, 31 May 2007 20:35:00 GMT\",\n+            \"Accept-Encoding\": \"gzip, deflate\",\n+            # custom headers\n+            \"X-Custom-Header\": \"Custom Value\",\n+        }\n+\n+        request = Request(\n+            mockserver.url(\"/echo\"),\n+            headers=request_headers,\n+        )\n+        response = await download_request(download_handler, request)\n+        assert response.status == HTTPStatus.OK\n+        body = json.loads(response.body.decode(\"utf-8\"))\n+        assert \"headers\" in body\n+        for header_name, header_value in request_headers.items():\n+            assert header_name in body[\"headers\"]\n+            assert body[\"headers\"][header_name] == [header_value]\n+\n+    @deferred_f_from_coro_f\n+    async def test_server_receives_correct_request_body(\n+        self,\n+        mockserver: MockServer,\n+        download_handler: DownloadHandlerProtocol,\n+    ) -> None:\n+        request_body = {\n+            \"message\": \"It works!\",\n+        }\n+        request = Request(\n+            mockserver.url(\"/echo\"),\n+            body=json.dumps(request_body),\n+        )\n+        response = await download_request(download_handler, request)\n+        assert response.status == HTTPStatus.OK\n+        body = json.loads(response.body.decode(\"utf-8\"))\n+        assert json.loads(body[\"body\"]) == request_body\n+\n+    @deferred_f_from_coro_f\n+    async def test_download_has_correct_response_headers(\n+        self,\n+        mockserver: MockServer,\n+        download_handler: DownloadHandlerProtocol,\n+    ) -> None:\n+        # these headers will be set on the response in the resource and returned\n+        response_headers = {\n+            # common response headers\n+            \"Access-Control-Allow-Origin\": \"*\",\n+            \"Allow\": \"Get, Head\",\n+            \"Age\": \"12\",\n+            \"Cache-Control\": \"max-age=3600\",\n+            \"Content-Encoding\": \"gzip\",\n+            \"Content-MD5\": \"Q2hlY2sgSW50ZWdyaXR5IQ==\",\n+            \"Content-Type\": \"text/html; charset=utf-8\",\n+            \"Date\": \"Date: Tue, 15 Nov 1994 08:12:31 GMT\",\n+            \"Pragma\": \"no-cache\",\n+            \"Retry-After\": \"120\",\n+            \"Set-Cookie\": \"CookieName=CookieValue; Max-Age=3600; Version=1\",\n+            \"WWW-Authenticate\": \"Basic\",",
      "comment": "Same comment. Happy to extend this dictionary if the approach seems reasonable.",
      "comment_id": 2384479000,
      "user": "galbwe",
      "created_at": "2025-09-28T04:32:09Z",
      "url": "https://github.com/scrapy/scrapy/pull/7059#discussion_r2384479000"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 7046,
      "file_path": "tests/test_crawl.py",
      "line": 417,
      "side": "LEFT",
      "diff_hunk": "@@ -414,11 +414,11 @@ def test_crawl_multiple(self):\n             mockserver=self.mockserver,\n         )\n \n-        with LogCapture() as log:",
      "comment": "It looked liked `LogCapture()` changes the root handler.",
      "comment_id": 2331143909,
      "user": "wRAR",
      "created_at": "2025-09-08T19:13:50Z",
      "url": "https://github.com/scrapy/scrapy/pull/7046#discussion_r2331143909"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 7045,
      "file_path": "scrapy/statscollectors.py",
      "line": 33,
      "side": "RIGHT",
      "diff_hunk": "@@ -28,9 +28,15 @@ def __init__(self, crawler: Crawler):\n         self._crawler: Crawler = crawler\n \n     def __getattribute__(self, name):\n+        cached_name = f\"_cached_{name}\"\n+        try:\n+            return super().__getattribute__(cached_name)",
      "comment": "TIL `hasattr()` \"is implemented by calling `getattr(object, name)` and seeing whether it raises an `AttributeError` or not\"",
      "comment_id": 2330033772,
      "user": "wRAR",
      "created_at": "2025-09-08T12:02:32Z",
      "url": "https://github.com/scrapy/scrapy/pull/7045#discussion_r2330033772"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 7037,
      "file_path": "scrapy/downloadermiddlewares/offsite.py",
      "line": 34,
      "side": "LEFT",
      "diff_hunk": "@@ -21,29 +22,34 @@\n \n \n class OffsiteMiddleware:\n+    crawler: Crawler\n+\n+    def __init__(self, stats: StatsCollector):\n+        self.stats = stats\n+        self.domains_seen: set[str] = set()\n+\n     @classmethod\n     def from_crawler(cls, crawler: Crawler) -> Self:\n         assert crawler.stats\n         o = cls(crawler.stats)\n         crawler.signals.connect(o.spider_opened, signal=signals.spider_opened)\n         crawler.signals.connect(o.request_scheduled, signal=signals.request_scheduled)\n+        o.crawler = crawler\n         return o\n \n-    def __init__(self, stats: StatsCollector):\n-        self.stats = stats\n-        self.domains_seen: set[str] = set()",
      "comment": "For the record, I kind of like the `__init__` after the `from_crawler`, in order of execution :slightly_smiling_face:",
      "comment_id": 2314576819,
      "user": "Gallaecio",
      "created_at": "2025-09-01T21:16:59Z",
      "url": "https://github.com/scrapy/scrapy/pull/7037#discussion_r2314576819"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 7037,
      "file_path": "scrapy/downloadermiddlewares/robotstxt.py",
      "line": 66,
      "side": "RIGHT",
      "diff_hunk": "@@ -51,17 +52,18 @@ def __init__(self, crawler: Crawler):\n     def from_crawler(cls, crawler: Crawler) -> Self:\n         return cls(crawler)\n \n-    async def process_request(self, request: Request, spider: Spider) -> None:\n+    @_warn_spider_arg\n+    async def process_request(\n+        self, request: Request, spider: Spider | None = None\n+    ) -> None:\n         if request.meta.get(\"dont_obey_robotstxt\"):\n             return\n         if request.url.startswith(\"data:\") or request.url.startswith(\"file:\"):\n             return\n-        rp = await self.robot_parser(request, spider)\n-        self.process_request_2(rp, request, spider)\n+        rp = await self.robot_parser(request)\n+        self.process_request_2(rp, request)\n \n-    def process_request_2(\n-        self, rp: RobotParser | None, request: Request, spider: Spider\n-    ) -> None:\n+    def process_request_2(self, rp: RobotParser | None, request: Request) -> None:",
      "comment": "I see we are not keeping backward compatibility here or in `robot_parser` below. Was that a deliberate decision?",
      "comment_id": 2314579060,
      "user": "Gallaecio",
      "created_at": "2025-09-01T21:20:20Z",
      "url": "https://github.com/scrapy/scrapy/pull/7037#discussion_r2314579060"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 7037,
      "file_path": "scrapy/downloadermiddlewares/robotstxt.py",
      "line": 66,
      "side": "RIGHT",
      "diff_hunk": "@@ -51,17 +52,18 @@ def __init__(self, crawler: Crawler):\n     def from_crawler(cls, crawler: Crawler) -> Self:\n         return cls(crawler)\n \n-    async def process_request(self, request: Request, spider: Spider) -> None:\n+    @_warn_spider_arg\n+    async def process_request(\n+        self, request: Request, spider: Spider | None = None\n+    ) -> None:\n         if request.meta.get(\"dont_obey_robotstxt\"):\n             return\n         if request.url.startswith(\"data:\") or request.url.startswith(\"file:\"):\n             return\n-        rp = await self.robot_parser(request, spider)\n-        self.process_request_2(rp, request, spider)\n+        rp = await self.robot_parser(request)\n+        self.process_request_2(rp, request)\n \n-    def process_request_2(\n-        self, rp: RobotParser | None, request: Request, spider: Spider\n-    ) -> None:\n+    def process_request_2(self, rp: RobotParser | None, request: Request) -> None:",
      "comment": "Somewhat, we already document in \"Backward-incompatible changes\" that `process_request()` and `robot_parser()` were changed to `async def` but I didn't think about `process_request_2()` too much. We can do it for it or even for both helpers.",
      "comment_id": 2315022931,
      "user": "wRAR",
      "created_at": "2025-09-02T06:16:31Z",
      "url": "https://github.com/scrapy/scrapy/pull/7037#discussion_r2315022931"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 7033,
      "file_path": "scrapy/utils/decorators.py",
      "line": 107,
      "side": "RIGHT",
      "diff_hunk": "@@ -65,3 +66,68 @@ def wrapped(*a: _P.args, **kw: _P.kwargs) -> Deferred[_T]:\n         return deferToThread(func, *a, **kw)\n \n     return wrapped\n+\n+\n+@overload\n+def _warn_spider_arg(\n+    func: Callable[_P, Coroutine[Any, Any, _T]],\n+) -> Callable[_P, Coroutine[Any, Any, _T]]: ...\n+\n+\n+@overload\n+def _warn_spider_arg(\n+    func: Callable[_P, AsyncGenerator[_T]],\n+) -> Callable[_P, AsyncGenerator[_T]]: ...\n+\n+\n+@overload\n+def _warn_spider_arg(func: Callable[_P, _T]) -> Callable[_P, _T]: ...\n+\n+\n+def _warn_spider_arg(\n+    func: Callable[_P, _T],\n+) -> (\n+    Callable[_P, _T]\n+    | Callable[_P, Coroutine[Any, Any, _T]]\n+    | Callable[_P, AsyncGenerator[_T]]\n+):\n+    \"\"\"Decorator to warn if a (non-None) ``spider`` argument is passed to a function.\"\"\"\n+\n+    def check_args(*args: _P.args, **kwargs: _P.kwargs) -> None:\n+        bound = inspect.signature(func).bind(*args, **kwargs)\n+        bound.apply_defaults()\n+        if bound.arguments.get(\"spider\"):\n+            warnings.warn(\n+                f\"Passing a 'spider' argument to {func.__qualname__}() is deprecated and \"\n+                \"the argument will be removed in a future Scrapy version.\",\n+                category=ScrapyDeprecationWarning,\n+                stacklevel=3,\n+            )\n+\n+    if inspect.iscoroutinefunction(func):",
      "comment": "OK, this is not used/covered because the only async functions that are decorated are `process_spider_output_async()` which are async generator functions.",
      "comment_id": 2310684726,
      "user": "wRAR",
      "created_at": "2025-08-29T17:07:25Z",
      "url": "https://github.com/scrapy/scrapy/pull/7033#discussion_r2310684726"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 7033,
      "file_path": "scrapy/utils/decorators.py",
      "line": 99,
      "side": "RIGHT",
      "diff_hunk": "@@ -65,3 +66,68 @@ def wrapped(*a: _P.args, **kw: _P.kwargs) -> Deferred[_T]:\n         return deferToThread(func, *a, **kw)\n \n     return wrapped\n+\n+\n+@overload\n+def _warn_spider_arg(\n+    func: Callable[_P, Coroutine[Any, Any, _T]],\n+) -> Callable[_P, Coroutine[Any, Any, _T]]: ...\n+\n+\n+@overload\n+def _warn_spider_arg(\n+    func: Callable[_P, AsyncGenerator[_T]],\n+) -> Callable[_P, AsyncGenerator[_T]]: ...\n+\n+\n+@overload\n+def _warn_spider_arg(func: Callable[_P, _T]) -> Callable[_P, _T]: ...\n+\n+\n+def _warn_spider_arg(\n+    func: Callable[_P, _T],\n+) -> (\n+    Callable[_P, _T]\n+    | Callable[_P, Coroutine[Any, Any, _T]]\n+    | Callable[_P, AsyncGenerator[_T]]\n+):\n+    \"\"\"Decorator to warn if a (non-None) ``spider`` argument is passed to a function.\"\"\"\n+\n+    def check_args(*args: _P.args, **kwargs: _P.kwargs) -> None:\n+        bound = inspect.signature(func).bind(*args, **kwargs)\n+        bound.apply_defaults()\n+        if bound.arguments.get(\"spider\"):",
      "comment": "I saw that `(non-None)` in the docstring above, and I\u2019m thinking: What if, now that we are using inspect anyway, we go a step further than with the previous code, and warn as well if the value if `None` provided it is specified as a parameter? (since such code would also break when we remove the parameter).\r\n\r\ne.g.\r\n\r\n```suggestion\r\n        if \"spider\" in bound.arguments:\r\n```",
      "comment_id": 2313711249,
      "user": "Gallaecio",
      "created_at": "2025-09-01T11:35:57Z",
      "url": "https://github.com/scrapy/scrapy/pull/7033#discussion_r2313711249"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 7013,
      "file_path": "tests/test_extension_statsmailer.py",
      "line": 26,
      "side": "RIGHT",
      "diff_hunk": "@@ -0,0 +1,77 @@\n+from unittest.mock import MagicMock\n+\n+import pytest\n+\n+from scrapy import signals\n+from scrapy.exceptions import NotConfigured\n+from scrapy.extensions import statsmailer\n+from scrapy.mail import MailSender\n+from scrapy.signalmanager import SignalManager\n+from scrapy.spiders import Spider\n+from scrapy.statscollectors import StatsCollector\n+\n+\n+class DummySpider(Spider):\n+    name = \"dummy_spider\"\n+\n+\n+@pytest.fixture\n+def dummy_stats():\n+    class DummyStats(StatsCollector):\n+        def __init__(self):\n+            # pylint: disable=super-init-not-called\n+            self._stats = {\"global_item_scraped_count\": 42}\n+\n+        def get_stats(self, spider=None):\n+            if spider:",
      "comment": "The spider arg was recently deprecated and is no longer passed.",
      "comment_id": 2295436642,
      "user": "wRAR",
      "created_at": "2025-08-23T07:33:08Z",
      "url": "https://github.com/scrapy/scrapy/pull/7013#discussion_r2295436642"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 7013,
      "file_path": "tests/test_extension_statsmailer.py",
      "line": 26,
      "side": "RIGHT",
      "diff_hunk": "@@ -0,0 +1,77 @@\n+from unittest.mock import MagicMock\n+\n+import pytest\n+\n+from scrapy import signals\n+from scrapy.exceptions import NotConfigured\n+from scrapy.extensions import statsmailer\n+from scrapy.mail import MailSender\n+from scrapy.signalmanager import SignalManager\n+from scrapy.spiders import Spider\n+from scrapy.statscollectors import StatsCollector\n+\n+\n+class DummySpider(Spider):\n+    name = \"dummy_spider\"\n+\n+\n+@pytest.fixture\n+def dummy_stats():\n+    class DummyStats(StatsCollector):\n+        def __init__(self):\n+            # pylint: disable=super-init-not-called\n+            self._stats = {\"global_item_scraped_count\": 42}\n+\n+        def get_stats(self, spider=None):\n+            if spider:",
      "comment": "We need to accept the spider argument in our DummyStats.get_stats, but ignore it. That way the test will work across different versions. Gives an error in case spider arg is not passed.",
      "comment_id": 2301737683,
      "user": "IkramKhanNiazi",
      "created_at": "2025-08-26T18:03:25Z",
      "url": "https://github.com/scrapy/scrapy/pull/7013#discussion_r2301737683"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 7013,
      "file_path": "tests/test_extension_statsmailer.py",
      "line": 26,
      "side": "RIGHT",
      "diff_hunk": "@@ -0,0 +1,77 @@\n+from unittest.mock import MagicMock\n+\n+import pytest\n+\n+from scrapy import signals\n+from scrapy.exceptions import NotConfigured\n+from scrapy.extensions import statsmailer\n+from scrapy.mail import MailSender\n+from scrapy.signalmanager import SignalManager\n+from scrapy.spiders import Spider\n+from scrapy.statscollectors import StatsCollector\n+\n+\n+class DummySpider(Spider):\n+    name = \"dummy_spider\"\n+\n+\n+@pytest.fixture\n+def dummy_stats():\n+    class DummyStats(StatsCollector):\n+        def __init__(self):\n+            # pylint: disable=super-init-not-called\n+            self._stats = {\"global_item_scraped_count\": 42}\n+\n+        def get_stats(self, spider=None):\n+            if spider:",
      "comment": "> That way the test will work across different versions\r\n\r\nVersions of what?",
      "comment_id": 2305207599,
      "user": "wRAR",
      "created_at": "2025-08-27T20:15:56Z",
      "url": "https://github.com/scrapy/scrapy/pull/7013#discussion_r2305207599"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 7013,
      "file_path": "tests/test_extension_statsmailer.py",
      "line": 21,
      "side": "RIGHT",
      "diff_hunk": "@@ -0,0 +1,82 @@\n+from unittest.mock import MagicMock\n+\n+import pytest\n+\n+from scrapy import signals\n+from scrapy.exceptions import NotConfigured\n+from scrapy.extensions import statsmailer\n+from scrapy.mail import MailSender\n+from scrapy.signalmanager import SignalManager\n+from scrapy.statscollectors import StatsCollector\n+from scrapy.utils.spider import DefaultSpider\n+\n+\n+@pytest.fixture\n+def dummy_stats():\n+    class DummyStats(StatsCollector):\n+        def __init__(self):\n+            # pylint: disable=super-init-not-called\n+            self._stats = {\"global_item_scraped_count\": 42}\n+\n+        def get_stats(self, spider=None):",
      "comment": "As mentioned earlier, the spider arg shouldn't be needed.",
      "comment_id": 2308248560,
      "user": "wRAR",
      "created_at": "2025-08-28T18:39:21Z",
      "url": "https://github.com/scrapy/scrapy/pull/7013#discussion_r2308248560"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 7013,
      "file_path": "tests/test_extension_statsmailer.py",
      "line": 21,
      "side": "RIGHT",
      "diff_hunk": "@@ -0,0 +1,82 @@\n+from unittest.mock import MagicMock\n+\n+import pytest\n+\n+from scrapy import signals\n+from scrapy.exceptions import NotConfigured\n+from scrapy.extensions import statsmailer\n+from scrapy.mail import MailSender\n+from scrapy.signalmanager import SignalManager\n+from scrapy.statscollectors import StatsCollector\n+from scrapy.utils.spider import DefaultSpider\n+\n+\n+@pytest.fixture\n+def dummy_stats():\n+    class DummyStats(StatsCollector):\n+        def __init__(self):\n+            # pylint: disable=super-init-not-called\n+            self._stats = {\"global_item_scraped_count\": 42}\n+\n+        def get_stats(self, *args, **kwargs):",
      "comment": "@wRAR \r\nIf no arguments or the spider argument are provided, an error is raised due to [this line](https://github.com/scrapy/scrapy/blob/master/scrapy/extensions/statsmailer.py?utm_source=chatgpt.com#L43)\r\n in the spider_closed method. Please let me know if I\u2019ve missed anything.\r\n\r\n<img width=\"945\" height=\"124\" alt=\"Screenshot 2025-08-30 at 1 13 31\u202fAM\" src=\"https://github.com/user-attachments/assets/64e9bb69-5743-4b43-8da3-86bc9c4bc1cb\" />\r\n",
      "comment_id": 2311104389,
      "user": "IkramKhanNiazi",
      "created_at": "2025-08-29T20:15:06Z",
      "url": "https://github.com/scrapy/scrapy/pull/7013#discussion_r2311104389"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 7013,
      "file_path": "tests/test_extension_statsmailer.py",
      "line": 21,
      "side": "RIGHT",
      "diff_hunk": "@@ -0,0 +1,82 @@\n+from unittest.mock import MagicMock\n+\n+import pytest\n+\n+from scrapy import signals\n+from scrapy.exceptions import NotConfigured\n+from scrapy.extensions import statsmailer\n+from scrapy.mail import MailSender\n+from scrapy.signalmanager import SignalManager\n+from scrapy.statscollectors import StatsCollector\n+from scrapy.utils.spider import DefaultSpider\n+\n+\n+@pytest.fixture\n+def dummy_stats():\n+    class DummyStats(StatsCollector):\n+        def __init__(self):\n+            # pylint: disable=super-init-not-called\n+            self._stats = {\"global_item_scraped_count\": 42}\n+\n+        def get_stats(self, *args, **kwargs):",
      "comment": "Right, the warning for that line wasn't caught because that line wasn't covered by tests. You should remove the spider arg passing from that line.",
      "comment_id": 2311288663,
      "user": "wRAR",
      "created_at": "2025-08-29T21:09:41Z",
      "url": "https://github.com/scrapy/scrapy/pull/7013#discussion_r2311288663"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 7013,
      "file_path": "tests/test_extension_statsmailer.py",
      "line": 21,
      "side": "RIGHT",
      "diff_hunk": "@@ -0,0 +1,82 @@\n+from unittest.mock import MagicMock\n+\n+import pytest\n+\n+from scrapy import signals\n+from scrapy.exceptions import NotConfigured\n+from scrapy.extensions import statsmailer\n+from scrapy.mail import MailSender\n+from scrapy.signalmanager import SignalManager\n+from scrapy.statscollectors import StatsCollector\n+from scrapy.utils.spider import DefaultSpider\n+\n+\n+@pytest.fixture\n+def dummy_stats():\n+    class DummyStats(StatsCollector):\n+        def __init__(self):\n+            # pylint: disable=super-init-not-called\n+            self._stats = {\"global_item_scraped_count\": 42}\n+\n+        def get_stats(self, *args, **kwargs):",
      "comment": "I've removed the spider arg passing from that line.",
      "comment_id": 2311402796,
      "user": "IkramKhanNiazi",
      "created_at": "2025-08-29T22:01:04Z",
      "url": "https://github.com/scrapy/scrapy/pull/7013#discussion_r2311402796"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 6969,
      "file_path": "scrapy/pipelines/files.py",
      "line": 460,
      "side": "RIGHT",
      "diff_hunk": "@@ -452,7 +452,15 @@ def __init__(\n     ):\n         store_uri = _to_string(store_uri)\n         if not store_uri:\n-            raise NotConfigured\n+            setting_name = (\n+                \"IMAGES_STORE\"\n+                if self.__class__.__name__ == \"ImagesPipeline\"\n+                else \"FILES_STORE\"\n+            )\n+            raise NotConfigured(",
      "comment": "Now the only change this PR does is changing the exception message.",
      "comment_id": 2236883966,
      "user": "wRAR",
      "created_at": "2025-07-28T15:08:57Z",
      "url": "https://github.com/scrapy/scrapy/pull/6969#discussion_r2236883966"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 6969,
      "file_path": "scrapy/pipelines/files.py",
      "line": 460,
      "side": "RIGHT",
      "diff_hunk": "@@ -452,7 +452,15 @@ def __init__(\n     ):\n         store_uri = _to_string(store_uri)\n         if not store_uri:\n-            raise NotConfigured\n+            setting_name = (\n+                \"IMAGES_STORE\"\n+                if self.__class__.__name__ == \"ImagesPipeline\"\n+                else \"FILES_STORE\"\n+            )\n+            raise NotConfigured(",
      "comment": "I have updated the check to handle that None case.",
      "comment_id": 2236950579,
      "user": "IkramKhanNiazi",
      "created_at": "2025-07-28T15:27:13Z",
      "url": "https://github.com/scrapy/scrapy/pull/6969#discussion_r2236950579"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 6969,
      "file_path": "tests/test_pipeline_files.py",
      "line": 816,
      "side": "RIGHT",
      "diff_hunk": "@@ -802,3 +804,13 @@ def from_crawler(cls, crawler):\n             assert len(w) == 0\n             assert pipe.store\n             assert pipe._from_crawler_called\n+\n+\n+@pytest.mark.parametrize(\"store\", [None, \"\"])\n+def test_files_pipeline_raises_notconfigured_when_files_store_invalid(store):\n+    settings = Settings()\n+    settings.clear()\n+    settings.set(\"FILES_STORE\", store, priority=\"cmdline\")\n+    print(f\"Test: FILES_STORE: {settings.get('FILES_STORE')}\")\n+    with pytest.raises(NotConfigured):\n+        FilesPipeline.from_settings(settings)",
      "comment": "`from_settings()` is deprecated, you need to use `from_crawler()`.",
      "comment_id": 2283144665,
      "user": "wRAR",
      "created_at": "2025-08-18T18:29:27Z",
      "url": "https://github.com/scrapy/scrapy/pull/6969#discussion_r2283144665"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 6969,
      "file_path": "scrapy/pipelines/files.py",
      "line": 458,
      "side": "RIGHT",
      "diff_hunk": "@@ -450,9 +450,16 @@ def __init__(\n         *,\n         crawler: Crawler | None = None,\n     ):\n-        store_uri = _to_string(store_uri)\n-        if not store_uri:\n-            raise NotConfigured\n+        if not (store_uri and (store_uri := _to_string(store_uri))):\n+            setting_name = (\n+                \"IMAGES_STORE\"\n+                if self.__class__.__name__ == \"ImagesPipeline\"\n+                else \"FILES_STORE\"\n+            )",
      "comment": "I don't like this but it seems to be needed to have a good message. Though I think this should use `isinstance()`/`issubclass()` instead of an equality check.",
      "comment_id": 2283147821,
      "user": "wRAR",
      "created_at": "2025-08-18T18:31:04Z",
      "url": "https://github.com/scrapy/scrapy/pull/6969#discussion_r2283147821"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 7006,
      "file_path": "scrapy/pipelines/__init__.py",
      "line": 61,
      "side": "RIGHT",
      "diff_hunk": "@@ -45,4 +55,38 @@ def process_item(self, item: Any, spider: Spider | None = None) -> Deferred[Any]\n         return deferred_from_coro(self.process_item_async(item))\n \n     async def process_item_async(self, item: Any) -> Any:\n-        return await self._process_chain(\"process_item\", item, self._spider)\n+        return await self._process_chain(\"process_item\", item, add_spider=True)\n+\n+    def _process_parallel(\n+        self, methodname: str, add_spider: bool = False",
      "comment": "What\u2019s the point of `add_spider`? It seems to be always `True` at the moment, and the method is private.",
      "comment_id": 2289042365,
      "user": "Gallaecio",
      "created_at": "2025-08-20T19:04:50Z",
      "url": "https://github.com/scrapy/scrapy/pull/7006#discussion_r2289042365"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 7006,
      "file_path": "scrapy/pipelines/__init__.py",
      "line": 61,
      "side": "RIGHT",
      "diff_hunk": "@@ -45,4 +55,38 @@ def process_item(self, item: Any, spider: Spider | None = None) -> Deferred[Any]\n         return deferred_from_coro(self.process_item_async(item))\n \n     async def process_item_async(self, item: Any) -> Any:\n-        return await self._process_chain(\"process_item\", item, self._spider)\n+        return await self._process_chain(\"process_item\", item, add_spider=True)\n+\n+    def _process_parallel(\n+        self, methodname: str, add_spider: bool = False",
      "comment": "I think it's an artifact of multi-step refactoring of this.",
      "comment_id": 2289045509,
      "user": "wRAR",
      "created_at": "2025-08-20T19:06:32Z",
      "url": "https://github.com/scrapy/scrapy/pull/7006#discussion_r2289045509"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 7005,
      "file_path": "scrapy/core/scraper.py",
      "line": 135,
      "side": "RIGHT",
      "diff_hunk": "@@ -109,12 +110,38 @@ def __init__(self, crawler: Crawler) -> None:\n             crawler.settings[\"ITEM_PROCESSOR\"]\n         )\n         self.itemproc: ItemPipelineManager = itemproc_cls.from_crawler(crawler)\n-        self._itemproc_needs_spider: dict[str, bool] = {}\n-        for method in (\n+        itemproc_methods = [\n             \"open_spider\",\n             \"close_spider\",\n-            \"process_item\",\n+        ]\n+        if not hasattr(self.itemproc, \"process_item_async\"):\n+            warnings.warn(\n+                f\"{global_object_name(itemproc_cls)} doesn't define a process_item_async() method,\"\n+                f\" this is deprecated and the method will be required in the future Scrapy versions.\",\n+                ScrapyDeprecationWarning,\n+                stacklevel=2,\n+            )\n+            itemproc_methods.append(\"process_item\")\n+            self._itemproc_has_process_async = False\n+        elif (\n+            issubclass(itemproc_cls, ItemPipelineManager)\n+            and method_is_overridden(itemproc_cls, ItemPipelineManager, \"process_item\")\n+            and not method_is_overridden(\n+                itemproc_cls, ItemPipelineManager, \"process_item_async\"\n+            )\n         ):\n+            warnings.warn(\n+                f\"{global_object_name(itemproc_cls)} overrides process_item() but doesn't override process_item_async().\"\n+                f\" This is deprecated. process_item() will be used, but in the future Scrapy versions process_item_async() will be used instead.\",",
      "comment": "```suggestion\r\n                f\" This is deprecated. process_item() will be used, but in future Scrapy versions process_item_async() will be used instead.\",\r\n```\r\n\r\n(applies to similar strings as well)",
      "comment_id": 2269044848,
      "user": "Gallaecio",
      "created_at": "2025-08-12T08:06:32Z",
      "url": "https://github.com/scrapy/scrapy/pull/7005#discussion_r2269044848"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 6979,
      "file_path": "scrapy/commands/shell.py",
      "line": 88,
      "side": "RIGHT",
      "diff_hunk": "@@ -84,7 +85,7 @@ def run(self, args: list[str], opts: Namespace) -> None:\n         crawler._apply_settings()\n         # The Shell class needs a persistent engine in the crawler\n         crawler.engine = crawler._create_engine()\n-        crawler.engine.start(_start_request_processing=False)\n+        deferred_from_coro(crawler.engine.start_async(_start_request_processing=False))",
      "comment": "`deferred_from_coro()` here and in some other places is used as a shortcut for \"if using asyncio, create a task for the coro\", as just calling the coro wouldn't schedule it; we could add a private helper function instead, or change all these places to keep the reference to the returned deferred so that the code doesn't look weird (and to add exception handling)",
      "comment_id": 2243709659,
      "user": "wRAR",
      "created_at": "2025-07-30T19:48:37Z",
      "url": "https://github.com/scrapy/scrapy/pull/6979#discussion_r2243709659"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 6979,
      "file_path": "scrapy/commands/shell.py",
      "line": 88,
      "side": "RIGHT",
      "diff_hunk": "@@ -84,7 +85,7 @@ def run(self, args: list[str], opts: Namespace) -> None:\n         crawler._apply_settings()\n         # The Shell class needs a persistent engine in the crawler\n         crawler.engine = crawler._create_engine()\n-        crawler.engine.start(_start_request_processing=False)\n+        deferred_from_coro(crawler.engine.start_async(_start_request_processing=False))",
      "comment": "> we could add a private helper function instead\r\n\r\nI think this would be nice. I cannot think of a name, though :sweat_smile: ",
      "comment_id": 2243716559,
      "user": "Gallaecio",
      "created_at": "2025-07-30T19:52:34Z",
      "url": "https://github.com/scrapy/scrapy/pull/6979#discussion_r2243716559"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 6842,
      "file_path": "tests/test_engine.py",
      "line": 530,
      "side": "RIGHT",
      "diff_hunk": "@@ -479,6 +481,216 @@ def kill_proc():\n         assert b\"Traceback\" not in stderr, stderr\n \n \n+class TestEngineDownloadSync(TestEngineBase):\n+    \"\"\"Test cases for the synchronous download method of ExecutionEngine.\"\"\"\n+\n+    def setUp(self):\n+        super().setUp()\n+        self.crawler = get_crawler(MySpider)\n+        self.engine = ExecutionEngine(self.crawler, lambda _: None)\n+        self.engine.downloader = Mock()\n+        self.engine._slot = Mock()\n+        self.engine._slot.inprogress = set()\n+\n+        # Stop the downloader's slot GC loop to prevent reactor cleanup issues\n+        # self.engine.downloader._slot_gc_loop = Mock()\n+        # self.engine.downloader._slot_gc_loop.running = False\n+\n+    def tearDown(self):\n+        from twisted.internet import reactor\n+\n+        # Clean up any pending calls\n+        for c in reactor.getDelayedCalls():\n+            c.cancel()",
      "comment": "Are there problems with these tests if this is not done? We have some rare failures related to something like this, but they are a more general problem and it looks like these new tests at least don't fail every time.",
      "comment_id": 2126223180,
      "user": "wRAR",
      "created_at": "2025-06-04T10:06:48Z",
      "url": "https://github.com/scrapy/scrapy/pull/6842#discussion_r2126223180"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 6842,
      "file_path": "tests/test_engine.py",
      "line": 530,
      "side": "RIGHT",
      "diff_hunk": "@@ -479,6 +481,216 @@ def kill_proc():\n         assert b\"Traceback\" not in stderr, stderr\n \n \n+class TestEngineDownloadSync(TestEngineBase):\n+    \"\"\"Test cases for the synchronous download method of ExecutionEngine.\"\"\"\n+\n+    def setUp(self):\n+        super().setUp()\n+        self.crawler = get_crawler(MySpider)\n+        self.engine = ExecutionEngine(self.crawler, lambda _: None)\n+        self.engine.downloader = Mock()\n+        self.engine._slot = Mock()\n+        self.engine._slot.inprogress = set()\n+\n+        # Stop the downloader's slot GC loop to prevent reactor cleanup issues\n+        # self.engine.downloader._slot_gc_loop = Mock()\n+        # self.engine.downloader._slot_gc_loop.running = False\n+\n+    def tearDown(self):\n+        from twisted.internet import reactor\n+\n+        # Clean up any pending calls\n+        for c in reactor.getDelayedCalls():\n+            c.cancel()",
      "comment": "I tried removing it, but some tests are failing. I will have to add it again. I think the problem is that the tests interfere in one another if this cancelling is not present. ",
      "comment_id": 2169835719,
      "user": "fbenevolo",
      "created_at": "2025-06-26T19:38:39Z",
      "url": "https://github.com/scrapy/scrapy/pull/6842#discussion_r2169835719"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 6960,
      "file_path": "conftest.py",
      "line": 59,
      "side": "RIGHT",
      "diff_hunk": "@@ -48,6 +55,12 @@ def _py_files(folder):\n     )\n \n \n+@pytest.fixture(scope=\"session\")\n+def mockserver() -> Generator[MockServer]:",
      "comment": "TIL you can skip the 2nd and 3rd param of `Generator` :facepalm: ",
      "comment_id": 2230361719,
      "user": "Gallaecio",
      "created_at": "2025-07-25T07:22:47Z",
      "url": "https://github.com/scrapy/scrapy/pull/6960#discussion_r2230361719"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 6960,
      "file_path": "conftest.py",
      "line": 59,
      "side": "RIGHT",
      "diff_hunk": "@@ -48,6 +55,12 @@ def _py_files(folder):\n     )\n \n \n+@pytest.fixture(scope=\"session\")\n+def mockserver() -> Generator[MockServer]:",
      "comment": "It's very recent! Python 3.13 apparently (and I guess with `from __future__ import annotations` only the mypy version matters).",
      "comment_id": 2230400831,
      "user": "wRAR",
      "created_at": "2025-07-25T07:41:20Z",
      "url": "https://github.com/scrapy/scrapy/pull/6960#discussion_r2230400831"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 6938,
      "file_path": "tests/test_webclient.py",
      "line": 299,
      "side": "RIGHT",
      "diff_hunk": "@@ -218,96 +214,98 @@ def setUp(self):\n         r.putChild(b\"payload\", PayloadResource())\n         r.putChild(b\"broken\", BrokenDownloadResource())\n         r.putChild(b\"encoding\", EncodingResource())\n-        self.site = server.Site(r, timeout=None)\n-        self.wrapper = WrappingFactory(self.site)\n-        self.port = self._listen(self.wrapper)\n-        self.portno = self.port.getHost().port\n+        site = server.Site(r, timeout=None)\n+        return WrappingFactory(site)\n \n-    @inlineCallbacks\n-    def tearDown(self):\n-        yield self.port.stopListening()\n-        shutil.rmtree(self.tmpname)\n+    @async_yield_fixture\n+    async def server_port(self, wrapper):\n+        port = self._listen(wrapper)\n+\n+        yield port.getHost().port\n+\n+        await port.stopListening()\n \n-    def getURL(self, path):\n-        return f\"http://127.0.0.1:{self.portno}/{path}\"\n+    @pytest.fixture\n+    def server_url(self, server_port):\n+        return f\"http://127.0.0.1:{server_port}/\"\n \n     @inlineCallbacks\n-    def testPayload(self):\n+    def testPayload(self, server_url):\n         s = \"0123456789\" * 10\n-        body = yield getPage(self.getURL(\"payload\"), body=s)\n+        body = yield getPage(server_url + \"payload\", body=s)\n         assert body == to_bytes(s)\n \n     @inlineCallbacks\n-    def testHostHeader(self):\n+    def testHostHeader(self, server_port, server_url):\n         # if we pass Host header explicitly, it should be used, otherwise\n         # it should extract from url\n-        body = yield getPage(self.getURL(\"host\"))\n-        assert body == to_bytes(f\"127.0.0.1:{self.portno}\")\n-        body = yield getPage(self.getURL(\"host\"), headers={\"Host\": \"www.example.com\"})\n+        body = yield getPage(server_url + \"host\")\n+        assert body == to_bytes(f\"127.0.0.1:{server_port}\")\n+        body = yield getPage(server_url + \"host\", headers={\"Host\": \"www.example.com\"})\n         assert body == to_bytes(\"www.example.com\")\n \n     @inlineCallbacks\n-    def test_getPage(self):\n+    def test_getPage(self, server_url):\n         \"\"\"\n         L{client.getPage} returns a L{Deferred} which is called back with\n         the body of the response if the default method B{GET} is used.\n         \"\"\"\n-        body = yield getPage(self.getURL(\"file\"))\n+        body = yield getPage(server_url + \"file\")\n         assert body == b\"0123456789\"\n \n     @inlineCallbacks\n-    def test_getPageHead(self):\n+    def test_getPageHead(self, server_url):\n         \"\"\"\n         L{client.getPage} returns a L{Deferred} which is called back with\n         the empty string if the method is C{HEAD} and there is a successful\n         response code.\n         \"\"\"\n \n         def _getPage(method):\n-            return getPage(self.getURL(\"file\"), method=method)\n+            return getPage(server_url + \"file\", method=method)\n \n         body = yield _getPage(\"head\")\n         assert body == b\"\"\n         body = yield _getPage(\"HEAD\")\n         assert body == b\"\"\n \n     @inlineCallbacks\n-    def test_timeoutNotTriggering(self):\n+    def test_timeoutNotTriggering(self, server_port, server_url):\n         \"\"\"\n         When a non-zero timeout is passed to L{getPage} and the page is\n         retrieved before the timeout period elapses, the L{Deferred} is\n         called back with the contents of the page.\n         \"\"\"\n-        body = yield getPage(self.getURL(\"host\"), timeout=100)\n-        assert body == to_bytes(f\"127.0.0.1:{self.portno}\")\n+        body = yield getPage(server_url + \"host\", timeout=100)\n+        assert body == to_bytes(f\"127.0.0.1:{server_port}\")\n \n     @inlineCallbacks\n-    def test_timeoutTriggering(self):\n+    def test_timeoutTriggering(self, wrapper, server_url):\n         \"\"\"\n         When a non-zero timeout is passed to L{getPage} and that many\n         seconds elapse before the server responds to the request. the\n         L{Deferred} is errbacked with a L{error.TimeoutError}.\n         \"\"\"\n         with pytest.raises(defer.TimeoutError):\n-            yield getPage(self.getURL(\"wait\"), timeout=0.000001)\n+            yield getPage(server_url + \"wait\", timeout=0.000001)\n         # Clean up the server which is hanging around not doing\n         # anything.\n-        connected = list(self.wrapper.protocols.keys())\n+        connected = list(wrapper.protocols.keys())\n         # There might be nothing here if the server managed to already see\n         # that the connection was lost.\n         if connected:\n             connected[0].transport.loseConnection()\n \n     @inlineCallbacks",
      "comment": "This test uses `yield getPage(...)` but is not decorated with `@inlineCallbacks`, so the Deferred won\u2019t be awaited. Add `@inlineCallbacks` above the method or convert it to `async def` and use `await`.\n```suggestion\n    @inlineCallbacks\n    @inlineCallbacks\n```",
      "comment_id": 2188233341,
      "user": "Copilot",
      "created_at": "2025-07-06T12:29:12Z",
      "url": "https://github.com/scrapy/scrapy/pull/6938#discussion_r2188233341"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 6938,
      "file_path": "tests/test_webclient.py",
      "line": 282,
      "side": "RIGHT",
      "diff_hunk": "@@ -218,96 +214,98 @@ def setUp(self):\n         r.putChild(b\"payload\", PayloadResource())\n         r.putChild(b\"broken\", BrokenDownloadResource())\n         r.putChild(b\"encoding\", EncodingResource())\n-        self.site = server.Site(r, timeout=None)\n-        self.wrapper = WrappingFactory(self.site)\n-        self.port = self._listen(self.wrapper)\n-        self.portno = self.port.getHost().port\n+        site = server.Site(r, timeout=None)\n+        return WrappingFactory(site)\n \n-    @inlineCallbacks\n-    def tearDown(self):\n-        yield self.port.stopListening()\n-        shutil.rmtree(self.tmpname)\n+    @async_yield_fixture\n+    async def server_port(self, wrapper):\n+        port = self._listen(wrapper)\n+\n+        yield port.getHost().port\n+\n+        await port.stopListening()\n \n-    def getURL(self, path):\n-        return f\"http://127.0.0.1:{self.portno}/{path}\"\n+    @pytest.fixture\n+    def server_url(self, server_port):\n+        return f\"http://127.0.0.1:{server_port}/\"\n \n     @inlineCallbacks\n-    def testPayload(self):\n+    def testPayload(self, server_url):\n         s = \"0123456789\" * 10\n-        body = yield getPage(self.getURL(\"payload\"), body=s)\n+        body = yield getPage(server_url + \"payload\", body=s)\n         assert body == to_bytes(s)\n \n     @inlineCallbacks\n-    def testHostHeader(self):\n+    def testHostHeader(self, server_port, server_url):\n         # if we pass Host header explicitly, it should be used, otherwise\n         # it should extract from url\n-        body = yield getPage(self.getURL(\"host\"))\n-        assert body == to_bytes(f\"127.0.0.1:{self.portno}\")\n-        body = yield getPage(self.getURL(\"host\"), headers={\"Host\": \"www.example.com\"})\n+        body = yield getPage(server_url + \"host\")\n+        assert body == to_bytes(f\"127.0.0.1:{server_port}\")\n+        body = yield getPage(server_url + \"host\", headers={\"Host\": \"www.example.com\"})\n         assert body == to_bytes(\"www.example.com\")\n \n     @inlineCallbacks\n-    def test_getPage(self):\n+    def test_getPage(self, server_url):\n         \"\"\"\n         L{client.getPage} returns a L{Deferred} which is called back with\n         the body of the response if the default method B{GET} is used.\n         \"\"\"\n-        body = yield getPage(self.getURL(\"file\"))\n+        body = yield getPage(server_url + \"file\")\n         assert body == b\"0123456789\"\n \n     @inlineCallbacks\n-    def test_getPageHead(self):\n+    def test_getPageHead(self, server_url):\n         \"\"\"\n         L{client.getPage} returns a L{Deferred} which is called back with\n         the empty string if the method is C{HEAD} and there is a successful\n         response code.\n         \"\"\"\n \n         def _getPage(method):\n-            return getPage(self.getURL(\"file\"), method=method)\n+            return getPage(server_url + \"file\", method=method)\n \n         body = yield _getPage(\"head\")\n         assert body == b\"\"\n         body = yield _getPage(\"HEAD\")\n         assert body == b\"\"\n \n     @inlineCallbacks\n-    def test_timeoutNotTriggering(self):\n+    def test_timeoutNotTriggering(self, server_port, server_url):\n         \"\"\"\n         When a non-zero timeout is passed to L{getPage} and the page is\n         retrieved before the timeout period elapses, the L{Deferred} is\n         called back with the contents of the page.\n         \"\"\"\n-        body = yield getPage(self.getURL(\"host\"), timeout=100)\n-        assert body == to_bytes(f\"127.0.0.1:{self.portno}\")\n+        body = yield getPage(server_url + \"host\", timeout=100)\n+        assert body == to_bytes(f\"127.0.0.1:{server_port}\")\n \n     @inlineCallbacks",
      "comment": "This test body contains `yield getPage(...)` but the method is missing the `@inlineCallbacks` decorator. Either restore `@inlineCallbacks` or change it to an `async def` with `await`.\n```suggestion\n    @inlineCallbacks\n    @inlineCallbacks\n```",
      "comment_id": 2188233345,
      "user": "Copilot",
      "created_at": "2025-07-06T12:29:12Z",
      "url": "https://github.com/scrapy/scrapy/pull/6938#discussion_r2188233345"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 6942,
      "file_path": "tests/test_downloadermiddleware_retry.py",
      "line": 101,
      "side": "RIGHT",
      "diff_hunk": "@@ -91,12 +93,12 @@ def test_twistederrors(self):\n             ConnectError,\n             ConnectionDone,\n             ConnectionLost,\n-            ConnectionRefusedError,\n+            TxConnectionRefusedError,\n             defer.TimeoutError,\n             DNSLookupError,\n             ResponseFailed,\n             TCPTimedOutError,\n-            TimeoutError,\n+            TxTimeoutError,",
      "comment": "This checked builtin exceptions instead of Twisted ones, the test was passing because the builtin exceptions are subclasses of OSError which is retried.",
      "comment_id": 2187298147,
      "user": "wRAR",
      "created_at": "2025-07-05T13:53:02Z",
      "url": "https://github.com/scrapy/scrapy/pull/6942#discussion_r2187298147"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 6900,
      "file_path": "scrapy/core/engine.py",
      "line": 250,
      "side": "RIGHT",
      "diff_hunk": "@@ -217,17 +224,30 @@ async def _start_request_processing(self) -> None:\n         # Starts the processing of scheduled requests, as well as a periodic\n         # call to that processing method for scenarios where the scheduler\n         # reports having pending requests but returns none.\n-        assert self._slot is not None  # typing\n-        self._slot.nextcall.schedule()\n-        self._slot.heartbeat.start(self._SLOT_HEARTBEAT_INTERVAL)\n-\n-        while self._start and self.spider:\n-            await self._process_start_next()\n-            if not self.needs_backout():\n-                # Give room for the outcome of self._process_start_next() to be\n-                # processed before continuing with the next iteration.\n-                self._slot.nextcall.schedule()\n-                await self._slot.nextcall.wait()\n+        try:\n+            assert self._slot is not None  # typing\n+            self._slot.nextcall.schedule()\n+            self._slot.heartbeat.start(self._SLOT_HEARTBEAT_INTERVAL)\n+\n+            while self._start and self.spider:\n+                await self._process_start_next()\n+                if not self.needs_backout():\n+                    # Give room for the outcome of self._process_start_next() to be\n+                    # processed before continuing with the next iteration.\n+                    self._slot.nextcall.schedule()\n+                    await self._slot.nextcall.wait()\n+        except (asyncio.exceptions.CancelledError, CancelledError):\n+            # self.stop() has cancelled us, nothing to do\n+            return\n+        except Exception:\n+            # an error happened, log it and stop the engine\n+            self._start_request_processing_dfd = None\n+            logger.error(\n+                \"Error while processing requests from start()\",\n+                exc_info=True,\n+                extra={\"spider\": self.spider},\n+            )\n+            await maybe_deferred_to_future(self.stop())",
      "comment": "`self.stop()` can theoretically cause another unhandled exception here, but in practice I don't see it being possible (and, consequently, couldn't design a failing test), as `self.running` should be True here, and `self.close_spider()` is designed to swallow any possible exceptions.",
      "comment_id": 2160135080,
      "user": "wRAR",
      "created_at": "2025-06-21T19:54:52Z",
      "url": "https://github.com/scrapy/scrapy/pull/6900#discussion_r2160135080"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 6937,
      "file_path": "scrapy/utils/defer.py",
      "line": 124,
      "side": "LEFT",
      "diff_hunk": "@@ -108,22 +138,24 @@ def mustbe_deferred(\n \n \n def mustbe_deferred(\n-    f: Callable[_P, Deferred[_T] | Coroutine[Deferred[Any], Any, _T] | _T],\n+    f: Callable[_P, Deferred[_T] | _T],\n     *args: _P.args,\n     **kw: _P.kwargs,\n ) -> Deferred[_T]:\n     \"\"\"Same as twisted.internet.defer.maybeDeferred, but delay calling\n     callback/errback to next reactor loop\n     \"\"\"\n+    warnings.warn(\n+        \"scrapy.utils.defer.mustbe_deferred() is deprecated, use\"\n+        \" twisted.internet.defer.maybeDeferred(), with an explicit sleep if needed.\",\n+        category=ScrapyDeprecationWarning,\n+        stacklevel=2,\n+    )\n+    result: _T | Deferred[_T] | Failure\n     try:\n         result = f(*args, **kw)\n-    # FIXME: Hack to avoid introspecting tracebacks. This to speed up\n-    # processing of IgnoreRequest errors which are, by far, the most common\n-    # exception in Scrapy - see #125\n-    except IgnoreRequest as e:\n-        return defer_fail(failure.Failure(e))",
      "comment": "This was very dead code, I've already forgot my analysis but it was dead since about Scrapy 1.0.",
      "comment_id": 2183429860,
      "user": "wRAR",
      "created_at": "2025-07-03T18:02:37Z",
      "url": "https://github.com/scrapy/scrapy/pull/6937#discussion_r2183429860"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 6937,
      "file_path": "tests/test_pipeline_media.py",
      "line": 243,
      "side": "RIGHT",
      "diff_hunk": "@@ -227,15 +228,19 @@ def test_result_succeed(self):\n     @inlineCallbacks\n     def test_result_failure(self):\n         self.pipe.LOG_FAILED_RESULTS = False\n-        fail = Failure(Exception())\n+        exc = Exception(\"foo\")\n+        fail = Failure(exc)\n         req = Request(\n             \"http://url1\",\n             meta={\"response\": fail},\n             errback=self._errback,\n         )\n         item = {\"requests\": req}\n         new_item = yield self.pipe.process_item(item, self.spider)\n-        assert new_item[\"results\"] == [(False, fail)]\n+        assert len(new_item[\"results\"]) == 1\n+        assert new_item[\"results\"][0][0] is False\n+        assert isinstance(new_item[\"results\"][0][1], Failure)\n+        assert new_item[\"results\"][0][1].value == exc",
      "comment": "Comparing failures directly no longer works because @inlineCallbacks recreates them.",
      "comment_id": 2185112634,
      "user": "wRAR",
      "created_at": "2025-07-04T11:27:34Z",
      "url": "https://github.com/scrapy/scrapy/pull/6937#discussion_r2185112634"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 6928,
      "file_path": "tests/test_squeues_request.py",
      "line": 70,
      "side": "RIGHT",
      "diff_hunk": "@@ -19,198 +22,140 @@\n )\n from scrapy.utils.test import get_crawler\n \n+if TYPE_CHECKING:\n+    from scrapy.crawler import Crawler\n+\n+\n+HAVE_PEEK = hasattr(queuelib.queue.FifoMemoryQueue, \"peek\")\n \n-class TestBaseQueue:\n-    def setup_method(self):\n-        self.crawler = get_crawler(Spider)\n \n+@pytest.fixture\n+def crawler() -> Crawler:\n+    return get_crawler(Spider)\n \n-class RequestQueueTestMixin:\n-    def queue(self, base_path: Path):\n+\n+class TestRequestQueueBase(ABC):\n+    @property\n+    @abstractmethod\n+    def is_fifo(self) -> bool:\n         raise NotImplementedError\n \n-    def test_one_element_with_peek(self, tmp_path):\n-        if not hasattr(queuelib.queue.FifoMemoryQueue, \"peek\"):\n+    @pytest.mark.parametrize(\"test_peek\", [True, False])\n+    def test_one_element(self, q: queuelib.queue.BaseQueue, test_peek: bool):\n+        if test_peek and not HAVE_PEEK:\n             pytest.skip(\"The queuelib queues do not define peek\")\n-        q = self.queue(tmp_path)\n-        assert len(q) == 0\n-        assert q.peek() is None\n-        assert q.pop() is None\n-        req = Request(\"http://www.example.com\")\n-        q.push(req)\n-        assert len(q) == 1\n-        assert q.peek().url == req.url\n-        assert q.pop().url == req.url\n-        assert len(q) == 0\n-        assert q.peek() is None\n-        assert q.pop() is None\n-        q.close()\n-\n-    def test_one_element_without_peek(self, tmp_path):\n-        if hasattr(queuelib.queue.FifoMemoryQueue, \"peek\"):\n+        if not test_peek and HAVE_PEEK:\n             pytest.skip(\"The queuelib queues define peek\")\n-        q = self.queue(tmp_path)\n         assert len(q) == 0\n-        assert q.pop() is None\n+        assert q.peek() is None\n+        if test_peek:\n+            assert q.pop() is None\n         req = Request(\"http://www.example.com\")\n         q.push(req)\n         assert len(q) == 1\n-        with pytest.raises(\n-            NotImplementedError,\n-            match=\"The underlying queue class does not implement 'peek'\",\n-        ):\n-            q.peek()\n-        assert q.pop().url == req.url\n+        if test_peek:\n+            result = q.peek()\n+            assert result is not None\n+            assert result.url == req.url\n+        result = q.pop()\n+        assert result is not None\n+        assert result.url == req.url\n         assert len(q) == 0\n+        if test_peek:\n+            assert q.peek() is None\n         assert q.pop() is None\n         q.close()\n \n-\n-class FifoQueueMixin(RequestQueueTestMixin):\n-    def test_fifo_with_peek(self, tmp_path):\n-        if not hasattr(queuelib.queue.FifoMemoryQueue, \"peek\"):\n+    @pytest.mark.parametrize(\"test_peek\", [True, False])\n+    def test_order(self, q: queuelib.queue.BaseQueue, test_peek: bool):",
      "comment": "This merges 4 methods (test/don't test peek(), fifo/lifo) into 1.",
      "comment_id": 2173752653,
      "user": "wRAR",
      "created_at": "2025-06-29T13:03:05Z",
      "url": "https://github.com/scrapy/scrapy/pull/6928#discussion_r2173752653"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 6921,
      "file_path": "tests/test_scheduler.py",
      "line": 394,
      "side": "RIGHT",
      "diff_hunk": "@@ -389,7 +390,27 @@ def _incompatible(self):\n         scheduler.open(spider)\n \n     def test_incompatibility(self):\n-        with pytest.raises(\n-            ValueError, match=\"does not support CONCURRENT_REQUESTS_PER_IP\"\n-        ):\n-            self._incompatible()\n+        with warnings.catch_warnings():\n+            warnings.filterwarnings(\"ignore\")",
      "comment": "I thought add the deprecate test here but having a separate test seems better, I just filtering the warning to not show on the test logs.",
      "comment_id": 2173110992,
      "user": "Laerte",
      "created_at": "2025-06-28T03:56:06Z",
      "url": "https://github.com/scrapy/scrapy/pull/6921#discussion_r2173110992"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 6921,
      "file_path": "scrapy/core/scheduler.py",
      "line": 301,
      "side": "RIGHT",
      "diff_hunk": "@@ -296,6 +296,15 @@ def __init__(\n         self._smqclass: type[BaseQueue] | None = self._get_start_queue_cls(\n             crawler, \"MEMORY\"\n         )\n+        if (\n+            self.crawler\n+            and self.crawler.settings.getint(\"CONCURRENT_REQUESTS_PER_IP\") != 0",
      "comment": "After removing the default setting, `getint` may return None or raise if the key is missing. Consider using `getint(\"CONCURRENT_REQUESTS_PER_IP\", 0)` to provide a fallback and avoid unexpected errors.\n```suggestion\n            and self.crawler.settings.getint(\"CONCURRENT_REQUESTS_PER_IP\", 0) != 0\n```",
      "comment_id": 2173112674,
      "user": "Copilot",
      "created_at": "2025-06-28T04:04:48Z",
      "url": "https://github.com/scrapy/scrapy/pull/6921#discussion_r2173112674"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 6921,
      "file_path": "scrapy/settings/default_settings.py",
      "line": 48,
      "side": "LEFT",
      "diff_hunk": "@@ -45,7 +45,6 @@\n \n CONCURRENT_REQUESTS = 16\n CONCURRENT_REQUESTS_PER_DOMAIN = 8\n-CONCURRENT_REQUESTS_PER_IP = 0",
      "comment": "I think we should keep it here during the deprecation period.\r\n\r\nWe could use a `__getattr__` module-level function to log a deprecation warning upon import. I wonder if that means we also need to define `__all__` with the whole list of settings defined here, but to be honest, it may be better to break any `from scrapy.settings.default_settings import *`, seems like a bad practice and I cannot picture a valid reason to use that.",
      "comment_id": 2173142926,
      "user": "Gallaecio",
      "created_at": "2025-06-28T06:16:53Z",
      "url": "https://github.com/scrapy/scrapy/pull/6921#discussion_r2173142926"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 6921,
      "file_path": "scrapy/core/scheduler.py",
      "line": 304,
      "side": "RIGHT",
      "diff_hunk": "@@ -296,6 +296,15 @@ def __init__(\n         self._smqclass: type[BaseQueue] | None = self._get_start_queue_cls(\n             crawler, \"MEMORY\"\n         )\n+        if (\n+            self.crawler\n+            and self.crawler.settings.getint(\"CONCURRENT_REQUESTS_PER_IP\") != 0\n+        ):\n+            warn(\n+                \"CONCURRENT_REQUESTS_PER_IP setting is deprecated, use CONCURRENT_REQUESTS_PER_DOMAIN instead.\",",
      "comment": "```suggestion\r\n                \"The CONCURRENT_REQUESTS_PER_IP setting is deprecated, use CONCURRENT_REQUESTS_PER_DOMAIN instead.\",\r\n```",
      "comment_id": 2173143291,
      "user": "Gallaecio",
      "created_at": "2025-06-28T06:19:34Z",
      "url": "https://github.com/scrapy/scrapy/pull/6921#discussion_r2173143291"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 6921,
      "file_path": "scrapy/core/scheduler.py",
      "line": 301,
      "side": "RIGHT",
      "diff_hunk": "@@ -296,6 +296,15 @@ def __init__(\n         self._smqclass: type[BaseQueue] | None = self._get_start_queue_cls(\n             crawler, \"MEMORY\"\n         )\n+        if (\n+            self.crawler\n+            and self.crawler.settings.getint(\"CONCURRENT_REQUESTS_PER_IP\") != 0",
      "comment": "First off, I think this is OK.\r\n\r\nHowever, alternatively, it may be worth considering to implement a deprecated setting reporting logic on the `get` method of `BaseSettings` that warns about a deprecated setting upon reading it (and in `set` upon writing it?) if the setting priority value is not 0 (0 means its value comes from `default_settings.py`, any other value means it was set by the user).\r\n\r\nIt has the advantage that it will also warn about the setting when used in third-party and user-defined components that may be currently relying on the setting.\r\n\r\nOn the other hand, if a third-party or user-defined component is relying on that setting and for some reason wants to keep relying on that setting (which seems weird for this specific setting, but may make sense for other settings we may deprecate in the future), there would be no way to silence this warning. Which makes me think this approach may also warrant adding a setting to allow allow-listing settings to prevent such warnings for them.\r\n\r\n(edit: removed another alternative suggestion that does not really work provided we keep the current `default_settings.py` definition, which I think we should keep)",
      "comment_id": 2173143906,
      "user": "Gallaecio",
      "created_at": "2025-06-28T06:22:54Z",
      "url": "https://github.com/scrapy/scrapy/pull/6921#discussion_r2173143906"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 6921,
      "file_path": "scrapy/settings/default_settings.py",
      "line": 48,
      "side": "LEFT",
      "diff_hunk": "@@ -45,7 +45,6 @@\n \n CONCURRENT_REQUESTS = 16\n CONCURRENT_REQUESTS_PER_DOMAIN = 8\n-CONCURRENT_REQUESTS_PER_IP = 0",
      "comment": "> We could use a __getattr__ module-level function to log a deprecation warning upon import.\r\n\r\nWhy? I don't think editing `default_settings.py` is supported.",
      "comment_id": 2173159484,
      "user": "wRAR",
      "created_at": "2025-06-28T07:37:39Z",
      "url": "https://github.com/scrapy/scrapy/pull/6921#discussion_r2173159484"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 6921,
      "file_path": "scrapy/settings/default_settings.py",
      "line": 48,
      "side": "LEFT",
      "diff_hunk": "@@ -45,7 +45,6 @@\n \n CONCURRENT_REQUESTS = 16\n CONCURRENT_REQUESTS_PER_DOMAIN = 8\n-CONCURRENT_REQUESTS_PER_IP = 0",
      "comment": "Ah, you mean getting the value from importing it in the user code via `from scrapy.settings.default_settings import *`. I'm fine with breaking that.",
      "comment_id": 2173159648,
      "user": "wRAR",
      "created_at": "2025-06-28T07:38:37Z",
      "url": "https://github.com/scrapy/scrapy/pull/6921#discussion_r2173159648"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 6921,
      "file_path": "scrapy/settings/default_settings.py",
      "line": 48,
      "side": "LEFT",
      "diff_hunk": "@@ -45,7 +45,6 @@\n \n CONCURRENT_REQUESTS = 16\n CONCURRENT_REQUESTS_PER_DOMAIN = 8\n-CONCURRENT_REQUESTS_PER_IP = 0",
      "comment": "> I'm fine with breaking that.\r\n\r\nWhile I am OK with breaking it for this specific setting, I would not make it a general rule. For example, checking `scrapy.settings.default_settings.TWISTED_REACTOR` seems like a nice way to check what the default reactor is in the installed version of Scrapy without specifically checking for the Scrapy version.",
      "comment_id": 2173200494,
      "user": "Gallaecio",
      "created_at": "2025-06-28T10:37:41Z",
      "url": "https://github.com/scrapy/scrapy/pull/6921#discussion_r2173200494"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 6921,
      "file_path": "scrapy/settings/default_settings.py",
      "line": 48,
      "side": "LEFT",
      "diff_hunk": "@@ -45,7 +45,6 @@\n \n CONCURRENT_REQUESTS = 16\n CONCURRENT_REQUESTS_PER_DOMAIN = 8\n-CONCURRENT_REQUESTS_PER_IP = 0",
      "comment": "https://github.com/search?q=%22from+scrapy.settings.default_settings%22&type=code\r\n\r\nhttps://github.com/search?q=%22from+scrapy.settings+import+default_settings%22&type=code",
      "comment_id": 2173237184,
      "user": "wRAR",
      "created_at": "2025-06-28T13:06:47Z",
      "url": "https://github.com/scrapy/scrapy/pull/6921#discussion_r2173237184"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 6921,
      "file_path": "scrapy/settings/default_settings.py",
      "line": 48,
      "side": "LEFT",
      "diff_hunk": "@@ -45,7 +45,6 @@\n \n CONCURRENT_REQUESTS = 16\n CONCURRENT_REQUESTS_PER_DOMAIN = 8\n-CONCURRENT_REQUESTS_PER_IP = 0",
      "comment": "I added `__all__` and logic to emit deprecation message when someone try to import CONCURRENT_REQUESTS_PER_IP directly.",
      "comment_id": 2173268214,
      "user": "Laerte",
      "created_at": "2025-06-28T14:04:36Z",
      "url": "https://github.com/scrapy/scrapy/pull/6921#discussion_r2173268214"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 6921,
      "file_path": "scrapy/settings/__init__.py",
      "line": 152,
      "side": "RIGHT",
      "diff_hunk": "@@ -147,6 +149,13 @@ def get(self, name: _SettingsKeyT, default: Any = None) -> Any:\n         :param default: the value to return if no setting is found\n         :type default: object\n         \"\"\"\n+        if name == \"CONCURRENT_REQUESTS_PER_IP\" and (self[name] or default) != 0:",
      "comment": "The condition `(self[name] or default) != 0` will be true even when the setting isn't defined (default is `None`), causing a warning on every access. Consider checking if the setting was explicitly provided, for example by inspecting an internal storage like `if name in self._values and self[name] != 0:`.\n```suggestion\n        if name == \"CONCURRENT_REQUESTS_PER_IP\" and name in self.attributes and self[name] != 0:\n```",
      "comment_id": 2173288993,
      "user": "Copilot",
      "created_at": "2025-06-28T14:34:29Z",
      "url": "https://github.com/scrapy/scrapy/pull/6921#discussion_r2173288993"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 6921,
      "file_path": "scrapy/settings/default_settings.py",
      "line": 550,
      "side": "RIGHT",
      "diff_hunk": "@@ -358,3 +532,19 @@\n USER_AGENT = f\"Scrapy/{import_module('scrapy').__version__} (+https://scrapy.org)\"\n \n WARN_ON_GENERATOR_RETURN_VALUE = True\n+\n+\n+def __getattr__(name: str):\n+    if name == \"CONCURRENT_REQUESTS_PER_IP\":\n+        import warnings\n+\n+        from scrapy.exceptions import ScrapyDeprecationWarning\n+\n+        warnings.warn(\n+            \"The scrapy.settings.default_settings.CONCURRENT_REQUESTS_PER_IP attribute is deprecated, use scrapy.settings.default_settings.CONCURRENT_REQUESTS_PER_DOMAIN instead.\",\n+            ScrapyDeprecationWarning,\n+            stacklevel=2,\n+        )\n+        return 0\n+\n+    raise AttributeError",
      "comment": "[nitpick] Raising `AttributeError` without a message can obscure debugging. Consider including `name` in the exception, e.g., `raise AttributeError(f\"module {__name__} has no attribute {name}\")`.\n```suggestion\n    raise AttributeError(f\"module {__name__} has no attribute {name}\")\n```",
      "comment_id": 2173289005,
      "user": "Copilot",
      "created_at": "2025-06-28T14:34:30Z",
      "url": "https://github.com/scrapy/scrapy/pull/6921#discussion_r2173289005"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 6921,
      "file_path": "tests/test_scheduler.py",
      "line": 394,
      "side": "RIGHT",
      "diff_hunk": "@@ -389,7 +390,9 @@ def _incompatible(self):\n         scheduler.open(spider)\n \n     def test_incompatibility(self):\n-        with pytest.raises(\n-            ValueError, match=\"does not support CONCURRENT_REQUESTS_PER_IP\"\n-        ):\n-            self._incompatible()\n+        with warnings.catch_warnings():\n+            warnings.filterwarnings(\"ignore\")",
      "comment": "This ignores all warnings globally, which may hide unrelated issues. It\u2019s better to target the specific deprecation warning, e.g. `warnings.filterwarnings(\"ignore\", category=ScrapyDeprecationWarning)`.\n```suggestion\n            warnings.filterwarnings(\"ignore\", category=DeprecationWarning)\n```",
      "comment_id": 2173289012,
      "user": "Copilot",
      "created_at": "2025-06-28T14:34:30Z",
      "url": "https://github.com/scrapy/scrapy/pull/6921#discussion_r2173289012"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 6921,
      "file_path": "scrapy/settings/__init__.py",
      "line": 152,
      "side": "RIGHT",
      "diff_hunk": "@@ -147,6 +149,13 @@ def get(self, name: _SettingsKeyT, default: Any = None) -> Any:\n         :param default: the value to return if no setting is found\n         :type default: object\n         \"\"\"\n+        if name == \"CONCURRENT_REQUESTS_PER_IP\" and (self[name] or default) != 0:",
      "comment": "> `(self[name] or default) != 0`\r\n\r\nWon\u2019t this always be `True`? (unless the `default` parameter itself is set to `0`)\r\n\r\n```python\r\n>>> (0 or None) != 0\r\nTrue\r\n```",
      "comment_id": 2174321388,
      "user": "Gallaecio",
      "created_at": "2025-06-30T06:30:31Z",
      "url": "https://github.com/scrapy/scrapy/pull/6921#discussion_r2174321388"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 6921,
      "file_path": "scrapy/settings/default_settings.py",
      "line": 538,
      "side": "RIGHT",
      "diff_hunk": "@@ -358,3 +532,19 @@\n USER_AGENT = f\"Scrapy/{import_module('scrapy').__version__} (+https://scrapy.org)\"\n \n WARN_ON_GENERATOR_RETURN_VALUE = True\n+\n+\n+def __getattr__(name: str):\n+    if name == \"CONCURRENT_REQUESTS_PER_IP\":",
      "comment": "I wonder if we could share some logic with the code in the get method.",
      "comment_id": 2174325129,
      "user": "Gallaecio",
      "created_at": "2025-06-30T06:33:24Z",
      "url": "https://github.com/scrapy/scrapy/pull/6921#discussion_r2174325129"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 6921,
      "file_path": "scrapy/settings/default_settings.py",
      "line": 538,
      "side": "RIGHT",
      "diff_hunk": "@@ -358,3 +532,19 @@\n USER_AGENT = f\"Scrapy/{import_module('scrapy').__version__} (+https://scrapy.org)\"\n \n WARN_ON_GENERATOR_RETURN_VALUE = True\n+\n+\n+def __getattr__(name: str):\n+    if name == \"CONCURRENT_REQUESTS_PER_IP\":",
      "comment": "The message is different, I think the only shareable thing here is the warning part?",
      "comment_id": 2174652963,
      "user": "Laerte",
      "created_at": "2025-06-30T09:37:05Z",
      "url": "https://github.com/scrapy/scrapy/pull/6921#discussion_r2174652963"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 6921,
      "file_path": "scrapy/settings/__init__.py",
      "line": 152,
      "side": "RIGHT",
      "diff_hunk": "@@ -147,6 +149,13 @@ def get(self, name: _SettingsKeyT, default: Any = None) -> Any:\n         :param default: the value to return if no setting is found\n         :type default: object\n         \"\"\"\n+        if name == \"CONCURRENT_REQUESTS_PER_IP\" and (self[name] or default) != 0:",
      "comment": "Yeah I did this way because some tests was failing since this setting was evaluating to null: https://github.com/scrapy/scrapy/pull/6921/commits/3ad3b24bfad09c15f8b697fcd4954cb19113e604 but I refactored this condition now, please take a look (also the calls of `CONCURRENT_REQUESTS_PER_IP` setting use getint method that makes the default be 0. https://github.com/search?q=repo%3Ascrapy%2Fscrapy%20(%22CONCURRENT_REQUESTS_PER_IP%22&type=code",
      "comment_id": 2174686864,
      "user": "Laerte",
      "created_at": "2025-06-30T09:53:59Z",
      "url": "https://github.com/scrapy/scrapy/pull/6921#discussion_r2174686864"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 6921,
      "file_path": "scrapy/settings/__init__.py",
      "line": 152,
      "side": "RIGHT",
      "diff_hunk": "@@ -147,6 +149,13 @@ def get(self, name: _SettingsKeyT, default: Any = None) -> Any:\n         :param default: the value to return if no setting is found\n         :type default: object\n         \"\"\"\n+        if name == \"CONCURRENT_REQUESTS_PER_IP\" and (self[name] or default) != 0:",
      "comment": "> also the calls of `CONCURRENT_REQUESTS_PER_IP` setting use getint method that makes the default be 0\r\n\r\nThat is a good point, but I think we should assume this (or more importantly, future settings we might deprecate this way) may also be read with a more generic getter, i.e. `get()` or `[]`, besides their type-specific getter.",
      "comment_id": 2174842325,
      "user": "Gallaecio",
      "created_at": "2025-06-30T11:23:16Z",
      "url": "https://github.com/scrapy/scrapy/pull/6921#discussion_r2174842325"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 6921,
      "file_path": "scrapy/settings/default_settings.py",
      "line": 538,
      "side": "RIGHT",
      "diff_hunk": "@@ -358,3 +532,19 @@\n USER_AGENT = f\"Scrapy/{import_module('scrapy').__version__} (+https://scrapy.org)\"\n \n WARN_ON_GENERATOR_RETURN_VALUE = True\n+\n+\n+def __getattr__(name: str):\n+    if name == \"CONCURRENT_REQUESTS_PER_IP\":",
      "comment": "While making the messages as specific as possible is usually a good thing, I am not sure if it is necessary here. If the message focuses on stating that setting A is deprecated, and optionally providing guidelines for replacement, provided the traceback points to the right line (and I think that is the case in both cases, and both use stacklevel=2 for that), I think the message does not require further specificity.",
      "comment_id": 2174849564,
      "user": "Gallaecio",
      "created_at": "2025-06-30T11:27:07Z",
      "url": "https://github.com/scrapy/scrapy/pull/6921#discussion_r2174849564"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 6921,
      "file_path": "scrapy/settings/default_settings.py",
      "line": 538,
      "side": "RIGHT",
      "diff_hunk": "@@ -358,3 +532,19 @@\n USER_AGENT = f\"Scrapy/{import_module('scrapy').__version__} (+https://scrapy.org)\"\n \n WARN_ON_GENERATOR_RETURN_VALUE = True\n+\n+\n+def __getattr__(name: str):\n+    if name == \"CONCURRENT_REQUESTS_PER_IP\":",
      "comment": "It is not a big deal, though. Reading myself, it is starting to sound like over-engineering.",
      "comment_id": 2174854072,
      "user": "Gallaecio",
      "created_at": "2025-06-30T11:29:38Z",
      "url": "https://github.com/scrapy/scrapy/pull/6921#discussion_r2174854072"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 6921,
      "file_path": "scrapy/settings/__init__.py",
      "line": 152,
      "side": "RIGHT",
      "diff_hunk": "@@ -147,6 +149,13 @@ def get(self, name: _SettingsKeyT, default: Any = None) -> Any:\n         :param default: the value to return if no setting is found\n         :type default: object\n         \"\"\"\n+        if name == \"CONCURRENT_REQUESTS_PER_IP\" and (self[name] or default) != 0:",
      "comment": "Sounds good! Since we implement `__getitem__` we don\u2019t need to call `.get()` in this case, thank you!",
      "comment_id": 2174868546,
      "user": "Laerte",
      "created_at": "2025-06-30T11:38:16Z",
      "url": "https://github.com/scrapy/scrapy/pull/6921#discussion_r2174868546"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 6897,
      "file_path": "scrapy/extensions/feedexport.py",
      "line": 189,
      "side": "RIGHT",
      "diff_hunk": "@@ -185,7 +185,9 @@ def store(self, file: IO[bytes]) -> Deferred[None] | None:\n @implementer(IFeedStorage)\n class FileFeedStorage:\n     def __init__(self, uri: str, *, feed_options: dict[str, Any] | None = None):\n-        self.path: str = file_uri_to_path(uri)\n+        self.path: str = (\n+            file_uri_to_path(uri) if uri.startswith(\"file://\") else str(Path(uri))",
      "comment": "Not sure what does `str(Path(uri))` achieve, does it do any normalization or is it a no-op?",
      "comment_id": 2159919185,
      "user": "wRAR",
      "created_at": "2025-06-21T07:26:31Z",
      "url": "https://github.com/scrapy/scrapy/pull/6897#discussion_r2159919185"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 6897,
      "file_path": "scrapy/extensions/feedexport.py",
      "line": 189,
      "side": "RIGHT",
      "diff_hunk": "@@ -185,7 +185,9 @@ def store(self, file: IO[bytes]) -> Deferred[None] | None:\n @implementer(IFeedStorage)\n class FileFeedStorage:\n     def __init__(self, uri: str, *, feed_options: dict[str, Any] | None = None):\n-        self.path: str = file_uri_to_path(uri)\n+        self.path: str = (\n+            file_uri_to_path(uri) if uri.startswith(\"file://\") else str(Path(uri))",
      "comment": "`str(Path(uri))` performs path normalization that's useful in this context, for example, ensures native path separators (\\ on Windows, / on Unix). If you prefer to keep it minimal, we could just use uri directly since the main fix is avoiding file_uri_to_path() on non-URI paths, please let me know",
      "comment_id": 2159995635,
      "user": "thalissonvs",
      "created_at": "2025-06-21T10:03:16Z",
      "url": "https://github.com/scrapy/scrapy/pull/6897#discussion_r2159995635"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 6897,
      "file_path": "scrapy/extensions/feedexport.py",
      "line": 189,
      "side": "RIGHT",
      "diff_hunk": "@@ -185,7 +185,9 @@ def store(self, file: IO[bytes]) -> Deferred[None] | None:\n @implementer(IFeedStorage)\n class FileFeedStorage:\n     def __init__(self, uri: str, *, feed_options: dict[str, Any] | None = None):\n-        self.path: str = file_uri_to_path(uri)\n+        self.path: str = (\n+            file_uri_to_path(uri) if uri.startswith(\"file://\") else str(Path(uri))",
      "comment": "I think it's fine to keep it minimal, as `self.path` is already passed to `Path()` anyway in `open()` (I think `self.path` itself is still a string because changing it would break compatibility with `FileFeedStorage` subclasses).",
      "comment_id": 2160063716,
      "user": "wRAR",
      "created_at": "2025-06-21T15:21:36Z",
      "url": "https://github.com/scrapy/scrapy/pull/6897#discussion_r2160063716"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 6875,
      "file_path": "scrapy/cmdline.py",
      "line": 35,
      "side": "RIGHT",
      "diff_hunk": "@@ -32,7 +32,7 @@ class ScrapyArgumentParser(argparse.ArgumentParser):\n     def _parse_optional(\n         self, arg_string: str\n     ) -> tuple[argparse.Action | None, str, str | None] | None:\n-        # if starts with -: it means that is a parameter not a argument\n+        # if starts with -: it means that it is a parameter not an argument",
      "comment": "While at it, what about:\r\n\r\n```suggestion\r\n        # Support something like \u2018-o -:json\u2019, where \u2018-:json\u2019 is a value for \r\n        # \u2018-o\u2019, not another parameter.\r\n```",
      "comment_id": 2133553267,
      "user": "Gallaecio",
      "created_at": "2025-06-07T07:24:57Z",
      "url": "https://github.com/scrapy/scrapy/pull/6875#discussion_r2133553267"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 6875,
      "file_path": "scrapy/cmdline.py",
      "line": 36,
      "side": "RIGHT",
      "diff_hunk": "@@ -32,7 +32,7 @@ class ScrapyArgumentParser(argparse.ArgumentParser):\n     def _parse_optional(\n         self, arg_string: str\n     ) -> tuple[argparse.Action | None, str, str | None] | None:\n-        # if starts with -: it means that is a parameter not a argument\n+        # if starts with -: it means that it is a parameter not an argument\n         if arg_string[:2] == \"-:\":",
      "comment": "And you could also take the chance to switch this to `startswith()`.\r\n\r\n```suggestion\r\n        if arg_string.startswith(\"-:\"):\r\n```\r\n\r\n@wRAR I checked to see if there was something in Ruff that we could enable to detect these cases, but it seems not. They may add it if they ever [port Sonar rules](https://github.com/astral-sh/ruff/issues/4935).",
      "comment_id": 2133573543,
      "user": "Gallaecio",
      "created_at": "2025-06-07T07:35:13Z",
      "url": "https://github.com/scrapy/scrapy/pull/6875#discussion_r2133573543"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 6875,
      "file_path": "scrapy/cmdline.py",
      "line": 36,
      "side": "RIGHT",
      "diff_hunk": "@@ -32,7 +32,7 @@ class ScrapyArgumentParser(argparse.ArgumentParser):\n     def _parse_optional(\n         self, arg_string: str\n     ) -> tuple[argparse.Action | None, str, str | None] | None:\n-        # if starts with -: it means that is a parameter not a argument\n+        # if starts with -: it means that it is a parameter not an argument\n         if arg_string[:2] == \"-:\":",
      "comment": "Thank you for all the suggestions!  \r\nI'm happy with all the improvements, including the comment and the use of `startswith()`.  \r\nPlease feel free to commit them directly if you'd like \u2014 I appreciate your help!",
      "comment_id": 2133592469,
      "user": "nakanoh",
      "created_at": "2025-06-07T07:45:14Z",
      "url": "https://github.com/scrapy/scrapy/pull/6875#discussion_r2133592469"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 6846,
      "file_path": "tests/test_downloader_handler_twisted_http2.py",
      "line": 119,
      "side": "RIGHT",
      "diff_hunk": "@@ -102,70 +107,60 @@ def test_download_broken_content_allow_data_loss_via_setting(self, url=\"broken\")\n     def test_download_broken_chunked_content_allow_data_loss_via_setting(self):\n         pytest.skip(self.HTTP2_DATALOSS_SKIP_REASON)\n \n-    def test_concurrent_requests_same_domain(self):\n+    @deferred_f_from_coro_f\n+    async def test_concurrent_requests_same_domain(self):\n         spider = Spider(\"foo\")\n \n         request1 = Request(self.getURL(\"file\"))\n-        d1 = self.download_request(request1, spider)\n-        d1.addCallback(lambda r: r.body)\n-        d1.addCallback(self.assertEqual, b\"0123456789\")\n+        response1 = await self.download_request(request1, spider)\n+        assert response1.body == b\"0123456789\"\n \n         request2 = Request(self.getURL(\"echo\"), method=\"POST\")\n-        d2 = self.download_request(request2, spider)\n-        d2.addCallback(lambda r: r.headers[\"Content-Length\"])\n-        d2.addCallback(self.assertEqual, b\"79\")\n-\n-        return defer.DeferredList([d1, d2])\n+        response2 = await self.download_request(request2, spider)",
      "comment": "The original test executed both requests concurrently via DeferredList, but this awaits the first before starting the second, losing concurrency coverage. Consider running both with `asyncio.gather` or using DeferredList to preserve the concurrent request behavior.",
      "comment_id": 2117788017,
      "user": "Copilot",
      "created_at": "2025-05-31T12:32:01Z",
      "url": "https://github.com/scrapy/scrapy/pull/6846#discussion_r2117788017"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 6852,
      "file_path": "tests/test_utils_defer.py",
      "line": 197,
      "side": "RIGHT",
      "diff_hunk": "@@ -194,6 +194,27 @@ def callable(o: int, results: list[int]) -> Deferred[None] | None:\n         results.append(o)\n         return None\n \n+    def callable_wrapped(",
      "comment": "The changes in this test are to check that the parallel limit is not violated.",
      "comment_id": 2121508106,
      "user": "wRAR",
      "created_at": "2025-06-02T15:28:35Z",
      "url": "https://github.com/scrapy/scrapy/pull/6852#discussion_r2121508106"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 6866,
      "file_path": "scrapy/utils/test.py",
      "line": 121,
      "side": "RIGHT",
      "diff_hunk": "@@ -117,6 +117,11 @@ def get_reactor_settings() -> dict[str, Any]:\n     settings, so tests that run the crawler in the current process may need to\n     pass a correct ``\"TWISTED_REACTOR\"`` setting value when creating it.\n     \"\"\"\n+    if not is_reactor_installed():\n+        raise RuntimeError(",
      "comment": "Writing a test for this would need running a standalone script, but I checked this with `scrapinghub-entrypoint-scrapy` before https://github.com/scrapinghub/scrapinghub-entrypoint-scrapy/pull/94 and it produces the correct exception.",
      "comment_id": 2131938592,
      "user": "wRAR",
      "created_at": "2025-06-06T10:21:59Z",
      "url": "https://github.com/scrapy/scrapy/pull/6866#discussion_r2131938592"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 6873,
      "file_path": "tests/test_utils_log.py",
      "line": 104,
      "side": "LEFT",
      "diff_hunk": "@@ -100,21 +99,19 @@ def test_filtered_out_level(self):\n         assert self.crawler.stats.get_value(\"log_count/INFO\") is None\n \n \n-class StreamLoggerTest(unittest.TestCase):\n-    def setUp(self):",
      "comment": "pytest overrides `sys.stdout` after the fixtures etc. run, so merging the code into the test method was the easiest way to reimplement this",
      "comment_id": 2132860636,
      "user": "wRAR",
      "created_at": "2025-06-06T20:18:34Z",
      "url": "https://github.com/scrapy/scrapy/pull/6873#discussion_r2132860636"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 6858,
      "file_path": "scrapy/core/downloader/__init__.py",
      "line": 224,
      "side": "RIGHT",
      "diff_hunk": "@@ -218,6 +221,10 @@ def _process_queue(self, spider: Spider, slot: Slot) -> None:\n                 self._process_queue(spider, slot)\n                 break\n \n+    def _latercall(self, spider: Spider, slot: Slot) -> None:",
      "comment": "This is a replacement for checking `slot.latercall.active()` to see if the scheduled call was already called or not.",
      "comment_id": 2126859631,
      "user": "wRAR",
      "created_at": "2025-06-04T15:14:26Z",
      "url": "https://github.com/scrapy/scrapy/pull/6858#discussion_r2126859631"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 6845,
      "file_path": "scrapy/commands/crawl.py",
      "line": 35,
      "side": "LEFT",
      "diff_hunk": "@@ -30,17 +28,7 @@ def run(self, args: list[str], opts: argparse.Namespace) -> None:\n         spname = args[0]\n \n         assert self.crawler_process\n-        crawl_defer = self.crawler_process.crawl(spname, **opts.spargs)\n-\n-        if getattr(crawl_defer, \"result\", None) is not None and issubclass(",
      "comment": "This was a no-op in the current code, apparently, see #6820",
      "comment_id": 2115748682,
      "user": "wRAR",
      "created_at": "2025-05-30T11:30:06Z",
      "url": "https://github.com/scrapy/scrapy/pull/6845#discussion_r2115748682"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 6845,
      "file_path": "scrapy/commands/crawl.py",
      "line": 43,
      "side": "LEFT",
      "diff_hunk": "@@ -30,17 +28,7 @@ def run(self, args: list[str], opts: argparse.Namespace) -> None:\n         spname = args[0]\n \n         assert self.crawler_process\n-        crawl_defer = self.crawler_process.crawl(spname, **opts.spargs)\n-\n-        if getattr(crawl_defer, \"result\", None) is not None and issubclass(\n-            cast(Failure, crawl_defer.result).type, Exception\n-        ):\n+        self.crawler_process.crawl(spname, **opts.spargs)\n+        self.crawler_process.start()\n+        if self.crawler_process.bootstrap_failed:\n             self.exitcode = 1\n-        else:\n-            self.crawler_process.start()\n-\n-            if self.crawler_process.bootstrap_failed or (\n-                hasattr(self.crawler_process, \"has_exception\")",
      "comment": "This was a no-op since introduction as nothing sets that.",
      "comment_id": 2115749426,
      "user": "wRAR",
      "created_at": "2025-05-30T11:30:26Z",
      "url": "https://github.com/scrapy/scrapy/pull/6845#discussion_r2115749426"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 6845,
      "file_path": "tests/test_commands.py",
      "line": 150,
      "side": "RIGHT",
      "diff_hunk": "@@ -124,6 +125,221 @@ def setUp(self):\n         self.env[\"SCRAPY_SETTINGS_MODULE\"] = f\"{self.project_name}.settings\"\n \n \n+class TestCommandCrawlerProcess(TestCommandBase):\n+    \"\"\"Test that the command uses the expected kind of *CrawlerProcess\n+    and produces expected errors when needed.\"\"\"\n+\n+    name = \"crawltest\"\n+\n+    NORMAL_MSG = \"Type of self.crawler_process: <class 'scrapy.crawler.CrawlerProcess'>\"\n+    ASYNC_MSG = (\n+        \"Type of self.crawler_process: <class 'scrapy.crawler.AsyncCrawlerProcess'>\"\n+    )\n+\n+    def setUp(self):\n+        super().setUp()\n+        (self.cwd / self.project_name / \"commands\").mkdir(exist_ok=True)\n+        (self.cwd / self.project_name / \"commands\" / \"__init__.py\").touch()\n+        (self.cwd / self.project_name / \"commands\" / f\"{self.name}.py\").write_text(\"\"\"\n+from scrapy.commands.crawl import Command\n+\n+class CrawlerProcessCrawlCommand(Command):\n+    requires_project = True\n+\n+    def run(self, args, opts):\n+        print(f\"Type of self.crawler_process: {type(self.crawler_process)}\")",
      "comment": "This can instead go into production code (with different wording), it may be helpful for debugging of e.g. why a specific reactor value was used. I don't know if mentioning CrawlerProcess in `scrapy crawl` logs can be confusing for users, probably not.",
      "comment_id": 2115755264,
      "user": "wRAR",
      "created_at": "2025-05-30T11:33:06Z",
      "url": "https://github.com/scrapy/scrapy/pull/6845#discussion_r2115755264"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 6845,
      "file_path": "tests/test_utils_defer.py",
      "line": 259,
      "side": "RIGHT",
      "diff_hunk": "@@ -256,7 +256,7 @@ async def coroutine() -> int:\n     @inlineCallbacks\n     def test_coroutine_asyncio(self):\n         async def coroutine() -> int:\n-            await asyncio.sleep(0)\n+            await asyncio.sleep(0.01)",
      "comment": "`asyncio.sleep(0)` doesn't require an event loop, it turns out.",
      "comment_id": 2115757816,
      "user": "wRAR",
      "created_at": "2025-05-30T11:34:18Z",
      "url": "https://github.com/scrapy/scrapy/pull/6845#discussion_r2115757816"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 6845,
      "file_path": "tests/test_commands.py",
      "line": 323,
      "side": "RIGHT",
      "diff_hunk": "@@ -124,6 +125,221 @@ def setUp(self):\n         self.env[\"SCRAPY_SETTINGS_MODULE\"] = f\"{self.project_name}.settings\"\n \n \n+class TestCommandCrawlerProcess(TestCommandBase):\n+    \"\"\"Test that the command uses the expected kind of *CrawlerProcess\n+    and produces expected errors when needed.\"\"\"\n+\n+    name = \"crawltest\"\n+\n+    NORMAL_MSG = \"Type of self.crawler_process: <class 'scrapy.crawler.CrawlerProcess'>\"\n+    ASYNC_MSG = (\n+        \"Type of self.crawler_process: <class 'scrapy.crawler.AsyncCrawlerProcess'>\"\n+    )\n+\n+    def setUp(self):\n+        super().setUp()\n+        (self.cwd / self.project_name / \"commands\").mkdir(exist_ok=True)\n+        (self.cwd / self.project_name / \"commands\" / \"__init__.py\").touch()\n+        (self.cwd / self.project_name / \"commands\" / f\"{self.name}.py\").write_text(\"\"\"\n+from scrapy.commands.crawl import Command\n+\n+class CrawlerProcessCrawlCommand(Command):\n+    requires_project = True\n+\n+    def run(self, args, opts):\n+        print(f\"Type of self.crawler_process: {type(self.crawler_process)}\")\n+        super().run(args, opts)\n+\"\"\")\n+\n+        self._append_settings(f\"COMMANDS_MODULE = '{self.project_name}.commands'\\n\")\n+\n+        (self.cwd / self.project_name / \"spiders\" / \"sp.py\").write_text(\"\"\"\n+import scrapy\n+\n+class MySpider(scrapy.Spider):\n+    name = 'sp'\n+\n+    custom_settings = {}\n+\n+    async def start(self):\n+        self.logger.debug('It works!')\n+        return\n+        yield\n+\"\"\")\n+\n+        (self.cwd / self.project_name / \"spiders\" / \"aiosp.py\").write_text(\"\"\"\n+import asyncio\n+\n+import scrapy\n+\n+class MySpider(scrapy.Spider):\n+    name = 'aiosp'\n+\n+    custom_settings = {}\n+\n+    async def start(self):\n+        await asyncio.sleep(0.01)\n+        self.logger.debug('It works!')\n+        return\n+        yield\n+\"\"\")\n+\n+    def _append_settings(self, text: str) -> None:\n+        \"\"\"Add text to the end of the project settings.py.\"\"\"\n+        with (self.cwd / self.project_name / \"settings.py\").open(\n+            \"a\", encoding=\"utf-8\"\n+        ) as f:\n+            f.write(text)\n+\n+    def _replace_custom_settings(self, spider_name: str, text: str) -> None:\n+        \"\"\"Replace custom_settings in the given spider file with the given text.\"\"\"\n+        spider_path = self.cwd / self.project_name / \"spiders\" / f\"{spider_name}.py\"\n+        with spider_path.open(\"r+\", encoding=\"utf-8\") as f:\n+            content = f.read()\n+            content = content.replace(\n+                \"custom_settings = {}\", f\"custom_settings = {text}\"\n+            )\n+            f.seek(0)\n+            f.write(content)\n+            f.truncate()\n+\n+    def _assert_spider_works(self, msg: str, *args: str) -> None:\n+        \"\"\"The command uses the expected *CrawlerProcess, the spider works.\"\"\"\n+        _, out, err = self.proc(self.name, *args)\n+        assert msg in out, out\n+        assert \"It works!\" in err, err\n+        assert \"Spider closed (finished)\" in err, err\n+\n+    def _assert_spider_asyncio_fail(self, msg: str, *args: str) -> None:\n+        \"\"\"The command uses the expected *CrawlerProcess, the spider fails to use asyncio.\"\"\"\n+        _, out, err = self.proc(self.name, *args)\n+        assert msg in out, out\n+        assert \"no running event loop\" in err, err\n+\n+    def test_project_settings(self):\n+        \"\"\"The reactor is set via the project default settings (to the asyncio value).\n+\n+        AsyncCrawlerProcess, the asyncio reactor, both spiders work.\"\"\"\n+        for spider in [\"sp\", \"aiosp\"]:\n+            self._assert_spider_works(self.ASYNC_MSG, spider)\n+\n+    def test_cmdline_asyncio(self):\n+        \"\"\"The reactor is set via the command line to the asyncio value.\n+        AsyncCrawlerProcess, the asyncio reactor, both spiders work.\"\"\"\n+        for spider in [\"sp\", \"aiosp\"]:\n+            self._assert_spider_works(\n+                self.ASYNC_MSG, spider, \"-s\", f\"TWISTED_REACTOR={_asyncio_reactor_path}\"\n+            )\n+\n+    def test_project_settings_explicit_asyncio(self):\n+        \"\"\"The reactor explicitly is set via the project settings to the asyncio value.\n+\n+        AsyncCrawlerProcess, the asyncio reactor, both spiders work.\"\"\"\n+        self._append_settings(f\"TWISTED_REACTOR = '{_asyncio_reactor_path}'\\n\")\n+\n+        for spider in [\"sp\", \"aiosp\"]:\n+            self._assert_spider_works(self.ASYNC_MSG, spider)\n+\n+    def test_cmdline_empty(self):\n+        \"\"\"The reactor is set via the command line to the empty value.\n+\n+        CrawlerProcess, the default reactor, only the normal spider works.\"\"\"\n+        self._assert_spider_works(self.NORMAL_MSG, \"sp\", \"-s\", \"TWISTED_REACTOR=\")\n+        self._assert_spider_asyncio_fail(\n+            self.NORMAL_MSG, \"aiosp\", \"-s\", \"TWISTED_REACTOR=\"\n+        )\n+\n+    def test_project_settings_empty(self):\n+        \"\"\"The reactor is set via the project settings to the empty value.\n+\n+        CrawlerProcess, the default reactor, only the normal spider works.\"\"\"\n+        self._append_settings(\"TWISTED_REACTOR = None\\n\")\n+\n+        self._assert_spider_works(self.NORMAL_MSG, \"sp\")\n+        self._assert_spider_asyncio_fail(\n+            self.NORMAL_MSG, \"aiosp\", \"-s\", \"TWISTED_REACTOR=\"\n+        )\n+\n+    def test_spider_settings_asyncio(self):\n+        \"\"\"The reactor is set via the spider settings to the asyncio value.\n+\n+        AsyncCrawlerProcess, the asyncio reactor, both spiders work.\"\"\"\n+        for spider in [\"sp\", \"aiosp\"]:\n+            self._replace_custom_settings(\n+                spider, f\"{{'TWISTED_REACTOR': '{_asyncio_reactor_path}'}}\"\n+            )\n+            self._assert_spider_works(self.ASYNC_MSG, spider)\n+\n+    def test_spider_settings_asyncio_cmdline_empty(self):\n+        \"\"\"The reactor is set via the spider settings to the asyncio value\n+        and via command line to the empty value. The command line value takes\n+        precedence so the spider settings don't matter.\n+\n+        CrawlerProcess, the default reactor, only the normal spider works.\"\"\"\n+        for spider in [\"sp\", \"aiosp\"]:\n+            self._replace_custom_settings(\n+                spider, f\"{{'TWISTED_REACTOR': '{_asyncio_reactor_path}'}}\"\n+            )\n+\n+        self._assert_spider_works(self.NORMAL_MSG, \"sp\", \"-s\", \"TWISTED_REACTOR=\")\n+        self._assert_spider_asyncio_fail(\n+            self.NORMAL_MSG, \"aiosp\", \"-s\", \"TWISTED_REACTOR=\"\n+        )\n+\n+    def test_project_empty_spider_settings_asyncio(self):\n+        \"\"\"The reactor is set via the project settings to the empty value\n+        and via the spider settings to the asyncio value. CrawlerProcess is\n+        chosen based on the project settings, but the asyncio reactor is chosen\n+        based on the spider settings.\n+\n+        CrawlerProcess, the asyncio reactor, both spiders work.\"\"\"\n+        self._append_settings(\"TWISTED_REACTOR = None\\n\")\n+        for spider in [\"sp\", \"aiosp\"]:\n+            self._replace_custom_settings(\n+                spider, f\"{{'TWISTED_REACTOR': '{_asyncio_reactor_path}'}}\"\n+            )\n+            self._assert_spider_works(self.NORMAL_MSG, spider)\n+\n+    def test_project_asyncio_spider_settings_select(self):\n+        \"\"\"The reactor is set via the project settings to the asyncio value\n+        and via the spider settings to the select value. AsyncCrawlerProcess\n+        is chosen based on the project settings, and the conflicting reactor\n+        setting in the spider settings causes an exception.\n+\n+        AsyncCrawlerProcess, the asyncio reactor, both spiders produce a\n+        mismatched reactor exception.\"\"\"\n+        self._append_settings(f\"TWISTED_REACTOR = '{_asyncio_reactor_path}'\\n\")\n+        for spider in [\"sp\", \"aiosp\"]:\n+            self._replace_custom_settings(\n+                spider,\n+                \"{'TWISTED_REACTOR': 'twisted.internet.selectreactor.SelectReactor'}\",\n+            )\n+            _, out, err = self.proc(self.name, spider)\n+            assert self.ASYNC_MSG in out, out\n+            assert (\n+                \"The installed reactor (twisted.internet.asyncioreactor.AsyncioSelectorReactor)\"\n+                \" does not match the requested one\"\n+                \" (twisted.internet.selectreactor.SelectReactor)\"\n+            ) in err, err",
      "comment": "I'll try to change this (and other cases where it's emitted) to a more specific message separately but I don't yet know if it's possible.",
      "comment_id": 2115761777,
      "user": "wRAR",
      "created_at": "2025-05-30T11:36:13Z",
      "url": "https://github.com/scrapy/scrapy/pull/6845#discussion_r2115761777"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 6845,
      "file_path": "scrapy/cmdline.py",
      "line": 207,
      "side": "RIGHT",
      "diff_hunk": "@@ -202,7 +203,13 @@ def execute(argv: list[str] | None = None, settings: Settings | None = None) ->\n     _run_print_help(parser, cmd.process_options, args, opts)\n \n     if cmd.requires_crawler_process:\n-        cmd.crawler_process = CrawlerProcess(settings)\n+        if (\n+            settings[\"TWISTED_REACTOR\"] == _asyncio_reactor_path",
      "comment": "Wouldn\u2019t this fail if a class is used directly instead of an import path?",
      "comment_id": 2123302567,
      "user": "Gallaecio",
      "created_at": "2025-06-03T09:44:41Z",
      "url": "https://github.com/scrapy/scrapy/pull/6845#discussion_r2123302567"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 6845,
      "file_path": "scrapy/cmdline.py",
      "line": 207,
      "side": "RIGHT",
      "diff_hunk": "@@ -202,7 +203,13 @@ def execute(argv: list[str] | None = None, settings: Settings | None = None) ->\n     _run_print_help(parser, cmd.process_options, args, opts)\n \n     if cmd.requires_crawler_process:\n-        cmd.crawler_process = CrawlerProcess(settings)\n+        if (\n+            settings[\"TWISTED_REACTOR\"] == _asyncio_reactor_path",
      "comment": "This isn't supported (I think it will work if `AsyncioSelectorReactor` is passed, but for any other non-string value `install_reactor()` will crash).",
      "comment_id": 2123625723,
      "user": "wRAR",
      "created_at": "2025-06-03T12:10:28Z",
      "url": "https://github.com/scrapy/scrapy/pull/6845#discussion_r2123625723"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 6804,
      "file_path": "tests/test_spider.py",
      "line": 491,
      "side": "RIGHT",
      "diff_hunk": "@@ -476,6 +476,53 @@ class TestSpider(self.spider_class):\n         assert \"Error while reading start items and requests\" in str(log)\n         assert \"did you miss an 's'?\" in str(log)\n \n+    def test_parse_response_use(self):\n+        class _CrawlSpider(CrawlSpider):\n+            name = \"test\"\n+            start_urls = \"https://www.example.com\"\n+            _follow_links = False\n+\n+        with warnings.catch_warnings(record=True) as w:\n+            spider = _CrawlSpider()\n+            assert len(w) == 0\n+            spider._parse_response(\n+                TextResponse(spider.start_urls, body=b\"\"), None, None\n+            )\n+            print(len(w))",
      "comment": "I somehow missed those after I figured out what was causing the tests to fail on my machine. I'll add a commit that removes those in a bit",
      "comment_id": 2100898765,
      "user": "Rodrigosnrocha",
      "created_at": "2025-05-21T18:13:34Z",
      "url": "https://github.com/scrapy/scrapy/pull/6804#discussion_r2100898765"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 6804,
      "file_path": "scrapy/spiders/crawl.py",
      "line": 188,
      "side": "RIGHT",
      "diff_hunk": "@@ -171,6 +179,22 @@ async def _parse_response(\n             for request_or_item in self._requests_to_follow(response):\n                 yield request_or_item\n \n+    def _parse_response(\n+        self,\n+        response: Response,\n+        callback: CallbackT | None,\n+        cb_kwargs: dict[str, Any],\n+        follow: bool = True,\n+        warn: bool = True,",
      "comment": "In the discussion for issue #4463 it was suggested to add a flag to the existing _parse_response method to suppress the deprecation warning, via a parameter with a default value of True, and I initially felt it best to include that suggestion in this PR.\r\nSince that suggestion was made under the assumption that parse_with_rules would call _parse_response and not the other way around (and thus would have needed a way to avoid the warning), it may be better to remove the flag to avoid situations where users set it to False manually and forget to replace _parse_response until it is too late",
      "comment_id": 2100912148,
      "user": "Rodrigosnrocha",
      "created_at": "2025-05-21T18:22:28Z",
      "url": "https://github.com/scrapy/scrapy/pull/6804#discussion_r2100912148"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 6804,
      "file_path": "scrapy/spiders/crawl.py",
      "line": 188,
      "side": "RIGHT",
      "diff_hunk": "@@ -171,6 +179,22 @@ async def _parse_response(\n             for request_or_item in self._requests_to_follow(response):\n                 yield request_or_item\n \n+    def _parse_response(\n+        self,\n+        response: Response,\n+        callback: CallbackT | None,\n+        cb_kwargs: dict[str, Any],\n+        follow: bool = True,\n+        warn: bool = True,",
      "comment": "> Since that suggestion was made under the assumption that parse_with_rules would call _parse_response and not the other way around\r\n\r\nYes, so there is no need for the flag.",
      "comment_id": 2100917057,
      "user": "wRAR",
      "created_at": "2025-05-21T18:25:29Z",
      "url": "https://github.com/scrapy/scrapy/pull/6804#discussion_r2100917057"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 6804,
      "file_path": "scrapy/spiders/crawl.py",
      "line": 192,
      "side": "RIGHT",
      "diff_hunk": "@@ -171,6 +179,20 @@ async def _parse_response(\n             for request_or_item in self._requests_to_follow(response):\n                 yield request_or_item\n \n+    def _parse_response(\n+        self,\n+        response: Response,\n+        callback: CallbackT | None,\n+        cb_kwargs: dict[str, Any],\n+        follow: bool = True,\n+    ) -> AsyncIterator[Any]:\n+        warnings.warn(\n+            \"CrawlSpider._parse_response method is deprecated: \"\n+            \"it will be removed in future Scrapy releases. \"\n+            \"Please use CrawlSpider.parse_with_rules method instead.\"",
      "comment": "```suggestion\r\n            \"The CrawlSpider._parse_response method is deprecated: \"\r\n            \"it will be removed in future Scrapy releases. \"\r\n            \"Please use the CrawlSpider.parse_with_rules method instead.\",\r\n            stacklevel=2,\r\n```",
      "comment_id": 2108531144,
      "user": "Gallaecio",
      "created_at": "2025-05-27T08:10:14Z",
      "url": "https://github.com/scrapy/scrapy/pull/6804#discussion_r2108531144"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 6804,
      "file_path": "scrapy/spiders/crawl.py",
      "line": 104,
      "side": "RIGHT",
      "diff_hunk": "@@ -95,9 +97,15 @@ class CrawlSpider(Spider):\n     def __init__(self, *a: Any, **kw: Any):\n         super().__init__(*a, **kw)\n         self._compile_rules()\n+        if method_is_overridden(self.__class__, CrawlSpider, \"_parse_response\"):\n+            warnings.warn(\n+                \"CrawlSpider._parse_response method is deprecated: \"\n+                \"it will be removed in future Scrapy releases. \"\n+                \"Please override CrawlSpider.parse_with_rules method instead.\"",
      "comment": "```suggestion\r\n                f\"The CrawlSpider._parse_response method, which the \"\r\n                f\"{global_object_name(self.__class__)} class overrides, is \"\r\n                f\"deprecated: it will be removed in future Scrapy releases. \"\r\n                f\"Please override the CrawlSpider.parse_with_rules method \"\r\n                f\"instead.\"\r\n```",
      "comment_id": 2108542324,
      "user": "Gallaecio",
      "created_at": "2025-05-27T08:15:25Z",
      "url": "https://github.com/scrapy/scrapy/pull/6804#discussion_r2108542324"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 6824,
      "file_path": "scrapy/commands/list.py",
      "line": 14,
      "side": "RIGHT",
      "diff_hunk": "@@ -3,19 +3,22 @@\n from typing import TYPE_CHECKING\n \n from scrapy.commands import ScrapyCommand\n+from scrapy.spiderloader import get_spider_loader\n \n if TYPE_CHECKING:\n     import argparse\n \n \n class Command(ScrapyCommand):\n     requires_project = True\n+    requires_crawler_process = False",
      "comment": "If False is a more common value, maybe we could make it False by default instead.",
      "comment_id": 2108587875,
      "user": "Gallaecio",
      "created_at": "2025-05-27T08:36:06Z",
      "url": "https://github.com/scrapy/scrapy/pull/6824#discussion_r2108587875"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 6817,
      "file_path": "scrapy/crawler.py",
      "line": 532,
      "side": "RIGHT",
      "diff_hunk": "@@ -465,66 +490,49 @@ def crawl(\n                 \"it must be a spider class (or a Crawler object)\"\n             )\n         if not is_asyncio_reactor_installed():\n-            raise RuntimeError(\"AsyncCrawlerRunner requires AsyncioSelectorReactor.\")\n+            raise RuntimeError(\n+                f\"{type(self).__name__} requires AsyncioSelectorReactor.\"\n+            )\n         crawler = self.create_crawler(crawler_or_spidercls)\n         return self._crawl(crawler, *args, **kwargs)\n \n-    def _crawl(\n-        self, crawler: Crawler, *args: Any, **kwargs: Any\n-    ) -> asyncio.Future[None]:\n+    def _crawl(self, crawler: Crawler, *args: Any, **kwargs: Any) -> asyncio.Task[None]:\n+        # At this point the asyncio loop has been installed either by the user\n+        # or by AsyncCrawlerProcess (but it isn't running yet, so no asyncio.create_task()).\n+        loop = asyncio.get_event_loop()\n         self.crawlers.add(crawler)\n-        future = deferred_to_future(crawler.crawl(*args, **kwargs))\n-        self._active.add(future)\n+        task = loop.create_task(crawler.crawl_async(*args, **kwargs))\n+        self._active.add(task)\n \n-        def _done(_: asyncio.Future[None]) -> None:\n+        def _done(_: asyncio.Task[None]) -> None:\n             self.crawlers.discard(crawler)\n-            self._active.discard(future)\n+            self._active.discard(task)\n             self.bootstrap_failed |= not getattr(crawler, \"spider\", None)\n \n-        future.add_done_callback(_done)\n-        return future\n+        task.add_done_callback(_done)\n+        return task\n \n     async def stop(self) -> None:\n         \"\"\"\n         Stops simultaneously all the crawling jobs taking place.\n \n         Completes when they all have ended.\n         \"\"\"\n-        await deferred_to_future(self._stop())\n+        if self.crawlers:\n+            await asyncio.wait(\n+                [asyncio.create_task(c.stop_async()) for c in self.crawlers]\n+            )\n \n     async def join(self) -> None:\n         \"\"\"\n         Completes when all managed :attr:`crawlers` have completed their\n         executions.\n         \"\"\"\n         while self._active:\n-            await asyncio.gather(*self._active)\n-\n-\n-class CrawlerProcess(CrawlerRunner):\n-    \"\"\"\n-    A class to run multiple scrapy crawlers in a process simultaneously.\n+            await asyncio.wait(self._active)",
      "comment": "`asyncio.gather()` has different exception handling semantics wrt `yield DeferredList()` (the former raises the first exception, the latter simply records it in the result), `asyncio.wait()` in this case does what we want, waiting until all tasks finish in some way.",
      "comment_id": 2098343548,
      "user": "wRAR",
      "created_at": "2025-05-20T16:01:01Z",
      "url": "https://github.com/scrapy/scrapy/pull/6817#discussion_r2098343548"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 6817,
      "file_path": "scrapy/core/engine.py",
      "line": 404,
      "side": "RIGHT",
      "diff_hunk": "@@ -392,8 +395,10 @@ def _download(\n         finally:\n             self._slot.nextcall.schedule()\n \n-    @deferred_f_from_coro_f\n-    async def open_spider(\n+    def open_spider(self, spider: Spider, close_if_idle: bool = True) -> Deferred[None]:\n+        return deferred_from_coro(self.open_spider_async(spider, close_if_idle))\n+\n+    async def open_spider_async(\n         self,\n         spider: Spider,\n         close_if_idle: bool = True,",
      "comment": "Maybe this would be a good chance to apply position-only (*spider*) and keyword-only (*close_if_idle*) logic to the new async method, to make things easier for us in case we ever decide to deprecate some part of the signature.",
      "comment_id": 2108382699,
      "user": "Gallaecio",
      "created_at": "2025-05-27T07:15:30Z",
      "url": "https://github.com/scrapy/scrapy/pull/6817#discussion_r2108382699"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 6817,
      "file_path": "scrapy/crawler.py",
      "line": 275,
      "side": "RIGHT",
      "diff_hunk": "@@ -264,6 +270,28 @@ def get_spider_middleware(self, cls: type[_T]) -> _T | None:\n             )\n         return self._get_component(cls, self.engine.scraper.spidermw.middlewares)\n \n+    async def crawl_async(self, *args: Any, **kwargs: Any) -> None:\n+        if self.crawling:\n+            raise RuntimeError(\"Crawling already taking place\")",
      "comment": "Could this be a good chance to increase coverage? (I did not check if the coverage data is accurate or we do have tests for these but they are executed in a way that is not reflected in the coverage data)",
      "comment_id": 2108394568,
      "user": "Gallaecio",
      "created_at": "2025-05-27T07:21:00Z",
      "url": "https://github.com/scrapy/scrapy/pull/6817#discussion_r2108394568"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 6827,
      "file_path": "scrapy/utils/asyncio.py",
      "line": 33,
      "side": "RIGHT",
      "diff_hunk": "@@ -0,0 +1,38 @@\n+\"\"\"Utilities related to asyncio and its support in Scrapy.\"\"\"\n+\n+from scrapy.utils.reactor import is_asyncio_reactor_installed, is_reactor_installed\n+\n+\n+def is_asyncio_available() -> bool:\n+    \"\"\"Check if it's possible to call asyncio code that relies on the asyncio event loop.\n+\n+    .. versionadded:: VERSION\n+\n+    Currently this function is identical to\n+    :func:`scrapy.utils.reactor.is_asyncio_reactor_installed`: it returns\n+    ``True`` if the Twisted reactor that is installed is\n+    :class:`~twisted.internet.asyncioreactor.AsyncioSelectorReactor`, returns\n+    ``False`` if a different reactor is installed, and raises a\n+    :exc:`RuntimeError` if no reactor is installed. In a future Scrapy version,\n+    when Scrapy supports running without a Twisted reactor, this function will\n+    also return ``True`` when running in that mode, so code that doesn't\n+    directly require a Twisted reactor should use this function instead of\n+    :func:`~scrapy.utils.reactor.is_asyncio_reactor_installed`.\n+\n+    When this returns ``True``, an asyncio loop is installed and used by\n+    Scrapy. It's possible to call functions that require it, such as\n+    :func:`asyncio.sleep`, and await on :class:`asyncio.Future` objects in\n+    Scrapy-related code.\n+\n+    When this returns ``False``, a non-asyncio Twisted reactor is installed.\n+    It's not possible to use asyncio features that require an asyncio event\n+    loop or await on :class:`asyncio.Future` objects in Scrapy-related code,\n+    but it's possible to await on :class:`~twisted.internet.defer.Deferred`\n+    objects.\n+    \"\"\"\n+    if not is_reactor_installed():",
      "comment": "Maybe we could add `is_reactor_installed()` to the [list of coverage ignores](https://github.com/scrapy/scrapy/blob/b41aea4873319df15ccb9145a4940ff1702d123a/pyproject.toml#L145), if there is no good way to test it?",
      "comment_id": 2111134889,
      "user": "Gallaecio",
      "created_at": "2025-05-28T07:23:38Z",
      "url": "https://github.com/scrapy/scrapy/pull/6827#discussion_r2111134889"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 6827,
      "file_path": "scrapy/utils/asyncio.py",
      "line": 33,
      "side": "RIGHT",
      "diff_hunk": "@@ -0,0 +1,38 @@\n+\"\"\"Utilities related to asyncio and its support in Scrapy.\"\"\"\n+\n+from scrapy.utils.reactor import is_asyncio_reactor_installed, is_reactor_installed\n+\n+\n+def is_asyncio_available() -> bool:\n+    \"\"\"Check if it's possible to call asyncio code that relies on the asyncio event loop.\n+\n+    .. versionadded:: VERSION\n+\n+    Currently this function is identical to\n+    :func:`scrapy.utils.reactor.is_asyncio_reactor_installed`: it returns\n+    ``True`` if the Twisted reactor that is installed is\n+    :class:`~twisted.internet.asyncioreactor.AsyncioSelectorReactor`, returns\n+    ``False`` if a different reactor is installed, and raises a\n+    :exc:`RuntimeError` if no reactor is installed. In a future Scrapy version,\n+    when Scrapy supports running without a Twisted reactor, this function will\n+    also return ``True`` when running in that mode, so code that doesn't\n+    directly require a Twisted reactor should use this function instead of\n+    :func:`~scrapy.utils.reactor.is_asyncio_reactor_installed`.\n+\n+    When this returns ``True``, an asyncio loop is installed and used by\n+    Scrapy. It's possible to call functions that require it, such as\n+    :func:`asyncio.sleep`, and await on :class:`asyncio.Future` objects in\n+    Scrapy-related code.\n+\n+    When this returns ``False``, a non-asyncio Twisted reactor is installed.\n+    It's not possible to use asyncio features that require an asyncio event\n+    loop or await on :class:`asyncio.Future` objects in Scrapy-related code,\n+    but it's possible to await on :class:`~twisted.internet.defer.Deferred`\n+    objects.\n+    \"\"\"\n+    if not is_reactor_installed():",
      "comment": "No, it should be possible to test, I'll add a test.",
      "comment_id": 2111187297,
      "user": "wRAR",
      "created_at": "2025-05-28T07:51:10Z",
      "url": "https://github.com/scrapy/scrapy/pull/6827#discussion_r2111187297"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 6821,
      "file_path": "tests/test_downloader_handler_twisted_http11.py",
      "line": 30,
      "side": "RIGHT",
      "diff_hunk": "@@ -0,0 +1,78 @@\n+\"\"\"Tests for scrapy.core.downloader.handlers.http11.HTTP11DownloadHandler.\"\"\"\n+\n+from __future__ import annotations\n+\n+from typing import TYPE_CHECKING, Any\n+\n+from scrapy.core.downloader.handlers.http11 import HTTP11DownloadHandler\n+from tests.test_downloader_handlers_http_base import (\n+    TestHttp11Base,\n+    TestHttpMockServerBase,\n+    TestHttpProxyBase,\n+    TestHttps11Base,\n+    TestHttpsCustomCiphersBase,\n+    TestHttpsInvalidDNSIdBase,\n+    TestHttpsInvalidDNSPatternBase,\n+    TestHttpsWrongHostnameBase,\n+    TestSimpleHttpsBase,\n+)\n+\n+if TYPE_CHECKING:\n+    from scrapy.core.downloader.handlers import DownloadHandlerProtocol\n+\n+\n+DH = HTTP11DownloadHandler\n+\n+\n+class TestHttp11(TestHttp11Base):\n+    @property\n+    def download_handler_cls(self) -> type[DownloadHandlerProtocol]:\n+        return DH",
      "comment": "Looking at the amount of repetition, I wonder if a mixin class to implement the property would be a cleaner option than a global variable.",
      "comment_id": 2108333695,
      "user": "Gallaecio",
      "created_at": "2025-05-27T06:51:53Z",
      "url": "https://github.com/scrapy/scrapy/pull/6821#discussion_r2108333695"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 6801,
      "file_path": "scrapy/signalmanager.py",
      "line": 71,
      "side": "RIGHT",
      "diff_hunk": "@@ -53,18 +53,32 @@ def send_catch_log_deferred(\n         self, signal: Any, **kwargs: Any\n     ) -> Deferred[list[tuple[Any, Any]]]:\n         \"\"\"\n-        Like :meth:`send_catch_log` but supports returning\n-        :class:`~twisted.internet.defer.Deferred` objects from signal handlers.\n+        Like :meth:`send_catch_log` but supports asynchronous signal handlers.\n \n         Returns a Deferred that gets fired once all signal handlers\n-        deferreds were fired. Send a signal, catch exceptions and log them.\n+        have finished. Send a signal, catch exceptions and log them.\n \n         The keyword arguments are passed to the signal handlers (connected\n         through the :meth:`connect` method).\n         \"\"\"\n         kwargs.setdefault(\"sender\", self.sender)\n         return _signal.send_catch_log_deferred(signal, **kwargs)\n \n+    async def send_catch_log_async(\n+        self, signal: Any, **kwargs: Any\n+    ) -> list[tuple[Any, Any]]:\n+        \"\"\"\n+        Like :meth:`send_catch_log` but supports asynchronous signal handlers.",
      "comment": "Same here, we could link \u201casynchronous signal handlers\u201d to that section.",
      "comment_id": 2091028264,
      "user": "Gallaecio",
      "created_at": "2025-05-15T12:10:25Z",
      "url": "https://github.com/scrapy/scrapy/pull/6801#discussion_r2091028264"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 6752,
      "file_path": "scrapy/spidermiddlewares/start.py",
      "line": 15,
      "side": "RIGHT",
      "diff_hunk": "@@ -0,0 +1,38 @@\n+from __future__ import annotations\n+\n+from typing import TYPE_CHECKING, Any\n+\n+from scrapy.http import Request\n+\n+if TYPE_CHECKING:\n+    from collections.abc import AsyncIterator, Iterable\n+\n+    from scrapy import Spider\n+\n+\n+class StartSpiderMiddleware:\n+    \"\"\"Set ``\"is_start_request\"`` to ``True`` in the\n+    :attr:`~scrapy.Request.meta` of :ref:`start requests <start-requests>`.",
      "comment": "I think we should document the new meta key in the release notes, when mentioning that this new middleware is enabled by default.\r\n\r\nWe should also document it in https://docs.scrapy.org/en/latest/topics/request-response.html#request-meta-special-keys.",
      "comment_id": 2064711148,
      "user": "kmike",
      "created_at": "2025-04-28T21:01:38Z",
      "url": "https://github.com/scrapy/scrapy/pull/6752#discussion_r2064711148"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 6752,
      "file_path": "scrapy/core/scheduler.py",
      "line": 143,
      "side": "RIGHT",
      "diff_hunk": "@@ -126,56 +129,39 @@ def next_request(self) -> Request | None:\n \n \n class Scheduler(BaseScheduler):\n-    \"\"\"\n-    Default Scrapy scheduler. This implementation also handles duplication\n-    filtering via the :setting:`dupefilter <DUPEFILTER_CLASS>`.\n+    \"\"\"Default Scrapy scheduler.\n \n-    This scheduler stores requests into several priority queues (defined by the\n+    Requests are stored into several priority queues (defined by the\n     :setting:`SCHEDULER_PRIORITY_QUEUE` setting). In turn, said priority queues\n-    are backed by either memory or disk based queues (respectively defined by the\n-    :setting:`SCHEDULER_MEMORY_QUEUE` and :setting:`SCHEDULER_DISK_QUEUE` settings).\n+    are backed by either memory or disk based queues (respectively defined by\n+    the :setting:`SCHEDULER_START_MEMORY_QUEUE` and\n+    :setting:`SCHEDULER_START_DISK_QUEUE` settings for :ref:`start requests\n+    <start-requests>` and by the :setting:`SCHEDULER_MEMORY_QUEUE` and\n+    :setting:`SCHEDULER_DISK_QUEUE` settings for other requests).\n \n     Request prioritization is almost entirely delegated to the priority queue. The only\n     prioritization performed by this scheduler is using the disk-based queue if present",
      "comment": "It also implicitly prefers start queues to regular queues.",
      "comment_id": 2065632190,
      "user": "kmike",
      "created_at": "2025-04-29T06:51:30Z",
      "url": "https://github.com/scrapy/scrapy/pull/6752#discussion_r2065632190"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 6752,
      "file_path": "scrapy/core/scheduler.py",
      "line": 225,
      "side": "RIGHT",
      "diff_hunk": "@@ -195,23 +217,22 @@ def __init__(\n         self.logunser: bool = logunser\n         self.stats: StatsCollector | None = stats\n         self.crawler: Crawler | None = crawler\n-\n-    @classmethod\n-    def from_crawler(cls, crawler: Crawler) -> Self:\n-        \"\"\"\n-        Factory method, initializes the scheduler with arguments taken from the crawl settings\n-        \"\"\"\n-        dupefilter_cls = load_object(crawler.settings[\"DUPEFILTER_CLASS\"])\n-        return cls(\n-            dupefilter=build_from_crawler(dupefilter_cls, crawler),\n-            jobdir=job_dir(crawler.settings),\n-            dqclass=load_object(crawler.settings[\"SCHEDULER_DISK_QUEUE\"]),\n-            mqclass=load_object(crawler.settings[\"SCHEDULER_MEMORY_QUEUE\"]),\n-            logunser=crawler.settings.getbool(\"SCHEDULER_DEBUG\"),\n-            stats=crawler.stats,\n-            pqclass=load_object(crawler.settings[\"SCHEDULER_PRIORITY_QUEUE\"]),\n-            crawler=crawler,\n+        self._sdqclass: type[BaseQueue] | None = self._get_start_queue_cls(\n+            crawler, \"DISK\"\n         )\n+        self._smqclass: type[BaseQueue] | None = self._get_start_queue_cls(\n+            crawler, \"MEMORY\"\n+        )",
      "comment": "Is it done here (instead of passing instances to `__init__`) to simplify backwards compatibility handling?",
      "comment_id": 2065660691,
      "user": "kmike",
      "created_at": "2025-04-29T07:05:28Z",
      "url": "https://github.com/scrapy/scrapy/pull/6752#discussion_r2065660691"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 6752,
      "file_path": "scrapy/pqueues.py",
      "line": 167,
      "side": "RIGHT",
      "diff_hunk": "@@ -115,29 +132,66 @@ def qfactory(self, key: int) -> QueueProtocol:\n             self.key + \"/\" + str(key),\n         )\n \n+    def _sqfactory(self, key: int) -> QueueProtocol:\n+        assert self._start_queue_cls is not None\n+        return build_from_crawler(\n+            self._start_queue_cls,\n+            self.crawler,\n+            f\"{self.key}/{key}s\",\n+        )\n+\n     def priority(self, request: Request) -> int:\n         return -request.priority\n \n     def push(self, request: Request) -> None:\n         priority = self.priority(request)\n-        if priority not in self.queues:\n-            self.queues[priority] = self.qfactory(priority)\n-        q = self.queues[priority]\n+        is_start_request = request.meta.get(\"is_start_request\", False)\n+        if is_start_request and self._start_queue_cls:\n+            if priority not in self._start_queues:\n+                self._start_queues[priority] = self._sqfactory(priority)\n+            q = self._start_queues[priority]\n+        else:\n+            if priority not in self.queues:\n+                self.queues[priority] = self.qfactory(priority)\n+            q = self.queues[priority]\n         q.push(request)  # this may fail (eg. serialization error)\n         if self.curprio is None or priority < self.curprio:\n             self.curprio = priority\n \n     def pop(self) -> Request | None:\n-        if self.curprio is None:\n-            return None\n-        q = self.queues[self.curprio]\n-        m = q.pop()\n-        if not q:\n-            del self.queues[self.curprio]\n-            q.close()\n-            prios = [p for p, q in self.queues.items() if q]\n-            self.curprio = min(prios) if prios else None\n-        return m\n+        while self.curprio is not None:\n+            if self._start_queues:\n+                try:\n+                    q = self._start_queues[self.curprio]\n+                except KeyError:\n+                    pass",
      "comment": "Why is _update_curprio not called here? It seems `self._start_queues` affects the curprio.\r\nIf it should be added, then it probably make sense to have a small `_pop` helper with the popping logic, to avoid duplication.",
      "comment_id": 2065671886,
      "user": "kmike",
      "created_at": "2025-04-29T07:13:18Z",
      "url": "https://github.com/scrapy/scrapy/pull/6752#discussion_r2065671886"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 6752,
      "file_path": "scrapy/core/scheduler.py",
      "line": 225,
      "side": "RIGHT",
      "diff_hunk": "@@ -195,23 +217,22 @@ def __init__(\n         self.logunser: bool = logunser\n         self.stats: StatsCollector | None = stats\n         self.crawler: Crawler | None = crawler\n-\n-    @classmethod\n-    def from_crawler(cls, crawler: Crawler) -> Self:\n-        \"\"\"\n-        Factory method, initializes the scheduler with arguments taken from the crawl settings\n-        \"\"\"\n-        dupefilter_cls = load_object(crawler.settings[\"DUPEFILTER_CLASS\"])\n-        return cls(\n-            dupefilter=build_from_crawler(dupefilter_cls, crawler),\n-            jobdir=job_dir(crawler.settings),\n-            dqclass=load_object(crawler.settings[\"SCHEDULER_DISK_QUEUE\"]),\n-            mqclass=load_object(crawler.settings[\"SCHEDULER_MEMORY_QUEUE\"]),\n-            logunser=crawler.settings.getbool(\"SCHEDULER_DEBUG\"),\n-            stats=crawler.stats,\n-            pqclass=load_object(crawler.settings[\"SCHEDULER_PRIORITY_QUEUE\"]),\n-            crawler=crawler,\n+        self._sdqclass: type[BaseQueue] | None = self._get_start_queue_cls(\n+            crawler, \"DISK\"\n         )\n+        self._smqclass: type[BaseQueue] | None = self._get_start_queue_cls(\n+            crawler, \"MEMORY\"\n+        )",
      "comment": "Yes. I kind of default to that nowadays, specially for things that can be overridden through a setting. But it may make sense to allow subclasses to override these, maybe ignore the setting or use some other setting to decide.\r\n\r\n@wRAR Shall I make them public?\r\n\r\nIf in doubt, we can discuss it with @kmike for a follow-up release.",
      "comment_id": 2072939031,
      "user": "Gallaecio",
      "created_at": "2025-05-05T07:09:34Z",
      "url": "https://github.com/scrapy/scrapy/pull/6752#discussion_r2072939031"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 6752,
      "file_path": "scrapy/pqueues.py",
      "line": 167,
      "side": "RIGHT",
      "diff_hunk": "@@ -115,29 +132,66 @@ def qfactory(self, key: int) -> QueueProtocol:\n             self.key + \"/\" + str(key),\n         )\n \n+    def _sqfactory(self, key: int) -> QueueProtocol:\n+        assert self._start_queue_cls is not None\n+        return build_from_crawler(\n+            self._start_queue_cls,\n+            self.crawler,\n+            f\"{self.key}/{key}s\",\n+        )\n+\n     def priority(self, request: Request) -> int:\n         return -request.priority\n \n     def push(self, request: Request) -> None:\n         priority = self.priority(request)\n-        if priority not in self.queues:\n-            self.queues[priority] = self.qfactory(priority)\n-        q = self.queues[priority]\n+        is_start_request = request.meta.get(\"is_start_request\", False)\n+        if is_start_request and self._start_queue_cls:\n+            if priority not in self._start_queues:\n+                self._start_queues[priority] = self._sqfactory(priority)\n+            q = self._start_queues[priority]\n+        else:\n+            if priority not in self.queues:\n+                self.queues[priority] = self.qfactory(priority)\n+            q = self.queues[priority]\n         q.push(request)  # this may fail (eg. serialization error)\n         if self.curprio is None or priority < self.curprio:\n             self.curprio = priority\n \n     def pop(self) -> Request | None:\n-        if self.curprio is None:\n-            return None\n-        q = self.queues[self.curprio]\n-        m = q.pop()\n-        if not q:\n-            del self.queues[self.curprio]\n-            q.close()\n-            prios = [p for p, q in self.queues.items() if q]\n-            self.curprio = min(prios) if prios else None\n-        return m\n+        while self.curprio is not None:\n+            if self._start_queues:\n+                try:\n+                    q = self._start_queues[self.curprio]\n+                except KeyError:\n+                    pass",
      "comment": "The logic is to call `self._update_curprio()` when *both* queues raise a `KeyError`. Here it is not called because self.curprio may still exist in `self.queues` below, and `self._update_curprio()` only needs to be changed once you know that neither queue has the current `curprio`.",
      "comment_id": 2072942577,
      "user": "Gallaecio",
      "created_at": "2025-05-05T07:13:06Z",
      "url": "https://github.com/scrapy/scrapy/pull/6752#discussion_r2072942577"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 6752,
      "file_path": "scrapy/core/scheduler.py",
      "line": 225,
      "side": "RIGHT",
      "diff_hunk": "@@ -195,23 +217,22 @@ def __init__(\n         self.logunser: bool = logunser\n         self.stats: StatsCollector | None = stats\n         self.crawler: Crawler | None = crawler\n-\n-    @classmethod\n-    def from_crawler(cls, crawler: Crawler) -> Self:\n-        \"\"\"\n-        Factory method, initializes the scheduler with arguments taken from the crawl settings\n-        \"\"\"\n-        dupefilter_cls = load_object(crawler.settings[\"DUPEFILTER_CLASS\"])\n-        return cls(\n-            dupefilter=build_from_crawler(dupefilter_cls, crawler),\n-            jobdir=job_dir(crawler.settings),\n-            dqclass=load_object(crawler.settings[\"SCHEDULER_DISK_QUEUE\"]),\n-            mqclass=load_object(crawler.settings[\"SCHEDULER_MEMORY_QUEUE\"]),\n-            logunser=crawler.settings.getbool(\"SCHEDULER_DEBUG\"),\n-            stats=crawler.stats,\n-            pqclass=load_object(crawler.settings[\"SCHEDULER_PRIORITY_QUEUE\"]),\n-            crawler=crawler,\n+        self._sdqclass: type[BaseQueue] | None = self._get_start_queue_cls(\n+            crawler, \"DISK\"\n         )\n+        self._smqclass: type[BaseQueue] | None = self._get_start_queue_cls(\n+            crawler, \"MEMORY\"\n+        )",
      "comment": "I'm fine with either approach. My main concern is about consistency (some things are passed to `__init__`, others are created later), but it's not a big deal, if it helps to make a backwards compatible change with less code to maintain.",
      "comment_id": 2073057407,
      "user": "kmike",
      "created_at": "2025-05-05T08:40:03Z",
      "url": "https://github.com/scrapy/scrapy/pull/6752#discussion_r2073057407"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 6752,
      "file_path": "scrapy/core/scheduler.py",
      "line": 225,
      "side": "RIGHT",
      "diff_hunk": "@@ -195,23 +217,22 @@ def __init__(\n         self.logunser: bool = logunser\n         self.stats: StatsCollector | None = stats\n         self.crawler: Crawler | None = crawler\n-\n-    @classmethod\n-    def from_crawler(cls, crawler: Crawler) -> Self:\n-        \"\"\"\n-        Factory method, initializes the scheduler with arguments taken from the crawl settings\n-        \"\"\"\n-        dupefilter_cls = load_object(crawler.settings[\"DUPEFILTER_CLASS\"])\n-        return cls(\n-            dupefilter=build_from_crawler(dupefilter_cls, crawler),\n-            jobdir=job_dir(crawler.settings),\n-            dqclass=load_object(crawler.settings[\"SCHEDULER_DISK_QUEUE\"]),\n-            mqclass=load_object(crawler.settings[\"SCHEDULER_MEMORY_QUEUE\"]),\n-            logunser=crawler.settings.getbool(\"SCHEDULER_DEBUG\"),\n-            stats=crawler.stats,\n-            pqclass=load_object(crawler.settings[\"SCHEDULER_PRIORITY_QUEUE\"]),\n-            crawler=crawler,\n+        self._sdqclass: type[BaseQueue] | None = self._get_start_queue_cls(\n+            crawler, \"DISK\"\n         )\n+        self._smqclass: type[BaseQueue] | None = self._get_start_queue_cls(\n+            crawler, \"MEMORY\"\n+        )",
      "comment": "I'm fine with keeping the current code, it's not the first time we do newer things differently from the older ones.",
      "comment_id": 2073077651,
      "user": "wRAR",
      "created_at": "2025-05-05T08:51:12Z",
      "url": "https://github.com/scrapy/scrapy/pull/6752#discussion_r2073077651"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 6729,
      "file_path": "scrapy/spiders/__init__.py",
      "line": 81,
      "side": "RIGHT",
      "diff_hunk": "@@ -72,7 +78,54 @@ def _set_crawler(self, crawler: Crawler) -> None:\n         self.settings: BaseSettings = crawler.settings\n         crawler.signals.connect(self.close, signals.spider_closed)\n \n-    def start_requests(self) -> Iterable[Request]:\n+    async def yield_seeds(self) -> AsyncIterator[Any]:",
      "comment": "Is it intentional that this is `AsyncIterator` and not just `AsyncIterable`? If we only use it with `async for` the latter is enough.",
      "comment_id": 1992112784,
      "user": "wRAR",
      "created_at": "2025-03-12T18:50:58Z",
      "url": "https://github.com/scrapy/scrapy/pull/6729#discussion_r1992112784"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 6729,
      "file_path": "scrapy/spiders/__init__.py",
      "line": 81,
      "side": "RIGHT",
      "diff_hunk": "@@ -72,7 +78,54 @@ def _set_crawler(self, crawler: Crawler) -> None:\n         self.settings: BaseSettings = crawler.settings\n         crawler.signals.connect(self.close, signals.spider_closed)\n \n-    def start_requests(self) -> Iterable[Request]:\n+    async def yield_seeds(self) -> AsyncIterator[Any]:",
      "comment": "I am unfamiliar with the differences between the 2, you are probably right.",
      "comment_id": 1992116405,
      "user": "Gallaecio",
      "created_at": "2025-03-12T18:53:48Z",
      "url": "https://github.com/scrapy/scrapy/pull/6729#discussion_r1992116405"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 6729,
      "file_path": "scrapy/spiders/__init__.py",
      "line": 81,
      "side": "RIGHT",
      "diff_hunk": "@@ -72,7 +78,54 @@ def _set_crawler(self, crawler: Crawler) -> None:\n         self.settings: BaseSettings = crawler.settings\n         crawler.signals.connect(self.close, signals.spider_closed)\n \n-    def start_requests(self) -> Iterable[Request]:\n+    async def yield_seeds(self) -> AsyncIterator[Any]:",
      "comment": "*Iterator is a superset of *Iterable, with the additions that are usually not needed. That's basically all I know without checking docs every time.",
      "comment_id": 1992122435,
      "user": "wRAR",
      "created_at": "2025-03-12T18:57:20Z",
      "url": "https://github.com/scrapy/scrapy/pull/6729#discussion_r1992122435"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 6729,
      "file_path": "tests/test_crawl.py",
      "line": 308,
      "side": "RIGHT",
      "diff_hunk": "@@ -305,10 +305,10 @@ def test_referer_header(self):\n         # basic asserts in case of weird communication errors\n         assert \"responses\" in crawler.spider.meta\n         assert \"failures\" not in crawler.spider.meta\n-        # start requests doesn't set Referer header\n+        # test_start doesn't set Referer header",
      "comment": "I think there are some search+replace errors in several files that produced \"test_start\" or e.g. \"process_test_start\"",
      "comment_id": 2008813110,
      "user": "wRAR",
      "created_at": "2025-03-22T16:53:27Z",
      "url": "https://github.com/scrapy/scrapy/pull/6729#discussion_r2008813110"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 6729,
      "file_path": "scrapy/commands/fetch.py",
      "line": 96,
      "side": "RIGHT",
      "diff_hunk": "@@ -89,5 +89,12 @@ def run(self, args: list[str], opts: Namespace) -> None:\n             spidercls = spider_loader.load(opts.spider)\n         else:\n             spidercls = spidercls_for_request(spider_loader, request, spidercls)\n-        self.crawler_process.crawl(spidercls, start_requests=lambda: [request])\n+\n+        async def start(self):\n+            yield self._request\n+\n+        spidercls._request = request  # type: ignore[assignment,attr-defined]",
      "comment": "```suggestion\r\n        async def start(self):\r\n            yield request\r\n```",
      "comment_id": 2011901296,
      "user": "kmike",
      "created_at": "2025-03-25T11:33:46Z",
      "url": "https://github.com/scrapy/scrapy/pull/6729#discussion_r2011901296"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 6729,
      "file_path": "scrapy/core/spidermw.py",
      "line": 108,
      "side": "RIGHT",
      "diff_hunk": "@@ -55,12 +56,56 @@ class SpiderMiddlewareManager(MiddlewareManager):\n     def _get_mwlist_from_settings(cls, settings: BaseSettings) -> list[Any]:\n         return build_component_list(settings.getwithbase(\"SPIDER_MIDDLEWARES\"))\n \n+    def __init__(self, *middlewares: Any) -> None:\n+        self._check_deprecated_process_start_requests_use(middlewares)\n+        super().__init__(*middlewares)\n+\n+    def _check_deprecated_process_start_requests_use(\n+        self, middlewares: tuple[Any]\n+    ) -> None:\n+        deprecated_middlewares = [\n+            middleware\n+            for middleware in middlewares\n+            if hasattr(middleware, \"process_start_requests\")\n+            and not hasattr(middleware, \"process_start\")\n+        ]\n+        self._use_start_requests = bool(deprecated_middlewares)\n+        if self._use_start_requests:\n+            deprecated_middleware_list = \", \".join(\n+                global_object_name(middleware.__class__)\n+                for middleware in deprecated_middlewares\n+            )\n+            warn(\n+                f\"The following enabled spider middlewares, directly or \"\n+                f\"through their parent classes, define the deprecated \"\n+                f\"process_start_requests() method: \"\n+                f\"{deprecated_middleware_list}. process_start_requests() has \"\n+                f\"been deprecated in favor of a new method, process_start(), \"\n+                f\"to support asynchronous code execution. \"\n+                f\"process_start_requests() will stop being called in a future \"\n+                f\"version of Scrapy. If you use Scrapy VERSION or higher \"\n+                f\"only, replace process_start_requests() with \"\n+                f\"process_start(); note that process_start() is a coroutine \"\n+                f\"(async def). If you need to maintain compatibility with \"\n+                f\"lower Scrapy versions, when defining \"\n+                f\"process_start_requests() in a spider middleware class, \"\n+                f\"define process_start() as well. See the release notes of \"\n+                f\"Scrapy VERSION for details: \"\n+                f\"https://docs.scrapy.org/en/VERSION/news.html\",\n+                ScrapyDeprecationWarning,\n+            )\n+\n     def _add_middleware(self, mw: Any) -> None:\n         super()._add_middleware(mw)\n         if hasattr(mw, \"process_spider_input\"):\n             self.methods[\"process_spider_input\"].append(mw.process_spider_input)\n-        if hasattr(mw, \"process_start_requests\"):\n-            self.methods[\"process_start_requests\"].appendleft(mw.process_start_requests)\n+        if self._use_start_requests:\n+            if hasattr(mw, \"process_start_requests\"):\n+                self.methods[\"process_start_requests\"].appendleft(\n+                    mw.process_start_requests\n+                )\n+        elif hasattr(mw, \"process_start\"):\n+            self.methods[\"process_start\"].appendleft(mw.process_start)",
      "comment": "It seems that if even one middleware doesn't define `process_start` method, `process_start` methods of other middlewares are not going to be called.",
      "comment_id": 2011990172,
      "user": "kmike",
      "created_at": "2025-03-25T12:30:36Z",
      "url": "https://github.com/scrapy/scrapy/pull/6729#discussion_r2011990172"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 6729,
      "file_path": "scrapy/crawler.py",
      "line": 154,
      "side": "RIGHT",
      "diff_hunk": "@@ -151,8 +151,7 @@ def crawl(self, *args: Any, **kwargs: Any) -> Generator[Deferred[Any], Any, None\n             self._apply_settings()\n             self._update_root_log_handler()\n             self.engine = self._create_engine()\n-            start_requests = iter(self.spider.start_requests())\n-            yield self.engine.open_spider(self.spider, start_requests)\n+            yield self.engine.open_spider(self.spider)",
      "comment": "There is a small difference in case start_requests is not a generator function (when it's a regular function which returns a list) - it'd be executed a bit earlier. But I don't think there should be any practical implications, it seems we can ignore this.",
      "comment_id": 2012024881,
      "user": "kmike",
      "created_at": "2025-03-25T12:51:18Z",
      "url": "https://github.com/scrapy/scrapy/pull/6729#discussion_r2012024881"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 6729,
      "file_path": "scrapy/extensions/telnet.py",
      "line": 107,
      "side": "LEFT",
      "diff_hunk": "@@ -104,7 +104,6 @@ def _get_telnet_vars(self) -> dict[str, Any]:\n         telnet_vars: dict[str, Any] = {\n             \"engine\": self.crawler.engine,\n             \"spider\": self.crawler.engine.spider,\n-            \"slot\": self.crawler.engine.slot,",
      "comment": "Do you know if there was anything useful for debugging here? Something like inprogress? I'm not sure :) \r\n\r\nIt seems we should drop this `Slot` / `_Slot`class, and just move everything to engine attributes. But it doesn't need to happen in this PR.",
      "comment_id": 2012030599,
      "user": "kmike",
      "created_at": "2025-03-25T12:54:17Z",
      "url": "https://github.com/scrapy/scrapy/pull/6729#discussion_r2012030599"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 6729,
      "file_path": "scrapy/extensions/telnet.py",
      "line": 107,
      "side": "LEFT",
      "diff_hunk": "@@ -104,7 +104,6 @@ def _get_telnet_vars(self) -> dict[str, Any]:\n         telnet_vars: dict[str, Any] = {\n             \"engine\": self.crawler.engine,\n             \"spider\": self.crawler.engine.spider,\n-            \"slot\": self.crawler.engine.slot,",
      "comment": "At a first stage, due to not understanding the code properly and the risk of wasting too much time of such a cleanup change without user-facing benefits, I decided against addressing #4296 as part of #6715.\r\n\r\nWhat I did was what I deemed the minimum necessary changes about it:\r\n\r\n1. Make the minimum backward-incompatible change in `Slot`, needed due to the start requests change.\r\n2. Make the class and attribute private already, since I am making a backward-incompatible change on them anyway, so that when we do #4296 we do not need to cover any backward incompatibility in the release notes.\r\n\r\nBut now that I am quite familiar with this part of the code, I don\u2019t know, it may be worth addressing as part of #6715 if I have the time.",
      "comment_id": 2012115159,
      "user": "Gallaecio",
      "created_at": "2025-03-25T13:33:27Z",
      "url": "https://github.com/scrapy/scrapy/pull/6729#discussion_r2012115159"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 6729,
      "file_path": "scrapy/core/spidermw.py",
      "line": 108,
      "side": "RIGHT",
      "diff_hunk": "@@ -55,12 +56,56 @@ class SpiderMiddlewareManager(MiddlewareManager):\n     def _get_mwlist_from_settings(cls, settings: BaseSettings) -> list[Any]:\n         return build_component_list(settings.getwithbase(\"SPIDER_MIDDLEWARES\"))\n \n+    def __init__(self, *middlewares: Any) -> None:\n+        self._check_deprecated_process_start_requests_use(middlewares)\n+        super().__init__(*middlewares)\n+\n+    def _check_deprecated_process_start_requests_use(\n+        self, middlewares: tuple[Any]\n+    ) -> None:\n+        deprecated_middlewares = [\n+            middleware\n+            for middleware in middlewares\n+            if hasattr(middleware, \"process_start_requests\")\n+            and not hasattr(middleware, \"process_start\")\n+        ]\n+        self._use_start_requests = bool(deprecated_middlewares)\n+        if self._use_start_requests:\n+            deprecated_middleware_list = \", \".join(\n+                global_object_name(middleware.__class__)\n+                for middleware in deprecated_middlewares\n+            )\n+            warn(\n+                f\"The following enabled spider middlewares, directly or \"\n+                f\"through their parent classes, define the deprecated \"\n+                f\"process_start_requests() method: \"\n+                f\"{deprecated_middleware_list}. process_start_requests() has \"\n+                f\"been deprecated in favor of a new method, process_start(), \"\n+                f\"to support asynchronous code execution. \"\n+                f\"process_start_requests() will stop being called in a future \"\n+                f\"version of Scrapy. If you use Scrapy VERSION or higher \"\n+                f\"only, replace process_start_requests() with \"\n+                f\"process_start(); note that process_start() is a coroutine \"\n+                f\"(async def). If you need to maintain compatibility with \"\n+                f\"lower Scrapy versions, when defining \"\n+                f\"process_start_requests() in a spider middleware class, \"\n+                f\"define process_start() as well. See the release notes of \"\n+                f\"Scrapy VERSION for details: \"\n+                f\"https://docs.scrapy.org/en/VERSION/news.html\",\n+                ScrapyDeprecationWarning,\n+            )\n+\n     def _add_middleware(self, mw: Any) -> None:\n         super()._add_middleware(mw)\n         if hasattr(mw, \"process_spider_input\"):\n             self.methods[\"process_spider_input\"].append(mw.process_spider_input)\n-        if hasattr(mw, \"process_start_requests\"):\n-            self.methods[\"process_start_requests\"].appendleft(mw.process_start_requests)\n+        if self._use_start_requests:\n+            if hasattr(mw, \"process_start_requests\"):\n+                self.methods[\"process_start_requests\"].appendleft(\n+                    mw.process_start_requests\n+                )\n+        elif hasattr(mw, \"process_start\"):\n+            self.methods[\"process_start\"].appendleft(mw.process_start)",
      "comment": "Nice catch. Shall we error out if there is 1+ non-universal old-style combined with 1+ non-universal new-style?",
      "comment_id": 2012272404,
      "user": "Gallaecio",
      "created_at": "2025-03-25T14:45:41Z",
      "url": "https://github.com/scrapy/scrapy/pull/6729#discussion_r2012272404"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 6729,
      "file_path": "scrapy/core/spidermw.py",
      "line": 108,
      "side": "RIGHT",
      "diff_hunk": "@@ -55,12 +56,56 @@ class SpiderMiddlewareManager(MiddlewareManager):\n     def _get_mwlist_from_settings(cls, settings: BaseSettings) -> list[Any]:\n         return build_component_list(settings.getwithbase(\"SPIDER_MIDDLEWARES\"))\n \n+    def __init__(self, *middlewares: Any) -> None:\n+        self._check_deprecated_process_start_requests_use(middlewares)\n+        super().__init__(*middlewares)\n+\n+    def _check_deprecated_process_start_requests_use(\n+        self, middlewares: tuple[Any]\n+    ) -> None:\n+        deprecated_middlewares = [\n+            middleware\n+            for middleware in middlewares\n+            if hasattr(middleware, \"process_start_requests\")\n+            and not hasattr(middleware, \"process_start\")\n+        ]\n+        self._use_start_requests = bool(deprecated_middlewares)\n+        if self._use_start_requests:\n+            deprecated_middleware_list = \", \".join(\n+                global_object_name(middleware.__class__)\n+                for middleware in deprecated_middlewares\n+            )\n+            warn(\n+                f\"The following enabled spider middlewares, directly or \"\n+                f\"through their parent classes, define the deprecated \"\n+                f\"process_start_requests() method: \"\n+                f\"{deprecated_middleware_list}. process_start_requests() has \"\n+                f\"been deprecated in favor of a new method, process_start(), \"\n+                f\"to support asynchronous code execution. \"\n+                f\"process_start_requests() will stop being called in a future \"\n+                f\"version of Scrapy. If you use Scrapy VERSION or higher \"\n+                f\"only, replace process_start_requests() with \"\n+                f\"process_start(); note that process_start() is a coroutine \"\n+                f\"(async def). If you need to maintain compatibility with \"\n+                f\"lower Scrapy versions, when defining \"\n+                f\"process_start_requests() in a spider middleware class, \"\n+                f\"define process_start() as well. See the release notes of \"\n+                f\"Scrapy VERSION for details: \"\n+                f\"https://docs.scrapy.org/en/VERSION/news.html\",\n+                ScrapyDeprecationWarning,\n+            )\n+\n     def _add_middleware(self, mw: Any) -> None:\n         super()._add_middleware(mw)\n         if hasattr(mw, \"process_spider_input\"):\n             self.methods[\"process_spider_input\"].append(mw.process_spider_input)\n-        if hasattr(mw, \"process_start_requests\"):\n-            self.methods[\"process_start_requests\"].appendleft(mw.process_start_requests)\n+        if self._use_start_requests:\n+            if hasattr(mw, \"process_start_requests\"):\n+                self.methods[\"process_start_requests\"].appendleft(\n+                    mw.process_start_requests\n+                )\n+        elif hasattr(mw, \"process_start\"):\n+            self.methods[\"process_start\"].appendleft(mw.process_start)",
      "comment": "Probably - I haven't understood the implementation yet :) \r\n\r\nFor the universal middlewares, is it possible to prefer `process_start` over `process_start_requests` if there are non-universal middlewares in the chain?",
      "comment_id": 2012290729,
      "user": "kmike",
      "created_at": "2025-03-25T14:53:22Z",
      "url": "https://github.com/scrapy/scrapy/pull/6729#discussion_r2012290729"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 6729,
      "file_path": "scrapy/core/spidermw.py",
      "line": 108,
      "side": "RIGHT",
      "diff_hunk": "@@ -55,12 +56,56 @@ class SpiderMiddlewareManager(MiddlewareManager):\n     def _get_mwlist_from_settings(cls, settings: BaseSettings) -> list[Any]:\n         return build_component_list(settings.getwithbase(\"SPIDER_MIDDLEWARES\"))\n \n+    def __init__(self, *middlewares: Any) -> None:\n+        self._check_deprecated_process_start_requests_use(middlewares)\n+        super().__init__(*middlewares)\n+\n+    def _check_deprecated_process_start_requests_use(\n+        self, middlewares: tuple[Any]\n+    ) -> None:\n+        deprecated_middlewares = [\n+            middleware\n+            for middleware in middlewares\n+            if hasattr(middleware, \"process_start_requests\")\n+            and not hasattr(middleware, \"process_start\")\n+        ]\n+        self._use_start_requests = bool(deprecated_middlewares)\n+        if self._use_start_requests:\n+            deprecated_middleware_list = \", \".join(\n+                global_object_name(middleware.__class__)\n+                for middleware in deprecated_middlewares\n+            )\n+            warn(\n+                f\"The following enabled spider middlewares, directly or \"\n+                f\"through their parent classes, define the deprecated \"\n+                f\"process_start_requests() method: \"\n+                f\"{deprecated_middleware_list}. process_start_requests() has \"\n+                f\"been deprecated in favor of a new method, process_start(), \"\n+                f\"to support asynchronous code execution. \"\n+                f\"process_start_requests() will stop being called in a future \"\n+                f\"version of Scrapy. If you use Scrapy VERSION or higher \"\n+                f\"only, replace process_start_requests() with \"\n+                f\"process_start(); note that process_start() is a coroutine \"\n+                f\"(async def). If you need to maintain compatibility with \"\n+                f\"lower Scrapy versions, when defining \"\n+                f\"process_start_requests() in a spider middleware class, \"\n+                f\"define process_start() as well. See the release notes of \"\n+                f\"Scrapy VERSION for details: \"\n+                f\"https://docs.scrapy.org/en/VERSION/news.html\",\n+                ScrapyDeprecationWarning,\n+            )\n+\n     def _add_middleware(self, mw: Any) -> None:\n         super()._add_middleware(mw)\n         if hasattr(mw, \"process_spider_input\"):\n             self.methods[\"process_spider_input\"].append(mw.process_spider_input)\n-        if hasattr(mw, \"process_start_requests\"):\n-            self.methods[\"process_start_requests\"].appendleft(mw.process_start_requests)\n+        if self._use_start_requests:\n+            if hasattr(mw, \"process_start_requests\"):\n+                self.methods[\"process_start_requests\"].appendleft(\n+                    mw.process_start_requests\n+                )\n+        elif hasattr(mw, \"process_start\"):\n+            self.methods[\"process_start\"].appendleft(mw.process_start)",
      "comment": "I went for an implementation where you cannot combine new-style and old-style middlewares, but you can mix either with universal. If there are new-style and universal, `process_start` is used. If there are old-style and universal, `process_start_requests` is used. What I had not accounted for was mixing new-style and old-style middlewares (only the equivalent for spider vs middlewares).",
      "comment_id": 2012302251,
      "user": "Gallaecio",
      "created_at": "2025-03-25T14:57:37Z",
      "url": "https://github.com/scrapy/scrapy/pull/6729#discussion_r2012302251"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 6729,
      "file_path": "tests/test_crawl.py",
      "line": 382,
      "side": "LEFT",
      "diff_hunk": "@@ -361,27 +351,6 @@ def cb(response):\n         assert s[\"engine.spider.name\"] == crawler.spider.name\n         assert s[\"len(engine.scraper.slot.active)\"] == \"1\"\n \n-    @defer.inlineCallbacks\n-    def test_graceful_crawl_error_handling(self):",
      "comment": "It was because I first switched it to async def generator, and that scenario was covered in later changes (in #6715, `test_exception_before_yield`).\r\n\r\nBut it seems it would make sense to keep a test about this for non-generator `start_requests`.",
      "comment_id": 2012499282,
      "user": "Gallaecio",
      "created_at": "2025-03-25T16:34:16Z",
      "url": "https://github.com/scrapy/scrapy/pull/6729#discussion_r2012499282"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 6729,
      "file_path": "scrapy/crawler.py",
      "line": 154,
      "side": "RIGHT",
      "diff_hunk": "@@ -151,8 +151,7 @@ def crawl(self, *args: Any, **kwargs: Any) -> Generator[Deferred[Any], Any, None\n             self._apply_settings()\n             self._update_root_log_handler()\n             self.engine = self._create_engine()\n-            start_requests = iter(self.spider.start_requests())\n-            yield self.engine.open_spider(self.spider, start_requests)\n+            yield self.engine.open_spider(self.spider)",
      "comment": "https://github.com/scrapy/scrapy/pull/6729/commits/97a0fed020926af464631d31bdfb354a12aea8c3",
      "comment_id": 2012534116,
      "user": "Gallaecio",
      "created_at": "2025-03-25T16:53:20Z",
      "url": "https://github.com/scrapy/scrapy/pull/6729#discussion_r2012534116"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 6729,
      "file_path": "scrapy/core/engine.py",
      "line": 129,
      "side": "RIGHT",
      "diff_hunk": "@@ -114,22 +125,28 @@ def _get_scheduler_class(self, settings: BaseSettings) -> type[BaseScheduler]:\n             )\n         return scheduler_cls\n \n-    @inlineCallbacks\n-    def start(self) -> Generator[Deferred[Any], Any, None]:\n+    @deferred_f_from_coro_f\n+    async def start(self, _start_request_processing=True) -> None:",
      "comment": "About the `_start_request_processing` parameter:\r\n\r\nStarting `spider.start()`  and `scheduler.next_request()` processing before `engine.start()` was problematic, because `engine.start()` sets `engine.running = True`, and before that, `engine.needs_backout()` returns `True`. This was one of the causes of the behavior differences in reactors, the asyncio one would happen to start request processing late enough for `engine.running` to be `True` already, but the default reactor would not.\r\n\r\nSo I concluded that request processing should be delayed until the engine starts.\r\n\r\nSo I moved the corresponding lines from `engine.open_spider()` to a separate, public method (should it be private?), and made `engine.start()` call it by default after setting `engine.running` to `True`. But I added a private parameter to allow disabling that, since the shell needs to delay that further.\r\n\r\nI wonder if this change could pave the way to make the shell open the spider before starting the engine, in line with `scrapy crawl`, but I don\u2019t want to go down that rabbit hole now, not even as part of the follow-up PR.",
      "comment_id": 2014920524,
      "user": "Gallaecio",
      "created_at": "2025-03-26T20:02:24Z",
      "url": "https://github.com/scrapy/scrapy/pull/6729#discussion_r2014920524"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 6729,
      "file_path": "scrapy/core/engine.py",
      "line": 381,
      "side": "LEFT",
      "diff_hunk": "@@ -362,31 +402,30 @@ def _on_complete(_: _T) -> _T:\n         dwld.addBoth(_on_complete)\n         return dwld\n \n-    @inlineCallbacks\n-    def open_spider(\n+    @deferred_f_from_coro_f\n+    async def open_spider(\n         self,\n         spider: Spider,\n-        start_requests: Iterable[Request] = (),\n         close_if_idle: bool = True,\n-    ) -> Generator[Deferred[Any], Any, None]:\n-        if self.slot is not None:\n+    ) -> None:\n+        if self._slot is not None:\n             raise RuntimeError(f\"No free spider slot when opening {spider.name!r}\")\n         logger.info(\"Spider opened\", extra={\"spider\": spider})\n-        nextcall = CallLaterOnce(self._next_request)\n+        self.spider = spider\n+        nextcall = CallLaterOnce(self._start_scheduled_requests)\n         scheduler = build_from_crawler(self.scheduler_cls, self.crawler)\n-        start_requests = yield self.scraper.spidermw.process_start_requests(\n-            start_requests, spider\n+        self._slot = _Slot(close_if_idle, nextcall, scheduler)\n+        self._start = await maybe_deferred_to_future(\n+            self.scraper.spidermw.process_start(spider)\n         )\n-        self.slot = Slot(start_requests, close_if_idle, nextcall, scheduler)\n-        self.spider = spider",
      "comment": "No technical reason for moving the definitions of spider and slot before the await, just felt cleaner.",
      "comment_id": 2014922432,
      "user": "Gallaecio",
      "created_at": "2025-03-26T20:04:01Z",
      "url": "https://github.com/scrapy/scrapy/pull/6729#discussion_r2014922432"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 6729,
      "file_path": "tests/test_cmdline_crawl_with_pipeline/__init__.py",
      "line": 23,
      "side": "RIGHT",
      "diff_hunk": "@@ -8,11 +8,16 @@ def _execute(self, spname):\n         args = (sys.executable, \"-m\", \"scrapy.cmdline\", \"crawl\", spname)\n         cwd = Path(__file__).resolve().parent\n         proc = Popen(args, stdout=PIPE, stderr=PIPE, cwd=cwd)\n-        proc.communicate()\n-        return proc.returncode\n+        _, stderr = proc.communicate()\n+        return proc.returncode, stderr\n \n     def test_open_spider_normally_in_pipeline(self):\n-        assert self._execute(\"normal\") == 0\n+        returncode, stderr = self._execute(\"normal\")\n+        assert returncode == 0\n \n     def test_exception_at_open_spider_in_pipeline(self):\n-        assert self._execute(\"exception\") == 1\n+        returncode, stderr = self._execute(\"exception\")\n+        assert (\n+            returncode == 0\n+        )  # An unhandled exception in a pipeline should not stop the crawl\n+        assert b'RuntimeError(\"exception\")' in stderr",
      "comment": "This change in expectations may be worth discussing, and if it stays, I should probably add it to the list of backward incompatibilities.\r\n\r\nDo we want *unhandled* exceptions in `SpiderMiddleware.open_spider` to prevent the spider from running normally? Should that apply to any handler of the [`spider_opened`](https://docs.scrapy.org/en/latest/topics/signals.html#std-signal-spider_opened) signal?",
      "comment_id": 2014926423,
      "user": "Gallaecio",
      "created_at": "2025-03-26T20:07:22Z",
      "url": "https://github.com/scrapy/scrapy/pull/6729#discussion_r2014926423"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 6729,
      "file_path": "scrapy/utils/reactor.py",
      "line": 137,
      "side": "RIGHT",
      "diff_hunk": "@@ -114,8 +131,10 @@ def set_asyncio_event_loop(event_loop_path: str | None) -> AbstractEventLoop:\n     \"\"\"Sets and returns the event loop with specified import path.\"\"\"\n     if event_loop_path is not None:\n         event_loop_class: type[AbstractEventLoop] = load_object(event_loop_path)\n-        event_loop = event_loop_class()\n-        asyncio.set_event_loop(event_loop)\n+        event_loop = _get_asyncio_event_loop()\n+        if not isinstance(event_loop, event_loop_class):\n+            event_loop = event_loop_class()\n+            asyncio.set_event_loop(event_loop)",
      "comment": "@wRAR I don\u2019t fully understand why this fixed [the hang](https://github.com/scrapy/scrapy/pull/6729#issuecomment-2755790919) or, more importantly, why this PR triggered the hang in the first place.",
      "comment_id": 2016212449,
      "user": "Gallaecio",
      "created_at": "2025-03-27T10:45:10Z",
      "url": "https://github.com/scrapy/scrapy/pull/6729#discussion_r2016212449"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 6729,
      "file_path": "scrapy/commands/bench.py",
      "line": 62,
      "side": "RIGHT",
      "diff_hunk": "@@ -61,10 +59,10 @@ class _BenchSpider(scrapy.Spider):\n     baseurl = \"http://localhost:8998\"\n     link_extractor = LinkExtractor()\n \n-    def start_requests(self) -> Iterable[Request]:\n+    async def start(self) -> AsyncIterator[Any]:",
      "comment": "@wRAR I looked into the differences between [`AsyncIterable`](https://docs.python.org/3/library/collections.abc.html#collections.abc.AsyncIterable) and [`AsyncIterator`](https://docs.python.org/3/library/collections.abc.html#collections.abc.AsyncIterator), and ended up going with the later. Asynchronous generators are both, but in the end we need an iterator, and an iterable is simply an object that can provide an iterator, so asking for the iterator directly seems simpler.",
      "comment_id": 2016375104,
      "user": "Gallaecio",
      "created_at": "2025-03-27T11:58:53Z",
      "url": "https://github.com/scrapy/scrapy/pull/6729#discussion_r2016375104"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 6729,
      "file_path": "scrapy/core/engine.py",
      "line": 115,
      "side": "RIGHT",
      "diff_hunk": "@@ -88,20 +93,26 @@ def __init__(\n         self.signals: SignalManager = crawler.signals\n         assert crawler.logformatter\n         self.logformatter: LogFormatter = crawler.logformatter\n-        self.slot: Slot | None = None\n+        self._slot: _Slot | None = None\n         self.spider: Spider | None = None\n         self.running: bool = False\n         self.paused: bool = False\n-        self.scheduler_cls: type[BaseScheduler] = self._get_scheduler_class(\n-            crawler.settings\n-        )\n-        downloader_cls: type[Downloader] = load_object(self.settings[\"DOWNLOADER\"])\n-        self.downloader: Downloader = downloader_cls(crawler)\n-        self.scraper: Scraper = Scraper(crawler)\n         self._spider_closed_callback: Callable[[Spider], Deferred[None] | None] = (\n             spider_closed_callback\n         )\n         self.start_time: float | None = None\n+        self._start: AsyncIterator[Any] | None = None\n+        self._started_request_processing = False\n+        downloader_cls: type[Downloader] = load_object(self.settings[\"DOWNLOADER\"])\n+        try:\n+            self.scheduler_cls: type[BaseScheduler] = self._get_scheduler_class(\n+                crawler.settings\n+            )\n+            self.downloader: Downloader = downloader_cls(crawler)\n+            self.scraper: Scraper = Scraper(crawler)\n+        except Exception:\n+            self.close()\n+            raise",
      "comment": "To exit cleanly in case of unhandled exceptions, since this is user-defined code.",
      "comment_id": 2016403637,
      "user": "Gallaecio",
      "created_at": "2025-03-27T12:04:29Z",
      "url": "https://github.com/scrapy/scrapy/pull/6729#discussion_r2016403637"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 6729,
      "file_path": "scrapy/shell.py",
      "line": 109,
      "side": "LEFT",
      "diff_hunk": "@@ -102,25 +103,33 @@ def _schedule(self, request: Request, spider: Spider | None) -> defer.Deferred[A\n             # set the asyncio event loop for the current thread\n             event_loop_path = self.crawler.settings[\"ASYNCIO_EVENT_LOOP\"]\n             set_asyncio_event_loop(event_loop_path)\n-        spider = self._open_spider(request, spider)\n+\n+        def crawl_request(_):\n+            assert self.crawler.engine is not None\n+            self.crawler.engine.crawl(request)\n+\n+        d2 = self._open_spider(request, spider)\n+        d2.addCallback(crawl_request)\n+\n         d = _request_deferred(request)\n         d.addCallback(lambda x: (x, spider))\n-        assert self.crawler.engine\n-        self.crawler.engine.crawl(request)",
      "comment": "I needed this to ensure that the spider had been opened by the time `engine.crawl()` was called.",
      "comment_id": 2016458152,
      "user": "Gallaecio",
      "created_at": "2025-03-27T12:22:34Z",
      "url": "https://github.com/scrapy/scrapy/pull/6729#discussion_r2016458152"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 6729,
      "file_path": "tests/test_crawl.py",
      "line": 232,
      "side": "LEFT",
      "diff_hunk": "@@ -185,45 +185,35 @@ def test_start_requests_bug_yielding(self):\n         assert record.exc_info[0] is ZeroDivisionError\n \n     @defer.inlineCallbacks\n-    def test_start_requests_items(self):\n+    def test_start_items(self):\n         with LogCapture(\"scrapy\", level=logging.ERROR) as log:\n-            crawler = get_crawler(StartRequestsItemSpider)\n+            crawler = get_crawler(StartItemSpider)\n             yield crawler.crawl(mockserver=self.mockserver)\n \n         assert len(log.records) == 0\n \n     @defer.inlineCallbacks\n-    def test_start_requests_unsupported_output(self):\n+    def test_start_unsupported_output(self):\n         \"\"\"Anything that is not a request is assumed to be an item, avoiding a\n-        potentially expensive call to itemadapter.is_item, and letting instead\n-        things fail when ItemAdapter is actually used on the corresponding\n-        non-item object.\"\"\"\n-\n+        potentially expensive call to itemadapter.is_item(), and letting\n+        instead things fail when ItemAdapter is actually used on the\n+        corresponding non-item object.\"\"\"\n         with LogCapture(\"scrapy\", level=logging.ERROR) as log:\n-            crawler = get_crawler(StartRequestsGoodAndBadOutput)\n+            crawler = get_crawler(StartGoodAndBadOutput)\n             yield crawler.crawl(mockserver=self.mockserver)\n \n         assert len(log.records) == 0\n \n     @defer.inlineCallbacks\n-    def test_start_requests_laziness(self):\n-        settings = {\"CONCURRENT_REQUESTS\": 1}\n-        crawler = get_crawler(BrokenStartRequestsSpider, settings)\n-        yield crawler.crawl(mockserver=self.mockserver)\n-        assert crawler.spider.seedsseen.index(None) < crawler.spider.seedsseen.index(\n-            99\n-        ), crawler.spider.seedsseen",
      "comment": "Replaced by `tests/test_engine_loop.py::RequestSendOrderTestCase::test_lazy`.",
      "comment_id": 2016481106,
      "user": "Gallaecio",
      "created_at": "2025-03-27T12:34:33Z",
      "url": "https://github.com/scrapy/scrapy/pull/6729#discussion_r2016481106"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 6729,
      "file_path": "tests/test_downloadermiddleware.py",
      "line": 52,
      "side": "RIGHT",
      "diff_hunk": "@@ -44,7 +49,7 @@ def download_func(request, spider):\n         # catch deferred result and return the value\n         results = []\n         dfd.addBoth(results.append)\n-        self._wait(dfd)\n+        await maybe_deferred_to_future(dfd)",
      "comment": "These changes were not just stylistic, `self._wait` was hanging. I don\u2019t really understand why, but since it was a test-specific issue, once I realized switching to modern syntax solved the issue, I did not put any more thought into it.",
      "comment_id": 2016486712,
      "user": "Gallaecio",
      "created_at": "2025-03-27T12:37:46Z",
      "url": "https://github.com/scrapy/scrapy/pull/6729#discussion_r2016486712"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 6729,
      "file_path": "tests/test_engine.py",
      "line": 193,
      "side": "LEFT",
      "diff_hunk": "@@ -190,7 +190,6 @@ def run(self):\n             self.response_downloaded, signals.response_downloaded\n         )\n         self.crawler.crawl(start_urls=start_urls)\n-        self.spider = self.crawler.spider",
      "comment": "At this point `self.crawler.spider` was no longer defined, since the earlier `crawl()` is async. I changed the implementation to just read the spider from the crawler where needed, since by the time that is used the spider has been defined already.",
      "comment_id": 2016491763,
      "user": "Gallaecio",
      "created_at": "2025-03-27T12:40:44Z",
      "url": "https://github.com/scrapy/scrapy/pull/6729#discussion_r2016491763"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 6729,
      "file_path": "scrapy/core/engine.py",
      "line": 253,
      "side": "RIGHT",
      "diff_hunk": "@@ -163,58 +179,84 @@ def pause(self) -> None:\n     def unpause(self) -> None:\n         self.paused = False\n \n-    def _next_request(self) -> None:\n-        if self.slot is None:\n-            return\n+    async def _process_start_next(self):\n+        \"\"\"Processes the next item or request from Spider.start().\n \n-        assert self.spider is not None  # typing\n-\n-        if self.paused:\n+        If a request, it is scheduled. If an item, it is sent to item\n+        pipelines.\n+        \"\"\"\n+        try:\n+            item_or_request = await self._start.__anext__()\n+        except StopAsyncIteration:\n+            self._start = None\n+        except Exception as exception:\n+            self._start = None\n+            exception_traceback = format_exc()\n+            logger.error(\n+                f\"Error while reading start items and requests: {exception}.\\n{exception_traceback}\",\n+                exc_info=True,\n+            )\n+        else:\n+            if not self.spider:\n+                return  # spider already closed\n+            if isinstance(item_or_request, Request):\n+                self.crawl(item_or_request)\n+            else:\n+                self.scraper.start_itemproc(item_or_request, response=None)\n+                self._slot.nextcall.schedule()\n+\n+    @deferred_f_from_coro_f\n+    async def _start_request_processing(self) -> None:\n+        \"\"\"Starts consuming Spider.start() output and sending scheduled\n+        requests.\"\"\"\n+        # Starts the processing of scheduled requests, as well as a periodic\n+        # call to that processing method for scenarios where the scheduler\n+        # reports having pending requests but returns none.\n+        assert self._slot is not None  # typing\n+        self._slot.nextcall.schedule()\n+        self._slot.heartbeat.start(self._SLOT_HEARTBEAT_INTERVAL)\n+\n+        while self._start and self.spider:\n+            await self._process_start_next()\n+            if not self.needs_backout():\n+                # Give room for the outcome of self._process_start_next() to be\n+                # processed before continuing with the next iteration.\n+                self._slot.nextcall.schedule()\n+                await self._slot.nextcall.wait()\n+\n+    def _start_scheduled_requests(self) -> None:\n+        if self._slot is None or self._slot.closing is not None or self.paused:\n             return\n \n-        while (\n-            not self._needs_backout()\n-            and self._next_request_from_scheduler() is not None\n-        ):\n-            pass\n-\n-        if self.slot.start_requests is not None and not self._needs_backout():\n-            try:\n-                request_or_item = next(self.slot.start_requests)\n-            except StopIteration:\n-                self.slot.start_requests = None\n-            except Exception:\n-                self.slot.start_requests = None\n-                logger.error(\n-                    \"Error while obtaining start requests\",\n-                    exc_info=True,\n-                    extra={\"spider\": self.spider},\n-                )\n-            else:\n-                if isinstance(request_or_item, Request):\n-                    self.crawl(request_or_item)\n-                else:\n-                    self.scraper.start_itemproc(request_or_item, response=None)\n+        while not self.needs_backout():\n+            if self._start_scheduled_request() is None:\n+                break\n \n-        if self.spider_is_idle() and self.slot.close_if_idle:\n+        if self.spider_is_idle() and self._slot.close_if_idle:\n             self._spider_idle()\n \n-    def _needs_backout(self) -> bool:\n-        assert self.slot is not None  # typing\n+    def needs_backout(self) -> bool:\n+        \"\"\"Returns ``True`` if no more requests can be sent at the moment, or\n+        ``False`` otherwise.\n+\n+        See :ref:`start-requests-lazy` for an example.\n+        \"\"\"\n+        assert self._slot is not None  # typing\n         assert self.scraper.slot is not None  # typing\n         return (\n             not self.running\n-            or bool(self.slot.closing)\n+            or bool(self._slot.closing)\n             or self.downloader.needs_backout()\n             or self.scraper.slot.needs_backout()\n         )\n \n-    def _next_request_from_scheduler(self) -> Deferred[None] | None:\n-        assert self.slot is not None  # typing\n+    def _start_scheduled_request(self) -> Deferred[None] | None:",
      "comment": "The returned deferred is never used, but it was the same with `_next_request_from_scheduler()`.\r\n\r\nI wonder if it's saved somewhere deep inside the code or is just garbage collected at a random time.",
      "comment_id": 2029284426,
      "user": "wRAR",
      "created_at": "2025-04-04T18:45:48Z",
      "url": "https://github.com/scrapy/scrapy/pull/6729#discussion_r2029284426"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 6729,
      "file_path": "scrapy/core/engine.py",
      "line": 253,
      "side": "RIGHT",
      "diff_hunk": "@@ -163,58 +179,84 @@ def pause(self) -> None:\n     def unpause(self) -> None:\n         self.paused = False\n \n-    def _next_request(self) -> None:\n-        if self.slot is None:\n-            return\n+    async def _process_start_next(self):\n+        \"\"\"Processes the next item or request from Spider.start().\n \n-        assert self.spider is not None  # typing\n-\n-        if self.paused:\n+        If a request, it is scheduled. If an item, it is sent to item\n+        pipelines.\n+        \"\"\"\n+        try:\n+            item_or_request = await self._start.__anext__()\n+        except StopAsyncIteration:\n+            self._start = None\n+        except Exception as exception:\n+            self._start = None\n+            exception_traceback = format_exc()\n+            logger.error(\n+                f\"Error while reading start items and requests: {exception}.\\n{exception_traceback}\",\n+                exc_info=True,\n+            )\n+        else:\n+            if not self.spider:\n+                return  # spider already closed\n+            if isinstance(item_or_request, Request):\n+                self.crawl(item_or_request)\n+            else:\n+                self.scraper.start_itemproc(item_or_request, response=None)\n+                self._slot.nextcall.schedule()\n+\n+    @deferred_f_from_coro_f\n+    async def _start_request_processing(self) -> None:\n+        \"\"\"Starts consuming Spider.start() output and sending scheduled\n+        requests.\"\"\"\n+        # Starts the processing of scheduled requests, as well as a periodic\n+        # call to that processing method for scenarios where the scheduler\n+        # reports having pending requests but returns none.\n+        assert self._slot is not None  # typing\n+        self._slot.nextcall.schedule()\n+        self._slot.heartbeat.start(self._SLOT_HEARTBEAT_INTERVAL)\n+\n+        while self._start and self.spider:\n+            await self._process_start_next()\n+            if not self.needs_backout():\n+                # Give room for the outcome of self._process_start_next() to be\n+                # processed before continuing with the next iteration.\n+                self._slot.nextcall.schedule()\n+                await self._slot.nextcall.wait()\n+\n+    def _start_scheduled_requests(self) -> None:\n+        if self._slot is None or self._slot.closing is not None or self.paused:\n             return\n \n-        while (\n-            not self._needs_backout()\n-            and self._next_request_from_scheduler() is not None\n-        ):\n-            pass\n-\n-        if self.slot.start_requests is not None and not self._needs_backout():\n-            try:\n-                request_or_item = next(self.slot.start_requests)\n-            except StopIteration:\n-                self.slot.start_requests = None\n-            except Exception:\n-                self.slot.start_requests = None\n-                logger.error(\n-                    \"Error while obtaining start requests\",\n-                    exc_info=True,\n-                    extra={\"spider\": self.spider},\n-                )\n-            else:\n-                if isinstance(request_or_item, Request):\n-                    self.crawl(request_or_item)\n-                else:\n-                    self.scraper.start_itemproc(request_or_item, response=None)\n+        while not self.needs_backout():\n+            if self._start_scheduled_request() is None:\n+                break\n \n-        if self.spider_is_idle() and self.slot.close_if_idle:\n+        if self.spider_is_idle() and self._slot.close_if_idle:\n             self._spider_idle()\n \n-    def _needs_backout(self) -> bool:\n-        assert self.slot is not None  # typing\n+    def needs_backout(self) -> bool:\n+        \"\"\"Returns ``True`` if no more requests can be sent at the moment, or\n+        ``False`` otherwise.\n+\n+        See :ref:`start-requests-lazy` for an example.\n+        \"\"\"\n+        assert self._slot is not None  # typing\n         assert self.scraper.slot is not None  # typing\n         return (\n             not self.running\n-            or bool(self.slot.closing)\n+            or bool(self._slot.closing)\n             or self.downloader.needs_backout()\n             or self.scraper.slot.needs_backout()\n         )\n \n-    def _next_request_from_scheduler(self) -> Deferred[None] | None:\n-        assert self.slot is not None  # typing\n+    def _start_scheduled_request(self) -> Deferred[None] | None:",
      "comment": "Yes, I think you do not need to await deferreds. I think what\u2019s an issue is when you define a deferred but never trigger or cancel it, but it is fine not to await deferreds.\r\n\r\nHowever, given this is a private method, it may be better to not return it to begin with.",
      "comment_id": 2030927344,
      "user": "Gallaecio",
      "created_at": "2025-04-07T10:13:11Z",
      "url": "https://github.com/scrapy/scrapy/pull/6729#discussion_r2030927344"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 6729,
      "file_path": "scrapy/core/spidermw.py",
      "line": 391,
      "side": "RIGHT",
      "diff_hunk": "@@ -323,10 +388,91 @@ def process_spider_exception(\n         dfd2.addErrback(process_spider_exception)\n         return dfd2\n \n-    def process_start_requests(\n-        self, start_requests: Iterable[Request], spider: Spider\n-    ) -> Deferred[Iterable[Request]]:\n-        return self._process_chain(\"process_start_requests\", start_requests, spider)\n+    @deferred_f_from_coro_f",
      "comment": "I think we don't need the Deferred wrapper here, as this is a new function.",
      "comment_id": 2076117736,
      "user": "wRAR",
      "created_at": "2025-05-06T19:26:44Z",
      "url": "https://github.com/scrapy/scrapy/pull/6729#discussion_r2076117736"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 6767,
      "file_path": "scrapy/core/scraper.py",
      "line": 250,
      "side": "RIGHT",
      "diff_hunk": "@@ -156,103 +155,101 @@ def enqueue_scrape(\n         if self.slot is None:\n             raise RuntimeError(\"Scraper slot not assigned\")\n         dfd = self.slot.add_response_request(result, request)\n-\n-        def finish_scraping(_: _T) -> _T:\n-            assert self.slot is not None\n-            self.slot.finish_response(result, request)\n-            self._check_if_closing()\n-            self._scrape_next()\n-            return _\n-\n-        dfd.addBoth(finish_scraping)\n-        dfd.addErrback(\n-            lambda f: logger.error(\n+        self._scrape_next()\n+        try:\n+            yield dfd\n+        except Exception:\n+            logger.error(\n                 \"Scraper bug processing %(request)s\",\n                 {\"request\": request},\n-                exc_info=failure_to_exc_info(f),\n+                exc_info=True,\n                 extra={\"spider\": self.crawler.spider},\n             )\n-        )\n-        self._scrape_next()\n-        return dfd\n+        finally:\n+            self.slot.finish_response(result, request)\n+            self._check_if_closing()\n+            self._scrape_next()\n \n     def _scrape_next(self) -> None:\n         assert self.slot is not None  # typing\n         while self.slot.queue:\n-            response, request, deferred = self.slot.next_response_request_deferred()\n-            self._scrape(response, request).chainDeferred(deferred)\n+            result, request, deferred = self.slot.next_response_request_deferred()\n+            self._scrape(result, request).chainDeferred(deferred)\n \n+    @inlineCallbacks\n     def _scrape(\n         self, result: Response | Failure, request: Request\n-    ) -> _HandleOutputDeferred:\n-        \"\"\"\n-        Handle the downloaded response or failure through the spider callback/errback\n-        \"\"\"\n+    ) -> Generator[Deferred[Any], Any, None]:\n+        \"\"\"Handle the downloaded response or failure through the spider callback/errback.\"\"\"\n         if not isinstance(result, (Response, Failure)):\n             raise TypeError(\n                 f\"Incorrect type: expected Response or Failure, got {type(result)}: {result!r}\"\n             )\n-        dfd: Deferred[Iterable[Any] | AsyncIterable[Any]] = self._scrape2(\n-            result, request\n-        )  # returns spider's processed output\n-        dfd.addErrback(self.handle_spider_error, request, result)\n-        dfd2: _HandleOutputDeferred = dfd.addCallback(\n-            self.handle_spider_output, request, cast(Response, result)\n-        )\n-        return dfd2\n \n-    def _scrape2(\n-        self, result: Response | Failure, request: Request\n-    ) -> Deferred[Iterable[Any] | AsyncIterable[Any]]:\n-        \"\"\"\n-        Handle the different cases of request's result been a Response or a Failure\n-        \"\"\"\n+        assert self.crawler.spider\n         if isinstance(result, Response):\n-            # Deferreds are invariant so Mutable*Chain isn't matched to *Iterable\n-            assert self.crawler.spider\n-            return self.spidermw.scrape_response(  # type: ignore[return-value]\n-                self.call_spider, result, request, self.crawler.spider\n-            )\n-        # else result is a Failure\n-        dfd = self.call_spider(result, request)\n-        dfd.addErrback(self._log_download_errors, result, request)\n-        return dfd\n+            try:\n+                # call the spider middlewares and the request callback with the response\n+                output = yield self.spidermw.scrape_response(  # type: ignore[return-value]\n+                    self.call_spider, result, request, self.crawler.spider\n+                )\n+            except Exception:\n+                self.handle_spider_error(Failure(), request, result)\n+            else:\n+                yield self.handle_spider_output(output, request, cast(Response, result))\n+            return\n+\n+        try:\n+            # call the request errback with the downloader error\n+            yield self.call_spider(result, request)\n+        except Exception as spider_exc:\n+            # the errback didn't silence the exception\n+            if not result.check(IgnoreRequest):\n+                logkws = self.logformatter.download_error(\n+                    result, request, self.crawler.spider\n+                )\n+                logger.log(\n+                    *logformatter_adapter(logkws),\n+                    extra={\"spider\": self.crawler.spider},\n+                    exc_info=failure_to_exc_info(result),\n+                )\n+            if spider_exc is not result.value:\n+                # the errback raised a different exception, handle it\n+                self.handle_spider_error(Failure(), request, result)\n \n+    @inlineCallbacks\n     def call_spider(\n         self, result: Response | Failure, request: Request, spider: Spider | None = None\n-    ) -> Deferred[Iterable[Any] | AsyncIterable[Any]]:\n+    ) -> Generator[Deferred[Any], Any, Iterable[Any] | AsyncIterable[Any]]:\n+        \"\"\"Call the request callback or errback with the response or failure.\"\"\"\n         if spider is not None:\n             warnings.warn(\n                 \"Passing a 'spider' argument to Scraper.call_spider() is deprecated.\",\n                 category=ScrapyDeprecationWarning,\n                 stacklevel=2,\n             )\n \n+        yield _defer_sleep()\n         assert self.crawler.spider\n-        dfd: Deferred[Any]\n         if isinstance(result, Response):\n             if getattr(result, \"request\", None) is None:\n                 result.request = request\n             assert result.request\n             callback = result.request.callback or self.crawler.spider._parse\n             warn_on_generator_with_return_value(self.crawler.spider, callback)\n-            dfd = defer_succeed(result)\n-            dfd.addCallbacks(\n-                callback=callback, callbackKeywords=result.request.cb_kwargs\n-            )\n+            output = callback(result, **result.request.cb_kwargs)\n         else:  # result is a Failure\n             # TODO: properly type adding this attribute to a Failure\n             result.request = request  # type: ignore[attr-defined]\n-            dfd = defer_fail(result)\n-            if request.errback:\n-                warn_on_generator_with_return_value(\n-                    self.crawler.spider, request.errback\n-                )\n-                dfd.addErrback(request.errback)\n-        dfd2: Deferred[Iterable[Any] | AsyncIterable[Any]] = dfd.addCallback(\n-            iterate_spider_output\n-        )\n-        return dfd2\n+            if not request.errback:\n+                result.raiseException()\n+            warn_on_generator_with_return_value(self.crawler.spider, request.errback)\n+            output = request.errback(result)\n+            if isinstance(output, Failure):\n+                output.raiseException()\n+            # else the errback returned actual output (like a callback),",
      "comment": "I don't think we document this.\r\n\r\nBut Gemini knows that this is very much possible, there is at least one test that yields a dict from an errback and there is e.g. https://stackoverflow.com/a/59217406/113586 ",
      "comment_id": 2071849747,
      "user": "wRAR",
      "created_at": "2025-05-02T16:16:54Z",
      "url": "https://github.com/scrapy/scrapy/pull/6767#discussion_r2071849747"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 6767,
      "file_path": "scrapy/core/engine.py",
      "line": 254,
      "side": "RIGHT",
      "diff_hunk": "@@ -250,11 +250,10 @@ def _remove_request(_: Any) -> None:\n         )\n         return d2\n \n+    @inlineCallbacks\n     def _handle_downloader_output(",
      "comment": "Did you consider `async def` with the deferred decorator? I know we cannot use it at some key places, but I wonder if this is one of them.",
      "comment_id": 2071902435,
      "user": "Gallaecio",
      "created_at": "2025-05-02T17:01:03Z",
      "url": "https://github.com/scrapy/scrapy/pull/6767#discussion_r2071902435"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 6767,
      "file_path": "scrapy/core/engine.py",
      "line": 254,
      "side": "RIGHT",
      "diff_hunk": "@@ -250,11 +250,10 @@ def _remove_request(_: Any) -> None:\n         )\n         return d2\n \n+    @inlineCallbacks\n     def _handle_downloader_output(",
      "comment": "No, I didn't, I'll check what can be done straight away.",
      "comment_id": 2071923366,
      "user": "wRAR",
      "created_at": "2025-05-02T17:21:14Z",
      "url": "https://github.com/scrapy/scrapy/pull/6767#discussion_r2071923366"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 6767,
      "file_path": "scrapy/core/scraper.py",
      "line": 200,
      "side": "RIGHT",
      "diff_hunk": "@@ -156,67 +158,67 @@ def enqueue_scrape(\n         if self.slot is None:\n             raise RuntimeError(\"Scraper slot not assigned\")\n         dfd = self.slot.add_response_request(result, request)\n-\n-        def finish_scraping(_: _T) -> _T:\n-            assert self.slot is not None\n-            self.slot.finish_response(result, request)\n-            self._check_if_closing()\n-            self._scrape_next()\n-            return _\n-\n-        dfd.addBoth(finish_scraping)\n-        dfd.addErrback(\n-            lambda f: logger.error(\n+        self._scrape_next()\n+        try:\n+            yield dfd\n+        except Exception:\n+            logger.error(\n                 \"Scraper bug processing %(request)s\",\n                 {\"request\": request},\n-                exc_info=failure_to_exc_info(f),\n+                exc_info=True,\n                 extra={\"spider\": self.crawler.spider},\n             )\n-        )\n-        self._scrape_next()\n-        return dfd\n+        finally:\n+            self.slot.finish_response(result, request)\n+            self._check_if_closing()\n+            self._scrape_next()\n \n     def _scrape_next(self) -> None:\n         assert self.slot is not None  # typing\n         while self.slot.queue:\n-            response, request, deferred = self.slot.next_response_request_deferred()\n-            self._scrape(response, request).chainDeferred(deferred)\n+            result, request, deferred = self.slot.next_response_request_deferred()\n+            self._scrape(result, request).chainDeferred(deferred)\n \n-    def _scrape(\n-        self, result: Response | Failure, request: Request\n-    ) -> _HandleOutputDeferred:\n-        \"\"\"\n-        Handle the downloaded response or failure through the spider callback/errback\n-        \"\"\"\n+    @deferred_f_from_coro_f\n+    async def _scrape(self, result: Response | Failure, request: Request) -> None:\n+        \"\"\"Handle the downloaded response or failure through the spider callback/errback.\"\"\"\n         if not isinstance(result, (Response, Failure)):\n             raise TypeError(\n                 f\"Incorrect type: expected Response or Failure, got {type(result)}: {result!r}\"\n             )\n-        dfd: Deferred[Iterable[Any] | AsyncIterable[Any]] = self._scrape2(\n-            result, request\n-        )  # returns spider's processed output\n-        dfd.addErrback(self.handle_spider_error, request, result)\n-        dfd2: _HandleOutputDeferred = dfd.addCallback(\n-            self.handle_spider_output, request, cast(Response, result)\n-        )\n-        return dfd2\n \n-    def _scrape2(\n-        self, result: Response | Failure, request: Request\n-    ) -> Deferred[Iterable[Any] | AsyncIterable[Any]]:\n-        \"\"\"\n-        Handle the different cases of request's result been a Response or a Failure\n-        \"\"\"\n+        assert self.crawler.spider\n         if isinstance(result, Response):\n-            # Deferreds are invariant so Mutable*Chain isn't matched to *Iterable\n-            assert self.crawler.spider\n-            return self.spidermw.scrape_response(  # type: ignore[return-value]\n-                self.call_spider, result, request, self.crawler.spider\n-            )\n-        # else result is a Failure\n-        dfd = self.call_spider(result, request)\n-        dfd.addErrback(self._log_download_errors, result, request)\n-        return dfd\n+            try:\n+                # call the spider middlewares and the request callback with the response\n+                output = await maybe_deferred_to_future(\n+                    self.spidermw.scrape_response(\n+                        self.call_spider, result, request, self.crawler.spider\n+                    )\n+                )\n+            except Exception:\n+                self.handle_spider_error(Failure(), request, result)",
      "comment": "A new Failure instance is created without preserving the original exception context; consider capturing and passing the caught exception to retain error details.\n```suggestion\n            except Exception as exc:\n                self.handle_spider_error(Failure(exc), request, result)\n```",
      "comment_id": 2072452855,
      "user": "Copilot",
      "created_at": "2025-05-03T19:31:13Z",
      "url": "https://github.com/scrapy/scrapy/pull/6767#discussion_r2072452855"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 6766,
      "file_path": "scrapy/core/scraper.py",
      "line": 382,
      "side": "LEFT",
      "diff_hunk": "@@ -374,32 +374,24 @@ def _log_download_errors(\n         errors that got propagated thru here).\n \n         spider_failure: the value passed into the errback of self.call_spider()\n+        (likely raised in the request errback)\n+\n         download_failure: the value passed into _scrape2() from\n         ExecutionEngine._handle_downloader_output() as \"result\"\n+        (likely raised in the download handler or a downloader middleware)\n         \"\"\"\n         if not download_failure.check(IgnoreRequest):\n             assert self.crawler.spider\n-            if download_failure.frames:",
      "comment": "It shouldn't be possible to get a failure value without a traceback here, but also this branch works fine for such faliure values so the alternative one shouldn't be needed anyway.",
      "comment_id": 2070591882,
      "user": "wRAR",
      "created_at": "2025-05-01T18:01:26Z",
      "url": "https://github.com/scrapy/scrapy/pull/6766#discussion_r2070591882"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 6693,
      "file_path": "scrapy/spidermiddlewares/base.py",
      "line": 47,
      "side": "RIGHT",
      "diff_hunk": "@@ -0,0 +1,55 @@\n+from __future__ import annotations\n+\n+from typing import TYPE_CHECKING, Any\n+\n+from scrapy import Request, Spider\n+\n+if TYPE_CHECKING:\n+    from collections.abc import AsyncIterable, Iterable\n+\n+    from scrapy.http import Response\n+\n+\n+class BaseSpiderMiddleware:\n+    \"\"\"Optional base class for spider middlewares.\n+\n+    This class provides helper methods for asynchronous ``process_spider_output``\n+    methods. Middlewares that don't have a ``process_spider_output`` method don't need\n+    to use it.\n+    \"\"\"\n+\n+    def process_spider_output(\n+        self, response: Response, result: Iterable[Any], spider: Spider\n+    ) -> Iterable[Any]:\n+        for o in result:\n+            if isinstance(o, Request):\n+                o = self._process_request(o, response, spider)\n+                if o is not None:\n+                    yield o\n+            else:\n+                o = yield self._process_item(o, response, spider)\n+                if o is not None:\n+                    yield o\n+\n+    async def process_spider_output_async(\n+        self, response: Response, result: AsyncIterable[Any], spider: Spider\n+    ) -> AsyncIterable[Any]:\n+        async for o in result:\n+            if isinstance(o, Request):\n+                o = self._process_request(o, response, spider)\n+                if o is not None:\n+                    yield o\n+            else:\n+                o = yield self._process_item(o, response, spider)\n+                if o is not None:\n+                    yield o\n+\n+    def _process_request(",
      "comment": "I don\u2019t think so, that makes it look like they are not meant to be overridden.",
      "comment_id": 1970542317,
      "user": "Gallaecio",
      "created_at": "2025-02-25T21:07:17Z",
      "url": "https://github.com/scrapy/scrapy/pull/6693#discussion_r1970542317"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 6693,
      "file_path": "scrapy/spidermiddlewares/base.py",
      "line": 28,
      "side": "RIGHT",
      "diff_hunk": "@@ -0,0 +1,55 @@\n+from __future__ import annotations\n+\n+from typing import TYPE_CHECKING, Any\n+\n+from scrapy import Request, Spider\n+\n+if TYPE_CHECKING:\n+    from collections.abc import AsyncIterable, Iterable\n+\n+    from scrapy.http import Response\n+\n+\n+class BaseSpiderMiddleware:\n+    \"\"\"Optional base class for spider middlewares.\n+\n+    This class provides helper methods for asynchronous ``process_spider_output``\n+    methods. Middlewares that don't have a ``process_spider_output`` method don't need\n+    to use it.\n+    \"\"\"\n+\n+    def process_spider_output(\n+        self, response: Response, result: Iterable[Any], spider: Spider\n+    ) -> Iterable[Any]:\n+        for o in result:\n+            if isinstance(o, Request):\n+                o = self._process_request(o, response, spider)\n+                if o is not None:\n+                    yield o",
      "comment": "I wonder if we should use `yield from self.process_request(o, response)`, to allow yielding multiple items/requests based on a given request (or item below), and to keep `spider` off since it feels like an obsolete parameter not needed nowadays with the 1 crawler = 1 spider constraint.",
      "comment_id": 1970545514,
      "user": "Gallaecio",
      "created_at": "2025-02-25T21:10:08Z",
      "url": "https://github.com/scrapy/scrapy/pull/6693#discussion_r1970545514"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 6693,
      "file_path": "scrapy/spidermiddlewares/base.py",
      "line": 28,
      "side": "RIGHT",
      "diff_hunk": "@@ -0,0 +1,55 @@\n+from __future__ import annotations\n+\n+from typing import TYPE_CHECKING, Any\n+\n+from scrapy import Request, Spider\n+\n+if TYPE_CHECKING:\n+    from collections.abc import AsyncIterable, Iterable\n+\n+    from scrapy.http import Response\n+\n+\n+class BaseSpiderMiddleware:\n+    \"\"\"Optional base class for spider middlewares.\n+\n+    This class provides helper methods for asynchronous ``process_spider_output``\n+    methods. Middlewares that don't have a ``process_spider_output`` method don't need\n+    to use it.\n+    \"\"\"\n+\n+    def process_spider_output(\n+        self, response: Response, result: Iterable[Any], spider: Spider\n+    ) -> Iterable[Any]:\n+        for o in result:\n+            if isinstance(o, Request):\n+                o = self._process_request(o, response, spider)\n+                if o is not None:\n+                    yield o",
      "comment": "`yield from` would require users to yield the items, instead of returning them, right?",
      "comment_id": 1971392057,
      "user": "kmike",
      "created_at": "2025-02-26T11:04:33Z",
      "url": "https://github.com/scrapy/scrapy/pull/6693#discussion_r1971392057"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 6693,
      "file_path": "scrapy/spidermiddlewares/base.py",
      "line": 28,
      "side": "RIGHT",
      "diff_hunk": "@@ -0,0 +1,55 @@\n+from __future__ import annotations\n+\n+from typing import TYPE_CHECKING, Any\n+\n+from scrapy import Request, Spider\n+\n+if TYPE_CHECKING:\n+    from collections.abc import AsyncIterable, Iterable\n+\n+    from scrapy.http import Response\n+\n+\n+class BaseSpiderMiddleware:\n+    \"\"\"Optional base class for spider middlewares.\n+\n+    This class provides helper methods for asynchronous ``process_spider_output``\n+    methods. Middlewares that don't have a ``process_spider_output`` method don't need\n+    to use it.\n+    \"\"\"\n+\n+    def process_spider_output(\n+        self, response: Response, result: Iterable[Any], spider: Spider\n+    ) -> Iterable[Any]:\n+        for o in result:\n+            if isinstance(o, Request):\n+                o = self._process_request(o, response, spider)\n+                if o is not None:\n+                    yield o",
      "comment": "Yes. And it feels like we already had this conversation and decided not to go for it, so please ignore :)",
      "comment_id": 1971479005,
      "user": "Gallaecio",
      "created_at": "2025-02-26T12:13:02Z",
      "url": "https://github.com/scrapy/scrapy/pull/6693#discussion_r1971479005"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 6693,
      "file_path": "scrapy/spidermiddlewares/urllength.py",
      "line": 37,
      "side": "LEFT",
      "diff_hunk": "@@ -7,72 +7,49 @@\n from __future__ import annotations\n \n import logging\n-import warnings\n-from typing import TYPE_CHECKING, Any\n+from typing import TYPE_CHECKING\n \n-from scrapy.exceptions import NotConfigured, ScrapyDeprecationWarning\n-from scrapy.http import Request, Response\n+from scrapy.exceptions import NotConfigured\n+from scrapy.spidermiddlewares.base import BaseSpiderMiddleware\n \n if TYPE_CHECKING:\n-    from collections.abc import AsyncIterable, Iterable\n-\n     # typing.Self requires Python 3.11\n     from typing_extensions import Self\n \n-    from scrapy import Spider\n     from scrapy.crawler import Crawler\n-    from scrapy.settings import BaseSettings\n+    from scrapy.http import Request, Response\n \n \n logger = logging.getLogger(__name__)\n \n \n-class UrlLengthMiddleware:\n+class UrlLengthMiddleware(BaseSpiderMiddleware):\n+    crawler: Crawler\n+\n     def __init__(self, maxlength: int):\n         self.maxlength: int = maxlength\n \n-    @classmethod\n-    def from_settings(cls, settings: BaseSettings) -> Self:\n-        warnings.warn(\n-            f\"{cls.__name__}.from_settings() is deprecated, use from_crawler() instead.\",",
      "comment": "This is removed early but I don't think it's a big deal (we should try to remember to mention it in the release notes though).",
      "comment_id": 2052598971,
      "user": "wRAR",
      "created_at": "2025-04-21T15:27:45Z",
      "url": "https://github.com/scrapy/scrapy/pull/6693#discussion_r2052598971"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 6693,
      "file_path": "scrapy/spidermiddlewares/urllength.py",
      "line": 37,
      "side": "LEFT",
      "diff_hunk": "@@ -7,72 +7,49 @@\n from __future__ import annotations\n \n import logging\n-import warnings\n-from typing import TYPE_CHECKING, Any\n+from typing import TYPE_CHECKING\n \n-from scrapy.exceptions import NotConfigured, ScrapyDeprecationWarning\n-from scrapy.http import Request, Response\n+from scrapy.exceptions import NotConfigured\n+from scrapy.spidermiddlewares.base import BaseSpiderMiddleware\n \n if TYPE_CHECKING:\n-    from collections.abc import AsyncIterable, Iterable\n-\n     # typing.Self requires Python 3.11\n     from typing_extensions import Self\n \n-    from scrapy import Spider\n     from scrapy.crawler import Crawler\n-    from scrapy.settings import BaseSettings\n+    from scrapy.http import Request, Response\n \n \n logger = logging.getLogger(__name__)\n \n \n-class UrlLengthMiddleware:\n+class UrlLengthMiddleware(BaseSpiderMiddleware):\n+    crawler: Crawler\n+\n     def __init__(self, maxlength: int):\n         self.maxlength: int = maxlength\n \n-    @classmethod\n-    def from_settings(cls, settings: BaseSettings) -> Self:\n-        warnings.warn(\n-            f\"{cls.__name__}.from_settings() is deprecated, use from_crawler() instead.\",",
      "comment": "Maybe edit `news.rst` already as part of this PR, so we don\u2019t forget.",
      "comment_id": 2055820990,
      "user": "Gallaecio",
      "created_at": "2025-04-23T11:12:20Z",
      "url": "https://github.com/scrapy/scrapy/pull/6693#discussion_r2055820990"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 6738,
      "file_path": "scrapy/utils/misc.py",
      "line": 296,
      "side": "RIGHT",
      "diff_hunk": "@@ -280,24 +280,32 @@ def returns_none(return_node: ast.Return) -> bool:\n \n \n def warn_on_generator_with_return_value(\n-    spider: Spider, callable: Callable[..., Any]\n+    spider: Spider, func: Callable[..., Any]\n ) -> None:\n     \"\"\"\n     Logs a warning if a callable is a generator function and includes\n     a 'return' statement with a value different than None\n     \"\"\"\n+    settings = getattr(spider, \"settings\", None)\n+    getbool = getattr(settings, \"getbool\", None)\n+    if (\n+        settings\n+        and callable(getbool)\n+        and not getbool(\"WARN_ON_GENERATOR_RETURN_VALUE\", True)\n+    ):\n+        return",
      "comment": "Is this logic really necessary at run time? Or are the (pre-existing) tests taking shortcuts and causing some things to not be defined during the tests, when those things are always defined when actually running a crawl?",
      "comment_id": 2004146309,
      "user": "Gallaecio",
      "created_at": "2025-03-19T19:31:20Z",
      "url": "https://github.com/scrapy/scrapy/pull/6738#discussion_r2004146309"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 6738,
      "file_path": "scrapy/utils/misc.py",
      "line": 296,
      "side": "RIGHT",
      "diff_hunk": "@@ -280,24 +280,32 @@ def returns_none(return_node: ast.Return) -> bool:\n \n \n def warn_on_generator_with_return_value(\n-    spider: Spider, callable: Callable[..., Any]\n+    spider: Spider, func: Callable[..., Any]\n ) -> None:\n     \"\"\"\n     Logs a warning if a callable is a generator function and includes\n     a 'return' statement with a value different than None\n     \"\"\"\n+    settings = getattr(spider, \"settings\", None)\n+    getbool = getattr(settings, \"getbool\", None)\n+    if (\n+        settings\n+        and callable(getbool)\n+        and not getbool(\"WARN_ON_GENERATOR_RETURN_VALUE\", True)\n+    ):\n+        return",
      "comment": "Good point !! I actually the defensive checks because unit test uses a dummy spider object . I wanted to avoid attribute error but you are right ! ",
      "comment_id": 2004160474,
      "user": "MehrazRumman",
      "created_at": "2025-03-19T19:40:16Z",
      "url": "https://github.com/scrapy/scrapy/pull/6738#discussion_r2004160474"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 6738,
      "file_path": "scrapy/utils/misc.py",
      "line": 296,
      "side": "RIGHT",
      "diff_hunk": "@@ -280,24 +280,32 @@ def returns_none(return_node: ast.Return) -> bool:\n \n \n def warn_on_generator_with_return_value(\n-    spider: Spider, callable: Callable[..., Any]\n+    spider: Spider, func: Callable[..., Any]\n ) -> None:\n     \"\"\"\n     Logs a warning if a callable is a generator function and includes\n     a 'return' statement with a value different than None\n     \"\"\"\n+    settings = getattr(spider, \"settings\", None)\n+    getbool = getattr(settings, \"getbool\", None)\n+    if (\n+        settings\n+        and callable(getbool)\n+        and not getbool(\"WARN_ON_GENERATOR_RETURN_VALUE\", True)\n+    ):\n+        return",
      "comment": "> Let me know if you need any help getting the existing tests to pass, your code looks fine.\r\n\r\nThis is what I meant by this \u2191.\r\n\r\nYour code seemed fine to me as it was. If you have trouble making the test more real so that they pass with your changes, do let me know, it may not be trivial to fix.",
      "comment_id": 2004182981,
      "user": "Gallaecio",
      "created_at": "2025-03-19T19:55:07Z",
      "url": "https://github.com/scrapy/scrapy/pull/6738#discussion_r2004182981"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 6738,
      "file_path": "scrapy/utils/misc.py",
      "line": 296,
      "side": "RIGHT",
      "diff_hunk": "@@ -280,24 +280,32 @@ def returns_none(return_node: ast.Return) -> bool:\n \n \n def warn_on_generator_with_return_value(\n-    spider: Spider, callable: Callable[..., Any]\n+    spider: Spider, func: Callable[..., Any]\n ) -> None:\n     \"\"\"\n     Logs a warning if a callable is a generator function and includes\n     a 'return' statement with a value different than None\n     \"\"\"\n+    settings = getattr(spider, \"settings\", None)\n+    getbool = getattr(settings, \"getbool\", None)\n+    if (\n+        settings\n+        and callable(getbool)\n+        and not getbool(\"WARN_ON_GENERATOR_RETURN_VALUE\", True)\n+    ):\n+        return",
      "comment": "I get your point now ! I just gave it a try to fix the test case . I introduce a mockspider , setting attribute that has a getbool method and change all `None` to `MockSpider` .  If its not ok then , I certainly need your help to fix the test . \ud83d\ude04 ",
      "comment_id": 2004900319,
      "user": "MehrazRumman",
      "created_at": "2025-03-20T06:24:06Z",
      "url": "https://github.com/scrapy/scrapy/pull/6738#discussion_r2004900319"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 6738,
      "file_path": "scrapy/utils/misc.py",
      "line": 290,
      "side": "RIGHT",
      "diff_hunk": "@@ -286,6 +286,8 @@ def warn_on_generator_with_return_value(\n     Logs a warning if a callable is a generator function and includes\n     a 'return' statement with a value different than None\n     \"\"\"\n+    if not spider.settings.getbool(\"WARN_ON_GENERATOR_RETURN_VALUE\", True):\n+        return",
      "comment": "Since the setting exists in `default_settings.py`, I believe it is safe to remove `True`:\r\n\r\n```suggestion\r\n    if not spider.settings.getbool(\"WARN_ON_GENERATOR_RETURN_VALUE\"):\r\n        return\r\n```",
      "comment_id": 2005079248,
      "user": "Gallaecio",
      "created_at": "2025-03-20T08:48:29Z",
      "url": "https://github.com/scrapy/scrapy/pull/6738#discussion_r2005079248"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 6740,
      "file_path": "scrapy/core/scraper.py",
      "line": 249,
      "side": "RIGHT",
      "diff_hunk": "@@ -246,6 +246,7 @@ def handle_spider_error(\n             spider=spider,\n         )\n         assert self.crawler.stats\n+        self.crawler.stats.inc_value(\"spider_exceptions/exception_count\", spider=spider)",
      "comment": "```suggestion\r\n        self.crawler.stats.inc_value(\"spider_exceptions/total\", spider=spider)\r\n```",
      "comment_id": 2005067675,
      "user": "Gallaecio",
      "created_at": "2025-03-20T08:42:01Z",
      "url": "https://github.com/scrapy/scrapy/pull/6740#discussion_r2005067675"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 6714,
      "file_path": "tests/test_spider.py",
      "line": 154,
      "side": "RIGHT",
      "diff_hunk": "@@ -147,6 +149,13 @@ def test_log(self):\n class TestInitSpider(TestSpider):\n     spider_class = InitSpider\n \n+    def setUp(self):\n+        super().setUp()\n+        warnings.filterwarnings(\"ignore\", category=ScrapyDeprecationWarning)",
      "comment": "You should use a pytest mark instead, like in https://github.com/scrapy/scrapy/blob/1469b2739ea566a57e0b5f8e6bb104fd19460d24/tests/test_downloader_handlers.py#L428",
      "comment_id": 1986387912,
      "user": "wRAR",
      "created_at": "2025-03-09T18:28:13Z",
      "url": "https://github.com/scrapy/scrapy/pull/6714#discussion_r1986387912"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 6714,
      "file_path": "tests/test_spider.py",
      "line": 35,
      "side": "RIGHT",
      "diff_hunk": "@@ -28,9 +28,11 @@\n )\n from scrapy.spiders.init import InitSpider\n from scrapy.utils.test import get_crawler\n+from scrapy.exceptions import ScrapyDeprecationWarning\n from tests import get_testdata, tests_datadir\n \n \n+",
      "comment": "This suggests you haven't used `pre-commit`, as described in https://docs.scrapy.org/en/latest/contributing.html#pre-commit",
      "comment_id": 1986388076,
      "user": "wRAR",
      "created_at": "2025-03-09T18:28:45Z",
      "url": "https://github.com/scrapy/scrapy/pull/6714#discussion_r1986388076"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 6696,
      "file_path": "scrapy/utils/testproc.py",
      "line": 23,
      "side": "RIGHT",
      "diff_hunk": "@@ -2,18 +2,27 @@\n \n import os\n import sys\n+import warnings\n from typing import TYPE_CHECKING, cast\n \n from twisted.internet.defer import Deferred\n from twisted.internet.error import ProcessTerminated\n from twisted.internet.protocol import ProcessProtocol\n \n+from scrapy.exceptions import ScrapyDeprecationWarning\n+\n if TYPE_CHECKING:\n     from collections.abc import Iterable\n \n     from twisted.python.failure import Failure\n \n \n+warnings.warn(\n+    \"The scrapy.utils.testproc module is deprecated.\",\n+    ScrapyDeprecationWarning,\n+)",
      "comment": "[Found 1 use in scrapy-poet](https://github.com/scrapinghub/scrapy-poet/blob/703290b1f7854e2837a82a02bea01a537a033795/tests/test_middleware.py#L15). Not sure if it changes anything, through.",
      "comment_id": 1978911348,
      "user": "Gallaecio",
      "created_at": "2025-03-04T08:46:13Z",
      "url": "https://github.com/scrapy/scrapy/pull/6696#discussion_r1978911348"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 6696,
      "file_path": "scrapy/utils/testproc.py",
      "line": 23,
      "side": "RIGHT",
      "diff_hunk": "@@ -2,18 +2,27 @@\n \n import os\n import sys\n+import warnings\n from typing import TYPE_CHECKING, cast\n \n from twisted.internet.defer import Deferred\n from twisted.internet.error import ProcessTerminated\n from twisted.internet.protocol import ProcessProtocol\n \n+from scrapy.exceptions import ScrapyDeprecationWarning\n+\n if TYPE_CHECKING:\n     from collections.abc import Iterable\n \n     from twisted.python.failure import Failure\n \n \n+warnings.warn(\n+    \"The scrapy.utils.testproc module is deprecated.\",\n+    ScrapyDeprecationWarning,\n+)",
      "comment": "For the record, found GitHub code search quite powerful:\r\n\r\n> [/(?-i)\\btestproc\\b/ AND ( org:scrapy OR org:scrapy-plugins  OR org:zytedata OR org:scrapinghub ) AND NOT repo:scrapy/scrapy](https://github.com/search?q=%2F%28%3F-i%29%5Cbtestproc%5Cb%2F+AND+%28+org%3Ascrapy+OR+org%3Ascrapy-plugins++OR+org%3Azytedata+OR+org%3Ascrapinghub+%29+AND+NOT+repo%3Ascrapy%2Fscrapy+&type=code)\r\n",
      "comment_id": 1978924608,
      "user": "Gallaecio",
      "created_at": "2025-03-04T08:52:32Z",
      "url": "https://github.com/scrapy/scrapy/pull/6696#discussion_r1978924608"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 6696,
      "file_path": "scrapy/utils/testproc.py",
      "line": 23,
      "side": "RIGHT",
      "diff_hunk": "@@ -2,18 +2,27 @@\n \n import os\n import sys\n+import warnings\n from typing import TYPE_CHECKING, cast\n \n from twisted.internet.defer import Deferred\n from twisted.internet.error import ProcessTerminated\n from twisted.internet.protocol import ProcessProtocol\n \n+from scrapy.exceptions import ScrapyDeprecationWarning\n+\n if TYPE_CHECKING:\n     from collections.abc import Iterable\n \n     from twisted.python.failure import Failure\n \n \n+warnings.warn(\n+    \"The scrapy.utils.testproc module is deprecated.\",\n+    ScrapyDeprecationWarning,\n+)",
      "comment": "It indeed looks useful to that scrapy-poet test but most of the `testproc.py` code is generic, only 2 or so lines are specific to Scrapy. So I don't think Scrapy is a good place for shipping it.",
      "comment_id": 1981830565,
      "user": "wRAR",
      "created_at": "2025-03-05T17:07:03Z",
      "url": "https://github.com/scrapy/scrapy/pull/6696#discussion_r1981830565"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 6614,
      "file_path": "scrapy/settings/__init__.py",
      "line": 354,
      "side": "RIGHT",
      "diff_hunk": "@@ -299,6 +325,41 @@ def maxpriority(self) -> int:\n             return max(cast(int, self.getpriority(name)) for name in self)\n         return get_settings_priority(\"default\")\n \n+    def replace_in_component_list(\n+        self, name: _SettingsKeyT, old_cls: type, new_cls: type, pos: int | None = None\n+    ) -> None:\n+        \"\"\"Replace *old_cls* with *new_cls* in the *name* component list.\n+\n+        If *old_cls* is missing, :exc:`KeyError` is raised.\n+\n+        If *old_cls* was present as an import string, even more than once,\n+        those keys are dropped and replaced by *new_cls*.\n+\n+        If *pos* is specified, that is the value assigned to *new_cls* in the\n+        component list. Otherwise, the value of *old_cls* is used. If *old_cls*\n+        was present multiple times (possible with import strings) with\n+        different values, the value assigned to *new_cls* is one of them, with\n+        no guarantee about which one it is.\n+\n+        This change is applied regardless of the priority of the *name*\n+        setting. The setting priority is not affected by this change either.\n+        \"\"\"\n+        component_list = self.getdict(name)\n+        old_pos = None\n+        for cls_or_path in tuple(component_list):\n+            if isinstance(cls_or_path, str):\n+                _cls = load_object(cls_or_path)\n+            else:\n+                _cls = cls_or_path\n+            if _cls == old_cls:",
      "comment": "I ended up checking for identity instead of using `issubclass` and raising an exception if `old_cls` is not found, with the idea that add-ons can then log a warning or error to let the user know. Still not completely sure if this is the right approach, and even if so, whether or not we should provide the option to check for subclasses.",
      "comment_id": 1915107488,
      "user": "Gallaecio",
      "created_at": "2025-01-14T15:56:43Z",
      "url": "https://github.com/scrapy/scrapy/pull/6614#discussion_r1915107488"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 6614,
      "file_path": "scrapy/settings/__init__.py",
      "line": 127,
      "side": "RIGHT",
      "diff_hunk": "@@ -111,6 +112,31 @@ def __getitem__(self, opt_name: _SettingsKeyT) -> Any:\n     def __contains__(self, name: Any) -> bool:\n         return name in self.attributes\n \n+    def add_to_list(self, name: _SettingsKeyT, item: Any) -> None:\n+        \"\"\"Append *item* to the :class:`list` setting with the specified *name*\n+        if *item* is not already in that list.\n+\n+        This change is applied regardless of the priority of the *name*\n+        setting. The setting priority is not affected by this change either.\n+        \"\"\"\n+        value: list[str] = self.getlist(name)\n+        if item not in value:\n+            self.set(name, [*value, item], self.getpriority(name) or 0)\n+\n+    def remove_from_list(self, name: _SettingsKeyT, item: Any) -> None:\n+        \"\"\"Remove *item* to the :class:`list` setting with the specified",
      "comment": "```suggestion\r\n        \"\"\"Remove *item* from the :class:`list` setting with the specified\r\n```",
      "comment_id": 1916303728,
      "user": "wRAR",
      "created_at": "2025-01-15T10:21:18Z",
      "url": "https://github.com/scrapy/scrapy/pull/6614#discussion_r1916303728"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 6614,
      "file_path": "scrapy/settings/__init__.py",
      "line": 356,
      "side": "RIGHT",
      "diff_hunk": "@@ -299,6 +328,45 @@ def maxpriority(self) -> int:\n             return max(cast(int, self.getpriority(name)) for name in self)\n         return get_settings_priority(\"default\")\n \n+    def replace_in_component_list(\n+        self, name: _SettingsKeyT, old_cls: type, new_cls: type, pos: int | None = None\n+    ) -> None:\n+        \"\"\"Replace *old_cls* with *new_cls* in the *name* :ref:`component list\n+        <component-lists>`.\n+\n+        If *old_cls* is missing, or has :data:`None` as value, :exc:`KeyError`\n+        is raised.\n+\n+        If *old_cls* was present as an import string, even more than once,\n+        those keys are dropped and replaced by *new_cls*.\n+\n+        If *pos* is specified, that is the value assigned to *new_cls* in the\n+        component list. Otherwise, the value of *old_cls* is used. If *old_cls*\n+        was present multiple times (possible with import strings) with\n+        different values, the value assigned to *new_cls* is one of them, with\n+        no guarantee about which one it is.\n+\n+        This change is applied regardless of the priority of the *name*\n+        setting. The setting priority is not affected by this change either.\n+        \"\"\"\n+        component_list = self.getdict(name)\n+        old_pos = None\n+        for cls_or_path in tuple(component_list):\n+            if isinstance(cls_or_path, str):\n+                _cls = load_object(cls_or_path)",
      "comment": "Why is this check needed? Isn't load_object handling non-strings already?",
      "comment_id": 1940943632,
      "user": "kmike",
      "created_at": "2025-02-04T10:52:09Z",
      "url": "https://github.com/scrapy/scrapy/pull/6614#discussion_r1940943632"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 6614,
      "file_path": "scrapy/settings/__init__.py",
      "line": 354,
      "side": "RIGHT",
      "diff_hunk": "@@ -299,6 +325,41 @@ def maxpriority(self) -> int:\n             return max(cast(int, self.getpriority(name)) for name in self)\n         return get_settings_priority(\"default\")\n \n+    def replace_in_component_list(\n+        self, name: _SettingsKeyT, old_cls: type, new_cls: type, pos: int | None = None\n+    ) -> None:\n+        \"\"\"Replace *old_cls* with *new_cls* in the *name* component list.\n+\n+        If *old_cls* is missing, :exc:`KeyError` is raised.\n+\n+        If *old_cls* was present as an import string, even more than once,\n+        those keys are dropped and replaced by *new_cls*.\n+\n+        If *pos* is specified, that is the value assigned to *new_cls* in the\n+        component list. Otherwise, the value of *old_cls* is used. If *old_cls*\n+        was present multiple times (possible with import strings) with\n+        different values, the value assigned to *new_cls* is one of them, with\n+        no guarantee about which one it is.\n+\n+        This change is applied regardless of the priority of the *name*\n+        setting. The setting priority is not affected by this change either.\n+        \"\"\"\n+        component_list = self.getdict(name)\n+        old_pos = None\n+        for cls_or_path in tuple(component_list):\n+            if isinstance(cls_or_path, str):\n+                _cls = load_object(cls_or_path)\n+            else:\n+                _cls = cls_or_path\n+            if _cls == old_cls:",
      "comment": "The current approach (checking for exact classes) makes most sense to me. \r\n\r\nWe can extend it to raise a warning on subclasses, but we haven't seen these cases in the wild yet, right?",
      "comment_id": 1940946708,
      "user": "kmike",
      "created_at": "2025-02-04T10:54:25Z",
      "url": "https://github.com/scrapy/scrapy/pull/6614#discussion_r1940946708"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 6614,
      "file_path": "scrapy/settings/__init__.py",
      "line": 354,
      "side": "RIGHT",
      "diff_hunk": "@@ -299,6 +325,41 @@ def maxpriority(self) -> int:\n             return max(cast(int, self.getpriority(name)) for name in self)\n         return get_settings_priority(\"default\")\n \n+    def replace_in_component_list(\n+        self, name: _SettingsKeyT, old_cls: type, new_cls: type, pos: int | None = None\n+    ) -> None:\n+        \"\"\"Replace *old_cls* with *new_cls* in the *name* component list.\n+\n+        If *old_cls* is missing, :exc:`KeyError` is raised.\n+\n+        If *old_cls* was present as an import string, even more than once,\n+        those keys are dropped and replaced by *new_cls*.\n+\n+        If *pos* is specified, that is the value assigned to *new_cls* in the\n+        component list. Otherwise, the value of *old_cls* is used. If *old_cls*\n+        was present multiple times (possible with import strings) with\n+        different values, the value assigned to *new_cls* is one of them, with\n+        no guarantee about which one it is.\n+\n+        This change is applied regardless of the priority of the *name*\n+        setting. The setting priority is not affected by this change either.\n+        \"\"\"\n+        component_list = self.getdict(name)\n+        old_pos = None\n+        for cls_or_path in tuple(component_list):\n+            if isinstance(cls_or_path, str):\n+                _cls = load_object(cls_or_path)\n+            else:\n+                _cls = cls_or_path\n+            if _cls == old_cls:",
      "comment": "> we haven't seen these cases in the wild yet, right?\r\n\r\nNot that I recall, no.",
      "comment_id": 1940976585,
      "user": "Gallaecio",
      "created_at": "2025-02-04T11:15:09Z",
      "url": "https://github.com/scrapy/scrapy/pull/6614#discussion_r1940976585"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 6680,
      "file_path": "tests/test_http_headers.py",
      "line": 161,
      "side": "RIGHT",
      "diff_hunk": "@@ -152,15 +155,11 @@ def test_int_value(self):\n         self.assertEqual(h1.getlist(\"hey\"), [b\"5\"])\n \n     def test_invalid_value(self):\n-        self.assertRaisesRegex(\n-            TypeError, \"Unsupported value type\", Headers, {\"foo\": object()}\n-        )\n-        self.assertRaisesRegex(\n-            TypeError, \"Unsupported value type\", Headers().__setitem__, \"foo\", object()\n-        )\n-        self.assertRaisesRegex(\n-            TypeError, \"Unsupported value type\", Headers().setdefault, \"foo\", object()\n-        )\n-        self.assertRaisesRegex(\n-            TypeError, \"Unsupported value type\", Headers().setlist, \"foo\", [object()]\n-        )\n+        with pytest.raises(TypeError, match=\"Unsupported value type\"):\n+            Headers({\"foo\": object()})\n+        with pytest.raises(TypeError, match=\"Unsupported value type\"):\n+            Headers().__setitem__(\"foo\", object())",
      "comment": "```suggestion\r\n            Headers()[\"foo\"] = object()\r\n```",
      "comment_id": 1973309756,
      "user": "kmike",
      "created_at": "2025-02-27T10:31:40Z",
      "url": "https://github.com/scrapy/scrapy/pull/6680#discussion_r1973309756"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 6680,
      "file_path": "tests/test_item.py",
      "line": 48,
      "side": "RIGHT",
      "diff_hunk": "@@ -33,15 +36,18 @@ class TestItem(Item):\n         i4 = TestItem(i3)\n         self.assertEqual(i4[\"name\"], \"john doe\")\n \n-        self.assertRaises(KeyError, TestItem, {\"name\": \"john doe\", \"other\": \"foo\"})\n+        with pytest.raises(KeyError):\n+            TestItem({\"name\": \"john doe\", \"other\": \"foo\"})\n \n     def test_invalid_field(self):\n         class TestItem(Item):\n             pass\n \n         i = TestItem()\n-        self.assertRaises(KeyError, i.__setitem__, \"field\", \"text\")\n-        self.assertRaises(KeyError, i.__getitem__, \"field\")\n+        with pytest.raises(KeyError):\n+            i.__setitem__(\"field\", \"text\")",
      "comment": "```suggestion\r\n            i[\"field\"] = \"text\"\r\n```\r\n\r\nI think this style corresponds better to how users write the code, i.e. to what we really want to test.",
      "comment_id": 1973315355,
      "user": "kmike",
      "created_at": "2025-02-27T10:35:23Z",
      "url": "https://github.com/scrapy/scrapy/pull/6680#discussion_r1973315355"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 6680,
      "file_path": "tests/test_utils_datatypes.py",
      "line": 93,
      "side": "RIGHT",
      "diff_hunk": "@@ -87,8 +87,10 @@ def test_caseless(self):\n     def test_delete(self):\n         d = self.dict_class({\"key_lower\": 1})\n         del d[\"key_LOWER\"]\n-        self.assertRaises(KeyError, d.__getitem__, \"key_LOWER\")\n-        self.assertRaises(KeyError, d.__getitem__, \"key_lower\")\n+        with pytest.raises(KeyError):\n+            d.__getitem__(\"key_LOWER\")\n+        with pytest.raises(KeyError):\n+            d.__getitem__(\"key_lower\")",
      "comment": "```suggestion\r\n        with pytest.raises(KeyError):\r\n            d[\"key_LOWER\"]\r\n        with pytest.raises(KeyError):\r\n            d[\"key_lower\"]\r\n```",
      "comment_id": 1973323505,
      "user": "kmike",
      "created_at": "2025-02-27T10:39:27Z",
      "url": "https://github.com/scrapy/scrapy/pull/6680#discussion_r1973323505"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 6680,
      "file_path": "tests/test_utils_datatypes.py",
      "line": 288,
      "side": "RIGHT",
      "diff_hunk": "@@ -279,8 +282,10 @@ def test_set(self):\n         self.assertIn(set(\"bar\"), d)\n \n         # supplied sequence is a set, so checking for list (non)inclusion fails\n-        self.assertRaises(TypeError, (0, 1, 2) in d)\n-        self.assertRaises(TypeError, d.__contains__, [\"a\", \"b\", \"c\"])\n+        with pytest.raises(TypeError):\n+            [0, 1, 2] in d  # noqa: B015\n+        with pytest.raises(TypeError):\n+            d.__contains__([\"a\", \"b\", \"c\"])",
      "comment": "```suggestion\r\n            [\"a\", \"b\", \"c\"] in d\r\n```",
      "comment_id": 1973324614,
      "user": "kmike",
      "created_at": "2025-02-27T10:40:06Z",
      "url": "https://github.com/scrapy/scrapy/pull/6680#discussion_r1973324614"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 6680,
      "file_path": "tests/test_utils_datatypes.py",
      "line": 282,
      "side": "LEFT",
      "diff_hunk": "@@ -279,8 +282,10 @@ def test_set(self):\n         self.assertIn(set(\"bar\"), d)\n \n         # supplied sequence is a set, so checking for list (non)inclusion fails\n-        self.assertRaises(TypeError, (0, 1, 2) in d)",
      "comment": "It seems it was just a wrong test, checking that tuple should raise an error, while it wasn't raising it",
      "comment_id": 1973328682,
      "user": "kmike",
      "created_at": "2025-02-27T10:42:40Z",
      "url": "https://github.com/scrapy/scrapy/pull/6680#discussion_r1973328682"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 6680,
      "file_path": "tests/test_utils_datatypes.py",
      "line": 282,
      "side": "LEFT",
      "diff_hunk": "@@ -279,8 +282,10 @@ def test_set(self):\n         self.assertIn(set(\"bar\"), d)\n \n         # supplied sequence is a set, so checking for list (non)inclusion fails\n-        self.assertRaises(TypeError, (0, 1, 2) in d)",
      "comment": "> checking that tuple should raise an error\r\n\r\nBut the comment talks about a list, so I also don't know what was this supposed to test.",
      "comment_id": 1973454879,
      "user": "wRAR",
      "created_at": "2025-02-27T12:09:17Z",
      "url": "https://github.com/scrapy/scrapy/pull/6680#discussion_r1973454879"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 6618,
      "file_path": "scrapy/downloadermiddlewares/httpcompression.py",
      "line": 101,
      "side": "RIGHT",
      "diff_hunk": "@@ -78,9 +81,35 @@ def open_spider(self, spider: Spider) -> None:\n         if hasattr(spider, \"download_warnsize\"):\n             self._warn_size = spider.download_warnsize\n \n+    @staticmethod\n+    def _get_unsupported_suggestion(encoding: bytes) -> str:\n+        if encoding == b\"br\":\n+            return \" You need to install brotli or brotlicffi to use it.\"\n+        if encoding == b\"zstd\":\n+            return \" You need to install zstandard to use it.\"\n+        return \"\"\n+\n     def process_request(\n         self, request: Request, spider: Spider\n     ) -> Request | Response | None:\n+\n+        user_header = request.headers.get(\"Accept-Encoding\")\n+        if user_header:\n+            for user_encoding in user_header.split(b\",\"):\n+                user_encoding = user_encoding.strip()\n+                # Encoding specification can also include a weight,\n+                # we won't check such encodings.",
      "comment": "Would this do the job?\r\n\r\n```suggestion\r\n                user_encoding = user_encoding.split(\";\")[0].strip()\r\n```",
      "comment_id": 1922101229,
      "user": "Gallaecio",
      "created_at": "2025-01-20T09:45:18Z",
      "url": "https://github.com/scrapy/scrapy/pull/6618#discussion_r1922101229"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 6618,
      "file_path": "scrapy/downloadermiddlewares/httpcompression.py",
      "line": 90,
      "side": "RIGHT",
      "diff_hunk": "@@ -78,9 +81,35 @@ def open_spider(self, spider: Spider) -> None:\n         if hasattr(spider, \"download_warnsize\"):\n             self._warn_size = spider.download_warnsize\n \n+    @staticmethod\n+    def _get_unsupported_suggestion(encoding: bytes) -> str:\n+        if encoding == b\"br\":\n+            return \" You need to install brotli or brotlicffi to use it.\"\n+        if encoding == b\"zstd\":\n+            return \" You need to install zstandard to use it.\"\n+        return \"\"",
      "comment": "Indeed.\r\n\r\nTBH the code I pushed is \"sample\" one, as different design decisions need quite different code. That's also why there are no tests yet.",
      "comment_id": 1922112582,
      "user": "wRAR",
      "created_at": "2025-01-20T09:52:27Z",
      "url": "https://github.com/scrapy/scrapy/pull/6618#discussion_r1922112582"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 6618,
      "file_path": "scrapy/downloadermiddlewares/httpcompression.py",
      "line": 101,
      "side": "RIGHT",
      "diff_hunk": "@@ -78,9 +81,35 @@ def open_spider(self, spider: Spider) -> None:\n         if hasattr(spider, \"download_warnsize\"):\n             self._warn_size = spider.download_warnsize\n \n+    @staticmethod\n+    def _get_unsupported_suggestion(encoding: bytes) -> str:\n+        if encoding == b\"br\":\n+            return \" You need to install brotli or brotlicffi to use it.\"\n+        if encoding == b\"zstd\":\n+            return \" You need to install zstandard to use it.\"\n+        return \"\"\n+\n     def process_request(\n         self, request: Request, spider: Spider\n     ) -> Request | Response | None:\n+\n+        user_header = request.headers.get(\"Accept-Encoding\")\n+        if user_header:\n+            for user_encoding in user_header.split(b\",\"):\n+                user_encoding = user_encoding.strip()\n+                # Encoding specification can also include a weight,\n+                # we won't check such encodings.",
      "comment": "What if the weight is 0? :)\r\n\r\nI just don't know if there is a need to complicate the code here.",
      "comment_id": 1922113480,
      "user": "wRAR",
      "created_at": "2025-01-20T09:52:57Z",
      "url": "https://github.com/scrapy/scrapy/pull/6618#discussion_r1922113480"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 6618,
      "file_path": "scrapy/downloadermiddlewares/httpcompression.py",
      "line": 97,
      "side": "RIGHT",
      "diff_hunk": "@@ -78,9 +81,35 @@ def open_spider(self, spider: Spider) -> None:\n         if hasattr(spider, \"download_warnsize\"):\n             self._warn_size = spider.download_warnsize\n \n+    @staticmethod\n+    def _get_unsupported_suggestion(encoding: bytes) -> str:\n+        if encoding == b\"br\":\n+            return \" You need to install brotli or brotlicffi to use it.\"\n+        if encoding == b\"zstd\":\n+            return \" You need to install zstandard to use it.\"\n+        return \"\"\n+\n     def process_request(\n         self, request: Request, spider: Spider\n     ) -> Request | Response | None:\n+\n+        user_header = request.headers.get(\"Accept-Encoding\")\n+        if user_header:",
      "comment": "```suggestion\r\n        if user_header:\r\n            user_header = user_header.lower()\r\n```\r\n\r\nWhile I found no resource to confirm that the value is meant to be interpreted as case-insensitive ([this](https://github.com/jquery/codeorigin.jquery.com/issues/43) was the closest), I suspect it should be. And it might be weird not to warn about `BR` but warn about `br`.",
      "comment_id": 1922212392,
      "user": "Gallaecio",
      "created_at": "2025-01-20T10:56:58Z",
      "url": "https://github.com/scrapy/scrapy/pull/6618#discussion_r1922212392"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 6618,
      "file_path": "scrapy/downloadermiddlewares/httpcompression.py",
      "line": 101,
      "side": "RIGHT",
      "diff_hunk": "@@ -78,9 +81,35 @@ def open_spider(self, spider: Spider) -> None:\n         if hasattr(spider, \"download_warnsize\"):\n             self._warn_size = spider.download_warnsize\n \n+    @staticmethod\n+    def _get_unsupported_suggestion(encoding: bytes) -> str:\n+        if encoding == b\"br\":\n+            return \" You need to install brotli or brotlicffi to use it.\"\n+        if encoding == b\"zstd\":\n+            return \" You need to install zstandard to use it.\"\n+        return \"\"\n+\n     def process_request(\n         self, request: Request, spider: Spider\n     ) -> Request | Response | None:\n+\n+        user_header = request.headers.get(\"Accept-Encoding\")\n+        if user_header:\n+            for user_encoding in user_header.split(b\",\"):\n+                user_encoding = user_encoding.strip()\n+                # Encoding specification can also include a weight,\n+                # we won't check such encodings.",
      "comment": "Oh, I did not realize that was a possibility! :+1: ",
      "comment_id": 1922221269,
      "user": "Gallaecio",
      "created_at": "2025-01-20T11:02:29Z",
      "url": "https://github.com/scrapy/scrapy/pull/6618#discussion_r1922221269"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 6618,
      "file_path": "scrapy/downloadermiddlewares/httpcompression.py",
      "line": 152,
      "side": "RIGHT",
      "diff_hunk": "@@ -143,9 +145,11 @@ def _handle_encoding(\n             body = self._decode(body, encoding, max_size)\n         return body, to_keep\n \n+    @staticmethod\n     def _split_encodings(\n-        self, content_encoding: list[bytes]\n+        content_encoding: list[bytes],\n     ) -> tuple[list[bytes], list[bytes]]:\n+        supported_encodings = {*ACCEPTED_ENCODINGS, b\"x-gzip\"}",
      "comment": "I wonder if we should do something to make it easier to subclass the middleware to extend support for additional encodings, and hopefully make the implementation slightly cleaner that the same time.\r\n\r\ne.g. Define `HttpCompressionMiddleware.DECODERS` as:\r\n\r\n```python\r\nDECODERS = {\r\n    \"deflate\": inflate,\r\n    \"gzip\": gunzip,\r\n    \"x-gzip\": gunzip,\r\n}\r\n// br and zstd added conditionally based on available imports.\r\n\r\n// \u2026\r\n\r\nbody = self.DECODERS[encoding](body, max_size=max_size)\r\n\r\n// \u2026\r\n\r\nif encoding not in self.DECODERS:\r\n```\r\n\r\nNote that I am also suggesting making decoding functions public, to enable easier mapping of new keywords, e.g. `\"x-deflate\": inflate`.\r\n\r\nNo strong opinion on this, though. It\u2019s rather out of scope here. And I am not sure if making those functions public is a good idea.",
      "comment_id": 1957401787,
      "user": "Gallaecio",
      "created_at": "2025-02-16T19:57:03Z",
      "url": "https://github.com/scrapy/scrapy/pull/6618#discussion_r1957401787"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 6618,
      "file_path": "scrapy/downloadermiddlewares/httpcompression.py",
      "line": 162,
      "side": "RIGHT",
      "diff_hunk": "@@ -155,19 +159,35 @@ def _split_encodings(\n         to_decode: list[bytes] = []\n         while to_keep:\n             encoding = to_keep.pop()\n-            if encoding not in ACCEPTED_ENCODINGS:\n+            if encoding not in supported_encodings:",
      "comment": "It seems it changes the behavior for x-gzip encoding; previously it wasn't removed from the headers, and probably wasn't decoded at all? Hm, does it mean that x-gzip handling code was not working before?\r\n\r\nI think this change is for better, but we might want to mention it in the release notes.",
      "comment_id": 1973226370,
      "user": "kmike",
      "created_at": "2025-02-27T09:41:21Z",
      "url": "https://github.com/scrapy/scrapy/pull/6618#discussion_r1973226370"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 6618,
      "file_path": "scrapy/downloadermiddlewares/httpcompression.py",
      "line": 152,
      "side": "RIGHT",
      "diff_hunk": "@@ -143,9 +145,11 @@ def _handle_encoding(\n             body = self._decode(body, encoding, max_size)\n         return body, to_keep\n \n+    @staticmethod\n     def _split_encodings(\n-        self, content_encoding: list[bytes]\n+        content_encoding: list[bytes],\n     ) -> tuple[list[bytes], list[bytes]]:\n+        supported_encodings = {*ACCEPTED_ENCODINGS, b\"x-gzip\"}",
      "comment": "I recall suggesting a similar thing to @wRAR :) But it seems leaving it out of scope for this PR is better. It doesn't seem this PR adds any additional obstacles to implement it later.",
      "comment_id": 1973227312,
      "user": "kmike",
      "created_at": "2025-02-27T09:41:55Z",
      "url": "https://github.com/scrapy/scrapy/pull/6618#discussion_r1973227312"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 6618,
      "file_path": "scrapy/downloadermiddlewares/httpcompression.py",
      "line": 162,
      "side": "RIGHT",
      "diff_hunk": "@@ -155,19 +159,35 @@ def _split_encodings(\n         to_decode: list[bytes] = []\n         while to_keep:\n             encoding = to_keep.pop()\n-            if encoding not in ACCEPTED_ENCODINGS:\n+            if encoding not in supported_encodings:",
      "comment": "`x-gzip` handling was silently broken in 2.12.0 (IIRC) when this code was added. ",
      "comment_id": 1973243365,
      "user": "wRAR",
      "created_at": "2025-02-27T09:51:05Z",
      "url": "https://github.com/scrapy/scrapy/pull/6618#discussion_r1973243365"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 6671,
      "file_path": "tests/test_spider.py",
      "line": 833,
      "side": "RIGHT",
      "diff_hunk": "@@ -827,3 +827,18 @@ def test_undefined_parse_method(self):\n         exc_msg = \"Spider.parse callback is not defined\"\n         with self.assertRaisesRegex(NotImplementedError, exc_msg):\n             spider.parse(resp)\n+\n+\n+class CallbackDepsTest(unittest.TestCase):\n+    \"\"\"Making sure annotations on all non-abstract callbacks can be resolved.\"\"\"",
      "comment": "Should we mention scrapy-poet here? Maybe even move this to a separate file, e.g. `test_poet`, to test things intended not to break that downstream?",
      "comment_id": 1954742524,
      "user": "Gallaecio",
      "created_at": "2025-02-13T15:33:45Z",
      "url": "https://github.com/scrapy/scrapy/pull/6671#discussion_r1954742524"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 6664,
      "file_path": "scrapy/core/spidermw.py",
      "line": 352,
      "side": "RIGHT",
      "diff_hunk": "@@ -340,10 +337,19 @@ def _get_async_method_pair(\n         methodname_async = methodname + \"_async\"\n         async_method: Callable | None = getattr(mw, methodname_async, None)\n         if not async_method:\n+            if normal_method and not isasyncgenfunction(normal_method):\n+                logger.warning(\n+                    f\"Middleware {global_object_name(mw.__class__)} doesn't support\"\n+                    f\" asynchronous spider output, this is deprecated and will stop\"\n+                    f\" working in a future version of Scrapy. The middleware should\"\n+                    f\" be updated to support it. Please see\"\n+                    f\" https://docs.scrapy.org/en/latest/topics/coroutines.html#mixing-synchronous-and-asynchronous-spider-middlewares\"\n+                    f\" for more information.\"\n+                )\n             return normal_method\n         if not normal_method:\n             logger.error(\n-                f\"Middleware {mw.__qualname__} has {methodname_async} \"\n+                f\"Middleware {global_object_name(mw.__class__)} has {methodname_async} \"",
      "comment": "This was a bug, hidden because the tests used the MiddlewareManager API incorrectly.",
      "comment_id": 1947944934,
      "user": "wRAR",
      "created_at": "2025-02-08T20:42:30Z",
      "url": "https://github.com/scrapy/scrapy/pull/6664#discussion_r1947944934"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 6657,
      "file_path": "scrapy/crawler.py",
      "line": 129,
      "side": "LEFT",
      "diff_hunk": "@@ -113,20 +113,27 @@ def _apply_settings(self) -> None:\n \n         reactor_class: str = self.settings[\"TWISTED_REACTOR\"]\n         event_loop: str = self.settings[\"ASYNCIO_EVENT_LOOP\"]\n+        logged_reactor_info: bool = False\n+\n         if self._init_reactor:\n             # this needs to be done after the spider settings are merged,\n             # but before something imports twisted.internet.reactor\n             if reactor_class:\n                 install_reactor(reactor_class, event_loop)\n             else:\n                 from twisted.internet import reactor  # noqa: F401\n-            log_reactor_info()\n+\n+            if not logged_reactor_info:\n+                log_reactor_info()\n+                logged_reactor_info = True\n+\n         if reactor_class:\n             verify_installed_reactor(reactor_class)\n             if is_asyncio_reactor_installed() and event_loop:\n                 verify_installed_asyncio_event_loop(event_loop)\n \n-            log_reactor_info()",
      "comment": "What if we only log it here, but remove 1 level of indentation?",
      "comment_id": 1944303226,
      "user": "Gallaecio",
      "created_at": "2025-02-06T08:29:54Z",
      "url": "https://github.com/scrapy/scrapy/pull/6657#discussion_r1944303226"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 6657,
      "file_path": "scrapy/crawler.py",
      "line": 129,
      "side": "LEFT",
      "diff_hunk": "@@ -113,20 +113,27 @@ def _apply_settings(self) -> None:\n \n         reactor_class: str = self.settings[\"TWISTED_REACTOR\"]\n         event_loop: str = self.settings[\"ASYNCIO_EVENT_LOOP\"]\n+        logged_reactor_info: bool = False\n+\n         if self._init_reactor:\n             # this needs to be done after the spider settings are merged,\n             # but before something imports twisted.internet.reactor\n             if reactor_class:\n                 install_reactor(reactor_class, event_loop)\n             else:\n                 from twisted.internet import reactor  # noqa: F401\n-            log_reactor_info()\n+\n+            if not logged_reactor_info:\n+                log_reactor_info()\n+                logged_reactor_info = True\n+\n         if reactor_class:\n             verify_installed_reactor(reactor_class)\n             if is_asyncio_reactor_installed() and event_loop:\n                 verify_installed_asyncio_event_loop(event_loop)\n \n-            log_reactor_info()",
      "comment": "There are cases where neither of these two blocks is executed I think.",
      "comment_id": 1944312602,
      "user": "wRAR",
      "created_at": "2025-02-06T08:36:45Z",
      "url": "https://github.com/scrapy/scrapy/pull/6657#discussion_r1944312602"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 6657,
      "file_path": "scrapy/crawler.py",
      "line": 129,
      "side": "LEFT",
      "diff_hunk": "@@ -113,20 +113,27 @@ def _apply_settings(self) -> None:\n \n         reactor_class: str = self.settings[\"TWISTED_REACTOR\"]\n         event_loop: str = self.settings[\"ASYNCIO_EVENT_LOOP\"]\n+        logged_reactor_info: bool = False\n+\n         if self._init_reactor:\n             # this needs to be done after the spider settings are merged,\n             # but before something imports twisted.internet.reactor\n             if reactor_class:\n                 install_reactor(reactor_class, event_loop)\n             else:\n                 from twisted.internet import reactor  # noqa: F401\n-            log_reactor_info()\n+\n+            if not logged_reactor_info:\n+                log_reactor_info()\n+                logged_reactor_info = True\n+\n         if reactor_class:\n             verify_installed_reactor(reactor_class)\n             if is_asyncio_reactor_installed() and event_loop:\n                 verify_installed_asyncio_event_loop(event_loop)\n \n-            log_reactor_info()",
      "comment": "TBH this logic needs some comments, I wasn't able to understand without spending some time what are the possible code paths here.",
      "comment_id": 1944313660,
      "user": "wRAR",
      "created_at": "2025-02-06T08:37:29Z",
      "url": "https://github.com/scrapy/scrapy/pull/6657#discussion_r1944313660"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 6657,
      "file_path": "scrapy/crawler.py",
      "line": 129,
      "side": "LEFT",
      "diff_hunk": "@@ -113,20 +113,27 @@ def _apply_settings(self) -> None:\n \n         reactor_class: str = self.settings[\"TWISTED_REACTOR\"]\n         event_loop: str = self.settings[\"ASYNCIO_EVENT_LOOP\"]\n+        logged_reactor_info: bool = False\n+\n         if self._init_reactor:\n             # this needs to be done after the spider settings are merged,\n             # but before something imports twisted.internet.reactor\n             if reactor_class:\n                 install_reactor(reactor_class, event_loop)\n             else:\n                 from twisted.internet import reactor  # noqa: F401\n-            log_reactor_info()\n+\n+            if not logged_reactor_info:\n+                log_reactor_info()\n+                logged_reactor_info = True\n+\n         if reactor_class:\n             verify_installed_reactor(reactor_class)\n             if is_asyncio_reactor_installed() and event_loop:\n                 verify_installed_asyncio_event_loop(event_loop)\n \n-            log_reactor_info()",
      "comment": "Since this only logs information about the reactor being used, I wonder if it makes sense to only log in when those conditions are meant. Although maybe it does, maybe logging it always could trigger multiple logging because this function is called multiple times, but only once with the conditions for the logging.\r\n\r\nTo be safe, we could check the conditions, both, at this point:\r\n\r\n```\r\nif a or b:\r\n    log()\r\n```",
      "comment_id": 1944319068,
      "user": "Gallaecio",
      "created_at": "2025-02-06T08:41:16Z",
      "url": "https://github.com/scrapy/scrapy/pull/6657#discussion_r1944319068"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 6657,
      "file_path": "scrapy/crawler.py",
      "line": 129,
      "side": "LEFT",
      "diff_hunk": "@@ -113,20 +113,27 @@ def _apply_settings(self) -> None:\n \n         reactor_class: str = self.settings[\"TWISTED_REACTOR\"]\n         event_loop: str = self.settings[\"ASYNCIO_EVENT_LOOP\"]\n+        logged_reactor_info: bool = False\n+\n         if self._init_reactor:\n             # this needs to be done after the spider settings are merged,\n             # but before something imports twisted.internet.reactor\n             if reactor_class:\n                 install_reactor(reactor_class, event_loop)\n             else:\n                 from twisted.internet import reactor  # noqa: F401\n-            log_reactor_info()\n+\n+            if not logged_reactor_info:\n+                log_reactor_info()\n+                logged_reactor_info = True\n+\n         if reactor_class:\n             verify_installed_reactor(reactor_class)\n             if is_asyncio_reactor_installed() and event_loop:\n                 verify_installed_asyncio_event_loop(event_loop)\n \n-            log_reactor_info()",
      "comment": "\ud83d\udcaf  @Gallaecio, I updated the code using your logic make more sense and is more clear, please take a look.",
      "comment_id": 1944482651,
      "user": "Laerte",
      "created_at": "2025-02-06T10:29:47Z",
      "url": "https://github.com/scrapy/scrapy/pull/6657#discussion_r1944482651"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 6650,
      "file_path": "tests/test_downloadermiddleware_httpcache.py",
      "line": 17,
      "side": "RIGHT",
      "diff_hunk": "@@ -14,7 +14,7 @@\n \n \n class _BaseTest(unittest.TestCase):\n-    storage_class = \"scrapy.extensions.httpcache.DbmCacheStorage\"\n+    storage_class = \"scrapy.extensions.httpcache.FilesystemCacheStorage\"",
      "comment": "I wonder if it'd be better to move these constants to DefaultStorageTest, and leave some non-working values here. Currently _BaseTest seems to be a mix of helper utilities, default values, and 1 test method. It may also require moving test_dont_cache somewhere else as well.\r\n\r\nI've noticed it because of removal of FilesystemStorageTest - it was not immediately clear where FilesystemCacheStorage is tested  - you go to the direct parent (DefaultStorageTest), and there is not storage_class set.\r\n\r\nI haven't really checked the code though :)",
      "comment_id": 1939017340,
      "user": "kmike",
      "created_at": "2025-02-03T09:03:31Z",
      "url": "https://github.com/scrapy/scrapy/pull/6650#discussion_r1939017340"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 6650,
      "file_path": "tests/test_downloadermiddleware_httpcache.py",
      "line": 17,
      "side": "RIGHT",
      "diff_hunk": "@@ -14,7 +14,7 @@\n \n \n class _BaseTest(unittest.TestCase):\n-    storage_class = \"scrapy.extensions.httpcache.DbmCacheStorage\"\n+    storage_class = \"scrapy.extensions.httpcache.FilesystemCacheStorage\"",
      "comment": "Yeah, I created #6649 after looking at this and trying to fix it, this is just a small simple fix for a part of the problem. E.g. simply moving these values from `_BaseTest` to `DefaultStorageTest` will break `DummyPolicyTest` that subclasses it directly. And `test_dont_cache` seems to be useful to run for all 4 combinations of options.",
      "comment_id": 1939739574,
      "user": "wRAR",
      "created_at": "2025-02-03T17:05:59Z",
      "url": "https://github.com/scrapy/scrapy/pull/6650#discussion_r1939739574"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 6608,
      "file_path": "scrapy/exceptions.py",
      "line": 62,
      "side": "RIGHT",
      "diff_hunk": "@@ -58,6 +58,14 @@ def __init__(self, *, fail: bool = True):\n class DropItem(Exception):\n     \"\"\"Drop item from the item pipeline\"\"\"\n \n+    def __init__(self, message, severity=None):\n+        from scrapy.utils.project import get_project_settings",
      "comment": "This approach is problematic, spider-specific settings (e.g. from `Spider.custom_settings`) would not be taken into account.\r\n\r\nI think we need to move the logic to read the setting to the code that captures the exception, and read the setting from `crawler` object of the Scrapy component handling the exception (`crawler.settings`).\r\n\r\nI think the right place would be [here](https://github.com/scrapy/scrapy/blob/1fc91bb46262118c9ff7aa2b4719d880f727699f/scrapy/core/scraper.py#L374-L377). If the exception severity is `None`, we read the setting from `self.crawler.setting` and update the setting severity accordingly.",
      "comment_id": 1908414285,
      "user": "Gallaecio",
      "created_at": "2025-01-09T09:21:08Z",
      "url": "https://github.com/scrapy/scrapy/pull/6608#discussion_r1908414285"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 6608,
      "file_path": "scrapy/exceptions.py",
      "line": 61,
      "side": "RIGHT",
      "diff_hunk": "@@ -58,6 +58,14 @@ def __init__(self, *, fail: bool = True):\n class DropItem(Exception):\n     \"\"\"Drop item from the item pipeline\"\"\"\n \n+    def __init__(self, message, severity=None):",
      "comment": "Should we call it `log_level`, in line with the setting?",
      "comment_id": 1908538782,
      "user": "Gallaecio",
      "created_at": "2025-01-09T10:48:44Z",
      "url": "https://github.com/scrapy/scrapy/pull/6608#discussion_r1908538782"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 6608,
      "file_path": "scrapy/core/scraper.py",
      "line": 380,
      "side": "RIGHT",
      "diff_hunk": "@@ -372,6 +372,12 @@ def _itemproc_finished(\n         if isinstance(output, Failure):\n             ex = output.value\n             if isinstance(ex, DropItem):\n+                if ex.log_level is None:\n+                    ex.log_level = spider.crawler.settings.get(\n+                        \"DEFAULT_DROPITEM_LOG_LEVEL\", \"WARNING\"\n+                    )\n+                else:\n+                    ex.log_level = ex.log_level.upper()",
      "comment": "Not sure that we need this, but if anything it should be `elif isinstance(ex.log_level, str):`, because I think we do want to support actual variables (`logging.INFO`) being used instead of strings.",
      "comment_id": 1909205908,
      "user": "Gallaecio",
      "created_at": "2025-01-09T17:31:38Z",
      "url": "https://github.com/scrapy/scrapy/pull/6608#discussion_r1909205908"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 6608,
      "file_path": "scrapy/core/scraper.py",
      "line": 380,
      "side": "RIGHT",
      "diff_hunk": "@@ -372,6 +372,12 @@ def _itemproc_finished(\n         if isinstance(output, Failure):\n             ex = output.value\n             if isinstance(ex, DropItem):\n+                if ex.log_level is None:\n+                    ex.log_level = spider.crawler.settings.get(\n+                        \"DEFAULT_DROPITEM_LOG_LEVEL\", \"WARNING\"\n+                    )\n+                else:\n+                    ex.log_level = ex.log_level.upper()",
      "comment": "Yes, that is correct. I think I should also write a list of valid logging levels in the code and check if the log level provided by the component is valid instead of just some random string.",
      "comment_id": 1909238895,
      "user": "protokoul",
      "created_at": "2025-01-09T18:01:34Z",
      "url": "https://github.com/scrapy/scrapy/pull/6608#discussion_r1909238895"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 6608,
      "file_path": "scrapy/core/scraper.py",
      "line": 380,
      "side": "RIGHT",
      "diff_hunk": "@@ -372,6 +372,12 @@ def _itemproc_finished(\n         if isinstance(output, Failure):\n             ex = output.value\n             if isinstance(ex, DropItem):\n+                if ex.log_level is None:\n+                    ex.log_level = spider.crawler.settings.get(\n+                        \"DEFAULT_DROPITEM_LOG_LEVEL\", \"WARNING\"\n+                    )\n+                else:\n+                    ex.log_level = ex.log_level.upper()",
      "comment": "> I think I should also write a list of valid logging levels in the code and check if the log level provided by the component is valid instead of just some random string.\r\n\r\nI would not bother. If the value is invalid, Python will raise some exception.\r\n\r\nWhat we need to make sure is that we do not make it invalid.\r\n\r\nTo be honest, I would not bother making it uppercase. If Python does not allow the user-submitted value, let it fail.",
      "comment_id": 1910003122,
      "user": "Gallaecio",
      "created_at": "2025-01-10T08:39:35Z",
      "url": "https://github.com/scrapy/scrapy/pull/6608#discussion_r1910003122"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 6608,
      "file_path": "scrapy/core/scraper.py",
      "line": 380,
      "side": "RIGHT",
      "diff_hunk": "@@ -372,6 +372,12 @@ def _itemproc_finished(\n         if isinstance(output, Failure):\n             ex = output.value\n             if isinstance(ex, DropItem):\n+                if ex.log_level is None:\n+                    ex.log_level = spider.crawler.settings.get(\n+                        \"DEFAULT_DROPITEM_LOG_LEVEL\", \"WARNING\"\n+                    )\n+                else:\n+                    ex.log_level = ex.log_level.upper()",
      "comment": "Understood. I can remove `valid_severities` if we rely on Python raising an exception. I still feel that I should make the `log_level` uppercase because I checked that `logging.warning` returns a function whereas `logging.WARNING` returns the numerical value of the logging level. Other functions defined in `scrapy/logformatter.py` also return the numerical value of the logging level.",
      "comment_id": 1910719952,
      "user": "protokoul",
      "created_at": "2025-01-10T17:51:47Z",
      "url": "https://github.com/scrapy/scrapy/pull/6608#discussion_r1910719952"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 6608,
      "file_path": "scrapy/core/scraper.py",
      "line": 380,
      "side": "RIGHT",
      "diff_hunk": "@@ -372,6 +372,12 @@ def _itemproc_finished(\n         if isinstance(output, Failure):\n             ex = output.value\n             if isinstance(ex, DropItem):\n+                if ex.log_level is None:\n+                    ex.log_level = spider.crawler.settings.get(\n+                        \"DEFAULT_DROPITEM_LOG_LEVEL\", \"WARNING\"\n+                    )\n+                else:\n+                    ex.log_level = ex.log_level.upper()",
      "comment": "If you remove the `severity = getattr(logging, log_level.upper())` line, and set `\"level\": log_level,` in the resulting dictionary, doesn\u2019t that work?",
      "comment_id": 1912881131,
      "user": "Gallaecio",
      "created_at": "2025-01-13T09:20:16Z",
      "url": "https://github.com/scrapy/scrapy/pull/6608#discussion_r1912881131"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 6608,
      "file_path": "scrapy/core/scraper.py",
      "line": 380,
      "side": "RIGHT",
      "diff_hunk": "@@ -372,6 +372,12 @@ def _itemproc_finished(\n         if isinstance(output, Failure):\n             ex = output.value\n             if isinstance(ex, DropItem):\n+                if ex.log_level is None:\n+                    ex.log_level = spider.crawler.settings.get(\n+                        \"DEFAULT_DROPITEM_LOG_LEVEL\", \"WARNING\"\n+                    )\n+                else:\n+                    ex.log_level = ex.log_level.upper()",
      "comment": "If I remove `severity = getattr(logging, log_level.upper())` and set `\"level\": log_level`, then one of my test cases called `test_log_formatter()` fails.\r\n\r\nAlso, I realized that `.upper()` in `severity = getattr(logging, log_level.upper())` is unnecessary so it can be removed and the test cases still pass.",
      "comment_id": 1913104668,
      "user": "protokoul",
      "created_at": "2025-01-13T12:21:17Z",
      "url": "https://github.com/scrapy/scrapy/pull/6608#discussion_r1913104668"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 6608,
      "file_path": "scrapy/core/scraper.py",
      "line": 380,
      "side": "RIGHT",
      "diff_hunk": "@@ -372,6 +372,12 @@ def _itemproc_finished(\n         if isinstance(output, Failure):\n             ex = output.value\n             if isinstance(ex, DropItem):\n+                if ex.log_level is None:\n+                    ex.log_level = spider.crawler.settings.get(\n+                        \"DEFAULT_DROPITEM_LOG_LEVEL\", \"WARNING\"\n+                    )\n+                else:\n+                    ex.log_level = ex.log_level.upper()",
      "comment": "If you mean `self.assertEqual(log[\"level\"], 40)`, maybe the expectation is the problem.",
      "comment_id": 1913192796,
      "user": "Gallaecio",
      "created_at": "2025-01-13T13:28:02Z",
      "url": "https://github.com/scrapy/scrapy/pull/6608#discussion_r1913192796"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 6608,
      "file_path": "scrapy/core/scraper.py",
      "line": 380,
      "side": "RIGHT",
      "diff_hunk": "@@ -372,6 +372,12 @@ def _itemproc_finished(\n         if isinstance(output, Failure):\n             ex = output.value\n             if isinstance(ex, DropItem):\n+                if ex.log_level is None:\n+                    ex.log_level = spider.crawler.settings.get(\n+                        \"DEFAULT_DROPITEM_LOG_LEVEL\", \"WARNING\"\n+                    )\n+                else:\n+                    ex.log_level = ex.log_level.upper()",
      "comment": "The value returned from other functions such as `crawled()`, `scraped()`, `item_error()` inside the `LogFormatter` class in `src/logformatter.py` have a fixed value assigned to `\"level\"`. Same used to be the case for `dropped()` but as it is going to be more flexible, I used the `getattr()` to fetch the correct value of logging. Isn't the expectation going to be a numerical value?",
      "comment_id": 1913206083,
      "user": "protokoul",
      "created_at": "2025-01-13T13:38:15Z",
      "url": "https://github.com/scrapy/scrapy/pull/6608#discussion_r1913206083"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 6608,
      "file_path": "scrapy/core/scraper.py",
      "line": 380,
      "side": "RIGHT",
      "diff_hunk": "@@ -372,6 +372,12 @@ def _itemproc_finished(\n         if isinstance(output, Failure):\n             ex = output.value\n             if isinstance(ex, DropItem):\n+                if ex.log_level is None:\n+                    ex.log_level = spider.crawler.settings.get(\n+                        \"DEFAULT_DROPITEM_LOG_LEVEL\", \"WARNING\"\n+                    )\n+                else:\n+                    ex.log_level = ex.log_level.upper()",
      "comment": "We can make it the expectation for it to be numerical, and it makes sense, it would ensure backward compatibility.\r\n\r\n~But then I think we need to enforce through type hints that the value of the exception must also be of that type (or None), and instead of doing conversion/resolving with `getattr`, require logging.X to be used instead of a string.~\r\n\r\nOh, but settings should always allow string values\u2026\r\n\r\nSo maybe allow `\"INFO\"`, but no `\"info\"`, so no `.upper()`?",
      "comment_id": 1913254129,
      "user": "Gallaecio",
      "created_at": "2025-01-13T14:11:57Z",
      "url": "https://github.com/scrapy/scrapy/pull/6608#discussion_r1913254129"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 6608,
      "file_path": "scrapy/core/scraper.py",
      "line": 380,
      "side": "RIGHT",
      "diff_hunk": "@@ -372,6 +372,12 @@ def _itemproc_finished(\n         if isinstance(output, Failure):\n             ex = output.value\n             if isinstance(ex, DropItem):\n+                if ex.log_level is None:\n+                    ex.log_level = spider.crawler.settings.get(\n+                        \"DEFAULT_DROPITEM_LOG_LEVEL\", \"WARNING\"\n+                    )\n+                else:\n+                    ex.log_level = ex.log_level.upper()",
      "comment": "I have tried both `logging.info` and `logging.INFO` in the python interpreter, Python will not raise an error in either case so even if I remove `.upper()`, I don't think an error will be raised while running Scrapy too and the logs written may not have some unexpected entries in it. Sure, if it was something like `logging.some_random_string`, then Python will definitely raise an error irrespective of whether `some_random_string` is upper case or lower case. If the `log_level` provided is valid but in lower case, should I raise an error informing to try only the valid uppercase log levels or continue with the approach to convert the log level provided by the DropItem exception to upper case and let Python handle it?",
      "comment_id": 1913306270,
      "user": "protokoul",
      "created_at": "2025-01-13T14:44:39Z",
      "url": "https://github.com/scrapy/scrapy/pull/6608#discussion_r1913306270"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 6608,
      "file_path": "scrapy/core/scraper.py",
      "line": 380,
      "side": "RIGHT",
      "diff_hunk": "@@ -372,6 +372,12 @@ def _itemproc_finished(\n         if isinstance(output, Failure):\n             ex = output.value\n             if isinstance(ex, DropItem):\n+                if ex.log_level is None:\n+                    ex.log_level = spider.crawler.settings.get(\n+                        \"DEFAULT_DROPITEM_LOG_LEVEL\", \"WARNING\"\n+                    )\n+                else:\n+                    ex.log_level = ex.log_level.upper()",
      "comment": "> I have tried both logging.info and logging.INFO in the python interpreter, Python will not raise an error in either case\r\n\r\n```python\r\n>>> logging.log(logging.INFO, \"foo\")\r\n>>> logging.log(logging.info, \"foo\")\r\nTraceback (most recent call last):\r\n  File \"<python-input-8>\", line 1, in <module>\r\n    logging.log(logging.info, \"foo\")\r\n    ~~~~~~~~~~~^^^^^^^^^^^^^^^^^^^^^\r\n  File \"/usr/lib/python3.13/logging/__init__.py\", line 2215, in log\r\n    root.log(level, msg, *args, **kwargs)\r\n    ~~~~~~~~^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\r\n  File \"/usr/lib/python3.13/logging/__init__.py\", line 1585, in log\r\n    raise TypeError(\"level must be an integer\")\r\nTypeError: level must be an integer\r\n```\r\n\r\n",
      "comment_id": 1913340478,
      "user": "Gallaecio",
      "created_at": "2025-01-13T15:05:57Z",
      "url": "https://github.com/scrapy/scrapy/pull/6608#discussion_r1913340478"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 6608,
      "file_path": "scrapy/core/scraper.py",
      "line": 380,
      "side": "RIGHT",
      "diff_hunk": "@@ -372,6 +372,12 @@ def _itemproc_finished(\n         if isinstance(output, Failure):\n             ex = output.value\n             if isinstance(ex, DropItem):\n+                if ex.log_level is None:\n+                    ex.log_level = spider.crawler.settings.get(\n+                        \"DEFAULT_DROPITEM_LOG_LEVEL\", \"WARNING\"\n+                    )\n+                else:\n+                    ex.log_level = ex.log_level.upper()",
      "comment": "Oh. My bad. I was directly running `logging.info` and `logging.INFO` in the interpreter to see what does it return and was not passing it to the `logger.log()`, I didn't think that eventually the level will be passed to `logger.log()`. I understand now that we can drop `.upper()` and Python will be able to handle it when it is passed to `logger.log()`. Let me implement the changes.",
      "comment_id": 1913347905,
      "user": "protokoul",
      "created_at": "2025-01-13T15:10:36Z",
      "url": "https://github.com/scrapy/scrapy/pull/6608#discussion_r1913347905"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 6608,
      "file_path": "scrapy/logformatter.py",
      "line": 128,
      "side": "RIGHT",
      "diff_hunk": "@@ -125,7 +125,7 @@ def dropped(\n         # that is used in DropItem exception, so a default value is provided\n         # inside the first getattr() below\n         log_level = getattr(exception, \"log_level\", \"WARNING\")\n-        severity = getattr(logging, log_level.upper())\n+        severity = getattr(logging, log_level)",
      "comment": "```suggestion\r\n        if isinstance(severity, str):\r\n            severity = getattr(logging, log_level)\r\n```\r\n\r\nIn case they pass `logging.INFO` or similar.",
      "comment_id": 1914555696,
      "user": "Gallaecio",
      "created_at": "2025-01-14T10:04:17Z",
      "url": "https://github.com/scrapy/scrapy/pull/6608#discussion_r1914555696"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 6608,
      "file_path": "scrapy/logformatter.py",
      "line": 123,
      "side": "RIGHT",
      "diff_hunk": "@@ -120,14 +120,12 @@ def dropped(\n         spider: Spider,\n     ) -> LogFormatterResult:\n         \"\"\"Logs a message when an item is dropped while it is passing through the item pipeline.\"\"\"\n-        # There is a test case called test_dropped under tests/test_logformatter.py\n-        # that raises base exception which will not have the attribute log_level\n-        # that is used in DropItem exception, so a default value is provided\n-        # inside the first getattr() below\n-        log_level = getattr(exception, \"log_level\", \"WARNING\")\n-        severity = getattr(logging, log_level)\n+        if (level := getattr(exception, \"log_level\", None)) is None:",
      "comment": "This is great. I understood that moving this logic from `scraper.py` to `logformatter.py` makes the testing easier as `dropped()` can be called directly instead of mocking a private function in the tests.",
      "comment_id": 1915193145,
      "user": "protokoul",
      "created_at": "2025-01-14T16:30:05Z",
      "url": "https://github.com/scrapy/scrapy/pull/6608#discussion_r1915193145"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 6628,
      "file_path": "scrapy/extensions/feedexport.py",
      "line": 296,
      "side": "RIGHT",
      "diff_hunk": "@@ -276,20 +276,41 @@ def _store_in_thread(self, file: IO[bytes]) -> None:\n \n \n class GCSFeedStorage(BlockingFeedStorage):\n-    def __init__(self, uri: str, project_id: str | None, acl: str | None):\n+    def __init__(\n+        self,\n+        uri: str,\n+        project_id: str | None,\n+        acl: str | None,\n+        *,\n+        feed_options: dict[str, Any] | None = None,\n+    ):\n         self.project_id: str | None = project_id\n         self.acl: str | None = acl\n         u = urlparse(uri)\n         assert u.hostname\n         self.bucket_name: str = u.hostname\n         self.blob_name: str = u.path[1:]  # remove first \"/\"\n \n+        if feed_options and feed_options.get(\"overwrite\", True) is False:\n+            logger.warning(\n+                \"S3 does not support appending to files. To \"",
      "comment": "This is not S3 :slightly_smiling_face: \r\n\r\n(sorry, just messing around, I know this is still a draft :sweat_smile:)",
      "comment_id": 1926810768,
      "user": "Gallaecio",
      "created_at": "2025-01-23T11:17:48Z",
      "url": "https://github.com/scrapy/scrapy/pull/6628#discussion_r1926810768"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 6624,
      "file_path": "docs/_ext/scrapydocs.py",
      "line": 50,
      "side": "RIGHT",
      "diff_hunk": "@@ -1,54 +1,62 @@\n # pylint: disable=import-error\n+# ruff: noqa: PGH003\n+from collections.abc import Sequence\n from operator import itemgetter\n+from typing import Any\n \n from docutils import nodes\n+from docutils.nodes import Element, General, Node, document\n from docutils.parsers.rst import Directive\n-from docutils.parsers.rst.roles import set_classes\n+from sphinx.application import Sphinx\n from sphinx.util.nodes import make_refnode\n \n \n-class settingslist_node(nodes.General, nodes.Element):\n+class settingslist_node(General, Element):\n     pass\n \n \n class SettingsListDirective(Directive):\n-    def run(self):\n+    def run(self) -> Sequence[Node]:\n         return [settingslist_node(\"\")]\n \n \n-def is_setting_index(node):\n-    if node.tagname == \"index\" and node[\"entries\"]:\n+def is_setting_index(node: Node) -> bool:\n+    if node.tagname == \"index\" and node[\"entries\"]:  # type: ignore\n         # index entries for setting directives look like:\n         # [('pair', 'SETTING_NAME; setting', 'std:setting-SETTING_NAME', '')]\n-        entry_type, info, refid = node[\"entries\"][0][:3]\n+        entry_type, info, refid = node[\"entries\"][0][:3]  # type: ignore\n         return entry_type == \"pair\" and info.endswith(\"; setting\")\n     return False\n \n \n-def get_setting_target(node):\n+def get_setting_target(node: Node) -> Node:\n     # target nodes are placed next to the node in the doc tree\n     return node.parent[node.parent.index(node) + 1]\n \n \n-def get_setting_name_and_refid(node):\n+def get_setting_name_and_refid(node: Node) -> tuple[Node, str]:\n     \"\"\"Extract setting name from directive index node\"\"\"\n-    entry_type, info, refid = node[\"entries\"][0][:3]\n+    entry_type, info, refid = node[\"entries\"][0][:3]  # type: ignore\n     return info.replace(\"; setting\", \"\"), refid\n \n \n-def collect_scrapy_settings_refs(app, doctree):\n+def collect_scrapy_settings_refs(app: Sphinx, doctree: document) -> None:\n     env = app.builder.env\n \n     if not hasattr(env, \"scrapy_all_settings\"):\n-        env.scrapy_all_settings = []\n+        env.scrapy_all_settings = []  # type: ignore\n \n-    for node in doctree.traverse(is_setting_index):\n-        targetnode = get_setting_target(node)\n-        assert isinstance(targetnode, nodes.target), \"Next node is not a target\"\n+    for node in doctree.findall(is_setting_index):\n+        # This seems not needed anymore.",
      "comment": "Interesting, the page is indeed generated correctly AFAICS.\r\n\r\n`def get_setting_target()` is also no longer needed then.",
      "comment_id": 1922285753,
      "user": "wRAR",
      "created_at": "2025-01-20T11:52:56Z",
      "url": "https://github.com/scrapy/scrapy/pull/6624#discussion_r1922285753"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 6624,
      "file_path": "docs/_ext/scrapydocs.py",
      "line": 50,
      "side": "RIGHT",
      "diff_hunk": "@@ -1,54 +1,62 @@\n # pylint: disable=import-error\n+# ruff: noqa: PGH003\n+from collections.abc import Sequence\n from operator import itemgetter\n+from typing import Any\n \n from docutils import nodes\n+from docutils.nodes import Element, General, Node, document\n from docutils.parsers.rst import Directive\n-from docutils.parsers.rst.roles import set_classes\n+from sphinx.application import Sphinx\n from sphinx.util.nodes import make_refnode\n \n \n-class settingslist_node(nodes.General, nodes.Element):\n+class settingslist_node(General, Element):\n     pass\n \n \n class SettingsListDirective(Directive):\n-    def run(self):\n+    def run(self) -> Sequence[Node]:\n         return [settingslist_node(\"\")]\n \n \n-def is_setting_index(node):\n-    if node.tagname == \"index\" and node[\"entries\"]:\n+def is_setting_index(node: Node) -> bool:\n+    if node.tagname == \"index\" and node[\"entries\"]:  # type: ignore\n         # index entries for setting directives look like:\n         # [('pair', 'SETTING_NAME; setting', 'std:setting-SETTING_NAME', '')]\n-        entry_type, info, refid = node[\"entries\"][0][:3]\n+        entry_type, info, refid = node[\"entries\"][0][:3]  # type: ignore\n         return entry_type == \"pair\" and info.endswith(\"; setting\")\n     return False\n \n \n-def get_setting_target(node):\n+def get_setting_target(node: Node) -> Node:\n     # target nodes are placed next to the node in the doc tree\n     return node.parent[node.parent.index(node) + 1]\n \n \n-def get_setting_name_and_refid(node):\n+def get_setting_name_and_refid(node: Node) -> tuple[Node, str]:\n     \"\"\"Extract setting name from directive index node\"\"\"\n-    entry_type, info, refid = node[\"entries\"][0][:3]\n+    entry_type, info, refid = node[\"entries\"][0][:3]  # type: ignore\n     return info.replace(\"; setting\", \"\"), refid\n \n \n-def collect_scrapy_settings_refs(app, doctree):\n+def collect_scrapy_settings_refs(app: Sphinx, doctree: document) -> None:\n     env = app.builder.env\n \n     if not hasattr(env, \"scrapy_all_settings\"):\n-        env.scrapy_all_settings = []\n+        env.scrapy_all_settings = []  # type: ignore\n \n-    for node in doctree.traverse(is_setting_index):\n-        targetnode = get_setting_target(node)\n-        assert isinstance(targetnode, nodes.target), \"Next node is not a target\"\n+    for node in doctree.findall(is_setting_index):\n+        # This seems not needed anymore.",
      "comment": "May we remove the commented out code before merging?",
      "comment_id": 1922394072,
      "user": "Gallaecio",
      "created_at": "2025-01-20T13:19:24Z",
      "url": "https://github.com/scrapy/scrapy/pull/6624#discussion_r1922394072"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 6568,
      "file_path": "scrapy/addons.py",
      "line": 25,
      "side": "RIGHT",
      "diff_hunk": "@@ -22,7 +22,7 @@ def __init__(self, crawler: Crawler) -> None:\n         self.crawler: Crawler = crawler\n         self.addons: list[Any] = []\n \n-    def load_settings(self, settings: Settings) -> None:\n+    def load_settings(self, settings: Settings | BaseSettings) -> None:",
      "comment": "What if we type it `BaseSettings` instead? (`Settings` is a subclass, and their API is identical, `Settings` only overrides `__init__`).",
      "comment_id": 1897890496,
      "user": "Gallaecio",
      "created_at": "2024-12-26T12:28:33Z",
      "url": "https://github.com/scrapy/scrapy/pull/6568#discussion_r1897890496"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 6568,
      "file_path": "scrapy/spiderloader.py",
      "line": 68,
      "side": "RIGHT",
      "diff_hunk": "@@ -59,6 +62,12 @@ def _load_spiders(self, module: ModuleType) -> None:\n             self._found[spcls.name].append((module.__name__, spcls.__name__))\n             self._spiders[spcls.name] = spcls\n \n+    def _get_spider_modules(self, settings: BaseSettings) -> list[str]:\n+        settings_copy = settings.copy()\n+        settings_copy.frozen = False\n+        AddonManager(Crawler(Spider)).load_settings(settings_copy)",
      "comment": "We need to update the docs of add-ons, to add a section or extend an existing section to clarify that add-ons are instantiated and its `update_settings` method executed more than once per crawl, to make sure users do not expect otherwise.",
      "comment_id": 1897893013,
      "user": "Gallaecio",
      "created_at": "2024-12-26T12:34:10Z",
      "url": "https://github.com/scrapy/scrapy/pull/6568#discussion_r1897893013"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 6568,
      "file_path": "tests/test_addons.py",
      "line": 177,
      "side": "RIGHT",
      "diff_hunk": "@@ -174,7 +174,7 @@ def update_settings(self, settings):\n                 addon = LoggedAddon()\n                 build_from_crawler_mock.return_value = addon\n                 crawler = get_crawler(settings_dict=settings_dict)\n-                logger_mock.info.assert_called_once_with(\n+                logger_mock.info.assert_called_with(",
      "comment": "This is an issue, this message should not be logged more than once. We need to prevent the logging of this when the `SPIDER_MODULES` setting is loaded.",
      "comment_id": 1897893827,
      "user": "Gallaecio",
      "created_at": "2024-12-26T12:36:00Z",
      "url": "https://github.com/scrapy/scrapy/pull/6568#discussion_r1897893827"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 6568,
      "file_path": "tests/test_crawler.py",
      "line": 953,
      "side": "RIGHT",
      "diff_hunk": "@@ -937,15 +945,24 @@ def test_change_default_reactor(self):\n def test_log_scrapy_info(settings, items, caplog):\n     with caplog.at_level(\"INFO\"):\n         CrawlerProcess(settings)\n+    scrapy_version_msg = next(\n+        record for record in caplog.records if record.getMessage().startswith(\"Scrapy \")\n+    ).getMessage()\n+    expected_scrapy_version_msg = (\n+        f\"Scrapy {scrapy.__version__} started (bot: scrapybot)\"\n+    )",
      "comment": "Same as above. We should prevent this PR to affect logs.",
      "comment_id": 1897895265,
      "user": "Gallaecio",
      "created_at": "2024-12-26T12:39:03Z",
      "url": "https://github.com/scrapy/scrapy/pull/6568#discussion_r1897895265"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 6568,
      "file_path": "scrapy/spiderloader.py",
      "line": 82,
      "side": "RIGHT",
      "diff_hunk": "@@ -76,6 +78,11 @@ def _load_all_spiders(self) -> None:\n                     raise\n         self._check_name_duplicates()\n \n+    def _load_spider_modules_from_addons(self, settings: BaseSettings) -> None:\n+        settings.frozen = False",
      "comment": "Should we move these to `AddonManager.load_spider_modules`?",
      "comment_id": 1914574355,
      "user": "Gallaecio",
      "created_at": "2025-01-14T10:18:22Z",
      "url": "https://github.com/scrapy/scrapy/pull/6568#discussion_r1914574355"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 6568,
      "file_path": "scrapy/addons.py",
      "line": 57,
      "side": "RIGHT",
      "diff_hunk": "@@ -52,3 +52,12 @@ def load_settings(self, settings: Settings) -> None:\n             },\n             extra={\"crawler\": self.crawler},\n         )\n+\n+    @classmethod\n+    def load_spider_modules(cls, settings):",
      "comment": "Since it may be useful for other settings, I wonder if we could make it more generic, less specific to `SPIDER_MODULES`. e.g. name it `load_early_settings` or similar (`global`? `pre_crawler`?), and call it right after https://github.com/scrapy/scrapy/blob/402500b164efc01257679247d3dd1628a5f90f5e/scrapy/crawler.py#L295\r\n",
      "comment_id": 1914580093,
      "user": "Gallaecio",
      "created_at": "2025-01-14T10:22:51Z",
      "url": "https://github.com/scrapy/scrapy/pull/6568#discussion_r1914580093"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 6568,
      "file_path": "scrapy/addons.py",
      "line": 63,
      "side": "RIGHT",
      "diff_hunk": "@@ -52,3 +52,12 @@ def load_settings(self, settings: Settings) -> None:\n             },\n             extra={\"crawler\": self.crawler},\n         )\n+\n+    @classmethod\n+    def load_early_settings(cls, settings: BaseSettings):\n+        for clspath in build_component_list(settings[\"ADDONS\"]):\n+            try:\n+                addoncls = load_object(clspath)\n+                addoncls.update_spider_modules(settings)\n+            except AttributeError:\n+                pass",
      "comment": "~Why this exception?~\r\n\r\n~I\u2019m thinking we should not capture any exception here, in line with the regular method, which only captures `NotConfigured` (which we should probably not capture here, it would be weird for users to have to raise that exception from 2 places instead of simply doing nothing in the class method).~\r\n\r\nOh, right, in case add-ons do not define the class method.\r\n\r\nWhat about using `hasattr` instead, to avoid potentially hiding other `AttributeError` exceptions that may happen inside the user-defined class method?",
      "comment_id": 1916224333,
      "user": "Gallaecio",
      "created_at": "2025-01-15T09:26:47Z",
      "url": "https://github.com/scrapy/scrapy/pull/6568#discussion_r1916224333"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 6568,
      "file_path": "scrapy/addons.py",
      "line": 66,
      "side": "RIGHT",
      "diff_hunk": "@@ -52,3 +53,19 @@ def load_settings(self, settings: Settings) -> None:\n             },\n             extra={\"crawler\": self.crawler},\n         )\n+\n+    @classmethod\n+    def load_early_settings(cls, settings: BaseSettings):\n+        \"\"\"Update early settings that do not require a crawler instance, such as SPIDER_MODULES.\n+\n+        Similar to the load_settings method, this loads each add-on configured in the\n+        ``ADDONS`` setting and calls their 'update_early_settings' class method if present.\n+        This method doesn't have access to the crawler instance or the addons list.\n+\n+        :param settings: The :class:`~scrapy.settings.BaseSettings` object from \\\n+            which to read the early add-on configuration",
      "comment": "```suggestion\r\n            which to read the early add-on configuration\r\n        :type settings: :class:`~scrapy.settings.Settings`\r\n```",
      "comment_id": 1920492890,
      "user": "wRAR",
      "created_at": "2025-01-17T17:06:50Z",
      "url": "https://github.com/scrapy/scrapy/pull/6568#discussion_r1920492890"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 6623,
      "file_path": "docs/conf.py",
      "line": 21,
      "side": "RIGHT",
      "diff_hunk": "@@ -20,36 +14,30 @@\n sys.path.insert(0, str(Path(__file__).parent.parent))\n \n \n-# General configuration\n-# ---------------------\n+# -- Project information -----------------------------------------------------\n+# https://www.sphinx-doc.org/en/master/usage/configuration.html#project-information\n+\n+project = \"Scrapy\"\n+project_copyright = \"%Y, Scrapy developers\"",
      "comment": "We decided we don't want a year in the copyright line.",
      "comment_id": 1921627299,
      "user": "wRAR",
      "created_at": "2025-01-19T20:27:16Z",
      "url": "https://github.com/scrapy/scrapy/pull/6623#discussion_r1921627299"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 3426,
      "file_path": "scrapy/cmdline.py",
      "line": 138,
      "side": "RIGHT",
      "diff_hunk": "@@ -121,11 +127,25 @@ def _print_commands(settings: BaseSettings, inproject: bool) -> None:\n     print('Use \"scrapy <command> -h\" to see more info about a command')\n \n \n+def _print_unknown_command_msg(\n+    settings: BaseSettings, cmdname: str, inproject: bool\n+) -> None:\n+    proj_only_cmds = _get_project_only_cmds(settings)\n+    if cmdname in proj_only_cmds and not inproject:\n+        cmd_list = \", \".join(sorted(proj_only_cmds))\n+        print(\n+            f\"{cmdname} command is not available from this location.\\n\"\n+            f\"These commands can only be triggered from within a project: {cmd_list}\\n\"",
      "comment": "```suggestion\r\n            f\"The {cmdname} command is not available from this location.\\n\"\r\n            f\"These commands are only available within a project: {cmd_list}\\n\"\r\n```",
      "comment_id": 1907448567,
      "user": "Gallaecio",
      "created_at": "2025-01-08T16:19:09Z",
      "url": "https://github.com/scrapy/scrapy/pull/3426#discussion_r1907448567"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 6151,
      "file_path": "scrapy/spidermiddlewares/offsite.py",
      "line": 61,
      "side": "RIGHT",
      "diff_hunk": "@@ -50,7 +51,15 @@ async def process_spider_output_async(\n     def _filter(self, request: Any, spider: Spider) -> bool:\n         if not isinstance(request, Request):\n             return True\n-        if request.dont_filter or self.should_follow(request, spider):\n+        if request.dont_filter:\n+            warnings.warn(\n+                \"The dont_filter filter flag is deprecated in OffsiteMiddleware. \"\n+                \"Set 'allow_offsite' to True in Request.meta instead.\",\n+                ScrapyDeprecationWarning,\n+                stacklevel=2,\n+            )\n+            return True",
      "comment": "Hm, I wonder if it'd be better to just keep supporting dont_filter, without a deprecation warning.\r\n\r\nFirst, the flag says \"dont_filter\", and we respect it, and don't filter out the request. An argument can be made though that \"don't filter\" only applies to deduplication filter, not to other types of filtering. I think that's valid, But that's not the current flag behavior, and also it's not in the flag name (it's not \"dont_deduplicate\").\r\n\r\nSecond, the user doesn't control all the don't_filter flags, Scrapy and other components can be setting this flag. For example, the default start_requests implementation uses dont_filter=True. \r\n\r\nIt seems it's not possibile to \"deprecate don_filter flag in OffsiteMiddleware\", because the user might be setting this flag not for the OffsiteMiddleware, but for other Scrapy components, but the request may still end up in OffsiteMiddleware.",
      "comment_id": 1422410500,
      "user": "kmike",
      "created_at": "2023-12-11T12:41:38Z",
      "url": "https://github.com/scrapy/scrapy/pull/6151#discussion_r1422410500"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 6151,
      "file_path": "scrapy/spidermiddlewares/offsite.py",
      "line": 61,
      "side": "RIGHT",
      "diff_hunk": "@@ -50,7 +51,15 @@ async def process_spider_output_async(\n     def _filter(self, request: Any, spider: Spider) -> bool:\n         if not isinstance(request, Request):\n             return True\n-        if request.dont_filter or self.should_follow(request, spider):\n+        if request.dont_filter:\n+            warnings.warn(\n+                \"The dont_filter filter flag is deprecated in OffsiteMiddleware. \"\n+                \"Set 'allow_offsite' to True in Request.meta instead.\",\n+                ScrapyDeprecationWarning,\n+                stacklevel=2,\n+            )\n+            return True",
      "comment": "Makes sense. In that case, we need to clarify that the `dont_filter` value also affects some middlewares as well and not just for the Scheduler.",
      "comment_id": 1423941916,
      "user": "BurnzZ",
      "created_at": "2023-12-12T12:46:22Z",
      "url": "https://github.com/scrapy/scrapy/pull/6151#discussion_r1423941916"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 6601,
      "file_path": "tests/test_spidermiddleware_referer.py",
      "line": 894,
      "side": "RIGHT",
      "diff_hunk": "@@ -891,14 +891,7 @@ def test_multiple_policy_tokens(self):\n         # test parsing without space(s) after the comma\n         settings1 = Settings(\n             {\n-                \"REFERRER_POLICY\": \",\".join(\n-                    [\n-                        \"some-custom-unknown-policy\",\n-                        POLICY_SAME_ORIGIN,\n-                        POLICY_STRICT_ORIGIN_WHEN_CROSS_ORIGIN,\n-                        \"another-custom-unknown-policy\",\n-                    ]\n-                )\n+                \"REFERRER_POLICY\": f\"some-custom-unknown-policy,{POLICY_SAME_ORIGIN},{POLICY_STRICT_ORIGIN_WHEN_CROSS_ORIGIN},another-custom-unknown-policy\"",
      "comment": "Maybe:\r\n\r\n```suggestion\r\n                \"REFERRER_POLICY\": (\r\n                    f\"some-custom-unknown-policy,\"\r\n                    f\"{POLICY_SAME_ORIGIN},\"\r\n                    f\"{POLICY_STRICT_ORIGIN_WHEN_CROSS_ORIGIN},\"\r\n                    f\"another-custom-unknown-policy\"\r\n                )\r\n```",
      "comment_id": 1900814505,
      "user": "Gallaecio",
      "created_at": "2025-01-02T12:06:06Z",
      "url": "https://github.com/scrapy/scrapy/pull/6601#discussion_r1900814505"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 6584,
      "file_path": "scrapy/__init__.py",
      "line": 34,
      "side": "RIGHT",
      "diff_hunk": "@@ -31,7 +31,7 @@\n \n def __getattr__(name: str):\n     if name == \"twisted_version\":\n-        import warnings\n+        import warnings  # pylint: disable=reimported",
      "comment": "I assume it's some magic around `__getattr__` that doesn't execute the top level imports but I didn't check.",
      "comment_id": 1884990831,
      "user": "wRAR",
      "created_at": "2024-12-14T09:16:00Z",
      "url": "https://github.com/scrapy/scrapy/pull/6584#discussion_r1884990831"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 6582,
      "file_path": "scrapy/utils/versions.py",
      "line": 28,
      "side": "RIGHT",
      "diff_hunk": "@@ -1,31 +1,32 @@\n+from __future__ import annotations\n+\n import platform\n import sys\n+from importlib.metadata import version\n \n-import cryptography\n-import cssselect\n import lxml.etree\n-import parsel\n-import twisted\n-import w3lib\n \n-import scrapy\n+from scrapy.settings.default_settings import LOG_VERSIONS\n from scrapy.utils.ssl import get_openssl_version\n \n+_DEFAULT_COMPONENTS = [\"Scrapy\"] + LOG_VERSIONS\n+\n+\n+def _version(component):\n+    lowercase_component = component.lower()\n+    if lowercase_component == \"libxml2\":\n+        return \".\".join(map(str, lxml.etree.LIBXML_VERSION))\n+    if lowercase_component == \"platform\":\n+        return platform.platform()\n+    if lowercase_component == \"pyopenssl\":\n+        return get_openssl_version()\n+    if lowercase_component == \"python\":\n+        return sys.version.replace(\"\\n\", \"- \")\n+    return version(component)\n+\n \n-def scrapy_components_versions() -> list[tuple[str, str]]:\n-    lxml_version = \".\".join(map(str, lxml.etree.LXML_VERSION))\n-    libxml2_version = \".\".join(map(str, lxml.etree.LIBXML_VERSION))\n-\n-    return [\n-        (\"Scrapy\", scrapy.__version__),\n-        (\"lxml\", lxml_version),\n-        (\"libxml2\", libxml2_version),\n-        (\"cssselect\", cssselect.__version__),\n-        (\"parsel\", parsel.__version__),\n-        (\"w3lib\", w3lib.__version__),\n-        (\"Twisted\", twisted.version.short()),\n-        (\"Python\", sys.version.replace(\"\\n\", \"- \")),\n-        (\"pyOpenSSL\", get_openssl_version()),\n-        (\"cryptography\", cryptography.__version__),\n-        (\"Platform\", platform.platform()),\n-    ]\n+def scrapy_components_versions(",
      "comment": "They don't need to be Scrapy components anymore; would it make sense to change the name of the function?",
      "comment_id": 1884276734,
      "user": "kmike",
      "created_at": "2024-12-13T17:40:01Z",
      "url": "https://github.com/scrapy/scrapy/pull/6582#discussion_r1884276734"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 6582,
      "file_path": "scrapy/utils/versions.py",
      "line": 38,
      "side": "RIGHT",
      "diff_hunk": "@@ -1,31 +1,48 @@\n+from __future__ import annotations\n+\n import platform\n import sys\n+from importlib.metadata import version\n+from warnings import warn\n \n-import cryptography\n-import cssselect\n import lxml.etree\n-import parsel\n-import twisted\n-import w3lib\n \n-import scrapy\n+from scrapy.exceptions import ScrapyDeprecationWarning\n+from scrapy.settings.default_settings import LOG_VERSIONS\n from scrapy.utils.ssl import get_openssl_version\n \n+_DEFAULT_SOFTWARE = [\"Scrapy\"] + LOG_VERSIONS\n+\n+\n+def _version(component):\n+    lowercase_component = component.lower()\n+    if lowercase_component == \"libxml2\":\n+        return \".\".join(map(str, lxml.etree.LIBXML_VERSION))\n+    if lowercase_component == \"platform\":\n+        return platform.platform()\n+    if lowercase_component == \"pyopenssl\":\n+        return get_openssl_version()\n+    if lowercase_component == \"python\":\n+        return sys.version.replace(\"\\n\", \"- \")\n+    return version(component)\n+\n+\n+def get_versions(\n+    software: list | None = None,\n+) -> list[tuple[str, str]]:\n+    software = software or _DEFAULT_SOFTWARE\n+    return [(item, _version(item)) for item in software]\n+\n \n-def scrapy_components_versions() -> list[tuple[str, str]]:\n-    lxml_version = \".\".join(map(str, lxml.etree.LXML_VERSION))\n-    libxml2_version = \".\".join(map(str, lxml.etree.LIBXML_VERSION))\n-\n-    return [\n-        (\"Scrapy\", scrapy.__version__),\n-        (\"lxml\", lxml_version),\n-        (\"libxml2\", libxml2_version),\n-        (\"cssselect\", cssselect.__version__),\n-        (\"parsel\", parsel.__version__),\n-        (\"w3lib\", w3lib.__version__),\n-        (\"Twisted\", twisted.version.short()),\n-        (\"Python\", sys.version.replace(\"\\n\", \"- \")),\n-        (\"pyOpenSSL\", get_openssl_version()),\n-        (\"cryptography\", cryptography.__version__),\n-        (\"Platform\", platform.platform()),\n-    ]\n+def scrapy_components_versions(\n+    components: list | None = None,",
      "comment": "What do you think about not adding this argument to scrapy_components_version? In this case, implementation will be different: it'd call `get_versions(_DEFAULT_SOFTWARE)`. We still should deprecate it probably.",
      "comment_id": 1886614702,
      "user": "kmike",
      "created_at": "2024-12-16T11:02:34Z",
      "url": "https://github.com/scrapy/scrapy/pull/6582#discussion_r1886614702"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 6582,
      "file_path": "scrapy/utils/log.py",
      "line": 178,
      "side": "RIGHT",
      "diff_hunk": "@@ -174,12 +175,11 @@ def log_scrapy_info(settings: Settings) -> None:\n         \"Scrapy %(version)s started (bot: %(bot)s)\",\n         {\"version\": scrapy.__version__, \"bot\": settings[\"BOT_NAME\"]},\n     )\n-    versions = [\n-        f\"{name} {version}\"\n-        for name, version in scrapy_components_versions()\n-        if name != \"Scrapy\"\n-    ]\n-    logger.info(\"Versions: %(versions)s\", {\"versions\": \", \".join(versions)})\n+    software = settings.getlist(\"LOG_VERSIONS\")",
      "comment": "\u201dsoftware\u201d is plural, singular would be \u201cpiece of software\u201d, \u201csoftware component\u201d, or similar. I went with \u201citem\u201d in a few places to keep things short.",
      "comment_id": 1886653772,
      "user": "Gallaecio",
      "created_at": "2024-12-16T11:26:07Z",
      "url": "https://github.com/scrapy/scrapy/pull/6582#discussion_r1886653772"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 6582,
      "file_path": "scrapy/utils/versions.py",
      "line": 41,
      "side": "RIGHT",
      "diff_hunk": "@@ -1,31 +1,46 @@\n+from __future__ import annotations\n+\n import platform\n import sys\n+from importlib.metadata import version\n+from warnings import warn\n \n-import cryptography\n-import cssselect\n import lxml.etree\n-import parsel\n-import twisted\n-import w3lib\n \n-import scrapy\n+from scrapy.exceptions import ScrapyDeprecationWarning\n+from scrapy.settings.default_settings import LOG_VERSIONS\n from scrapy.utils.ssl import get_openssl_version\n \n+_DEFAULT_SOFTWARE = [\"Scrapy\"] + LOG_VERSIONS\n+\n+\n+def _version(item):\n+    lowercase_item = item.lower()\n+    if lowercase_item == \"libxml2\":\n+        return \".\".join(map(str, lxml.etree.LIBXML_VERSION))\n+    if lowercase_item == \"platform\":\n+        return platform.platform()\n+    if lowercase_item == \"pyopenssl\":\n+        return get_openssl_version()\n+    if lowercase_item == \"python\":\n+        return sys.version.replace(\"\\n\", \"- \")\n+    return version(item)\n+\n+\n+def get_versions(\n+    software: list | None = None,\n+) -> list[tuple[str, str]]:\n+    software = software or _DEFAULT_SOFTWARE\n+    return [(item, _version(item)) for item in software]\n+\n \n def scrapy_components_versions() -> list[tuple[str, str]]:\n-    lxml_version = \".\".join(map(str, lxml.etree.LXML_VERSION))\n-    libxml2_version = \".\".join(map(str, lxml.etree.LIBXML_VERSION))\n-\n-    return [\n-        (\"Scrapy\", scrapy.__version__),\n-        (\"lxml\", lxml_version),\n-        (\"libxml2\", libxml2_version),\n-        (\"cssselect\", cssselect.__version__),\n-        (\"parsel\", parsel.__version__),\n-        (\"w3lib\", w3lib.__version__),\n-        (\"Twisted\", twisted.version.short()),\n-        (\"Python\", sys.version.replace(\"\\n\", \"- \")),\n-        (\"pyOpenSSL\", get_openssl_version()),\n-        (\"cryptography\", cryptography.__version__),\n-        (\"Platform\", platform.platform()),\n-    ]\n+    warn(\n+        (\n+            \"scrapy.utils.versions.scrapy_components_versions is deprecated, \"\n+            \"use scrapy.utils.versions.get_versions instead.\"",
      "comment": "```suggestion\r\n            \"scrapy.utils.versions.scrapy_components_versions() is deprecated, \"\r\n            \"use scrapy.utils.versions.get_versions() instead.\"\r\n```",
      "comment_id": 1886674988,
      "user": "wRAR",
      "created_at": "2024-12-16T11:43:16Z",
      "url": "https://github.com/scrapy/scrapy/pull/6582#discussion_r1886674988"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 6582,
      "file_path": "scrapy/utils/versions.py",
      "line": 46,
      "side": "RIGHT",
      "diff_hunk": "@@ -1,31 +1,46 @@\n+from __future__ import annotations\n+\n import platform\n import sys\n+from importlib.metadata import version\n+from warnings import warn\n \n-import cryptography\n-import cssselect\n import lxml.etree\n-import parsel\n-import twisted\n-import w3lib\n \n-import scrapy\n+from scrapy.exceptions import ScrapyDeprecationWarning\n+from scrapy.settings.default_settings import LOG_VERSIONS\n from scrapy.utils.ssl import get_openssl_version\n \n+_DEFAULT_SOFTWARE = [\"Scrapy\"] + LOG_VERSIONS\n+\n+\n+def _version(item):\n+    lowercase_item = item.lower()\n+    if lowercase_item == \"libxml2\":\n+        return \".\".join(map(str, lxml.etree.LIBXML_VERSION))\n+    if lowercase_item == \"platform\":\n+        return platform.platform()\n+    if lowercase_item == \"pyopenssl\":\n+        return get_openssl_version()\n+    if lowercase_item == \"python\":\n+        return sys.version.replace(\"\\n\", \"- \")\n+    return version(item)\n+\n+\n+def get_versions(\n+    software: list | None = None,\n+) -> list[tuple[str, str]]:\n+    software = software or _DEFAULT_SOFTWARE\n+    return [(item, _version(item)) for item in software]\n+\n \n def scrapy_components_versions() -> list[tuple[str, str]]:\n-    lxml_version = \".\".join(map(str, lxml.etree.LXML_VERSION))\n-    libxml2_version = \".\".join(map(str, lxml.etree.LIBXML_VERSION))\n-\n-    return [\n-        (\"Scrapy\", scrapy.__version__),\n-        (\"lxml\", lxml_version),\n-        (\"libxml2\", libxml2_version),\n-        (\"cssselect\", cssselect.__version__),\n-        (\"parsel\", parsel.__version__),\n-        (\"w3lib\", w3lib.__version__),\n-        (\"Twisted\", twisted.version.short()),\n-        (\"Python\", sys.version.replace(\"\\n\", \"- \")),\n-        (\"pyOpenSSL\", get_openssl_version()),\n-        (\"cryptography\", cryptography.__version__),\n-        (\"Platform\", platform.platform()),\n-    ]\n+    warn(\n+        (\n+            \"scrapy.utils.versions.scrapy_components_versions is deprecated, \"\n+            \"use scrapy.utils.versions.get_versions instead.\"\n+        ),\n+        ScrapyDeprecationWarning,\n+        stacklevel=2,\n+    )\n+    return get_versions(_DEFAULT_SOFTWARE)",
      "comment": "Should this call just `get_versions()`, or should the `get_versions()` arg become mandatory? What's your plan for after `scrapy_components_versions()` is removed?",
      "comment_id": 1886677609,
      "user": "wRAR",
      "created_at": "2024-12-16T11:45:27Z",
      "url": "https://github.com/scrapy/scrapy/pull/6582#discussion_r1886677609"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 6582,
      "file_path": "scrapy/utils/versions.py",
      "line": 46,
      "side": "RIGHT",
      "diff_hunk": "@@ -1,31 +1,46 @@\n+from __future__ import annotations\n+\n import platform\n import sys\n+from importlib.metadata import version\n+from warnings import warn\n \n-import cryptography\n-import cssselect\n import lxml.etree\n-import parsel\n-import twisted\n-import w3lib\n \n-import scrapy\n+from scrapy.exceptions import ScrapyDeprecationWarning\n+from scrapy.settings.default_settings import LOG_VERSIONS\n from scrapy.utils.ssl import get_openssl_version\n \n+_DEFAULT_SOFTWARE = [\"Scrapy\"] + LOG_VERSIONS\n+\n+\n+def _version(item):\n+    lowercase_item = item.lower()\n+    if lowercase_item == \"libxml2\":\n+        return \".\".join(map(str, lxml.etree.LIBXML_VERSION))\n+    if lowercase_item == \"platform\":\n+        return platform.platform()\n+    if lowercase_item == \"pyopenssl\":\n+        return get_openssl_version()\n+    if lowercase_item == \"python\":\n+        return sys.version.replace(\"\\n\", \"- \")\n+    return version(item)\n+\n+\n+def get_versions(\n+    software: list | None = None,\n+) -> list[tuple[str, str]]:\n+    software = software or _DEFAULT_SOFTWARE\n+    return [(item, _version(item)) for item in software]\n+\n \n def scrapy_components_versions() -> list[tuple[str, str]]:\n-    lxml_version = \".\".join(map(str, lxml.etree.LXML_VERSION))\n-    libxml2_version = \".\".join(map(str, lxml.etree.LIBXML_VERSION))\n-\n-    return [\n-        (\"Scrapy\", scrapy.__version__),\n-        (\"lxml\", lxml_version),\n-        (\"libxml2\", libxml2_version),\n-        (\"cssselect\", cssselect.__version__),\n-        (\"parsel\", parsel.__version__),\n-        (\"w3lib\", w3lib.__version__),\n-        (\"Twisted\", twisted.version.short()),\n-        (\"Python\", sys.version.replace(\"\\n\", \"- \")),\n-        (\"pyOpenSSL\", get_openssl_version()),\n-        (\"cryptography\", cryptography.__version__),\n-        (\"Platform\", platform.platform()),\n-    ]\n+    warn(\n+        (\n+            \"scrapy.utils.versions.scrapy_components_versions is deprecated, \"\n+            \"use scrapy.utils.versions.get_versions instead.\"\n+        ),\n+        ScrapyDeprecationWarning,\n+        stacklevel=2,\n+    )\n+    return get_versions(_DEFAULT_SOFTWARE)",
      "comment": "I thought about making it mandatory, but since the implementation of the `scrapy version` command uses `get_versions()`, it\u2019s probably cleaner to keep it optional. It does make sense to remove the parameter from here, though.",
      "comment_id": 1886688588,
      "user": "Gallaecio",
      "created_at": "2024-12-16T11:53:41Z",
      "url": "https://github.com/scrapy/scrapy/pull/6582#discussion_r1886688588"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 6581,
      "file_path": "tests/test_spidermiddleware.py",
      "line": 292,
      "side": "RIGHT",
      "diff_hunk": "@@ -290,10 +289,7 @@ def process_spider_output(self, response, result, spider):\n \n class ProcessSpiderOutputCoroutineMiddleware:\n     async def process_spider_output(self, response, result, spider):\n-        results = []\n-        for r in result:\n-            results.append(r)\n-        return results\n+        return result",
      "comment": "Interesting. It is technically not the same, since result is not a list but an iterator. On the other hand, in this specific case it is most likely OK.",
      "comment_id": 1883603913,
      "user": "Gallaecio",
      "created_at": "2024-12-13T09:11:18Z",
      "url": "https://github.com/scrapy/scrapy/pull/6581#discussion_r1883603913"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 6581,
      "file_path": "scrapy/link.py",
      "line": 40,
      "side": "RIGHT",
      "diff_hunk": "@@ -39,7 +37,7 @@ def __init__(\n         self.fragment: str = fragment\n         self.nofollow: bool = nofollow\n \n-    def __eq__(self, other: Any) -> bool:\n+    def __eq__(self, other: object) -> bool:",
      "comment": "Yeah. https://docs.astral.sh/ruff/rules/any-eq-ne-annotation/ says \"The Python documentation recommends the use of object to \"indicate that a value could be any type in a typesafe manner\". Any, on the other hand, should be seen as an \"escape hatch when you need to mix dynamically and statically typed code\".\" which makes sense and may be useful in other places too.",
      "comment_id": 1883603998,
      "user": "wRAR",
      "created_at": "2024-12-13T09:11:22Z",
      "url": "https://github.com/scrapy/scrapy/pull/6581#discussion_r1883603998"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 6581,
      "file_path": "tests/test_spidermiddleware.py",
      "line": 292,
      "side": "RIGHT",
      "diff_hunk": "@@ -290,10 +289,7 @@ def process_spider_output(self, response, result, spider):\n \n class ProcessSpiderOutputCoroutineMiddleware:\n     async def process_spider_output(self, response, result, spider):\n-        results = []\n-        for r in result:\n-            results.append(r)\n-        return results\n+        return result",
      "comment": "I rewrote this myself, the linter suggests a copy via `list(result)`.",
      "comment_id": 1883605920,
      "user": "wRAR",
      "created_at": "2024-12-13T09:12:52Z",
      "url": "https://github.com/scrapy/scrapy/pull/6581#discussion_r1883605920"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 6581,
      "file_path": "tests/test_spidermiddleware.py",
      "line": 292,
      "side": "RIGHT",
      "diff_hunk": "@@ -290,10 +289,7 @@ def process_spider_output(self, response, result, spider):\n \n class ProcessSpiderOutputCoroutineMiddleware:\n     async def process_spider_output(self, response, result, spider):\n-        results = []\n-        for r in result:\n-            results.append(r)\n-        return results\n+        return result",
      "comment": "(Well, not a copy, as it's not necessarily a list)",
      "comment_id": 1883607300,
      "user": "wRAR",
      "created_at": "2024-12-13T09:13:59Z",
      "url": "https://github.com/scrapy/scrapy/pull/6581#discussion_r1883607300"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 6540,
      "file_path": "scrapy/middleware.py",
      "line": 58,
      "side": "RIGHT",
      "diff_hunk": "@@ -50,8 +51,41 @@ def __init__(self, *middlewares: Any) -> None:\n     def _get_mwlist_from_settings(cls, settings: Settings) -> list[Any]:\n         raise NotImplementedError\n \n+    @staticmethod\n+    def _build_from_settings(objcls: type[_T], settings: BaseSettings) -> _T:\n+        if hasattr(objcls, \"from_settings\"):\n+            warnings.warn(\n+                f\"{objcls.__qualname__} has from_settings() but not from_crawler().\"",
      "comment": "I suspect I am missing something, but from a quick look, it seems to me that `_build_from_settings` is called when `MiddlewareManager.from_settings` is used without a crawler, and I see nothing ensuring that `objcls` does not have `from_crawler` defined.",
      "comment_id": 1841809115,
      "user": "Gallaecio",
      "created_at": "2024-11-14T08:57:44Z",
      "url": "https://github.com/scrapy/scrapy/pull/6540#discussion_r1841809115"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 6540,
      "file_path": "scrapy/pipelines/media.py",
      "line": 157,
      "side": "RIGHT",
      "diff_hunk": "@@ -112,13 +147,19 @@ def _key_for_pipe(\n     @classmethod\n     def from_crawler(cls, crawler: Crawler) -> Self:\n         pipe: Self\n-        try:\n+        if hasattr(cls, \"from_settings\"):\n             pipe = cls.from_settings(crawler.settings)  # type: ignore[attr-defined]\n-        except AttributeError:\n+        elif \"crawler\" in get_func_args(cls.__init__):\n+            pipe = cls(crawler=crawler)\n+        else:\n             pipe = cls()\n-        pipe.crawler = crawler\n-        assert crawler.request_fingerprinter\n-        pipe._fingerprinter = crawler.request_fingerprinter\n+            warnings.warn(\n+                f\"{cls.__qualname__}.__init__() doesn't take a crawler argument.\"",
      "comment": "In cases like these where the stacklevel would not help to point to the offending like, I wonder if we should prefix `cls.__qualname__` with the module name, i.e. use [`globa_object_name`](https://github.com/scrapy/scrapy/blob/261c4b61dc48353346c1e0387d0783ac15ab459d/scrapy/utils/python.py#L330).",
      "comment_id": 1841833611,
      "user": "Gallaecio",
      "created_at": "2024-11-14T09:14:54Z",
      "url": "https://github.com/scrapy/scrapy/pull/6540#discussion_r1841833611"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 6540,
      "file_path": "scrapy/utils/misc.py",
      "line": 178,
      "side": "RIGHT",
      "diff_hunk": "@@ -176,7 +175,7 @@ def create_instance(objcls, settings, crawler, *args, **kwargs):\n def build_from_crawler(\n     objcls: type[T], crawler: Crawler, /, *args: Any, **kwargs: Any\n ) -> T:\n-    \"\"\"Construct a class instance using its ``from_crawler`` constructor.\n+    \"\"\"Construct a class instance using its ``from_crawler`` or ``from_settings`` constructor.",
      "comment": "I wonder if we need this given `from_settings` is deprecated, but no strong opinion against it.",
      "comment_id": 1841836638,
      "user": "Gallaecio",
      "created_at": "2024-11-14T09:16:57Z",
      "url": "https://github.com/scrapy/scrapy/pull/6540#discussion_r1841836638"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 6519,
      "file_path": "scrapy/utils/serialize.py",
      "line": 20,
      "side": "RIGHT",
      "diff_hunk": "@@ -14,6 +16,11 @@ class ScrapyJSONEncoder(json.JSONEncoder):\n     TIME_FORMAT = \"%H:%M:%S\"\n \n     def default(self, o: Any) -> Any:\n+        warnings.warn(\n+            \"'ScrapyJSONEncoder' is a deprecated setting.\\nIt will be removed in a future version of Scrapy.\",",
      "comment": "Yes i got confused.\r\nI think if i implement this the issue will be resolved. \r\n```python\r\ndef __init__(self, *args, **kwargs):\r\n    warnings.warn(\r\n        \"'ScrapyJSONEncoder' is a deprecated setting.\\nIt will be removed in a future version of Scrapy.\",\r\n        category=ScrapyDeprecationWarning,\r\n        stacklevel=2\r\n    )\r\n    super().__init__(*args, **kwargs)\r\n```\r\nI'm asking it beforehand as I have very less experience with Oops in python.",
      "comment_id": 1824023508,
      "user": "Rohitkr117",
      "created_at": "2024-10-31T07:49:02Z",
      "url": "https://github.com/scrapy/scrapy/pull/6519#discussion_r1824023508"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 6519,
      "file_path": "scrapy/utils/serialize.py",
      "line": 20,
      "side": "RIGHT",
      "diff_hunk": "@@ -14,6 +16,11 @@ class ScrapyJSONEncoder(json.JSONEncoder):\n     TIME_FORMAT = \"%H:%M:%S\"\n \n     def default(self, o: Any) -> Any:\n+        warnings.warn(\n+            \"'ScrapyJSONEncoder' is a deprecated setting.\\nIt will be removed in a future version of Scrapy.\",",
      "comment": "What I meant here is that `ScrapyJSONEncoder` and `ScrapyJSONDecoder` are different classes (they are also not settings).\r\n\r\nMy stacklevel comment was about the other places where you care calling `warn()` with the default value of it.",
      "comment_id": 1824027147,
      "user": "wRAR",
      "created_at": "2024-10-31T07:52:42Z",
      "url": "https://github.com/scrapy/scrapy/pull/6519#discussion_r1824027147"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 6519,
      "file_path": "scrapy/utils/serialize.py",
      "line": 20,
      "side": "RIGHT",
      "diff_hunk": "@@ -14,6 +16,11 @@ class ScrapyJSONEncoder(json.JSONEncoder):\n     TIME_FORMAT = \"%H:%M:%S\"\n \n     def default(self, o: Any) -> Any:\n+        warnings.warn(\n+            \"'ScrapyJSONEncoder' is a deprecated setting.\\nIt will be removed in a future version of Scrapy.\",",
      "comment": "(as for the implementation, putting this in `__init__` is correct)",
      "comment_id": 1824028559,
      "user": "wRAR",
      "created_at": "2024-10-31T07:54:09Z",
      "url": "https://github.com/scrapy/scrapy/pull/6519#discussion_r1824028559"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 6519,
      "file_path": "scrapy/utils/serialize.py",
      "line": 20,
      "side": "RIGHT",
      "diff_hunk": "@@ -14,6 +16,11 @@ class ScrapyJSONEncoder(json.JSONEncoder):\n     TIME_FORMAT = \"%H:%M:%S\"\n \n     def default(self, o: Any) -> Any:\n+        warnings.warn(\n+            \"'ScrapyJSONEncoder' is a deprecated setting.\\nIt will be removed in a future version of Scrapy.\",",
      "comment": "> What I meant here is that `ScrapyJSONEncoder` and `ScrapyJSONDecoder` are different classes (they are also not settings).\r\n\r\nReally sorry for such a silly mistake of targetting the wrong class. I would double-check things like these from next time. \r\n\r\n",
      "comment_id": 1824045412,
      "user": "Rohitkr117",
      "created_at": "2024-10-31T08:10:35Z",
      "url": "https://github.com/scrapy/scrapy/pull/6519#discussion_r1824045412"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 6519,
      "file_path": "scrapy/utils/test.py",
      "line": 131,
      "side": "RIGHT",
      "diff_hunk": "@@ -125,6 +127,10 @@ def assert_samelines(\n     \"\"\"Asserts text1 and text2 have the same lines, ignoring differences in\n     line endings between platforms\n     \"\"\"\n+    warnings.warn(\n+        \"The 'assert_samelines' is a deprecated function and will be removed in a future version of Scrapy.\",",
      "comment": "```suggestion\r\n        \"The 'assert_samelines' function is deprecated and will be removed in a future version of Scrapy.\",\r\n```",
      "comment_id": 1824386001,
      "user": "wRAR",
      "created_at": "2024-10-31T12:43:31Z",
      "url": "https://github.com/scrapy/scrapy/pull/6519#discussion_r1824386001"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 6519,
      "file_path": "scrapy/utils/serialize.py",
      "line": 43,
      "side": "RIGHT",
      "diff_hunk": "@@ -36,4 +38,10 @@ def default(self, o: Any) -> Any:\n \n \n class ScrapyJSONDecoder(json.JSONDecoder):\n-    pass\n+    def __init__(self, *args, **kwargs):\n+        warnings.warn(\n+            \"'ScrapyJSONDecoder' is a deprecated setting.\\nIt will be removed in a future version of Scrapy.\",",
      "comment": "Should make the format for this warning(for the class) a two line statement just to distinguish it from a deprecation message for a function or make it a one-liner like a function?",
      "comment_id": 1824423228,
      "user": "Rohitkr117",
      "created_at": "2024-10-31T13:06:35Z",
      "url": "https://github.com/scrapy/scrapy/pull/6519#discussion_r1824423228"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 6519,
      "file_path": "scrapy/utils/serialize.py",
      "line": 43,
      "side": "RIGHT",
      "diff_hunk": "@@ -40,7 +40,7 @@ def default(self, o: Any) -> Any:\n class ScrapyJSONDecoder(json.JSONDecoder):\n     def __init__(self, *args, **kwargs):\n         warnings.warn(\n-            \"'ScrapyJSONDecoder' is a deprecated setting.\\nIt will be removed in a future version of Scrapy.\",\n+            \"'ScrapyJSONDecoder' class is deprecated and will be removed in a future version of Scrapy.\",",
      "comment": "```suggestion\r\n            \"The 'ScrapyJSONDecoder' class is deprecated and will be removed in a future version of Scrapy.\",\r\n```\r\n\r\nYou could also omit the single quotes, I think, but no strong opinion on that.",
      "comment_id": 1827509455,
      "user": "Gallaecio",
      "created_at": "2024-11-04T10:29:17Z",
      "url": "https://github.com/scrapy/scrapy/pull/6519#discussion_r1827509455"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 6246,
      "file_path": "scrapy/extensions/throttle.py",
      "line": 53,
      "side": "RIGHT",
      "diff_hunk": "@@ -50,7 +50,7 @@ def _start_delay(self, spider):\n     def _response_downloaded(self, response, request, spider):\n         key, slot = self._get_slot(request, spider)\n         latency = request.meta.get(\"download_latency\")\n-        if latency is None or slot is None:\n+        if latency is None or slot is None or slot.throttle is False:",
      "comment": "On a first sight, it's possible to add `dont_throttle` meta key, and avoid connecting core components with extensions.",
      "comment_id": 1827583470,
      "user": "kmike",
      "created_at": "2024-11-04T11:28:12Z",
      "url": "https://github.com/scrapy/scrapy/pull/6246#discussion_r1827583470"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 6246,
      "file_path": "scrapy/extensions/throttle.py",
      "line": 53,
      "side": "RIGHT",
      "diff_hunk": "@@ -50,7 +50,7 @@ def _start_delay(self, spider):\n     def _response_downloaded(self, response, request, spider):\n         key, slot = self._get_slot(request, spider)\n         latency = request.meta.get(\"download_latency\")\n-        if latency is None or slot is None:\n+        if latency is None or slot is None or slot.throttle is False:",
      "comment": "Are we talking about implementing a downloader middleware that applies that meta key based on the `DOWNLOAD_SLOTS` setting, i.e. that setting would be managed by the core expect for that specific key? Or do you have something else in mind for the user-facing API?",
      "comment_id": 1827605821,
      "user": "Gallaecio",
      "created_at": "2024-11-04T11:47:21Z",
      "url": "https://github.com/scrapy/scrapy/pull/6246#discussion_r1827605821"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 6246,
      "file_path": "scrapy/extensions/throttle.py",
      "line": 53,
      "side": "RIGHT",
      "diff_hunk": "@@ -50,7 +50,7 @@ def _start_delay(self, spider):\n     def _response_downloaded(self, response, request, spider):\n         key, slot = self._get_slot(request, spider)\n         latency = request.meta.get(\"download_latency\")\n-        if latency is None or slot is None:\n+        if latency is None or slot is None or slot.throttle is False:",
      "comment": "I was thinking that this feature can be unrelated to slots: just a per-request flag to disable autothrottle.\r\nIf this solves the scrapy-zyte-api issue, we can bypass all DOWNLOAD_SLOTS discussions for now :)",
      "comment_id": 1827772375,
      "user": "kmike",
      "created_at": "2024-11-04T13:55:16Z",
      "url": "https://github.com/scrapy/scrapy/pull/6246#discussion_r1827772375"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 6427,
      "file_path": "scrapy/item.py",
      "line": 72,
      "side": "RIGHT",
      "diff_hunk": "@@ -61,16 +61,13 @@ def __new__(\n \n \n class Item(MutableMapping[str, Any], object_ref, metaclass=ItemMeta):\n-    \"\"\"\n-    Base class for scraped items.\n-\n-    In Scrapy, an object is considered an ``item`` if it is an instance of either\n-    :class:`Item` or :class:`dict`, or any subclass. For example, when the output of a\n-    spider callback is evaluated, only instances of :class:`Item` or\n-    :class:`dict` are passed to :ref:`item pipelines <topics-item-pipeline>`.\n+    \"\"\"Base class for scraped items.\n \n-    If you need instances of a custom class to be considered items by Scrapy,\n-    you must inherit from either :class:`Item` or :class:`dict`.\n+    In Scrapy, an object is considered an ``item`` if it's supported by the\n+    `itemadapter`_ library. For example, when the output of a spider callback\n+    is evaluated, only such objects are passed to :ref:`item pipelines\n+    <topics-item-pipeline>`. :class:`Item` is one of the classes supported by\n+    `itemadapter`_ by default.\n \n     Items must declare :class:`Field` attributes, which are processed and stored",
      "comment": "Maybe changing ``` :class:`Field` ``` to ``` :class:`~scrapy.Field` ``` or (more likely) ``` :class:`~scrapy.item.Field` ``` fixes the linking.",
      "comment_id": 1665164151,
      "user": "Gallaecio",
      "created_at": "2024-07-04T05:53:38Z",
      "url": "https://github.com/scrapy/scrapy/pull/6427#discussion_r1665164151"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 6427,
      "file_path": "scrapy/item.py",
      "line": 72,
      "side": "RIGHT",
      "diff_hunk": "@@ -61,16 +61,13 @@ def __new__(\n \n \n class Item(MutableMapping[str, Any], object_ref, metaclass=ItemMeta):\n-    \"\"\"\n-    Base class for scraped items.\n-\n-    In Scrapy, an object is considered an ``item`` if it is an instance of either\n-    :class:`Item` or :class:`dict`, or any subclass. For example, when the output of a\n-    spider callback is evaluated, only instances of :class:`Item` or\n-    :class:`dict` are passed to :ref:`item pipelines <topics-item-pipeline>`.\n+    \"\"\"Base class for scraped items.\n \n-    If you need instances of a custom class to be considered items by Scrapy,\n-    you must inherit from either :class:`Item` or :class:`dict`.\n+    In Scrapy, an object is considered an ``item`` if it's supported by the\n+    `itemadapter`_ library. For example, when the output of a spider callback\n+    is evaluated, only such objects are passed to :ref:`item pipelines\n+    <topics-item-pipeline>`. :class:`Item` is one of the classes supported by\n+    `itemadapter`_ by default.\n \n     Items must declare :class:`Field` attributes, which are processed and stored",
      "comment": "There is also another problem, the fragments in generated links: https://docs.scrapy.org/en/latest/topics/items.html#scrapy.item.scrapy.item.Item\r\n\r\nProbably because of `.. module:: scrapy.item` at the beginning of items.rst?\r\n\r\nAnd what do you think about adding the docstring to the documentation page, or is it a separate more general task?",
      "comment_id": 1665254868,
      "user": "wRAR",
      "created_at": "2024-07-04T07:24:51Z",
      "url": "https://github.com/scrapy/scrapy/pull/6427#discussion_r1665254868"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 6427,
      "file_path": "scrapy/item.py",
      "line": 72,
      "side": "RIGHT",
      "diff_hunk": "@@ -61,16 +61,13 @@ def __new__(\n \n \n class Item(MutableMapping[str, Any], object_ref, metaclass=ItemMeta):\n-    \"\"\"\n-    Base class for scraped items.\n-\n-    In Scrapy, an object is considered an ``item`` if it is an instance of either\n-    :class:`Item` or :class:`dict`, or any subclass. For example, when the output of a\n-    spider callback is evaluated, only instances of :class:`Item` or\n-    :class:`dict` are passed to :ref:`item pipelines <topics-item-pipeline>`.\n+    \"\"\"Base class for scraped items.\n \n-    If you need instances of a custom class to be considered items by Scrapy,\n-    you must inherit from either :class:`Item` or :class:`dict`.\n+    In Scrapy, an object is considered an ``item`` if it's supported by the\n+    `itemadapter`_ library. For example, when the output of a spider callback\n+    is evaluated, only such objects are passed to :ref:`item pipelines\n+    <topics-item-pipeline>`. :class:`Item` is one of the classes supported by\n+    `itemadapter`_ by default.\n \n     Items must declare :class:`Field` attributes, which are processed and stored",
      "comment": "> Probably because of `.. module:: scrapy.item` at the beginning of items.rst?\r\n\r\nIndeed.\r\n\r\n> And what do you think about adding the docstring to the documentation page, or is it a separate more general task?\r\n\r\nNo strong opinion, up to you.",
      "comment_id": 1665406782,
      "user": "Gallaecio",
      "created_at": "2024-07-04T09:17:49Z",
      "url": "https://github.com/scrapy/scrapy/pull/6427#discussion_r1665406782"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 6500,
      "file_path": "scrapy/crawler.py",
      "line": 144,
      "side": "RIGHT",
      "diff_hunk": "@@ -142,10 +140,8 @@ def crawl(self, *args: Any, **kwargs: Any) -> Generator[Deferred[Any], Any, None\n         if self.crawling:\n             raise RuntimeError(\"Crawling already taking place\")\n         if self._started:\n-            warnings.warn(\n-                \"Running Crawler.crawl() more than once is deprecated.\",\n-                ScrapyDeprecationWarning,\n-                stacklevel=2,\n+            raise RuntimeError(\n+                \"Running Crawler.crawl() more than once on the same instance is forbidden.\"",
      "comment": "\u201cForbidden\u201d in this context sounds a bit weird to me. What about:\r\n\r\n```suggestion\r\n                \"Cannot run Crawler.crawl() more than once on the same instance.\"\r\n```",
      "comment_id": 1822137434,
      "user": "Gallaecio",
      "created_at": "2024-10-30T08:46:17Z",
      "url": "https://github.com/scrapy/scrapy/pull/6500#discussion_r1822137434"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 6500,
      "file_path": "scrapy/pipelines/images.py",
      "line": 208,
      "side": "RIGHT",
      "diff_hunk": "@@ -203,49 +188,25 @@ def get_images(\n                 f\"{self.min_width}x{self.min_height})\"\n             )\n \n-        if self._deprecated_convert_image is None:\n-            self._deprecated_convert_image = \"response_body\" not in get_func_args(\n-                self.convert_image\n-            )\n-            if self._deprecated_convert_image:\n-                warnings.warn(\n-                    f\"{self.__class__.__name__}.convert_image() method overridden in a deprecated way, \"\n-                    \"overridden method does not accept response_body argument.\",\n-                    category=ScrapyDeprecationWarning,\n-                )\n-\n-        if self._deprecated_convert_image:\n-            image, buf = self.convert_image(orig_image)\n-        else:\n-            image, buf = self.convert_image(\n-                orig_image, response_body=BytesIO(response.body)\n-            )\n+        image, buf = self.convert_image(\n+            orig_image, response_body=BytesIO(response.body)\n+        )\n         yield path, image, buf\n \n         for thumb_id, size in self.thumbs.items():\n             thumb_path = self.thumb_path(\n                 request, thumb_id, response=response, info=info, item=item\n             )\n-            if self._deprecated_convert_image:\n-                thumb_image, thumb_buf = self.convert_image(image, size)\n-            else:\n-                thumb_image, thumb_buf = self.convert_image(image, size, buf)\n+            thumb_image, thumb_buf = self.convert_image(image, size, response_body=buf)\n             yield thumb_path, thumb_image, thumb_buf\n \n     def convert_image(\n         self,\n         image: Image.Image,\n         size: tuple[int, int] | None = None,\n-        response_body: BytesIO | None = None,\n+        *,\n+        response_body: BytesIO,",
      "comment": "I get that the goal is to make the parameter required, without a default value, but we deprecated it having `None` as value, not it being used as a positional argument, so this change is backward-incompatible.\r\n\r\nI\u2019m thinking we should raise `ValueError` if the value is `None` now, and log a new warning if the parameter is used positionally, so that we can eventually make this change. And maybe we should take the chance to do the same with  `size`, deprecate it being positional.\r\n\r\nI was unsure how to handle such a deprecation without removing the typing hints. Gemini suggested using `inspect`:\r\n\r\n```python\r\nimport inspect\r\n\r\ndef my_function(param1: int, param2: str = \"default_value\"):\r\n    frame_record = inspect.stack()[1]\r\n    args, _, _, values = inspect.getargvalues(frame_record[0])\r\n    if param2 in args:\r\n        print(\"param2 was passed positionally\")\r\n    else:\r\n        print(\"param2 was passed as a keyword argument\")\r\n```\r\n\r\n",
      "comment_id": 1822158615,
      "user": "Gallaecio",
      "created_at": "2024-10-30T09:00:44Z",
      "url": "https://github.com/scrapy/scrapy/pull/6500#discussion_r1822158615"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 6500,
      "file_path": "scrapy/utils/conf.py",
      "line": 23,
      "side": "RIGHT",
      "diff_hunk": "@@ -21,7 +20,7 @@\n \n def build_component_list(\n     compdict: MutableMapping[Any, Any],\n-    custom: Any = None,\n+    *,",
      "comment": "While this seems similar to the `convert_image` scenario above, I feel like here we are more justified in this change, because the Pythonic way to fix `build_component_list({}, foo, bar)` was switching to `build_component_list({}, convert=bar)`.\r\n\r\nThat said, I wonder if we should follow a similar inspect-based deprecation approach here as well, in case some users went with `build_component_list({}, None, bar)` instead, as that was also a valid way to get rid of the warning.",
      "comment_id": 1822174241,
      "user": "Gallaecio",
      "created_at": "2024-10-30T09:10:00Z",
      "url": "https://github.com/scrapy/scrapy/pull/6500#discussion_r1822174241"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 6500,
      "file_path": "scrapy/utils/conf.py",
      "line": 148,
      "side": "RIGHT",
      "diff_hunk": "@@ -159,7 +145,7 @@ def feed_complete_default_values_from_settings(\n def feed_process_params_from_cli(\n     settings: BaseSettings,\n     output: list[str],\n-    output_format: str | None = None,\n+    *,",
      "comment": "Same as with `build_component_list` here. I am OK with this approach, but I would see the argument for deprecating the existence of the parameter separately in a more robust way.",
      "comment_id": 1822178151,
      "user": "Gallaecio",
      "created_at": "2024-10-30T09:12:48Z",
      "url": "https://github.com/scrapy/scrapy/pull/6500#discussion_r1822178151"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 6500,
      "file_path": "scrapy/pipelines/images.py",
      "line": 208,
      "side": "RIGHT",
      "diff_hunk": "@@ -203,49 +188,25 @@ def get_images(\n                 f\"{self.min_width}x{self.min_height})\"\n             )\n \n-        if self._deprecated_convert_image is None:\n-            self._deprecated_convert_image = \"response_body\" not in get_func_args(\n-                self.convert_image\n-            )\n-            if self._deprecated_convert_image:\n-                warnings.warn(\n-                    f\"{self.__class__.__name__}.convert_image() method overridden in a deprecated way, \"\n-                    \"overridden method does not accept response_body argument.\",\n-                    category=ScrapyDeprecationWarning,\n-                )\n-\n-        if self._deprecated_convert_image:\n-            image, buf = self.convert_image(orig_image)\n-        else:\n-            image, buf = self.convert_image(\n-                orig_image, response_body=BytesIO(response.body)\n-            )\n+        image, buf = self.convert_image(\n+            orig_image, response_body=BytesIO(response.body)\n+        )\n         yield path, image, buf\n \n         for thumb_id, size in self.thumbs.items():\n             thumb_path = self.thumb_path(\n                 request, thumb_id, response=response, info=info, item=item\n             )\n-            if self._deprecated_convert_image:\n-                thumb_image, thumb_buf = self.convert_image(image, size)\n-            else:\n-                thumb_image, thumb_buf = self.convert_image(image, size, buf)\n+            thumb_image, thumb_buf = self.convert_image(image, size, response_body=buf)\n             yield thumb_path, thumb_image, thumb_buf\n \n     def convert_image(\n         self,\n         image: Image.Image,\n         size: tuple[int, int] | None = None,\n-        response_body: BytesIO | None = None,\n+        *,\n+        response_body: BytesIO,",
      "comment": "FTR this suggestion doesn't work :) https://stackoverflow.com/questions/56468082/inspect-if-an-argument-was-passed-positionally-or-via-keyword",
      "comment_id": 1824245893,
      "user": "wRAR",
      "created_at": "2024-10-31T10:44:03Z",
      "url": "https://github.com/scrapy/scrapy/pull/6500#discussion_r1824245893"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 6512,
      "file_path": "scrapy/__init__.py",
      "line": 37,
      "side": "LEFT",
      "diff_hunk": "@@ -30,13 +26,22 @@\n # Scrapy and Twisted versions\n __version__ = (pkgutil.get_data(__package__, \"VERSION\") or b\"\").decode(\"ascii\").strip()\n version_info = tuple(int(v) if v.isdigit() else v for v in __version__.split(\".\"))\n-twisted_version = (_txv.major, _txv.minor, _txv.micro)\n \n \n-# Ignore noisy twisted deprecation warnings\n-warnings.filterwarnings(\"ignore\", category=DeprecationWarning, module=\"twisted\")",
      "comment": "For some reason if I add this piece I get duplicate deprecation warning message, also not sure where should I place a test for this change.",
      "comment_id": 1817918626,
      "user": "Laerte",
      "created_at": "2024-10-26T19:43:03Z",
      "url": "https://github.com/scrapy/scrapy/pull/6512#discussion_r1817918626"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 6512,
      "file_path": "scrapy/__init__.py",
      "line": 37,
      "side": "LEFT",
      "diff_hunk": "@@ -30,13 +26,22 @@\n # Scrapy and Twisted versions\n __version__ = (pkgutil.get_data(__package__, \"VERSION\") or b\"\").decode(\"ascii\").strip()\n version_info = tuple(int(v) if v.isdigit() else v for v in __version__.split(\".\"))\n-twisted_version = (_txv.major, _txv.minor, _txv.micro)\n \n \n-# Ignore noisy twisted deprecation warnings\n-warnings.filterwarnings(\"ignore\", category=DeprecationWarning, module=\"twisted\")",
      "comment": "> if I add this piece I get duplicate deprecation warning message\r\n\r\nCan you show an example?\r\n\r\nI think this line shouldn't be removed, though it's probably not that useful, as IIRC `DeprecationWarning` warnings aren't printed anywhere by default.",
      "comment_id": 1817921563,
      "user": "wRAR",
      "created_at": "2024-10-26T20:07:11Z",
      "url": "https://github.com/scrapy/scrapy/pull/6512#discussion_r1817921563"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 6512,
      "file_path": "scrapy/__init__.py",
      "line": 37,
      "side": "LEFT",
      "diff_hunk": "@@ -30,13 +26,22 @@\n # Scrapy and Twisted versions\n __version__ = (pkgutil.get_data(__package__, \"VERSION\") or b\"\").decode(\"ascii\").strip()\n version_info = tuple(int(v) if v.isdigit() else v for v in __version__.split(\".\"))\n-twisted_version = (_txv.major, _txv.minor, _txv.micro)\n \n \n-# Ignore noisy twisted deprecation warnings\n-warnings.filterwarnings(\"ignore\", category=DeprecationWarning, module=\"twisted\")",
      "comment": "Sure, add the removed line after the warnings import and then call this snippet:\r\n\r\n```python\r\nfrom scrapy import twisted_version\r\nprint(twisted_version)\r\n```",
      "comment_id": 1817922044,
      "user": "Laerte",
      "created_at": "2024-10-26T20:10:27Z",
      "url": "https://github.com/scrapy/scrapy/pull/6512#discussion_r1817922044"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 6512,
      "file_path": "scrapy/__init__.py",
      "line": 37,
      "side": "LEFT",
      "diff_hunk": "@@ -30,13 +26,22 @@\n # Scrapy and Twisted versions\n __version__ = (pkgutil.get_data(__package__, \"VERSION\") or b\"\").decode(\"ascii\").strip()\n version_info = tuple(int(v) if v.isdigit() else v for v in __version__.split(\".\"))\n-twisted_version = (_txv.major, _txv.minor, _txv.micro)\n \n \n-# Ignore noisy twisted deprecation warnings\n-warnings.filterwarnings(\"ignore\", category=DeprecationWarning, module=\"twisted\")",
      "comment": "~~Now i'm trying to figure out why tests are failing after I added ``__getattr__`` method. \ud83d\ude05~~. Done. ",
      "comment_id": 1817922133,
      "user": "Laerte",
      "created_at": "2024-10-26T20:11:20Z",
      "url": "https://github.com/scrapy/scrapy/pull/6512#discussion_r1817922133"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 6512,
      "file_path": "scrapy/__init__.py",
      "line": 45,
      "side": "RIGHT",
      "diff_hunk": "@@ -30,13 +26,24 @@\n # Scrapy and Twisted versions\n __version__ = (pkgutil.get_data(__package__, \"VERSION\") or b\"\").decode(\"ascii\").strip()\n version_info = tuple(int(v) if v.isdigit() else v for v in __version__.split(\".\"))\n-twisted_version = (_txv.major, _txv.minor, _txv.micro)\n \n \n-# Ignore noisy twisted deprecation warnings\n-warnings.filterwarnings(\"ignore\", category=DeprecationWarning, module=\"twisted\")\n+def __getattr__(name: str):\n+    if name == \"twisted_version\":\n+        import warnings\n+\n+        from twisted import version as _txv\n+\n+        from scrapy.exceptions import ScrapyDeprecationWarning\n+\n+        warnings.warn(\n+            \"The scrapy.twisted_version attribute is deprecated, use twisted.version instead\",\n+            ScrapyDeprecationWarning,\n+        )\n+        return _txv.major, _txv.minor, _txv.micro\n+\n+    raise AttributeError",
      "comment": "Wondering since this is a module if we should raise `ImportError` instead.",
      "comment_id": 1817945668,
      "user": "Laerte",
      "created_at": "2024-10-26T22:50:05Z",
      "url": "https://github.com/scrapy/scrapy/pull/6512#discussion_r1817945668"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 6512,
      "file_path": "scrapy/__init__.py",
      "line": 37,
      "side": "LEFT",
      "diff_hunk": "@@ -30,13 +26,22 @@\n # Scrapy and Twisted versions\n __version__ = (pkgutil.get_data(__package__, \"VERSION\") or b\"\").decode(\"ascii\").strip()\n version_info = tuple(int(v) if v.isdigit() else v for v in __version__.split(\".\"))\n-twisted_version = (_txv.major, _txv.minor, _txv.micro)\n \n \n-# Ignore noisy twisted deprecation warnings\n-warnings.filterwarnings(\"ignore\", category=DeprecationWarning, module=\"twisted\")",
      "comment": "I get this with or without this line:\r\n```\r\n>>> from scrapy import twisted_version\r\n[...]/scrapy/scrapy/__init__.py:43: ScrapyDeprecationWarning: The scrapy.twisted_version attribute is deprecated, use twisted.version instead\r\n  warnings.warn(\r\n>>> print(twisted_version)\r\n(24, 7, 0)\r\n```",
      "comment_id": 1820972881,
      "user": "wRAR",
      "created_at": "2024-10-29T14:57:28Z",
      "url": "https://github.com/scrapy/scrapy/pull/6512#discussion_r1820972881"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 6512,
      "file_path": "scrapy/__init__.py",
      "line": 36,
      "side": "RIGHT",
      "diff_hunk": "@@ -30,13 +26,27 @@\n # Scrapy and Twisted versions\n __version__ = (pkgutil.get_data(__package__, \"VERSION\") or b\"\").decode(\"ascii\").strip()\n version_info = tuple(int(v) if v.isdigit() else v for v in __version__.split(\".\"))\n-twisted_version = (_txv.major, _txv.minor, _txv.micro)\n \n \n-# Ignore noisy twisted deprecation warnings\n-warnings.filterwarnings(\"ignore\", category=DeprecationWarning, module=\"twisted\")\n+def __getattr__(name: str):\n+    if name == \"twisted_version\":\n+        import warnings\n+\n+        # Ignore noisy twisted deprecation warnings\n+        warnings.filterwarnings(\"ignore\", category=DeprecationWarning, module=\"twisted\")",
      "comment": "I think the reason for this line is to be executed before any Scrapy code, so that the user doesn't see those warnings. It was there before `from twisted import version` was even added.",
      "comment_id": 1821229337,
      "user": "wRAR",
      "created_at": "2024-10-29T17:04:50Z",
      "url": "https://github.com/scrapy/scrapy/pull/6512#discussion_r1821229337"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 6463,
      "file_path": "scrapy/pipelines/media.py",
      "line": 214,
      "side": "RIGHT",
      "diff_hunk": "@@ -211,7 +211,7 @@ def _cache_result_and_execute_waiters(\n             # minimize cached information for failure\n             result.cleanFailure()\n             result.frames = []\n-            result.stack = None\n+            result.stack = []",
      "comment": "Can you please revert this change? It's unrelated and has its own PR.",
      "comment_id": 1726885934,
      "user": "wRAR",
      "created_at": "2024-08-22T11:34:14Z",
      "url": "https://github.com/scrapy/scrapy/pull/6463#discussion_r1726885934"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 6501,
      "file_path": "tests/test_utils_asyncio.py",
      "line": 5,
      "side": "RIGHT",
      "diff_hunk": "@@ -1,8 +1,8 @@\n import asyncio\n import warnings\n-from unittest import TestCase\n \n from pytest import mark\n+from twisted.trial.unittest import TestCase",
      "comment": "Found when looking at deprecation warnings but it's actually a bug fix, the test didn't run before the change.",
      "comment_id": 1807298842,
      "user": "wRAR",
      "created_at": "2024-10-19T11:44:42Z",
      "url": "https://github.com/scrapy/scrapy/pull/6501#discussion_r1807298842"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 6472,
      "file_path": "scrapy/utils/trackref.py",
      "line": 33,
      "side": "RIGHT",
      "diff_hunk": "@@ -9,27 +9,28 @@\n alias to object in that case).\n \"\"\"\n \n+from __future__ import annotations\n+\n from collections import defaultdict\n from operator import itemgetter\n from time import time\n-from typing import TYPE_CHECKING, Any, DefaultDict, Iterable\n+from typing import TYPE_CHECKING, Any\n from weakref import WeakKeyDictionary\n \n if TYPE_CHECKING:\n-    # typing.Self requires Python 3.11\n-    from typing_extensions import Self\n+    from collections.abc import Iterable\n \n \n NoneType = type(None)\n-live_refs: DefaultDict[type, WeakKeyDictionary] = defaultdict(WeakKeyDictionary)\n+live_refs: defaultdict[type, WeakKeyDictionary] = defaultdict(WeakKeyDictionary)\n \n \n class object_ref:\n     \"\"\"Inherit from this class to a keep a record of live instances\"\"\"\n \n     __slots__ = ()\n \n-    def __new__(cls, *args: Any, **kwargs: Any) -> \"Self\":\n+    def __new__(cls, *args: Any, **kwargs: Any) -> object_ref:",
      "comment": "I don't think this is correct, `object.__new__(cls)` returns a `cls` instance.",
      "comment_id": 1741941645,
      "user": "wRAR",
      "created_at": "2024-09-03T12:07:31Z",
      "url": "https://github.com/scrapy/scrapy/pull/6472#discussion_r1741941645"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 6472,
      "file_path": "scrapy/utils/defer.py",
      "line": 133,
      "side": "RIGHT",
      "diff_hunk": "@@ -145,7 +130,7 @@ def parallel(\n     return DeferredList([coop.coiterate(work) for _ in range(count)])\n \n \n-class _AsyncCooperatorAdapter(Iterator[Deferred], Generic[_T]):\n+class _AsyncCooperatorAdapter(Iterator[Deferred], Generic[_T, _SelfResultT]):",
      "comment": "Reverted. I was getting the following error (and am now getting it again):\r\n\r\nE   TypeError: Some type variables (\\~_SelfResultT) are not listed in Generic[\\~_T]",
      "comment_id": 1743532415,
      "user": "vsevolodbreus",
      "created_at": "2024-09-04T10:52:47Z",
      "url": "https://github.com/scrapy/scrapy/pull/6472#discussion_r1743532415"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 6472,
      "file_path": "setup.py",
      "line": 9,
      "side": "RIGHT",
      "diff_hunk": "@@ -6,7 +6,7 @@\n \n \n install_requires = [\n-    \"Twisted>=18.9.0\",\n+    \"Twisted>=20.3.0\",",
      "comment": "Windows build is failing for 18.9.0. Trying to determine whether this is a version issue.",
      "comment_id": 1743534685,
      "user": "vsevolodbreus",
      "created_at": "2024-09-04T10:54:17Z",
      "url": "https://github.com/scrapy/scrapy/pull/6472#discussion_r1743534685"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 6472,
      "file_path": "scrapy/utils/defer.py",
      "line": 133,
      "side": "RIGHT",
      "diff_hunk": "@@ -145,7 +130,7 @@ def parallel(\n     return DeferredList([coop.coiterate(work) for _ in range(count)])\n \n \n-class _AsyncCooperatorAdapter(Iterator[Deferred], Generic[_T]):\n+class _AsyncCooperatorAdapter(Iterator[Deferred], Generic[_T, _SelfResultT]):",
      "comment": "See full error stack trace here: https://github.com/vsevolodbreus/scrapy/actions/runs/10700184494/job/29663370539",
      "comment_id": 1743543183,
      "user": "vsevolodbreus",
      "created_at": "2024-09-04T10:59:42Z",
      "url": "https://github.com/scrapy/scrapy/pull/6472#discussion_r1743543183"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 6472,
      "file_path": "scrapy/utils/trackref.py",
      "line": 33,
      "side": "RIGHT",
      "diff_hunk": "@@ -9,27 +9,28 @@\n alias to object in that case).\n \"\"\"\n \n+from __future__ import annotations\n+\n from collections import defaultdict\n from operator import itemgetter\n from time import time\n-from typing import TYPE_CHECKING, Any, DefaultDict, Iterable\n+from typing import TYPE_CHECKING, Any\n from weakref import WeakKeyDictionary\n \n if TYPE_CHECKING:\n-    # typing.Self requires Python 3.11\n-    from typing_extensions import Self\n+    from collections.abc import Iterable\n \n \n NoneType = type(None)\n-live_refs: DefaultDict[type, WeakKeyDictionary] = defaultdict(WeakKeyDictionary)\n+live_refs: defaultdict[type, WeakKeyDictionary] = defaultdict(WeakKeyDictionary)\n \n \n class object_ref:\n     \"\"\"Inherit from this class to a keep a record of live instances\"\"\"\n \n     __slots__ = ()\n \n-    def __new__(cls, *args: Any, **kwargs: Any) -> \"Self\":\n+    def __new__(cls, *args: Any, **kwargs: Any) -> object_ref:",
      "comment": "Reverted. But with quotes removed. I got an error message about \"Self\" being a string literal.",
      "comment_id": 1743545113,
      "user": "vsevolodbreus",
      "created_at": "2024-09-04T11:00:59Z",
      "url": "https://github.com/scrapy/scrapy/pull/6472#discussion_r1743545113"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 6472,
      "file_path": "scrapy/utils/defer.py",
      "line": 133,
      "side": "RIGHT",
      "diff_hunk": "@@ -145,7 +130,7 @@ def parallel(\n     return DeferredList([coop.coiterate(work) for _ in range(count)])\n \n \n-class _AsyncCooperatorAdapter(Iterator[Deferred], Generic[_T]):\n+class _AsyncCooperatorAdapter(Iterator[Deferred], Generic[_T, _SelfResultT]):",
      "comment": "Looks like it was fixed in some 3.10.x (it works on 3.10.14 and doesn't work on 3.10.5, maybe it's related to \"gh-98852: Fix subscription of types.GenericAlias instances containing bare generic types: for example tuple[A, T][int], where A is a generic type, and T is a type variable.\" from 3.10.9) and 3.11+ and wasn't fixed in 3.9. And it looks like `typing.Iterator` works here so there is a workaround.",
      "comment_id": 1743632271,
      "user": "wRAR",
      "created_at": "2024-09-04T11:52:12Z",
      "url": "https://github.com/scrapy/scrapy/pull/6472#discussion_r1743632271"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 6472,
      "file_path": "setup.py",
      "line": 9,
      "side": "RIGHT",
      "diff_hunk": "@@ -6,7 +6,7 @@\n \n \n install_requires = [\n-    \"Twisted>=18.9.0\",\n+    \"Twisted>=20.3.0\",",
      "comment": "I checked this and yeah, iocpsupport from Twisted < 20.3.0 fails to build on Python 3.8 so this makes sense.",
      "comment_id": 1770569112,
      "user": "wRAR",
      "created_at": "2024-09-22T14:38:01Z",
      "url": "https://github.com/scrapy/scrapy/pull/6472#discussion_r1770569112"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 6417,
      "file_path": "scrapy/core/engine.py",
      "line": 221,
      "side": "RIGHT",
      "diff_hunk": "@@ -205,7 +206,19 @@ def _next_request(self) -> None:\n                     extra={\"spider\": self.spider},\n                 )\n             else:\n-                self.crawl(request)\n+                if isinstance(request, Request):\n+                    self.crawl(request)\n+                elif is_item(request):\n+                    self.scraper.slot.itemproc_size += 1\n+                    dfd = self.scraper.itemproc.process_item(\n+                        request, self.crawler.spider\n+                    )\n+                    dfd.addBoth(\n+                        self.scraper._itemproc_finished,\n+                        request,\n+                        f\"{self.crawler.spider.__class__.__name__}.start_requests\",\n+                        self.crawler.spider,\n+                    )",
      "comment": "Looks good to me.\r\n\r\nI wonder if maybe we should fallback to self.crawl, i.e. add else with self.crawl, to maintain backward compatibility. Edit: maybe do `if isinstance(\u2026, Request) or not is_item(\u2026): \u2026 else: \u2026`?\r\n\r\nI also wonder if the elif code could be wrapped into a method, if that way we can avoid any code duplication, but if there is no duplication to be saved, the way it is here looks fine to me.\r\n\r\nWe do need tests and to mention this (the ability to yield items) in the reference docs of the start_requests method.",
      "comment_id": 1658565672,
      "user": "Gallaecio",
      "created_at": "2024-06-28T11:30:26Z",
      "url": "https://github.com/scrapy/scrapy/pull/6417#discussion_r1658565672"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 6417,
      "file_path": "scrapy/core/engine.py",
      "line": 221,
      "side": "RIGHT",
      "diff_hunk": "@@ -205,7 +206,19 @@ def _next_request(self) -> None:\n                     extra={\"spider\": self.spider},\n                 )\n             else:\n-                self.crawl(request)\n+                if isinstance(request, Request):\n+                    self.crawl(request)\n+                elif is_item(request):\n+                    self.scraper.slot.itemproc_size += 1\n+                    dfd = self.scraper.itemproc.process_item(\n+                        request, self.crawler.spider\n+                    )\n+                    dfd.addBoth(\n+                        self.scraper._itemproc_finished,\n+                        request,\n+                        f\"{self.crawler.spider.__class__.__name__}.start_requests\",\n+                        self.crawler.spider,\n+                    )",
      "comment": "There is also process_start_requests in spider middlewares, at least its doc needs to be updated.",
      "comment_id": 1661893942,
      "user": "wRAR",
      "created_at": "2024-07-02T06:17:43Z",
      "url": "https://github.com/scrapy/scrapy/pull/6417#discussion_r1661893942"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 6417,
      "file_path": "tests/test_spidermiddleware.py",
      "line": 331,
      "side": "RIGHT",
      "diff_hunk": "@@ -328,12 +328,13 @@ def process_start_requests(self, start_requests, spider):\n class ProcessStartRequestsSimple(BaseAsyncSpiderMiddlewareTestCase):\n     \"\"\"process_start_requests tests for simple start_requests\"\"\"\n \n-    ITEM_TYPE = Request\n+    ITEM_TYPE = Union[Request, dict]",
      "comment": "Looks like this doesn't work on 3.8-3.9 because `isinstance()` can't use it. \r\n\r\nhttps://bugs.python.org/issue44529",
      "comment_id": 1724948863,
      "user": "wRAR",
      "created_at": "2024-08-21T12:15:33Z",
      "url": "https://github.com/scrapy/scrapy/pull/6417#discussion_r1724948863"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 6417,
      "file_path": "tests/test_spidermiddleware.py",
      "line": 331,
      "side": "RIGHT",
      "diff_hunk": "@@ -328,12 +328,13 @@ def process_start_requests(self, start_requests, spider):\n class ProcessStartRequestsSimple(BaseAsyncSpiderMiddlewareTestCase):\n     \"\"\"process_start_requests tests for simple start_requests\"\"\"\n \n-    ITEM_TYPE = Request\n+    ITEM_TYPE = Union[Request, dict]",
      "comment": "Changing this to tuple `ITEM_TYPE = (Request, dict)` resolve issues with `isinstance()` but it cause failing of `checks (3.8 typing-tests)`",
      "comment_id": 1725094814,
      "user": "GeorgeA92",
      "created_at": "2024-08-21T13:51:38Z",
      "url": "https://github.com/scrapy/scrapy/pull/6417#discussion_r1725094814"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 6417,
      "file_path": "scrapy/core/engine.py",
      "line": 221,
      "side": "RIGHT",
      "diff_hunk": "@@ -205,7 +206,19 @@ def _next_request(self) -> None:\n                     extra={\"spider\": self.spider},\n                 )\n             else:\n-                self.crawl(request)\n+                if isinstance(request, Request):\n+                    self.crawl(request)\n+                elif is_item(request):\n+                    self.scraper.slot.itemproc_size += 1\n+                    dfd = self.scraper.itemproc.process_item(\n+                        request, self.crawler.spider\n+                    )\n+                    dfd.addBoth(\n+                        self.scraper._itemproc_finished,\n+                        request,\n+                        f\"{self.crawler.spider.__class__.__name__}.start_requests\",\n+                        self.crawler.spider,\n+                    )",
      "comment": "> We do need tests and to mention this (the ability to yield items) in the reference docs of the start_requests method.\r\n\r\n> There is also process_start_requests in spider middlewares, at least its doc needs to be updated.\r\n\r\nAdded as result of https://github.com/scrapy/scrapy/pull/6417/commits/8f24f131a64914963c8d95d81f972087cd7f239d",
      "comment_id": 1725099688,
      "user": "GeorgeA92",
      "created_at": "2024-08-21T13:54:29Z",
      "url": "https://github.com/scrapy/scrapy/pull/6417#discussion_r1725099688"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 6417,
      "file_path": "tests/test_spidermiddleware.py",
      "line": 331,
      "side": "RIGHT",
      "diff_hunk": "@@ -328,12 +328,13 @@ def process_start_requests(self, start_requests, spider):\n class ProcessStartRequestsSimple(BaseAsyncSpiderMiddlewareTestCase):\n     \"\"\"process_start_requests tests for simple start_requests\"\"\"\n \n-    ITEM_TYPE = Request\n+    ITEM_TYPE = Union[Request, dict]",
      "comment": "Does it work if you change the typing tests to 3.9? If so, we can expedite https://github.com/scrapy/scrapy/issues/6466.",
      "comment_id": 1725258112,
      "user": "Gallaecio",
      "created_at": "2024-08-21T15:09:34Z",
      "url": "https://github.com/scrapy/scrapy/pull/6417#discussion_r1725258112"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 6417,
      "file_path": "tests/test_spidermiddleware.py",
      "line": 331,
      "side": "RIGHT",
      "diff_hunk": "@@ -328,12 +328,13 @@ def process_start_requests(self, start_requests, spider):\n class ProcessStartRequestsSimple(BaseAsyncSpiderMiddlewareTestCase):\n     \"\"\"process_start_requests tests for simple start_requests\"\"\"\n \n-    ITEM_TYPE = Request\n+    ITEM_TYPE = Union[Request, dict]",
      "comment": "I doubt that, `isinstance()` supporting a tuple is unique to it, you cannot use a tuple instead of a union.",
      "comment_id": 1725283509,
      "user": "wRAR",
      "created_at": "2024-08-21T15:19:07Z",
      "url": "https://github.com/scrapy/scrapy/pull/6417#discussion_r1725283509"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 6417,
      "file_path": "tests/test_spidermiddleware.py",
      "line": 331,
      "side": "RIGHT",
      "diff_hunk": "@@ -328,12 +328,13 @@ def process_start_requests(self, start_requests, spider):\n class ProcessStartRequestsSimple(BaseAsyncSpiderMiddlewareTestCase):\n     \"\"\"process_start_requests tests for simple start_requests\"\"\"\n \n-    ITEM_TYPE = Request\n+    ITEM_TYPE = Union[Request, dict]",
      "comment": "(I haven't looked at this code yet but I suspect we need to rewrite it, e.g. by rewriting the assert)",
      "comment_id": 1725284943,
      "user": "wRAR",
      "created_at": "2024-08-21T15:19:51Z",
      "url": "https://github.com/scrapy/scrapy/pull/6417#discussion_r1725284943"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 6417,
      "file_path": "tests/test_spidermiddleware.py",
      "line": 331,
      "side": "RIGHT",
      "diff_hunk": "@@ -328,12 +328,13 @@ def process_start_requests(self, start_requests, spider):\n class ProcessStartRequestsSimple(BaseAsyncSpiderMiddlewareTestCase):\n     \"\"\"process_start_requests tests for simple start_requests\"\"\"\n \n-    ITEM_TYPE = Request\n+    ITEM_TYPE = Union[Request, dict]",
      "comment": "> I doubt that, isinstance() supporting a tuple is unique to it, you cannot use a tuple instead of a union.\r\n\r\nIt is directly mentioned on python docs that it support tuples as argument\r\nhttps://docs.python.org/3.8/library/functions.html?highlight=tuple#isinstance\r\nhttps://docs.python.org/3.9/library/functions.html?highlight=tuple#isinstance\r\nhttps://docs.python.org/3.10/library/functions.html?highlight=tuple#isinstance\r\nhttps://docs.python.org/3.11/library/functions.html?highlight=tuple#isinstance\r\n\r\nbuilt in `issubclass` - also supports tuple for its checks as well as `isinstance` so it is not unique.\r\nAs it is directly mentioned on docs - I think it's valid to use tuple here.",
      "comment_id": 1725320566,
      "user": "GeorgeA92",
      "created_at": "2024-08-21T15:41:16Z",
      "url": "https://github.com/scrapy/scrapy/pull/6417#discussion_r1725320566"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 6417,
      "file_path": "tests/test_spidermiddleware.py",
      "line": 331,
      "side": "RIGHT",
      "diff_hunk": "@@ -328,12 +328,13 @@ def process_start_requests(self, start_requests, spider):\n class ProcessStartRequestsSimple(BaseAsyncSpiderMiddlewareTestCase):\n     \"\"\"process_start_requests tests for simple start_requests\"\"\"\n \n-    ITEM_TYPE = Request\n+    ITEM_TYPE = Union[Request, dict]",
      "comment": "I've meant that you can use a tuple for isinstance() but not for type hints. But I've now checked the actual failure, it's \"Incompatible types in assignment (expression has type \"Tuple[Type[Request], Type[Dict[Any, Any]]]\", base class \"BaseAsyncSpiderMiddlewareTestCase\" defined the type as \"type\")\" and it should be possible to solve it by updating the type hint of `BaseAsyncSpiderMiddlewareTestCase.ITEM_TYPE` to e.g. `Union[type, Union]` or something like that.",
      "comment_id": 1725326829,
      "user": "wRAR",
      "created_at": "2024-08-21T15:45:46Z",
      "url": "https://github.com/scrapy/scrapy/pull/6417#discussion_r1725326829"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 6417,
      "file_path": "scrapy/core/scraper.py",
      "line": 332,
      "side": "RIGHT",
      "diff_hunk": "@@ -333,6 +329,19 @@ def _process_spidermw_output(\n             )\n         return None\n \n+    def start_itemproc(self, item, *, response: Optional[Response]):",
      "comment": "```suggestion\r\n    def start_itemproc(self, item, *, response: Optional[Response]) -> Deferred[Any]:\r\n```",
      "comment_id": 1729170156,
      "user": "wRAR",
      "created_at": "2024-08-23T15:39:52Z",
      "url": "https://github.com/scrapy/scrapy/pull/6417#discussion_r1729170156"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 6469,
      "file_path": "scrapy/contracts/default.py",
      "line": 39,
      "side": "RIGHT",
      "diff_hunk": "@@ -35,6 +35,20 @@ def adjust_request_args(self, args: Dict[str, Any]) -> Dict[str, Any]:\n         return args\n \n \n+class MetadataContract(Contract):\n+    \"\"\"Contract to key metadata arguments for the request.",
      "comment": "```suggestion\r\n    \"\"\"Contract to set metadata arguments for the request.\r\n```",
      "comment_id": 1732574477,
      "user": "Laerte",
      "created_at": "2024-08-27T10:24:53Z",
      "url": "https://github.com/scrapy/scrapy/pull/6469#discussion_r1732574477"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 6460,
      "file_path": "scrapy/pipelines/media.py",
      "line": 214,
      "side": "RIGHT",
      "diff_hunk": "@@ -211,7 +211,7 @@ def _cache_result_and_execute_waiters(\n             # minimize cached information for failure\n             result.cleanFailure()\n             result.frames = []\n-            result.stack = None\n+            result.stack = []",
      "comment": "This started producing a mypy error with Twisted 24.7.0 so we likely need to copy this change to the 2.11 branch.",
      "comment_id": 1713029223,
      "user": "wRAR",
      "created_at": "2024-08-11T17:40:10Z",
      "url": "https://github.com/scrapy/scrapy/pull/6460#discussion_r1713029223"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 6434,
      "file_path": "scrapy/extensions/closespider.py",
      "line": 78,
      "side": "RIGHT",
      "diff_hunk": "@@ -60,6 +64,19 @@ def __init__(self, crawler: Crawler):\n             crawler.signals.connect(\n                 self.item_scraped_no_item, signal=signals.item_scraped\n             )\n+        if self.close_on.get(\"pagecount_no_item\"):\n+            if self.page_count not in dispatcher.getReceivers(\n+                signal=signals.response_received\n+            ):\n+                crawler.signals.connect(\n+                    self.page_count, signal=signals.response_received\n+                )\n+\n+            if self.item_scraped not in dispatcher.getReceivers(\n+                signal=signals.item_scraped\n+            ):\n+                crawler.signals.connect(self.item_scraped, signal=signals.item_scraped)",
      "comment": "What if instead of using dispatcher you extend the `if` statements above?\r\n\r\ne.g.\r\n\r\n```python\r\n        if self.close_on.get(\"pagecount\") or self.close_on.get(\"pagecount_no_item\"):\r\n            crawler.signals.connect(self.page_count, signal=signals.response_received)\r\n```",
      "comment_id": 1671741929,
      "user": "Gallaecio",
      "created_at": "2024-07-10T07:15:29Z",
      "url": "https://github.com/scrapy/scrapy/pull/6434#discussion_r1671741929"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 6434,
      "file_path": "scrapy/extensions/closespider.py",
      "line": 97,
      "side": "RIGHT",
      "diff_hunk": "@@ -74,9 +91,16 @@ def error_count(self, failure: Failure, response: Response, spider: Spider) -> N\n \n     def page_count(self, response: Response, request: Request, spider: Spider) -> None:\n         self.counter[\"pagecount\"] += 1\n+        self.counter[\"pagecount_since_last_item\"] += 1\n         if self.counter[\"pagecount\"] == self.close_on[\"pagecount\"]:\n             assert self.crawler.engine\n             self.crawler.engine.close_spider(spider, \"closespider_pagecount\")",
      "comment": "Maybe add an early return at the end of this `if`. No need to check if the condition below has been met if this one has.",
      "comment_id": 1671744827,
      "user": "Gallaecio",
      "created_at": "2024-07-10T07:17:53Z",
      "url": "https://github.com/scrapy/scrapy/pull/6434#discussion_r1671744827"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 6434,
      "file_path": "tests/test_closespider.py",
      "line": 48,
      "side": "RIGHT",
      "diff_hunk": "@@ -34,6 +34,19 @@ def test_closespider_pagecount(self):\n         pagecount = crawler.stats.get_value(\"response_received_count\")\n         self.assertTrue(pagecount >= close_on)\n \n+    @defer.inlineCallbacks\n+    def test_closespider_pagecount_no_item(self):\n+        close_on = 5\n+        crawler = get_crawler(\n+            FollowAllSpider,\n+            {\"CLOSESPIDER_PAGECOUNT_NO_ITEM\": close_on},\n+        )\n+        yield crawler.crawl(mockserver=self.mockserver)\n+        reason = crawler.spider.meta[\"close_reason\"]\n+        self.assertEqual(reason, \"closespider_pagecount_no_item\")\n+        pagecount = crawler.stats.get_value(\"response_received_count\")\n+        self.assertTrue(pagecount >= close_on)",
      "comment": "This does not test what makes this feature different from `CLOSESPIDER_PAGECOUNT`, though. Maybe you could implement an alternative to `FollowAllSpider` that allows testing that difference, i.e. build a test that would fail with `CLOSESPIDER_PAGECOUNT`.",
      "comment_id": 1671753436,
      "user": "Gallaecio",
      "created_at": "2024-07-10T07:21:24Z",
      "url": "https://github.com/scrapy/scrapy/pull/6434#discussion_r1671753436"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 6432,
      "file_path": "scrapy/extensions/telnet.py",
      "line": 53,
      "side": "LEFT",
      "diff_hunk": "@@ -50,11 +42,7 @@ class TelnetConsole(protocol.ServerFactory):\n     def __init__(self, crawler: Crawler):\n         if not crawler.settings.getbool(\"TELNETCONSOLE_ENABLED\"):\n             raise NotConfigured\n-        if not TWISTED_CONCH_AVAILABLE:",
      "comment": "This special handling was added in #1161 because `twisted.conch` wasn't ported to Python 3 until later, which is no longer relevant, and it was useful again in #3326 when that module was for some time incompatible with Python 3.7. It's a coincidence that this handling was useful twice, and I don't think it should be kept even if it will be useful in the future, as that can happen with any other optional dependency module.",
      "comment_id": 1668948101,
      "user": "wRAR",
      "created_at": "2024-07-08T16:30:42Z",
      "url": "https://github.com/scrapy/scrapy/pull/6432#discussion_r1668948101"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 6274,
      "file_path": "scrapy/spiders/__init__.py",
      "line": 29,
      "side": "RIGHT",
      "diff_hunk": "@@ -17,12 +17,17 @@\n from scrapy.utils.url import url_is_from_spider\n \n if TYPE_CHECKING:\n+    from collections.abc import Callable\n+\n+    # typing.Concatenate requires Python 3.10\n     # typing.Self requires Python 3.11\n-    from typing_extensions import Self\n+    from typing_extensions import Concatenate, Self\n \n     from scrapy.crawler import Crawler\n     from scrapy.settings import BaseSettings\n \n+    CallbackT = Callable[Concatenate[Response, ...], Any]",
      "comment": "This could be useful in other places as it's a general type for a spider callback. I didn't think about that further though.",
      "comment_id": 1515003148,
      "user": "wRAR",
      "created_at": "2024-03-06T19:03:38Z",
      "url": "https://github.com/scrapy/scrapy/pull/6274#discussion_r1515003148"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 6274,
      "file_path": "scrapy/spiders/__init__.py",
      "line": 29,
      "side": "RIGHT",
      "diff_hunk": "@@ -17,12 +17,17 @@\n from scrapy.utils.url import url_is_from_spider\n \n if TYPE_CHECKING:\n+    from collections.abc import Callable\n+\n+    # typing.Concatenate requires Python 3.10\n     # typing.Self requires Python 3.11\n-    from typing_extensions import Self\n+    from typing_extensions import Concatenate, Self\n \n     from scrapy.crawler import Crawler\n     from scrapy.settings import BaseSettings\n \n+    CallbackT = Callable[Concatenate[Response, ...], Any]",
      "comment": "Looks like we can't, probably because of wrong covariance when assigning a specific callback to a request, I need to investigate this separately.",
      "comment_id": 1597495523,
      "user": "wRAR",
      "created_at": "2024-05-11T19:18:54Z",
      "url": "https://github.com/scrapy/scrapy/pull/6274#discussion_r1597495523"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 6143,
      "file_path": "scrapy/downloadermiddlewares/redirect.py",
      "line": 30,
      "side": "RIGHT",
      "diff_hunk": "@@ -27,6 +27,7 @@ def _build_redirect_request(\n     redirect_request = source_request.replace(\n         url=url,\n         **kwargs,\n+        cls=None,",
      "comment": "Without this line the type of `redirect_request` is inferred to be `Any`.",
      "comment_id": 1390246825,
      "user": "wRAR",
      "created_at": "2023-11-11T16:01:50Z",
      "url": "https://github.com/scrapy/scrapy/pull/6143#discussion_r1390246825"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 6143,
      "file_path": "scrapy/downloadermiddlewares/redirect.py",
      "line": 30,
      "side": "RIGHT",
      "diff_hunk": "@@ -27,6 +27,7 @@ def _build_redirect_request(\n     redirect_request = source_request.replace(\n         url=url,\n         **kwargs,\n+        cls=None,",
      "comment": "Could you please add a test for this case? I guess it's `**kwargs` handling?",
      "comment_id": 1422439287,
      "user": "kmike",
      "created_at": "2023-12-11T13:03:02Z",
      "url": "https://github.com/scrapy/scrapy/pull/6143#discussion_r1422439287"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 6143,
      "file_path": "scrapy/downloadermiddlewares/redirect.py",
      "line": 30,
      "side": "RIGHT",
      "diff_hunk": "@@ -27,6 +27,7 @@ def _build_redirect_request(\n     redirect_request = source_request.replace(\n         url=url,\n         **kwargs,\n+        cls=None,",
      "comment": "I think it's because it cannot know that `kwargs` passed to `_build_redirect_request` doesn't contain `cls`.",
      "comment_id": 1422845595,
      "user": "wRAR",
      "created_at": "2023-12-11T17:25:21Z",
      "url": "https://github.com/scrapy/scrapy/pull/6143#discussion_r1422845595"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 6143,
      "file_path": "scrapy/downloadermiddlewares/redirect.py",
      "line": 30,
      "side": "RIGHT",
      "diff_hunk": "@@ -27,6 +27,7 @@ def _build_redirect_request(\n     redirect_request = source_request.replace(\n         url=url,\n         **kwargs,\n+        cls=None,",
      "comment": "If kwargs are passed, what's the reveal_type of the result",
      "comment_id": 1423760804,
      "user": "kmike",
      "created_at": "2023-12-12T10:04:46Z",
      "url": "https://github.com/scrapy/scrapy/pull/6143#discussion_r1423760804"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 6143,
      "file_path": "scrapy/downloadermiddlewares/redirect.py",
      "line": 30,
      "side": "RIGHT",
      "diff_hunk": "@@ -27,6 +27,7 @@ def _build_redirect_request(\n     redirect_request = source_request.replace(\n         url=url,\n         **kwargs,\n+        cls=None,",
      "comment": "I've added tests that check that the result is `Any` unless `cls` was also passed.",
      "comment_id": 1432645705,
      "user": "wRAR",
      "created_at": "2023-12-20T12:19:06Z",
      "url": "https://github.com/scrapy/scrapy/pull/6143#discussion_r1432645705"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 6385,
      "file_path": "scrapy/extensions/httpcache.py",
      "line": 373,
      "side": "RIGHT",
      "diff_hunk": "@@ -368,11 +370,12 @@ def store_response(\n         with self._open(rpath / \"pickled_meta\", \"wb\") as f:\n             pickle.dump(metadata, f, protocol=4)\n         with self._open(rpath / \"response_headers\", \"wb\") as f:\n-            f.write(headers_dict_to_raw(response.headers))\n+            # headers_dict_to_raw() needs a better type hint",
      "comment": "This needs to be improved in w3lib, I'll do that separately.",
      "comment_id": 1622744846,
      "user": "wRAR",
      "created_at": "2024-05-31T17:27:42Z",
      "url": "https://github.com/scrapy/scrapy/pull/6385#discussion_r1622744846"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 6391,
      "file_path": "scrapy/utils/iterators.py",
      "line": 190,
      "side": "RIGHT",
      "diff_hunk": "@@ -184,10 +181,13 @@ def csviter(\n     quotechar is the character used to enclosure fields on the given obj.\n     \"\"\"\n \n-    encoding = obj.encoding if isinstance(obj, TextResponse) else encoding or \"utf-8\"\n-\n-    def row_to_unicode(row_: Iterable) -> List[str]:\n-        return [to_unicode(field, encoding) for field in row_]\n+    if encoding is not None:\n+        warn(\n+            \"The encoding argument of csviter() is ignored and will be removed\"\n+            \" in a future Scrapy version.\",\n+            category=ScrapyDeprecationWarning,\n+            stacklevel=2,\n+        )",
      "comment": "Shouldn\u2019t we keep the encoding functionality until we remove the parameter?",
      "comment_id": 1629849238,
      "user": "Gallaecio",
      "created_at": "2024-06-06T16:33:16Z",
      "url": "https://github.com/scrapy/scrapy/pull/6391#discussion_r1629849238"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 6391,
      "file_path": "scrapy/utils/iterators.py",
      "line": 190,
      "side": "RIGHT",
      "diff_hunk": "@@ -184,10 +181,13 @@ def csviter(\n     quotechar is the character used to enclosure fields on the given obj.\n     \"\"\"\n \n-    encoding = obj.encoding if isinstance(obj, TextResponse) else encoding or \"utf-8\"\n-\n-    def row_to_unicode(row_: Iterable) -> List[str]:\n-        return [to_unicode(field, encoding) for field in row_]\n+    if encoding is not None:\n+        warn(\n+            \"The encoding argument of csviter() is ignored and will be removed\"\n+            \" in a future Scrapy version.\",\n+            category=ScrapyDeprecationWarning,\n+            stacklevel=2,\n+        )",
      "comment": "The existing encoding functionality requires getting bytes in row_to_unicode(), which can't happen as all this code operates on strings (after `_body_or_str(obj, unicode=True)` converts the input with a hardcoded utf-8 encoding, anyway), so it was a no-op.",
      "comment_id": 1629881886,
      "user": "wRAR",
      "created_at": "2024-06-06T16:53:19Z",
      "url": "https://github.com/scrapy/scrapy/pull/6391#discussion_r1629881886"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 6391,
      "file_path": "scrapy/utils/iterators.py",
      "line": 190,
      "side": "RIGHT",
      "diff_hunk": "@@ -184,10 +181,13 @@ def csviter(\n     quotechar is the character used to enclosure fields on the given obj.\n     \"\"\"\n \n-    encoding = obj.encoding if isinstance(obj, TextResponse) else encoding or \"utf-8\"\n-\n-    def row_to_unicode(row_: Iterable) -> List[str]:\n-        return [to_unicode(field, encoding) for field in row_]\n+    if encoding is not None:\n+        warn(\n+            \"The encoding argument of csviter() is ignored and will be removed\"\n+            \" in a future Scrapy version.\",\n+            category=ScrapyDeprecationWarning,\n+            stacklevel=2,\n+        )",
      "comment": "AFAICS it was for the Py2 code path where `csv_r` produced bytes.",
      "comment_id": 1629882793,
      "user": "wRAR",
      "created_at": "2024-06-06T16:53:53Z",
      "url": "https://github.com/scrapy/scrapy/pull/6391#discussion_r1629882793"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 6371,
      "file_path": "scrapy/contracts/__init__.py",
      "line": 123,
      "side": "RIGHT",
      "diff_hunk": "@@ -96,21 +112,26 @@ def tested_methods_from_spidercls(self, spidercls):\n \n         return methods\n \n-    def extract_contracts(self, method):\n-        contracts = []\n+    def extract_contracts(self, method: Callable) -> List[Contract]:\n+        contracts: List[Contract] = []\n+        assert method.__doc__ is not None\n         for line in method.__doc__.split(\"\\n\"):\n             line = line.strip()\n \n             if line.startswith(\"@\"):\n-                name, args = re.match(r\"@(\\w+)\\s*(.*)\", line).groups()\n+                m = re.match(r\"@(\\w+)\\s*(.*)\", line)\n+                assert m is not None",
      "comment": "It could be `None`, though. Should we open a ticket to update it, e.g. to raise an exception about an invalid contract line being found?",
      "comment_id": 1616817778,
      "user": "Gallaecio",
      "created_at": "2024-05-28T08:30:14Z",
      "url": "https://github.com/scrapy/scrapy/pull/6371#discussion_r1616817778"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 6371,
      "file_path": "scrapy/contracts/__init__.py",
      "line": 123,
      "side": "RIGHT",
      "diff_hunk": "@@ -96,21 +112,26 @@ def tested_methods_from_spidercls(self, spidercls):\n \n         return methods\n \n-    def extract_contracts(self, method):\n-        contracts = []\n+    def extract_contracts(self, method: Callable) -> List[Contract]:\n+        contracts: List[Contract] = []\n+        assert method.__doc__ is not None\n         for line in method.__doc__.split(\"\\n\"):\n             line = line.strip()\n \n             if line.startswith(\"@\"):\n-                name, args = re.match(r\"@(\\w+)\\s*(.*)\", line).groups()\n+                m = re.match(r\"@(\\w+)\\s*(.*)\", line)\n+                assert m is not None",
      "comment": "@wRAR @Gallaecio Should we raise an exception or just pass the unmatched regex using `continue` ?",
      "comment_id": 1624285641,
      "user": "suvanbanerjee",
      "created_at": "2024-06-03T11:50:22Z",
      "url": "https://github.com/scrapy/scrapy/pull/6371#discussion_r1624285641"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 6371,
      "file_path": "scrapy/contracts/__init__.py",
      "line": 123,
      "side": "RIGHT",
      "diff_hunk": "@@ -96,21 +112,26 @@ def tested_methods_from_spidercls(self, spidercls):\n \n         return methods\n \n-    def extract_contracts(self, method):\n-        contracts = []\n+    def extract_contracts(self, method: Callable) -> List[Contract]:\n+        contracts: List[Contract] = []\n+        assert method.__doc__ is not None\n         for line in method.__doc__.split(\"\\n\"):\n             line = line.strip()\n \n             if line.startswith(\"@\"):\n-                name, args = re.match(r\"@(\\w+)\\s*(.*)\", line).groups()\n+                m = re.match(r\"@(\\w+)\\s*(.*)\", line)\n+                assert m is not None",
      "comment": "As I said in #6383, \"I think we should just skip lines that don't match.\"",
      "comment_id": 1624297078,
      "user": "wRAR",
      "created_at": "2024-06-03T12:00:00Z",
      "url": "https://github.com/scrapy/scrapy/pull/6371#discussion_r1624297078"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 6381,
      "file_path": "scrapy/spidermiddlewares/referer.py",
      "line": 327,
      "side": "RIGHT",
      "diff_hunk": "@@ -323,15 +323,17 @@ def _load_policy_class(\n     try:\n         return cast(Type[ReferrerPolicy], load_object(policy))\n     except ValueError:\n-        try:\n-            return _policy_classes[policy.lower()]\n-        except KeyError:\n-            msg = f\"Could not load referrer policy {policy!r}\"\n-            if not warning_only:\n-                raise RuntimeError(msg)\n-            else:\n-                warnings.warn(msg, RuntimeWarning)\n-                return None\n+        tokens = [token.strip() for token in policy.lower().split(\",\")]\n+        for token in tokens[::-1]:",
      "comment": "For future reference, it was not obvious to me why we are picking the last known policy instead of the first one.\r\n\r\n```suggestion\r\n        # https://www.w3.org/TR/referrer-policy/#parse-referrer-policy-from-header\r\n        for token in tokens[::-1]:\r\n```",
      "comment_id": 1618557742,
      "user": "Gallaecio",
      "created_at": "2024-05-29T09:30:32Z",
      "url": "https://github.com/scrapy/scrapy/pull/6381#discussion_r1618557742"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 6368,
      "file_path": "scrapy/pipelines/media.py",
      "line": 227,
      "side": "LEFT",
      "diff_hunk": "@@ -197,35 +197,32 @@ def _cache_result_and_execute_waiters(self, result, fp, info):\n             defer_result(result).chainDeferred(wad)\n \n     # Overridable Interface\n+    @abstractmethod\n     def media_to_download(self, request, info, *, item=None):\n         \"\"\"Check request before starting download\"\"\"\n-        pass\n+        raise NotImplementedError()\n \n+    @abstractmethod\n     def get_media_requests(self, item, info):\n         \"\"\"Returns the media requests to download\"\"\"\n-        pass\n+        raise NotImplementedError()\n \n+    @abstractmethod\n     def media_downloaded(self, response, request, info, *, item=None):\n         \"\"\"Handler for success downloads\"\"\"\n-        return response\n+        raise NotImplementedError()\n \n+    @abstractmethod\n     def media_failed(self, failure, request, info):\n         \"\"\"Handler for failed downloads\"\"\"\n-        return failure\n+        raise NotImplementedError()\n \n+    @abstractmethod\n     def item_completed(self, results, item, info):\n         \"\"\"Called per item when all media requests has been processed\"\"\"\n-        if self.LOG_FAILED_RESULTS:\n-            for ok, value in results:\n-                if not ok:\n-                    logger.error(\n-                        \"%(class)s found errors processing %(item)s\",\n-                        {\"class\": self.__class__.__name__, \"item\": item},\n-                        exc_info=failure_to_exc_info(value),\n-                        extra={\"spider\": info.spider},\n-                    )\n-        return item",
      "comment": "I think this (and the tests for it) should stay, in case some 3rd-party subclasses call super() for it (as bundled ones don't).",
      "comment_id": 1606070144,
      "user": "wRAR",
      "created_at": "2024-05-19T17:10:19Z",
      "url": "https://github.com/scrapy/scrapy/pull/6368#discussion_r1606070144"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 6368,
      "file_path": "tests/test_pipeline_media.py",
      "line": 213,
      "side": "LEFT",
      "diff_hunk": "@@ -176,257 +143,8 @@ def test_should_remove_req_res_references_before_caching_the_results(self):\n         self.assertIsNone(context)\n \n \n-class MockedMediaPipeline(MediaPipeline):\n-    def __init__(self, *args, **kwargs):\n-        super().__init__(*args, **kwargs)\n-        self._mockcalled = []\n-\n-    def download(self, request, info):\n-        self._mockcalled.append(\"download\")\n-        return super().download(request, info)\n-\n-    def media_to_download(self, request, info, *, item=None):\n-        self._mockcalled.append(\"media_to_download\")\n-        if \"result\" in request.meta:\n-            return request.meta.get(\"result\")\n-        return super().media_to_download(request, info)\n-\n-    def get_media_requests(self, item, info):\n-        self._mockcalled.append(\"get_media_requests\")\n-        return item.get(\"requests\")\n-\n-    def media_downloaded(self, response, request, info, *, item=None):\n-        self._mockcalled.append(\"media_downloaded\")\n-        return super().media_downloaded(response, request, info)\n-\n-    def media_failed(self, failure, request, info):\n-        self._mockcalled.append(\"media_failed\")\n-        return super().media_failed(failure, request, info)\n-\n-    def item_completed(self, results, item, info):\n-        self._mockcalled.append(\"item_completed\")\n-        item = super().item_completed(results, item, info)\n-        item[\"results\"] = results\n-        return item\n-\n-\n-class MediaPipelineTestCase(BaseMediaPipelineTestCase):",
      "comment": "On the first glance this, or maybe parts of this, looks like tests for the `MediaPipeline` machinery so they need to stay (unless the same tests are also in some other class/file).",
      "comment_id": 1606070394,
      "user": "wRAR",
      "created_at": "2024-05-19T17:11:55Z",
      "url": "https://github.com/scrapy/scrapy/pull/6368#discussion_r1606070394"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 6368,
      "file_path": "tests/test_pipeline_media.py",
      "line": 213,
      "side": "LEFT",
      "diff_hunk": "@@ -176,257 +143,8 @@ def test_should_remove_req_res_references_before_caching_the_results(self):\n         self.assertIsNone(context)\n \n \n-class MockedMediaPipeline(MediaPipeline):\n-    def __init__(self, *args, **kwargs):\n-        super().__init__(*args, **kwargs)\n-        self._mockcalled = []\n-\n-    def download(self, request, info):\n-        self._mockcalled.append(\"download\")\n-        return super().download(request, info)\n-\n-    def media_to_download(self, request, info, *, item=None):\n-        self._mockcalled.append(\"media_to_download\")\n-        if \"result\" in request.meta:\n-            return request.meta.get(\"result\")\n-        return super().media_to_download(request, info)\n-\n-    def get_media_requests(self, item, info):\n-        self._mockcalled.append(\"get_media_requests\")\n-        return item.get(\"requests\")\n-\n-    def media_downloaded(self, response, request, info, *, item=None):\n-        self._mockcalled.append(\"media_downloaded\")\n-        return super().media_downloaded(response, request, info)\n-\n-    def media_failed(self, failure, request, info):\n-        self._mockcalled.append(\"media_failed\")\n-        return super().media_failed(failure, request, info)\n-\n-    def item_completed(self, results, item, info):\n-        self._mockcalled.append(\"item_completed\")\n-        item = super().item_completed(results, item, info)\n-        item[\"results\"] = results\n-        return item\n-\n-\n-class MediaPipelineTestCase(BaseMediaPipelineTestCase):",
      "comment": "@wRAR I\u2019ve kept required tests. Let me know if im missing something ",
      "comment_id": 1607035571,
      "user": "kumar-sanchay",
      "created_at": "2024-05-20T17:09:59Z",
      "url": "https://github.com/scrapy/scrapy/pull/6368#discussion_r1607035571"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 6368,
      "file_path": "tests/test_pipeline_media.py",
      "line": 36,
      "side": "RIGHT",
      "diff_hunk": "@@ -35,8 +31,26 @@ def _mocked_download_func(request, info):\n     return response() if callable(response) else response\n \n \n+class UserDefinedPipeline(MediaPipeline):",
      "comment": "I wouldn't reuse the old MediaPipeline implementations here but followed the expected return values. So:\r\n\r\n* media_downloaded() should return {} (technically, that's also wrong but better than returning `response`)\r\n* file_path() should return ''\r\n\r\nOthers I think are fine.",
      "comment_id": 1607146350,
      "user": "wRAR",
      "created_at": "2024-05-20T18:49:45Z",
      "url": "https://github.com/scrapy/scrapy/pull/6368#discussion_r1607146350"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 6368,
      "file_path": "tests/test_pipeline_media.py",
      "line": 75,
      "side": "LEFT",
      "diff_hunk": "@@ -54,54 +68,6 @@ def tearDown(self):\n             if not name.startswith(\"_\"):\n                 disconnect_all(signal)\n \n-    def test_default_media_to_download(self):\n-        request = Request(\"http://url\")\n-        assert self.pipe.media_to_download(request, self.info) is None\n-\n-    def test_default_get_media_requests(self):\n-        item = {\"name\": \"name\"}\n-        assert self.pipe.get_media_requests(item, self.info) is None\n-\n-    def test_default_media_downloaded(self):\n-        request = Request(\"http://url\")\n-        response = Response(\"http://url\", body=b\"\")\n-        assert self.pipe.media_downloaded(response, request, self.info) is response\n-\n-    def test_default_media_failed(self):\n-        request = Request(\"http://url\")\n-        fail = Failure(Exception())\n-        assert self.pipe.media_failed(fail, request, self.info) is fail\n-\n-    def test_default_item_completed(self):",
      "comment": "Ah yes you are right ! \r\nStill trying to understand the project :)",
      "comment_id": 1609232505,
      "user": "kumar-sanchay",
      "created_at": "2024-05-22T04:13:17Z",
      "url": "https://github.com/scrapy/scrapy/pull/6368#discussion_r1609232505"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 6363,
      "file_path": "tests/test_pipeline_crawl.py",
      "line": 238,
      "side": "RIGHT",
      "diff_hunk": "@@ -217,6 +217,25 @@ def file_path(self, request, response=None, info=None, *, item=None):\n             )\n         self.assertIn(\"ZeroDivisionError\", str(log))\n \n+        class ExceptionRaisingMediaPipeline(cls):\n+            def file_path(self, request, response=None, info=None, *, item=None):\n+                return 1 / 0\n+\n+        settings = {\n+            **self.settings,\n+            \"ITEM_PIPELINES\": {ExceptionRaisingMediaPipeline: 1},\n+        }\n+        runner = CrawlerRunner(settings)\n+        crawler = self._create_crawler(MediaDownloadSpider, runner=runner)\n+        with LogCapture() as log:\n+            yield crawler.crawl(\n+                self.mockserver.url(\"/files/images/\"),\n+                media_key=self.media_key,\n+                media_urls_key=self.media_urls_key,\n+                mockserver=self.mockserver,\n+            )\n+        self.assertIn(\"ZeroDivisionError\", str(log))\n+",
      "comment": "Merge error? This should be already present in master (#5068)",
      "comment_id": 1600132632,
      "user": "wRAR",
      "created_at": "2024-05-14T14:19:57Z",
      "url": "https://github.com/scrapy/scrapy/pull/6363#discussion_r1600132632"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 6324,
      "file_path": "scrapy/spiders/__init__.py",
      "line": 48,
      "side": "RIGHT",
      "diff_hunk": "@@ -42,9 +43,9 @@ def __init__(self, name: Optional[str] = None, **kwargs: Any):\n             self.start_urls: List[str] = []\n \n     @property\n-    def logger(self) -> logging.LoggerAdapter:\n+    def logger(self) -> SpiderLoggerAdapter:\n         logger = logging.getLogger(self.name)\n-        return logging.LoggerAdapter(logger, {\"spider\": self})\n+        return SpiderLoggerAdapter(logger, {\"spider\": self})",
      "comment": "```suggestion\r\n        return SpiderLoggerAdapter(logger, {\"spider\": self.name})\r\n```\r\nMaybe also change `self` to `self.name`? So we get actual spider name in logs instead of `<Spider 'spider_name' at 0x1b2fc089580>`.\r\n\r\nProbably not the best idea since it's gonna change current behavior\r\n",
      "comment_id": 1592787002,
      "user": "bloodforcream",
      "created_at": "2024-05-07T16:42:59Z",
      "url": "https://github.com/scrapy/scrapy/pull/6324#discussion_r1592787002"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 6324,
      "file_path": "scrapy/spiders/__init__.py",
      "line": 48,
      "side": "RIGHT",
      "diff_hunk": "@@ -42,9 +43,9 @@ def __init__(self, name: Optional[str] = None, **kwargs: Any):\n             self.start_urls: List[str] = []\n \n     @property\n-    def logger(self) -> logging.LoggerAdapter:\n+    def logger(self) -> SpiderLoggerAdapter:\n         logger = logging.getLogger(self.name)\n-        return logging.LoggerAdapter(logger, {\"spider\": self})\n+        return SpiderLoggerAdapter(logger, {\"spider\": self})",
      "comment": "> Probably not the best idea since it's gonna change current behavior\r\n\r\nYeah",
      "comment_id": 1596397550,
      "user": "wRAR",
      "created_at": "2024-05-10T07:49:45Z",
      "url": "https://github.com/scrapy/scrapy/pull/6324#discussion_r1596397550"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 6341,
      "file_path": "scrapy/core/downloader/handlers/http11.py",
      "line": 158,
      "side": "RIGHT",
      "diff_hunk": "@@ -123,83 +127,88 @@ class TunnelingTCP4ClientEndpoint(TCP4ClientEndpoint):\n \n     def __init__(\n         self,\n-        reactor,\n-        host,\n-        port,\n-        proxyConf,\n-        contextFactory,\n-        timeout=30,\n-        bindAddress=None,\n+        reactor: ReactorBase,\n+        host: str,\n+        port: int,\n+        proxyConf: Tuple[str, int, Optional[bytes]],\n+        contextFactory: IPolicyForHTTPS,\n+        timeout: float = 30,\n+        bindAddress: Optional[Tuple[str, int]] = None,\n     ):\n         proxyHost, proxyPort, self._proxyAuthHeader = proxyConf\n         super().__init__(reactor, proxyHost, proxyPort, timeout, bindAddress)\n-        self._tunnelReadyDeferred = defer.Deferred()\n-        self._tunneledHost = host\n-        self._tunneledPort = port\n-        self._contextFactory = contextFactory\n-        self._connectBuffer = bytearray()\n+        self._tunnelReadyDeferred: Deferred = Deferred()\n+        self._tunneledHost: str = host\n+        self._tunneledPort: int = port\n+        self._contextFactory: IPolicyForHTTPS = contextFactory\n+        self._connectBuffer: bytearray = bytearray()\n \n-    def requestTunnel(self, protocol):\n+    def requestTunnel(self, protocol: Protocol) -> Protocol:\n         \"\"\"Asks the proxy to open a tunnel.\"\"\"\n+        assert protocol.transport\n         tunnelReq = tunnel_request_data(\n             self._tunneledHost, self._tunneledPort, self._proxyAuthHeader\n         )\n         protocol.transport.write(tunnelReq)\n         self._protocolDataReceived = protocol.dataReceived\n-        protocol.dataReceived = self.processProxyResponse\n+        protocol.dataReceived = self.processProxyResponse  # type: ignore[method-assign]\n         self._protocol = protocol\n         return protocol\n \n-    def processProxyResponse(self, rcvd_bytes):\n+    def processProxyResponse(self, data: bytes) -> None:",
      "comment": "Technically backward incompatible, but :see_no_evil: ",
      "comment_id": 1591970021,
      "user": "Gallaecio",
      "created_at": "2024-05-07T07:48:35Z",
      "url": "https://github.com/scrapy/scrapy/pull/6341#discussion_r1591970021"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 6341,
      "file_path": "scrapy/core/downloader/handlers/http11.py",
      "line": 250,
      "side": "RIGHT",
      "diff_hunk": "@@ -230,18 +239,20 @@ class TunnelingAgent(Agent):\n \n     def __init__(\n         self,\n-        reactor,\n-        proxyConf,\n-        contextFactory=None,\n-        connectTimeout=None,\n-        bindAddress=None,\n-        pool=None,\n+        reactor: ReactorBase,\n+        proxyConf: Tuple[str, int, Optional[bytes]],\n+        contextFactory: Optional[IPolicyForHTTPS] = None,\n+        connectTimeout: Optional[float] = None,\n+        bindAddress: Optional[bytes] = None,\n+        pool: Optional[HTTPConnectionPool] = None,\n     ):\n+        # TODO make this arg required instead\n+        assert contextFactory is not None",
      "comment": "To do in this PR, or should we create an issue to track this? (same about similar comments below)",
      "comment_id": 1591971773,
      "user": "Gallaecio",
      "created_at": "2024-05-07T07:49:55Z",
      "url": "https://github.com/scrapy/scrapy/pull/6341#discussion_r1591971773"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 6341,
      "file_path": "scrapy/core/downloader/handlers/http11.py",
      "line": 250,
      "side": "RIGHT",
      "diff_hunk": "@@ -230,18 +239,20 @@ class TunnelingAgent(Agent):\n \n     def __init__(\n         self,\n-        reactor,\n-        proxyConf,\n-        contextFactory=None,\n-        connectTimeout=None,\n-        bindAddress=None,\n-        pool=None,\n+        reactor: ReactorBase,\n+        proxyConf: Tuple[str, int, Optional[bytes]],\n+        contextFactory: Optional[IPolicyForHTTPS] = None,\n+        connectTimeout: Optional[float] = None,\n+        bindAddress: Optional[bytes] = None,\n+        pool: Optional[HTTPConnectionPool] = None,\n     ):\n+        # TODO make this arg required instead\n+        assert contextFactory is not None",
      "comment": "Not here, I'll make an issue for both instances. Not sure how to properly do this though. We could make all args kw-only.",
      "comment_id": 1592004354,
      "user": "wRAR",
      "created_at": "2024-05-07T08:15:14Z",
      "url": "https://github.com/scrapy/scrapy/pull/6341#discussion_r1592004354"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 6341,
      "file_path": "scrapy/core/downloader/handlers/http11.py",
      "line": 158,
      "side": "RIGHT",
      "diff_hunk": "@@ -123,83 +127,88 @@ class TunnelingTCP4ClientEndpoint(TCP4ClientEndpoint):\n \n     def __init__(\n         self,\n-        reactor,\n-        host,\n-        port,\n-        proxyConf,\n-        contextFactory,\n-        timeout=30,\n-        bindAddress=None,\n+        reactor: ReactorBase,\n+        host: str,\n+        port: int,\n+        proxyConf: Tuple[str, int, Optional[bytes]],\n+        contextFactory: IPolicyForHTTPS,\n+        timeout: float = 30,\n+        bindAddress: Optional[Tuple[str, int]] = None,\n     ):\n         proxyHost, proxyPort, self._proxyAuthHeader = proxyConf\n         super().__init__(reactor, proxyHost, proxyPort, timeout, bindAddress)\n-        self._tunnelReadyDeferred = defer.Deferred()\n-        self._tunneledHost = host\n-        self._tunneledPort = port\n-        self._contextFactory = contextFactory\n-        self._connectBuffer = bytearray()\n+        self._tunnelReadyDeferred: Deferred = Deferred()\n+        self._tunneledHost: str = host\n+        self._tunneledPort: int = port\n+        self._contextFactory: IPolicyForHTTPS = contextFactory\n+        self._connectBuffer: bytearray = bytearray()\n \n-    def requestTunnel(self, protocol):\n+    def requestTunnel(self, protocol: Protocol) -> Protocol:\n         \"\"\"Asks the proxy to open a tunnel.\"\"\"\n+        assert protocol.transport\n         tunnelReq = tunnel_request_data(\n             self._tunneledHost, self._tunneledPort, self._proxyAuthHeader\n         )\n         protocol.transport.write(tunnelReq)\n         self._protocolDataReceived = protocol.dataReceived\n-        protocol.dataReceived = self.processProxyResponse\n+        protocol.dataReceived = self.processProxyResponse  # type: ignore[method-assign]\n         self._protocol = protocol\n         return protocol\n \n-    def processProxyResponse(self, rcvd_bytes):\n+    def processProxyResponse(self, data: bytes) -> None:",
      "comment": "I assume it's only called when assigned to `protocol.dataReceived` so there shouldn't be problems even theoretically.",
      "comment_id": 1592015937,
      "user": "wRAR",
      "created_at": "2024-05-07T08:24:09Z",
      "url": "https://github.com/scrapy/scrapy/pull/6341#discussion_r1592015937"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 6279,
      "file_path": "scrapy/extensions/periodic_log.py",
      "line": 80,
      "side": "RIGHT",
      "diff_hunk": "@@ -15,52 +25,59 @@ class PeriodicLog:\n \n     def __init__(\n         self,\n-        stats,\n-        interval=60.0,\n-        ext_stats={},\n-        ext_delta={},\n-        ext_timing_enabled=False,\n+        stats: StatsCollector,\n+        interval: float = 60.0,\n+        ext_stats: Dict[str, Any] = {},\n+        ext_delta: Dict[str, Any] = {},\n+        ext_timing_enabled: bool = False,\n     ):\n-        self.stats = stats\n-        self.interval = interval\n-        self.multiplier = 60.0 / self.interval\n-        self.task = None\n-        self.encoder = ScrapyJSONEncoder(sort_keys=True, indent=4)\n-        self.ext_stats_enabled = bool(ext_stats)\n-        self.ext_stats_include = ext_stats.get(\"include\", [])\n-        self.ext_stats_exclude = ext_stats.get(\"exclude\", [])\n-        self.ext_delta_enabled = bool(ext_delta)\n-        self.ext_delta_include = ext_delta.get(\"include\", [])\n-        self.ext_delta_exclude = ext_delta.get(\"exclude\", [])\n-        self.ext_timing_enabled = ext_timing_enabled\n+        self.stats: StatsCollector = stats\n+        self.interval: float = interval\n+        self.multiplier: float = 60.0 / self.interval\n+        self.task: Optional[task.LoopingCall] = None\n+        self.encoder: JSONEncoder = ScrapyJSONEncoder(sort_keys=True, indent=4)\n+        self.ext_stats_enabled: bool = bool(ext_stats)\n+        self.ext_stats_include: List[str] = ext_stats.get(\"include\", [])\n+        self.ext_stats_exclude: List[str] = ext_stats.get(\"exclude\", [])\n+        self.ext_delta_enabled: bool = bool(ext_delta)\n+        self.ext_delta_include: List[str] = ext_delta.get(\"include\", [])\n+        self.ext_delta_exclude: List[str] = ext_delta.get(\"exclude\", [])\n+        self.ext_timing_enabled: bool = ext_timing_enabled\n \n     @classmethod\n-    def from_crawler(cls, crawler):\n-        interval = crawler.settings.getfloat(\"LOGSTATS_INTERVAL\")\n+    def from_crawler(cls, crawler: Crawler) -> Self:\n+        interval: float = crawler.settings.getfloat(\"LOGSTATS_INTERVAL\")\n         if not interval:\n             raise NotConfigured\n         try:\n-            ext_stats = crawler.settings.getdict(\"PERIODIC_LOG_STATS\")\n+            ext_stats: Optional[Dict[str, Any]] = crawler.settings.getdict(\n+                \"PERIODIC_LOG_STATS\"\n+            )\n         except (TypeError, ValueError):\n             ext_stats = (\n                 {\"enabled\": True}\n                 if crawler.settings.getbool(\"PERIODIC_LOG_STATS\")\n                 else None\n             )\n         try:\n-            ext_delta = crawler.settings.getdict(\"PERIODIC_LOG_DELTA\")\n+            ext_delta: Optional[Dict[str, Any]] = crawler.settings.getdict(\n+                \"PERIODIC_LOG_DELTA\"\n+            )\n         except (TypeError, ValueError):\n             ext_delta = (\n                 {\"enabled\": True}\n                 if crawler.settings.getbool(\"PERIODIC_LOG_DELTA\")\n                 else None\n             )\n \n-        ext_timing_enabled = crawler.settings.getbool(\n+        ext_timing_enabled: bool = crawler.settings.getbool(\n             \"PERIODIC_LOG_TIMING_ENABLED\", False\n         )\n         if not (ext_stats or ext_delta or ext_timing_enabled):\n             raise NotConfigured\n+        assert crawler.stats\n+        assert ext_stats is not None\n+        assert ext_delta is not None",
      "comment": "The logic for these two settings is complicated because they can (per the docs) be `None` (which is equivalent to an empty dict after `getdict()` anyway), `True` or a dict and so can't be False. Setting one of them to False indeed breaks the code. So the code above that sets the vars to None if getbool() returned False is dead code that can be refactored.",
      "comment_id": 1518125501,
      "user": "wRAR",
      "created_at": "2024-03-08T18:33:30Z",
      "url": "https://github.com/scrapy/scrapy/pull/6279#discussion_r1518125501"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 6279,
      "file_path": "scrapy/utils/reactor.py",
      "line": 24,
      "side": "LEFT",
      "diff_hunk": "@@ -2,26 +2,26 @@\n import sys\n from asyncio import AbstractEventLoop, AbstractEventLoopPolicy\n from contextlib import suppress\n-from typing import Any, Callable, Dict, Optional, Sequence, Type\n+from typing import Any, Callable, Dict, List, Optional, Sequence, Type\n from warnings import catch_warnings, filterwarnings, warn\n \n from twisted.internet import asyncioreactor, error\n from twisted.internet.base import DelayedCall\n+from twisted.internet.protocol import ServerFactory\n+from twisted.internet.tcp import Port\n \n from scrapy.exceptions import ScrapyDeprecationWarning\n from scrapy.utils.misc import load_object\n \n \n-def listen_tcp(portrange, host, factory):\n+def listen_tcp(portrange: List[int], host: str, factory: ServerFactory) -> Port:  # type: ignore[return]\n     \"\"\"Like reactor.listenTCP but tries different ports in a range.\"\"\"\n     from twisted.internet import reactor\n \n     if len(portrange) > 2:\n         raise ValueError(f\"invalid portrange: {portrange}\")\n     if not portrange:\n         return reactor.listenTCP(0, factory, interface=host)\n-    if not hasattr(portrange, \"__iter__\"):\n-        return reactor.listenTCP(portrange, factory, interface=host)",
      "comment": "Dead code, this function went through a few rounds of fixing the logic but in any case we always pass a list to it in the only place we use it, and if somebody passed a single value to it it would explode since 2020 (or, with asserts enabled, since the beginning).",
      "comment_id": 1518130861,
      "user": "wRAR",
      "created_at": "2024-03-08T18:37:16Z",
      "url": "https://github.com/scrapy/scrapy/pull/6279#discussion_r1518130861"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 6333,
      "file_path": "scrapy/squeues.py",
      "line": 25,
      "side": "RIGHT",
      "diff_hunk": "@@ -2,20 +2,28 @@\n Scheduler queues\n \"\"\"\n \n+from __future__ import annotations\n+\n import marshal\n import pickle  # nosec\n from os import PathLike\n from pathlib import Path\n-from typing import Union\n+from typing import TYPE_CHECKING, Any, Callable, Optional, Type, Union\n \n from queuelib import queue\n \n+from scrapy import Request\n+from scrapy.crawler import Crawler\n from scrapy.utils.request import request_from_dict\n \n+if TYPE_CHECKING:\n+    # typing.Self requires Python 3.11\n+    from typing_extensions import Self\n+\n \n-def _with_mkdir(queue_class):\n-    class DirectoriesCreated(queue_class):\n-        def __init__(self, path: Union[str, PathLike], *args, **kwargs):\n+def _with_mkdir(queue_class: Type[queue.BaseQueue]) -> Type[queue.BaseQueue]:\n+    class DirectoriesCreated(queue_class):  # type: ignore[valid-type,misc]",
      "comment": "Still not sure how to do this correctly, and whether this is a deficiency in mypy, something the hints can't express or just wrong hints.",
      "comment_id": 1589968938,
      "user": "wRAR",
      "created_at": "2024-05-04T11:31:46Z",
      "url": "https://github.com/scrapy/scrapy/pull/6333#discussion_r1589968938"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 6333,
      "file_path": "scrapy/squeues.py",
      "line": 145,
      "side": "RIGHT",
      "diff_hunk": "@@ -122,23 +142,24 @@ def _pickle_serialize(obj):\n         raise ValueError(str(e)) from e\n \n \n+# queue.*Queue aren't subclasses of queue.BaseQueue",
      "comment": "I think `queuelib.queue.BaseQueue` needs to be a Protocol, not an ABC with `__subclasscheck__`.",
      "comment_id": 1589969277,
      "user": "wRAR",
      "created_at": "2024-05-04T11:33:36Z",
      "url": "https://github.com/scrapy/scrapy/pull/6333#discussion_r1589969277"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 6333,
      "file_path": "scrapy/core/downloader/__init__.py",
      "line": 146,
      "side": "RIGHT",
      "diff_hunk": "@@ -143,7 +143,7 @@ def _get_slot(self, request: Request, spider: Spider) -> Tuple[str, Slot]:\n \n         return key, self.slots[key]\n \n-    def _get_slot_key(self, request: Request, spider: Spider) -> str:\n+    def _get_slot_key(self, request: Request, spider: Any) -> str:",
      "comment": "Not `Optional[Spider]`? It this because of tests passing junk, or something else?",
      "comment_id": 1590733052,
      "user": "Gallaecio",
      "created_at": "2024-05-06T09:05:02Z",
      "url": "https://github.com/scrapy/scrapy/pull/6333#discussion_r1590733052"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 6333,
      "file_path": "scrapy/core/downloader/__init__.py",
      "line": 146,
      "side": "RIGHT",
      "diff_hunk": "@@ -143,7 +143,7 @@ def _get_slot(self, request: Request, spider: Spider) -> Tuple[str, Slot]:\n \n         return key, self.slots[key]\n \n-    def _get_slot_key(self, request: Request, spider: Spider) -> str:\n+    def _get_slot_key(self, request: Request, spider: Any) -> str:",
      "comment": "It doesn't really matter as the argument is not used. We should deprecate and remove it I think, we can't remove it right away because it's used both in private and public code (e.g. in `ScrapyZyteAPIDownloaderMiddleware`)",
      "comment_id": 1590745864,
      "user": "wRAR",
      "created_at": "2024-05-06T09:16:42Z",
      "url": "https://github.com/scrapy/scrapy/pull/6333#discussion_r1590745864"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 6316,
      "file_path": "tests/test_utils_python.py",
      "line": 243,
      "side": "RIGHT",
      "diff_hunk": "@@ -238,13 +237,11 @@ def __call__(self, a, b, c):\n         self.assertEqual(get_func_args(str.split, stripself=True), [\"sep\", \"maxsplit\"])\n         self.assertEqual(get_func_args(\" \".join, stripself=True), [\"iterable\"])\n \n-        if platform.python_implementation() == \"CPython\":\n-            # doesn't work on CPython: https://bugs.python.org/issue42785\n-            self.assertEqual(get_func_args(operator.itemgetter(2)), [])\n-        elif platform.python_implementation() == \"PyPy\":\n-            self.assertEqual(\n-                get_func_args(operator.itemgetter(2), stripself=True), [\"obj\"]\n-            )\n+        # Didn't used to work on CPython: https://bugs.python.org/issue42785\n+        self.assertIn(\n+            get_func_args(operator.itemgetter(2), stripself=True),\n+            [[], [\"obj\"], [\"args\", \"kwargs\"]],",
      "comment": "Is `[\"args\", \"kwargs\"]` what CPython returns now? If so, it might be best to keep the old if/else for PyPy, and assert CPython for `[[], [\"args\", \"kwargs\"]]` instead.",
      "comment_id": 1568349603,
      "user": "Gallaecio",
      "created_at": "2024-04-17T07:21:59Z",
      "url": "https://github.com/scrapy/scrapy/pull/6316#discussion_r1568349603"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 6316,
      "file_path": "tests/test_utils_python.py",
      "line": 242,
      "side": "RIGHT",
      "diff_hunk": "@@ -239,8 +239,11 @@ def __call__(self, a, b, c):\n         self.assertEqual(get_func_args(\" \".join, stripself=True), [\"iterable\"])\n \n         if platform.python_implementation() == \"CPython\":\n-            # doesn't work on CPython: https://bugs.python.org/issue42785\n-            self.assertEqual(get_func_args(operator.itemgetter(2)), [])\n+            # Didn't used to work on CPython: https://bugs.python.org/issue42785",
      "comment": "I'd rephrase it: https://english.stackexchange.com/questions/8816/whats-the-negation-of-i-used-to-be-surely-not-i-didnt-used-to-be",
      "comment_id": 1568452973,
      "user": "wRAR",
      "created_at": "2024-04-17T08:39:28Z",
      "url": "https://github.com/scrapy/scrapy/pull/6316#discussion_r1568452973"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 6316,
      "file_path": "tests/test_utils_python.py",
      "line": 242,
      "side": "RIGHT",
      "diff_hunk": "@@ -239,8 +239,11 @@ def __call__(self, a, b, c):\n         self.assertEqual(get_func_args(\" \".join, stripself=True), [\"iterable\"])\n \n         if platform.python_implementation() == \"CPython\":\n-            # doesn't work on CPython: https://bugs.python.org/issue42785\n-            self.assertEqual(get_func_args(operator.itemgetter(2)), [])\n+            # This never worked on CPython: https://bugs.python.org/issue42785",
      "comment": "Well it didn't work but now works :) How about \"This didn't work on older versions of CPython\"?\r\n\r\nAlso I would update the issue URL to https://github.com/python/cpython/issues/86951",
      "comment_id": 1568492431,
      "user": "wRAR",
      "created_at": "2024-04-17T09:07:11Z",
      "url": "https://github.com/scrapy/scrapy/pull/6316#discussion_r1568492431"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 6310,
      "file_path": "scrapy/http/cookies.py",
      "line": 174,
      "side": "RIGHT",
      "diff_hunk": "@@ -170,7 +170,8 @@ def has_header(self, name):\n         return name in self.request.headers\n \n     def get_header(self, name, default=None):\n-        return to_unicode(self.request.headers.get(name, default), errors=\"replace\")\n+        value = self.request.headers.get(name, default)\n+        return to_unicode(value, errors=\"replace\") if value else value",
      "comment": "I think it will return `b''` where we want to return `''` :)",
      "comment_id": 1555371325,
      "user": "wRAR",
      "created_at": "2024-04-08T07:47:53Z",
      "url": "https://github.com/scrapy/scrapy/pull/6310#discussion_r1555371325"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 6298,
      "file_path": "tests/test_robotstxt_interface.py",
      "line": 162,
      "side": "RIGHT",
      "diff_hunk": "@@ -141,6 +143,25 @@ def test_unicode_url_and_useragent(self):\n         )\n \n \n+class DecodeRobotsTxtTest(unittest.TestCase):\n+    def test_native_string_conversion(self):\n+        robotstxt_body = \"User-agent: *\\nDisallow: /\\n\".encode(\"utf-8\")\n+        decoded_content = decode_robotstxt(\n+            robotstxt_body, spider=None, to_native_str_type=True\n+        )\n+        self.assertEqual(decoded_content, \"User-agent: *\\nDisallow: /\\n\")\n+\n+    def test_decode_utf8(self):\n+        robotstxt_body = \"User-agent: *\\nDisallow: /\\n\".encode(\"utf-8\")\n+        decoded_content = decode_robotstxt(robotstxt_body, spider=None)\n+        self.assertEqual(decoded_content, \"User-agent: *\\nDisallow: /\\n\")\n+\n+    def test_decode_non_utf8(self):\n+        robotstxt_body = b\"User-agent: *\\n\\xFFDisallow: /\\n\"\n+        decoded_content = decode_robotstxt(robotstxt_body, spider=None)\n+        self.assertNotEqual(decoded_content, \"\")",
      "comment": "Why not use `assertEqual` with the real returned value here?",
      "comment_id": 1550192820,
      "user": "wRAR",
      "created_at": "2024-04-03T17:39:36Z",
      "url": "https://github.com/scrapy/scrapy/pull/6298#discussion_r1550192820"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 6298,
      "file_path": "tests/test_robotstxt_interface.py",
      "line": 162,
      "side": "RIGHT",
      "diff_hunk": "@@ -141,6 +143,25 @@ def test_unicode_url_and_useragent(self):\n         )\n \n \n+class DecodeRobotsTxtTest(unittest.TestCase):\n+    def test_native_string_conversion(self):\n+        robotstxt_body = \"User-agent: *\\nDisallow: /\\n\".encode(\"utf-8\")\n+        decoded_content = decode_robotstxt(\n+            robotstxt_body, spider=None, to_native_str_type=True\n+        )\n+        self.assertEqual(decoded_content, \"User-agent: *\\nDisallow: /\\n\")\n+\n+    def test_decode_utf8(self):\n+        robotstxt_body = \"User-agent: *\\nDisallow: /\\n\".encode(\"utf-8\")\n+        decoded_content = decode_robotstxt(robotstxt_body, spider=None)\n+        self.assertEqual(decoded_content, \"User-agent: *\\nDisallow: /\\n\")\n+\n+    def test_decode_non_utf8(self):\n+        robotstxt_body = b\"User-agent: *\\n\\xFFDisallow: /\\n\"\n+        decoded_content = decode_robotstxt(robotstxt_body, spider=None)\n+        self.assertNotEqual(decoded_content, \"\")",
      "comment": "The idea behind this test case is that when a string is not in UTF-8 we can't reliably predict what the output will be as a result of adding `errors=\"ignore\"` when decoding.\r\nAs it stands, we do obviously know what `robotstxt_body` will be and we might as well just use `assertEqual`, however I was trying to make sure that this code wouldn't fall under the [case where a `UnicodeDecodeError` is thrown](https://github.com/scrapy/scrapy/pull/6298/files#diff-0dc4cc282c7f78b4d6199a7b5de162f382efdf5d4836bb9fd567be94d15c8637R26-R36) - which just returns `\"\"` - and I suppose we're trying to avoid that with this change?\r\nLet me know what you think is best \ud83d\ude42 ",
      "comment_id": 1550326866,
      "user": "lorenzoverardo",
      "created_at": "2024-04-03T19:22:48Z",
      "url": "https://github.com/scrapy/scrapy/pull/6298#discussion_r1550326866"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 6298,
      "file_path": "tests/test_robotstxt_interface.py",
      "line": 162,
      "side": "RIGHT",
      "diff_hunk": "@@ -141,6 +143,25 @@ def test_unicode_url_and_useragent(self):\n         )\n \n \n+class DecodeRobotsTxtTest(unittest.TestCase):\n+    def test_native_string_conversion(self):\n+        robotstxt_body = \"User-agent: *\\nDisallow: /\\n\".encode(\"utf-8\")\n+        decoded_content = decode_robotstxt(\n+            robotstxt_body, spider=None, to_native_str_type=True\n+        )\n+        self.assertEqual(decoded_content, \"User-agent: *\\nDisallow: /\\n\")\n+\n+    def test_decode_utf8(self):\n+        robotstxt_body = \"User-agent: *\\nDisallow: /\\n\".encode(\"utf-8\")\n+        decoded_content = decode_robotstxt(robotstxt_body, spider=None)\n+        self.assertEqual(decoded_content, \"User-agent: *\\nDisallow: /\\n\")\n+\n+    def test_decode_non_utf8(self):\n+        robotstxt_body = b\"User-agent: *\\n\\xFFDisallow: /\\n\"\n+        decoded_content = decode_robotstxt(robotstxt_body, spider=None)\n+        self.assertNotEqual(decoded_content, \"\")",
      "comment": "I also think we should use `assertEqual` with the actual value.\r\n\r\n> was trying to make sure that this code wouldn't fall under the [case where a `UnicodeDecodeError` is thrown](https://github.com/scrapy/scrapy/pull/6298/files#diff-0dc4cc282c7f78b4d6199a7b5de162f382efdf5d4836bb9fd567be94d15c8637R26-R36)\r\n\r\n`assertEqual` with the actual value works for this as well, as long as the actual value is not `\"\"`, i.e. `self.assertEqual(decoded_content, \"foo\")` implies `self.assertNotEqual(decoded_content, \"\")`, but is better than the latter because it also proves we are using `ignore` and not some other error handling (e.g. replacing errors with special characters or something).",
      "comment_id": 1551233860,
      "user": "Gallaecio",
      "created_at": "2024-04-04T08:39:55Z",
      "url": "https://github.com/scrapy/scrapy/pull/6298#discussion_r1551233860"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 6272,
      "file_path": "tests/test_utils_display.py",
      "line": 15,
      "side": "RIGHT",
      "diff_hunk": "@@ -1,9 +1,18 @@\n from io import StringIO\n-from unittest import TestCase, mock\n+from unittest import TestCase, mock, skipIf\n \n from scrapy.utils.display import pformat, pprint\n \n+try:\n+    import bpython\n \n+    bpy = True\n+    del bpython\n+except ImportError:\n+    bpy = False\n+\n+\n+@skipIf(not bpy, \"bpython not available in testenv\")",
      "comment": "Why is this needed? Looks like this test works without bpython and doesn't use it?",
      "comment_id": 1520919328,
      "user": "wRAR",
      "created_at": "2024-03-12T06:29:36Z",
      "url": "https://github.com/scrapy/scrapy/pull/6272#discussion_r1520919328"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 6272,
      "file_path": "tests/test_utils_display.py",
      "line": 15,
      "side": "RIGHT",
      "diff_hunk": "@@ -1,9 +1,18 @@\n from io import StringIO\n-from unittest import TestCase, mock\n+from unittest import TestCase, mock, skipIf\n \n from scrapy.utils.display import pformat, pprint\n \n+try:\n+    import bpython\n \n+    bpy = True\n+    del bpython\n+except ImportError:\n+    bpy = False\n+\n+\n+@skipIf(not bpy, \"bpython not available in testenv\")",
      "comment": "Without this, we have errors on this tests:\r\n\r\n![image](https://github.com/scrapy/scrapy/assets/144740771/fd1b1a69-f2a1-44b3-b841-2b03a46dec6a)\r\n\r\nLike a said on this comment: https://github.com/scrapy/scrapy/pull/6272#discussion_r1518409690\r\n\r\nDo you think there is a better way?",
      "comment_id": 1521465577,
      "user": "lucas-belo",
      "created_at": "2024-03-12T13:26:57Z",
      "url": "https://github.com/scrapy/scrapy/pull/6272#discussion_r1521465577"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 6272,
      "file_path": "tests/test_utils_display.py",
      "line": 15,
      "side": "RIGHT",
      "diff_hunk": "@@ -1,9 +1,18 @@\n from io import StringIO\n-from unittest import TestCase, mock\n+from unittest import TestCase, mock, skipIf\n \n from scrapy.utils.display import pformat, pprint\n \n+try:\n+    import bpython\n \n+    bpy = True\n+    del bpython\n+except ImportError:\n+    bpy = False\n+\n+\n+@skipIf(not bpy, \"bpython not available in testenv\")",
      "comment": "`scrapy.utils.display._colorize()` uses pygments but we don't install it explicitly in tests, you should fix that (I assume pygments is a dep of bpython).",
      "comment_id": 1521540355,
      "user": "wRAR",
      "created_at": "2024-03-12T14:10:17Z",
      "url": "https://github.com/scrapy/scrapy/pull/6272#discussion_r1521540355"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 6129,
      "file_path": "scrapy/downloadermiddlewares/cookies.py",
      "line": 65,
      "side": "RIGHT",
      "diff_hunk": "@@ -1,45 +1,69 @@\n+from __future__ import annotations\n+\n import logging\n from collections import defaultdict\n+from http.cookiejar import Cookie\n+from typing import (\n+    TYPE_CHECKING,\n+    Any,\n+    DefaultDict,\n+    Dict,\n+    Iterable,\n+    Optional,\n+    Sequence,\n+    Union,\n+)\n \n from tldextract import TLDExtract\n \n+from scrapy import Request, Spider\n+from scrapy.crawler import Crawler\n from scrapy.exceptions import NotConfigured\n from scrapy.http import Response\n from scrapy.http.cookies import CookieJar\n from scrapy.utils.httpobj import urlparse_cached\n from scrapy.utils.python import to_unicode\n \n+if TYPE_CHECKING:\n+    # typing.Self requires Python 3.11\n+    from typing_extensions import Self\n+\n+\n logger = logging.getLogger(__name__)\n \n \n _split_domain = TLDExtract(include_psl_private_domains=True)\n \n \n-def _is_public_domain(domain):\n+def _is_public_domain(domain: str) -> bool:\n     parts = _split_domain(domain)\n     return not parts.domain\n \n \n class CookiesMiddleware:\n     \"\"\"This middleware enables working with sites that need cookies\"\"\"\n \n-    def __init__(self, debug=False):\n-        self.jars = defaultdict(CookieJar)\n-        self.debug = debug\n+    def __init__(self, debug: bool = False):\n+        self.jars: DefaultDict[Any, CookieJar] = defaultdict(CookieJar)\n+        self.debug: bool = debug\n \n     @classmethod\n-    def from_crawler(cls, crawler):\n+    def from_crawler(cls, crawler: Crawler) -> Self:\n         if not crawler.settings.getbool(\"COOKIES_ENABLED\"):\n             raise NotConfigured\n         return cls(crawler.settings.getbool(\"COOKIES_DEBUG\"))\n \n-    def _process_cookies(self, cookies, *, jar, request):\n+    def _process_cookies(\n+        self, cookies: Iterable[Cookie], *, jar: CookieJar, request: Request\n+    ) -> None:\n         for cookie in cookies:\n             cookie_domain = cookie.domain\n             if cookie_domain.startswith(\".\"):\n                 cookie_domain = cookie_domain[1:]\n \n-            request_domain = urlparse_cached(request).hostname.lower()\n+            hostname = urlparse_cached(request).hostname\n+            assert hostname is not None",
      "comment": "Is this a given? I was thinking some URL protocols do allow this in valid URLs, and I am not sure we prevent cookies from being used with them:\r\n\r\n```python\r\n>>> from urllib.parse import urlparse\r\n>>> print(urlparse('file:///home/adrian').hostname)\r\nNone\r\n```",
      "comment_id": 1381260715,
      "user": "Gallaecio",
      "created_at": "2023-11-03T08:02:32Z",
      "url": "https://github.com/scrapy/scrapy/pull/6129#discussion_r1381260715"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 6129,
      "file_path": "scrapy/downloadermiddlewares/redirect.py",
      "line": 119,
      "side": "RIGHT",
      "diff_hunk": "@@ -98,6 +116,7 @@ def process_response(self, request, response, spider):\n         if \"Location\" not in response.headers or response.status not in allowed_status:\n             return response\n \n+        assert response.headers[\"Location\"]",
      "comment": "Would mypy understand this?\r\n\r\n```suggestion\r\n        assert \"Location\" in response.headers\r\n```\r\n\r\nor\r\n\r\n```suggestion\r\n        assert isinstance(response.headers[\"Location\"], bytes)\r\n```\r\n\r\nOtherwise, we are saying that a Location header cannot be an empty string, which I imagine it technically can.",
      "comment_id": 1381266950,
      "user": "Gallaecio",
      "created_at": "2023-11-03T08:08:35Z",
      "url": "https://github.com/scrapy/scrapy/pull/6129#discussion_r1381266950"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 6129,
      "file_path": "scrapy/downloadermiddlewares/robotstxt.py",
      "line": 101,
      "side": "RIGHT",
      "diff_hunk": "@@ -75,24 +97,27 @@ def robot_parser(self, request, spider):\n                 meta={\"dont_obey_robotstxt\": True},\n                 callback=NO_CALLBACK,\n             )\n+            assert self.crawler.engine\n+            assert self.crawler.stats",
      "comment": "I wonder how we could make this easier for users in their own code.\r\n\r\nWould mypy understand if we moved this to `__init__` or `from_crawler`?\r\nIs there anything we can do to enable writing a single line that asserts that the crawler has been initialized?",
      "comment_id": 1381270705,
      "user": "Gallaecio",
      "created_at": "2023-11-03T08:13:29Z",
      "url": "https://github.com/scrapy/scrapy/pull/6129#discussion_r1381270705"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 6129,
      "file_path": "scrapy/downloadermiddlewares/robotstxt.py",
      "line": 101,
      "side": "RIGHT",
      "diff_hunk": "@@ -75,24 +97,27 @@ def robot_parser(self, request, spider):\n                 meta={\"dont_obey_robotstxt\": True},\n                 callback=NO_CALLBACK,\n             )\n+            assert self.crawler.engine\n+            assert self.crawler.stats",
      "comment": "Yeah, it would be good if we didn't need that. `from_crawler` is unlikely to help as checkers don't know it was called. Not sure about `__init__`, as checkers could think that the attribute became `None` since then.",
      "comment_id": 1381306390,
      "user": "wRAR",
      "created_at": "2023-11-03T08:46:25Z",
      "url": "https://github.com/scrapy/scrapy/pull/6129#discussion_r1381306390"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 6129,
      "file_path": "scrapy/downloadermiddlewares/cookies.py",
      "line": 65,
      "side": "RIGHT",
      "diff_hunk": "@@ -1,45 +1,69 @@\n+from __future__ import annotations\n+\n import logging\n from collections import defaultdict\n+from http.cookiejar import Cookie\n+from typing import (\n+    TYPE_CHECKING,\n+    Any,\n+    DefaultDict,\n+    Dict,\n+    Iterable,\n+    Optional,\n+    Sequence,\n+    Union,\n+)\n \n from tldextract import TLDExtract\n \n+from scrapy import Request, Spider\n+from scrapy.crawler import Crawler\n from scrapy.exceptions import NotConfigured\n from scrapy.http import Response\n from scrapy.http.cookies import CookieJar\n from scrapy.utils.httpobj import urlparse_cached\n from scrapy.utils.python import to_unicode\n \n+if TYPE_CHECKING:\n+    # typing.Self requires Python 3.11\n+    from typing_extensions import Self\n+\n+\n logger = logging.getLogger(__name__)\n \n \n _split_domain = TLDExtract(include_psl_private_domains=True)\n \n \n-def _is_public_domain(domain):\n+def _is_public_domain(domain: str) -> bool:\n     parts = _split_domain(domain)\n     return not parts.domain\n \n \n class CookiesMiddleware:\n     \"\"\"This middleware enables working with sites that need cookies\"\"\"\n \n-    def __init__(self, debug=False):\n-        self.jars = defaultdict(CookieJar)\n-        self.debug = debug\n+    def __init__(self, debug: bool = False):\n+        self.jars: DefaultDict[Any, CookieJar] = defaultdict(CookieJar)\n+        self.debug: bool = debug\n \n     @classmethod\n-    def from_crawler(cls, crawler):\n+    def from_crawler(cls, crawler: Crawler) -> Self:\n         if not crawler.settings.getbool(\"COOKIES_ENABLED\"):\n             raise NotConfigured\n         return cls(crawler.settings.getbool(\"COOKIES_DEBUG\"))\n \n-    def _process_cookies(self, cookies, *, jar, request):\n+    def _process_cookies(\n+        self, cookies: Iterable[Cookie], *, jar: CookieJar, request: Request\n+    ) -> None:\n         for cookie in cookies:\n             cookie_domain = cookie.domain\n             if cookie_domain.startswith(\".\"):\n                 cookie_domain = cookie_domain[1:]\n \n-            request_domain = urlparse_cached(request).hostname.lower()\n+            hostname = urlparse_cached(request).hostname\n+            assert hostname is not None",
      "comment": "The code will fail anyway as it calls `.lower()` on it later. But I'm not sure if it's possible to run this code in a non-HTTP context.",
      "comment_id": 1381307117,
      "user": "wRAR",
      "created_at": "2023-11-03T08:47:11Z",
      "url": "https://github.com/scrapy/scrapy/pull/6129#discussion_r1381307117"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 6129,
      "file_path": "scrapy/downloadermiddlewares/cookies.py",
      "line": 65,
      "side": "RIGHT",
      "diff_hunk": "@@ -1,45 +1,69 @@\n+from __future__ import annotations\n+\n import logging\n from collections import defaultdict\n+from http.cookiejar import Cookie\n+from typing import (\n+    TYPE_CHECKING,\n+    Any,\n+    DefaultDict,\n+    Dict,\n+    Iterable,\n+    Optional,\n+    Sequence,\n+    Union,\n+)\n \n from tldextract import TLDExtract\n \n+from scrapy import Request, Spider\n+from scrapy.crawler import Crawler\n from scrapy.exceptions import NotConfigured\n from scrapy.http import Response\n from scrapy.http.cookies import CookieJar\n from scrapy.utils.httpobj import urlparse_cached\n from scrapy.utils.python import to_unicode\n \n+if TYPE_CHECKING:\n+    # typing.Self requires Python 3.11\n+    from typing_extensions import Self\n+\n+\n logger = logging.getLogger(__name__)\n \n \n _split_domain = TLDExtract(include_psl_private_domains=True)\n \n \n-def _is_public_domain(domain):\n+def _is_public_domain(domain: str) -> bool:\n     parts = _split_domain(domain)\n     return not parts.domain\n \n \n class CookiesMiddleware:\n     \"\"\"This middleware enables working with sites that need cookies\"\"\"\n \n-    def __init__(self, debug=False):\n-        self.jars = defaultdict(CookieJar)\n-        self.debug = debug\n+    def __init__(self, debug: bool = False):\n+        self.jars: DefaultDict[Any, CookieJar] = defaultdict(CookieJar)\n+        self.debug: bool = debug\n \n     @classmethod\n-    def from_crawler(cls, crawler):\n+    def from_crawler(cls, crawler: Crawler) -> Self:\n         if not crawler.settings.getbool(\"COOKIES_ENABLED\"):\n             raise NotConfigured\n         return cls(crawler.settings.getbool(\"COOKIES_DEBUG\"))\n \n-    def _process_cookies(self, cookies, *, jar, request):\n+    def _process_cookies(\n+        self, cookies: Iterable[Cookie], *, jar: CookieJar, request: Request\n+    ) -> None:\n         for cookie in cookies:\n             cookie_domain = cookie.domain\n             if cookie_domain.startswith(\".\"):\n                 cookie_domain = cookie_domain[1:]\n \n-            request_domain = urlparse_cached(request).hostname.lower()\n+            hostname = urlparse_cached(request).hostname\n+            assert hostname is not None",
      "comment": "OK. I guess the only change here is that the exception will be different, and if anyone is getting this exception they should report it anyway so that we can do something about it (maybe prevent cookie handling from working on file:// altogether).",
      "comment_id": 1381321107,
      "user": "Gallaecio",
      "created_at": "2023-11-03T08:57:40Z",
      "url": "https://github.com/scrapy/scrapy/pull/6129#discussion_r1381321107"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 6129,
      "file_path": "scrapy/downloadermiddlewares/robotstxt.py",
      "line": 101,
      "side": "RIGHT",
      "diff_hunk": "@@ -75,24 +97,27 @@ def robot_parser(self, request, spider):\n                 meta={\"dont_obey_robotstxt\": True},\n                 callback=NO_CALLBACK,\n             )\n+            assert self.crawler.engine\n+            assert self.crawler.stats",
      "comment": "Doing this in `__init__` doesn't help here, I'll create a separate issue for this (but I'm not sure if it's possible).",
      "comment_id": 1382528404,
      "user": "wRAR",
      "created_at": "2023-11-05T09:14:25Z",
      "url": "https://github.com/scrapy/scrapy/pull/6129#discussion_r1382528404"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 6268,
      "file_path": "scrapy/commands/__init__.py",
      "line": 202,
      "side": "RIGHT",
      "diff_hunk": "@@ -183,19 +184,26 @@ class ScrapyHelpFormatter(argparse.HelpFormatter):\n     Help Formatter for scrapy command line help messages.\n     \"\"\"\n \n-    def __init__(self, prog, indent_increment=2, max_help_position=24, width=None):\n+    def __init__(\n+        self,\n+        prog: str,\n+        indent_increment: int = 2,\n+        max_help_position: int = 24,\n+        width: Optional[int] = None,\n+    ):\n         super().__init__(\n             prog,\n             indent_increment=indent_increment,\n             max_help_position=max_help_position,\n             width=width,\n         )\n \n-    def _join_parts(self, part_strings):\n-        parts = self.format_part_strings(part_strings)\n+    def _join_parts(self, part_strings: Iterable[str]) -> str:\n+        # scrapy.commands.list shadows builtins.list",
      "comment": "https://docs.python.org/3/reference/import.html#submodules",
      "comment_id": 1513411848,
      "user": "wRAR",
      "created_at": "2024-03-05T19:55:00Z",
      "url": "https://github.com/scrapy/scrapy/pull/6268#discussion_r1513411848"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 6269,
      "file_path": "scrapy/utils/_compression.py",
      "line": 23,
      "side": "RIGHT",
      "diff_hunk": "@@ -17,8 +20,8 @@\n                 \"You have brotlipy installed, and Scrapy will use it, but \"\n                 \"Scrapy support for brotlipy is deprecated and will stop \"\n                 \"working in a future version of Scrapy. brotlipy itself is \"\n-                \"deprecated, it has been superseded by brotlicffi (not \"\n-                \"currently supported by Scrapy). Please, uninstall brotlipy \"\n+                \"deprecated, it has been superseded by brotlicffi \"",
      "comment": "```suggestion\r\n                \"deprecated, it has been superseded by brotlicffi. \"\r\n```",
      "comment_id": 1513842170,
      "user": "wRAR",
      "created_at": "2024-03-06T05:30:49Z",
      "url": "https://github.com/scrapy/scrapy/pull/6269#discussion_r1513842170"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 6269,
      "file_path": "scrapy/utils/_compression.py",
      "line": 25,
      "side": "RIGHT",
      "diff_hunk": "@@ -17,8 +20,8 @@\n                 \"You have brotlipy installed, and Scrapy will use it, but \"\n                 \"Scrapy support for brotlipy is deprecated and will stop \"\n                 \"working in a future version of Scrapy. brotlipy itself is \"\n-                \"deprecated, it has been superseded by brotlicffi (not \"\n-                \"currently supported by Scrapy). Please, uninstall brotlipy \"\n+                \"deprecated, it has been superseded by brotlicffi. \"\n+                \"Please, uninstall brotlipy \"\n                 \"and install brotli instead. brotlipy has the same import \"",
      "comment": "```suggestion\r\n                \"and install brotli or brotlicffi instead. brotlipy has the same import \"\r\n```",
      "comment_id": 1514334968,
      "user": "Gallaecio",
      "created_at": "2024-03-06T11:50:20Z",
      "url": "https://github.com/scrapy/scrapy/pull/6269#discussion_r1514334968"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 6261,
      "file_path": "scrapy/utils/_compression.py",
      "line": 13,
      "side": "RIGHT",
      "diff_hunk": "@@ -5,6 +5,19 @@\n     import brotli\n except ImportError:\n     pass\n+else:\n+    try:\n+        brotli.Decompressor.process\n+    except AttributeError:\n+\n+        def _brotli_decompress(decompressor, data):",
      "comment": "Should we add a warning here?\r\n\r\nBy the way `brotlipy` is now `brotlicffi` (with the import name adjusted accordingly), but whether we need to add support for it is a separate question.",
      "comment_id": 1508690276,
      "user": "wRAR",
      "created_at": "2024-03-01T09:05:38Z",
      "url": "https://github.com/scrapy/scrapy/pull/6261#discussion_r1508690276"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 6261,
      "file_path": "scrapy/utils/_compression.py",
      "line": 13,
      "side": "RIGHT",
      "diff_hunk": "@@ -5,6 +5,19 @@\n     import brotli\n except ImportError:\n     pass\n+else:\n+    try:\n+        brotli.Decompressor.process\n+    except AttributeError:\n+\n+        def _brotli_decompress(decompressor, data):",
      "comment": "[Sounds like support may make sense for PyPy support](https://github.com/urllib3/urllib3/issues/2040), but indeed [out of scope here](https://github.com/scrapy/scrapy/issues/6263).",
      "comment_id": 1508695748,
      "user": "Gallaecio",
      "created_at": "2024-03-01T09:10:37Z",
      "url": "https://github.com/scrapy/scrapy/pull/6261#discussion_r1508695748"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 6265,
      "file_path": "scrapy/http/request/form.py",
      "line": 13,
      "side": "RIGHT",
      "diff_hunk": "@@ -10,21 +10,16 @@\n from typing import TYPE_CHECKING, Any, Iterable, List, Optional, Tuple, Union, cast\n from urllib.parse import urlencode, urljoin, urlsplit, urlunsplit\n \n-from lxml.html import (\n-    FormElement,\n-    HTMLParser,\n-    InputElement,\n-    MultipleSelectOptions,\n-    SelectElement,\n-    TextareaElement,\n-)\n-from parsel.selector import create_root_node\n+from lxml.html import FormElement  # nosec",
      "comment": "Question: We need to change import style because is not possible to use # no sec otherwise? Thanks",
      "comment_id": 1508961146,
      "user": "Laerte",
      "created_at": "2024-03-01T13:06:29Z",
      "url": "https://github.com/scrapy/scrapy/pull/6265#discussion_r1508961146"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 6265,
      "file_path": "scrapy/http/request/form.py",
      "line": 13,
      "side": "RIGHT",
      "diff_hunk": "@@ -10,21 +10,16 @@\n from typing import TYPE_CHECKING, Any, Iterable, List, Optional, Tuple, Union, cast\n from urllib.parse import urlencode, urljoin, urlsplit, urlunsplit\n \n-from lxml.html import (\n-    FormElement,\n-    HTMLParser,\n-    InputElement,\n-    MultipleSelectOptions,\n-    SelectElement,\n-    TextareaElement,\n-)\n-from parsel.selector import create_root_node\n+from lxml.html import FormElement  # nosec",
      "comment": "isort did that automatically, not sure why, I imagine it is a style choice.",
      "comment_id": 1509020849,
      "user": "Gallaecio",
      "created_at": "2024-03-01T13:31:47Z",
      "url": "https://github.com/scrapy/scrapy/pull/6265#discussion_r1509020849"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 6265,
      "file_path": "scrapy/http/request/form.py",
      "line": 118,
      "side": "RIGHT",
      "diff_hunk": "@@ -120,7 +115,7 @@ def _get_form(\n     formxpath: Optional[str],\n ) -> FormElement:\n     \"\"\"Find the wanted form element within the given response.\"\"\"\n-    root = create_root_node(response.text, HTMLParser, base_url=get_base_url(response))\n+    root = response.selector.root",
      "comment": "Can you please explain this? Also does this work with all supported parsel versions?",
      "comment_id": 1509040432,
      "user": "wRAR",
      "created_at": "2024-03-01T13:49:34Z",
      "url": "https://github.com/scrapy/scrapy/pull/6265#discussion_r1509040432"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 6265,
      "file_path": "scrapy/http/request/form.py",
      "line": 118,
      "side": "RIGHT",
      "diff_hunk": "@@ -120,7 +115,7 @@ def _get_form(\n     formxpath: Optional[str],\n ) -> FormElement:\n     \"\"\"Find the wanted form element within the given response.\"\"\"\n-    root = create_root_node(response.text, HTMLParser, base_url=get_base_url(response))\n+    root = response.selector.root",
      "comment": "Some of the code later on relies on attributes from `lxml.etree.Element` not exposed by `Selector` (e.g. `name`), so using the selector all the way was not possible.\r\n\r\n[`Selector.root` was already available in the lowest parsel version Scrapy supports](https://github.com/scrapy/parsel/blob/v1.5.0/parsel/selector.py#L200).\r\n\r\n",
      "comment_id": 1509048456,
      "user": "Gallaecio",
      "created_at": "2024-03-01T13:56:40Z",
      "url": "https://github.com/scrapy/scrapy/pull/6265#discussion_r1509048456"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 6264,
      "file_path": "scrapy/utils/misc.py",
      "line": 124,
      "side": "RIGHT",
      "diff_hunk": "@@ -113,7 +113,15 @@ def md5sum(file: IO) -> str:\n     >>> md5sum(BytesIO(b'file content to hash'))\n     '784406af91dd5a54fbb9c84c2236595a'\n     \"\"\"\n-    m = hashlib.md5()\n+    warnings.warn(\n+        (\n+            \"The scrapy.utils.misc.md5sum function is deprecated, and will be \"\n+            \"removed in a future version of Scrapy.\"\n+        ),\n+        ScrapyDeprecationWarning,\n+        stacklevel=2,\n+    )\n+    m = hashlib.md5(usedforsecurity=False)",
      "comment": "Since whether the function is intended for security or not depends on the caller, I thought it best to deprecate this function and reimplement it as private in the media pipelines, which is where it was being used internally, and where we can ensure it is not being used for security purposes.",
      "comment_id": 1508836271,
      "user": "Gallaecio",
      "created_at": "2024-03-01T11:04:12Z",
      "url": "https://github.com/scrapy/scrapy/pull/6264#discussion_r1508836271"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 6253,
      "file_path": "scrapy/utils/signal.py",
      "line": 101,
      "side": "RIGHT",
      "diff_hunk": "@@ -97,7 +98,10 @@ def logerror(failure: Failure, recv: Any) -> Failure:\n             robustApply, receiver, signal=signal, sender=sender, *arguments, **named\n         )\n         d.addErrback(logerror, receiver)\n-        d.addBoth(lambda result: (receiver, result))\n+        # TODO https://pylint.readthedocs.io/en/latest/user_guide/messages/warning/cell-var-from-loop.html",
      "comment": "The article suggests that the code doesn't work the way it looks, we should investigate if this indeed applies to our code (I would be surprised that signals are sent to wrong places as we would notice that).",
      "comment_id": 1505644114,
      "user": "wRAR",
      "created_at": "2024-02-28T09:35:45Z",
      "url": "https://github.com/scrapy/scrapy/pull/6253#discussion_r1505644114"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 6251,
      "file_path": "scrapy/http/request/rpc.py",
      "line": 10,
      "side": "RIGHT",
      "diff_hunk": "@@ -7,9 +7,13 @@\n import xmlrpc.client as xmlrpclib\n from typing import Any, Optional\n \n+from defusedxml import xmlrpc",
      "comment": "I think it's better to import `defusedxml.xmlrpc`, as `xmlrpc` is the name of the stdlib module so this can cause confusion (and maybe name clashes if we need to import the stdlib one in the future).",
      "comment_id": 1504947625,
      "user": "wRAR",
      "created_at": "2024-02-27T20:35:24Z",
      "url": "https://github.com/scrapy/scrapy/pull/6251#discussion_r1504947625"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 6251,
      "file_path": "scrapy/http/request/rpc.py",
      "line": 10,
      "side": "RIGHT",
      "diff_hunk": "@@ -7,9 +7,13 @@\n import xmlrpc.client as xmlrpclib\n from typing import Any, Optional\n \n+import defusedxml.xmlrpc as xml_rpc",
      "comment": "I don't think this alias is much better, as I think the only alias that makes sense here is something like `defusedxml_xmlrpc` and I don't think that's better than just importing `defusedxml.xmlrpc`, unless I'm missing some reasons why it's not possible.",
      "comment_id": 1504990112,
      "user": "wRAR",
      "created_at": "2024-02-27T21:06:28Z",
      "url": "https://github.com/scrapy/scrapy/pull/6251#discussion_r1504990112"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 5285,
      "file_path": "tests/test_commands.py",
      "line": 583,
      "side": "RIGHT",
      "diff_hunk": "@@ -580,7 +580,7 @@ def start_requests(self):\n \n     @contextmanager\n     def _create_file(self, content, name=None):\n-        tmpdir = self.mktemp()\n+        tmpdir = self.NamedTemporaryFile(delete=False)\n         os.mkdir(tmpdir)",
      "comment": "Not your fault, but this is a bit weird. I would expect we need to at least remove the file before we use its path for a folder. Using `mkdtemp` directly may be best. I see this is also used in a few more test files.",
      "comment_id": 733014032,
      "user": "Gallaecio",
      "created_at": "2021-10-20T17:49:58Z",
      "url": "https://github.com/scrapy/scrapy/pull/5285#discussion_r733014032"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 5285,
      "file_path": "tests/test_downloader_handlers.py",
      "line": 104,
      "side": "RIGHT",
      "diff_hunk": "@@ -100,7 +100,7 @@ def test_lazy_handlers(self):\n class FileTestCase(unittest.TestCase):\n \n     def setUp(self):\n-        self.tmpname = self.mktemp()\n+        self.tmpname = self.NamedTemporaryFile(delete=False)\n         with open(self.tmpname + '^', 'w') as f:",
      "comment": "Also weird. Not sure if `^` needs to be in the filename, but if it does, maybe the safest approach is to use `suffix` in `NamedTemporaryFile`.",
      "comment_id": 733015078,
      "user": "Gallaecio",
      "created_at": "2021-10-20T17:51:26Z",
      "url": "https://github.com/scrapy/scrapy/pull/5285#discussion_r733015078"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 5285,
      "file_path": "tests/test_commands.py",
      "line": 583,
      "side": "RIGHT",
      "diff_hunk": "@@ -580,7 +580,7 @@ def start_requests(self):\n \n     @contextmanager\n     def _create_file(self, content, name=None):\n-        tmpdir = self.mktemp()\n+        tmpdir = self.mkstemp()\n         os.mkdir(tmpdir)",
      "comment": "It turns out this is [a method of Twisted\u2019s TestCase](https://twistedmatrix.com/documents/8.1.0/api/twisted.trial.unittest.TestCase.html#mktemp), which [is now undocumented](https://twistedmatrix.com/trac/ticket/7849). That explains the `os.mkdir` call, which according to the old documentation is needed.\r\n\r\nWhat would you think about switching these 2 lines (and similar in other files) to `tmpdir = mkdtemp()`?",
      "comment_id": 733035246,
      "user": "Gallaecio",
      "created_at": "2021-10-20T18:19:35Z",
      "url": "https://github.com/scrapy/scrapy/pull/5285#discussion_r733035246"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 5285,
      "file_path": "scrapy/downloadermiddlewares/decompression.py",
      "line": 36,
      "side": "RIGHT",
      "diff_hunk": "@@ -31,7 +31,7 @@ def __init__(self):\n     def _is_tar(self, response):\n         archive = BytesIO(response.body)\n         try:\n-            tar_file = tarfile.open(name=mktemp(), fileobj=archive)\n+            tar_file = tarfile.open(name=mkstemp(), fileobj=archive)\n         except tarfile.ReadError:\n             return",
      "comment": "I think we should take the chance to make this code better by actually removing the temporary file. The current code (and the previous one) seems to leave it in the filesystem. Maybe do `tar_file_path = mkstemp()` before the `try`, and add a `finally` that removes the file.",
      "comment_id": 733038353,
      "user": "Gallaecio",
      "created_at": "2021-10-20T18:23:54Z",
      "url": "https://github.com/scrapy/scrapy/pull/5285#discussion_r733038353"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 5285,
      "file_path": "tests/test_commands.py",
      "line": 583,
      "side": "RIGHT",
      "diff_hunk": "@@ -580,7 +580,7 @@ def start_requests(self):\n \n     @contextmanager\n     def _create_file(self, content, name=None):\n-        tmpdir = self.mktemp()\n+        tmpdir = self.mkstemp()\n         os.mkdir(tmpdir)",
      "comment": "Oh interesting. So the unimportant `mktemp` in the tests wasn't actually the same. Just so I'm clear you're proposing to convert the `mktemp` usage in the tests into `tmpdir = mkdtemp()` and to remove the `os.mkdir`s?",
      "comment_id": 733047087,
      "user": "darakian",
      "created_at": "2021-10-20T18:36:01Z",
      "url": "https://github.com/scrapy/scrapy/pull/5285#discussion_r733047087"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 5285,
      "file_path": "scrapy/downloadermiddlewares/decompression.py",
      "line": 36,
      "side": "RIGHT",
      "diff_hunk": "@@ -31,7 +31,7 @@ def __init__(self):\n     def _is_tar(self, response):\n         archive = BytesIO(response.body)\n         try:\n-            tar_file = tarfile.open(name=mktemp(), fileobj=archive)\n+            tar_file = tarfile.open(name=mkstemp(), fileobj=archive)\n         except tarfile.ReadError:\n             return",
      "comment": "How about moving to `TemporaryFile` which gets cleaned up on close?\r\nhttps://docs.python.org/3/library/tempfile.html#tempfile.TemporaryFile",
      "comment_id": 733050298,
      "user": "darakian",
      "created_at": "2021-10-20T18:40:39Z",
      "url": "https://github.com/scrapy/scrapy/pull/5285#discussion_r733050298"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 5285,
      "file_path": "tests/test_commands.py",
      "line": 583,
      "side": "RIGHT",
      "diff_hunk": "@@ -580,7 +580,7 @@ def start_requests(self):\n \n     @contextmanager\n     def _create_file(self, content, name=None):\n-        tmpdir = self.mktemp()\n+        tmpdir = self.mkstemp()\n         os.mkdir(tmpdir)",
      "comment": "Yes, I think that would be the best approach. The fact that they removed `TestCase.mktemp` from the docs means it is not meant to be used.",
      "comment_id": 733053638,
      "user": "Gallaecio",
      "created_at": "2021-10-20T18:45:39Z",
      "url": "https://github.com/scrapy/scrapy/pull/5285#discussion_r733053638"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 5285,
      "file_path": "scrapy/downloadermiddlewares/decompression.py",
      "line": 36,
      "side": "RIGHT",
      "diff_hunk": "@@ -31,7 +31,7 @@ def __init__(self):\n     def _is_tar(self, response):\n         archive = BytesIO(response.body)\n         try:\n-            tar_file = tarfile.open(name=mktemp(), fileobj=archive)\n+            tar_file = tarfile.open(name=mkstemp(), fileobj=archive)\n         except tarfile.ReadError:\n             return",
      "comment": "The issue I see with that is that `TemporaryFile` returns a file object that may not have a path, and what we need here is a temporary path, the actual file object does not matter.\r\n\r\nHowever, I guess it makes sense to use `NamedTemporaryFile`. You can use it as a context manager and put the `try`-`except` within it, saving the need for a `finally`.",
      "comment_id": 733055645,
      "user": "Gallaecio",
      "created_at": "2021-10-20T18:48:39Z",
      "url": "https://github.com/scrapy/scrapy/pull/5285#discussion_r733055645"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 5285,
      "file_path": "tests/test_commands.py",
      "line": 583,
      "side": "RIGHT",
      "diff_hunk": "@@ -580,7 +580,7 @@ def start_requests(self):\n \n     @contextmanager\n     def _create_file(self, content, name=None):\n-        tmpdir = self.mktemp()\n+        tmpdir = self.mkstemp()\n         os.mkdir(tmpdir)",
      "comment": "Is https://github.com/scrapy/scrapy/pull/5285/commits/d82fcb0dc4f988a3a1a6e7cabc9e9c7390ea746b what you're thinking?",
      "comment_id": 733058999,
      "user": "darakian",
      "created_at": "2021-10-20T18:53:13Z",
      "url": "https://github.com/scrapy/scrapy/pull/5285#discussion_r733058999"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 5285,
      "file_path": "scrapy/downloadermiddlewares/decompression.py",
      "line": 34,
      "side": "RIGHT",
      "diff_hunk": "@@ -31,7 +31,7 @@ def __init__(self):\n     def _is_tar(self, response):\n         archive = BytesIO(response.body)\n         try:\n-            tar_file = tarfile.open(name=mktemp(), fileobj=archive)\n+            tar_file = tarfile.open(name=NamedTemporaryFile(), fileobj=archive)",
      "comment": "Did you run this test locally before pushing? The import does not match the class used here :slightly_smiling_face: \r\n\r\nAlso, I don\u2019t think this is how you are supposed to use `NamedTemporaryFile`. It should be:\r\n\r\n```py\r\nwith NamedTemporaryFile() as temporary_file:\r\n    try:\r\n        tar_file = tarfile.open(name=temporary_file.name, fileobj=archive)\r\n    ...\r\n```",
      "comment_id": 733064745,
      "user": "Gallaecio",
      "created_at": "2021-10-20T19:01:28Z",
      "url": "https://github.com/scrapy/scrapy/pull/5285#discussion_r733064745"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 5285,
      "file_path": "scrapy/downloadermiddlewares/decompression.py",
      "line": 34,
      "side": "RIGHT",
      "diff_hunk": "@@ -31,7 +31,7 @@ def __init__(self):\n     def _is_tar(self, response):\n         archive = BytesIO(response.body)\n         try:\n-            tar_file = tarfile.open(name=mktemp(), fileobj=archive)\n+            tar_file = tarfile.open(name=NamedTemporaryFile(), fileobj=archive)",
      "comment": "> Did you run this test locally before pushing?\r\n\r\nNope. That's what CI is for :)\r\n\r\nI did see the import after pushing and corrected that. Moved to the `with NamedTemporaryFile() ...` pattern as well.",
      "comment_id": 733066834,
      "user": "darakian",
      "created_at": "2021-10-20T19:04:30Z",
      "url": "https://github.com/scrapy/scrapy/pull/5285#discussion_r733066834"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 5285,
      "file_path": "tests/test_crawler.py",
      "line": 7,
      "side": "RIGHT",
      "diff_hunk": "@@ -5,6 +5,7 @@\n import sys\n import warnings\n from unittest import skipIf\n+from tempfile import mkstemp",
      "comment": ":lipstick: A-Z\r\n\r\n```suggestion\r\nfrom tempfile import mkstemp\r\nfrom unittest import skipIf\r\n```",
      "comment_id": 733068515,
      "user": "Gallaecio",
      "created_at": "2021-10-20T19:07:10Z",
      "url": "https://github.com/scrapy/scrapy/pull/5285#discussion_r733068515"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 5285,
      "file_path": "tests/test_downloader_handlers.py",
      "line": 6,
      "side": "RIGHT",
      "diff_hunk": "@@ -4,6 +4,7 @@\n import tempfile\n from typing import Optional, Type\n from unittest import mock\n+from tempfile import mkdtemp, mkstemp",
      "comment": ":lipstick: A-Z\r\n\r\n```suggestion\r\nimport tempfile\r\nfrom tempfile import mkdtemp, mkstemp\r\nfrom typing import Optional, Type\r\nfrom unittest import mock\r\n```\r\n\r\nYou could also take the chance to see where the `tempfile` module is used directly, maybe avoid that usage by extending `from tempfile import` as needed.",
      "comment_id": 733069705,
      "user": "Gallaecio",
      "created_at": "2021-10-20T19:08:54Z",
      "url": "https://github.com/scrapy/scrapy/pull/5285#discussion_r733069705"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 5285,
      "file_path": "tests/test_downloader_handlers.py",
      "line": 219,
      "side": "RIGHT",
      "diff_hunk": "@@ -215,8 +216,7 @@ class HttpTestCase(unittest.TestCase):\n     certfile = 'keys/localhost.crt'\n \n     def setUp(self):\n-        self.tmpname = self.mktemp()\n-        os.mkdir(self.tmpname)\n+        self.tmpname = self.mkdtemp()",
      "comment": "Still have the `self` here and in a few other places.\r\n\r\n```suggestion\r\n        self.tmpname = mkdtemp()\r\n```",
      "comment_id": 733070482,
      "user": "Gallaecio",
      "created_at": "2021-10-20T19:09:59Z",
      "url": "https://github.com/scrapy/scrapy/pull/5285#discussion_r733070482"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 5285,
      "file_path": "tests/test_feedexport.py",
      "line": 22,
      "side": "RIGHT",
      "diff_hunk": "@@ -19,6 +19,7 @@\n from unittest import mock\n from urllib.parse import urljoin, quote\n from urllib.request import pathname2url\n+from tempfile import mkdtemp",
      "comment": "```suggestion\r\nfrom tempfile import mkdtemp\r\nfrom unittest import mock\r\nfrom urllib.parse import urljoin, quote\r\nfrom urllib.request import pathname2url\r\n```",
      "comment_id": 733070835,
      "user": "Gallaecio",
      "created_at": "2021-10-20T19:10:32Z",
      "url": "https://github.com/scrapy/scrapy/pull/5285#discussion_r733070835"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 5285,
      "file_path": "tests/test_pipeline_crawl.py",
      "line": 14,
      "side": "RIGHT",
      "diff_hunk": "@@ -10,6 +10,8 @@\n from scrapy import signals\n from tests.mockserver import MockServer\n from tests.spiders import SimpleSpider\n+from tempfile import mkdtemp\n+",
      "comment": "```suggestion\r\nfrom tempfile import mkdtemp\r\n\r\nfrom scrapy import signals\r\nfrom tests.mockserver import MockServer\r\nfrom tests.spiders import SimpleSpider\r\n```",
      "comment_id": 733071368,
      "user": "Gallaecio",
      "created_at": "2021-10-20T19:11:20Z",
      "url": "https://github.com/scrapy/scrapy/pull/5285#discussion_r733071368"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 5285,
      "file_path": "tests/test_spiderloader/__init__.py",
      "line": 6,
      "side": "RIGHT",
      "diff_hunk": "@@ -5,6 +5,7 @@\n \n from zope.interface.verify import verifyObject\n from twisted.trial import unittest\n+from tempfile import mkdtemp",
      "comment": "```suggestion\r\nfrom tempfile import mkdtemp\r\n\r\nfrom zope.interface.verify import verifyObject\r\nfrom twisted.trial import unittest\r\n```",
      "comment_id": 733071636,
      "user": "Gallaecio",
      "created_at": "2021-10-20T19:11:40Z",
      "url": "https://github.com/scrapy/scrapy/pull/5285#discussion_r733071636"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 5285,
      "file_path": "tests/test_webclient.py",
      "line": 386,
      "side": "RIGHT",
      "diff_hunk": "@@ -382,7 +382,7 @@ def getURL(self, path):\n         return f\"https://127.0.0.1:{self.portno}/{path}\"\n \n     def setUp(self):\n-        self.tmpname = self.mktemp()\n+        self.tmpname = mkstemp()\n         os.mkdir(self.tmpname)",
      "comment": "```suggestion\r\n        self.tmpname = mkdtemp()\r\n```",
      "comment_id": 733072036,
      "user": "Gallaecio",
      "created_at": "2021-10-20T19:12:17Z",
      "url": "https://github.com/scrapy/scrapy/pull/5285#discussion_r733072036"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 5285,
      "file_path": "tests/test_downloader_handlers.py",
      "line": 110,
      "side": "RIGHT",
      "diff_hunk": "@@ -107,7 +107,7 @@ def test_lazy_handlers(self):\n class FileTestCase(unittest.TestCase):\n \n     def setUp(self):\n-        self.tmpname = self.mktemp()\n+        fd, self.tmpname = mkstemp()",
      "comment": "This actually creates the file and it's not deleted later. The old code only creates the file with the `^` suffix and deletes it in `tearDown`. As far as I can see the test just needs a temporary file with `^` as a suffix, so we can just use `suffix='^'` as proposed in a now hidden comment (not with a context manager though, as we don't want it to be deleted right away).",
      "comment_id": 844017508,
      "user": "wRAR",
      "created_at": "2022-04-06T14:25:41Z",
      "url": "https://github.com/scrapy/scrapy/pull/5285#discussion_r844017508"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 5285,
      "file_path": "scrapy/downloadermiddlewares/decompression.py",
      "line": 35,
      "side": "RIGHT",
      "diff_hunk": "@@ -30,10 +30,11 @@ def __init__(self):\n \n     def _is_tar(self, response):\n         archive = BytesIO(response.body)\n-        try:\n-            tar_file = tarfile.open(name=mktemp(), fileobj=archive)\n-        except tarfile.ReadError:\n-            return\n+        with NamedTemporaryFile() as temporary_file:\n+            try:\n+                tar_file = tarfile.open(name=temporary_file.name, fileobj=archive)",
      "comment": "[According to the documentation](https://docs.python.org/3/library/tarfile.html#tarfile.TarFile), the `name` parameter is optional. [We added it 13 years ago](https://github.com/scrapy/scrapy/commit/9022f84c05a13d58a03f24cc65439ccc109ee57b) because \u201c`None` is failing in some cases\u201d. But I have no idea what those cases would be. It may be that the Python version back then had a bug or something.\r\n\r\nI am thinking that we could remove the parameter altogether. If anyone can provide a scenario where it fails, we can try to address that scenario in a point release of Scrapy, this time documenting the issue and adding a test for it, which would be best in the long run.",
      "comment_id": 850444842,
      "user": "Gallaecio",
      "created_at": "2022-04-14T13:28:27Z",
      "url": "https://github.com/scrapy/scrapy/pull/5285#discussion_r850444842"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 5285,
      "file_path": "tests/test_downloader_handlers.py",
      "line": 110,
      "side": "RIGHT",
      "diff_hunk": "@@ -107,7 +107,7 @@ def test_lazy_handlers(self):\n class FileTestCase(unittest.TestCase):\n \n     def setUp(self):\n-        self.tmpname = self.mktemp()\n+        fd, self.tmpname = mkstemp()",
      "comment": "#5736 \r\n\r\nSo using `suffix='^'` indeed should work.",
      "comment_id": 1032424165,
      "user": "wRAR",
      "created_at": "2022-11-25T12:48:53Z",
      "url": "https://github.com/scrapy/scrapy/pull/5285#discussion_r1032424165"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 5285,
      "file_path": "scrapy/downloadermiddlewares/decompression.py",
      "line": 35,
      "side": "RIGHT",
      "diff_hunk": "@@ -30,10 +30,11 @@ def __init__(self):\n \n     def _is_tar(self, response):\n         archive = BytesIO(response.body)\n-        try:\n-            tar_file = tarfile.open(name=mktemp(), fileobj=archive)\n-        except tarfile.ReadError:\n-            return\n+        with NamedTemporaryFile() as temporary_file:\n+            try:\n+                tar_file = tarfile.open(name=temporary_file.name, fileobj=archive)",
      "comment": "This became irrelevant with the removal of the entire module.",
      "comment_id": 1495376638,
      "user": "Gallaecio",
      "created_at": "2024-02-20T07:55:15Z",
      "url": "https://github.com/scrapy/scrapy/pull/5285#discussion_r1495376638"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 5285,
      "file_path": "tests/test_downloader_handlers.py",
      "line": 110,
      "side": "RIGHT",
      "diff_hunk": "@@ -107,7 +107,7 @@ def test_lazy_handlers(self):\n class FileTestCase(unittest.TestCase):\n \n     def setUp(self):\n-        self.tmpname = self.mktemp()\n+        fd, self.tmpname = mkstemp()",
      "comment": "Done as part of the [merge with the main branch](https://github.com/scrapy/scrapy/pull/5285/commits/8cf1f9fb106a0b3cdee579d9b661035531ea7195).",
      "comment_id": 1495377032,
      "user": "Gallaecio",
      "created_at": "2024-02-20T07:55:40Z",
      "url": "https://github.com/scrapy/scrapy/pull/5285#discussion_r1495377032"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 6063,
      "file_path": "scrapy/downloadermiddlewares/httpcompression.py",
      "line": 91,
      "side": "RIGHT",
      "diff_hunk": "@@ -83,6 +83,38 @@ def process_response(self, request, response, spider):\n \n         return response\n \n+    def _handle_encoding(self, body, content_encoding):\n+        content_to_decode = body\n+\n+        separator = b\",\"\n+        for encodings in reversed(content_encoding):\n+            if separator in encodings:",
      "comment": "What about handling the comma issue earlier? i.e. (untested)\r\n\r\n```python\r\nencodings = reversed(\r\n    item.strip()\r\n    for value in content_encoding\r\n    for item in value.split(b\",\")\r\n)\r\n```\r\n\r\nThat should simplify the later code.",
      "comment_id": 1335597711,
      "user": "Gallaecio",
      "created_at": "2023-09-25T09:02:10Z",
      "url": "https://github.com/scrapy/scrapy/pull/6063#discussion_r1335597711"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 6063,
      "file_path": "scrapy/downloadermiddlewares/httpcompression.py",
      "line": 91,
      "side": "RIGHT",
      "diff_hunk": "@@ -83,6 +83,38 @@ def process_response(self, request, response, spider):\n \n         return response\n \n+    def _handle_encoding(self, body, content_encoding):\n+        content_to_decode = body\n+\n+        separator = b\",\"\n+        for encodings in reversed(content_encoding):\n+            if separator in encodings:",
      "comment": "Oh, I see, there\u2019s the editing of `Content-Encoding` to mind as well.",
      "comment_id": 1335599768,
      "user": "Gallaecio",
      "created_at": "2023-09-25T09:03:57Z",
      "url": "https://github.com/scrapy/scrapy/pull/6063#discussion_r1335599768"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 6063,
      "file_path": "scrapy/downloadermiddlewares/httpcompression.py",
      "line": 93,
      "side": "RIGHT",
      "diff_hunk": "@@ -83,6 +83,51 @@ def process_response(self, request, response, spider):\n \n         return response\n \n+    def _handle_encoding(self, body, content_encoding):\n+        content_to_decode = body\n+\n+        separator = b\",\"\n+        decoded_body = \"\"\n+        for index, encodings in reversed(list(enumerate(content_encoding))):\n+            if separator in encodings:\n+                decoded_body = \"\"",
      "comment": "I think this line is unnecessary, and would break scenarios with multiple headers where some of those headers include comma-separated encodings.",
      "comment_id": 1339608030,
      "user": "Gallaecio",
      "created_at": "2023-09-28T06:43:22Z",
      "url": "https://github.com/scrapy/scrapy/pull/6063#discussion_r1339608030"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 6235,
      "file_path": "tests/test_http_request.py",
      "line": 1457,
      "side": "RIGHT",
      "diff_hunk": "@@ -1426,6 +1426,62 @@ def test_from_response_valid_form_methods(self):\n             r = self.request_class.from_response(response)\n             self.assertEqual(r.method, expected)\n \n+    def test_form_response_with_invalid_formdata_type_error(self):\n+        \"\"\"Test that a ValueError is raised for non-iterable and non-dict formdata input\"\"\"\n+        response = _buildresponse(\n+            \"\"\"<html><body>\n+            <form action=\"/submit\" method=\"post\">\n+                <input type=\"text\" name=\"test\" value=\"value\">\n+            </form>\n+            </body></html>\"\"\"\n+        )\n+        with self.assertRaises(ValueError) as context:\n+            FormRequest.from_response(response, formdata=123)\n+\n+        self.assertIn(\n+            \"formdata should be a dict or iterable of tuples\", str(context.exception)\n+        )\n+\n+    def test_form_response_with_custom_invalid_formdata_value_error(self):\n+        \"\"\"Test that a ValueError is raised for fault-inducing iterable formdata input\"\"\"\n+        response = _buildresponse(\n+            \"\"\"<html><body>\n+                <form action=\"/submit\" method=\"post\">\n+                    <input type=\"text\" name=\"test\" value=\"value\">\n+                </form>\n+            </body></html>\"\"\"\n+        )\n+\n+        class CustomFormdata:\n+            def __iter__(self):\n+                raise ValueError(\"Custom iteration error for testing\")",
      "comment": "This feels too artificial, I think. `(\"a\",)` should work the same as `CustomFormdata()` below.",
      "comment_id": 1497374583,
      "user": "Gallaecio",
      "created_at": "2024-02-21T11:39:10Z",
      "url": "https://github.com/scrapy/scrapy/pull/6235#discussion_r1497374583"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 6236,
      "file_path": "tests/test_http_request.py",
      "line": 1657,
      "side": "RIGHT",
      "diff_hunk": "@@ -1642,6 +1642,26 @@ def test_replace_dumps_kwargs(self):\n             self.assertEqual(kwargs[\"ensure_ascii\"], True)\n             self.assertEqual(kwargs[\"allow_nan\"], True)\n \n+    def test_replacement_both_body_and_data_warns(self):\n+        \"\"\"Test that we can get a warning if both body and data are passed for branch coverage\"\"\"\n+        body1 = None\n+        body2 = b\"body\"\n+        data1 = {\n+            \"name1\": \"value1\",\n+        }\n+        data2 = {\n+            \"name2\": \"value2\",\n+        }\n+        r1 = self.request_class(url=\"http://www.example.com/\", data=data1, body=body1)\n+\n+        with mock.patch(\"warnings.warn\") as mock_warn:",
      "comment": "https://docs.pytest.org/en/latest/how-to/capture-warnings.html",
      "comment_id": 1497380068,
      "user": "Gallaecio",
      "created_at": "2024-02-21T11:44:03Z",
      "url": "https://github.com/scrapy/scrapy/pull/6236#discussion_r1497380068"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 6236,
      "file_path": "tests/test_http_request.py",
      "line": 1646,
      "side": "RIGHT",
      "diff_hunk": "@@ -1642,6 +1642,26 @@ def test_replace_dumps_kwargs(self):\n             self.assertEqual(kwargs[\"ensure_ascii\"], True)\n             self.assertEqual(kwargs[\"allow_nan\"], True)\n \n+    def test_replacement_both_body_and_data_warns(self):\n+        \"\"\"Test that we can get a warning if both body and data are passed for branch coverage\"\"\"",
      "comment": "Can you please remove the branch coverage mentions from here and other similar changes in other PRs? I don't think they are useful.",
      "comment_id": 1497425458,
      "user": "wRAR",
      "created_at": "2024-02-21T12:14:55Z",
      "url": "https://github.com/scrapy/scrapy/pull/6236#discussion_r1497425458"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 6232,
      "file_path": "tests/test_linkextractors.py",
      "line": 857,
      "side": "RIGHT",
      "diff_hunk": "@@ -851,3 +852,36 @@ def test_skip_bad_links(self):\n                 ),\n             ],\n         )\n+\n+    def test_link_allowed_is_false_with_empty_url(self):\n+        mock_link = Mock()",
      "comment": "Do you need to use `Mock` in these tests? It feels like `Link` could work, and `Mock` is usually left for cases where it is needed.",
      "comment_id": 1497329653,
      "user": "Gallaecio",
      "created_at": "2024-02-21T11:02:00Z",
      "url": "https://github.com/scrapy/scrapy/pull/6232#discussion_r1497329653"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 6232,
      "file_path": "tests/test_linkextractors.py",
      "line": 867,
      "side": "RIGHT",
      "diff_hunk": "@@ -851,3 +852,36 @@ def test_skip_bad_links(self):\n                 ),\n             ],\n         )\n+\n+    def test_link_allowed_is_false_with_empty_url(self):\n+        mock_link = Mock()\n+        mock_link.url = \"\"\n+        expected = False\n+\n+        actual = LxmlLinkExtractor()._link_allowed(mock_link)\n+\n+        self.assertEqual(expected, actual)\n+\n+    def test_link_allowed_is_false_with_bad_url_prefix(self):\n+        mock_link = Mock()\n+        mock_link.url = \"htp://should_be_http.com\"",
      "comment": "`should_be_http.com` could become a real domain in the future. Please use a domain ending in `.example` (instead of `.com`) when needing a custom domain name.",
      "comment_id": 1497333492,
      "user": "Gallaecio",
      "created_at": "2024-02-21T11:03:57Z",
      "url": "https://github.com/scrapy/scrapy/pull/6232#discussion_r1497333492"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 6232,
      "file_path": "tests/test_linkextractors.py",
      "line": 887,
      "side": "RIGHT",
      "diff_hunk": "@@ -851,3 +852,36 @@ def test_skip_bad_links(self):\n                 ),\n             ],\n         )\n+\n+    def test_link_allowed_is_false_with_empty_url(self):\n+        mock_link = Mock()\n+        mock_link.url = \"\"\n+        expected = False\n+\n+        actual = LxmlLinkExtractor()._link_allowed(mock_link)\n+\n+        self.assertEqual(expected, actual)\n+\n+    def test_link_allowed_is_false_with_bad_url_prefix(self):\n+        mock_link = Mock()\n+        mock_link.url = \"htp://should_be_http.com\"\n+        expected = False\n+\n+        actual = LxmlLinkExtractor()._link_allowed(mock_link)\n+\n+        self.assertEqual(expected, actual)\n+\n+    def test_link_allowed_is_false_with_missing_url_prefix(self):\n+        mock_link = Mock()\n+        mock_link.url = \"should_have_prefix.com\"\n+        expected = False\n+\n+        actual = LxmlLinkExtractor()._link_allowed(mock_link)\n+\n+        self.assertEqual(expected, actual)\n+\n+    def test_link_allowed_raises_with_none_url(self):\n+        mock_link = Mock()\n+        mock_link.url = None\n+\n+        self.assertRaises(AttributeError, LxmlLinkExtractor()._link_allowed, mock_link)",
      "comment": "This is not a good test, because [`Link.url` should never be `None`](https://github.com/scrapy/scrapy/blob/ee1189512f652fae72f013c9d4759976b8b69994/scrapy/link.py#L33-L35).\r\n\r\n",
      "comment_id": 1497336948,
      "user": "Gallaecio",
      "created_at": "2024-02-21T11:06:29Z",
      "url": "https://github.com/scrapy/scrapy/pull/6232#discussion_r1497336948"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 6232,
      "file_path": "tests/test_linkextractors.py",
      "line": 881,
      "side": "RIGHT",
      "diff_hunk": "@@ -851,3 +852,36 @@ def test_skip_bad_links(self):\n                 ),\n             ],\n         )\n+\n+    def test_link_allowed_is_false_with_empty_url(self):\n+        mock_link = Mock()\n+        mock_link.url = \"\"\n+        expected = False\n+\n+        actual = LxmlLinkExtractor()._link_allowed(mock_link)\n+\n+        self.assertEqual(expected, actual)\n+\n+    def test_link_allowed_is_false_with_bad_url_prefix(self):\n+        mock_link = Mock()\n+        mock_link.url = \"htp://should_be_http.com\"\n+        expected = False\n+\n+        actual = LxmlLinkExtractor()._link_allowed(mock_link)\n+\n+        self.assertEqual(expected, actual)\n+\n+    def test_link_allowed_is_false_with_missing_url_prefix(self):\n+        mock_link = Mock()\n+        mock_link.url = \"should_have_prefix.com\"\n+        expected = False\n+\n+        actual = LxmlLinkExtractor()._link_allowed(mock_link)\n+\n+        self.assertEqual(expected, actual)",
      "comment": ":lipstick: This is a very personal opinion, feel free to ignore it, but I feel like a more compact version of these tests would still be readable:\r\n\r\n```suggestion\r\n    def test_link_allowed_is_false_with_missing_url_prefix(self):\r\n        link = Link(\"should_have_prefix.example\")\r\n        self.assertFalse(LxmlLinkExtractor()._link_allowed(link))\r\n```",
      "comment_id": 1497339868,
      "user": "Gallaecio",
      "created_at": "2024-02-21T11:08:45Z",
      "url": "https://github.com/scrapy/scrapy/pull/6232#discussion_r1497339868"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 4111,
      "file_path": "scrapy/extensions/logstats.py",
      "line": 55,
      "side": "RIGHT",
      "diff_hunk": "@@ -35,18 +38,25 @@ def spider_opened(self, spider):\n         self.task.start(self.interval)\n \n     def log(self, spider):\n-        items = self.stats.get_value('item_scraped_count', 0)\n-        pages = self.stats.get_value('response_received_count', 0)\n-        irate = (items - self.itemsprev) * self.multiplier\n-        prate = (pages - self.pagesprev) * self.multiplier\n-        self.pagesprev, self.itemsprev = pages, items\n+        self.calculate_stats()\n \n         msg = (\"Crawled %(pages)d pages (at %(pagerate)d pages/min), \"\n                \"scraped %(items)d items (at %(itemrate)d items/min)\")\n-        log_args = {'pages': pages, 'pagerate': prate,\n-                    'items': items, 'itemrate': irate}\n+        log_args = {'pages': self.pages, 'pagerate': self.prate,\n+                    'items': self.items, 'itemrate': self.irate}\n         logger.info(msg, log_args, extra={'spider': spider})\n \n     def spider_closed(self, spider, reason):\n         if self.task and self.task.running:\n             self.task.stop()\n+\n+        self.calculate_stats()\n+        self.stats.set_value('IPM', self.irate)\n+        self.stats.set_value('RPM', self.prate)",
      "comment": ":lipstick:  I think `items_per_minute` and `requests_per_minute` would be a better choice here.",
      "comment_id": 340487893,
      "user": "Gallaecio",
      "created_at": "2019-10-30T08:49:12Z",
      "url": "https://github.com/scrapy/scrapy/pull/4111#discussion_r340487893"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 4111,
      "file_path": "scrapy/extensions/logstats.py",
      "line": 55,
      "side": "RIGHT",
      "diff_hunk": "@@ -35,18 +38,25 @@ def spider_opened(self, spider):\n         self.task.start(self.interval)\n \n     def log(self, spider):\n-        items = self.stats.get_value('item_scraped_count', 0)\n-        pages = self.stats.get_value('response_received_count', 0)\n-        irate = (items - self.itemsprev) * self.multiplier\n-        prate = (pages - self.pagesprev) * self.multiplier\n-        self.pagesprev, self.itemsprev = pages, items\n+        self.calculate_stats()\n \n         msg = (\"Crawled %(pages)d pages (at %(pagerate)d pages/min), \"\n                \"scraped %(items)d items (at %(itemrate)d items/min)\")\n-        log_args = {'pages': pages, 'pagerate': prate,\n-                    'items': items, 'itemrate': irate}\n+        log_args = {'pages': self.pages, 'pagerate': self.prate,\n+                    'items': self.items, 'itemrate': self.irate}\n         logger.info(msg, log_args, extra={'spider': spider})\n \n     def spider_closed(self, spider, reason):\n         if self.task and self.task.running:\n             self.task.stop()\n+\n+        self.calculate_stats()\n+        self.stats.set_value('IPM', self.irate)\n+        self.stats.set_value('RPM', self.prate)",
      "comment": "Thanks @Gallaecio! I'll update this one along with the tests. Please don't merge this one yet as I'd like to have tests on this module. Marking it as `WIP:` at the moment.",
      "comment_id": 340539659,
      "user": "BurnzZ",
      "created_at": "2019-10-30T10:38:16Z",
      "url": "https://github.com/scrapy/scrapy/pull/4111#discussion_r340539659"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 6213,
      "file_path": "scrapy/utils/request.py",
      "line": 160,
      "side": "RIGHT",
      "diff_hunk": "@@ -258,32 +141,22 @@ def __init__(self, crawler: Optional[\"Crawler\"] = None):\n                 \"REQUEST_FINGERPRINTER_IMPLEMENTATION\"\n             )\n         else:\n-            implementation = \"2.6\"\n-        if implementation == \"2.6\":\n+            implementation = \"SENTINEL\"\n+\n+        if implementation == \"SENTINEL\":\n+            self._fingerprint = fingerprint\n+        elif implementation == \"2.7\":\n             message = (\n-                \"'2.6' is a deprecated value for the \"\n-                \"'REQUEST_FINGERPRINTER_IMPLEMENTATION' setting.\\n\"\n-                \"\\n\"\n-                \"It is also the default value. In other words, it is normal \"\n-                \"to get this warning if you have not defined a value for the \"\n-                \"'REQUEST_FINGERPRINTER_IMPLEMENTATION' setting. This is so \"\n-                \"for backward compatibility reasons, but it will change in a \"\n-                \"future version of Scrapy.\\n\"\n-                \"\\n\"\n-                \"See the documentation of the \"\n-                \"'REQUEST_FINGERPRINTER_IMPLEMENTATION' setting for \"\n-                \"information on how to handle this deprecation.\"\n+                \"'REQUEST_FINGERPRINTER_IMPLEMENTATION' is a deprecated setting.\\n\"\n+                \"And it will be removed in future version of Scrapy.\"\n             )\n             warnings.warn(message, category=ScrapyDeprecationWarning, stacklevel=2)\n-            self._fingerprint = _request_fingerprint_as_bytes\n-        elif implementation == \"2.7\":\n             self._fingerprint = fingerprint\n         else:\n             raise ValueError(\n                 f\"Got an invalid value on setting \"\n                 f\"'REQUEST_FINGERPRINTER_IMPLEMENTATION': \"\n-                f\"{implementation!r}. Valid values are '2.6' (deprecated) \"\n-                f\"and '2.7'.\"\n+                f\"{implementation!r}. Valid values are '2.7' and 'SENTINEL'.\"\n             )",
      "comment": "What about:\r\n\r\n```python\r\nif implementation != \"SENTINEL\":\r\n    warn(\u2026)\r\nself._fingerprint = fingerprint\r\n```\r\n\r\nto replace the whole thing?\r\n\r\ni.e. We no longer care if they use an invalid value or not, we ignore whatever value they set, and just warn them to stop using the setting.",
      "comment_id": 1473047751,
      "user": "Gallaecio",
      "created_at": "2024-01-31T15:43:48Z",
      "url": "https://github.com/scrapy/scrapy/pull/6213#discussion_r1473047751"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 6213,
      "file_path": "scrapy/utils/test.py",
      "line": 79,
      "side": "LEFT",
      "diff_hunk": "@@ -76,7 +76,6 @@ class TestSpider(Spider):\n def get_crawler(\n     spidercls: Optional[Type[Spider]] = None,\n     settings_dict: Optional[Dict[str, Any]] = None,\n-    prevent_warnings: bool = True,",
      "comment": "I think we might want to keep this one here, as this is part of the public API. Not only for backward compatibility, but also forward compatibility, maybe we will need to set some default settings like these in the future.\r\n\r\nAlthough you will probably need to add `del prevent_warnings` in the beginning of the implementation so that linters do not complain about the unused parameter.",
      "comment_id": 1473050375,
      "user": "Gallaecio",
      "created_at": "2024-01-31T15:45:37Z",
      "url": "https://github.com/scrapy/scrapy/pull/6213#discussion_r1473050375"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 6213,
      "file_path": "scrapy/utils/test.py",
      "line": 90,
      "side": "RIGHT",
      "diff_hunk": "@@ -87,7 +87,7 @@ def get_crawler(\n     # Set by default settings that prevent deprecation warnings.\n     settings: Dict[str, Any] = {}\n     if prevent_warnings:\n-        settings[\"REQUEST_FINGERPRINTER_IMPLEMENTATION\"] = \"2.7\"\n+        pass",
      "comment": "Seems that work as well, local pre-commit pass, just pushed. cc: @Gallaecio ",
      "comment_id": 1473100710,
      "user": "Laerte",
      "created_at": "2024-01-31T16:18:49Z",
      "url": "https://github.com/scrapy/scrapy/pull/6213#discussion_r1473100710"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 6213,
      "file_path": "scrapy/utils/test.py",
      "line": 90,
      "side": "RIGHT",
      "diff_hunk": "@@ -87,7 +87,7 @@ def get_crawler(\n     # Set by default settings that prevent deprecation warnings.\n     settings: Dict[str, Any] = {}\n     if prevent_warnings:\n-        settings[\"REQUEST_FINGERPRINTER_IMPLEMENTATION\"] = \"2.7\"\n+        pass",
      "comment": "(if some linters complain and these lines are needed, we should add some comments to them to explain why they are needed)",
      "comment_id": 1473101583,
      "user": "wRAR",
      "created_at": "2024-01-31T16:19:22Z",
      "url": "https://github.com/scrapy/scrapy/pull/6213#discussion_r1473101583"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 4972,
      "file_path": "scrapy/downloadermiddlewares/stats.py",
      "line": 26,
      "side": "RIGHT",
      "diff_hunk": "@@ -24,7 +23,7 @@ def process_request(self, request, spider):\n     def process_response(self, request, response, spider):\n         self.stats.inc_value('downloader/response_count', spider=spider)\n         self.stats.inc_value(f'downloader/response_status_count/{response.status}', spider=spider)\n-        reslen = len(response_httprepr(response))\n+        reslen = len(response.body)",
      "comment": "This seems to no longer take into account headers and such. I think the right solution is to create an alternative to `response_httprepr` that, without creating a new bytes object, providers the length of all parts involved.",
      "comment_id": 568427408,
      "user": "Gallaecio",
      "created_at": "2021-02-02T08:58:14Z",
      "url": "https://github.com/scrapy/scrapy/pull/4972#discussion_r568427408"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 4972,
      "file_path": "scrapy/downloadermiddlewares/stats.py",
      "line": 26,
      "side": "RIGHT",
      "diff_hunk": "@@ -24,7 +23,7 @@ def process_request(self, request, spider):\n     def process_response(self, request, response, spider):\n         self.stats.inc_value('downloader/response_count', spider=spider)\n         self.stats.inc_value(f'downloader/response_status_count/{response.status}', spider=spider)\n-        reslen = len(response_httprepr(response))\n+        reslen = len(response.body)",
      "comment": "@Gallaecio \r\n`headers.to_string` used inside `response_httprepr` also duplicates headers in memory just like response_httprepr duplicates response.body\r\nhttps://github.com/scrapy/scrapy/blob/26836c4e1ae9588ee173c5977fc6611364ca7cc7/scrapy/utils/response.py#L57-L60\r\n\r\nhttps://github.com/scrapy/scrapy/blob/26836c4e1ae9588ee173c5977fc6611364ca7cc7/scrapy/http/headers.py#L75-L76\r\n\r\nI think that each base http structure (request, response, headers, cookies etc.) needs to have it's own `get_size` method that calculate it's own size without duplicating it in memory as  raw `str` representation. ",
      "comment_id": 568459002,
      "user": "GeorgeA92",
      "created_at": "2021-02-02T09:43:20Z",
      "url": "https://github.com/scrapy/scrapy/pull/4972#discussion_r568459002"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 4972,
      "file_path": "scrapy/downloadermiddlewares/stats.py",
      "line": 26,
      "side": "RIGHT",
      "diff_hunk": "@@ -24,7 +23,7 @@ def process_request(self, request, spider):\n     def process_response(self, request, response, spider):\n         self.stats.inc_value('downloader/response_count', spider=spider)\n         self.stats.inc_value(f'downloader/response_status_count/{response.status}', spider=spider)\n-        reslen = len(response_httprepr(response))\n+        reslen = len(response.body)",
      "comment": "I think we basically need to replace all those functions that generate strings with functions that calculate sizes, yes.",
      "comment_id": 568471951,
      "user": "Gallaecio",
      "created_at": "2021-02-02T10:01:07Z",
      "url": "https://github.com/scrapy/scrapy/pull/4972#discussion_r568471951"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 4972,
      "file_path": "scrapy/downloadermiddlewares/stats.py",
      "line": 29,
      "side": "RIGHT",
      "diff_hunk": "@@ -1,7 +1,32 @@\n from scrapy.exceptions import NotConfigured\n+from scrapy.utils.python import global_object_name, to_bytes\n from scrapy.utils.request import request_httprepr\n-from scrapy.utils.response import response_httprepr\n-from scrapy.utils.python import global_object_name\n+\n+from twisted.web import http\n+\n+\n+def get_header_size(headers):\n+    if headers is None:\n+        return None\n+    size = 0\n+    for key, value in headers.items():\n+        if isinstance(value, bytes):\n+            size += len(b\": \") + len(key) + len(value)\n+        elif isinstance(value, (list, tuple)):\n+            for v in value:\n+                size += len(b\": \") + len(key) + len(v)\n+    return size + len(b'\\r\\n') * (len(headers.keys()) - 1)\n+\n+\n+def get_status_size(response_status):\n+    values = [\n+        9,\n+        len(to_bytes(str(response_status))),\n+        1,\n+        len(to_bytes(http.RESPONSES.get(response_status, b''))),\n+        2,\n+    ]\n+    return sum(values)",
      "comment": "```suggestion\r\n    return (\r\n        9  # b\"HTTP/1.1 \"\r\n        + len(to_bytes(str(response_status)))\r\n        + 1  # \" \"\r\n        + len(to_bytes(http.RESPONSES.get(response_status, b\"\")))\r\n        + 2  # b\"\\r\\n\"\r\n    )\r\n```\r\nAdding comments for future reference. Also, since we're optimizing memory usage, building a list (and assigning it to a variable) has an unnecessary overhead (even more so than a tuple, because of their mutability).\r\nGoing even further, the integers could be consolidated, but that might be counter-productive in terms of readability.",
      "comment_id": 701310543,
      "user": "elacuesta",
      "created_at": "2021-09-02T18:03:34Z",
      "url": "https://github.com/scrapy/scrapy/pull/4972#discussion_r701310543"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 4972,
      "file_path": "scrapy/downloadermiddlewares/stats.py",
      "line": 29,
      "side": "RIGHT",
      "diff_hunk": "@@ -1,7 +1,32 @@\n from scrapy.exceptions import NotConfigured\n+from scrapy.utils.python import global_object_name, to_bytes\n from scrapy.utils.request import request_httprepr\n-from scrapy.utils.response import response_httprepr\n-from scrapy.utils.python import global_object_name\n+\n+from twisted.web import http\n+\n+\n+def get_header_size(headers):\n+    if headers is None:\n+        return None\n+    size = 0\n+    for key, value in headers.items():\n+        if isinstance(value, bytes):\n+            size += len(b\": \") + len(key) + len(value)\n+        elif isinstance(value, (list, tuple)):\n+            for v in value:\n+                size += len(b\": \") + len(key) + len(v)\n+    return size + len(b'\\r\\n') * (len(headers.keys()) - 1)\n+\n+\n+def get_status_size(response_status):\n+    values = [\n+        9,\n+        len(to_bytes(str(response_status))),\n+        1,\n+        len(to_bytes(http.RESPONSES.get(response_status, b''))),\n+        2,\n+    ]\n+    return sum(values)",
      "comment": "@elacuesta related codelines changed in https://github.com/GeorgeA92/scrapy/commit/d7b3cbfbaab7c040d306bf9be0a64c2e144accc2",
      "comment_id": 709583820,
      "user": "GeorgeA92",
      "created_at": "2021-09-15T21:20:29Z",
      "url": "https://github.com/scrapy/scrapy/pull/4972#discussion_r709583820"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 4972,
      "file_path": "scrapy/downloadermiddlewares/stats.py",
      "line": 21,
      "side": "RIGHT",
      "diff_hunk": "@@ -1,7 +1,26 @@\n from scrapy.exceptions import NotConfigured\n+from scrapy.utils.python import global_object_name, to_bytes\n from scrapy.utils.request import request_httprepr\n-from scrapy.utils.response import response_httprepr\n-from scrapy.utils.python import global_object_name\n+\n+from twisted.web import http\n+\n+\n+def get_header_size(headers):\n+    size = 0\n+    for key, value in headers.items():\n+        if isinstance(value, (list, tuple)):\n+            for v in value:\n+                size += len(b\": \") + len(key) + len(v)\n+    return size + len(b'\\r\\n') * (len(headers.keys()) - 1)\n+\n+\n+def get_status_size(response_status):\n+    return sum((\n+        9,  # b\"HTTP/1.1 \"\n+        len(to_bytes(str(response_status))),\n+        1,  # \" \"",
      "comment": "```suggestion\r\n        13,  # b\"HTTP/1.1 <100-599> \"\r\n```",
      "comment_id": 716022532,
      "user": "Gallaecio",
      "created_at": "2021-09-25T10:19:17Z",
      "url": "https://github.com/scrapy/scrapy/pull/4972#discussion_r716022532"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 4972,
      "file_path": "scrapy/downloadermiddlewares/stats.py",
      "line": 46,
      "side": "RIGHT",
      "diff_hunk": "@@ -24,7 +43,7 @@ def process_request(self, request, spider):\n     def process_response(self, request, response, spider):\n         self.stats.inc_value('downloader/response_count', spider=spider)\n         self.stats.inc_value(f'downloader/response_status_count/{response.status}', spider=spider)\n-        reslen = len(response_httprepr(response))\n+        reslen = len(response.body) + get_header_size(response.headers) + get_status_size(response.status) + 4",
      "comment": "It looks like this was the only usage of `response_httprepr`. May be deprecate the function? (i.e. log a deprecation warning when it is used, lookup usage of `ScrapyDeprecation` in code).\r\n\r\nAlso, maybe worth commenting that 4 stands for the 2 `\\r\\n` between those 3 sections.",
      "comment_id": 716022853,
      "user": "Gallaecio",
      "created_at": "2021-09-25T10:22:04Z",
      "url": "https://github.com/scrapy/scrapy/pull/4972#discussion_r716022853"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 4972,
      "file_path": "tests/test_downloadermiddleware_stats.py",
      "line": 47,
      "side": "RIGHT",
      "diff_hunk": "@@ -37,6 +39,17 @@ def test_process_response(self):\n         self.mw.process_response(self.req, self.res, self.spider)\n         self.assertStatsEqual('downloader/response_count', 1)\n \n+    def test_response_len(self):\n+        body = (b'', b'not_empty')  # empty/notempty body\n+        headers = ({}, {'lang': 'en'}, {'lang': 'en', 'User-Agent': 'scrapy'})  # 0 headers, 1h and 2h\n+        test_responses = [\n+            Response(url='scrapytest.org', status=200, body=r[0], headers=r[1])\n+            for r in product(body, headers)]  # form test responses with all combinations of body/headers",
      "comment": ":lipstick: \r\n```suggestion\r\n        test_responses = [\r\n            Response(\r\n                url='https://scrapy.org/',\r\n                status=200,\r\n                body=body,\r\n                headers=headers,\r\n            )\r\n            for body, headers in product(body, headers)\r\n        ]\r\n```",
      "comment_id": 716023600,
      "user": "Gallaecio",
      "created_at": "2021-09-25T10:29:57Z",
      "url": "https://github.com/scrapy/scrapy/pull/4972#discussion_r716023600"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 4972,
      "file_path": "scrapy/downloadermiddlewares/stats.py",
      "line": 21,
      "side": "RIGHT",
      "diff_hunk": "@@ -1,7 +1,26 @@\n from scrapy.exceptions import NotConfigured\n+from scrapy.utils.python import global_object_name, to_bytes\n from scrapy.utils.request import request_httprepr\n-from scrapy.utils.response import response_httprepr\n-from scrapy.utils.python import global_object_name\n+\n+from twisted.web import http\n+\n+\n+def get_header_size(headers):\n+    size = 0\n+    for key, value in headers.items():\n+        if isinstance(value, (list, tuple)):\n+            for v in value:\n+                size += len(b\": \") + len(key) + len(v)\n+    return size + len(b'\\r\\n') * (len(headers.keys()) - 1)\n+\n+\n+def get_status_size(response_status):\n+    return sum((\n+        9,  # b\"HTTP/1.1 \"\n+        len(to_bytes(str(response_status))),\n+        1,  # \" \"",
      "comment": "function optimized https://github.com/scrapy/scrapy/pull/4972/commits/7a8c2541f2d4d5fc1994c6f62f3a5c2050385593",
      "comment_id": 720561069,
      "user": "GeorgeA92",
      "created_at": "2021-10-01T21:58:25Z",
      "url": "https://github.com/scrapy/scrapy/pull/4972#discussion_r720561069"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 4972,
      "file_path": "scrapy/downloadermiddlewares/stats.py",
      "line": 46,
      "side": "RIGHT",
      "diff_hunk": "@@ -24,7 +43,7 @@ def process_request(self, request, spider):\n     def process_response(self, request, response, spider):\n         self.stats.inc_value('downloader/response_count', spider=spider)\n         self.stats.inc_value(f'downloader/response_status_count/{response.status}', spider=spider)\n-        reslen = len(response_httprepr(response))\n+        reslen = len(response.body) + get_header_size(response.headers) + get_status_size(response.status) + 4",
      "comment": "explanation (comment) added https://github.com/scrapy/scrapy/pull/4972/commits/915bd9cca933f3050250186b0479c9c71e475751\r\n`response_httprepr` deprecated https://github.com/scrapy/scrapy/pull/4972/commits/f0a4d7857c282bf52829455d3300f3b28e366cdb",
      "comment_id": 720561110,
      "user": "GeorgeA92",
      "created_at": "2021-10-01T21:58:31Z",
      "url": "https://github.com/scrapy/scrapy/pull/4972#discussion_r720561110"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 4972,
      "file_path": "tests/test_downloadermiddleware_stats.py",
      "line": 47,
      "side": "RIGHT",
      "diff_hunk": "@@ -37,6 +39,17 @@ def test_process_response(self):\n         self.mw.process_response(self.req, self.res, self.spider)\n         self.assertStatsEqual('downloader/response_count', 1)\n \n+    def test_response_len(self):\n+        body = (b'', b'not_empty')  # empty/notempty body\n+        headers = ({}, {'lang': 'en'}, {'lang': 'en', 'User-Agent': 'scrapy'})  # 0 headers, 1h and 2h\n+        test_responses = [\n+            Response(url='scrapytest.org', status=200, body=r[0], headers=r[1])\n+            for r in product(body, headers)]  # form test responses with all combinations of body/headers",
      "comment": "@Gallaecio  fixed https://github.com/scrapy/scrapy/pull/4972/commits/fbdc6a9a25b3b457d509580349e286e5c5d5771e",
      "comment_id": 720561134,
      "user": "GeorgeA92",
      "created_at": "2021-10-01T21:58:36Z",
      "url": "https://github.com/scrapy/scrapy/pull/4972#discussion_r720561134"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 4972,
      "file_path": "tests/test_downloadermiddleware_stats.py",
      "line": 47,
      "side": "RIGHT",
      "diff_hunk": "@@ -37,6 +39,17 @@ def test_process_response(self):\n         self.mw.process_response(self.req, self.res, self.spider)\n         self.assertStatsEqual('downloader/response_count', 1)\n \n+    def test_response_len(self):\n+        body = (b'', b'not_empty')  # empty/notempty body\n+        headers = ({}, {'lang': 'en'}, {'lang': 'en', 'User-Agent': 'scrapy'})  # 0 headers, 1h and 2h\n+        test_responses = [\n+            Response(url='scrapytest.org', status=200, body=r[0], headers=r[1])\n+            for r in product(body, headers)]  # form test responses with all combinations of body/headers",
      "comment": "The used URL is still invalid (no scheme), and points to a domain we do not own which, based on recent experience, could eventually be a NSFW website.",
      "comment_id": 720636651,
      "user": "Gallaecio",
      "created_at": "2021-10-02T06:33:48Z",
      "url": "https://github.com/scrapy/scrapy/pull/4972#discussion_r720636651"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 4972,
      "file_path": "tests/test_downloadermiddleware_stats.py",
      "line": 47,
      "side": "RIGHT",
      "diff_hunk": "@@ -37,6 +39,17 @@ def test_process_response(self):\n         self.mw.process_response(self.req, self.res, self.spider)\n         self.assertStatsEqual('downloader/response_count', 1)\n \n+    def test_response_len(self):\n+        body = (b'', b'not_empty')  # empty/notempty body\n+        headers = ({}, {'lang': 'en'}, {'lang': 'en', 'User-Agent': 'scrapy'})  # 0 headers, 1h and 2h\n+        test_responses = [\n+            Response(url='scrapytest.org', status=200, body=r[0], headers=r[1])\n+            for r in product(body, headers)]  # form test responses with all combinations of body/headers",
      "comment": "@Gallaecio I think that in this specific case - it is not an issue. This test creates `Response` objects from scratch without sending requests.",
      "comment_id": 720665827,
      "user": "GeorgeA92",
      "created_at": "2021-10-02T11:13:41Z",
      "url": "https://github.com/scrapy/scrapy/pull/4972#discussion_r720665827"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 4972,
      "file_path": "scrapy/utils/response.py",
      "line": 55,
      "side": "RIGHT",
      "diff_hunk": "@@ -50,6 +51,7 @@ def response_status_message(status: Union[bytes, float, int, str]) -> str:\n     return f'{status_int} {to_unicode(message)}'\n \n \n+@deprecated\n def response_httprepr(response: Response) -> bytes:",
      "comment": "@wRAR FYI this function is deprecated here (and removed in 2.11) but never mentioned in the [release logs](https://docs.scrapy.org/en/2.10/news.html) (nor its removal)",
      "comment_id": 1454122081,
      "user": "mario-stylesage",
      "created_at": "2024-01-16T22:13:13Z",
      "url": "https://github.com/scrapy/scrapy/pull/4972#discussion_r1454122081"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 4972,
      "file_path": "scrapy/utils/response.py",
      "line": 55,
      "side": "RIGHT",
      "diff_hunk": "@@ -50,6 +51,7 @@ def response_status_message(status: Union[bytes, float, int, str]) -> str:\n     return f'{status_int} {to_unicode(message)}'\n \n \n+@deprecated\n def response_httprepr(response: Response) -> bytes:",
      "comment": "Great catch, I\u2019ve logged https://github.com/scrapy/scrapy/issues/6207.",
      "comment_id": 1454977562,
      "user": "Gallaecio",
      "created_at": "2024-01-17T08:49:38Z",
      "url": "https://github.com/scrapy/scrapy/pull/4972#discussion_r1454977562"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 6181,
      "file_path": "scrapy/crawler.py",
      "line": 186,
      "side": "RIGHT",
      "diff_hunk": "@@ -178,6 +178,51 @@ def stop(self) -> Generator[Deferred, Any, None]:\n             assert self.engine\n             yield maybeDeferred(self.engine.stop)\n \n+    @staticmethod\n+    def _get_component(component_class, components):\n+        for component in components:\n+            if (\n+                type(component)  # pylint: disable=unidiomatic-typecheck\n+                is component_class",
      "comment": "I think it'd be good to check what's the best behavor here, based on the use cases in the wild: should the default be to match the type exactly, or to use ininstance (i.e. allow subclasses).",
      "comment_id": 1432994575,
      "user": "kmike",
      "created_at": "2023-12-20T17:26:51Z",
      "url": "https://github.com/scrapy/scrapy/pull/6181#discussion_r1432994575"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 6181,
      "file_path": "scrapy/crawler.py",
      "line": 186,
      "side": "RIGHT",
      "diff_hunk": "@@ -178,6 +178,51 @@ def stop(self) -> Generator[Deferred, Any, None]:\n             assert self.engine\n             yield maybeDeferred(self.engine.stop)\n \n+    @staticmethod\n+    def _get_component(component_class, components):\n+        for component in components:\n+            if (\n+                type(component)  # pylint: disable=unidiomatic-typecheck\n+                is component_class",
      "comment": "We could add a boolean parameter to control that, but I guess even then we should check use cases to choose a good default.",
      "comment_id": 1433821045,
      "user": "Gallaecio",
      "created_at": "2023-12-21T09:44:11Z",
      "url": "https://github.com/scrapy/scrapy/pull/6181#discussion_r1433821045"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 6181,
      "file_path": "scrapy/crawler.py",
      "line": 186,
      "side": "RIGHT",
      "diff_hunk": "@@ -178,6 +178,51 @@ def stop(self) -> Generator[Deferred, Any, None]:\n             assert self.engine\n             yield maybeDeferred(self.engine.stop)\n \n+    @staticmethod\n+    def _get_component(component_class, components):\n+        for component in components:\n+            if (\n+                type(component)  # pylint: disable=unidiomatic-typecheck\n+                is component_class",
      "comment": "Use cases I could find in the wild:\r\n- `isinstance`: [1](https://stackoverflow.com/q/64495540/939364), [2](https://stackoverflow.com/a/69681922/939364), [3](https://stackoverflow.com/a/40385860/939364), [4](https://stackoverflow.com/a/33007741/939364), [5](https://stackoverflow.com/a/41994630/939364).\r\n- `type` match: none found.\r\n- `str` in: [1](https://stackoverflow.com/a/54776137/939364), [2](https://github.com/scrapy/scrapy/issues/3590#issuecomment-465796924).\r\n- N/A: [1](https://github.com/scrapy/scrapy/issues/4253#issuecomment-568485213), [2](https://stackoverflow.com/a/60705942/939364), [3](https://stackoverflow.com/a/36623006/939364).\r\n\r\nSo, do we go with `isinstance`? Do we provide a boolean parameter to switch to a `type` match?",
      "comment_id": 1433852041,
      "user": "Gallaecio",
      "created_at": "2023-12-21T10:06:28Z",
      "url": "https://github.com/scrapy/scrapy/pull/6181#discussion_r1433852041"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 6181,
      "file_path": "scrapy/crawler.py",
      "line": 186,
      "side": "RIGHT",
      "diff_hunk": "@@ -178,6 +178,51 @@ def stop(self) -> Generator[Deferred, Any, None]:\n             assert self.engine\n             yield maybeDeferred(self.engine.stop)\n \n+    @staticmethod\n+    def _get_component(component_class, components):\n+        for component in components:\n+            if (\n+                type(component)  # pylint: disable=unidiomatic-typecheck\n+                is component_class",
      "comment": "I assumed checking the exact type is what people would actually want (not sure if real-world code examples show that they don't, as people could just forget about the subclasses).\r\n\r\nA boolean argument with a default looks fine to me.",
      "comment_id": 1433864766,
      "user": "wRAR",
      "created_at": "2023-12-21T10:16:54Z",
      "url": "https://github.com/scrapy/scrapy/pull/6181#discussion_r1433864766"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 6181,
      "file_path": "scrapy/crawler.py",
      "line": 186,
      "side": "RIGHT",
      "diff_hunk": "@@ -178,6 +178,51 @@ def stop(self) -> Generator[Deferred, Any, None]:\n             assert self.engine\n             yield maybeDeferred(self.engine.stop)\n \n+    @staticmethod\n+    def _get_component(component_class, components):\n+        for component in components:\n+            if (\n+                type(component)  # pylint: disable=unidiomatic-typecheck\n+                is component_class",
      "comment": "The use case for isinstance: there is e.g. a middleware (Scrapy built-in, or provided by some package). Some other object (could be e.g. some extension) uses a components getter to find the middleware, and read some information from it. Then, to change the behavior of the middleware, user makes a subclass, disables the original middleware, and enables the new one. \r\n\r\nThe question is: should the extension keep reading the information from the new middleware, or should it behave as is there is no middeware available anymore? \r\n\r\nIt seems there are arguments for both. For me it looks like using a subclass is better, because subclass is expected to keep the features of the base class, and extend it. So, +0.5 to do isinstance.",
      "comment_id": 1434129374,
      "user": "kmike",
      "created_at": "2023-12-21T14:14:50Z",
      "url": "https://github.com/scrapy/scrapy/pull/6181#discussion_r1434129374"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 6181,
      "file_path": "scrapy/crawler.py",
      "line": 186,
      "side": "RIGHT",
      "diff_hunk": "@@ -178,6 +178,51 @@ def stop(self) -> Generator[Deferred, Any, None]:\n             assert self.engine\n             yield maybeDeferred(self.engine.stop)\n \n+    @staticmethod\n+    def _get_component(component_class, components):\n+        for component in components:\n+            if (\n+                type(component)  # pylint: disable=unidiomatic-typecheck\n+                is component_class",
      "comment": "> It seems there are arguments for both.\r\n\r\nYeah.\r\n\r\n> For me it looks like using a subclass is better, because subclass is expected to keep the features of the base class, and extend it.\r\n\r\nMakes sense, let's do isinstance then. Shluld we still have a flag to switch it?",
      "comment_id": 1434196553,
      "user": "wRAR",
      "created_at": "2023-12-21T15:14:28Z",
      "url": "https://github.com/scrapy/scrapy/pull/6181#discussion_r1434196553"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 6181,
      "file_path": "scrapy/crawler.py",
      "line": 186,
      "side": "RIGHT",
      "diff_hunk": "@@ -178,6 +178,51 @@ def stop(self) -> Generator[Deferred, Any, None]:\n             assert self.engine\n             yield maybeDeferred(self.engine.stop)\n \n+    @staticmethod\n+    def _get_component(component_class, components):\n+        for component in components:\n+            if (\n+                type(component)  # pylint: disable=unidiomatic-typecheck\n+                is component_class",
      "comment": "> Shluld we still have a flag to switch it?\r\n\r\nI think we shouldn't do it now, without a real-world use case.",
      "comment_id": 1434268897,
      "user": "kmike",
      "created_at": "2023-12-21T16:18:49Z",
      "url": "https://github.com/scrapy/scrapy/pull/6181#discussion_r1434268897"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 6201,
      "file_path": "tests/test_proxy_connect.py",
      "line": 50,
      "side": "RIGHT",
      "diff_hunk": "@@ -46,7 +47,7 @@ def start(self):\n             stdout=PIPE,\n         )\n         line = self.proc.stdout.readline().decode(\"utf-8\")\n-        host_port = re.search(r\"listening at http://([^:]+:\\d+)\", line).group(1)\n+        host_port = re.search(r\"listening at (?:http://)?([^:]+:\\d+)\", line).group(1)",
      "comment": "The output format has changed in some newer version but we can support both.",
      "comment_id": 1443390550,
      "user": "wRAR",
      "created_at": "2024-01-05T21:38:15Z",
      "url": "https://github.com/scrapy/scrapy/pull/6201#discussion_r1443390550"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 6201,
      "file_path": "tests/test_proxy_connect.py",
      "line": 34,
      "side": "RIGHT",
      "diff_hunk": "@@ -31,6 +31,7 @@ def start(self):\n         self.proc = Popen(\n             [\n                 sys.executable,\n+                \"-u\",",
      "comment": "mitmproxy changed the code that prints log lines and we now need to disable stdout buffering to get it via Popen.",
      "comment_id": 1443392304,
      "user": "wRAR",
      "created_at": "2024-01-05T21:41:15Z",
      "url": "https://github.com/scrapy/scrapy/pull/6201#discussion_r1443392304"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 5068,
      "file_path": "scrapy/pipelines/media.py",
      "line": 125,
      "side": "RIGHT",
      "diff_hunk": "@@ -112,12 +112,18 @@ def _process_request(self, request, info, item):\n         info.downloading.add(fp)\n         dfd = mustbe_deferred(self.media_to_download, request, info, item=item)\n         dfd.addCallback(self._check_media_to_download, request, info, item=item)\n+        dfd.addErrback(self._log_error, info)\n         dfd.addBoth(self._cache_result_and_execute_waiters, fp, info)\n-        dfd.addErrback(lambda f: logger.error(\n-            f.value, exc_info=failure_to_exc_info(f), extra={'spider': info.spider})\n-        )\n         return dfd.addBoth(lambda _: wad)  # it must return wad at last\n \n+    def _log_error(self, result, info):\n+        logger.error(\n+            result.value,\n+            exc_info=failure_to_exc_info(result),\n+            extra={'spider': info.spider}\n+        )\n+        return result",
      "comment": "Well, the main change is actually moving the `addErrback` 1 line above. Returning `result` here is just so that the line move does not break the `addBoth` line that now goes afterwards.",
      "comment_id": 607013479,
      "user": "Gallaecio",
      "created_at": "2021-04-05T09:57:26Z",
      "url": "https://github.com/scrapy/scrapy/pull/5068#discussion_r607013479"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 5068,
      "file_path": "scrapy/pipelines/media.py",
      "line": 125,
      "side": "RIGHT",
      "diff_hunk": "@@ -112,12 +112,18 @@ def _process_request(self, request, info, item):\n         info.downloading.add(fp)\n         dfd = mustbe_deferred(self.media_to_download, request, info, item=item)\n         dfd.addCallback(self._check_media_to_download, request, info, item=item)\n+        dfd.addErrback(self._log_error, info)\n         dfd.addBoth(self._cache_result_and_execute_waiters, fp, info)\n-        dfd.addErrback(lambda f: logger.error(\n-            f.value, exc_info=failure_to_exc_info(f), extra={'spider': info.spider})\n-        )\n         return dfd.addBoth(lambda _: wad)  # it must return wad at last\n \n+    def _log_error(self, result, info):\n+        logger.error(\n+            result.value,\n+            exc_info=failure_to_exc_info(result),\n+            extra={'spider': info.spider}\n+        )\n+        return result",
      "comment": "The reason for the line move is that `_cache_result_and_execute_waiters` removes the failure information to save memory. So we were basically removing an error and then logging it, now we should be logging it and _then_ removing it.",
      "comment_id": 607015423,
      "user": "Gallaecio",
      "created_at": "2021-04-05T10:03:21Z",
      "url": "https://github.com/scrapy/scrapy/pull/5068#discussion_r607015423"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 6169,
      "file_path": "scrapy/core/scheduler.py",
      "line": 204,
      "side": "RIGHT",
      "diff_hunk": "@@ -201,8 +201,12 @@ def from_crawler(cls: Type[SchedulerTV], crawler: Crawler) -> SchedulerTV:\n         Factory method, initializes the scheduler with arguments taken from the crawl settings\n         \"\"\"\n         dupefilter_cls = load_object(crawler.settings[\"DUPEFILTER_CLASS\"])\n+        if crawler is not None:",
      "comment": "Many of those checks seem unneeded but some of them, like this one (and especially a check for `self` later) are definitely unneeded.",
      "comment_id": 1419680973,
      "user": "wRAR",
      "created_at": "2023-12-07T21:29:16Z",
      "url": "https://github.com/scrapy/scrapy/pull/6169#discussion_r1419680973"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 6169,
      "file_path": "scrapy/utils/misc.py",
      "line": 128,
      "side": "RIGHT",
      "diff_hunk": "@@ -125,27 +125,14 @@ def rel_has_nofollow(rel: Optional[str]) -> bool:\n     return rel is not None and \"nofollow\" in rel.replace(\",\", \" \").split()\n \n \n-def create_instance(objcls, settings, crawler, *args, **kwargs):\n-    \"\"\"Construct a class instance using its ``from_crawler`` or\n-    ``from_settings`` constructors, if available.\n-\n-    At least one of ``settings`` and ``crawler`` needs to be different from\n-    ``None``. If ``settings `` is ``None``, ``crawler.settings`` will be used.\n-    If ``crawler`` is ``None``, only the ``from_settings`` constructor will be\n-    tried.\n-\n-    ``*args`` and ``**kwargs`` are forwarded to the constructors.\n-\n-    Raises ``ValueError`` if both ``settings`` and ``crawler`` are ``None``.\n-\n-    .. versionchanged:: 2.2\n-       Raises ``TypeError`` if the resulting instance is ``None`` (e.g. if an\n-       extension has not been implemented correctly).\n-    \"\"\"\n-    if settings is None:\n-        if crawler is None:\n-            raise ValueError(\"Specify at least one of settings and crawler.\")\n-        settings = crawler.settings\n+# ``*args`` and ``**kwargs`` are forwarded to the constructors.",
      "comment": "These comments should instead be in the docstring.",
      "comment_id": 1419681752,
      "user": "wRAR",
      "created_at": "2023-12-07T21:30:04Z",
      "url": "https://github.com/scrapy/scrapy/pull/6169#discussion_r1419681752"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 6169,
      "file_path": "scrapy/utils/misc.py",
      "line": 169,
      "side": "RIGHT",
      "diff_hunk": "@@ -160,6 +160,50 @@ def create_instance(objcls, settings, crawler, *args, **kwargs):\n     return instance\n \n \n+def build_from_crawler(objcls, crawler, *args, **kwargs):\n+    \"\"\"\n+    ``*args`` and ``**kwargs`` are forwarded to the constructors.\n+    Raises ``ValueError`` if``crawler`` is``None``.\n+    Raises typeError is instance is None\n+    Creates a class instance using 'from_crawler' constructor\n+    \"\"\"",
      "comment": "Both new methods should get a proper complete docstring.",
      "comment_id": 1420847471,
      "user": "wRAR",
      "created_at": "2023-12-08T17:55:17Z",
      "url": "https://github.com/scrapy/scrapy/pull/6169#discussion_r1420847471"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 6169,
      "file_path": "scrapy/utils/misc.py",
      "line": 169,
      "side": "RIGHT",
      "diff_hunk": "@@ -160,6 +160,50 @@ def create_instance(objcls, settings, crawler, *args, **kwargs):\n     return instance\n \n \n+def build_from_crawler(objcls, crawler, *args, **kwargs):\n+    \"\"\"\n+    ``*args`` and ``**kwargs`` are forwarded to the constructors.\n+    Raises ``ValueError`` if``crawler`` is``None``.\n+    Raises typeError is instance is None\n+    Creates a class instance using 'from_crawler' constructor\n+    \"\"\"",
      "comment": "Thank you for the feedback, the issues should be fixed now. I didn't have additional documentations to add for the methods, but I reformatted them similarly to other docstrings.",
      "comment_id": 1421015899,
      "user": "monicaq21",
      "created_at": "2023-12-08T20:50:23Z",
      "url": "https://github.com/scrapy/scrapy/pull/6169#discussion_r1421015899"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 6169,
      "file_path": "scrapy/utils/misc.py",
      "line": 163,
      "side": "RIGHT",
      "diff_hunk": "@@ -160,6 +160,50 @@ def create_instance(objcls, settings, crawler, *args, **kwargs):\n     return instance\n \n \n+def build_from_crawler(objcls, crawler, *args, **kwargs):",
      "comment": "```suggestion\r\ndef build_from_crawler(objcls, crawler, /, *args, **kwargs):\r\n```",
      "comment_id": 1421729460,
      "user": "wRAR",
      "created_at": "2023-12-10T11:06:44Z",
      "url": "https://github.com/scrapy/scrapy/pull/6169#discussion_r1421729460"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 6169,
      "file_path": "scrapy/utils/misc.py",
      "line": 187,
      "side": "RIGHT",
      "diff_hunk": "@@ -160,6 +160,50 @@ def create_instance(objcls, settings, crawler, *args, **kwargs):\n     return instance\n \n \n+def build_from_crawler(objcls, crawler, *args, **kwargs):\n+    \"\"\"\n+    Constructs a class instance using ``from_crawler`` constructor\n+\n+    ``*args`` and ``**kwargs`` are forwarded to the constructors.\n+\n+    Raises ``ValueError`` if``crawler`` is``None``.\n+    Raises typeError is instance is None\n+    \"\"\"\n+    settings = crawler.settings\n+    if crawler and hasattr(objcls, \"from_crawler\"):\n+        instance = objcls.from_crawler(crawler, *args, **kwargs)\n+        method_name = \"from_crawler\"\n+    elif hasattr(objcls, \"from_settings\"):\n+        instance = objcls.from_settings(settings, *args, **kwargs)\n+        method_name = \"from_settings\"\n+    else:\n+        instance = objcls(*args, **kwargs)\n+        method_name = \"__new__\"\n+    if instance is None:\n+        raise TypeError(f\"{objcls.__qualname__}.{method_name} returned None\")\n+    return instance\n+\n+\n+def build_from_settings(objcls, settings, *args, **kwargs):",
      "comment": "```suggestion\r\ndef build_from_settings(objcls, settings, /, *args, **kwargs):\r\n```",
      "comment_id": 1421729476,
      "user": "wRAR",
      "created_at": "2023-12-10T11:06:54Z",
      "url": "https://github.com/scrapy/scrapy/pull/6169#discussion_r1421729476"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 6169,
      "file_path": "scrapy/utils/misc.py",
      "line": 165,
      "side": "RIGHT",
      "diff_hunk": "@@ -160,6 +160,50 @@ def create_instance(objcls, settings, crawler, *args, **kwargs):\n     return instance\n \n \n+def build_from_crawler(objcls, crawler, *args, **kwargs):\n+    \"\"\"\n+    Constructs a class instance using ``from_crawler`` constructor",
      "comment": "```suggestion\r\n    \"\"\"Construct a class instance using its ``from_crawler`` constructor.\r\n```",
      "comment_id": 1421729644,
      "user": "wRAR",
      "created_at": "2023-12-10T11:08:14Z",
      "url": "https://github.com/scrapy/scrapy/pull/6169#discussion_r1421729644"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 6169,
      "file_path": "scrapy/utils/misc.py",
      "line": 167,
      "side": "RIGHT",
      "diff_hunk": "@@ -160,6 +160,50 @@ def create_instance(objcls, settings, crawler, *args, **kwargs):\n     return instance\n \n \n+def build_from_crawler(objcls, crawler, *args, **kwargs):\n+    \"\"\"\n+    Constructs a class instance using ``from_crawler`` constructor\n+\n+    ``*args`` and ``**kwargs`` are forwarded to the constructors.",
      "comment": "```suggestion\r\n    ``*args`` and ``**kwargs`` are forwarded to the constructor.\r\n```",
      "comment_id": 1421729674,
      "user": "wRAR",
      "created_at": "2023-12-10T11:08:26Z",
      "url": "https://github.com/scrapy/scrapy/pull/6169#discussion_r1421729674"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 6169,
      "file_path": "scrapy/utils/misc.py",
      "line": 170,
      "side": "RIGHT",
      "diff_hunk": "@@ -160,6 +160,50 @@ def create_instance(objcls, settings, crawler, *args, **kwargs):\n     return instance\n \n \n+def build_from_crawler(objcls, crawler, *args, **kwargs):\n+    \"\"\"\n+    Constructs a class instance using ``from_crawler`` constructor\n+\n+    ``*args`` and ``**kwargs`` are forwarded to the constructors.\n+\n+    Raises ``ValueError`` if``crawler`` is``None``.\n+    Raises typeError is instance is None",
      "comment": "```suggestion\r\n    Raises ``TypeError`` if the resulting instance is ``None``.\r\n```",
      "comment_id": 1421730034,
      "user": "wRAR",
      "created_at": "2023-12-10T11:10:51Z",
      "url": "https://github.com/scrapy/scrapy/pull/6169#discussion_r1421730034"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 6169,
      "file_path": "scrapy/utils/misc.py",
      "line": 188,
      "side": "RIGHT",
      "diff_hunk": "@@ -160,6 +160,50 @@ def create_instance(objcls, settings, crawler, *args, **kwargs):\n     return instance\n \n \n+def build_from_crawler(objcls, crawler, *args, **kwargs):\n+    \"\"\"\n+    Constructs a class instance using ``from_crawler`` constructor\n+\n+    ``*args`` and ``**kwargs`` are forwarded to the constructors.\n+\n+    Raises ``ValueError`` if``crawler`` is``None``.\n+    Raises typeError is instance is None\n+    \"\"\"\n+    settings = crawler.settings\n+    if crawler and hasattr(objcls, \"from_crawler\"):\n+        instance = objcls.from_crawler(crawler, *args, **kwargs)\n+        method_name = \"from_crawler\"\n+    elif hasattr(objcls, \"from_settings\"):\n+        instance = objcls.from_settings(settings, *args, **kwargs)\n+        method_name = \"from_settings\"\n+    else:\n+        instance = objcls(*args, **kwargs)\n+        method_name = \"__new__\"\n+    if instance is None:\n+        raise TypeError(f\"{objcls.__qualname__}.{method_name} returned None\")\n+    return instance\n+\n+\n+def build_from_settings(objcls, settings, *args, **kwargs):\n+    \"\"\"",
      "comment": "All feedback for the `build_from_crawler` docstring also applies here.",
      "comment_id": 1421730154,
      "user": "wRAR",
      "created_at": "2023-12-10T11:11:39Z",
      "url": "https://github.com/scrapy/scrapy/pull/6169#discussion_r1421730154"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 6169,
      "file_path": "scrapy/utils/misc.py",
      "line": 170,
      "side": "RIGHT",
      "diff_hunk": "@@ -160,6 +160,46 @@ def create_instance(objcls, settings, crawler, *args, **kwargs):\n     return instance\n \n \n+def build_from_crawler(objcls, crawler, /, *args, **kwargs):\n+    \"\"\"Construct a class instance using its ``from_crawler`` constructor.\n+\n+    ``*args`` and ``**kwargs`` are forwarded to the constructor.\n+\n+    Raises ``TypeError`` if the resulting instance is ``None``.\n+    \"\"\"\n+    settings = crawler.settings",
      "comment": "As this is only used in the line 175, I'd just remove this var and used `crawler.settings` directly on that line.",
      "comment_id": 1421796864,
      "user": "wRAR",
      "created_at": "2023-12-10T18:34:35Z",
      "url": "https://github.com/scrapy/scrapy/pull/6169#discussion_r1421796864"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 6169,
      "file_path": "scrapy/utils/misc.py",
      "line": 171,
      "side": "RIGHT",
      "diff_hunk": "@@ -160,6 +160,46 @@ def create_instance(objcls, settings, crawler, *args, **kwargs):\n     return instance\n \n \n+def build_from_crawler(objcls, crawler, /, *args, **kwargs):\n+    \"\"\"Construct a class instance using its ``from_crawler`` constructor.\n+\n+    ``*args`` and ``**kwargs`` are forwarded to the constructor.\n+\n+    Raises ``TypeError`` if the resulting instance is ``None``.\n+    \"\"\"\n+    settings = crawler.settings\n+    if crawler and hasattr(objcls, \"from_crawler\"):",
      "comment": "I think we shouldn't check `if crawler` and assume it's not None if this method was called.",
      "comment_id": 1421797242,
      "user": "wRAR",
      "created_at": "2023-12-10T18:37:09Z",
      "url": "https://github.com/scrapy/scrapy/pull/6169#discussion_r1421797242"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 6169,
      "file_path": "scrapy/utils/misc.py",
      "line": 192,
      "side": "RIGHT",
      "diff_hunk": "@@ -160,6 +160,46 @@ def create_instance(objcls, settings, crawler, *args, **kwargs):\n     return instance\n \n \n+def build_from_crawler(objcls, crawler, /, *args, **kwargs):\n+    \"\"\"Construct a class instance using its ``from_crawler`` constructor.\n+\n+    ``*args`` and ``**kwargs`` are forwarded to the constructor.\n+\n+    Raises ``TypeError`` if the resulting instance is ``None``.\n+    \"\"\"\n+    settings = crawler.settings\n+    if crawler and hasattr(objcls, \"from_crawler\"):\n+        instance = objcls.from_crawler(crawler, *args, **kwargs)\n+        method_name = \"from_crawler\"\n+    elif hasattr(objcls, \"from_settings\"):\n+        instance = objcls.from_settings(settings, *args, **kwargs)\n+        method_name = \"from_settings\"\n+    else:\n+        instance = objcls(*args, **kwargs)\n+        method_name = \"__new__\"\n+    if instance is None:\n+        raise TypeError(f\"{objcls.__qualname__}.{method_name} returned None\")\n+    return instance\n+\n+\n+def build_from_settings(objcls, settings, /, *args, **kwargs):\n+    \"\"\"Constructs a class instance using its ``from_settings`` constructor\n+\n+    ``*args`` and ``**kwargs`` are forwarded to the constructors.\n+\n+    Raises ``TypeError`` if the resulting instance is ``None``.\n+    \"\"\"\n+    if settings and hasattr(objcls, \"from_settings\"):",
      "comment": "Similarly, I think we shouldn't check `if settings`.",
      "comment_id": 1421797282,
      "user": "wRAR",
      "created_at": "2023-12-10T18:37:26Z",
      "url": "https://github.com/scrapy/scrapy/pull/6169#discussion_r1421797282"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 6169,
      "file_path": "scrapy/utils/misc.py",
      "line": 185,
      "side": "RIGHT",
      "diff_hunk": "@@ -160,6 +160,45 @@ def create_instance(objcls, settings, crawler, *args, **kwargs):\n     return instance\n \n \n+def build_from_crawler(objcls, crawler, /, *args, **kwargs):\n+    \"\"\"Construct a class instance using its ``from_crawler`` constructor.\n+\n+    ``*args`` and ``**kwargs`` are forwarded to the constructor.\n+\n+    Raises ``TypeError`` if the resulting instance is ``None``.\n+    \"\"\"\n+    if hasattr(objcls, \"from_crawler\"):\n+        instance = objcls.from_crawler(crawler, *args, **kwargs)\n+        method_name = \"from_crawler\"\n+    elif hasattr(objcls, \"from_settings\"):\n+        instance = objcls.from_settings(crawler.settings, *args, **kwargs)\n+        method_name = \"from_settings\"\n+    else:\n+        instance = objcls(*args, **kwargs)\n+        method_name = \"__new__\"\n+    if instance is None:\n+        raise TypeError(f\"{objcls.__qualname__}.{method_name} returned None\")\n+    return instance\n+\n+\n+def build_from_settings(objcls, settings, /, *args, **kwargs):\n+    \"\"\"Constructs a class instance using its ``from_settings`` constructor.",
      "comment": "```suggestion\r\n    \"\"\"Construct a class instance using its ``from_settings`` constructor.\r\n```",
      "comment_id": 1421810341,
      "user": "wRAR",
      "created_at": "2023-12-10T20:18:51Z",
      "url": "https://github.com/scrapy/scrapy/pull/6169#discussion_r1421810341"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 6169,
      "file_path": "tests/test_utils_misc/__init__.py",
      "line": 109,
      "side": "RIGHT",
      "diff_hunk": "@@ -95,14 +96,44 @@ class TestItem(Item):\n             list(arg_to_iter(TestItem(name=\"john\"))), [TestItem(name=\"john\")]\n         )\n \n-    def test_create_instance(self):\n-        settings = mock.MagicMock()\n+    def test_build_from_crawler(self):\n         crawler = mock.MagicMock(spec_set=[\"settings\"])\n         args = (True, 100.0)\n         kwargs = {\"key\": \"val\"}\n \n+        def _test_with_crawler(m, crawler):\n+            build_from_crawler(m, crawler, *args, **kwargs)\n+            if hasattr(m, \"from_crawler\"):\n+                m.from_crawler.assert_called_once_with(crawler, *args, **kwargs)\n+                self.assertEqual(m.call_count, 0)\n+            else:",
      "comment": "So this test only checks `from_crawler` while `test_build_from_settings` checks `from_crawler` and `from_settings`, I think this is an error, this one should check both while `test_build_from_settings` should only check `from_settings`.",
      "comment_id": 1425142718,
      "user": "wRAR",
      "created_at": "2023-12-13T10:18:53Z",
      "url": "https://github.com/scrapy/scrapy/pull/6169#discussion_r1425142718"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 6169,
      "file_path": "tests/test_utils_misc/__init__.py",
      "line": 114,
      "side": "LEFT",
      "diff_hunk": "@@ -111,47 +142,23 @@ def _test_with_settings(mock, settings):\n             else:\n                 mock.assert_called_once_with(*args, **kwargs)\n \n-        def _test_with_crawler(mock, settings, crawler):",
      "comment": "So this logic should be kept in `_test_with_crawler`.",
      "comment_id": 1425146303,
      "user": "wRAR",
      "created_at": "2023-12-13T10:21:46Z",
      "url": "https://github.com/scrapy/scrapy/pull/6169#discussion_r1425146303"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 6169,
      "file_path": "tests/test_utils_misc/__init__.py",
      "line": 98,
      "side": "LEFT",
      "diff_hunk": "@@ -95,14 +96,44 @@ class TestItem(Item):\n             list(arg_to_iter(TestItem(name=\"john\"))), [TestItem(name=\"john\")]\n         )\n \n-    def test_create_instance(self):",
      "comment": "I also think the create_instance test should be kept as long as we keep the function itself.",
      "comment_id": 1425149249,
      "user": "wRAR",
      "created_at": "2023-12-13T10:24:02Z",
      "url": "https://github.com/scrapy/scrapy/pull/6169#discussion_r1425149249"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 6127,
      "file_path": "scrapy/http/response/__init__.py",
      "line": 99,
      "side": "RIGHT",
      "diff_hunk": "@@ -41,62 +63,62 @@ class Response(object_ref):\n     def __init__(\n         self,\n         url: str,\n-        status=200,\n+        status: int = 200,\n         headers: Union[Mapping[AnyStr, Any], Iterable[Tuple[AnyStr, Any]], None] = None,\n-        body=b\"\",\n-        flags=None,\n-        request=None,\n-        certificate=None,\n-        ip_address=None,\n-        protocol=None,\n+        body: bytes = b\"\",\n+        flags: Optional[List[str]] = None,\n+        request: Optional[Request] = None,\n+        certificate: Optional[Certificate] = None,\n+        ip_address: Union[IPv4Address, IPv6Address, None] = None,\n+        protocol: Optional[str] = None,\n     ):\n-        self.headers = Headers(headers or {})\n-        self.status = int(status)\n+        self.headers: Headers = Headers(headers or {})\n+        self.status: int = int(status)\n         self._set_body(body)\n         self._set_url(url)\n-        self.request = request\n-        self.flags = [] if flags is None else list(flags)\n-        self.certificate = certificate\n-        self.ip_address = ip_address\n-        self.protocol = protocol\n+        self.request: Optional[Request] = request\n+        self.flags: List[str] = [] if flags is None else list(flags)\n+        self.certificate: Optional[Certificate] = certificate\n+        self.ip_address: Union[IPv4Address, IPv6Address, None] = ip_address\n+        self.protocol: Optional[str] = protocol\n \n     @property\n-    def cb_kwargs(self):\n+    def cb_kwargs(self) -> Dict[str, Any]:\n         try:\n-            return self.request.cb_kwargs\n+            return self.request.cb_kwargs  # type: ignore[union-attr]\n         except AttributeError:\n             raise AttributeError(\n                 \"Response.cb_kwargs not available, this response \"\n                 \"is not tied to any request\"\n             )\n \n     @property\n-    def meta(self):\n+    def meta(self) -> Dict[str, Any]:\n         try:\n-            return self.request.meta\n+            return self.request.meta  # type: ignore[union-attr]\n         except AttributeError:",
      "comment": "I have no idea why is this just not checking `self.request is not None` btw.",
      "comment_id": 1378202306,
      "user": "wRAR",
      "created_at": "2023-10-31T21:57:03Z",
      "url": "https://github.com/scrapy/scrapy/pull/6127#discussion_r1378202306"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 6127,
      "file_path": "scrapy/http/response/__init__.py",
      "line": 208,
      "side": "RIGHT",
      "diff_hunk": "@@ -183,6 +205,8 @@ def follow(\n         .. versionadded:: 2.0\n            The *flags* parameter.\n         \"\"\"\n+        if encoding is None:",
      "comment": "Allowing None in the signature because `TextResponse` needs it allowed in its method implementations and those call the base class methods (`TextResponse` methods don't call `Response.follow()` but I'm not sure if it can be detected statically).",
      "comment_id": 1378205864,
      "user": "wRAR",
      "created_at": "2023-10-31T22:02:43Z",
      "url": "https://github.com/scrapy/scrapy/pull/6127#discussion_r1378205864"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 6127,
      "file_path": "scrapy/http/response/text.py",
      "line": 50,
      "side": "LEFT",
      "diff_hunk": "@@ -39,20 +54,14 @@ class TextResponse(Response):\n     attributes: Tuple[str, ...] = Response.attributes + (\"encoding\",)\n \n     def __init__(self, *args: Any, **kwargs: Any):\n-        self._encoding = kwargs.pop(\"encoding\", None)\n+        self._encoding: Optional[str] = kwargs.pop(\"encoding\", None)\n         self._cached_benc: Optional[str] = None\n         self._cached_ubody: Optional[str] = None\n         self._cached_selector: Optional[Selector] = None\n         super().__init__(*args, **kwargs)\n \n-    def _set_url(self, url):\n-        if isinstance(url, str):\n-            self._url = to_unicode(url, self.encoding)",
      "comment": "This additional code became no-op after Python 2 code removal. Initially it encoded py2 `unicode` to py2 `str` using `self.encoding` but now both the input and the internal representation are str-only.",
      "comment_id": 1378206957,
      "user": "wRAR",
      "created_at": "2023-10-31T22:04:28Z",
      "url": "https://github.com/scrapy/scrapy/pull/6127#discussion_r1378206957"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 6127,
      "file_path": "tests/test_http2_client_protocol.py",
      "line": 603,
      "side": "RIGHT",
      "diff_hunk": "@@ -600,6 +600,7 @@ def test_response_has_correct_certificate_ip_address(self):\n         def assert_metadata(response: Response):\n             self.assertEqual(response.request, request)\n             self.assertIsInstance(response.certificate, Certificate)\n+            assert response.certificate  # typing",
      "comment": "I haven't found how to make mypy look at ~~pytest~~ unittest asserts :)",
      "comment_id": 1378207687,
      "user": "wRAR",
      "created_at": "2023-10-31T22:05:46Z",
      "url": "https://github.com/scrapy/scrapy/pull/6127#discussion_r1378207687"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 6127,
      "file_path": "scrapy/http/common.py",
      "line": 4,
      "side": "RIGHT",
      "diff_hunk": "@@ -1,5 +1,8 @@\n-def obsolete_setter(setter, attrname):\n-    def newsetter(self, value):\n+from typing import Any, Callable, NoReturn\n+\n+\n+def obsolete_setter(setter: Callable, attrname: str) -> Callable[[Any, Any], NoReturn]:",
      "comment": "Though we need to make sure the docs clearly direct the user to `.replace()`.",
      "comment_id": 1378498024,
      "user": "wRAR",
      "created_at": "2023-11-01T08:04:58Z",
      "url": "https://github.com/scrapy/scrapy/pull/6127#discussion_r1378498024"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 6127,
      "file_path": "scrapy/http/request/__init__.py",
      "line": 182,
      "side": "RIGHT",
      "diff_hunk": "@@ -174,19 +179,19 @@ def __repr__(self) -> str:\n     def copy(self) -> \"Request\":\n         return self.replace()\n \n-    def replace(self, *args, **kwargs) -> \"Request\":\n+    def replace(self, *args: Any, **kwargs: Any) -> \"Request\":",
      "comment": "I think technically the return type is different; the same applies to .copy() - the class is preserved by default, unless \"cls\" attribute is passed. This could matter for classes like FormRequest or other custom request classes. Not a big deal, but I wonder if having self type as a default return type is better than hardcoding Request? We can also try to support `cls` typing directly, though it's more work.",
      "comment_id": 1386696665,
      "user": "kmike",
      "created_at": "2023-11-08T14:20:06Z",
      "url": "https://github.com/scrapy/scrapy/pull/6127#discussion_r1386696665"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 6127,
      "file_path": "scrapy/http/response/__init__.py",
      "line": 142,
      "side": "RIGHT",
      "diff_hunk": "@@ -110,65 +132,65 @@ def _set_body(self, body):\n \n     body = property(_get_body, obsolete_setter(_set_body, \"body\"))\n \n-    def __repr__(self):\n+    def __repr__(self) -> str:\n         return f\"<{self.status} {self.url}>\"\n \n-    def copy(self):\n+    def copy(self) -> Response:\n         \"\"\"Return a copy of this Response\"\"\"\n         return self.replace()\n \n-    def replace(self, *args, **kwargs):\n+    def replace(self, *args: Any, **kwargs: Any) -> Response:",
      "comment": "I think this could cause some false positives with the type checking, when using response subclasses.",
      "comment_id": 1386699714,
      "user": "kmike",
      "created_at": "2023-11-08T14:22:18Z",
      "url": "https://github.com/scrapy/scrapy/pull/6127#discussion_r1386699714"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 6127,
      "file_path": "scrapy/http/request/__init__.py",
      "line": 182,
      "side": "RIGHT",
      "diff_hunk": "@@ -174,19 +179,19 @@ def __repr__(self) -> str:\n     def copy(self) -> \"Request\":\n         return self.replace()\n \n-    def replace(self, *args, **kwargs) -> \"Request\":\n+    def replace(self, *args: Any, **kwargs: Any) -> \"Request\":",
      "comment": "The current hint means any descendant of `Request` could be returned, while `Self` is more restrictive, so if we remember about `cls` it doesn't look correct to put `Self` here.",
      "comment_id": 1386959697,
      "user": "wRAR",
      "created_at": "2023-11-08T17:16:14Z",
      "url": "https://github.com/scrapy/scrapy/pull/6127#discussion_r1386959697"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 6127,
      "file_path": "scrapy/http/request/__init__.py",
      "line": 182,
      "side": "RIGHT",
      "diff_hunk": "@@ -174,19 +179,19 @@ def __repr__(self) -> str:\n     def copy(self) -> \"Request\":\n         return self.replace()\n \n-    def replace(self, *args, **kwargs) -> \"Request\":\n+    def replace(self, *args: Any, **kwargs: Any) -> \"Request\":",
      "comment": "Hm, was thinking that Request typing is more restrictive than Self typing, for the user code. \r\n\r\nWe're telling that the result of .replace (and other similar methods) no longer has all the new methods or attributes of the Request subclass, and it's just a basic Request, so mypy is going to show an error if user tries to access them.",
      "comment_id": 1388028547,
      "user": "kmike",
      "created_at": "2023-11-09T13:48:47Z",
      "url": "https://github.com/scrapy/scrapy/pull/6127#discussion_r1388028547"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 6127,
      "file_path": "scrapy/http/request/__init__.py",
      "line": 182,
      "side": "RIGHT",
      "diff_hunk": "@@ -174,19 +179,19 @@ def __repr__(self) -> str:\n     def copy(self) -> \"Request\":\n         return self.replace()\n \n-    def replace(self, *args, **kwargs) -> \"Request\":\n+    def replace(self, *args: Any, **kwargs: Any) -> \"Request\":",
      "comment": "Neither Request nor Self is 100% correct here, but I wonder if using Self is going to cause fewer false positives in the type checks for the users, and is a better default overall. \r\n\r\nFor `cls` edge case both of the approaches are incorrect. Without the `cls` edge case, Self typing looks correct, and Request looks incorrect (as it can lead to wrong typing errors while checking the user's code).",
      "comment_id": 1388029742,
      "user": "kmike",
      "created_at": "2023-11-09T13:49:48Z",
      "url": "https://github.com/scrapy/scrapy/pull/6127#discussion_r1388029742"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 6127,
      "file_path": "scrapy/http/request/__init__.py",
      "line": 182,
      "side": "RIGHT",
      "diff_hunk": "@@ -174,19 +179,19 @@ def __repr__(self) -> str:\n     def copy(self) -> \"Request\":\n         return self.replace()\n \n-    def replace(self, *args, **kwargs) -> \"Request\":\n+    def replace(self, *args: Any, **kwargs: Any) -> \"Request\":",
      "comment": "> Without the cls edge case, Self typing looks correct\r\n\r\nYup.\r\n\r\nWe could add an overload to all these methods that covers the case when `cls is not None`, though that requires adding a `cls` named arg explicitly, not sure if that will break anything.",
      "comment_id": 1388406846,
      "user": "wRAR",
      "created_at": "2023-11-09T18:14:05Z",
      "url": "https://github.com/scrapy/scrapy/pull/6127#discussion_r1388406846"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 6127,
      "file_path": "scrapy/http/response/__init__.py",
      "line": 142,
      "side": "RIGHT",
      "diff_hunk": "@@ -110,65 +132,65 @@ def _set_body(self, body):\n \n     body = property(_get_body, obsolete_setter(_set_body, \"body\"))\n \n-    def __repr__(self):\n+    def __repr__(self) -> str:\n         return f\"<{self.status} {self.url}>\"\n \n-    def copy(self):\n+    def copy(self) -> Response:\n         \"\"\"Return a copy of this Response\"\"\"\n         return self.replace()\n \n-    def replace(self, *args, **kwargs):\n+    def replace(self, *args: Any, **kwargs: Any) -> Response:",
      "comment": "False positives in the user code, i.e. mypy can raise an error where it shouldn't. For example, `text_response.replace(status=200).text` can cause a false alarm from mypy.",
      "comment_id": 1389213602,
      "user": "kmike",
      "created_at": "2023-11-10T10:24:32Z",
      "url": "https://github.com/scrapy/scrapy/pull/6127#discussion_r1389213602"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 6133,
      "file_path": "scrapy/utils/project.py",
      "line": 49,
      "side": "RIGHT",
      "diff_hunk": "@@ -44,7 +46,7 @@ def project_data_dir(project: str = \"default\") -> str:\n     return str(d)\n \n \n-def data_path(path: str, createdir: bool = False) -> str:\n+def data_path(path: Union[str, PathLike, Path], createdir: bool = False) -> str:",
      "comment": "`pathlib.Path` is a subclass of `os.PathLike` so it's not needed to be mentioned separately here.",
      "comment_id": 1381680291,
      "user": "wRAR",
      "created_at": "2023-11-03T13:28:24Z",
      "url": "https://github.com/scrapy/scrapy/pull/6133#discussion_r1381680291"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 6133,
      "file_path": "scrapy/utils/project.py",
      "line": 49,
      "side": "RIGHT",
      "diff_hunk": "@@ -44,7 +46,7 @@ def project_data_dir(project: str = \"default\") -> str:\n     return str(d)\n \n \n-def data_path(path: str, createdir: bool = False) -> str:\n+def data_path(path: Union[str, PathLike, Path], createdir: bool = False) -> str:",
      "comment": "I meant removing `Path`, not removing `PathLike`. `Union[str, PathLike]` is the usual hint for these APIs.",
      "comment_id": 1381815160,
      "user": "wRAR",
      "created_at": "2023-11-03T14:55:33Z",
      "url": "https://github.com/scrapy/scrapy/pull/6133#discussion_r1381815160"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 6124,
      "file_path": "scrapy/utils/job.py",
      "line": 8,
      "side": "RIGHT",
      "diff_hunk": "@@ -6,6 +6,8 @@\n \n def job_dir(settings: BaseSettings) -> Optional[str]:\n     path: str = settings[\"JOBDIR\"]",
      "comment": "```suggestion\r\n    path: Optional[str] = settings[\"JOBDIR\"]\r\n```",
      "comment_id": 1377129774,
      "user": "Gallaecio",
      "created_at": "2023-10-31T07:01:42Z",
      "url": "https://github.com/scrapy/scrapy/pull/6124#discussion_r1377129774"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 6116,
      "file_path": "scrapy/utils/log.py",
      "line": 236,
      "side": "RIGHT",
      "diff_hunk": "@@ -235,15 +235,8 @@ def logformatter_adapter(logkws: dict) -> Tuple[int, str, dict]:\n     if not {\"level\", \"msg\", \"args\"} <= set(logkws):\n         warnings.warn(\"Missing keys in LogFormatter method\", ScrapyDeprecationWarning)",
      "comment": "Thanks for guiding. I've deleted these in the latest commit.",
      "comment_id": 1363711370,
      "user": "Chenwei-Niu",
      "created_at": "2023-10-18T11:32:33Z",
      "url": "https://github.com/scrapy/scrapy/pull/6116#discussion_r1363711370"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 6116,
      "file_path": "scrapy/utils/log.py",
      "line": 235,
      "side": "RIGHT",
      "diff_hunk": "@@ -232,18 +230,9 @@ def logformatter_adapter(logkws: dict) -> Tuple[int, str, dict]:\n     and adapts it into a tuple of positional arguments for logger.log calls,\n     handling backward compatibility as well.\n     \"\"\"\n-    if not {\"level\", \"msg\", \"args\"} <= set(logkws):\n-        warnings.warn(\"Missing keys in LogFormatter method\", ScrapyDeprecationWarning)\n-\n-    if \"format\" in logkws:\n-        warnings.warn(\n-            \"`format` key in LogFormatter methods has been \"\n-            \"deprecated, use `msg` instead\",\n-            ScrapyDeprecationWarning,\n-        )\n \n     level = logkws.get(\"level\", logging.INFO)\n-    message = logkws.get(\"format\", logkws.get(\"msg\"))\n+    message = str(logkws.get(\"msg\"))",
      "comment": "Hi, wRAR,\r\nThe problem here is that `logkws.get(\"msg\")` returns `Any | None` instead of `Any`. The previous code works well since it sets a default value in get() and returns `Any`.\r\nIf we don't take measures here, the type of variable message is `Any | None`. And an incompatible return value error arises when conducting tests.\r\n<img width=\"711\" alt=\"c0a2e8ee4fb9c2b8c01599fad954a21\" src=\"https://github.com/scrapy/scrapy/assets/61908960/89f864b7-86fd-499b-a069-d8e49703ed83\">\r\n<img width=\"850\" alt=\"f105114ba8921466f0a84ab5fa76967\" src=\"https://github.com/scrapy/scrapy/assets/61908960/4a5cd105-1d77-4e61-a5f1-b89f167a73e0\">\r\n\r\n\r\n\r\nI came up with three possible solutions:\r\n\r\n1. ```message = logkws.get(\"msg\", logkws.get(\"msg\"))```\r\n2. ```message = logkws.get(\"msg\", \"\")```\r\n3. ```message = str(logkws.get(\"msg\"))```\r\n\r\nDo you have any suggestions or preferences among these three solutions?\r\n",
      "comment_id": 1364758583,
      "user": "Chenwei-Niu",
      "created_at": "2023-10-19T01:15:58Z",
      "url": "https://github.com/scrapy/scrapy/pull/6116#discussion_r1364758583"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 6116,
      "file_path": "scrapy/utils/log.py",
      "line": 235,
      "side": "RIGHT",
      "diff_hunk": "@@ -232,18 +230,9 @@ def logformatter_adapter(logkws: dict) -> Tuple[int, str, dict]:\n     and adapts it into a tuple of positional arguments for logger.log calls,\n     handling backward compatibility as well.\n     \"\"\"\n-    if not {\"level\", \"msg\", \"args\"} <= set(logkws):\n-        warnings.warn(\"Missing keys in LogFormatter method\", ScrapyDeprecationWarning)\n-\n-    if \"format\" in logkws:\n-        warnings.warn(\n-            \"`format` key in LogFormatter methods has been \"\n-            \"deprecated, use `msg` instead\",\n-            ScrapyDeprecationWarning,\n-        )\n \n     level = logkws.get(\"level\", logging.INFO)\n-    message = logkws.get(\"format\", logkws.get(\"msg\"))\n+    message = str(logkws.get(\"msg\"))",
      "comment": "> `logkws.get(\"msg\", \"\")` is fine I think.\r\n\r\nOnly if `msg` is missing from the dict, not if it exists as `None`, which mypy probably considers a possibility.\r\n\r\nIf it _could_ exist as `None` (e.g. it the user made a mistake), `logkws.get(\"msg\") or \"\"` should work. Otherwise, what @wRAR said, and `assert message is not None` after the line should silence mypy about the impossible scenario of `logkws` containing `{\"msg\": None}`.",
      "comment_id": 1365077351,
      "user": "Gallaecio",
      "created_at": "2023-10-19T08:01:11Z",
      "url": "https://github.com/scrapy/scrapy/pull/6116#discussion_r1365077351"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 6116,
      "file_path": "scrapy/utils/log.py",
      "line": 235,
      "side": "RIGHT",
      "diff_hunk": "@@ -232,18 +230,9 @@ def logformatter_adapter(logkws: dict) -> Tuple[int, str, dict]:\n     and adapts it into a tuple of positional arguments for logger.log calls,\n     handling backward compatibility as well.\n     \"\"\"\n-    if not {\"level\", \"msg\", \"args\"} <= set(logkws):\n-        warnings.warn(\"Missing keys in LogFormatter method\", ScrapyDeprecationWarning)\n-\n-    if \"format\" in logkws:\n-        warnings.warn(\n-            \"`format` key in LogFormatter methods has been \"\n-            \"deprecated, use `msg` instead\",\n-            ScrapyDeprecationWarning,\n-        )\n \n     level = logkws.get(\"level\", logging.INFO)\n-    message = logkws.get(\"format\", logkws.get(\"msg\"))\n+    message = str(logkws.get(\"msg\"))",
      "comment": "I\u2018ve already tested, the code below could handle both two scenarios you mentioned.\r\n1. key `msg` is missing in the dictionary\r\n2. Dictionary contains `\"msg\": None`\r\n```python\r\n    message = logkws.get(\"msg\", \"\")\r\n    assert message is not None\r\n```\r\nIf there is no problem, I will modify and commit it.\r\n@Gallaecio @wRAR ",
      "comment_id": 1365156492,
      "user": "Chenwei-Niu",
      "created_at": "2023-10-19T08:55:01Z",
      "url": "https://github.com/scrapy/scrapy/pull/6116#discussion_r1365156492"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 6116,
      "file_path": "scrapy/utils/log.py",
      "line": 236,
      "side": "RIGHT",
      "diff_hunk": "@@ -232,18 +230,10 @@ def logformatter_adapter(logkws: dict) -> Tuple[int, str, dict]:\n     and adapts it into a tuple of positional arguments for logger.log calls,\n     handling backward compatibility as well.\n     \"\"\"\n-    if not {\"level\", \"msg\", \"args\"} <= set(logkws):\n-        warnings.warn(\"Missing keys in LogFormatter method\", ScrapyDeprecationWarning)\n-\n-    if \"format\" in logkws:\n-        warnings.warn(\n-            \"`format` key in LogFormatter methods has been \"\n-            \"deprecated, use `msg` instead\",\n-            ScrapyDeprecationWarning,\n-        )\n \n     level = logkws.get(\"level\", logging.INFO)\n-    message = logkws.get(\"format\", logkws.get(\"msg\"))\n+    message = logkws.get(\"msg\", \"\")\n+    assert message is not None",
      "comment": "OK, now that I look at the warning, I see 2 things:\r\n- The warning was about `msg` being a required key, so I think `logkws[\"msg\"]` instead of `logkws.get(\"msg\", \"\")` makes sense now that the warning is gone.\r\n- There was no warning if `logkws[\"msg\"]` was `None`, so we should assume that as a possibility since this dict seems to be user-provided. So we cannot `assert`, we have to fall back: `message = logkws[\"msg\"] or \"\"`.",
      "comment_id": 1366577406,
      "user": "Gallaecio",
      "created_at": "2023-10-20T07:25:04Z",
      "url": "https://github.com/scrapy/scrapy/pull/6116#discussion_r1366577406"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 6116,
      "file_path": "scrapy/utils/log.py",
      "line": 236,
      "side": "RIGHT",
      "diff_hunk": "@@ -232,18 +230,10 @@ def logformatter_adapter(logkws: dict) -> Tuple[int, str, dict]:\n     and adapts it into a tuple of positional arguments for logger.log calls,\n     handling backward compatibility as well.\n     \"\"\"\n-    if not {\"level\", \"msg\", \"args\"} <= set(logkws):\n-        warnings.warn(\"Missing keys in LogFormatter method\", ScrapyDeprecationWarning)\n-\n-    if \"format\" in logkws:\n-        warnings.warn(\n-            \"`format` key in LogFormatter methods has been \"\n-            \"deprecated, use `msg` instead\",\n-            ScrapyDeprecationWarning,\n-        )\n \n     level = logkws.get(\"level\", logging.INFO)\n-    message = logkws.get(\"format\", logkws.get(\"msg\"))\n+    message = logkws.get(\"msg\", \"\")\n+    assert message is not None",
      "comment": "Hi Gallarcio,\r\nI don't really understand why we have to fall back: `message = logkws[\"msg\"] or \"\"`.\r\n\r\nFirstly ,this part of the warnings has been removed according to   @wRAR 's comments https://github.com/scrapy/scrapy/pull/6116#discussion_r1363487495\r\n``` python\r\nif not {\"level\", \"msg\", \"args\"} <= set(logkws):\r\n        warnings.warn(\"Missing keys in LogFormatter method\", ScrapyDeprecationWarning)\r\n```\r\n----------------\r\nSecondly:\r\n> [Gallaecio](https://github.com/Gallaecio): The warning was about msg being a required key, so I think logkws[\"msg\"] instead of logkws.get(\"msg\", \"\") makes sense now that the warning is gone.\r\n\r\nAlthough msg is a requried key, but it is only mentioned and constrained in comments in `class LogFormatter`,  there is no actual code constraints. The user can still provide a dictionary without the `msg key`. Hence, if `key msg` is missing, simply using `logkws[\"msg\"]` would arise a KeyError.\r\n\r\nAnd I agree the point we cannot assert `message is not None`. \r\nIn fact, our current logging system could cope with the case `{\"msg\": None}`. So maybe only `message = logkws.get(\"msg\", \"\")` should be fine.\r\n",
      "comment_id": 1366704279,
      "user": "Chenwei-Niu",
      "created_at": "2023-10-20T09:12:27Z",
      "url": "https://github.com/scrapy/scrapy/pull/6116#discussion_r1366704279"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 6116,
      "file_path": "scrapy/utils/log.py",
      "line": 236,
      "side": "RIGHT",
      "diff_hunk": "@@ -232,18 +230,10 @@ def logformatter_adapter(logkws: dict) -> Tuple[int, str, dict]:\n     and adapts it into a tuple of positional arguments for logger.log calls,\n     handling backward compatibility as well.\n     \"\"\"\n-    if not {\"level\", \"msg\", \"args\"} <= set(logkws):\n-        warnings.warn(\"Missing keys in LogFormatter method\", ScrapyDeprecationWarning)\n-\n-    if \"format\" in logkws:\n-        warnings.warn(\n-            \"`format` key in LogFormatter methods has been \"\n-            \"deprecated, use `msg` instead\",\n-            ScrapyDeprecationWarning,\n-        )\n \n     level = logkws.get(\"level\", logging.INFO)\n-    message = logkws.get(\"format\", logkws.get(\"msg\"))\n+    message = logkws.get(\"msg\", \"\")\n+    assert message is not None",
      "comment": "I think raising `KeyError` is fine. I think it is the natural evolution from the warning: first msg was probably not necessary, then it became necessary but it worked without it causing a warning, now it will raise KeyError if missing.\r\n\r\nIf `\"msg\": None` is OK, then I agree the fall back is not needed, and we can simply use `logkws[\"msg\"]`.",
      "comment_id": 1366736312,
      "user": "Gallaecio",
      "created_at": "2023-10-20T09:41:22Z",
      "url": "https://github.com/scrapy/scrapy/pull/6116#discussion_r1366736312"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 6116,
      "file_path": "scrapy/utils/log.py",
      "line": 236,
      "side": "RIGHT",
      "diff_hunk": "@@ -232,18 +230,10 @@ def logformatter_adapter(logkws: dict) -> Tuple[int, str, dict]:\n     and adapts it into a tuple of positional arguments for logger.log calls,\n     handling backward compatibility as well.\n     \"\"\"\n-    if not {\"level\", \"msg\", \"args\"} <= set(logkws):\n-        warnings.warn(\"Missing keys in LogFormatter method\", ScrapyDeprecationWarning)\n-\n-    if \"format\" in logkws:\n-        warnings.warn(\n-            \"`format` key in LogFormatter methods has been \"\n-            \"deprecated, use `msg` instead\",\n-            ScrapyDeprecationWarning,\n-        )\n \n     level = logkws.get(\"level\", logging.INFO)\n-    message = logkws.get(\"format\", logkws.get(\"msg\"))\n+    message = logkws.get(\"msg\", \"\")\n+    assert message is not None",
      "comment": "By using `or` operator in case we have the key `msg` but the value is null we fallback to empty string, since the default empty string value using `get()` is only when the dict don\u2019t have the key not for the key being null.",
      "comment_id": 1366740910,
      "user": "Laerte",
      "created_at": "2023-10-20T09:45:24Z",
      "url": "https://github.com/scrapy/scrapy/pull/6116#discussion_r1366740910"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 6116,
      "file_path": "scrapy/utils/log.py",
      "line": 236,
      "side": "RIGHT",
      "diff_hunk": "@@ -232,18 +230,10 @@ def logformatter_adapter(logkws: dict) -> Tuple[int, str, dict]:\n     and adapts it into a tuple of positional arguments for logger.log calls,\n     handling backward compatibility as well.\n     \"\"\"\n-    if not {\"level\", \"msg\", \"args\"} <= set(logkws):\n-        warnings.warn(\"Missing keys in LogFormatter method\", ScrapyDeprecationWarning)\n-\n-    if \"format\" in logkws:\n-        warnings.warn(\n-            \"`format` key in LogFormatter methods has been \"\n-            \"deprecated, use `msg` instead\",\n-            ScrapyDeprecationWarning,\n-        )\n \n     level = logkws.get(\"level\", logging.INFO)\n-    message = logkws.get(\"format\", logkws.get(\"msg\"))\n+    message = logkws.get(\"msg\", \"\")\n+    assert message is not None",
      "comment": "Probably the best solution for this is would be:\r\n\r\n```python\r\nmessage = logkws.get(\"msg\") or \"\"\r\n```",
      "comment_id": 1366744847,
      "user": "Laerte",
      "created_at": "2023-10-20T09:48:53Z",
      "url": "https://github.com/scrapy/scrapy/pull/6116#discussion_r1366744847"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 6116,
      "file_path": "scrapy/utils/log.py",
      "line": 236,
      "side": "RIGHT",
      "diff_hunk": "@@ -232,18 +230,10 @@ def logformatter_adapter(logkws: dict) -> Tuple[int, str, dict]:\n     and adapts it into a tuple of positional arguments for logger.log calls,\n     handling backward compatibility as well.\n     \"\"\"\n-    if not {\"level\", \"msg\", \"args\"} <= set(logkws):\n-        warnings.warn(\"Missing keys in LogFormatter method\", ScrapyDeprecationWarning)\n-\n-    if \"format\" in logkws:\n-        warnings.warn(\n-            \"`format` key in LogFormatter methods has been \"\n-            \"deprecated, use `msg` instead\",\n-            ScrapyDeprecationWarning,\n-        )\n \n     level = logkws.get(\"level\", logging.INFO)\n-    message = logkws.get(\"format\", logkws.get(\"msg\"))\n+    message = logkws.get(\"msg\", \"\")\n+    assert message is not None",
      "comment": "Unless like @Gallaecio said we want to raise a exception so the user can fix their code, then we don\u2019t need to `get` at all only the `or` operator to handle cases where key exist but is null.",
      "comment_id": 1366750217,
      "user": "Laerte",
      "created_at": "2023-10-20T09:53:51Z",
      "url": "https://github.com/scrapy/scrapy/pull/6116#discussion_r1366750217"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 6116,
      "file_path": "scrapy/utils/log.py",
      "line": 236,
      "side": "RIGHT",
      "diff_hunk": "@@ -232,18 +230,10 @@ def logformatter_adapter(logkws: dict) -> Tuple[int, str, dict]:\n     and adapts it into a tuple of positional arguments for logger.log calls,\n     handling backward compatibility as well.\n     \"\"\"\n-    if not {\"level\", \"msg\", \"args\"} <= set(logkws):\n-        warnings.warn(\"Missing keys in LogFormatter method\", ScrapyDeprecationWarning)\n-\n-    if \"format\" in logkws:\n-        warnings.warn(\n-            \"`format` key in LogFormatter methods has been \"\n-            \"deprecated, use `msg` instead\",\n-            ScrapyDeprecationWarning,\n-        )\n \n     level = logkws.get(\"level\", logging.INFO)\n-    message = logkws.get(\"format\", logkws.get(\"msg\"))\n+    message = logkws.get(\"msg\", \"\")\n+    assert message is not None",
      "comment": "Hi @Laerte \r\nI finally edited to ```message = logkws.get(\"msg\") or \"\"``` as your suggestion.\r\nCould you please review and merge my pull request?\r\n\r\nThank you!",
      "comment_id": 1368288895,
      "user": "Chenwei-Niu",
      "created_at": "2023-10-23T08:14:40Z",
      "url": "https://github.com/scrapy/scrapy/pull/6116#discussion_r1368288895"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 6116,
      "file_path": "scrapy/utils/log.py",
      "line": 236,
      "side": "RIGHT",
      "diff_hunk": "@@ -232,18 +230,10 @@ def logformatter_adapter(logkws: dict) -> Tuple[int, str, dict]:\n     and adapts it into a tuple of positional arguments for logger.log calls,\n     handling backward compatibility as well.\n     \"\"\"\n-    if not {\"level\", \"msg\", \"args\"} <= set(logkws):\n-        warnings.warn(\"Missing keys in LogFormatter method\", ScrapyDeprecationWarning)\n-\n-    if \"format\" in logkws:\n-        warnings.warn(\n-            \"`format` key in LogFormatter methods has been \"\n-            \"deprecated, use `msg` instead\",\n-            ScrapyDeprecationWarning,\n-        )\n \n     level = logkws.get(\"level\", logging.INFO)\n-    message = logkws.get(\"format\", logkws.get(\"msg\"))\n+    message = logkws.get(\"msg\", \"\")\n+    assert message is not None",
      "comment": "I don\u2019t have write access, we need to wait for @wRAR / @Gallaecio ",
      "comment_id": 1368345071,
      "user": "Laerte",
      "created_at": "2023-10-23T09:00:02Z",
      "url": "https://github.com/scrapy/scrapy/pull/6116#discussion_r1368345071"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 6116,
      "file_path": "scrapy/utils/log.py",
      "line": 236,
      "side": "RIGHT",
      "diff_hunk": "@@ -232,18 +230,10 @@ def logformatter_adapter(logkws: dict) -> Tuple[int, str, dict]:\n     and adapts it into a tuple of positional arguments for logger.log calls,\n     handling backward compatibility as well.\n     \"\"\"\n-    if not {\"level\", \"msg\", \"args\"} <= set(logkws):\n-        warnings.warn(\"Missing keys in LogFormatter method\", ScrapyDeprecationWarning)\n-\n-    if \"format\" in logkws:\n-        warnings.warn(\n-            \"`format` key in LogFormatter methods has been \"\n-            \"deprecated, use `msg` instead\",\n-            ScrapyDeprecationWarning,\n-        )\n \n     level = logkws.get(\"level\", logging.INFO)\n-    message = logkws.get(\"format\", logkws.get(\"msg\"))\n+    message = logkws.get(\"msg\", \"\")\n+    assert message is not None",
      "comment": "Hi @wRAR @Gallaecio , could you please review and merge this pull request?\r\nThanks!",
      "comment_id": 1371100214,
      "user": "Chenwei-Niu",
      "created_at": "2023-10-25T03:37:07Z",
      "url": "https://github.com/scrapy/scrapy/pull/6116#discussion_r1371100214"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 6113,
      "file_path": "scrapy/pipelines/media.py",
      "line": 146,
      "side": "LEFT",
      "diff_hunk": "@@ -126,37 +123,6 @@ def _process_request(self, request, info, item):\n         )\n         return dfd.addBoth(lambda _: wad)  # it must return wad at last\n \n-    def _make_compatible(self):\n-        \"\"\"Make overridable methods of MediaPipeline and subclasses backwards compatible\"\"\"\n-        methods = [\n-            \"file_path\",\n-            \"thumb_path\",\n-            \"media_to_download\",\n-            \"media_downloaded\",\n-            \"file_downloaded\",\n-            \"image_downloaded\",\n-            \"get_images\",\n-        ]\n-\n-        for method_name in methods:\n-            method = getattr(self, method_name, None)\n-            if callable(method):\n-                setattr(self, method_name, self._compatible(method))\n-\n-    def _compatible(self, func):",
      "comment": "Removed `_compatible` and `_check_signature` methods as well because is not called anymore after  `_make_compatible` removal.",
      "comment_id": 1362895611,
      "user": "Laerte",
      "created_at": "2023-10-17T22:45:50Z",
      "url": "https://github.com/scrapy/scrapy/pull/6113#discussion_r1362895611"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 6113,
      "file_path": "tests/test_feedexport.py",
      "line": 2853,
      "side": "RIGHT",
      "diff_hunk": "@@ -2850,20 +2850,8 @@ def test_init(self):\n             \"FEED_URI\": \"file:///tmp/foobar\",\n             \"FEED_STORAGES\": {\"file\": StdoutFeedStorageWithoutFeedOptions},\n         }\n-        with pytest.warns(\n-            ScrapyDeprecationWarning,\n-            match=\"The `FEED_URI` and `FEED_FORMAT` settings have been deprecated\",\n-        ):\n-            crawler = get_crawler(settings_dict=settings_dict)\n-            feed_exporter = FeedExporter.from_crawler(crawler)\n-\n-        spider = scrapy.Spider(\"default\")\n-        with pytest.warns(\n-            ScrapyDeprecationWarning,\n-            match=\"StdoutFeedStorageWithoutFeedOptions does not support \"\n-            \"the 'feed_options' keyword argument.\",\n-        ):\n-            feed_exporter.open_spider(spider)\n+        with pytest.raises(TypeError):",
      "comment": "Similarly, I think all these `*PreFeedOptionsTest` tests can be removed.",
      "comment_id": 1363484207,
      "user": "wRAR",
      "created_at": "2023-10-18T08:36:53Z",
      "url": "https://github.com/scrapy/scrapy/pull/6113#discussion_r1363484207"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 6050,
      "file_path": "scrapy/downloadermiddlewares/retry.py",
      "line": 43,
      "side": "RIGHT",
      "diff_hunk": "@@ -37,6 +38,13 @@ def EXCEPTIONS_TO_RETRY(cls):\n             load_object(x) if isinstance(x, str) else x\n             for x in Settings().getlist(\"RETRY_EXCEPTIONS\")\n         )\n+    raise AttributeError(\n+        f\"{self.__class__.__name__!r} object has no attribute {name!r}\"\n+    )",
      "comment": "When you try to access an attribute that doesn't exist, like when `__getattr__()` isn't defined.",
      "comment_id": 1325926519,
      "user": "wRAR",
      "created_at": "2023-09-14T13:08:49Z",
      "url": "https://github.com/scrapy/scrapy/pull/6050#discussion_r1325926519"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 6050,
      "file_path": "scrapy/downloadermiddlewares/retry.py",
      "line": 33,
      "side": "RIGHT",
      "diff_hunk": "@@ -23,12 +23,13 @@\n \n retry_logger = getLogger(__name__)\n \n+DEPRECATED_ATTRIBUTE = \"EXCEPTIONS_TO_RETRY\"\n \n-class BackwardsCompatibilityMetaclass(type):\n-    @property\n-    def EXCEPTIONS_TO_RETRY(cls):\n+\n+def backwards_compatibility_getattr(self, name):\n+    if name == DEPRECATED_ATTRIBUTE:\n         warnings.warn(\n-            \"Attribute RetryMiddleware.EXCEPTIONS_TO_RETRY is deprecated. \"\n+            f\"Attribute RetryMiddleware.{DEPRECATED_ATTRIBUTE} is deprecated. \"\n             \"Use the RETRY_EXCEPTIONS setting instead.\",",
      "comment": "I think we should either have both old/new attribute names as constants, or none of them.",
      "comment_id": 1326097899,
      "user": "kmike",
      "created_at": "2023-09-14T15:02:46Z",
      "url": "https://github.com/scrapy/scrapy/pull/6050#discussion_r1326097899"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 6050,
      "file_path": "scrapy/downloadermiddlewares/retry.py",
      "line": 43,
      "side": "RIGHT",
      "diff_hunk": "@@ -37,6 +38,13 @@ def EXCEPTIONS_TO_RETRY(cls):\n             load_object(x) if isinstance(x, str) else x\n             for x in Settings().getlist(\"RETRY_EXCEPTIONS\")\n         )\n+    raise AttributeError(\n+        f\"{self.__class__.__name__!r} object has no attribute {name!r}\"\n+    )",
      "comment": "I was thinking to define super call here, but it only makes sense if there is multiple inheritance and 2+ superclasses redefine `getattr` which is not common in middlewares.\r\n\r\nBut making super call requires function definition to be inside class (to fill `super()` with correct arguments) or to pass correct class as first argument. Since the function is shared between different classes, I decided to just raise `AtrributeError` as super call does in regular single inheritance situation (actually super call is really weird because neither `object` nor `type` have defined `getattr` and yet super call of `getattr` somehow works).",
      "comment_id": 1327689496,
      "user": "Prometheus3375",
      "created_at": "2023-09-15T19:17:15Z",
      "url": "https://github.com/scrapy/scrapy/pull/6050#discussion_r1327689496"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 6038,
      "file_path": "scrapy/crawler.py",
      "line": 76,
      "side": "RIGHT",
      "diff_hunk": "@@ -71,7 +71,6 @@ def __init__(\n \n         self.spidercls: Type[Spider] = spidercls\n         self.settings: Settings = settings.copy()\n-        self.spidercls.update_settings(self.settings)\n \n         self.addons: AddonManager = AddonManager(self)\n         self.addons.load_settings(self.settings)",
      "comment": "We probably should keep this after spider.update_settings.\r\n\r\nIt does not make anything impossible, and if we were to make such a backward-incompatible change this would be the time, when the add-on feature has not yet been used much.\r\n\r\nBut I think it does make common scenarios harder for users: spider-defined settings will not be taken into account for add-ons, so enabling or configuring an add-on on custom_settings would not work. Users could still create a custom add-on for that and put it first, but I think it might be best to move this as well.",
      "comment_id": 1317255199,
      "user": "Gallaecio",
      "created_at": "2023-09-06T13:06:00Z",
      "url": "https://github.com/scrapy/scrapy/pull/6038#discussion_r1317255199"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 6038,
      "file_path": "scrapy/crawler.py",
      "line": 105,
      "side": "RIGHT",
      "diff_hunk": "@@ -105,24 +104,8 @@ def __init__(\n             crawler=self,\n         )",
      "comment": "We might want to move the fingerprinter as well, specially if we move addons, to allow addons to change the fingerprinter.\r\n\r\nI also wonder if there is more stuff we could move. Like logging the overriden settings, and *maybe* stats (not sure what that could break).",
      "comment_id": 1317259116,
      "user": "Gallaecio",
      "created_at": "2023-09-06T13:09:06Z",
      "url": "https://github.com/scrapy/scrapy/pull/6038#discussion_r1317259116"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 6038,
      "file_path": "scrapy/crawler.py",
      "line": 76,
      "side": "RIGHT",
      "diff_hunk": "@@ -71,7 +71,6 @@ def __init__(\n \n         self.spidercls: Type[Spider] = spidercls\n         self.settings: Settings = settings.copy()\n-        self.spidercls.update_settings(self.settings)\n \n         self.addons: AddonManager = AddonManager(self)\n         self.addons.load_settings(self.settings)",
      "comment": "I didn't do anything about these lines for now, but when we discussed it with kmike we thought that it's debatable but looks like we want spiders to enable addons (in which case these lines should indeed be moved).",
      "comment_id": 1317268153,
      "user": "wRAR",
      "created_at": "2023-09-06T13:16:01Z",
      "url": "https://github.com/scrapy/scrapy/pull/6038#discussion_r1317268153"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 6038,
      "file_path": "scrapy/crawler.py",
      "line": 76,
      "side": "RIGHT",
      "diff_hunk": "@@ -71,7 +71,6 @@ def __init__(\n \n         self.spidercls: Type[Spider] = spidercls\n         self.settings: Settings = settings.copy()\n-        self.spidercls.update_settings(self.settings)\n \n         self.addons: AddonManager = AddonManager(self)\n         self.addons.load_settings(self.settings)",
      "comment": "I am also thinking that addons could be a way to cleaning implement argument processing this way.\r\n\r\nIf we move addons after spider.update_settings, addons can use crawler.spider from from_crawler to process spider args. It would happen after spider.__init__, but other than that, it would be cleaner than needing code in a base spider, a spider mixin, or a spider itself.",
      "comment_id": 1317268824,
      "user": "Gallaecio",
      "created_at": "2023-09-06T13:16:30Z",
      "url": "https://github.com/scrapy/scrapy/pull/6038#discussion_r1317268824"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 6038,
      "file_path": "scrapy/crawler.py",
      "line": 121,
      "side": "RIGHT",
      "diff_hunk": "@@ -135,6 +118,26 @@ def crawl(self, *args: Any, **kwargs: Any) -> Generator[Deferred, Any, None]:\n \n         try:\n             self.spider = self._create_spider(*args, **kwargs)\n+            self.spider.update_settings(self.settings)",
      "comment": "I wonder if update_settings running after `__init__` now could be an issue to some existing code, e.g. code reading settings from `__init__`.\r\n\r\nAlso, update_settings kind of becomes unnecessary, since spiders could now use crawler.settings from `__init__` instead for the same purpose. Still convenient, I guess.\r\n\r\nI am thinking, although we do need setting processing to happen within `crawl`, maybe it could still happen before `spider.__init__`.\r\n\r\nAnd we could expose *args and **kwargs to update_settings, with some backward-compatibility code to not pass them if unexpected, or maybe better, through a new method (of extensions?) that gets executed after setting processing but before spider init, gets access to arguments and (unfrozen) settings, and can edit both, so we not only allow arguments to affect settings, we also allow argument processing, like type conversion, or even processing arguments differently based on settings.\r\n\r\nI do wonder whether argument processing should happen at the beginning or at the end, or both. You might want to modify settings based on arguments as soon as possible, e.g. before add-ons do, to allow enabling an add-on through an argument. But to process arguments based on settings, you would prefer that to happen later on, once you have final settings. We could consider 2 methods, maybe?\r\n\r\nMaybe allow update_settings (both spider\u2019s and add-on\u2019s) to get spider arguments, but not modify them, and implement a new method (for extensions?) to process arguments, including modifying them, once settings are frozen?",
      "comment_id": 1317283267,
      "user": "Gallaecio",
      "created_at": "2023-09-06T13:27:14Z",
      "url": "https://github.com/scrapy/scrapy/pull/6038#discussion_r1317283267"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 6038,
      "file_path": "tests/test_downloadermiddleware.py",
      "line": 30,
      "side": "RIGHT",
      "diff_hunk": "@@ -3,33 +3,33 @@\n \n from pytest import mark\n from twisted.internet import defer\n-from twisted.internet.defer import Deferred\n+from twisted.internet.defer import Deferred, inlineCallbacks\n from twisted.python.failure import Failure\n from twisted.trial.unittest import TestCase\n \n from scrapy.core.downloader.middleware import DownloaderMiddlewareManager\n from scrapy.exceptions import _InvalidOutput\n from scrapy.http import Request, Response\n-from scrapy.spiders import Spider\n from scrapy.utils.python import to_bytes\n from scrapy.utils.test import get_crawler, get_from_asyncio_queue\n+from tests.spiders import NoRequestsSpider\n \n \n class ManagerTestCase(TestCase):\n     settings_dict = None\n \n+    @inlineCallbacks\n     def setUp(self):\n-        self.crawler = get_crawler(Spider, self.settings_dict)\n-        self.spider = self.crawler._create_spider(\"foo\")\n+        self.crawler = get_crawler(NoRequestsSpider, self.settings_dict)\n+        yield self.crawler.crawl()\n+        self.spider = self.crawler.spider\n         self.mwman = DownloaderMiddlewareManager.from_crawler(self.crawler)\n-        # some mw depends on stats collector\n-        self.crawler.stats.open_spider(self.spider)\n-        return self.mwman.open_spider(self.spider)\n+        yield self.mwman.open_spider(self.spider)\n \n     def tearDown(self):\n-        self.crawler.stats.close_spider(self.spider, \"\")\n         return self.mwman.close_spider(self.spider)",
      "comment": "Should we close/stop the crawler itself? \r\nA related question: instead of creating DownloaderMiddlewareManager, should we get an instance which is created by the crawler?",
      "comment_id": 1321415945,
      "user": "kmike",
      "created_at": "2023-09-11T11:43:30Z",
      "url": "https://github.com/scrapy/scrapy/pull/6038#discussion_r1321415945"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 6038,
      "file_path": "tests/test_downloadermiddleware.py",
      "line": 30,
      "side": "RIGHT",
      "diff_hunk": "@@ -3,33 +3,33 @@\n \n from pytest import mark\n from twisted.internet import defer\n-from twisted.internet.defer import Deferred\n+from twisted.internet.defer import Deferred, inlineCallbacks\n from twisted.python.failure import Failure\n from twisted.trial.unittest import TestCase\n \n from scrapy.core.downloader.middleware import DownloaderMiddlewareManager\n from scrapy.exceptions import _InvalidOutput\n from scrapy.http import Request, Response\n-from scrapy.spiders import Spider\n from scrapy.utils.python import to_bytes\n from scrapy.utils.test import get_crawler, get_from_asyncio_queue\n+from tests.spiders import NoRequestsSpider\n \n \n class ManagerTestCase(TestCase):\n     settings_dict = None\n \n+    @inlineCallbacks\n     def setUp(self):\n-        self.crawler = get_crawler(Spider, self.settings_dict)\n-        self.spider = self.crawler._create_spider(\"foo\")\n+        self.crawler = get_crawler(NoRequestsSpider, self.settings_dict)\n+        yield self.crawler.crawl()\n+        self.spider = self.crawler.spider\n         self.mwman = DownloaderMiddlewareManager.from_crawler(self.crawler)\n-        # some mw depends on stats collector\n-        self.crawler.stats.open_spider(self.spider)\n-        return self.mwman.open_spider(self.spider)\n+        yield self.mwman.open_spider(self.spider)\n \n     def tearDown(self):\n-        self.crawler.stats.close_spider(self.spider, \"\")\n         return self.mwman.close_spider(self.spider)",
      "comment": "> Should we close the crawler itself?\r\n\r\nThe crawler should be \"closed\" when `yield crawl()` returns.\r\n\r\n> instead of creating DownloaderMiddlewareManager, should we get an instance which is created by the crawler?\r\n\r\nThat instance is created by the engine, so we can do it if we decide to keep calling `crawler.crawl()` (which I was going to revert and just call `_load_settings()`).",
      "comment_id": 1321426814,
      "user": "wRAR",
      "created_at": "2023-09-11T11:52:01Z",
      "url": "https://github.com/scrapy/scrapy/pull/6038#discussion_r1321426814"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 6038,
      "file_path": "tests/test_downloadermiddleware_httpcompression.py",
      "line": 387,
      "side": "RIGHT",
      "diff_hunk": "@@ -374,13 +376,15 @@ def test_process_response_head_request_no_decode_required(self):\n         self.assertStatsEqual(\"httpcompression/response_bytes\", None)\n \n \n-class HttpCompressionSubclassTest(TestCase):\n+class HttpCompressionSubclassTest(unittest.TestCase):\n+    @inlineCallbacks\n     def test_init_missing_stats(self):\n         class HttpCompressionMiddlewareSubclass(HttpCompressionMiddleware):\n             def __init__(self):\n                 super().__init__()\n \n-        crawler = get_crawler(Spider)\n+        crawler = get_crawler(NoRequestsSpider)\n+        yield crawler.crawl()",
      "comment": "again, should the crawler be stopped? Or is it not required, and there is no clean-up needed?",
      "comment_id": 1321456642,
      "user": "kmike",
      "created_at": "2023-09-11T12:12:38Z",
      "url": "https://github.com/scrapy/scrapy/pull/6038#discussion_r1321456642"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 6038,
      "file_path": "tests/test_downloadermiddleware_httpcompression.py",
      "line": 387,
      "side": "RIGHT",
      "diff_hunk": "@@ -374,13 +376,15 @@ def test_process_response_head_request_no_decode_required(self):\n         self.assertStatsEqual(\"httpcompression/response_bytes\", None)\n \n \n-class HttpCompressionSubclassTest(TestCase):\n+class HttpCompressionSubclassTest(unittest.TestCase):\n+    @inlineCallbacks\n     def test_init_missing_stats(self):\n         class HttpCompressionMiddlewareSubclass(HttpCompressionMiddleware):\n             def __init__(self):\n                 super().__init__()\n \n-        crawler = get_crawler(Spider)\n+        crawler = get_crawler(NoRequestsSpider)\n+        yield crawler.crawl()",
      "comment": "(there are a few more places; I won't be adding comments about them, as they seem redundant)",
      "comment_id": 1321457973,
      "user": "kmike",
      "created_at": "2023-09-11T12:13:56Z",
      "url": "https://github.com/scrapy/scrapy/pull/6038#discussion_r1321457973"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 6038,
      "file_path": "tests/test_downloadermiddleware_httpcompression.py",
      "line": 387,
      "side": "RIGHT",
      "diff_hunk": "@@ -374,13 +376,15 @@ def test_process_response_head_request_no_decode_required(self):\n         self.assertStatsEqual(\"httpcompression/response_bytes\", None)\n \n \n-class HttpCompressionSubclassTest(TestCase):\n+class HttpCompressionSubclassTest(unittest.TestCase):\n+    @inlineCallbacks\n     def test_init_missing_stats(self):\n         class HttpCompressionMiddlewareSubclass(HttpCompressionMiddleware):\n             def __init__(self):\n                 super().__init__()\n \n-        crawler = get_crawler(Spider)\n+        crawler = get_crawler(NoRequestsSpider)\n+        yield crawler.crawl()",
      "comment": "https://github.com/scrapy/scrapy/pull/6038#discussion_r1321426814",
      "comment_id": 1321458240,
      "user": "wRAR",
      "created_at": "2023-09-11T12:14:11Z",
      "url": "https://github.com/scrapy/scrapy/pull/6038#discussion_r1321458240"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 6038,
      "file_path": "tests/test_dupefilters.py",
      "line": 20,
      "side": "RIGHT",
      "diff_hunk": "@@ -2,22 +2,25 @@\n import shutil\n import sys\n import tempfile\n-import unittest\n from pathlib import Path\n \n from testfixtures import LogCapture\n+from twisted.internet.defer import inlineCallbacks\n+from twisted.trial import unittest\n \n from scrapy.core.scheduler import Scheduler\n from scrapy.dupefilters import RFPDupeFilter\n from scrapy.http import Request\n from scrapy.utils.python import to_bytes\n from scrapy.utils.test import get_crawler\n-from tests.spiders import SimpleSpider\n+from tests.spiders import NoRequestsSpider\n \n \n+@inlineCallbacks\n def _get_dupefilter(*, crawler=None, settings=None, open=True):",
      "comment": "I wonder if this function should get the dupefilter from the crawler, instead of creating a new one. No strong opinion though.",
      "comment_id": 1321459893,
      "user": "kmike",
      "created_at": "2023-09-11T12:15:41Z",
      "url": "https://github.com/scrapy/scrapy/pull/6038#discussion_r1321459893"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 6038,
      "file_path": "tests/test_engine.py",
      "line": 426,
      "side": "RIGHT",
      "diff_hunk": "@@ -420,12 +420,16 @@ def _assert_signals_caught(self, run: CrawlerRun):\n \n     @defer.inlineCallbacks\n     def test_close_downloader(self):\n-        e = ExecutionEngine(get_crawler(TestSpider), lambda _: None)\n+        crawler = get_crawler(TestSpider)\n+        yield crawler.crawl()\n+        e = ExecutionEngine(crawler, lambda _: None)\n         yield e.close()",
      "comment": "1. Why is this test called test_close_downloader?\r\n2. Why is the engine closed, but the crawler isn't? Would it make more sense to pick engine from the crawler, and the close the crawler?\r\n3. tbh, I don't quite get what is this test testing\r\n",
      "comment_id": 1321463137,
      "user": "kmike",
      "created_at": "2023-09-11T12:18:35Z",
      "url": "https://github.com/scrapy/scrapy/pull/6038#discussion_r1321463137"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 6038,
      "file_path": "tests/test_downloadermiddleware.py",
      "line": 30,
      "side": "RIGHT",
      "diff_hunk": "@@ -3,33 +3,33 @@\n \n from pytest import mark\n from twisted.internet import defer\n-from twisted.internet.defer import Deferred\n+from twisted.internet.defer import Deferred, inlineCallbacks\n from twisted.python.failure import Failure\n from twisted.trial.unittest import TestCase\n \n from scrapy.core.downloader.middleware import DownloaderMiddlewareManager\n from scrapy.exceptions import _InvalidOutput\n from scrapy.http import Request, Response\n-from scrapy.spiders import Spider\n from scrapy.utils.python import to_bytes\n from scrapy.utils.test import get_crawler, get_from_asyncio_queue\n+from tests.spiders import NoRequestsSpider\n \n \n class ManagerTestCase(TestCase):\n     settings_dict = None\n \n+    @inlineCallbacks\n     def setUp(self):\n-        self.crawler = get_crawler(Spider, self.settings_dict)\n-        self.spider = self.crawler._create_spider(\"foo\")\n+        self.crawler = get_crawler(NoRequestsSpider, self.settings_dict)\n+        yield self.crawler.crawl()\n+        self.spider = self.crawler.spider\n         self.mwman = DownloaderMiddlewareManager.from_crawler(self.crawler)\n-        # some mw depends on stats collector\n-        self.crawler.stats.open_spider(self.spider)\n-        return self.mwman.open_spider(self.spider)\n+        yield self.mwman.open_spider(self.spider)\n \n     def tearDown(self):\n-        self.crawler.stats.close_spider(self.spider, \"\")\n         return self.mwman.close_spider(self.spider)",
      "comment": "> The crawler should be \"closed\" when yield crawl() returns.\r\n\r\noh, right; I think most of my comments to the PR are irrelevant :)",
      "comment_id": 1321466117,
      "user": "kmike",
      "created_at": "2023-09-11T12:21:20Z",
      "url": "https://github.com/scrapy/scrapy/pull/6038#discussion_r1321466117"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 6038,
      "file_path": "tests/test_dupefilters.py",
      "line": 20,
      "side": "RIGHT",
      "diff_hunk": "@@ -2,22 +2,25 @@\n import shutil\n import sys\n import tempfile\n-import unittest\n from pathlib import Path\n \n from testfixtures import LogCapture\n+from twisted.internet.defer import inlineCallbacks\n+from twisted.trial import unittest\n \n from scrapy.core.scheduler import Scheduler\n from scrapy.dupefilters import RFPDupeFilter\n from scrapy.http import Request\n from scrapy.utils.python import to_bytes\n from scrapy.utils.test import get_crawler\n-from tests.spiders import SimpleSpider\n+from tests.spiders import NoRequestsSpider\n \n \n+@inlineCallbacks\n def _get_dupefilter(*, crawler=None, settings=None, open=True):",
      "comment": "Same as with `DownloaderMiddlewareManager`, it's created via the engine, so it would make sense if we run `crawler.crawl()` and doesn't if we don't, except that here we also open and close the dupefilter explicitly, which can be problematic if it was already opened and closed during `crawler.crawl()`.",
      "comment_id": 1321474980,
      "user": "wRAR",
      "created_at": "2023-09-11T12:28:55Z",
      "url": "https://github.com/scrapy/scrapy/pull/6038#discussion_r1321474980"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 6038,
      "file_path": "tests/test_downloadermiddleware.py",
      "line": 30,
      "side": "RIGHT",
      "diff_hunk": "@@ -3,33 +3,33 @@\n \n from pytest import mark\n from twisted.internet import defer\n-from twisted.internet.defer import Deferred\n+from twisted.internet.defer import Deferred, inlineCallbacks\n from twisted.python.failure import Failure\n from twisted.trial.unittest import TestCase\n \n from scrapy.core.downloader.middleware import DownloaderMiddlewareManager\n from scrapy.exceptions import _InvalidOutput\n from scrapy.http import Request, Response\n-from scrapy.spiders import Spider\n from scrapy.utils.python import to_bytes\n from scrapy.utils.test import get_crawler, get_from_asyncio_queue\n+from tests.spiders import NoRequestsSpider\n \n \n class ManagerTestCase(TestCase):\n     settings_dict = None\n \n+    @inlineCallbacks\n     def setUp(self):\n-        self.crawler = get_crawler(Spider, self.settings_dict)\n-        self.spider = self.crawler._create_spider(\"foo\")\n+        self.crawler = get_crawler(NoRequestsSpider, self.settings_dict)\n+        yield self.crawler.crawl()\n+        self.spider = self.crawler.spider\n         self.mwman = DownloaderMiddlewareManager.from_crawler(self.crawler)\n-        # some mw depends on stats collector\n-        self.crawler.stats.open_spider(self.spider)\n-        return self.mwman.open_spider(self.spider)\n+        yield self.mwman.open_spider(self.spider)\n \n     def tearDown(self):\n-        self.crawler.stats.close_spider(self.spider, \"\")\n         return self.mwman.close_spider(self.spider)",
      "comment": "> The crawler should be \"closed\" when yield crawl() returns.\r\n\r\nHm, why would it be guaranteed? It seems crawler.crawl waits until `self.engine.start` is successful, but it doesn't wait for the crawling to be stopped. \r\n",
      "comment_id": 1321483215,
      "user": "kmike",
      "created_at": "2023-09-11T12:36:03Z",
      "url": "https://github.com/scrapy/scrapy/pull/6038#discussion_r1321483215"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 6038,
      "file_path": "tests/test_engine.py",
      "line": 426,
      "side": "RIGHT",
      "diff_hunk": "@@ -420,12 +420,16 @@ def _assert_signals_caught(self, run: CrawlerRun):\n \n     @defer.inlineCallbacks\n     def test_close_downloader(self):\n-        e = ExecutionEngine(get_crawler(TestSpider), lambda _: None)\n+        crawler = get_crawler(TestSpider)\n+        yield crawler.crawl()\n+        e = ExecutionEngine(crawler, lambda _: None)\n         yield e.close()",
      "comment": "> Why is this test called test_close_downloader?\r\n\r\nInitially there were three tests added in #1423: `test_close_downloader`, `test_close_spiders_downloader` and `test_close_engine_spiders_downloader` which called and tested different open/close things, then the last two were removed when `ExecutionEngine.open_spiders` was removed.\r\n\r\n> tbh, I don't quite get what is this test testing\r\n\r\nI guess it just tests that `ExecutionEngine.close()` doesn't produce exceptions.",
      "comment_id": 1321484638,
      "user": "wRAR",
      "created_at": "2023-09-11T12:37:16Z",
      "url": "https://github.com/scrapy/scrapy/pull/6038#discussion_r1321484638"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 6038,
      "file_path": "tests/test_downloadermiddleware.py",
      "line": 30,
      "side": "RIGHT",
      "diff_hunk": "@@ -3,33 +3,33 @@\n \n from pytest import mark\n from twisted.internet import defer\n-from twisted.internet.defer import Deferred\n+from twisted.internet.defer import Deferred, inlineCallbacks\n from twisted.python.failure import Failure\n from twisted.trial.unittest import TestCase\n \n from scrapy.core.downloader.middleware import DownloaderMiddlewareManager\n from scrapy.exceptions import _InvalidOutput\n from scrapy.http import Request, Response\n-from scrapy.spiders import Spider\n from scrapy.utils.python import to_bytes\n from scrapy.utils.test import get_crawler, get_from_asyncio_queue\n+from tests.spiders import NoRequestsSpider\n \n \n class ManagerTestCase(TestCase):\n     settings_dict = None\n \n+    @inlineCallbacks\n     def setUp(self):\n-        self.crawler = get_crawler(Spider, self.settings_dict)\n-        self.spider = self.crawler._create_spider(\"foo\")\n+        self.crawler = get_crawler(NoRequestsSpider, self.settings_dict)\n+        yield self.crawler.crawl()\n+        self.spider = self.crawler.spider\n         self.mwman = DownloaderMiddlewareManager.from_crawler(self.crawler)\n-        # some mw depends on stats collector\n-        self.crawler.stats.open_spider(self.spider)\n-        return self.mwman.open_spider(self.spider)\n+        yield self.mwman.open_spider(self.spider)\n \n     def tearDown(self):\n-        self.crawler.stats.close_spider(self.spider, \"\")\n         return self.mwman.close_spider(self.spider)",
      "comment": "`ExecutionEngine.start()` returns a deferred that fires when the crawling finishes.",
      "comment_id": 1321486553,
      "user": "wRAR",
      "created_at": "2023-09-11T12:38:46Z",
      "url": "https://github.com/scrapy/scrapy/pull/6038#discussion_r1321486553"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 6038,
      "file_path": "tests/test_downloadermiddleware.py",
      "line": 30,
      "side": "RIGHT",
      "diff_hunk": "@@ -3,33 +3,33 @@\n \n from pytest import mark\n from twisted.internet import defer\n-from twisted.internet.defer import Deferred\n+from twisted.internet.defer import Deferred, inlineCallbacks\n from twisted.python.failure import Failure\n from twisted.trial.unittest import TestCase\n \n from scrapy.core.downloader.middleware import DownloaderMiddlewareManager\n from scrapy.exceptions import _InvalidOutput\n from scrapy.http import Request, Response\n-from scrapy.spiders import Spider\n from scrapy.utils.python import to_bytes\n from scrapy.utils.test import get_crawler, get_from_asyncio_queue\n+from tests.spiders import NoRequestsSpider\n \n \n class ManagerTestCase(TestCase):\n     settings_dict = None\n \n+    @inlineCallbacks\n     def setUp(self):\n-        self.crawler = get_crawler(Spider, self.settings_dict)\n-        self.spider = self.crawler._create_spider(\"foo\")\n+        self.crawler = get_crawler(NoRequestsSpider, self.settings_dict)\n+        yield self.crawler.crawl()\n+        self.spider = self.crawler.spider\n         self.mwman = DownloaderMiddlewareManager.from_crawler(self.crawler)\n-        # some mw depends on stats collector\n-        self.crawler.stats.open_spider(self.spider)\n-        return self.mwman.open_spider(self.spider)\n+        yield self.mwman.open_spider(self.spider)\n \n     def tearDown(self):\n-        self.crawler.stats.close_spider(self.spider, \"\")\n         return self.mwman.close_spider(self.spider)",
      "comment": "Overall, it seems we're doing some strange things in the tests, which is not very clean: \r\n\r\n* crawler is started and stopped(?)\r\n* then some internal components are created using this stopped crawler (which we don't have a well-defined behavior for)\r\n\r\nIt seems we're not using our public APIs (or any well-defined APIs), and instead just trying to get the components in usable state, using whatever the current inernal behavior is.\r\n\r\nI haven't understood the recent proposals about `_load_settings`, maybe it makes sense to try them.\r\n\r\nAnother alternative would be to try to use public APIs. If it's not possible with the current .crawl API, it could be an argument to improve Crawler API slightly, e.g. split .crawl() into a few methods, e.g. to init the crawler and actually start it (.crawl sould be kept as a shortcut to do both).\r\n",
      "comment_id": 1321491350,
      "user": "kmike",
      "created_at": "2023-09-11T12:42:47Z",
      "url": "https://github.com/scrapy/scrapy/pull/6038#discussion_r1321491350"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 6038,
      "file_path": "tests/test_downloadermiddleware.py",
      "line": 30,
      "side": "RIGHT",
      "diff_hunk": "@@ -3,33 +3,33 @@\n \n from pytest import mark\n from twisted.internet import defer\n-from twisted.internet.defer import Deferred\n+from twisted.internet.defer import Deferred, inlineCallbacks\n from twisted.python.failure import Failure\n from twisted.trial.unittest import TestCase\n \n from scrapy.core.downloader.middleware import DownloaderMiddlewareManager\n from scrapy.exceptions import _InvalidOutput\n from scrapy.http import Request, Response\n-from scrapy.spiders import Spider\n from scrapy.utils.python import to_bytes\n from scrapy.utils.test import get_crawler, get_from_asyncio_queue\n+from tests.spiders import NoRequestsSpider\n \n \n class ManagerTestCase(TestCase):\n     settings_dict = None\n \n+    @inlineCallbacks\n     def setUp(self):\n-        self.crawler = get_crawler(Spider, self.settings_dict)\n-        self.spider = self.crawler._create_spider(\"foo\")\n+        self.crawler = get_crawler(NoRequestsSpider, self.settings_dict)\n+        yield self.crawler.crawl()\n+        self.spider = self.crawler.spider\n         self.mwman = DownloaderMiddlewareManager.from_crawler(self.crawler)\n-        # some mw depends on stats collector\n-        self.crawler.stats.open_spider(self.spider)\n-        return self.mwman.open_spider(self.spider)\n+        yield self.mwman.open_spider(self.spider)\n \n     def tearDown(self):\n-        self.crawler.stats.close_spider(self.spider, \"\")\n         return self.mwman.close_spider(self.spider)",
      "comment": "> ExecutionEngine.start() returns a deferred that fires when the crawling finishes\r\n\r\nOh, you're right again :)",
      "comment_id": 1321496065,
      "user": "kmike",
      "created_at": "2023-09-11T12:46:42Z",
      "url": "https://github.com/scrapy/scrapy/pull/6038#discussion_r1321496065"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 6038,
      "file_path": "tests/test_downloadermiddleware.py",
      "line": 30,
      "side": "RIGHT",
      "diff_hunk": "@@ -3,33 +3,33 @@\n \n from pytest import mark\n from twisted.internet import defer\n-from twisted.internet.defer import Deferred\n+from twisted.internet.defer import Deferred, inlineCallbacks\n from twisted.python.failure import Failure\n from twisted.trial.unittest import TestCase\n \n from scrapy.core.downloader.middleware import DownloaderMiddlewareManager\n from scrapy.exceptions import _InvalidOutput\n from scrapy.http import Request, Response\n-from scrapy.spiders import Spider\n from scrapy.utils.python import to_bytes\n from scrapy.utils.test import get_crawler, get_from_asyncio_queue\n+from tests.spiders import NoRequestsSpider\n \n \n class ManagerTestCase(TestCase):\n     settings_dict = None\n \n+    @inlineCallbacks\n     def setUp(self):\n-        self.crawler = get_crawler(Spider, self.settings_dict)\n-        self.spider = self.crawler._create_spider(\"foo\")\n+        self.crawler = get_crawler(NoRequestsSpider, self.settings_dict)\n+        yield self.crawler.crawl()\n+        self.spider = self.crawler.spider\n         self.mwman = DownloaderMiddlewareManager.from_crawler(self.crawler)\n-        # some mw depends on stats collector\n-        self.crawler.stats.open_spider(self.spider)\n-        return self.mwman.open_spider(self.spider)\n+        yield self.mwman.open_spider(self.spider)\n \n     def tearDown(self):\n-        self.crawler.stats.close_spider(self.spider, \"\")\n         return self.mwman.close_spider(self.spider)",
      "comment": "> Overall, it seems we're doing some strange things in the tests, which is not very clean:\r\n\r\nYes, this is my main problem with the current PR code and the main reason I want a separate initialization function.\r\n\r\n> Another alternative would be to try to use public APIs. If it's not possible with the current .crawl API, it could be an argument to improve Crawler API slightly, e.g. split .crawl() into a few methods, e.g. to init the crawler and actually start it (.crawl sould be kept as a shortcut to do both).\r\n\r\nThat's what I proposed initially in https://github.com/scrapy/scrapy/pull/6038#issuecomment-1710108413 and recently in https://github.com/scrapy/scrapy/pull/6038#issuecomment-1713601583\r\n\r\nThough I see it as a private function that includes all that initialization we are moving from `__init__`, not something we expect the user to call. If we want public functions, I think it's better to reshuffle the code so that we have e.g. only `__init__()` and `crawl()`, not 3 functions, but I'm not sure how useful would that be.",
      "comment_id": 1321625845,
      "user": "wRAR",
      "created_at": "2023-09-11T14:15:22Z",
      "url": "https://github.com/scrapy/scrapy/pull/6038#discussion_r1321625845"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 6038,
      "file_path": "tests/test_downloadermiddleware.py",
      "line": 30,
      "side": "RIGHT",
      "diff_hunk": "@@ -3,33 +3,33 @@\n \n from pytest import mark\n from twisted.internet import defer\n-from twisted.internet.defer import Deferred\n+from twisted.internet.defer import Deferred, inlineCallbacks\n from twisted.python.failure import Failure\n from twisted.trial.unittest import TestCase\n \n from scrapy.core.downloader.middleware import DownloaderMiddlewareManager\n from scrapy.exceptions import _InvalidOutput\n from scrapy.http import Request, Response\n-from scrapy.spiders import Spider\n from scrapy.utils.python import to_bytes\n from scrapy.utils.test import get_crawler, get_from_asyncio_queue\n+from tests.spiders import NoRequestsSpider\n \n \n class ManagerTestCase(TestCase):\n     settings_dict = None\n \n+    @inlineCallbacks\n     def setUp(self):\n-        self.crawler = get_crawler(Spider, self.settings_dict)\n-        self.spider = self.crawler._create_spider(\"foo\")\n+        self.crawler = get_crawler(NoRequestsSpider, self.settings_dict)\n+        yield self.crawler.crawl()\n+        self.spider = self.crawler.spider\n         self.mwman = DownloaderMiddlewareManager.from_crawler(self.crawler)\n-        # some mw depends on stats collector\n-        self.crawler.stats.open_spider(self.spider)\n-        return self.mwman.open_spider(self.spider)\n+        yield self.mwman.open_spider(self.spider)\n \n     def tearDown(self):\n-        self.crawler.stats.close_spider(self.spider, \"\")\n         return self.mwman.close_spider(self.spider)",
      "comment": "To be more concrete, I was thinking about doing it like this:\r\n\r\n```py\r\n    def init_crawl(self):  # we can also make it private\r\n        # + exception and flag handling\r\n        self.spider = self._create_spider(*args, **kwargs)\r\n        self.engine = self._create_engine()\r\n        # all the new initialization code moved from __init__ goes here?\r\n\r\n    @defer.inlineCallbacks\r\n    def start_engine(self):  # we can also make it private\r\n        # + exception and flag handling\r\n        start_requests = iter(self.spider.start_requests())\r\n        yield self.engine.open_spider(self.spider, start_requests)\r\n        yield defer.maybeDeferred(self.engine.start)\r\n\r\n    @defer.inlineCallbacks\r\n    def crawl(self):\r\n        self.init_crawl()\r\n        yield self.start_engine()\r\n```\r\n\r\nIs the idea to just move init_crawl content to `__init__`? On a first sight, it looks more risky, as it'd start calling `spider.__init__` and `spider.from_crawler`, so we'd need to check if that's backwards compatible, and what kind of issues it can raise.",
      "comment_id": 1321640717,
      "user": "kmike",
      "created_at": "2023-09-11T14:25:42Z",
      "url": "https://github.com/scrapy/scrapy/pull/6038#discussion_r1321640717"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 6038,
      "file_path": "tests/test_downloadermiddleware.py",
      "line": 30,
      "side": "RIGHT",
      "diff_hunk": "@@ -3,33 +3,33 @@\n \n from pytest import mark\n from twisted.internet import defer\n-from twisted.internet.defer import Deferred\n+from twisted.internet.defer import Deferred, inlineCallbacks\n from twisted.python.failure import Failure\n from twisted.trial.unittest import TestCase\n \n from scrapy.core.downloader.middleware import DownloaderMiddlewareManager\n from scrapy.exceptions import _InvalidOutput\n from scrapy.http import Request, Response\n-from scrapy.spiders import Spider\n from scrapy.utils.python import to_bytes\n from scrapy.utils.test import get_crawler, get_from_asyncio_queue\n+from tests.spiders import NoRequestsSpider\n \n \n class ManagerTestCase(TestCase):\n     settings_dict = None\n \n+    @inlineCallbacks\n     def setUp(self):\n-        self.crawler = get_crawler(Spider, self.settings_dict)\n-        self.spider = self.crawler._create_spider(\"foo\")\n+        self.crawler = get_crawler(NoRequestsSpider, self.settings_dict)\n+        yield self.crawler.crawl()\n+        self.spider = self.crawler.spider\n         self.mwman = DownloaderMiddlewareManager.from_crawler(self.crawler)\n-        # some mw depends on stats collector\n-        self.crawler.stats.open_spider(self.spider)\n-        return self.mwman.open_spider(self.spider)\n+        yield self.mwman.open_spider(self.spider)\n \n     def tearDown(self):\n-        self.crawler.stats.close_spider(self.spider, \"\")\n         return self.mwman.close_spider(self.spider)",
      "comment": "2 separate private functions look better to me than 1 private function (_init_crawl + keep engine starting code in `crawl()`), because this way we'd \r\n\r\n1) keep the code in crawl() on the same level of abstraction (no low-level vs high-level code)\r\n2) allow to do the init, then do something else, and then start the crawl; it kind-of makes the init function semi-official, not just another internal implementation detail we plug into \r\n\r\n",
      "comment_id": 1321644269,
      "user": "kmike",
      "created_at": "2023-09-11T14:28:21Z",
      "url": "https://github.com/scrapy/scrapy/pull/6038#discussion_r1321644269"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 6038,
      "file_path": "tests/test_downloadermiddleware.py",
      "line": 30,
      "side": "RIGHT",
      "diff_hunk": "@@ -3,33 +3,33 @@\n \n from pytest import mark\n from twisted.internet import defer\n-from twisted.internet.defer import Deferred\n+from twisted.internet.defer import Deferred, inlineCallbacks\n from twisted.python.failure import Failure\n from twisted.trial.unittest import TestCase\n \n from scrapy.core.downloader.middleware import DownloaderMiddlewareManager\n from scrapy.exceptions import _InvalidOutput\n from scrapy.http import Request, Response\n-from scrapy.spiders import Spider\n from scrapy.utils.python import to_bytes\n from scrapy.utils.test import get_crawler, get_from_asyncio_queue\n+from tests.spiders import NoRequestsSpider\n \n \n class ManagerTestCase(TestCase):\n     settings_dict = None\n \n+    @inlineCallbacks\n     def setUp(self):\n-        self.crawler = get_crawler(Spider, self.settings_dict)\n-        self.spider = self.crawler._create_spider(\"foo\")\n+        self.crawler = get_crawler(NoRequestsSpider, self.settings_dict)\n+        yield self.crawler.crawl()\n+        self.spider = self.crawler.spider\n         self.mwman = DownloaderMiddlewareManager.from_crawler(self.crawler)\n-        # some mw depends on stats collector\n-        self.crawler.stats.open_spider(self.spider)\n-        return self.mwman.open_spider(self.spider)\n+        yield self.mwman.open_spider(self.spider)\n \n     def tearDown(self):\n-        self.crawler.stats.close_spider(self.spider, \"\")\n         return self.mwman.close_spider(self.spider)",
      "comment": "The current idea is\r\n\r\n```python\r\n    def _load_settings(self) -> None:\r\n        if self._settings_loaded:\r\n            return\r\n        self._settings_loaded = True\r\n        # all the new initialization code moved from __init__ goes here\r\n\r\n    def crawl(self, *args: Any, **kwargs: Any) -> Generator[Deferred, Any, None]:\r\n        # flag handling\r\n        try:\r\n            self.spider = self._create_spider(*args, **kwargs)\r\n            self._load_settings()\r\n            self.engine = self._create_engine()\r\n            # etc.\r\n```\r\n\r\nso the `Crawler` API is the same but `scrapy shell` and `scrapy.utils.test.get_crawler()` can call `crawler._load_settings()` (and `crawler.spider = crawler._create_spider()` if needed) to get an initialized Crawler instance. This doesn't create or start the engine, but the old API didn't either.\r\n\r\nWe could move `_create_spider` and `_create_engine` there too, to slightly simplify the code in `scrapy shell` and to allow tests to get more components from the engine, though this state may still be not suitable for some tests (e.g. `engine.scheduler` is only assigned in `engine.open_spider()`) and also making such changes to tests is out of scope.\r\n\r\n> Is the idea to just move init_crawl content to __init__\r\n\r\nI don't want to do this but I proposed it as a way to have no more than 2 public methods.\r\n\r\n",
      "comment_id": 1321666508,
      "user": "wRAR",
      "created_at": "2023-09-11T14:44:37Z",
      "url": "https://github.com/scrapy/scrapy/pull/6038#discussion_r1321666508"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 6038,
      "file_path": "tests/test_downloadermiddleware.py",
      "line": 30,
      "side": "RIGHT",
      "diff_hunk": "@@ -3,33 +3,33 @@\n \n from pytest import mark\n from twisted.internet import defer\n-from twisted.internet.defer import Deferred\n+from twisted.internet.defer import Deferred, inlineCallbacks\n from twisted.python.failure import Failure\n from twisted.trial.unittest import TestCase\n \n from scrapy.core.downloader.middleware import DownloaderMiddlewareManager\n from scrapy.exceptions import _InvalidOutput\n from scrapy.http import Request, Response\n-from scrapy.spiders import Spider\n from scrapy.utils.python import to_bytes\n from scrapy.utils.test import get_crawler, get_from_asyncio_queue\n+from tests.spiders import NoRequestsSpider\n \n \n class ManagerTestCase(TestCase):\n     settings_dict = None\n \n+    @inlineCallbacks\n     def setUp(self):\n-        self.crawler = get_crawler(Spider, self.settings_dict)\n-        self.spider = self.crawler._create_spider(\"foo\")\n+        self.crawler = get_crawler(NoRequestsSpider, self.settings_dict)\n+        yield self.crawler.crawl()\n+        self.spider = self.crawler.spider\n         self.mwman = DownloaderMiddlewareManager.from_crawler(self.crawler)\n-        # some mw depends on stats collector\n-        self.crawler.stats.open_spider(self.spider)\n-        return self.mwman.open_spider(self.spider)\n+        yield self.mwman.open_spider(self.spider)\n \n     def tearDown(self):\n-        self.crawler.stats.close_spider(self.spider, \"\")\n         return self.mwman.close_spider(self.spider)",
      "comment": "This sounds fine. \r\nShould it be called something like _apply_settings though? ",
      "comment_id": 1321670041,
      "user": "kmike",
      "created_at": "2023-09-11T14:47:12Z",
      "url": "https://github.com/scrapy/scrapy/pull/6038#discussion_r1321670041"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 6038,
      "file_path": "tests/test_downloadermiddleware.py",
      "line": 30,
      "side": "RIGHT",
      "diff_hunk": "@@ -3,33 +3,33 @@\n \n from pytest import mark\n from twisted.internet import defer\n-from twisted.internet.defer import Deferred\n+from twisted.internet.defer import Deferred, inlineCallbacks\n from twisted.python.failure import Failure\n from twisted.trial.unittest import TestCase\n \n from scrapy.core.downloader.middleware import DownloaderMiddlewareManager\n from scrapy.exceptions import _InvalidOutput\n from scrapy.http import Request, Response\n-from scrapy.spiders import Spider\n from scrapy.utils.python import to_bytes\n from scrapy.utils.test import get_crawler, get_from_asyncio_queue\n+from tests.spiders import NoRequestsSpider\n \n \n class ManagerTestCase(TestCase):\n     settings_dict = None\n \n+    @inlineCallbacks\n     def setUp(self):\n-        self.crawler = get_crawler(Spider, self.settings_dict)\n-        self.spider = self.crawler._create_spider(\"foo\")\n+        self.crawler = get_crawler(NoRequestsSpider, self.settings_dict)\n+        yield self.crawler.crawl()\n+        self.spider = self.crawler.spider\n         self.mwman = DownloaderMiddlewareManager.from_crawler(self.crawler)\n-        # some mw depends on stats collector\n-        self.crawler.stats.open_spider(self.spider)\n-        return self.mwman.open_spider(self.spider)\n+        yield self.mwman.open_spider(self.spider)\n \n     def tearDown(self):\n-        self.crawler.stats.close_spider(self.spider, \"\")\n         return self.mwman.close_spider(self.spider)",
      "comment": "No opinion on the name (I proposed load, but apply sounds good too).",
      "comment_id": 1321672972,
      "user": "Gallaecio",
      "created_at": "2023-09-11T14:49:21Z",
      "url": "https://github.com/scrapy/scrapy/pull/6038#discussion_r1321672972"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 6038,
      "file_path": "tests/test_downloadermiddleware.py",
      "line": 30,
      "side": "RIGHT",
      "diff_hunk": "@@ -3,33 +3,33 @@\n \n from pytest import mark\n from twisted.internet import defer\n-from twisted.internet.defer import Deferred\n+from twisted.internet.defer import Deferred, inlineCallbacks\n from twisted.python.failure import Failure\n from twisted.trial.unittest import TestCase\n \n from scrapy.core.downloader.middleware import DownloaderMiddlewareManager\n from scrapy.exceptions import _InvalidOutput\n from scrapy.http import Request, Response\n-from scrapy.spiders import Spider\n from scrapy.utils.python import to_bytes\n from scrapy.utils.test import get_crawler, get_from_asyncio_queue\n+from tests.spiders import NoRequestsSpider\n \n \n class ManagerTestCase(TestCase):\n     settings_dict = None\n \n+    @inlineCallbacks\n     def setUp(self):\n-        self.crawler = get_crawler(Spider, self.settings_dict)\n-        self.spider = self.crawler._create_spider(\"foo\")\n+        self.crawler = get_crawler(NoRequestsSpider, self.settings_dict)\n+        yield self.crawler.crawl()\n+        self.spider = self.crawler.spider\n         self.mwman = DownloaderMiddlewareManager.from_crawler(self.crawler)\n-        # some mw depends on stats collector\n-        self.crawler.stats.open_spider(self.spider)\n-        return self.mwman.open_spider(self.spider)\n+        yield self.mwman.open_spider(self.spider)\n \n     def tearDown(self):\n-        self.crawler.stats.close_spider(self.spider, \"\")\n         return self.mwman.close_spider(self.spider)",
      "comment": "@kmike do you think it should create the spider and the engine instances?",
      "comment_id": 1321679347,
      "user": "wRAR",
      "created_at": "2023-09-11T14:53:58Z",
      "url": "https://github.com/scrapy/scrapy/pull/6038#discussion_r1321679347"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 6038,
      "file_path": "tests/test_downloadermiddleware.py",
      "line": 30,
      "side": "RIGHT",
      "diff_hunk": "@@ -3,33 +3,33 @@\n \n from pytest import mark\n from twisted.internet import defer\n-from twisted.internet.defer import Deferred\n+from twisted.internet.defer import Deferred, inlineCallbacks\n from twisted.python.failure import Failure\n from twisted.trial.unittest import TestCase\n \n from scrapy.core.downloader.middleware import DownloaderMiddlewareManager\n from scrapy.exceptions import _InvalidOutput\n from scrapy.http import Request, Response\n-from scrapy.spiders import Spider\n from scrapy.utils.python import to_bytes\n from scrapy.utils.test import get_crawler, get_from_asyncio_queue\n+from tests.spiders import NoRequestsSpider\n \n \n class ManagerTestCase(TestCase):\n     settings_dict = None\n \n+    @inlineCallbacks\n     def setUp(self):\n-        self.crawler = get_crawler(Spider, self.settings_dict)\n-        self.spider = self.crawler._create_spider(\"foo\")\n+        self.crawler = get_crawler(NoRequestsSpider, self.settings_dict)\n+        yield self.crawler.crawl()\n+        self.spider = self.crawler.spider\n         self.mwman = DownloaderMiddlewareManager.from_crawler(self.crawler)\n-        # some mw depends on stats collector\n-        self.crawler.stats.open_spider(self.spider)\n-        return self.mwman.open_spider(self.spider)\n+        yield self.mwman.open_spider(self.spider)\n \n     def tearDown(self):\n-        self.crawler.stats.close_spider(self.spider, \"\")\n         return self.mwman.close_spider(self.spider)",
      "comment": "@wRAR no strong opinion on that; please follow the approach you prefer. I haven't checked all code which is relevant (e.g. scrapy shell), while you have checked it :)",
      "comment_id": 1321688968,
      "user": "kmike",
      "created_at": "2023-09-11T15:00:49Z",
      "url": "https://github.com/scrapy/scrapy/pull/6038#discussion_r1321688968"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 6038,
      "file_path": "scrapy/crawler.py",
      "line": 97,
      "side": "RIGHT",
      "diff_hunk": "@@ -72,42 +72,55 @@ def __init__(\n         self.spidercls: Type[Spider] = spidercls\n         self.settings: Settings = settings.copy()\n         self.spidercls.update_settings(self.settings)\n+        self._update_root_log_handler()\n \n         self.addons: AddonManager = AddonManager(self)\n-        self.addons.load_settings(self.settings)\n-\n         self.signals: SignalManager = SignalManager(self)\n \n-        self.stats: StatsCollector = load_object(self.settings[\"STATS_CLASS\"])(self)\n-\n-        handler = LogCounterHandler(self, level=self.settings.get(\"LOG_LEVEL\"))\n-        logging.root.addHandler(handler)\n+        self._init_reactor: bool = init_reactor\n+        self.crawling: bool = False\n+        self._settings_loaded: bool = False\n+        self._started: bool = False\n \n-        d = dict(overridden_settings(self.settings))\n-        logger.info(\n-            \"Overridden settings:\\n%(settings)s\", {\"settings\": pprint.pformat(d)}\n-        )\n+        self.extensions: Optional[ExtensionManager] = None\n+        self.stats: Optional[StatsCollector] = None\n+        self.logformatter: Optional[LogFormatter] = None\n+        self.request_fingerprinter: Optional[RequestFingerprinter] = None\n+        self.spider: Optional[Spider] = None\n+        self.engine: Optional[ExecutionEngine] = None\n \n+    def _update_root_log_handler(self) -> None:\n         if get_scrapy_root_handler() is not None:\n             # scrapy root handler already installed: update it with new settings\n             install_scrapy_root_handler(self.settings)\n+\n+    def _load_settings(self) -> None:",
      "comment": "a nitpick, about the method name :) _load_settings suggests that this method loads the settings (from somewhere?). It seems what this method does is to load/create the components based on the settings, not loading the settings themselves.\r\n\r\nThis seems to apply to AddonManager.load_settings name as well, btw. Not sure if it's too late to change this; it seems we could make a change, as we haven't made AddonManager a part of the public API.\r\n\r\nSome name suggestions:\r\n\r\n* _apply_settings\r\n\r\nor, if -apply_settings doesn't sound right, something like \r\n\r\n* _load_components\r\n* _create_components",
      "comment_id": 1324386624,
      "user": "kmike",
      "created_at": "2023-09-13T11:43:06Z",
      "url": "https://github.com/scrapy/scrapy/pull/6038#discussion_r1324386624"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 6038,
      "file_path": "scrapy/addons.py",
      "line": 22,
      "side": "RIGHT",
      "diff_hunk": "@@ -19,8 +19,8 @@ def __init__(self, crawler: \"Crawler\") -> None:\n         self.crawler: \"Crawler\" = crawler\n         self.addons: List[Any] = []\n \n-    def load_settings(self, settings: Settings) -> None:\n-        \"\"\"Load add-ons and configurations from a settings object.\n+    def apply_settings(self, settings: Settings) -> None:",
      "comment": "heh, should we name this method update_settings, based on what it actually does?",
      "comment_id": 1324393162,
      "user": "kmike",
      "created_at": "2023-09-13T11:49:34Z",
      "url": "https://github.com/scrapy/scrapy/pull/6038#discussion_r1324393162"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 6038,
      "file_path": "scrapy/crawler.py",
      "line": 98,
      "side": "RIGHT",
      "diff_hunk": "@@ -72,42 +72,55 @@ def __init__(\n         self.spidercls: Type[Spider] = spidercls\n         self.settings: Settings = settings.copy()\n         self.spidercls.update_settings(self.settings)\n+        self._update_root_log_handler()\n \n         self.addons: AddonManager = AddonManager(self)\n-        self.addons.load_settings(self.settings)\n-\n         self.signals: SignalManager = SignalManager(self)\n \n-        self.stats: StatsCollector = load_object(self.settings[\"STATS_CLASS\"])(self)\n-\n-        handler = LogCounterHandler(self, level=self.settings.get(\"LOG_LEVEL\"))\n-        logging.root.addHandler(handler)\n+        self._init_reactor: bool = init_reactor\n+        self.crawling: bool = False\n+        self._settings_loaded: bool = False\n+        self._started: bool = False\n \n-        d = dict(overridden_settings(self.settings))\n-        logger.info(\n-            \"Overridden settings:\\n%(settings)s\", {\"settings\": pprint.pformat(d)}\n-        )\n+        self.extensions: Optional[ExtensionManager] = None\n+        self.stats: Optional[StatsCollector] = None\n+        self.logformatter: Optional[LogFormatter] = None\n+        self.request_fingerprinter: Optional[RequestFingerprinter] = None\n+        self.spider: Optional[Spider] = None\n+        self.engine: Optional[ExecutionEngine] = None\n \n+    def _update_root_log_handler(self) -> None:\n         if get_scrapy_root_handler() is not None:\n             # scrapy root handler already installed: update it with new settings\n             install_scrapy_root_handler(self.settings)\n+\n+    def _apply_settings(self) -> None:\n+        if self._settings_loaded:",
      "comment": "Can it be simplified/improved to `if self.settings.frozen`?",
      "comment_id": 1324395131,
      "user": "kmike",
      "created_at": "2023-09-13T11:51:32Z",
      "url": "https://github.com/scrapy/scrapy/pull/6038#discussion_r1324395131"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 6038,
      "file_path": "scrapy/crawler.py",
      "line": 98,
      "side": "RIGHT",
      "diff_hunk": "@@ -72,42 +72,55 @@ def __init__(\n         self.spidercls: Type[Spider] = spidercls\n         self.settings: Settings = settings.copy()\n         self.spidercls.update_settings(self.settings)\n+        self._update_root_log_handler()\n \n         self.addons: AddonManager = AddonManager(self)\n-        self.addons.load_settings(self.settings)\n-\n         self.signals: SignalManager = SignalManager(self)\n \n-        self.stats: StatsCollector = load_object(self.settings[\"STATS_CLASS\"])(self)\n-\n-        handler = LogCounterHandler(self, level=self.settings.get(\"LOG_LEVEL\"))\n-        logging.root.addHandler(handler)\n+        self._init_reactor: bool = init_reactor\n+        self.crawling: bool = False\n+        self._settings_loaded: bool = False\n+        self._started: bool = False\n \n-        d = dict(overridden_settings(self.settings))\n-        logger.info(\n-            \"Overridden settings:\\n%(settings)s\", {\"settings\": pprint.pformat(d)}\n-        )\n+        self.extensions: Optional[ExtensionManager] = None\n+        self.stats: Optional[StatsCollector] = None\n+        self.logformatter: Optional[LogFormatter] = None\n+        self.request_fingerprinter: Optional[RequestFingerprinter] = None\n+        self.spider: Optional[Spider] = None\n+        self.engine: Optional[ExecutionEngine] = None\n \n+    def _update_root_log_handler(self) -> None:\n         if get_scrapy_root_handler() is not None:\n             # scrapy root handler already installed: update it with new settings\n             install_scrapy_root_handler(self.settings)\n+\n+    def _apply_settings(self) -> None:\n+        if self._settings_loaded:",
      "comment": "Also, if it's called when the settings are frozen, should it be a warning?",
      "comment_id": 1324395675,
      "user": "kmike",
      "created_at": "2023-09-13T11:52:10Z",
      "url": "https://github.com/scrapy/scrapy/pull/6038#discussion_r1324395675"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 6038,
      "file_path": "scrapy/addons.py",
      "line": 22,
      "side": "RIGHT",
      "diff_hunk": "@@ -19,8 +19,8 @@ def __init__(self, crawler: \"Crawler\") -> None:\n         self.crawler: \"Crawler\" = crawler\n         self.addons: List[Any] = []\n \n-    def load_settings(self, settings: Settings) -> None:\n-        \"\"\"Load add-ons and configurations from a settings object.\n+    def apply_settings(self, settings: Settings) -> None:",
      "comment": "Well, the old and the current name reflect that it reads the `ADDONS` setting, not that it runs add-ons' `update_settings` methods, so I'm not sure.",
      "comment_id": 1324400287,
      "user": "wRAR",
      "created_at": "2023-09-13T11:56:41Z",
      "url": "https://github.com/scrapy/scrapy/pull/6038#discussion_r1324400287"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 6038,
      "file_path": "scrapy/addons.py",
      "line": 22,
      "side": "RIGHT",
      "diff_hunk": "@@ -19,8 +19,8 @@ def __init__(self, crawler: \"Crawler\") -> None:\n         self.crawler: \"Crawler\" = crawler\n         self.addons: List[Any] = []\n \n-    def load_settings(self, settings: Settings) -> None:\n-        \"\"\"Load add-ons and configurations from a settings object.\n+    def apply_settings(self, settings: Settings) -> None:",
      "comment": "Isn't updating the settings the single useful piece of work this method does?",
      "comment_id": 1324403867,
      "user": "kmike",
      "created_at": "2023-09-13T12:00:17Z",
      "url": "https://github.com/scrapy/scrapy/pull/6038#discussion_r1324403867"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 6038,
      "file_path": "scrapy/crawler.py",
      "line": 98,
      "side": "RIGHT",
      "diff_hunk": "@@ -72,42 +72,55 @@ def __init__(\n         self.spidercls: Type[Spider] = spidercls\n         self.settings: Settings = settings.copy()\n         self.spidercls.update_settings(self.settings)\n+        self._update_root_log_handler()\n \n         self.addons: AddonManager = AddonManager(self)\n-        self.addons.load_settings(self.settings)\n-\n         self.signals: SignalManager = SignalManager(self)\n \n-        self.stats: StatsCollector = load_object(self.settings[\"STATS_CLASS\"])(self)\n-\n-        handler = LogCounterHandler(self, level=self.settings.get(\"LOG_LEVEL\"))\n-        logging.root.addHandler(handler)\n+        self._init_reactor: bool = init_reactor\n+        self.crawling: bool = False\n+        self._settings_loaded: bool = False\n+        self._started: bool = False\n \n-        d = dict(overridden_settings(self.settings))\n-        logger.info(\n-            \"Overridden settings:\\n%(settings)s\", {\"settings\": pprint.pformat(d)}\n-        )\n+        self.extensions: Optional[ExtensionManager] = None\n+        self.stats: Optional[StatsCollector] = None\n+        self.logformatter: Optional[LogFormatter] = None\n+        self.request_fingerprinter: Optional[RequestFingerprinter] = None\n+        self.spider: Optional[Spider] = None\n+        self.engine: Optional[ExecutionEngine] = None\n \n+    def _update_root_log_handler(self) -> None:\n         if get_scrapy_root_handler() is not None:\n             # scrapy root handler already installed: update it with new settings\n             install_scrapy_root_handler(self.settings)\n+\n+    def _apply_settings(self) -> None:\n+        if self._settings_loaded:",
      "comment": "Right, and error is even better, if there is no use case for running this method twice",
      "comment_id": 1324405579,
      "user": "kmike",
      "created_at": "2023-09-13T12:01:59Z",
      "url": "https://github.com/scrapy/scrapy/pull/6038#discussion_r1324405579"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 6038,
      "file_path": "scrapy/addons.py",
      "line": 22,
      "side": "RIGHT",
      "diff_hunk": "@@ -19,8 +19,8 @@ def __init__(self, crawler: \"Crawler\") -> None:\n         self.crawler: \"Crawler\" = crawler\n         self.addons: List[Any] = []\n \n-    def load_settings(self, settings: Settings) -> None:\n-        \"\"\"Load add-ons and configurations from a settings object.\n+    def apply_settings(self, settings: Settings) -> None:",
      "comment": "Technically, this has nothing to do with this PR, so if there is no easy agreement (cc @Gallaecio), let's revert the name change and handle it separately :)",
      "comment_id": 1324409459,
      "user": "kmike",
      "created_at": "2023-09-13T12:04:41Z",
      "url": "https://github.com/scrapy/scrapy/pull/6038#discussion_r1324409459"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 6038,
      "file_path": "scrapy/crawler.py",
      "line": 98,
      "side": "RIGHT",
      "diff_hunk": "@@ -72,42 +72,55 @@ def __init__(\n         self.spidercls: Type[Spider] = spidercls\n         self.settings: Settings = settings.copy()\n         self.spidercls.update_settings(self.settings)\n+        self._update_root_log_handler()\n \n         self.addons: AddonManager = AddonManager(self)\n-        self.addons.load_settings(self.settings)\n-\n         self.signals: SignalManager = SignalManager(self)\n \n-        self.stats: StatsCollector = load_object(self.settings[\"STATS_CLASS\"])(self)\n-\n-        handler = LogCounterHandler(self, level=self.settings.get(\"LOG_LEVEL\"))\n-        logging.root.addHandler(handler)\n+        self._init_reactor: bool = init_reactor\n+        self.crawling: bool = False\n+        self._settings_loaded: bool = False\n+        self._started: bool = False\n \n-        d = dict(overridden_settings(self.settings))\n-        logger.info(\n-            \"Overridden settings:\\n%(settings)s\", {\"settings\": pprint.pformat(d)}\n-        )\n+        self.extensions: Optional[ExtensionManager] = None\n+        self.stats: Optional[StatsCollector] = None\n+        self.logformatter: Optional[LogFormatter] = None\n+        self.request_fingerprinter: Optional[RequestFingerprinter] = None\n+        self.spider: Optional[Spider] = None\n+        self.engine: Optional[ExecutionEngine] = None\n \n+    def _update_root_log_handler(self) -> None:\n         if get_scrapy_root_handler() is not None:\n             # scrapy root handler already installed: update it with new settings\n             install_scrapy_root_handler(self.settings)\n+\n+    def _apply_settings(self) -> None:\n+        if self._settings_loaded:",
      "comment": "Though when designing it I thought that we need a check so that we can safely run it twice, e.g. directly and then via crawl(). This only matters in tests as users shouldn't run _apply_settings() directly, and either a warning or an error will affect them, as we indeed have tests that call `get_crawler()` (which calls _apply_settings() so that you can get an initialized crawler) and then call `crawl()`.",
      "comment_id": 1324410208,
      "user": "wRAR",
      "created_at": "2023-09-13T12:05:24Z",
      "url": "https://github.com/scrapy/scrapy/pull/6038#discussion_r1324410208"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 6038,
      "file_path": "tests/CrawlerProcess/asyncio_enabled_reactor_different_loop.py",
      "line": 28,
      "side": "RIGHT",
      "diff_hunk": "@@ -24,5 +24,6 @@ def start_requests(self):\n         \"ASYNCIO_EVENT_LOOP\": \"uvloop.Loop\",\n     }\n )\n-process.crawl(NoRequestsSpider)\n+d = process.crawl(NoRequestsSpider)\n+d.addErrback(lambda failure: failure.printTraceback())",
      "comment": "I wonder if we should do it by default for CrawlerRunner, maybe with `CrawlerRunner.__init__` flag to disable printing.",
      "comment_id": 1324525971,
      "user": "kmike",
      "created_at": "2023-09-13T13:34:50Z",
      "url": "https://github.com/scrapy/scrapy/pull/6038#discussion_r1324525971"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 6038,
      "file_path": "tests/CrawlerProcess/asyncio_enabled_reactor_different_loop.py",
      "line": 28,
      "side": "RIGHT",
      "diff_hunk": "@@ -24,5 +24,6 @@ def start_requests(self):\n         \"ASYNCIO_EVENT_LOOP\": \"uvloop.Loop\",\n     }\n )\n-process.crawl(NoRequestsSpider)\n+d = process.crawl(NoRequestsSpider)\n+d.addErrback(lambda failure: failure.printTraceback())",
      "comment": "The issue here is that we're not following https://docs.scrapy.org/en/latest/topics/practices.html#run-scrapy-from-a-script in the tests because it's problematic. So, it may be problematic for our users as well.",
      "comment_id": 1324530155,
      "user": "kmike",
      "created_at": "2023-09-13T13:37:57Z",
      "url": "https://github.com/scrapy/scrapy/pull/6038#discussion_r1324530155"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 6038,
      "file_path": "scrapy/addons.py",
      "line": 22,
      "side": "RIGHT",
      "diff_hunk": "@@ -19,8 +19,8 @@ def __init__(self, crawler: \"Crawler\") -> None:\n         self.crawler: \"Crawler\" = crawler\n         self.addons: List[Any] = []\n \n-    def load_settings(self, settings: Settings) -> None:\n-        \"\"\"Load add-ons and configurations from a settings object.\n+    def apply_settings(self, settings: Settings) -> None:",
      "comment": "I don\u2019t care, to me this method could be private and then the name does not matter that much :)",
      "comment_id": 1324578032,
      "user": "Gallaecio",
      "created_at": "2023-09-13T14:10:11Z",
      "url": "https://github.com/scrapy/scrapy/pull/6038#discussion_r1324578032"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 6040,
      "file_path": "scrapy/crawler.py",
      "line": 139,
      "side": "RIGHT",
      "diff_hunk": "@@ -124,14 +124,21 @@ def __init__(\n \n         self.settings.freeze()\n         self.crawling: bool = False\n+        self._started: bool = False\n         self.spider: Optional[Spider] = None\n         self.engine: Optional[ExecutionEngine] = None\n \n     @inlineCallbacks\n     def crawl(self, *args: Any, **kwargs: Any) -> Generator[Deferred, Any, None]:\n         if self.crawling:\n             raise RuntimeError(\"Crawling already taking place\")\n-        self.crawling = True\n+        if self._started:\n+            warnings.warn(\n+                \"Running Crawler.crawl() more than once is deprecated.\",\n+                ScrapyDeprecationWarning,\n+                stacklevel=2,",
      "comment": "With 2 it's still not helpful as it points to twisted/internet/defer.py (as inlineCallbacks turns into several frames), but I'm not sure if it's possible to set a correct number here.",
      "comment_id": 1317489302,
      "user": "wRAR",
      "created_at": "2023-09-06T15:41:39Z",
      "url": "https://github.com/scrapy/scrapy/pull/6040#discussion_r1317489302"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 6016,
      "file_path": "tests/test_http_response.py",
      "line": 847,
      "side": "LEFT",
      "diff_hunk": "@@ -844,7 +844,7 @@ def test_cache_json_response(self):\n             with mock.patch(\"json.loads\") as mock_json:\n                 for _ in range(2):\n                     json_response.json()\n-                mock_json.assert_called_once_with(json_body.decode())",
      "comment": "Now,` json.loads()` receives bytes, so there's no need to use `decode()`",
      "comment_id": 1297487177,
      "user": "jxlil",
      "created_at": "2023-08-17T16:49:07Z",
      "url": "https://github.com/scrapy/scrapy/pull/6016#discussion_r1297487177"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 6016,
      "file_path": "scrapy/http/response/text.py",
      "line": 85,
      "side": "RIGHT",
      "diff_hunk": "@@ -82,7 +82,7 @@ def json(self):\n         Deserialize a JSON document to a Python object.\n         \"\"\"\n         if self._cached_decoded_json is _NONE:\n-            self._cached_decoded_json = json.loads(self.text)\n+            self._cached_decoded_json = json.loads(self.body)",
      "comment": "The behavior is not exactly the same, if the response is not UTF-8, and properly indicates it.\r\n\r\nFrom https://datatracker.ietf.org/doc/html/rfc7159#section-8.1:\r\n\r\n> JSON text SHALL be encoded in UTF-8, UTF-16, or UTF-32. \r\n\r\nFrom https://docs.python.org/3/library/json.html#json.loads:\r\n\r\n> s can now be of type [bytes](https://docs.python.org/3/library/stdtypes.html#bytes) or [bytearray](https://docs.python.org/3/library/stdtypes.html#bytearray). The input encoding should be UTF-8, UTF-16 or UTF-32.\r\n\r\nSo we should be fine in most cases after this change. \r\n\r\nAt the same time, SHALL in the RFC is not MUST (see https://datatracker.ietf.org/doc/html/rfc2119#section-3):\r\n\r\n> SHOULD   This word, or the adjective \"RECOMMENDED\", mean that there\r\n   may exist valid reasons in particular circumstances to ignore a\r\n   particular item, but the full implications must be understood and\r\n   carefully weighed before choosing a different course.\r\n\r\nI'm fine with making the change, but we should add an entry to the changelog, which explains that the change is backwards incompatible, and that Scrapy stops support some of these weird cases to improve the efficiency for the vast majority of cases. Users can always use `json.loads(response.text)` in their code, instead of the `response.json()` shortcut.",
      "comment_id": 1298169287,
      "user": "kmike",
      "created_at": "2023-08-18T08:29:15Z",
      "url": "https://github.com/scrapy/scrapy/pull/6016#discussion_r1298169287"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 6016,
      "file_path": "scrapy/http/response/text.py",
      "line": 85,
      "side": "RIGHT",
      "diff_hunk": "@@ -82,7 +82,7 @@ def json(self):\n         Deserialize a JSON document to a Python object.\n         \"\"\"\n         if self._cached_decoded_json is _NONE:\n-            self._cached_decoded_json = json.loads(self.text)\n+            self._cached_decoded_json = json.loads(self.body)",
      "comment": "Done! I've just added an entry to the **Backward-incompatible changes** section in the changelog. Please let me know if I need to correct something.",
      "comment_id": 1298874729,
      "user": "jxlil",
      "created_at": "2023-08-18T21:23:02Z",
      "url": "https://github.com/scrapy/scrapy/pull/6016#discussion_r1298874729"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 6016,
      "file_path": "scrapy/http/response/text.py",
      "line": 85,
      "side": "RIGHT",
      "diff_hunk": "@@ -82,7 +82,7 @@ def json(self):\n         Deserialize a JSON document to a Python object.\n         \"\"\"\n         if self._cached_decoded_json is _NONE:\n-            self._cached_decoded_json = json.loads(self.text)\n+            self._cached_decoded_json = json.loads(self.body)",
      "comment": "SHALL != SHOULD.\r\n\r\n> MUST   This word, or the terms \"REQUIRED\" or \"SHALL\", mean that the\r\n   definition is an absolute requirement of the specification.",
      "comment_id": 1300173194,
      "user": "Gallaecio",
      "created_at": "2023-08-21T14:14:05Z",
      "url": "https://github.com/scrapy/scrapy/pull/6016#discussion_r1300173194"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 5926,
      "file_path": "scrapy/extensions/logstats_extended.py",
      "line": 42,
      "side": "RIGHT",
      "diff_hunk": "@@ -0,0 +1,112 @@\n+import logging\n+from datetime import datetime\n+\n+from twisted.internet import task\n+\n+from scrapy import signals\n+from scrapy.exceptions import NotConfigured\n+from scrapy.utils.serialize import ScrapyJSONEncoder\n+\n+logger = logging.getLogger(__name__)\n+\n+\n+class LogStatsExtended:\n+    \"\"\"Log basic scraping stats periodically\"\"\"\n+\n+    def __init__(\n+            self, stats, interval=60.0, extended=False, ext_include=None, ext_exclude=None\n+    ):\n+        self.stats = stats\n+        self.interval = interval\n+        self.multiplier = 60.0 / self.interval\n+        self.task = None\n+        self.extended = extended\n+        self.encoder = ScrapyJSONEncoder(sort_keys=True, indent=4)\n+        self.ext_include = ext_include\n+        self.ext_exclude = ext_exclude\n+\n+    @classmethod\n+    def from_crawler(cls, crawler):\n+        interval = crawler.settings.getfloat(\"LOGSTATS_INTERVAL\")\n+        extended = crawler.settings.getbool(\"LOGSTATS_EXTENDED_ENABLED\")\n+        ext_include = crawler.settings.getlist(\"LOGSTATS_EXTENDED_INCLUDE\", [])\n+        ext_exclude = crawler.settings.getlist(\"LOGSTATS_EXTENDED_EXCLUDE\", [])\n+        if not interval:\n+            raise NotConfigured\n+        o = cls(crawler.stats, interval, extended, ext_include, ext_exclude)\n+        crawler.signals.connect(o.spider_opened, signal=signals.spider_opened)\n+        crawler.signals.connect(o.spider_closed, signal=signals.spider_closed)\n+        return o\n+\n+    def spider_opened(self, spider):\n+        self.time_prev = datetime.utcnow()",
      "comment": "Maybe use `.now()` and pass the timezone? [Reason](https://blog.ganssle.io/articles/2019/11/utcnow.html)",
      "comment_id": 1186916810,
      "user": "Laerte",
      "created_at": "2023-05-07T21:30:29Z",
      "url": "https://github.com/scrapy/scrapy/pull/5926#discussion_r1186916810"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 5926,
      "file_path": "scrapy/extensions/logstats_extended.py",
      "line": 42,
      "side": "RIGHT",
      "diff_hunk": "@@ -0,0 +1,112 @@\n+import logging\n+from datetime import datetime\n+\n+from twisted.internet import task\n+\n+from scrapy import signals\n+from scrapy.exceptions import NotConfigured\n+from scrapy.utils.serialize import ScrapyJSONEncoder\n+\n+logger = logging.getLogger(__name__)\n+\n+\n+class LogStatsExtended:\n+    \"\"\"Log basic scraping stats periodically\"\"\"\n+\n+    def __init__(\n+            self, stats, interval=60.0, extended=False, ext_include=None, ext_exclude=None\n+    ):\n+        self.stats = stats\n+        self.interval = interval\n+        self.multiplier = 60.0 / self.interval\n+        self.task = None\n+        self.extended = extended\n+        self.encoder = ScrapyJSONEncoder(sort_keys=True, indent=4)\n+        self.ext_include = ext_include\n+        self.ext_exclude = ext_exclude\n+\n+    @classmethod\n+    def from_crawler(cls, crawler):\n+        interval = crawler.settings.getfloat(\"LOGSTATS_INTERVAL\")\n+        extended = crawler.settings.getbool(\"LOGSTATS_EXTENDED_ENABLED\")\n+        ext_include = crawler.settings.getlist(\"LOGSTATS_EXTENDED_INCLUDE\", [])\n+        ext_exclude = crawler.settings.getlist(\"LOGSTATS_EXTENDED_EXCLUDE\", [])\n+        if not interval:\n+            raise NotConfigured\n+        o = cls(crawler.stats, interval, extended, ext_include, ext_exclude)\n+        crawler.signals.connect(o.spider_opened, signal=signals.spider_opened)\n+        crawler.signals.connect(o.spider_closed, signal=signals.spider_closed)\n+        return o\n+\n+    def spider_opened(self, spider):\n+        self.time_prev = datetime.utcnow()",
      "comment": "Implemented here as `datetime.utcnow()` to correspond with  `finish_time` and `start_time` stats values which is also populated by `datetime.utcnow()` in `..extensions.corestats`\r\nhttps://github.com/scrapy/scrapy/blob/92f86fab062d179fd68590f1be6a24ca13ec33b6/scrapy/extensions/corestats.py#L24C3-L29\r\n\r\nThis change making sense to apply only if we remove (replace) all other usages of `datetime.utcnow()` in this repo, which may require separate issue/discuss/approval and it is definitely not planned as part if this pull request.",
      "comment_id": 1187071432,
      "user": "GeorgeA92",
      "created_at": "2023-05-08T06:30:20Z",
      "url": "https://github.com/scrapy/scrapy/pull/5926#discussion_r1187071432"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 5926,
      "file_path": "scrapy/extensions/logstats_extended.py",
      "line": 13,
      "side": "RIGHT",
      "diff_hunk": "@@ -0,0 +1,132 @@\n+import logging\n+from datetime import datetime\n+\n+from twisted.internet import task\n+\n+from scrapy import signals\n+from scrapy.exceptions import NotConfigured\n+from scrapy.utils.serialize import ScrapyJSONEncoder\n+\n+logger = logging.getLogger(__name__)\n+\n+\n+class LogStatsExtended:",
      "comment": "I think it may make sense to keep this new class in `log_stats.py`, rather than having a separate file for it.\r\n\r\nI also think we may want to reconsider the class name. I would suggest making `Extended` a prefix instead (`ExtendedLogStats`), and consider an alternative word instead (e.g. `Verbose`, `Detailed`, `Flexible`, `Configurable`).",
      "comment_id": 1200140833,
      "user": "Gallaecio",
      "created_at": "2023-05-22T08:23:53Z",
      "url": "https://github.com/scrapy/scrapy/pull/5926#discussion_r1200140833"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 5926,
      "file_path": "scrapy/extensions/logstats_extended.py",
      "line": 46,
      "side": "RIGHT",
      "diff_hunk": "@@ -0,0 +1,132 @@\n+import logging\n+from datetime import datetime\n+\n+from twisted.internet import task\n+\n+from scrapy import signals\n+from scrapy.exceptions import NotConfigured\n+from scrapy.utils.serialize import ScrapyJSONEncoder\n+\n+logger = logging.getLogger(__name__)\n+\n+\n+class LogStatsExtended:\n+    \"\"\"Log basic scraping stats periodically\"\"\"\n+\n+    def __init__(\n+            self, stats, interval=60.0,\n+            ext_stats_enabled=False,\n+            ext_stats_include=None,\n+            ext_stats_exclude=None,\n+            ext_delta_enabled=False,\n+            ext_delta_include=None,\n+            ext_delta_exclude=None,\n+            ext_timing_enabled=False,\n+            ext_timing_include=None,\n+            ext_timing_exclude=None,\n+    ):\n+        self.stats = stats\n+        self.interval = interval\n+        self.multiplier = 60.0 / self.interval\n+        self.task = None\n+        self.encoder = ScrapyJSONEncoder(sort_keys=True, indent=4)\n+        self.ext_stats_enabled = ext_stats_enabled\n+        self.ext_stats_include = ext_stats_include\n+        self.ext_stats_exclude = ext_stats_exclude\n+        self.ext_delta_enabled = ext_delta_enabled\n+        self.ext_delta_include = ext_delta_include\n+        self.ext_delta_exclude = ext_delta_exclude\n+        self.ext_timing_enabled = ext_timing_enabled\n+        self.ext_timing_include = ext_timing_include\n+        self.ext_timing_exclude = ext_timing_exclude\n+\n+\n+    @classmethod\n+    def from_crawler(cls, crawler):\n+        interval = crawler.settings.getfloat(\"LOGSTATS_INTERVAL\")",
      "comment": "Instead of having 3 new `_ENABLED` settings, we could have a single one called `LOGSTATS_FOO`, where `FOO` would be whatever the prefix/suffix of the new class is, e.g. `LOGSTATS_EXTENDED` if we keep the current name.\r\n\r\n```suggestion\r\n        settings = crawler.settings\r\n        interval = settings.getfloat(\"LOGSTATS_INTERVAL\")\r\n        if not interval or not settings.getfloat(\"LOGSTATS_EXTENDED\"):\r\n            raise NotConfigured\r\n```\r\n\r\nThen, to get those `_enabled` booleans, you could do:\r\n\r\n```suggestion\r\n        ext_stats_include = crawler.settings.getlist(\"LOGSTATS_STATS_INCLUDE\", [])\r\n        ext_stats_exclude = crawler.settings.getlist(\"LOGSTATS_STATS_EXCLUDE\", [])\r\n        ext_stats_enabled = bool(ext_stats_include) or bool(ext_stats_exclude)\r\n```\r\n\r\nIt probably makes sense to move the `_enabled` definition later on, to `__init__`, when following this approach.",
      "comment_id": 1200160763,
      "user": "Gallaecio",
      "created_at": "2023-05-22T08:37:39Z",
      "url": "https://github.com/scrapy/scrapy/pull/5926#discussion_r1200160763"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 5926,
      "file_path": "scrapy/extensions/logstats_extended.py",
      "line": 53,
      "side": "RIGHT",
      "diff_hunk": "@@ -0,0 +1,132 @@\n+import logging\n+from datetime import datetime\n+\n+from twisted.internet import task\n+\n+from scrapy import signals\n+from scrapy.exceptions import NotConfigured\n+from scrapy.utils.serialize import ScrapyJSONEncoder\n+\n+logger = logging.getLogger(__name__)\n+\n+\n+class LogStatsExtended:\n+    \"\"\"Log basic scraping stats periodically\"\"\"\n+\n+    def __init__(\n+            self, stats, interval=60.0,\n+            ext_stats_enabled=False,\n+            ext_stats_include=None,\n+            ext_stats_exclude=None,\n+            ext_delta_enabled=False,\n+            ext_delta_include=None,\n+            ext_delta_exclude=None,\n+            ext_timing_enabled=False,\n+            ext_timing_include=None,\n+            ext_timing_exclude=None,\n+    ):\n+        self.stats = stats\n+        self.interval = interval\n+        self.multiplier = 60.0 / self.interval\n+        self.task = None\n+        self.encoder = ScrapyJSONEncoder(sort_keys=True, indent=4)\n+        self.ext_stats_enabled = ext_stats_enabled\n+        self.ext_stats_include = ext_stats_include\n+        self.ext_stats_exclude = ext_stats_exclude\n+        self.ext_delta_enabled = ext_delta_enabled\n+        self.ext_delta_include = ext_delta_include\n+        self.ext_delta_exclude = ext_delta_exclude\n+        self.ext_timing_enabled = ext_timing_enabled\n+        self.ext_timing_include = ext_timing_include\n+        self.ext_timing_exclude = ext_timing_exclude\n+\n+\n+    @classmethod\n+    def from_crawler(cls, crawler):\n+        interval = crawler.settings.getfloat(\"LOGSTATS_INTERVAL\")\n+        ext_stats_enabled = crawler.settings.getbool(\"LOGSTATS_EXT_STATS_ENABLED\")\n+        ext_stats_include = crawler.settings.getlist(\"LOGSTATS_EXT_STATS_INCLUDE\", [])\n+        ext_stats_exclude = crawler.settings.getlist(\"LOGSTATS_EXT_STATS_EXCLUDE\", [])\n+        ext_delta_enabled = crawler.settings.getbool(\"LOGSTATS_EXT_DELTA_ENABLED\")\n+        ext_delta_include = crawler.settings.getlist(\"LOGSTATS_EXT_DELTA_INCLUDE\", [])\n+        ext_delta_exclude = crawler.settings.getlist(\"LOGSTATS_EXT_DELTA_EXCLUDE\", [])\n+        ext_timing_enabled = crawler.settings.getbool(\"LOGSTATS_EXT_TIMING_ENABLED\")",
      "comment": "I think we can keep `LOGSTATS_` as the prefix as long as we make sure there are no conflicts with existing settings:\r\n\r\n```suggestion\r\n        ext_stats_include = crawler.settings.getlist(\"LOGSTATS_INCLUDE\", [])\r\n        ext_stats_exclude = crawler.settings.getlist(\"LOGSTATS_EXCLUDE\", [])\r\n        ext_delta_include = crawler.settings.getlist(\"LOGSTATS_DELTA_INCLUDE\", [])\r\n        ext_delta_exclude = crawler.settings.getlist(\"LOGSTATS_DELTA_EXCLUDE\", [])\r\n        ext_timing_enabled = crawler.settings.getbool(\"LOGSTATS_EXTENDED_TIME\")\r\n```\r\n\r\nWe could also modify the existing extension to be smart about settings specific to this new extension, e.g.\r\n- Raise `NotConfigured` if `LOGSTATS_EXTENDED` is `True`.\r\n- Log a warning if one of these 5 settings are defined with a non-default value, indicating that they only have effect if `LOGSTATS_EXTENDED` is set to `True`.",
      "comment_id": 1200171233,
      "user": "Gallaecio",
      "created_at": "2023-05-22T08:42:41Z",
      "url": "https://github.com/scrapy/scrapy/pull/5926#discussion_r1200171233"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 5926,
      "file_path": "scrapy/extensions/logstats_extended.py",
      "line": 13,
      "side": "RIGHT",
      "diff_hunk": "@@ -0,0 +1,132 @@\n+import logging\n+from datetime import datetime\n+\n+from twisted.internet import task\n+\n+from scrapy import signals\n+from scrapy.exceptions import NotConfigured\n+from scrapy.utils.serialize import ScrapyJSONEncoder\n+\n+logger = logging.getLogger(__name__)\n+\n+\n+class LogStatsExtended:",
      "comment": "I don't have strong opinion about naming anything here.\r\n\r\nExcept(maybe) to make name.. to avoid disambiguation between this one and default `logstats` extension (assuming that we keep this as separate extension).\r\n\r\nIn next iteration I will try to use `PERIODIC_LOG_` prefix like`PERIODIC_LOG_STATS` , `PERIODIC_LOG_DELTA` etc.",
      "comment_id": 1200925850,
      "user": "GeorgeA92",
      "created_at": "2023-05-22T19:07:21Z",
      "url": "https://github.com/scrapy/scrapy/pull/5926#discussion_r1200925850"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 5926,
      "file_path": "scrapy/extensions/logstats_extended.py",
      "line": 46,
      "side": "RIGHT",
      "diff_hunk": "@@ -0,0 +1,132 @@\n+import logging\n+from datetime import datetime\n+\n+from twisted.internet import task\n+\n+from scrapy import signals\n+from scrapy.exceptions import NotConfigured\n+from scrapy.utils.serialize import ScrapyJSONEncoder\n+\n+logger = logging.getLogger(__name__)\n+\n+\n+class LogStatsExtended:\n+    \"\"\"Log basic scraping stats periodically\"\"\"\n+\n+    def __init__(\n+            self, stats, interval=60.0,\n+            ext_stats_enabled=False,\n+            ext_stats_include=None,\n+            ext_stats_exclude=None,\n+            ext_delta_enabled=False,\n+            ext_delta_include=None,\n+            ext_delta_exclude=None,\n+            ext_timing_enabled=False,\n+            ext_timing_include=None,\n+            ext_timing_exclude=None,\n+    ):\n+        self.stats = stats\n+        self.interval = interval\n+        self.multiplier = 60.0 / self.interval\n+        self.task = None\n+        self.encoder = ScrapyJSONEncoder(sort_keys=True, indent=4)\n+        self.ext_stats_enabled = ext_stats_enabled\n+        self.ext_stats_include = ext_stats_include\n+        self.ext_stats_exclude = ext_stats_exclude\n+        self.ext_delta_enabled = ext_delta_enabled\n+        self.ext_delta_include = ext_delta_include\n+        self.ext_delta_exclude = ext_delta_exclude\n+        self.ext_timing_enabled = ext_timing_enabled\n+        self.ext_timing_include = ext_timing_include\n+        self.ext_timing_exclude = ext_timing_exclude\n+\n+\n+    @classmethod\n+    def from_crawler(cls, crawler):\n+        interval = crawler.settings.getfloat(\"LOGSTATS_INTERVAL\")",
      "comment": "> Instead of having 3 new _ENABLED settings, we could have a single one called LOGSTATS_FOO, where FOO would be whatever the prefix/suffix of the new class is, e.g. LOGSTATS_EXTENDED if we keep the current name.\r\n\r\nI also have thoughts in this direction to make it work with.. 3 settings only, like this:\r\n```\r\n        \"PERIODIC_LOG_STATS\" : {\r\n            \"include\": [\"downloader/\", \"scheduler/\", \"log_count/\", \"item_scraped_count\"],\r\n            \"exclude\": [\"scheduler/\"]\r\n        },\r\n\r\n        \"PERIODIC_LOG_DELTA\": {\r\n            \"include\": [\"downloader/\"]\r\n        },\r\n        \"PERIODIC_LOG_TIMING_ENABLED\" : True,\r\n```\r\nWhere expected to interpret delta/stats as enabled on any non `None` setting value\r\nIt will look (conceptually) closer to conf of `FEEDS` setting",
      "comment_id": 1200929174,
      "user": "GeorgeA92",
      "created_at": "2023-05-22T19:10:36Z",
      "url": "https://github.com/scrapy/scrapy/pull/5926#discussion_r1200929174"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 5926,
      "file_path": "scrapy/extensions/logstats_extended.py",
      "line": 53,
      "side": "RIGHT",
      "diff_hunk": "@@ -0,0 +1,132 @@\n+import logging\n+from datetime import datetime\n+\n+from twisted.internet import task\n+\n+from scrapy import signals\n+from scrapy.exceptions import NotConfigured\n+from scrapy.utils.serialize import ScrapyJSONEncoder\n+\n+logger = logging.getLogger(__name__)\n+\n+\n+class LogStatsExtended:\n+    \"\"\"Log basic scraping stats periodically\"\"\"\n+\n+    def __init__(\n+            self, stats, interval=60.0,\n+            ext_stats_enabled=False,\n+            ext_stats_include=None,\n+            ext_stats_exclude=None,\n+            ext_delta_enabled=False,\n+            ext_delta_include=None,\n+            ext_delta_exclude=None,\n+            ext_timing_enabled=False,\n+            ext_timing_include=None,\n+            ext_timing_exclude=None,\n+    ):\n+        self.stats = stats\n+        self.interval = interval\n+        self.multiplier = 60.0 / self.interval\n+        self.task = None\n+        self.encoder = ScrapyJSONEncoder(sort_keys=True, indent=4)\n+        self.ext_stats_enabled = ext_stats_enabled\n+        self.ext_stats_include = ext_stats_include\n+        self.ext_stats_exclude = ext_stats_exclude\n+        self.ext_delta_enabled = ext_delta_enabled\n+        self.ext_delta_include = ext_delta_include\n+        self.ext_delta_exclude = ext_delta_exclude\n+        self.ext_timing_enabled = ext_timing_enabled\n+        self.ext_timing_include = ext_timing_include\n+        self.ext_timing_exclude = ext_timing_exclude\n+\n+\n+    @classmethod\n+    def from_crawler(cls, crawler):\n+        interval = crawler.settings.getfloat(\"LOGSTATS_INTERVAL\")\n+        ext_stats_enabled = crawler.settings.getbool(\"LOGSTATS_EXT_STATS_ENABLED\")\n+        ext_stats_include = crawler.settings.getlist(\"LOGSTATS_EXT_STATS_INCLUDE\", [])\n+        ext_stats_exclude = crawler.settings.getlist(\"LOGSTATS_EXT_STATS_EXCLUDE\", [])\n+        ext_delta_enabled = crawler.settings.getbool(\"LOGSTATS_EXT_DELTA_ENABLED\")\n+        ext_delta_include = crawler.settings.getlist(\"LOGSTATS_EXT_DELTA_INCLUDE\", [])\n+        ext_delta_exclude = crawler.settings.getlist(\"LOGSTATS_EXT_DELTA_EXCLUDE\", [])\n+        ext_timing_enabled = crawler.settings.getbool(\"LOGSTATS_EXT_TIMING_ENABLED\")",
      "comment": "> Log a warning if one of these 5 settings are defined with a non-default value, indicating that they only have effect if LOGSTATS_EXTENDED is set to True.\r\n\r\nTo implement this I'd prefer to use existing `overridden settings` feature in scrapy.\r\n\r\nIf we define `PERIODIC_LOG_STATS=None; PERIODIC_LOG_DELTA=None; PERIODIC_LOG_TIMING_ENABLED=None` in scrapy/settings/default_settings.py - on run with.. non default values of this settings - it will be reflected in overridden settings log entry",
      "comment_id": 1200929910,
      "user": "GeorgeA92",
      "created_at": "2023-05-22T19:11:32Z",
      "url": "https://github.com/scrapy/scrapy/pull/5926#discussion_r1200929910"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 5926,
      "file_path": "scrapy/extensions/periodic_log.py",
      "line": 48,
      "side": "RIGHT",
      "diff_hunk": "@@ -0,0 +1,151 @@\n+import logging\n+from datetime import datetime\n+\n+from twisted.internet import task\n+\n+from scrapy import signals\n+from scrapy.exceptions import NotConfigured\n+from scrapy.utils.serialize import ScrapyJSONEncoder\n+\n+logger = logging.getLogger(__name__)\n+\n+\n+class PeriodicLog:\n+    \"\"\"Log basic scraping stats periodically\"\"\"\n+\n+    def __init__(\n+        self,\n+        stats,\n+        interval=60.0,\n+        ext_stats={},\n+        ext_delta={},\n+        ext_timing_enabled=False,\n+    ):\n+        self.stats = stats\n+        self.interval = interval\n+        self.multiplier = 60.0 / self.interval\n+        self.task = None\n+        self.encoder = ScrapyJSONEncoder(sort_keys=True, indent=4)\n+        self.ext_stats_enabled = bool(ext_stats)\n+        self.ext_stats_include = ext_stats.get(\"include\", [])\n+        self.ext_stats_exclude = ext_stats.get(\"exclude\", [])\n+        self.ext_delta_enabled = bool(ext_delta)\n+        self.ext_delta_include = ext_delta.get(\"include\", [])\n+        self.ext_delta_exclude = ext_delta.get(\"exclude\", [])\n+        self.ext_timing_enabled = ext_timing_enabled\n+\n+    @classmethod\n+    def from_crawler(cls, crawler):\n+        interval = crawler.settings.getfloat(\"LOGSTATS_INTERVAL\")\n+        try:\n+            ext_stats = crawler.settings.getdict(\"PERIODIC_LOG_STATS\")\n+        except ValueError:\n+            ext_stats = (\n+                {\"enabled\": True}\n+                if crawler.settings.getbool(\"PERIODIC_LOG_STATS\")\n+                else None\n+            )\n+        except TypeError:",
      "comment": "Shouldn't these two except clauses be combined as their code is the same?",
      "comment_id": 1236755530,
      "user": "wRAR",
      "created_at": "2023-06-21T10:18:21Z",
      "url": "https://github.com/scrapy/scrapy/pull/5926#discussion_r1236755530"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 5926,
      "file_path": "scrapy/extensions/periodic_log.py",
      "line": 61,
      "side": "RIGHT",
      "diff_hunk": "@@ -0,0 +1,140 @@\n+import logging\n+from datetime import datetime\n+\n+from twisted.internet import task\n+\n+from scrapy import signals\n+from scrapy.exceptions import NotConfigured\n+from scrapy.utils.serialize import ScrapyJSONEncoder\n+\n+logger = logging.getLogger(__name__)\n+\n+\n+class PeriodicLog:\n+    \"\"\"Log basic scraping stats periodically\"\"\"\n+\n+    def __init__(\n+        self,\n+        stats,\n+        interval=60.0,\n+        ext_stats={},\n+        ext_delta={},\n+        ext_timing_enabled=False,\n+    ):\n+        self.stats = stats\n+        self.interval = interval\n+        self.multiplier = 60.0 / self.interval\n+        self.task = None\n+        self.encoder = ScrapyJSONEncoder(sort_keys=True, indent=4)\n+        self.ext_stats_enabled = bool(ext_stats)\n+        self.ext_stats_include = ext_stats.get(\"include\", [])\n+        self.ext_stats_exclude = ext_stats.get(\"exclude\", [])\n+        self.ext_delta_enabled = bool(ext_delta)\n+        self.ext_delta_include = ext_delta.get(\"include\", [])\n+        self.ext_delta_exclude = ext_delta.get(\"exclude\", [])\n+        self.ext_timing_enabled = ext_timing_enabled\n+\n+    @classmethod\n+    def from_crawler(cls, crawler):\n+        interval = crawler.settings.getfloat(\"LOGSTATS_INTERVAL\")\n+        try:\n+            ext_stats = crawler.settings.getdict(\"PERIODIC_LOG_STATS\")\n+        except (TypeError, ValueError):\n+            ext_stats = (\n+                {\"enabled\": True}\n+                if crawler.settings.getbool(\"PERIODIC_LOG_STATS\")\n+                else None\n+            )\n+        try:\n+            ext_delta = crawler.settings.getdict(\"PERIODIC_LOG_DELTA\")\n+        except (TypeError, ValueError):\n+            ext_delta = (\n+                {\"enabled\": True}\n+                if crawler.settings.getbool(\"PERIODIC_LOG_DELTA\")\n+                else None\n+            )\n+\n+        ext_timing_enabled = crawler.settings.getbool(\n+            \"PERIODIC_LOG_TIMING_ENABLED\", False\n+        )\n+        if not interval:\n+            raise NotConfigured",
      "comment": ":lipstick: Maybe we could move this earlier, to line 40?",
      "comment_id": 1287513486,
      "user": "Gallaecio",
      "created_at": "2023-08-08T18:38:38Z",
      "url": "https://github.com/scrapy/scrapy/pull/5926#discussion_r1287513486"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 5926,
      "file_path": "scrapy/extensions/periodic_log.py",
      "line": 124,
      "side": "RIGHT",
      "diff_hunk": "@@ -0,0 +1,140 @@\n+import logging\n+from datetime import datetime\n+\n+from twisted.internet import task\n+\n+from scrapy import signals\n+from scrapy.exceptions import NotConfigured\n+from scrapy.utils.serialize import ScrapyJSONEncoder\n+\n+logger = logging.getLogger(__name__)\n+\n+\n+class PeriodicLog:\n+    \"\"\"Log basic scraping stats periodically\"\"\"\n+\n+    def __init__(\n+        self,\n+        stats,\n+        interval=60.0,\n+        ext_stats={},\n+        ext_delta={},\n+        ext_timing_enabled=False,\n+    ):\n+        self.stats = stats\n+        self.interval = interval\n+        self.multiplier = 60.0 / self.interval\n+        self.task = None\n+        self.encoder = ScrapyJSONEncoder(sort_keys=True, indent=4)\n+        self.ext_stats_enabled = bool(ext_stats)\n+        self.ext_stats_include = ext_stats.get(\"include\", [])\n+        self.ext_stats_exclude = ext_stats.get(\"exclude\", [])\n+        self.ext_delta_enabled = bool(ext_delta)\n+        self.ext_delta_include = ext_delta.get(\"include\", [])\n+        self.ext_delta_exclude = ext_delta.get(\"exclude\", [])\n+        self.ext_timing_enabled = ext_timing_enabled\n+\n+    @classmethod\n+    def from_crawler(cls, crawler):\n+        interval = crawler.settings.getfloat(\"LOGSTATS_INTERVAL\")\n+        try:\n+            ext_stats = crawler.settings.getdict(\"PERIODIC_LOG_STATS\")\n+        except (TypeError, ValueError):\n+            ext_stats = (\n+                {\"enabled\": True}\n+                if crawler.settings.getbool(\"PERIODIC_LOG_STATS\")\n+                else None\n+            )\n+        try:\n+            ext_delta = crawler.settings.getdict(\"PERIODIC_LOG_DELTA\")\n+        except (TypeError, ValueError):\n+            ext_delta = (\n+                {\"enabled\": True}\n+                if crawler.settings.getbool(\"PERIODIC_LOG_DELTA\")\n+                else None\n+            )\n+\n+        ext_timing_enabled = crawler.settings.getbool(\n+            \"PERIODIC_LOG_TIMING_ENABLED\", False\n+        )\n+        if not interval:\n+            raise NotConfigured\n+        if not (ext_stats or ext_delta or ext_timing_enabled):\n+            raise NotConfigured\n+        o = cls(\n+            crawler.stats,\n+            interval,\n+            ext_stats,\n+            ext_delta,\n+            ext_timing_enabled,\n+        )\n+        crawler.signals.connect(o.spider_opened, signal=signals.spider_opened)\n+        crawler.signals.connect(o.spider_closed, signal=signals.spider_closed)\n+        return o\n+\n+    def spider_opened(self, spider):\n+        self.time_prev = datetime.utcnow()\n+        self.delta_prev = {}\n+        self.stats_prev = {}\n+\n+        self.task = task.LoopingCall(self.log)\n+        self.task.start(self.interval)\n+\n+    def log(self):\n+        data = {}\n+        if self.ext_timing_enabled:\n+            data.update(self.log_timing())\n+        if self.ext_delta_enabled:\n+            data.update(self.log_delta())\n+        if self.ext_stats_enabled:\n+            data.update(self.log_crawler_stats())\n+        logger.info(self.encoder.encode(data))\n+\n+    def log_delta(self):\n+        num_stats = {\n+            k: v\n+            for k, v in self.stats._stats.items()\n+            if isinstance(v, (int, float))\n+            and self.param_allowed(k, self.ext_delta_include, self.ext_delta_exclude)\n+        }\n+        delta = {k: v - self.delta_prev.get(k, 0) for k, v in num_stats.items()}\n+        self.delta_prev = num_stats\n+        return {\"delta\": delta}\n+\n+    def log_timing(self):\n+        now = datetime.utcnow()\n+        time = {\n+            \"log_interval\": self.interval,\n+            \"start_time\": self.stats._stats[\"start_time\"],\n+            \"utcnow\": now,\n+            \"log_interval_real\": (now - self.time_prev).total_seconds(),\n+            \"elapsed\": (now - self.stats._stats[\"start_time\"]).total_seconds(),\n+        }\n+        self.time_prev = now\n+        return {\"time\": time}\n+\n+    def log_crawler_stats(self):\n+        stats = {\n+            k: v\n+            for k, v in self.stats._stats.items()\n+            if self.param_allowed(k, self.ext_stats_include, self.ext_stats_exclude)\n+        }\n+        return {\"stats\": stats}\n+\n+    def param_allowed(self, stat_name, include, exclude):",
      "comment": "I wonder if it would make sense to cache this method.",
      "comment_id": 1287515331,
      "user": "Gallaecio",
      "created_at": "2023-08-08T18:40:49Z",
      "url": "https://github.com/scrapy/scrapy/pull/5926#discussion_r1287515331"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 5926,
      "file_path": "scrapy/settings/default_settings.py",
      "line": 245,
      "side": "RIGHT",
      "diff_hunk": "@@ -240,6 +240,10 @@\n \n NEWSPIDER_MODULE = \"\"\n \n+PERIODIC_LOG_DELTA = None\n+PERIODIC_LOG_STATS = None\n+PERIODIC_LOG_TIMING_ENABLED = None",
      "comment": "```suggestion\r\nPERIODIC_LOG_TIMING_ENABLED = False\r\n```",
      "comment_id": 1287516057,
      "user": "Gallaecio",
      "created_at": "2023-08-08T18:41:38Z",
      "url": "https://github.com/scrapy/scrapy/pull/5926#discussion_r1287516057"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 5926,
      "file_path": "scrapy/extensions/periodic_log.py",
      "line": 124,
      "side": "RIGHT",
      "diff_hunk": "@@ -0,0 +1,140 @@\n+import logging\n+from datetime import datetime\n+\n+from twisted.internet import task\n+\n+from scrapy import signals\n+from scrapy.exceptions import NotConfigured\n+from scrapy.utils.serialize import ScrapyJSONEncoder\n+\n+logger = logging.getLogger(__name__)\n+\n+\n+class PeriodicLog:\n+    \"\"\"Log basic scraping stats periodically\"\"\"\n+\n+    def __init__(\n+        self,\n+        stats,\n+        interval=60.0,\n+        ext_stats={},\n+        ext_delta={},\n+        ext_timing_enabled=False,\n+    ):\n+        self.stats = stats\n+        self.interval = interval\n+        self.multiplier = 60.0 / self.interval\n+        self.task = None\n+        self.encoder = ScrapyJSONEncoder(sort_keys=True, indent=4)\n+        self.ext_stats_enabled = bool(ext_stats)\n+        self.ext_stats_include = ext_stats.get(\"include\", [])\n+        self.ext_stats_exclude = ext_stats.get(\"exclude\", [])\n+        self.ext_delta_enabled = bool(ext_delta)\n+        self.ext_delta_include = ext_delta.get(\"include\", [])\n+        self.ext_delta_exclude = ext_delta.get(\"exclude\", [])\n+        self.ext_timing_enabled = ext_timing_enabled\n+\n+    @classmethod\n+    def from_crawler(cls, crawler):\n+        interval = crawler.settings.getfloat(\"LOGSTATS_INTERVAL\")\n+        try:\n+            ext_stats = crawler.settings.getdict(\"PERIODIC_LOG_STATS\")\n+        except (TypeError, ValueError):\n+            ext_stats = (\n+                {\"enabled\": True}\n+                if crawler.settings.getbool(\"PERIODIC_LOG_STATS\")\n+                else None\n+            )\n+        try:\n+            ext_delta = crawler.settings.getdict(\"PERIODIC_LOG_DELTA\")\n+        except (TypeError, ValueError):\n+            ext_delta = (\n+                {\"enabled\": True}\n+                if crawler.settings.getbool(\"PERIODIC_LOG_DELTA\")\n+                else None\n+            )\n+\n+        ext_timing_enabled = crawler.settings.getbool(\n+            \"PERIODIC_LOG_TIMING_ENABLED\", False\n+        )\n+        if not interval:\n+            raise NotConfigured\n+        if not (ext_stats or ext_delta or ext_timing_enabled):\n+            raise NotConfigured\n+        o = cls(\n+            crawler.stats,\n+            interval,\n+            ext_stats,\n+            ext_delta,\n+            ext_timing_enabled,\n+        )\n+        crawler.signals.connect(o.spider_opened, signal=signals.spider_opened)\n+        crawler.signals.connect(o.spider_closed, signal=signals.spider_closed)\n+        return o\n+\n+    def spider_opened(self, spider):\n+        self.time_prev = datetime.utcnow()\n+        self.delta_prev = {}\n+        self.stats_prev = {}\n+\n+        self.task = task.LoopingCall(self.log)\n+        self.task.start(self.interval)\n+\n+    def log(self):\n+        data = {}\n+        if self.ext_timing_enabled:\n+            data.update(self.log_timing())\n+        if self.ext_delta_enabled:\n+            data.update(self.log_delta())\n+        if self.ext_stats_enabled:\n+            data.update(self.log_crawler_stats())\n+        logger.info(self.encoder.encode(data))\n+\n+    def log_delta(self):\n+        num_stats = {\n+            k: v\n+            for k, v in self.stats._stats.items()\n+            if isinstance(v, (int, float))\n+            and self.param_allowed(k, self.ext_delta_include, self.ext_delta_exclude)\n+        }\n+        delta = {k: v - self.delta_prev.get(k, 0) for k, v in num_stats.items()}\n+        self.delta_prev = num_stats\n+        return {\"delta\": delta}\n+\n+    def log_timing(self):\n+        now = datetime.utcnow()\n+        time = {\n+            \"log_interval\": self.interval,\n+            \"start_time\": self.stats._stats[\"start_time\"],\n+            \"utcnow\": now,\n+            \"log_interval_real\": (now - self.time_prev).total_seconds(),\n+            \"elapsed\": (now - self.stats._stats[\"start_time\"]).total_seconds(),\n+        }\n+        self.time_prev = now\n+        return {\"time\": time}\n+\n+    def log_crawler_stats(self):\n+        stats = {\n+            k: v\n+            for k, v in self.stats._stats.items()\n+            if self.param_allowed(k, self.ext_stats_include, self.ext_stats_exclude)\n+        }\n+        return {\"stats\": stats}\n+\n+    def param_allowed(self, stat_name, include, exclude):",
      "comment": "@Gallaecio \r\nI think it is required to have several hudreds of active stats values to have performance issues from this method - this is not typical scrapy usecase. \r\n\r\nI think that we need wider community feedback to this extension to make decision.\r\nTo implement this it is required:\r\n1. update method to have only 1 argument `param_allowed(self, stat_name)` to make `functools.lru_cache` a bit easier to implement/maintain.\r\n2. implement possibility to define size of lru cache (by setting).",
      "comment_id": 1291537368,
      "user": "GeorgeA92",
      "created_at": "2023-08-11T15:57:35Z",
      "url": "https://github.com/scrapy/scrapy/pull/5926#discussion_r1291537368"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 6014,
      "file_path": "scrapy/extensions/corestats.py",
      "line": 29,
      "side": "RIGHT",
      "diff_hunk": "@@ -22,11 +22,11 @@ def from_crawler(cls, crawler):\n         return o\n \n     def spider_opened(self, spider):\n-        self.start_time = datetime.utcnow()\n+        self.start_time = datetime.now(tz=timezone.utc)\n         self.stats.set_value(\"start_time\", self.start_time, spider=spider)\n \n     def spider_closed(self, spider, reason):\n-        finish_time = datetime.utcnow()\n+        finish_time = datetime.now(tz=timezone.utc)",
      "comment": "I notify that at this stage contents of https://github.com/scrapy/scrapy/pull/5926 have additional usage of `datetime.utcnow()` to.. match/compare with values generated from.. current version of this codelines.",
      "comment_id": 1297590809,
      "user": "GeorgeA92",
      "created_at": "2023-08-17T18:26:24Z",
      "url": "https://github.com/scrapy/scrapy/pull/6014#discussion_r1297590809"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 6013,
      "file_path": "scrapy/settings/__init__.py",
      "line": 242,
      "side": "RIGHT",
      "diff_hunk": "@@ -238,7 +239,7 @@ def getdict(\n     def getdictorlist(\n         self,\n         name: _SettingsKeyT,\n-        default: Union[Dict[Any, Any], List[Any], None] = None,\n+        default: Union[Dict[Any, Any], List[Any], Set[Any], Tuple[Any], None] = None,",
      "comment": "@wRAR I with doubt about add this typing hint, since is for the default value, make sense or should i remove it?",
      "comment_id": 1292690690,
      "user": "Laerte",
      "created_at": "2023-08-13T06:58:53Z",
      "url": "https://github.com/scrapy/scrapy/pull/6013#discussion_r1292690690"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 6013,
      "file_path": "scrapy/settings/__init__.py",
      "line": 242,
      "side": "RIGHT",
      "diff_hunk": "@@ -238,7 +239,7 @@ def getdict(\n     def getdictorlist(\n         self,\n         name: _SettingsKeyT,\n-        default: Union[Dict[Any, Any], List[Any], None] = None,\n+        default: Union[Dict[Any, Any], List[Any], Set[Any], Tuple[Any], None] = None,",
      "comment": "I think it makes sense as it's supported, but doesn't matter that much.",
      "comment_id": 1292763053,
      "user": "wRAR",
      "created_at": "2023-08-13T11:25:10Z",
      "url": "https://github.com/scrapy/scrapy/pull/6013#discussion_r1292763053"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 6013,
      "file_path": "scrapy/settings/__init__.py",
      "line": 275,
      "side": "RIGHT",
      "diff_hunk": "@@ -271,6 +272,8 @@ def getdictorlist(\n                 return value_loaded\n             except ValueError:\n                 return value.split(\",\")\n+        if isinstance(value, (tuple, set)):",
      "comment": "Supporting sets looks a bit strange here, because sets don't gurantee the same order of elements. I think it's better to discourage users from using sets here, as there is no real use case for that, and it'd shuffle the order of columns in the final file in unexpected way.",
      "comment_id": 1293180703,
      "user": "kmike",
      "created_at": "2023-08-14T08:51:58Z",
      "url": "https://github.com/scrapy/scrapy/pull/6013#discussion_r1293180703"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 6005,
      "file_path": "scrapy/dupefilters.py",
      "line": 51,
      "side": "RIGHT",
      "diff_hunk": "@@ -47,10 +48,12 @@ def __init__(\n         path: Optional[str] = None,\n         debug: bool = False,\n         *,\n-        fingerprinter=None,\n+        fingerprinter: Optional[RequestFingerprinter] = None,",
      "comment": "I\u2019m not sure this and other uses of RequestFingerprinter for typing below are technically true.\r\n\r\nAny object that implements the request fingerprinting interface, i.e. having a `fingerprint(request: Request) -> bytes` method, should be expected here, not only a RequestFingerprinter subclass.",
      "comment_id": 1289567798,
      "user": "Gallaecio",
      "created_at": "2023-08-10T05:27:11Z",
      "url": "https://github.com/scrapy/scrapy/pull/6005#discussion_r1289567798"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 6005,
      "file_path": "scrapy/dupefilters.py",
      "line": 51,
      "side": "RIGHT",
      "diff_hunk": "@@ -47,10 +48,12 @@ def __init__(\n         path: Optional[str] = None,\n         debug: bool = False,\n         *,\n-        fingerprinter=None,\n+        fingerprinter: Optional[RequestFingerprinter] = None,",
      "comment": "This is a bigger question to be honest.\r\n\r\nThere are many places where Scrapy provides an implementation (sometimes 2-3 implementations), allows users to provide a custom implementation and uses a setting to load the class (LOG_FORMATTER, STATS_CLASS, SPIDER_LOADER_CLASS, DOWNLOADER, SCHEDULER etc.). So far in these cases I used the default implementation for type hints, assuming that a custom implementation will have the same interface even when it's not a subclass of it. But after your comment I think we should instead explicitly define protocols and use those.",
      "comment_id": 1289916316,
      "user": "wRAR",
      "created_at": "2023-08-10T10:26:10Z",
      "url": "https://github.com/scrapy/scrapy/pull/6005#discussion_r1289916316"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 6005,
      "file_path": "scrapy/dupefilters.py",
      "line": 51,
      "side": "RIGHT",
      "diff_hunk": "@@ -47,10 +48,12 @@ def __init__(\n         path: Optional[str] = None,\n         debug: bool = False,\n         *,\n-        fingerprinter=None,\n+        fingerprinter: Optional[RequestFingerprinter] = None,",
      "comment": "I've added `RequestFingerprinterProtocol` and removed typing for SpiderLoader fields as we have ISpiderLoader and adding proper typing for interfaces should be done separately.",
      "comment_id": 1290581954,
      "user": "wRAR",
      "created_at": "2023-08-10T19:19:26Z",
      "url": "https://github.com/scrapy/scrapy/pull/6005#discussion_r1290581954"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 6003,
      "file_path": "scrapy/utils/iterators.py",
      "line": 114,
      "side": "RIGHT",
      "diff_hunk": "@@ -71,30 +101,39 @@ def xmliter_lxml(obj, nodename, namespace=None, prefix=\"x\"):\n \n \n class _StreamReader:\n-    def __init__(self, obj):\n-        self._ptr = 0\n-        if isinstance(obj, Response):\n+    def __init__(self, obj: Union[TextResponse, str, bytes]):\n+        self._ptr: int = 0\n+        self._text: Union[str, bytes]\n+        if isinstance(obj, TextResponse):\n             self._text, self.encoding = obj.body, obj.encoding\n         else:\n             self._text, self.encoding = obj, \"utf-8\"\n-        self._is_unicode = isinstance(self._text, str)\n+        self._is_unicode: bool = isinstance(self._text, str)\n \n-    def read(self, n=65535):\n-        self.read = self._read_unicode if self._is_unicode else self._read_string\n+    def read(self, n: int = 65535) -> bytes:\n+        self.read: Callable[[int], bytes] = (  # type: ignore[method-assign]",
      "comment": "This code is wild: if you look closely you'll see that it assigns a different callable to itself. I have no idea if it's intended. I even think the behavior on the first and subsequent calls is different as `lstrip()` is only called on the first call.",
      "comment_id": 1285221930,
      "user": "wRAR",
      "created_at": "2023-08-06T13:50:16Z",
      "url": "https://github.com/scrapy/scrapy/pull/6003#discussion_r1285221930"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 6003,
      "file_path": "scrapy/utils/iterators.py",
      "line": 114,
      "side": "RIGHT",
      "diff_hunk": "@@ -71,30 +101,39 @@ def xmliter_lxml(obj, nodename, namespace=None, prefix=\"x\"):\n \n \n class _StreamReader:\n-    def __init__(self, obj):\n-        self._ptr = 0\n-        if isinstance(obj, Response):\n+    def __init__(self, obj: Union[TextResponse, str, bytes]):\n+        self._ptr: int = 0\n+        self._text: Union[str, bytes]\n+        if isinstance(obj, TextResponse):\n             self._text, self.encoding = obj.body, obj.encoding\n         else:\n             self._text, self.encoding = obj, \"utf-8\"\n-        self._is_unicode = isinstance(self._text, str)\n+        self._is_unicode: bool = isinstance(self._text, str)\n \n-    def read(self, n=65535):\n-        self.read = self._read_unicode if self._is_unicode else self._read_string\n+    def read(self, n: int = 65535) -> bytes:\n+        self.read: Callable[[int], bytes] = (  # type: ignore[method-assign]",
      "comment": "Maybe we should take the chance to fix it? e.g. assign `self._read = \u2026` on `__init__`, and use `self._read(n).lstrip()` here?",
      "comment_id": 1285587470,
      "user": "Gallaecio",
      "created_at": "2023-08-07T09:03:53Z",
      "url": "https://github.com/scrapy/scrapy/pull/6003#discussion_r1285587470"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 6003,
      "file_path": "scrapy/utils/iterators.py",
      "line": 114,
      "side": "RIGHT",
      "diff_hunk": "@@ -71,30 +101,39 @@ def xmliter_lxml(obj, nodename, namespace=None, prefix=\"x\"):\n \n \n class _StreamReader:\n-    def __init__(self, obj):\n-        self._ptr = 0\n-        if isinstance(obj, Response):\n+    def __init__(self, obj: Union[TextResponse, str, bytes]):\n+        self._ptr: int = 0\n+        self._text: Union[str, bytes]\n+        if isinstance(obj, TextResponse):\n             self._text, self.encoding = obj.body, obj.encoding\n         else:\n             self._text, self.encoding = obj, \"utf-8\"\n-        self._is_unicode = isinstance(self._text, str)\n+        self._is_unicode: bool = isinstance(self._text, str)\n \n-    def read(self, n=65535):\n-        self.read = self._read_unicode if self._is_unicode else self._read_string\n+    def read(self, n: int = 65535) -> bytes:\n+        self.read: Callable[[int], bytes] = (  # type: ignore[method-assign]",
      "comment": "I think it could just use a local variable and not assign it anywhere. But, as usual, I wonder if fixing it will break anytning :)\r\n\r\nOn the other hand, it shouldn't and we have tests for it.",
      "comment_id": 1285671430,
      "user": "wRAR",
      "created_at": "2023-08-07T10:15:14Z",
      "url": "https://github.com/scrapy/scrapy/pull/6003#discussion_r1285671430"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 6003,
      "file_path": "scrapy/utils/iterators.py",
      "line": 114,
      "side": "RIGHT",
      "diff_hunk": "@@ -71,30 +101,39 @@ def xmliter_lxml(obj, nodename, namespace=None, prefix=\"x\"):\n \n \n class _StreamReader:\n-    def __init__(self, obj):\n-        self._ptr = 0\n-        if isinstance(obj, Response):\n+    def __init__(self, obj: Union[TextResponse, str, bytes]):\n+        self._ptr: int = 0\n+        self._text: Union[str, bytes]\n+        if isinstance(obj, TextResponse):\n             self._text, self.encoding = obj.body, obj.encoding\n         else:\n             self._text, self.encoding = obj, \"utf-8\"\n-        self._is_unicode = isinstance(self._text, str)\n+        self._is_unicode: bool = isinstance(self._text, str)\n \n-    def read(self, n=65535):\n-        self.read = self._read_unicode if self._is_unicode else self._read_string\n+    def read(self, n: int = 65535) -> bytes:\n+        self.read: Callable[[int], bytes] = (  # type: ignore[method-assign]",
      "comment": "Looks like it intentionally only strips on the first read, to skip the leading whitespace in the file (it's even possible that it's just for tests which have leading whitespace). `xmliter` instead uses regexes to find the document header.\r\n\r\nIn any case, we don't even advertise this function, even though it's used in some old 3rd-party code, I don't want to spend too much time on it.",
      "comment_id": 1285727741,
      "user": "wRAR",
      "created_at": "2023-08-07T11:14:50Z",
      "url": "https://github.com/scrapy/scrapy/pull/6003#discussion_r1285727741"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 6003,
      "file_path": "scrapy/extensions/feedexport.py",
      "line": 293,
      "side": "RIGHT",
      "diff_hunk": "@@ -282,15 +282,22 @@ def _store_in_thread(self, file):\n \n \n class FTPFeedStorage(BlockingFeedStorage):\n-    def __init__(self, uri, use_active_mode=False, *, feed_options=None):\n+    def __init__(\n+        self,\n+        uri: str,\n+        use_active_mode: bool = False,\n+        *,\n+        feed_options: Optional[Dict[str, Any]] = None,\n+    ):\n         u = urlparse(uri)\n-        self.host = u.hostname\n-        self.port = int(u.port or \"21\")\n-        self.username = u.username\n-        self.password = unquote(u.password or \"\")\n-        self.path = u.path\n-        self.use_active_mode = use_active_mode\n-        self.overwrite = not feed_options or feed_options.get(\"overwrite\", True)\n+        assert u.hostname",
      "comment": "Maybe it would be better to raise a ValueError or similar here instead?",
      "comment_id": 1288063347,
      "user": "Gallaecio",
      "created_at": "2023-08-09T07:26:53Z",
      "url": "https://github.com/scrapy/scrapy/pull/6003#discussion_r1288063347"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 6003,
      "file_path": "scrapy/utils/iterators.py",
      "line": 90,
      "side": "RIGHT",
      "diff_hunk": "@@ -54,12 +75,20 @@ def xmliter(obj, nodename):\n         yield Selector(text=nodetext, type=\"xml\")\n \n \n-def xmliter_lxml(obj, nodename, namespace=None, prefix=\"x\"):\n+def xmliter_lxml(\n+    obj: Union[Response, str, bytes],\n+    nodename: str,\n+    namespace: Optional[str] = None,\n+    prefix: str = \"x\",\n+) -> Generator[Selector, Any, None]:\n     from lxml import etree\n \n     reader = _StreamReader(obj)\n     tag = f\"{{{namespace}}}{nodename}\" if namespace else nodename\n-    iterable = etree.iterparse(reader, tag=tag, encoding=reader.encoding)\n+    # technically, etree.iterparse only needs .read() AFAICS, but this is how it's typed\n+    iterable = etree.iterparse(\n+        cast(\"SupportsReadClose[bytes]\", reader), tag=tag, encoding=reader.encoding",
      "comment": ":lipstick: Would it work to move the type hint to line 60/86 above instead of casting here?\r\n\r\nPS: I\u2019m not sure we need the comment.",
      "comment_id": 1288070251,
      "user": "Gallaecio",
      "created_at": "2023-08-09T07:33:12Z",
      "url": "https://github.com/scrapy/scrapy/pull/6003#discussion_r1288070251"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 5146,
      "file_path": "scrapy/http/headers.py",
      "line": 86,
      "side": "RIGHT",
      "diff_hunk": "@@ -76,13 +77,13 @@ def to_string(self):\n         return headers_dict_to_raw(self)\n \n     def to_unicode_dict(self):\n-        \"\"\" Return headers as a CaselessDict with unicode keys\n+        \"\"\" Return headers as a CaseInsensitiveDict with unicode keys\n         and unicode values. Multiple values are joined with ','.\n         \"\"\"\n-        return CaselessDict(\n-            (to_unicode(key, encoding=self.encoding),\n-             to_unicode(b','.join(value), encoding=self.encoding))\n-            for key, value in self.items())\n+        return CaseInsensitiveDict(\n+            (to_unicode(key, encoding=self.encoding), to_unicode(b','.join(value), encoding=self.encoding))\n+            for key, value in self.items()\n+        )",
      "comment": "This change should be safe I think, `CaseInsensitiveDict`'s interface is the same as `CaselessDict`. The method is only used [here](https://github.com/scrapy/scrapy/blob/2.5.0/scrapy/core/downloader/handlers/s3.py#L67). ",
      "comment_id": 631242349,
      "user": "elacuesta",
      "created_at": "2021-05-12T17:18:39Z",
      "url": "https://github.com/scrapy/scrapy/pull/5146#discussion_r631242349"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 5146,
      "file_path": "scrapy/utils/datatypes.py",
      "line": 97,
      "side": "RIGHT",
      "diff_hunk": "@@ -63,6 +79,36 @@ def pop(self, key, *args):\n         return dict.pop(self, self.normkey(key), *args)\n \n \n+class CaseInsensitiveDict(collections.UserDict):\n+    \"\"\"A dict-like structure that accepts strings or bytes as keys and allows case-insensitive lookups.\n+\n+    It also allows overriding key and value normalization by defining custom `normkey` and `normvalue` methods.\n+    \"\"\"\n+\n+    def __getitem__(self, key: AnyStr) -> Any:\n+        return super().__getitem__(self.normkey(key))\n+\n+    def __setitem__(self, key: AnyStr, value: Any) -> None:\n+        super().__setitem__(self.normkey(key), self.normvalue(value))\n+\n+    def __delitem__(self, key: AnyStr) -> None:\n+        super().__delitem__(self.normkey(key))\n+\n+    def __contains__(self, key: AnyStr) -> bool:  # type: ignore[override]",
      "comment": "Even if this goes against [Liskov substitution principle](https://mypy.readthedocs.io/en/stable/common_issues.html#incompatible-overrides), it makes sense because being case-insensitive only applies to str or bytes, not to all hashable types.",
      "comment_id": 631244953,
      "user": "elacuesta",
      "created_at": "2021-05-12T17:22:23Z",
      "url": "https://github.com/scrapy/scrapy/pull/5146#discussion_r631244953"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 5146,
      "file_path": "scrapy/http/headers.py",
      "line": 86,
      "side": "RIGHT",
      "diff_hunk": "@@ -76,13 +77,13 @@ def to_string(self):\n         return headers_dict_to_raw(self)\n \n     def to_unicode_dict(self):\n-        \"\"\" Return headers as a CaselessDict with unicode keys\n+        \"\"\" Return headers as a CaseInsensitiveDict with unicode keys\n         and unicode values. Multiple values are joined with ','.\n         \"\"\"\n-        return CaselessDict(\n-            (to_unicode(key, encoding=self.encoding),\n-             to_unicode(b','.join(value), encoding=self.encoding))\n-            for key, value in self.items())\n+        return CaseInsensitiveDict(\n+            (to_unicode(key, encoding=self.encoding), to_unicode(b','.join(value), encoding=self.encoding))\n+            for key, value in self.items()\n+        )",
      "comment": "It\u2019s still a potential issue for `isinstance` usages. I\u2019m not saying I\u2019m against this change, but I am unsure.",
      "comment_id": 631878717,
      "user": "Gallaecio",
      "created_at": "2021-05-13T15:02:06Z",
      "url": "https://github.com/scrapy/scrapy/pull/5146#discussion_r631878717"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 5146,
      "file_path": "scrapy/http/headers.py",
      "line": 86,
      "side": "RIGHT",
      "diff_hunk": "@@ -76,13 +77,13 @@ def to_string(self):\n         return headers_dict_to_raw(self)\n \n     def to_unicode_dict(self):\n-        \"\"\" Return headers as a CaselessDict with unicode keys\n+        \"\"\" Return headers as a CaseInsensitiveDict with unicode keys\n         and unicode values. Multiple values are joined with ','.\n         \"\"\"\n-        return CaselessDict(\n-            (to_unicode(key, encoding=self.encoding),\n-             to_unicode(b','.join(value), encoding=self.encoding))\n-            for key, value in self.items())\n+        return CaseInsensitiveDict(\n+            (to_unicode(key, encoding=self.encoding), to_unicode(b','.join(value), encoding=self.encoding))\n+            for key, value in self.items()\n+        )",
      "comment": "This should address the `isinstance` check:\r\n```diff\r\ndiff --git scrapy/utils/datatypes.py scrapy/utils/datatypes.py\r\nindex 6eeabe1e..63c07b48 100644\r\n--- scrapy/utils/datatypes.py\r\n+++ scrapy/utils/datatypes.py\r\n@@ -21,7 +21,7 @@ class CaselessDict(dict):\r\n     def __new__(cls, *args, **kwargs):\r\n         from scrapy.http.headers import Headers\r\n \r\n-        if issubclass(cls, CaselessDict) and not issubclass(cls, Headers):\r\n+        if issubclass(cls, CaselessDict) and not issubclass(cls, (CaseInsensitiveDict, Headers)):\r\n             warnings.warn(\r\n                 \"scrapy.utils.datatypes.CaselessDict is deprecated,\"\r\n                 \" please use scrapy.utils.datatypes.CaseInsensitiveDict instead\",\r\n@@ -79,7 +79,7 @@ class CaselessDict(dict):\r\n         return dict.pop(self, self.normkey(key), *args)\r\n \r\n \r\n-class CaseInsensitiveDict(collections.UserDict):\r\n+class CaseInsensitiveDict(collections.UserDict, CaselessDict):\r\n     \"\"\"A dict-like structure that accepts strings or bytes as keys and allows case-insensitive lookups.\r\n \r\n     It also allows overriding key and value normalization by defining custom `normkey` and `normvalue` methods.\r\n```\r\n\r\nAlthough as we discussed this might not be a problem, mostly because `CaselessDict` is not documented.",
      "comment_id": 692333172,
      "user": "elacuesta",
      "created_at": "2021-08-19T17:15:36Z",
      "url": "https://github.com/scrapy/scrapy/pull/5146#discussion_r692333172"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 5146,
      "file_path": "scrapy/utils/datatypes.py",
      "line": 94,
      "side": "RIGHT",
      "diff_hunk": "@@ -63,6 +79,46 @@ def pop(self, key, *args):\n         return dict.pop(self, self.normkey(key), *args)\n \n \n+class CaseInsensitiveDict(collections.UserDict):\n+    \"\"\"A dict-like structure that accepts strings or bytes as keys and allows case-insensitive lookups.\n+\n+    It also allows overriding key and value normalization by defining custom `normkey` and `normvalue` methods.\n+    \"\"\"\n+\n+    def __init__(self, *args, **kwargs) -> None:\n+        self._keys: dict = {}\n+        super().__init__(*args, **kwargs)\n+\n+    def __getitem__(self, key: AnyStr) -> Any:\n+        normalized_key = self.normkey(key)\n+        return super().__getitem__(self._keys[normalized_key.lower()])",
      "comment": "Shouldn\u2019t `.lower()` remain in `self.normkey()`? It feels like we are hardcoding key normalization here.\r\n\r\nOn the one hand, it suits the class name. Maybe what we should have is a parent class with most of the functionality and this class simply setting `normkey`? Or simply have the docstrings clarify that the caseinsensitive part is not customizable in subclasses.\r\n\r\nOn the other hand, since the argument not to worry too much about backward incompatibilities with the previous class was that it was not documented, maybe we should make this class private, and if so maybe we do not need to offer facilities for subclassing.",
      "comment_id": 694538755,
      "user": "Gallaecio",
      "created_at": "2021-08-24T06:31:47Z",
      "url": "https://github.com/scrapy/scrapy/pull/5146#discussion_r694538755"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 5146,
      "file_path": "scrapy/utils/datatypes.py",
      "line": 94,
      "side": "RIGHT",
      "diff_hunk": "@@ -63,6 +79,46 @@ def pop(self, key, *args):\n         return dict.pop(self, self.normkey(key), *args)\n \n \n+class CaseInsensitiveDict(collections.UserDict):\n+    \"\"\"A dict-like structure that accepts strings or bytes as keys and allows case-insensitive lookups.\n+\n+    It also allows overriding key and value normalization by defining custom `normkey` and `normvalue` methods.\n+    \"\"\"\n+\n+    def __init__(self, *args, **kwargs) -> None:\n+        self._keys: dict = {}\n+        super().__init__(*args, **kwargs)\n+\n+    def __getitem__(self, key: AnyStr) -> Any:\n+        normalized_key = self.normkey(key)\n+        return super().__getitem__(self._keys[normalized_key.lower()])",
      "comment": "The intention is to hardcode the normalization of the access, while delegating the normalization of the keys/values themselves to `normkkey/normvalue`. Consider the following example:\r\n\r\n```python\r\nIn [1]: from scrapy.utils.datatypes import CaseInsensitiveDict\r\n\r\nIn [2]: CaseInsensitiveDict({\"FOO\": \"bar\"})  # key remains uppercase\r\nOut[2]: <CaseInsensitiveDict: {'FOO': 'bar'}>\r\n\r\nIn [3]: CaseInsensitiveDict({\"FOO\": \"bar\"})[\"foo\"]  # access via lowercase key\r\nOut[3]: 'bar'\r\n\r\nIn [4]: class TitleCaseCaseInsensitiveDict(CaseInsensitiveDict):\r\n   ...:    def normkey(self, key):\r\n   ...:        return key.title()\r\n   ...: \r\n\r\nIn [5]: TitleCaseCaseInsensitiveDict({\"FOO\": \"bar\"})  # key is converted to title case\r\nOut[5]: <TitleCaseCaseInsensitiveDict: {'Foo': 'bar'}>\r\n\r\nIn [6]: TitleCaseCaseInsensitiveDict({\"FOO\": \"bar\"})[\"foo\"]  # access via lowercase key\r\nOut[6]: 'bar'\r\n```\r\n\r\nMy plan was to override this in the new `Headers` implementation, to go from `header-name` to `Header-Name`, but that probably only needs to be an implementation detail and not part of the public interface (in fact, we might not event need or want to do that, if Twisted capitalizes headers on its own). For now I'll rename to `_normkey/_normvalue`, we might even remove them altogether later.",
      "comment_id": 871557720,
      "user": "elacuesta",
      "created_at": "2022-05-12T15:56:40Z",
      "url": "https://github.com/scrapy/scrapy/pull/5146#discussion_r871557720"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 5146,
      "file_path": "scrapy/utils/datatypes.py",
      "line": 97,
      "side": "RIGHT",
      "diff_hunk": "@@ -63,6 +79,36 @@ def pop(self, key, *args):\n         return dict.pop(self, self.normkey(key), *args)\n \n \n+class CaseInsensitiveDict(collections.UserDict):\n+    \"\"\"A dict-like structure that accepts strings or bytes as keys and allows case-insensitive lookups.\n+\n+    It also allows overriding key and value normalization by defining custom `normkey` and `normvalue` methods.\n+    \"\"\"\n+\n+    def __getitem__(self, key: AnyStr) -> Any:\n+        return super().__getitem__(self.normkey(key))\n+\n+    def __setitem__(self, key: AnyStr, value: Any) -> None:\n+        super().__setitem__(self.normkey(key), self.normvalue(value))\n+\n+    def __delitem__(self, key: AnyStr) -> None:\n+        super().__delitem__(self.normkey(key))\n+\n+    def __contains__(self, key: AnyStr) -> bool:  # type: ignore[override]",
      "comment": "I wonder if it's possible to inherit from some type-enabled dict",
      "comment_id": 895061579,
      "user": "kmike",
      "created_at": "2022-06-11T19:51:07Z",
      "url": "https://github.com/scrapy/scrapy/pull/5146#discussion_r895061579"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 5998,
      "file_path": "scrapy/core/engine.py",
      "line": 300,
      "side": "RIGHT",
      "diff_hunk": "@@ -311,39 +293,24 @@ def _schedule_request(self, request: Request, spider: Spider) -> None:\n                 signals.request_dropped, request=request, spider=spider\n             )\n \n-    def download(self, request: Request, spider: Optional[Spider] = None) -> Deferred:\n+    def download(self, request: Request) -> Deferred:\n         \"\"\"Return a Deferred which fires with a Response as result, only downloader middlewares are applied\"\"\"\n-        if spider is not None:\n-            warnings.warn(\n-                \"Passing a 'spider' argument to ExecutionEngine.download is deprecated\",\n-                category=ScrapyDeprecationWarning,\n-                stacklevel=2,\n-            )\n-            if spider is not self.spider:\n-                logger.warning(\n-                    \"The spider '%s' does not match the open spider\", spider.name\n-                )\n         if self.spider is None:\n             raise RuntimeError(f\"No open spider to crawl: {request}\")\n-        return self._download(request, spider).addBoth(\n-            self._downloaded, request, spider\n-        )\n+        return self._download(request).addBoth(self._downloaded, request)",
      "comment": "Here's the culprit from the previous attempt. I forgot to remove spider parameter from `.addBoth` call after removing from `_downloaded` method. \ud83e\udd26\ud83c\udffb\u200d\u2642\ufe0f ",
      "comment_id": 1283701568,
      "user": "Laerte",
      "created_at": "2023-08-03T20:44:36Z",
      "url": "https://github.com/scrapy/scrapy/pull/5998#discussion_r1283701568"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 5996,
      "file_path": "scrapy/core/engine.py",
      "line": 301,
      "side": "RIGHT",
      "diff_hunk": "@@ -311,30 +293,20 @@ def _schedule_request(self, request: Request, spider: Spider) -> None:\n                 signals.request_dropped, request=request, spider=spider\n             )\n \n-    def download(self, request: Request, spider: Optional[Spider] = None) -> Deferred:\n+    def download(self, request: Request) -> Deferred:\n         \"\"\"Return a Deferred which fires with a Response as result, only downloader middlewares are applied\"\"\"\n-        if spider is not None:\n-            warnings.warn(\n-                \"Passing a 'spider' argument to ExecutionEngine.download is deprecated\",\n-                category=ScrapyDeprecationWarning,\n-                stacklevel=2,\n-            )\n-            if spider is not self.spider:\n-                logger.warning(\n-                    \"The spider '%s' does not match the open spider\", spider.name\n-                )\n         if self.spider is None:\n             raise RuntimeError(f\"No open spider to crawl: {request}\")\n-        return self._download(request, spider).addBoth(\n-            self._downloaded, request, spider\n+        return self._download(request, self.spider).addBoth(\n+            self._downloaded, request, self.spider",
      "comment": "Maybe remove this parameter altogether from `_download` function? Since we have this logic inside the function?\r\n\r\nhttps://github.com/scrapy/scrapy/blob/9f9a2292e08cb0944e1e88e64cef1f4b17486ec8/scrapy/core/engine.py#L344-L345",
      "comment_id": 1282010952,
      "user": "Laerte",
      "created_at": "2023-08-02T14:43:08Z",
      "url": "https://github.com/scrapy/scrapy/pull/5996#discussion_r1282010952"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 5950,
      "file_path": "scrapy/addons.py",
      "line": 150,
      "side": "RIGHT",
      "diff_hunk": "@@ -0,0 +1,425 @@\n+import warnings\n+from collections import OrderedDict, defaultdict\n+from collections.abc import Mapping\n+from inspect import isclass\n+from typing import Dict\n+\n+import zope.interface\n+from packaging.requirements import Requirement\n+from packaging.version import Version\n+from zope.interface.verify import verifyObject\n+\n+from scrapy.interfaces import IAddon\n+from scrapy.utils.conf import build_component_list\n+from scrapy.utils.misc import load_module_or_object\n+\n+\n+@zope.interface.implementer(IAddon)\n+class Addon(object):\n+    basic_settings = None\n+    \"\"\"``dict`` of settings that will be exported via :meth:`export_basics`.\"\"\"\n+\n+    default_config = None\n+    \"\"\"``dict`` with default configuration.\"\"\"\n+\n+    config_mapping = None\n+    \"\"\"``dict`` with mappings from config names to setting names. The given\n+    setting names will be taken as given, i.e. they will be neither prefixed\n+    nor uppercased.\n+    \"\"\"\n+\n+    component_type = None\n+    \"\"\"Component setting into which to export via :meth:`export_component`. Can\n+    be any of the dictionary-like component setting names. If ``None``,\n+    :meth:`export_component` will do nothing.\n+    \"\"\"\n+\n+    component_key = None\n+    \"\"\"Key to be used in the component dictionary setting when exporting via\n+    :meth:`export_component`. This is only useful for the settings that have\n+    no order, e.g. ``DOWNLOAD_HANDLERS`` or ``FEED_EXPORTERS``.\n+    \"\"\"\n+\n+    component_order = 0\n+    \"\"\"Component order to use when not given in the add-on configuration. Has\n+    no effect for component types that use :attr:`component_key`.\n+    \"\"\"\n+\n+    component = None\n+    \"\"\"Component to be inserted via :meth:`export_component`. This can be\n+    anything that can be used in the dictionary-like component settings, i.e.\n+    a class path or a class. If ``None``, it is assumed that the add-on itself\n+    also provides the component interface, and ``self`` will be used.\n+    \"\"\"\n+\n+    settings_prefix = None\n+    \"\"\"Prefix with which the add-on configuration will be exported into the\n+    global settings namespace via :meth:`export_config`. If ``None``,\n+    :attr:`name` will be used. If ``False``, no configuration will be exported.\n+    \"\"\"\n+\n+    def export_component(self, config, settings):\n+        \"\"\"Export the component in :attr:`component` into the dictionary-like\n+        component setting derived from :attr:`component_type`.\n+\n+        Where applicable, the order parameter of the component (i.e. the\n+        dictionary value) will be retrieved from the ``order`` add-on\n+        configuration value.\n+\n+        :param config: Add-on configuration from which to read component order\n+        :type config: ``dict``\n+\n+        :param settings: Settings object into which to export component\n+        :type settings: :class:`~scrapy.settings.Settings`\n+        \"\"\"\n+        if self.component_type:\n+            comp = self.component or self\n+            if self.component_key:\n+                # e.g. for DOWNLOAD_HANDLERS: {'http': 'myclass'}\n+                k = self.component_key\n+                v = comp\n+            else:\n+                # e.g. for DOWNLOADER_MIDDLEWARES: {'myclass': 100}\n+                k = comp\n+                v = config.get(\"order\", self.component_order)\n+            settings[self.component_type].update({k: v}, \"addon\")\n+\n+    def export_basics(self, settings):\n+        \"\"\"Export the :attr:`basic_settings` attribute into the settings object.\n+\n+        All settings will be exported with ``addon`` priority (see\n+        :ref:`topics-api-settings`).\n+\n+        :param settings: Settings object into which to expose the basic settings\n+        :type settings: :class:`~scrapy.settings.Settings`\n+        \"\"\"\n+        for setting, value in (self.basic_settings or {}).items():\n+            settings.set(setting, value, \"addon\")\n+\n+    def export_config(self, config, settings):\n+        \"\"\"Export the add-on configuration, all keys in caps and with\n+        :attr:`settings_prefix` or :attr:`name` prepended, into the settings\n+        object.\n+\n+        For example, the add-on configuration ``{'key': 'value'}`` will export\n+        the setting ``ADDONNAME_KEY`` with a value of ``value``. All settings\n+        will be exported with ``addon`` priority (see\n+        :ref:`topics-api-settings`).\n+\n+        :param config: Add-on configuration to be exposed\n+        :type config: ``dict``\n+\n+        :param settings: Settings object into which to export the configuration\n+        :type settings: :class:`~scrapy.settings.Settings`\n+        \"\"\"\n+        if self.settings_prefix is False:\n+            return\n+        conf = self.default_config or {}\n+        conf.update(config)\n+        prefix = self.settings_prefix or self.name\n+        # Since default exported config is case-insensitive (everything will be\n+        # uppercased), make mapped config case-insensitive as well\n+        conf_mapping = {k.lower(): v for k, v in (self.config_mapping or {}).items()}\n+        for key, val in conf.items():\n+            if key.lower() in conf_mapping:\n+                key = conf_mapping[key.lower()]\n+            else:\n+                key = (prefix + \"_\" + key).upper()\n+            settings.set(key, val, \"addon\")\n+\n+    def update_settings(self, config, settings):\n+        \"\"\"Export both the basic settings and the add-on configuration. I.e.,\n+        call :meth:`export_basics` and :meth:`export_config`.\n+\n+        For more advanced add-ons, you may want to override this callback.\n+\n+        :param config: Add-on configuration\n+        :type config: ``dict``\n+\n+        :param settings: Crawler settings object\n+        :type settings: :class:`~scrapy.settings.Settings`\n+        \"\"\"\n+        self.export_component(config, settings)\n+        self.export_basics(settings)\n+        self.export_config(config, settings)\n+\n+\n+class AddonManager(Mapping):\n+    \"\"\"This class facilitates loading and storing :ref:`topics-addons`.\n+\n+    You can treat it like a read-only dictionary in which keys correspond to",
      "comment": "it's not really read-only if `__delitem__` is supported",
      "comment_id": 1240223547,
      "user": "kmike",
      "created_at": "2023-06-23T19:20:50Z",
      "url": "https://github.com/scrapy/scrapy/pull/5950#discussion_r1240223547"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 5950,
      "file_path": "scrapy/addons.py",
      "line": 147,
      "side": "RIGHT",
      "diff_hunk": "@@ -0,0 +1,425 @@\n+import warnings\n+from collections import OrderedDict, defaultdict\n+from collections.abc import Mapping\n+from inspect import isclass\n+from typing import Dict\n+\n+import zope.interface\n+from packaging.requirements import Requirement\n+from packaging.version import Version\n+from zope.interface.verify import verifyObject\n+\n+from scrapy.interfaces import IAddon\n+from scrapy.utils.conf import build_component_list\n+from scrapy.utils.misc import load_module_or_object\n+\n+\n+@zope.interface.implementer(IAddon)\n+class Addon(object):\n+    basic_settings = None\n+    \"\"\"``dict`` of settings that will be exported via :meth:`export_basics`.\"\"\"\n+\n+    default_config = None\n+    \"\"\"``dict`` with default configuration.\"\"\"\n+\n+    config_mapping = None\n+    \"\"\"``dict`` with mappings from config names to setting names. The given\n+    setting names will be taken as given, i.e. they will be neither prefixed\n+    nor uppercased.\n+    \"\"\"\n+\n+    component_type = None\n+    \"\"\"Component setting into which to export via :meth:`export_component`. Can\n+    be any of the dictionary-like component setting names. If ``None``,\n+    :meth:`export_component` will do nothing.\n+    \"\"\"\n+\n+    component_key = None\n+    \"\"\"Key to be used in the component dictionary setting when exporting via\n+    :meth:`export_component`. This is only useful for the settings that have\n+    no order, e.g. ``DOWNLOAD_HANDLERS`` or ``FEED_EXPORTERS``.\n+    \"\"\"\n+\n+    component_order = 0\n+    \"\"\"Component order to use when not given in the add-on configuration. Has\n+    no effect for component types that use :attr:`component_key`.\n+    \"\"\"\n+\n+    component = None\n+    \"\"\"Component to be inserted via :meth:`export_component`. This can be\n+    anything that can be used in the dictionary-like component settings, i.e.\n+    a class path or a class. If ``None``, it is assumed that the add-on itself\n+    also provides the component interface, and ``self`` will be used.\n+    \"\"\"\n+\n+    settings_prefix = None\n+    \"\"\"Prefix with which the add-on configuration will be exported into the\n+    global settings namespace via :meth:`export_config`. If ``None``,\n+    :attr:`name` will be used. If ``False``, no configuration will be exported.\n+    \"\"\"\n+\n+    def export_component(self, config, settings):\n+        \"\"\"Export the component in :attr:`component` into the dictionary-like\n+        component setting derived from :attr:`component_type`.\n+\n+        Where applicable, the order parameter of the component (i.e. the\n+        dictionary value) will be retrieved from the ``order`` add-on\n+        configuration value.\n+\n+        :param config: Add-on configuration from which to read component order\n+        :type config: ``dict``\n+\n+        :param settings: Settings object into which to export component\n+        :type settings: :class:`~scrapy.settings.Settings`\n+        \"\"\"\n+        if self.component_type:\n+            comp = self.component or self\n+            if self.component_key:\n+                # e.g. for DOWNLOAD_HANDLERS: {'http': 'myclass'}\n+                k = self.component_key\n+                v = comp\n+            else:\n+                # e.g. for DOWNLOADER_MIDDLEWARES: {'myclass': 100}\n+                k = comp\n+                v = config.get(\"order\", self.component_order)\n+            settings[self.component_type].update({k: v}, \"addon\")\n+\n+    def export_basics(self, settings):\n+        \"\"\"Export the :attr:`basic_settings` attribute into the settings object.\n+\n+        All settings will be exported with ``addon`` priority (see\n+        :ref:`topics-api-settings`).\n+\n+        :param settings: Settings object into which to expose the basic settings\n+        :type settings: :class:`~scrapy.settings.Settings`\n+        \"\"\"\n+        for setting, value in (self.basic_settings or {}).items():\n+            settings.set(setting, value, \"addon\")\n+\n+    def export_config(self, config, settings):\n+        \"\"\"Export the add-on configuration, all keys in caps and with\n+        :attr:`settings_prefix` or :attr:`name` prepended, into the settings\n+        object.\n+\n+        For example, the add-on configuration ``{'key': 'value'}`` will export\n+        the setting ``ADDONNAME_KEY`` with a value of ``value``. All settings\n+        will be exported with ``addon`` priority (see\n+        :ref:`topics-api-settings`).\n+\n+        :param config: Add-on configuration to be exposed\n+        :type config: ``dict``\n+\n+        :param settings: Settings object into which to export the configuration\n+        :type settings: :class:`~scrapy.settings.Settings`\n+        \"\"\"\n+        if self.settings_prefix is False:\n+            return\n+        conf = self.default_config or {}\n+        conf.update(config)\n+        prefix = self.settings_prefix or self.name\n+        # Since default exported config is case-insensitive (everything will be\n+        # uppercased), make mapped config case-insensitive as well\n+        conf_mapping = {k.lower(): v for k, v in (self.config_mapping or {}).items()}\n+        for key, val in conf.items():\n+            if key.lower() in conf_mapping:\n+                key = conf_mapping[key.lower()]\n+            else:\n+                key = (prefix + \"_\" + key).upper()\n+            settings.set(key, val, \"addon\")\n+\n+    def update_settings(self, config, settings):\n+        \"\"\"Export both the basic settings and the add-on configuration. I.e.,\n+        call :meth:`export_basics` and :meth:`export_config`.\n+\n+        For more advanced add-ons, you may want to override this callback.\n+\n+        :param config: Add-on configuration\n+        :type config: ``dict``\n+\n+        :param settings: Crawler settings object\n+        :type settings: :class:`~scrapy.settings.Settings`\n+        \"\"\"\n+        self.export_component(config, settings)\n+        self.export_basics(settings)\n+        self.export_config(config, settings)\n+\n+\n+class AddonManager(Mapping):",
      "comment": "If we proceed with removal of various features, we should check which code in the AddonManager is still valuable.",
      "comment_id": 1240224938,
      "user": "kmike",
      "created_at": "2023-06-23T19:22:45Z",
      "url": "https://github.com/scrapy/scrapy/pull/5950#discussion_r1240224938"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 5950,
      "file_path": "scrapy/crawler.py",
      "line": 60,
      "side": "RIGHT",
      "diff_hunk": "@@ -56,6 +57,7 @@ def __init__(\n         spidercls: Type[Spider],\n         settings: Union[None, dict, Settings] = None,\n         init_reactor: bool = False,\n+        addons: Optional[AddonManager] = None,",
      "comment": "Why does Crawler need this argument? It doesn't accept e.g. a SignalManager or StatsCollector.",
      "comment_id": 1240225820,
      "user": "kmike",
      "created_at": "2023-06-23T19:24:06Z",
      "url": "https://github.com/scrapy/scrapy/pull/5950#discussion_r1240225820"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 5950,
      "file_path": "scrapy/interfaces.py",
      "line": 24,
      "side": "RIGHT",
      "diff_hunk": "@@ -15,3 +15,22 @@ def list():\n \n     def find_by_request(request):\n         \"\"\"Return the list of spiders names that can handle the given request\"\"\"\n+\n+\n+class IAddon(Interface):\n+    \"\"\"Scrapy add-on\"\"\"\n+\n+    name = Attribute(\"\"\"Add-on name\"\"\")\n+    version = Attribute(\"\"\"Add-on version string (PEP440)\"\"\")",
      "comment": "As these attributes don't seem to be required, I'm not sure we need this interface.",
      "comment_id": 1240227276,
      "user": "kmike",
      "created_at": "2023-06-23T19:26:10Z",
      "url": "https://github.com/scrapy/scrapy/pull/5950#discussion_r1240227276"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 5950,
      "file_path": "scrapy/utils/conf.py",
      "line": 102,
      "side": "LEFT",
      "diff_hunk": "@@ -99,14 +99,20 @@ def init_env(project=\"default\", set_syspath=True):\n             sys.path.append(projdir)\n \n \n-def get_config(use_closest=True):",
      "comment": "Is it a general refactoring, or is it needed for the PR to work?",
      "comment_id": 1240228712,
      "user": "kmike",
      "created_at": "2023-06-23T19:27:47Z",
      "url": "https://github.com/scrapy/scrapy/pull/5950#discussion_r1240228712"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 5950,
      "file_path": "scrapy/addons.py",
      "line": 46,
      "side": "RIGHT",
      "diff_hunk": "@@ -0,0 +1,65 @@\n+import logging\n+from typing import TYPE_CHECKING, Any, List\n+\n+from scrapy.utils.conf import build_component_list\n+from scrapy.utils.misc import create_instance, load_object\n+\n+if TYPE_CHECKING:\n+    from scrapy.crawler import Crawler\n+\n+logger = logging.getLogger(__name__)\n+\n+\n+class AddonManager:\n+    \"\"\"This class facilitates loading and storing :ref:`topics-addons`.\"\"\"\n+\n+    def __init__(self, crawler: \"Crawler\") -> None:\n+        self.crawler: \"Crawler\" = crawler\n+        self.addons: List[Any] = []\n+\n+    def add(self, addon: Any) -> None:\n+        \"\"\"Store an add-on.\n+\n+        :param addon: The add-on object (or path) to be stored\n+        :type addon: Python object, class or ``str``\n+\n+        :param config: The add-on configuration dictionary\n+        :type config: ``dict``\n+        \"\"\"\n+        if isinstance(addon, (type, str)):\n+            addon = load_object(addon)\n+        if isinstance(addon, type):\n+            addon = create_instance(addon, settings=None, crawler=self.crawler)\n+        self.addons.append(addon)\n+\n+    def load_settings(self, settings) -> None:\n+        \"\"\"Load add-ons and configurations from settings object.\n+\n+        This will load the addon for every add-on path in the\n+        ``ADDONS`` setting.\n+\n+        :param settings: The :class:`~scrapy.settings.Settings` object from \\\n+            which to read the add-on configuration\n+        :type settings: :class:`~scrapy.settings.Settings`\n+        \"\"\"\n+        paths = build_component_list(settings[\"ADDONS\"])\n+        addons = [load_object(path) for path in paths]",
      "comment": "I wonder if the use if `load_object` here is on purpose, given `self.add` already takes care of that.\r\n\r\nBut maybe it *is* on purpose, to normalize `addons` for the `logger.info` call later, without having to instead use `[addon.__class__ for addon in self.addons]` instead.",
      "comment_id": 1266522980,
      "user": "Gallaecio",
      "created_at": "2023-07-18T09:43:53Z",
      "url": "https://github.com/scrapy/scrapy/pull/5950#discussion_r1266522980"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 5950,
      "file_path": "scrapy/addons.py",
      "line": 13,
      "side": "RIGHT",
      "diff_hunk": "@@ -0,0 +1,65 @@\n+import logging\n+from typing import TYPE_CHECKING, Any, List\n+\n+from scrapy.utils.conf import build_component_list\n+from scrapy.utils.misc import create_instance, load_object\n+\n+if TYPE_CHECKING:\n+    from scrapy.crawler import Crawler\n+\n+logger = logging.getLogger(__name__)\n+\n+\n+class AddonManager:",
      "comment": "I wonder if we should make the methods private, at least `add`. No strong opinion, though.",
      "comment_id": 1266533617,
      "user": "Gallaecio",
      "created_at": "2023-07-18T09:52:51Z",
      "url": "https://github.com/scrapy/scrapy/pull/5950#discussion_r1266533617"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 5950,
      "file_path": "scrapy/addons.py",
      "line": 13,
      "side": "RIGHT",
      "diff_hunk": "@@ -0,0 +1,65 @@\n+import logging\n+from typing import TYPE_CHECKING, Any, List\n+\n+from scrapy.utils.conf import build_component_list\n+from scrapy.utils.misc import create_instance, load_object\n+\n+if TYPE_CHECKING:\n+    from scrapy.crawler import Crawler\n+\n+logger = logging.getLogger(__name__)\n+\n+\n+class AddonManager:",
      "comment": "Initially it was public because users were able to add addons in their code (and do other things with them that we no longer have APIs for, like removing, disabling and changing configuration).",
      "comment_id": 1266855963,
      "user": "wRAR",
      "created_at": "2023-07-18T14:24:36Z",
      "url": "https://github.com/scrapy/scrapy/pull/5950#discussion_r1266855963"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 5950,
      "file_path": "scrapy/addons.py",
      "line": 46,
      "side": "RIGHT",
      "diff_hunk": "@@ -0,0 +1,65 @@\n+import logging\n+from typing import TYPE_CHECKING, Any, List\n+\n+from scrapy.utils.conf import build_component_list\n+from scrapy.utils.misc import create_instance, load_object\n+\n+if TYPE_CHECKING:\n+    from scrapy.crawler import Crawler\n+\n+logger = logging.getLogger(__name__)\n+\n+\n+class AddonManager:\n+    \"\"\"This class facilitates loading and storing :ref:`topics-addons`.\"\"\"\n+\n+    def __init__(self, crawler: \"Crawler\") -> None:\n+        self.crawler: \"Crawler\" = crawler\n+        self.addons: List[Any] = []\n+\n+    def add(self, addon: Any) -> None:\n+        \"\"\"Store an add-on.\n+\n+        :param addon: The add-on object (or path) to be stored\n+        :type addon: Python object, class or ``str``\n+\n+        :param config: The add-on configuration dictionary\n+        :type config: ``dict``\n+        \"\"\"\n+        if isinstance(addon, (type, str)):\n+            addon = load_object(addon)\n+        if isinstance(addon, type):\n+            addon = create_instance(addon, settings=None, crawler=self.crawler)\n+        self.addons.append(addon)\n+\n+    def load_settings(self, settings) -> None:\n+        \"\"\"Load add-ons and configurations from settings object.\n+\n+        This will load the addon for every add-on path in the\n+        ``ADDONS`` setting.\n+\n+        :param settings: The :class:`~scrapy.settings.Settings` object from \\\n+            which to read the add-on configuration\n+        :type settings: :class:`~scrapy.settings.Settings`\n+        \"\"\"\n+        paths = build_component_list(settings[\"ADDONS\"])\n+        addons = [load_object(path) for path in paths]",
      "comment": "I don't think it's on purpose, as it was a public API. We can keep just one `load_object()` call.",
      "comment_id": 1266933707,
      "user": "wRAR",
      "created_at": "2023-07-18T15:18:36Z",
      "url": "https://github.com/scrapy/scrapy/pull/5950#discussion_r1266933707"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 5950,
      "file_path": "tests/test_addons.py",
      "line": 45,
      "side": "RIGHT",
      "diff_hunk": "@@ -0,0 +1,62 @@\n+import unittest\n+from typing import Any, Dict, Optional\n+\n+from scrapy.crawler import Crawler\n+from scrapy.settings import BaseSettings\n+from scrapy.utils.test import get_crawler\n+\n+\n+class GoodAddon:\n+    def __init__(self, config: Optional[Dict[str, Any]] = None) -> None:\n+        super().__init__()\n+        self.config = config or {}\n+\n+    def update_settings(self, settings):\n+        settings.update(self.config, \"addon\")\n+\n+\n+class CreateInstanceAddon:\n+    def __init__(self, crawler: Crawler) -> None:\n+        super().__init__()\n+        self.crawler = crawler\n+        self.config = crawler.settings.getdict(\"MYADDON\")\n+\n+    @classmethod\n+    def from_crawler(cls, crawler: Crawler):\n+        return cls(crawler)\n+\n+    def update_settings(self, settings):\n+        settings.update(self.config, \"addon\")\n+\n+\n+class AddonTest(unittest.TestCase):\n+    def test_update_settings(self):\n+        settings = BaseSettings()\n+        settings.set(\"KEY1\", \"default\", priority=\"default\")\n+        settings.set(\"KEY2\", \"project\", priority=\"project\")\n+        addon_config = {\"KEY1\": \"addon\", \"KEY2\": \"addon\", \"KEY3\": \"addon\"}\n+        testaddon = GoodAddon(addon_config)\n+        testaddon.update_settings(settings)\n+        self.assertEqual(settings[\"KEY1\"], \"addon\")\n+        self.assertEqual(settings[\"KEY2\"], \"project\")\n+        self.assertEqual(settings[\"KEY3\"], \"addon\")\n+\n+\n+class AddonManagerTest(unittest.TestCase):",
      "comment": "Could you please add a couple more tests:\r\n\r\n1. Check that addon priority works (i.e. a right addon is used , based on the priority)\r\n2. Check that using addon classes works in settings, not just paths\r\n\r\nSomething else?",
      "comment_id": 1271327355,
      "user": "kmike",
      "created_at": "2023-07-22T18:08:02Z",
      "url": "https://github.com/scrapy/scrapy/pull/5950#discussion_r1271327355"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 5950,
      "file_path": "tests/test_addons.py",
      "line": 10,
      "side": "RIGHT",
      "diff_hunk": "@@ -0,0 +1,62 @@\n+import unittest\n+from typing import Any, Dict, Optional\n+\n+from scrapy.crawler import Crawler\n+from scrapy.settings import BaseSettings\n+from scrapy.utils.test import get_crawler\n+\n+\n+class GoodAddon:\n+    def __init__(self, config: Optional[Dict[str, Any]] = None) -> None:",
      "comment": "I'm not sure, what's the use case? It seems you can't use such addons with a custom config in setting.py, as a class needs to be used, not an instance, right?",
      "comment_id": 1271327456,
      "user": "kmike",
      "created_at": "2023-07-22T18:08:44Z",
      "url": "https://github.com/scrapy/scrapy/pull/5950#discussion_r1271327456"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 5950,
      "file_path": "tests/test_addons.py",
      "line": 45,
      "side": "RIGHT",
      "diff_hunk": "@@ -0,0 +1,62 @@\n+import unittest\n+from typing import Any, Dict, Optional\n+\n+from scrapy.crawler import Crawler\n+from scrapy.settings import BaseSettings\n+from scrapy.utils.test import get_crawler\n+\n+\n+class GoodAddon:\n+    def __init__(self, config: Optional[Dict[str, Any]] = None) -> None:\n+        super().__init__()\n+        self.config = config or {}\n+\n+    def update_settings(self, settings):\n+        settings.update(self.config, \"addon\")\n+\n+\n+class CreateInstanceAddon:\n+    def __init__(self, crawler: Crawler) -> None:\n+        super().__init__()\n+        self.crawler = crawler\n+        self.config = crawler.settings.getdict(\"MYADDON\")\n+\n+    @classmethod\n+    def from_crawler(cls, crawler: Crawler):\n+        return cls(crawler)\n+\n+    def update_settings(self, settings):\n+        settings.update(self.config, \"addon\")\n+\n+\n+class AddonTest(unittest.TestCase):\n+    def test_update_settings(self):\n+        settings = BaseSettings()\n+        settings.set(\"KEY1\", \"default\", priority=\"default\")\n+        settings.set(\"KEY2\", \"project\", priority=\"project\")\n+        addon_config = {\"KEY1\": \"addon\", \"KEY2\": \"addon\", \"KEY3\": \"addon\"}\n+        testaddon = GoodAddon(addon_config)\n+        testaddon.update_settings(settings)\n+        self.assertEqual(settings[\"KEY1\"], \"addon\")\n+        self.assertEqual(settings[\"KEY2\"], \"project\")\n+        self.assertEqual(settings[\"KEY3\"], \"addon\")\n+\n+\n+class AddonManagerTest(unittest.TestCase):",
      "comment": "I think we should also add tests for the suggestions we make in the documentation, e.g. using \"addon\" priority and they way it interacts with other settings; an addon which reads the default setting and uses a fallback implementation.",
      "comment_id": 1271327623,
      "user": "kmike",
      "created_at": "2023-07-22T18:10:13Z",
      "url": "https://github.com/scrapy/scrapy/pull/5950#discussion_r1271327623"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 5950,
      "file_path": "tests/test_addons.py",
      "line": 10,
      "side": "RIGHT",
      "diff_hunk": "@@ -0,0 +1,62 @@\n+import unittest\n+from typing import Any, Dict, Optional\n+\n+from scrapy.crawler import Crawler\n+from scrapy.settings import BaseSettings\n+from scrapy.utils.test import get_crawler\n+\n+\n+class GoodAddon:\n+    def __init__(self, config: Optional[Dict[str, Any]] = None) -> None:",
      "comment": "It looked good to me on my latest pass. Though I guess the `AddonTest` below only really tests BaseSettings.update, so maybe it is not that useful.",
      "comment_id": 1271917540,
      "user": "Gallaecio",
      "created_at": "2023-07-24T08:26:26Z",
      "url": "https://github.com/scrapy/scrapy/pull/5950#discussion_r1271917540"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 5950,
      "file_path": "tests/test_addons.py",
      "line": 10,
      "side": "RIGHT",
      "diff_hunk": "@@ -0,0 +1,62 @@\n+import unittest\n+from typing import Any, Dict, Optional\n+\n+from scrapy.crawler import Crawler\n+from scrapy.settings import BaseSettings\n+from scrapy.utils.test import get_crawler\n+\n+\n+class GoodAddon:\n+    def __init__(self, config: Optional[Dict[str, Any]] = None) -> None:",
      "comment": "I think that users shouldn't be defining addons with `__init__` arguments, unless the addon has a from_crawler method which passes these arguments to `__init__`.",
      "comment_id": 1272019109,
      "user": "kmike",
      "created_at": "2023-07-24T09:51:41Z",
      "url": "https://github.com/scrapy/scrapy/pull/5950#discussion_r1272019109"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 5950,
      "file_path": "tests/test_addons.py",
      "line": 10,
      "side": "RIGHT",
      "diff_hunk": "@@ -0,0 +1,62 @@\n+import unittest\n+from typing import Any, Dict, Optional\n+\n+from scrapy.crawler import Crawler\n+from scrapy.settings import BaseSettings\n+from scrapy.utils.test import get_crawler\n+\n+\n+class GoodAddon:\n+    def __init__(self, config: Optional[Dict[str, Any]] = None) -> None:",
      "comment": "I don\u2019t think it was meant as an example of a real use case, but as a shortcut for a clean test later on.",
      "comment_id": 1272164636,
      "user": "Gallaecio",
      "created_at": "2023-07-24T11:57:42Z",
      "url": "https://github.com/scrapy/scrapy/pull/5950#discussion_r1272164636"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 5950,
      "file_path": "tests/test_addons.py",
      "line": 10,
      "side": "RIGHT",
      "diff_hunk": "@@ -0,0 +1,62 @@\n+import unittest\n+from typing import Any, Dict, Optional\n+\n+from scrapy.crawler import Crawler\n+from scrapy.settings import BaseSettings\n+from scrapy.utils.test import get_crawler\n+\n+\n+class GoodAddon:\n+    def __init__(self, config: Optional[Dict[str, Any]] = None) -> None:",
      "comment": "It's just a remnant of old paradigm and it's handy to be able to use the same class with different settings, I guess I can rewrite it to a factory.",
      "comment_id": 1272530950,
      "user": "wRAR",
      "created_at": "2023-07-24T17:06:44Z",
      "url": "https://github.com/scrapy/scrapy/pull/5950#discussion_r1272530950"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 5950,
      "file_path": "scrapy/addons.py",
      "line": 44,
      "side": "RIGHT",
      "diff_hunk": "@@ -41,13 +29,29 @@ def load_settings(self, settings: Settings) -> None:\n             which to read the add-on configuration\n         :type settings: :class:`~scrapy.settings.Settings`\n         \"\"\"\n-        addons = build_component_list(settings[\"ADDONS\"])\n-        for addon in build_component_list(settings[\"ADDONS\"]):\n-            self._add(addon, settings)\n+        enabled = []\n+        for clspath in build_component_list(settings[\"ADDONS\"]):\n+            try:\n+                addoncls = load_object(clspath)\n+                addon = create_instance(\n+                    addoncls, settings=settings, crawler=self.crawler\n+                )\n+                addon.update_settings(settings)\n+                self.addons.append(addon)\n+            except NotConfigured as e:\n+                if e.args:\n+                    clsname = (\n+                        clspath.split(\".\")[-1] if isinstance(clspath, str) else clspath",
      "comment": "I.e. wouldn't it be easier to debug issues if the full path is present? ",
      "comment_id": 1280633350,
      "user": "kmike",
      "created_at": "2023-08-01T13:19:29Z",
      "url": "https://github.com/scrapy/scrapy/pull/5950#discussion_r1280633350"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 5950,
      "file_path": "scrapy/addons.py",
      "line": 44,
      "side": "RIGHT",
      "diff_hunk": "@@ -41,13 +29,29 @@ def load_settings(self, settings: Settings) -> None:\n             which to read the add-on configuration\n         :type settings: :class:`~scrapy.settings.Settings`\n         \"\"\"\n-        addons = build_component_list(settings[\"ADDONS\"])\n-        for addon in build_component_list(settings[\"ADDONS\"]):\n-            self._add(addon, settings)\n+        enabled = []\n+        for clspath in build_component_list(settings[\"ADDONS\"]):\n+            try:\n+                addoncls = load_object(clspath)\n+                addon = create_instance(\n+                    addoncls, settings=settings, crawler=self.crawler\n+                )\n+                addon.update_settings(settings)\n+                self.addons.append(addon)\n+            except NotConfigured as e:\n+                if e.args:\n+                    clsname = (\n+                        clspath.split(\".\")[-1] if isinstance(clspath, str) else clspath",
      "comment": "It's copied from https://github.com/scrapy/scrapy/blob/bddbbc522aef00dc150e479e6288041cee2e95c9/scrapy/middleware.py#L49 ",
      "comment_id": 1280640364,
      "user": "wRAR",
      "created_at": "2023-08-01T13:24:04Z",
      "url": "https://github.com/scrapy/scrapy/pull/5950#discussion_r1280640364"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 5950,
      "file_path": "scrapy/addons.py",
      "line": 44,
      "side": "RIGHT",
      "diff_hunk": "@@ -41,13 +29,29 @@ def load_settings(self, settings: Settings) -> None:\n             which to read the add-on configuration\n         :type settings: :class:`~scrapy.settings.Settings`\n         \"\"\"\n-        addons = build_component_list(settings[\"ADDONS\"])\n-        for addon in build_component_list(settings[\"ADDONS\"]):\n-            self._add(addon, settings)\n+        enabled = []\n+        for clspath in build_component_list(settings[\"ADDONS\"]):\n+            try:\n+                addoncls = load_object(clspath)\n+                addon = create_instance(\n+                    addoncls, settings=settings, crawler=self.crawler\n+                )\n+                addon.update_settings(settings)\n+                self.addons.append(addon)\n+            except NotConfigured as e:\n+                if e.args:\n+                    clsname = (\n+                        clspath.split(\".\")[-1] if isinstance(clspath, str) else clspath",
      "comment": "I see.. As you also noticed, the code there is wrong, as it doesn't handle instances (like you do here).\r\n\r\nI prefer to log the full path, because there could be e.g. my_project.middlewares.RobotsTxtMiddleware which is a subclass of scrapy's RobotsTxtMiddleware, so if you just log \"RobotsTxtMiddleware\", it can be confusing. I think we went in a similar direction with logging; previously we preferred short logger names like [scrapy], but now in logs we usually use full path to the logger, to make debugging easier.\r\n\r\nIf you agree with this direction, we have 3 options:\r\n\r\n1. Change both MiddlewareManager and addons, to have the desired behavior and consistency\r\n2. Use full path here, and keep MiddlewareManager as-is, to not make unrelated changes in the PR; address MiddlewareManager issues separately\r\n3. Follow the same approach as in MiddlewareManager, and address both separately (though it's not really the same, as here you have a fix which MiddlewareManager doesn't)\r\n\r\nWhat do you think? cc @Gallaecio ",
      "comment_id": 1280669204,
      "user": "kmike",
      "created_at": "2023-08-01T13:43:54Z",
      "url": "https://github.com/scrapy/scrapy/pull/5950#discussion_r1280669204"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 5950,
      "file_path": "scrapy/addons.py",
      "line": 44,
      "side": "RIGHT",
      "diff_hunk": "@@ -41,13 +29,29 @@ def load_settings(self, settings: Settings) -> None:\n             which to read the add-on configuration\n         :type settings: :class:`~scrapy.settings.Settings`\n         \"\"\"\n-        addons = build_component_list(settings[\"ADDONS\"])\n-        for addon in build_component_list(settings[\"ADDONS\"]):\n-            self._add(addon, settings)\n+        enabled = []\n+        for clspath in build_component_list(settings[\"ADDONS\"]):\n+            try:\n+                addoncls = load_object(clspath)\n+                addon = create_instance(\n+                    addoncls, settings=settings, crawler=self.crawler\n+                )\n+                addon.update_settings(settings)\n+                self.addons.append(addon)\n+            except NotConfigured as e:\n+                if e.args:\n+                    clsname = (\n+                        clspath.split(\".\")[-1] if isinstance(clspath, str) else clspath",
      "comment": "No strong opinion. 1 sounds great, if it is not too bothersome. Otherwise, 2 makes sense. 3 is more consistent than 2, but I don\u2019t think that matters that much here.",
      "comment_id": 1280691665,
      "user": "Gallaecio",
      "created_at": "2023-08-01T13:59:29Z",
      "url": "https://github.com/scrapy/scrapy/pull/5950#discussion_r1280691665"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 5979,
      "file_path": "scrapy/extensions/closespider.py",
      "line": 105,
      "side": "RIGHT",
      "diff_hunk": "@@ -69,3 +82,31 @@ def spider_closed(self, spider):\n         task = getattr(self, \"task\", False)\n         if task and task.active():\n             task.cancel()\n+\n+        task_no_item = getattr(self, \"task_no_item\", False)\n+        if task_no_item and task_no_item.running:\n+            task_no_item.stop()\n+\n+    def spider_opened_no_item(self, spider):\n+        from twisted.internet import task\n+\n+        self.task_no_item = task.LoopingCall(self._count_items_produced, spider)\n+        self.task_no_item.start(self.timeout_no_item, now=False)\n+\n+        logger.info(\n+            f\"Spider will stop when no items are produced after \"\n+            f\"{self.timeout_no_item} seconds.\"\n+        )\n+\n+    def item_scraped_no_item(self, item, spider):\n+        self.items_in_period += 1\n+\n+    def _count_items_produced(self, spider):\n+        if self.items_in_period >= 1:",
      "comment": "I initially thought of exposing this but I think it's better to keep it simple for now. Users can opt to override this method anyway if they need a customized condition of when to close the spider.",
      "comment_id": 1266750193,
      "user": "BurnzZ",
      "created_at": "2023-07-18T13:08:31Z",
      "url": "https://github.com/scrapy/scrapy/pull/5979#discussion_r1266750193"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 5980,
      "file_path": "scrapy/extensions/feedexport.py",
      "line": 172,
      "side": "RIGHT",
      "diff_hunk": "@@ -169,6 +169,7 @@ def __init__(\n         secret_key=None,\n         acl=None,\n         endpoint_url=None,\n+        region_name=None,\n         *,",
      "comment": "Addressed in https://github.com/scrapy/scrapy/pull/5980/commits/e39fe1c9ef546b820317dbc275c730bbf4b8324f",
      "comment_id": 1271752536,
      "user": "BurnzZ",
      "created_at": "2023-07-24T05:09:00Z",
      "url": "https://github.com/scrapy/scrapy/pull/5980#discussion_r1271752536"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 5952,
      "file_path": "scrapy/exporters.py",
      "line": 157,
      "side": "RIGHT",
      "diff_hunk": "@@ -142,14 +149,15 @@ def finish_exporting(self):\n         self.file.write(b\"]\")\n \n     def export_item(self, item):\n-        if self.first_item:\n-            self.first_item = False\n-        else:\n-            self.file.write(b\",\")\n-            self._beautify_newline()\n-        itemdict = dict(self._get_serialized_fields(item))\n-        data = self.encoder.encode(itemdict)\n-        self.file.write(to_bytes(data, self.encoding))\n+        # catch exception and don't add empty item for export\n+        try:\n+            itemdict = dict(self._get_serialized_fields(item))\n+            data = to_bytes(self.encoder.encode(itemdict), self.encoding)\n+        except TypeError as e:\n+            raise e",
      "comment": "I don't think this catch+reraise does anything (except breaking the traceback IIRC)?",
      "comment_id": 1259764432,
      "user": "wRAR",
      "created_at": "2023-07-11T13:46:18Z",
      "url": "https://github.com/scrapy/scrapy/pull/5952#discussion_r1259764432"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 5952,
      "file_path": "scrapy/exporters.py",
      "line": 157,
      "side": "RIGHT",
      "diff_hunk": "@@ -142,14 +149,15 @@ def finish_exporting(self):\n         self.file.write(b\"]\")\n \n     def export_item(self, item):\n-        if self.first_item:\n-            self.first_item = False\n-        else:\n-            self.file.write(b\",\")\n-            self._beautify_newline()\n-        itemdict = dict(self._get_serialized_fields(item))\n-        data = self.encoder.encode(itemdict)\n-        self.file.write(to_bytes(data, self.encoding))\n+        # catch exception and don't add empty item for export\n+        try:\n+            itemdict = dict(self._get_serialized_fields(item))\n+            data = to_bytes(self.encoder.encode(itemdict), self.encoding)\n+        except TypeError as e:\n+            raise e",
      "comment": "@wRAR  thanks for your comment. \r\n\r\nActually, [this](https://github.com/scrapy/scrapy/pull/5952/commits/0bd481de7cec4540aad8b9cfae896519fd9b2016#diff-b4b7b51f903343e1ac43a4655e42263010d0631f9d1702eb5058cbd5d5402d47R608) test expect the TypeError. Do you've something better in your mind for its replacement?.",
      "comment_id": 1260159774,
      "user": "adnan-awan",
      "created_at": "2023-07-11T19:02:36Z",
      "url": "https://github.com/scrapy/scrapy/pull/5952#discussion_r1260159774"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 5952,
      "file_path": "scrapy/exporters.py",
      "line": 157,
      "side": "RIGHT",
      "diff_hunk": "@@ -142,14 +149,15 @@ def finish_exporting(self):\n         self.file.write(b\"]\")\n \n     def export_item(self, item):\n-        if self.first_item:\n-            self.first_item = False\n-        else:\n-            self.file.write(b\",\")\n-            self._beautify_newline()\n-        itemdict = dict(self._get_serialized_fields(item))\n-        data = self.encoder.encode(itemdict)\n-        self.file.write(to_bytes(data, self.encoding))\n+        # catch exception and don't add empty item for export\n+        try:\n+            itemdict = dict(self._get_serialized_fields(item))\n+            data = to_bytes(self.encoder.encode(itemdict), self.encoding)\n+        except TypeError as e:\n+            raise e",
      "comment": "But as this code does nothing then removing it won't break the test.",
      "comment_id": 1260184819,
      "user": "wRAR",
      "created_at": "2023-07-11T19:29:51Z",
      "url": "https://github.com/scrapy/scrapy/pull/5952#discussion_r1260184819"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 5971,
      "file_path": "scrapy/extensions/feedexport.py",
      "line": 594,
      "side": "RIGHT",
      "diff_hunk": "@@ -591,7 +591,7 @@ def _settings_are_valid(self):\n \n     def _storage_supported(self, uri, feed_options):\n         scheme = urlparse(uri).scheme\n-        if scheme in self.storages:\n+        if scheme in self.storages or PureWindowsPath(uri).drive:",
      "comment": "```\r\n>>> from urllib.parse import urlparse\r\n>>> urlparse(\"C:\\Scrapy\\output.json\").scheme\r\n'c'\r\n```\r\nHad to add this condition because `scheme` value for windows absolut paths is misleading. By using `PureWindowsPath` we can look for drive letter if exists it means is a windows absolute path.",
      "comment_id": 1259142730,
      "user": "Laerte",
      "created_at": "2023-07-11T03:52:08Z",
      "url": "https://github.com/scrapy/scrapy/pull/5971#discussion_r1259142730"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 5971,
      "file_path": "scrapy/extensions/feedexport.py",
      "line": 620,
      "side": "RIGHT",
      "diff_hunk": "@@ -617,7 +617,7 @@ def _get_storage(self, uri, feed_options):\n         It supports not passing the *feed_options* parameters to classes that\n         do not support it, and issuing a deprecation warning instead.\n         \"\"\"\n-        feedcls = self.storages[urlparse(uri).scheme]\n+        feedcls = self.storages.get(urlparse(uri).scheme) or self.storages[\"file\"]",
      "comment": "```suggestion\r\n        feedcls = self.storages.get(urlparse(uri).scheme, self.storages[\"file\"])\r\n```\r\n\r\n(assuming it works that way)",
      "comment_id": 1263893339,
      "user": "wRAR",
      "created_at": "2023-07-14T15:58:54Z",
      "url": "https://github.com/scrapy/scrapy/pull/5971#discussion_r1263893339"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 5971,
      "file_path": "scrapy/extensions/feedexport.py",
      "line": 620,
      "side": "RIGHT",
      "diff_hunk": "@@ -617,7 +617,7 @@ def _get_storage(self, uri, feed_options):\n         It supports not passing the *feed_options* parameters to classes that\n         do not support it, and issuing a deprecation warning instead.\n         \"\"\"\n-        feedcls = self.storages[urlparse(uri).scheme]\n+        feedcls = self.storages.get(urlparse(uri).scheme) or self.storages[\"file\"]",
      "comment": "I was wondering because i tried this before now i understand why did not work \ud83e\udd21 \r\n\r\n![image](https://github.com/scrapy/scrapy/assets/5853172/2b2f97e3-5905-4c00-9c8a-6bc00388efee)\r\n\r\nThanks @wRAR ",
      "comment_id": 1263902460,
      "user": "Laerte",
      "created_at": "2023-07-14T16:08:43Z",
      "url": "https://github.com/scrapy/scrapy/pull/5971#discussion_r1263902460"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 5847,
      "file_path": "scrapy/settings/default_settings.py",
      "line": 144,
      "side": "RIGHT",
      "diff_hunk": "@@ -141,7 +141,7 @@\n FEED_TEMPDIR = None\n FEEDS = {}\n FEED_URI_PARAMS = None  # a function to extend uri arguments\n-FEED_STORE_EMPTY = False\n+FEED_STORE_EMPTY = True",
      "comment": "We need to update [the docs](https://github.com/scrapy/scrapy/blob/d60b4edd11436e61284615ec7ce89f8ac7e46d9a/docs/topics/feed-exports.rst?plain=1#L555) accordingly.",
      "comment_id": 1137406774,
      "user": "Gallaecio",
      "created_at": "2023-03-15T16:30:32Z",
      "url": "https://github.com/scrapy/scrapy/pull/5847#discussion_r1137406774"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 5847,
      "file_path": "scrapy/settings/default_settings.py",
      "line": 144,
      "side": "RIGHT",
      "diff_hunk": "@@ -141,7 +141,7 @@\n FEED_TEMPDIR = None\n FEEDS = {}\n FEED_URI_PARAMS = None  # a function to extend uri arguments\n-FEED_STORE_EMPTY = False\n+FEED_STORE_EMPTY = True",
      "comment": "I forgot about that.\r\nOther than changing the default values, do I need to make any additions to the documentation with this modification? For example, mentioning that files are not exported explicitly, etc.\r\n",
      "comment_id": 1137826248,
      "user": "namelessGonbai",
      "created_at": "2023-03-15T22:11:30Z",
      "url": "https://github.com/scrapy/scrapy/pull/5847#discussion_r1137826248"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 5847,
      "file_path": "scrapy/settings/default_settings.py",
      "line": 144,
      "side": "RIGHT",
      "diff_hunk": "@@ -141,7 +141,7 @@\n FEED_TEMPDIR = None\n FEEDS = {}\n FEED_URI_PARAMS = None  # a function to extend uri arguments\n-FEED_STORE_EMPTY = False\n+FEED_STORE_EMPTY = True",
      "comment": "To mention that files are not exported may be a good thing, yes.\r\n\r\nI don\u2019t think we need anything else, though. We will need to justify this default value change, explain the reasons behind it, in the release notes, but we usually handle release notes entries when preparing the release, so you do not need to worry about that part here.",
      "comment_id": 1138214724,
      "user": "Gallaecio",
      "created_at": "2023-03-16T07:15:06Z",
      "url": "https://github.com/scrapy/scrapy/pull/5847#discussion_r1138214724"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 5847,
      "file_path": "scrapy/extensions/feedexport.py",
      "line": 281,
      "side": "LEFT",
      "diff_hunk": "@@ -277,18 +277,21 @@ def _store_in_thread(self, file):\n class FeedSlot:\n     def __init__(\n         self,\n-        file,\n-        exporter,",
      "comment": "This now changes a public class, as we made FeedSlot public recently. @kmike @Gallaecio thoughts?",
      "comment_id": 1228223964,
      "user": "wRAR",
      "created_at": "2023-06-13T14:28:14Z",
      "url": "https://github.com/scrapy/scrapy/pull/5847#discussion_r1228223964"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 5847,
      "file_path": "scrapy/extensions/feedexport.py",
      "line": 445,
      "side": "RIGHT",
      "diff_hunk": "@@ -406,11 +438,16 @@ def get_file(slot_):\n                 return slot_.file.file\n             return slot_.file\n \n-        slot.finish_exporting()\n-        if not slot.itemcount and not slot.store_empty:\n-            # We need to call slot.storage.store nonetheless to get the file\n-            # properly closed.\n-            return defer.maybeDeferred(slot.storage.store, get_file(slot))\n+        if slot.itemcount:\n+            # Nomal case\n+            slot.finish_exporting()\n+        elif slot.store_empty and slot.batch_id == 1:\n+            # Need Store Empty",
      "comment": "```suggestion\r\n            # Need to store the empty file\r\n```",
      "comment_id": 1228227955,
      "user": "wRAR",
      "created_at": "2023-06-13T14:30:57Z",
      "url": "https://github.com/scrapy/scrapy/pull/5847#discussion_r1228227955"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 5847,
      "file_path": "scrapy/extensions/feedexport.py",
      "line": 281,
      "side": "LEFT",
      "diff_hunk": "@@ -277,18 +277,21 @@ def _store_in_thread(self, file):\n class FeedSlot:\n     def __init__(\n         self,\n-        file,\n-        exporter,",
      "comment": "The only backward-compatible option I can think of at the moment is to keep the current class unchanged, deprecate it, and create a new class with the new API with a new class name (`BatchSlot`?).",
      "comment_id": 1228408848,
      "user": "Gallaecio",
      "created_at": "2023-06-13T16:29:09Z",
      "url": "https://github.com/scrapy/scrapy/pull/5847#discussion_r1228408848"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 5847,
      "file_path": "scrapy/extensions/feedexport.py",
      "line": 281,
      "side": "LEFT",
      "diff_hunk": "@@ -277,18 +277,21 @@ def _store_in_thread(self, file):\n class FeedSlot:\n     def __init__(\n         self,\n-        file,\n-        exporter,",
      "comment": "We decided that as this only changes the `__init__` signature and the current usage of this class is to receive it in the `feed_slot_closed` signal handler, it's fine to just change this.",
      "comment_id": 1238688165,
      "user": "wRAR",
      "created_at": "2023-06-22T15:20:10Z",
      "url": "https://github.com/scrapy/scrapy/pull/5847#discussion_r1238688165"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 5965,
      "file_path": "scrapy/utils/project.py",
      "line": 16,
      "side": "RIGHT",
      "diff_hunk": "@@ -12,8 +12,8 @@\n \n \n def inside_project():\n-    scrapy_module = os.environ.get(\"SCRAPY_SETTINGS_MODULE\")\n-    if scrapy_module is not None:\n+    scrapy_module = os.environ.get(ENVVAR)\n+    if scrapy_module:",
      "comment": "This is a change in behavior when the `SCRAPY_SETTINGS_MODULE` is set to an empty string. That said, an empty string cannot work here, so I guess it is fine and slightly improves readability, so +1 from me.",
      "comment_id": 1252730312,
      "user": "Gallaecio",
      "created_at": "2023-07-05T08:15:45Z",
      "url": "https://github.com/scrapy/scrapy/pull/5965#discussion_r1252730312"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 5925,
      "file_path": "scrapy/utils/deprecate.py",
      "line": 150,
      "side": "RIGHT",
      "diff_hunk": "@@ -134,7 +137,17 @@ def _clspath(cls, forced=None):\n DEPRECATION_RULES: List[Tuple[str, str]] = []\n \n \n-def update_classpath(path):\n+@overload\n+def update_classpath(path: str) -> str:\n+    ...\n+\n+\n+@overload\n+def update_classpath(path: Any) -> Any:\n+    ...\n+\n+\n+def update_classpath(path: Any) -> Any:",
      "comment": "Based on [the example on the docs](https://docs.python.org/3.7/library/typing.html#typing.overload), there should be no type hints here. Does mypy complain?\r\n\r\n```suggestion\r\ndef update_classpath(path):\r\n```",
      "comment_id": 1189853901,
      "user": "Gallaecio",
      "created_at": "2023-05-10T12:42:38Z",
      "url": "https://github.com/scrapy/scrapy/pull/5925#discussion_r1189853901"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 5925,
      "file_path": "scrapy/utils/deprecate.py",
      "line": 150,
      "side": "RIGHT",
      "diff_hunk": "@@ -134,7 +137,17 @@ def _clspath(cls, forced=None):\n DEPRECATION_RULES: List[Tuple[str, str]] = []\n \n \n-def update_classpath(path):\n+@overload\n+def update_classpath(path: str) -> str:\n+    ...\n+\n+\n+@overload\n+def update_classpath(path: Any) -> Any:\n+    ...\n+\n+\n+def update_classpath(path: Any) -> Any:",
      "comment": "If there is no type hints on the actual function, its body won't be checked (at least without `--check-untyped-defs`).",
      "comment_id": 1189883498,
      "user": "wRAR",
      "created_at": "2023-05-10T13:05:53Z",
      "url": "https://github.com/scrapy/scrapy/pull/5925#discussion_r1189883498"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 5925,
      "file_path": "scrapy/utils/gz.py",
      "line": 27,
      "side": "RIGHT",
      "diff_hunk": "@@ -18,17 +21,12 @@ def gunzip(data):\n         except (IOError, EOFError, struct.error):\n             # complete only if there is some data, otherwise re-raise\n             # see issue 87 about catching struct.error\n-            # some pages are quite small so output_list is empty and f.extrabuf\n-            # contains the whole page content\n-            if output_list or getattr(f, \"extrabuf\", None):\n-                try:\n-                    output_list.append(f.extrabuf[-f.extrasize :])\n-                finally:\n-                    break\n-            else:\n-                raise\n+            # some pages are quite small so output_list is empty\n+            if output_list:\n+                break\n+            raise",
      "comment": "Right, I was going to do that but forgot.\r\n\r\n`extrabuf` and `extrasize` were removed in 3.5 when the underlying logic was rewritten, they were never documented as far as I can see. Looks like this code was intended to salvage a partially decompressed chunk when possible, and now it's probably just not possible. The main purpose of this function though is to salvage previous completely decompressed chunks and it still does that, and tests in https://github.com/scrapy/scrapy/blob/master/tests/test_utils_gz.py only test that, as far as I can see.",
      "comment_id": 1189887837,
      "user": "wRAR",
      "created_at": "2023-05-10T13:09:11Z",
      "url": "https://github.com/scrapy/scrapy/pull/5925#discussion_r1189887837"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 5925,
      "file_path": "scrapy/utils/gz.py",
      "line": 27,
      "side": "RIGHT",
      "diff_hunk": "@@ -18,17 +21,12 @@ def gunzip(data):\n         except (IOError, EOFError, struct.error):\n             # complete only if there is some data, otherwise re-raise\n             # see issue 87 about catching struct.error\n-            # some pages are quite small so output_list is empty and f.extrabuf\n-            # contains the whole page content\n-            if output_list or getattr(f, \"extrabuf\", None):\n-                try:\n-                    output_list.append(f.extrabuf[-f.extrasize :])\n-                finally:\n-                    break\n-            else:\n-                raise\n+            # some pages are quite small so output_list is empty\n+            if output_list:\n+                break\n+            raise",
      "comment": "OTOH `test_gunzip_truncated_short` looks like it should be testing the removed case. I'll recheck it.",
      "comment_id": 1189889351,
      "user": "wRAR",
      "created_at": "2023-05-10T13:10:21Z",
      "url": "https://github.com/scrapy/scrapy/pull/5925#discussion_r1189889351"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 5925,
      "file_path": "scrapy/utils/gz.py",
      "line": 27,
      "side": "RIGHT",
      "diff_hunk": "@@ -18,17 +21,12 @@ def gunzip(data):\n         except (IOError, EOFError, struct.error):\n             # complete only if there is some data, otherwise re-raise\n             # see issue 87 about catching struct.error\n-            # some pages are quite small so output_list is empty and f.extrabuf\n-            # contains the whole page content\n-            if output_list or getattr(f, \"extrabuf\", None):\n-                try:\n-                    output_list.append(f.extrabuf[-f.extrasize :])\n-                finally:\n-                    break\n-            else:\n-                raise\n+            # some pages are quite small so output_list is empty\n+            if output_list:\n+                break\n+            raise",
      "comment": "For the file in that test the first read1 call returns the data we expect. I'm not going to dive further into GzipFile implementations, it's possible that it's just more robust than before 3.5, I'm fine that the tests return the expected data with the code we have.",
      "comment_id": 1240831542,
      "user": "wRAR",
      "created_at": "2023-06-24T14:47:49Z",
      "url": "https://github.com/scrapy/scrapy/pull/5925#discussion_r1240831542"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 4716,
      "file_path": "scrapy/pipelines/__init__.py",
      "line": 21,
      "side": "RIGHT",
      "diff_hunk": "@@ -18,7 +18,7 @@ def _get_mwlist_from_settings(cls, settings):\n         return build_component_list(settings.getwithbase('ITEM_PIPELINES'))\n \n     def _add_middleware(self, pipe):\n-        super(ItemPipelineManager, self)._add_middleware(pipe)\n+        super()._add_middleware(pipe)",
      "comment": "I missed this in this PR: https://github.com/scrapy/scrapy/pull/4707",
      "comment_id": 466435255,
      "user": "noviluni",
      "created_at": "2020-08-06T14:02:11Z",
      "url": "https://github.com/scrapy/scrapy/pull/4716#discussion_r466435255"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 4716,
      "file_path": "tests/test_downloadermiddleware.py",
      "line": 74,
      "side": "RIGHT",
      "diff_hunk": "@@ -71,7 +71,7 @@ def test_3xx_and_invalid_gzipped_body_must_redirect(self):\n         In particular when some website returns a 30x response with header\n         'Content-Encoding: gzip' giving as result the error below:\n \n-            exceptions.IOError: Not a gzipped file\n+            BadGzipFile: Not a gzipped file (...)",
      "comment": "To reproduce it, you can do:\r\n\r\n```python\r\nimport gzip\r\nimport io\r\n\r\nbuff = io.BytesIO(b'aaaa') \r\nbuff.seek(0) \r\ngz = gzip.GzipFile(fileobj=buff) \r\ngz.read()  ",
      "comment_id": 466436261,
      "user": "noviluni",
      "created_at": "2020-08-06T14:03:42Z",
      "url": "https://github.com/scrapy/scrapy/pull/4716#discussion_r466436261"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 4716,
      "file_path": "scrapy/downloadermiddlewares/retry.py",
      "line": 36,
      "side": "RIGHT",
      "diff_hunk": "@@ -33,12 +33,12 @@\n \n class RetryMiddleware:\n \n-    # IOError is raised by the HttpCompression middleware when trying to\n+    # OSError is raised by the HttpCompression middleware when trying to",
      "comment": "Do you think we should remove this comment or keep it?",
      "comment_id": 466437311,
      "user": "noviluni",
      "created_at": "2020-08-06T14:05:10Z",
      "url": "https://github.com/scrapy/scrapy/pull/4716#discussion_r466437311"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 4716,
      "file_path": "scrapy/downloadermiddlewares/retry.py",
      "line": 36,
      "side": "RIGHT",
      "diff_hunk": "@@ -33,12 +33,12 @@\n \n class RetryMiddleware:\n \n-    # IOError is raised by the HttpCompression middleware when trying to\n+    # OSError is raised by the HttpCompression middleware when trying to",
      "comment": "I think leaving the comment makes sense. I think it\u2019s the only exception with a comment because it is the only exception for which it is not obvious why it belongs in `EXCEPTIONS_TO_RETRY`.\r\n\r\nI do wonder if there\u2019s any potential for backward incompatibility here, and whether we can address it or we can only document it. The best I can think of is a subclass which rewrites the tuple to remove `IOError` and leave all other exceptions, which could be implemented in a way that would fail to remove `OSError`, but I do not know how we could address that. ",
      "comment_id": 467819980,
      "user": "Gallaecio",
      "created_at": "2020-08-10T10:40:38Z",
      "url": "https://github.com/scrapy/scrapy/pull/4716#discussion_r467819980"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 4716,
      "file_path": "tests/test_downloadermiddleware.py",
      "line": 74,
      "side": "RIGHT",
      "diff_hunk": "@@ -71,7 +71,7 @@ def test_3xx_and_invalid_gzipped_body_must_redirect(self):\n         In particular when some website returns a 30x response with header\n         'Content-Encoding: gzip' giving as result the error below:\n \n-            exceptions.IOError: Not a gzipped file\n+            BadGzipFile: Not a gzipped file (...)",
      "comment": "Maybe the test should assert that `BadGzipFile` is raised, then?\r\n\r\nIt may make sense to add a comment which links this to the redirect middleware `EXCEPTIONS_TO_RETRY` attribute, and test that `BadGzipFile` is a subclass of `OSError`, just in case that changes in some future Python version, and we need to update `EXCEPTIONS_TO_RETRY` accordingly.",
      "comment_id": 467825237,
      "user": "Gallaecio",
      "created_at": "2020-08-10T10:52:38Z",
      "url": "https://github.com/scrapy/scrapy/pull/4716#discussion_r467825237"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 4716,
      "file_path": "tests/test_downloadermiddleware.py",
      "line": 74,
      "side": "RIGHT",
      "diff_hunk": "@@ -71,7 +71,7 @@ def test_3xx_and_invalid_gzipped_body_must_redirect(self):\n         In particular when some website returns a 30x response with header\n         'Content-Encoding: gzip' giving as result the error below:\n \n-            exceptions.IOError: Not a gzipped file\n+            BadGzipFile: Not a gzipped file (...)",
      "comment": "Well, this test actually tests that the default middleware order prevents the httpcompression middleware from seeing this response.\r\n\r\nNot sure if we have a test that a similar 200 response is handled by retrying via the httpcompression and retry middlewares working together.",
      "comment_id": 1237378949,
      "user": "wRAR",
      "created_at": "2023-06-21T17:53:21Z",
      "url": "https://github.com/scrapy/scrapy/pull/4716#discussion_r1237378949"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 4716,
      "file_path": "tests/test_downloadermiddleware.py",
      "line": 74,
      "side": "RIGHT",
      "diff_hunk": "@@ -71,7 +71,7 @@ def test_3xx_and_invalid_gzipped_body_must_redirect(self):\n         In particular when some website returns a 30x response with header\n         'Content-Encoding: gzip' giving as result the error below:\n \n-            exceptions.IOError: Not a gzipped file\n+            BadGzipFile: Not a gzipped file (...)",
      "comment": "`test_200_and_invalid_gzipped_body_must_fail` (which is the next test here) handles the second case, and while the code raises `BadGzipFile` the tests expects `IOError` so I think we have everything we need, except maybe better comments.",
      "comment_id": 1237382142,
      "user": "wRAR",
      "created_at": "2023-06-21T17:56:39Z",
      "url": "https://github.com/scrapy/scrapy/pull/4716#discussion_r1237382142"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 5705,
      "file_path": "scrapy/exporters.py",
      "line": 254,
      "side": "RIGHT",
      "diff_hunk": "@@ -247,6 +247,12 @@ def export_item(self, item):\n         values = list(self._build_row(x for _, x in fields))\n         self.csv_writer.writerow(values)\n \n+    def finish_exporting(self):\n+        # Detaching stream in order to avoid file closing.\n+        # The file will be closed with slot.storage.store\n+        # https://github.com/scrapy/scrapy/issues/5043\n+        self.stream.detach()",
      "comment": "Does this need to happen on finish exporting, or can it happen on `__init__`, right after initializing `self.stream`?",
      "comment_id": 1015112147,
      "user": "Gallaecio",
      "created_at": "2022-11-07T08:13:05Z",
      "url": "https://github.com/scrapy/scrapy/pull/5705#discussion_r1015112147"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 5705,
      "file_path": "scrapy/exporters.py",
      "line": 254,
      "side": "RIGHT",
      "diff_hunk": "@@ -247,6 +247,12 @@ def export_item(self, item):\n         values = list(self._build_row(x for _, x in fields))\n         self.csv_writer.writerow(values)\n \n+    def finish_exporting(self):\n+        # Detaching stream in order to avoid file closing.\n+        # The file will be closed with slot.storage.store\n+        # https://github.com/scrapy/scrapy/issues/5043\n+        self.stream.detach()",
      "comment": "> Does this need to happen on finish exporting, or can it happen on `__init__`, right after initializing `self.stream`?\r\n\r\nI haven't actually tried that, but I doubt that it will work. From the [documentation](https://docs.python.org/3/library/io.html):\r\n**_After the raw stream has been detached, the buffer is in an unusable state._**\r\nand thus  it seems to me that it would make sense to detach the stream with `finish_exporting`.\r\n\r\n> Maybe it is a race condition, that in the tests we are closing `file` before the exporter class gets destroyed?\r\n\r\nI am pretty certain that this is the case since while testing I managed to avoid the problem without detaching input stream by sleeping feedexport for a few seconds after slot is closed, but before a new batch is started:\r\n   https://github.com/scrapy/scrapy/blob/c56caaf0b76939729fdc6d8982f4b249edb7d830/scrapy/extensions/feedexport.py#L437-L443\r\n   \r\n We might need to sleep the code somewhere in order to obtain successful tests?",
      "comment_id": 1015639985,
      "user": "srki24",
      "created_at": "2022-11-07T16:32:59Z",
      "url": "https://github.com/scrapy/scrapy/pull/5705#discussion_r1015639985"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 5929,
      "file_path": "scrapy/downloadermiddlewares/retry.py",
      "line": 39,
      "side": "RIGHT",
      "diff_hunk": "@@ -9,31 +9,38 @@\n Failed pages are collected on the scraping process and rescheduled at the end,\n once the spider has finished crawling all regular (non failed) pages.\n \"\"\"\n+import warnings\n from logging import Logger, getLogger\n from typing import Optional, Union\n \n-from twisted.internet import defer\n-from twisted.internet.error import (\n-    ConnectError,\n-    ConnectionDone,\n-    ConnectionLost,\n-    ConnectionRefusedError,\n-    DNSLookupError,\n-    TCPTimedOutError,\n-    TimeoutError,\n-)\n-from twisted.web.client import ResponseFailed\n-\n-from scrapy.core.downloader.handlers.http11 import TunnelError\n-from scrapy.exceptions import NotConfigured\n+import six\n+\n+from scrapy.exceptions import NotConfigured, ScrapyDeprecationWarning\n from scrapy.http.request import Request\n+from scrapy.settings import Settings\n from scrapy.spiders import Spider\n+from scrapy.utils.misc import load_object\n from scrapy.utils.python import global_object_name\n from scrapy.utils.response import response_status_message\n \n retry_logger = getLogger(__name__)\n \n \n+class BackwardsCompatibilityMetaclass(type):\n+    @property\n+    def EXCEPTIONS_TO_RETRY(self):\n+        warnings.warn(\n+            \"Attribute RetryMiddleware.EXCEPTIONS_TO_RETRY is deprecated. \"\n+            \"Use the RETRY_EXCEPTIONS setting instead.\",\n+            ScrapyDeprecationWarning,\n+            stacklevel=2,\n+        )\n+        return tuple(\n+            load_object(x) if isinstance(x, six.string_types) else x",
      "comment": "```suggestion\r\n            load_object(x) if isinstance(x, str) else x\r\n```",
      "comment_id": 1188873515,
      "user": "wRAR",
      "created_at": "2023-05-09T16:43:31Z",
      "url": "https://github.com/scrapy/scrapy/pull/5929#discussion_r1188873515"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 5929,
      "file_path": "scrapy/downloadermiddlewares/retry.py",
      "line": 16,
      "side": "RIGHT",
      "diff_hunk": "@@ -9,31 +9,38 @@\n Failed pages are collected on the scraping process and rescheduled at the end,\n once the spider has finished crawling all regular (non failed) pages.\n \"\"\"\n+import warnings\n from logging import Logger, getLogger\n from typing import Optional, Union\n \n-from twisted.internet import defer\n-from twisted.internet.error import (\n-    ConnectError,\n-    ConnectionDone,\n-    ConnectionLost,\n-    ConnectionRefusedError,\n-    DNSLookupError,\n-    TCPTimedOutError,\n-    TimeoutError,\n-)\n-from twisted.web.client import ResponseFailed\n-\n-from scrapy.core.downloader.handlers.http11 import TunnelError\n-from scrapy.exceptions import NotConfigured\n+import six",
      "comment": "We shouldn't use six as our code doesn't support Python 2.",
      "comment_id": 1188874819,
      "user": "wRAR",
      "created_at": "2023-05-09T16:44:48Z",
      "url": "https://github.com/scrapy/scrapy/pull/5929#discussion_r1188874819"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 5929,
      "file_path": "scrapy/downloadermiddlewares/retry.py",
      "line": 131,
      "side": "RIGHT",
      "diff_hunk": "@@ -121,23 +128,7 @@ def parse(self, response):\n     return None\n \n \n-class RetryMiddleware:\n-    # IOError is raised by the HttpCompression middleware when trying to\n-    # decompress an empty response\n-    EXCEPTIONS_TO_RETRY = (\n-        defer.TimeoutError,\n-        TimeoutError,\n-        DNSLookupError,\n-        ConnectionRefusedError,\n-        ConnectionDone,\n-        ConnectError,\n-        ConnectionLost,\n-        TCPTimedOutError,\n-        ResponseFailed,\n-        IOError,\n-        TunnelError,\n-    )\n-\n+class RetryMiddleware(six.with_metaclass(BackwardsCompatibilityMetaclass, object)):",
      "comment": "I *think* this should be `class RetryMiddleware(metaclass=BackwardsCompatibilityMetaclass)`",
      "comment_id": 1188876850,
      "user": "wRAR",
      "created_at": "2023-05-09T16:46:35Z",
      "url": "https://github.com/scrapy/scrapy/pull/5929#discussion_r1188876850"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 5929,
      "file_path": "scrapy/downloadermiddlewares/retry.py",
      "line": 145,
      "side": "RIGHT",
      "diff_hunk": "@@ -147,6 +138,16 @@ def __init__(self, settings):\n         )\n         self.priority_adjust = settings.getint(\"RETRY_PRIORITY_ADJUST\")\n \n+        if not hasattr(\n+            self, \"EXCEPTIONS_TO_RETRY\"\n+        ):  # If EXCEPTIONS_TO_RETRY is not \"overriden\"\n+            self.exceptions_to_retry = tuple(\n+                load_object(x) if isinstance(x, six.string_types) else x",
      "comment": "```suggestion\r\n                load_object(x) if isinstance(x, str) else x\r\n```",
      "comment_id": 1188877440,
      "user": "wRAR",
      "created_at": "2023-05-09T16:47:11Z",
      "url": "https://github.com/scrapy/scrapy/pull/5929#discussion_r1188877440"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 5929,
      "file_path": "scrapy/downloadermiddlewares/retry.py",
      "line": 145,
      "side": "RIGHT",
      "diff_hunk": "@@ -147,6 +138,16 @@ def __init__(self, settings):\n         )\n         self.priority_adjust = settings.getint(\"RETRY_PRIORITY_ADJUST\")\n \n+        if not hasattr(\n+            self, \"EXCEPTIONS_TO_RETRY\"\n+        ):  # If EXCEPTIONS_TO_RETRY is not \"overriden\"\n+            self.exceptions_to_retry = tuple(\n+                load_object(x) if isinstance(x, six.string_types) else x",
      "comment": "Actually in both these lines just `load_object(x)` should work, as `load_object()` works with any classes and just returns them.",
      "comment_id": 1188879823,
      "user": "wRAR",
      "created_at": "2023-05-09T16:49:28Z",
      "url": "https://github.com/scrapy/scrapy/pull/5929#discussion_r1188879823"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 5929,
      "file_path": "tests/test_downloadermiddleware_retry.py",
      "line": 128,
      "side": "RIGHT",
      "diff_hunk": "@@ -110,6 +110,29 @@ def test_twistederrors(self):\n             == 2\n         )\n \n+    def test_exception_to_retry_added(self):\n+        # Don't retry\n+        exc = ValueError\n+        req = Request(\"http://www.scrapytest.org/%s\" % exc.__name__)\n+        req = self.mw.process_exception(req, exc(\"foo\"), self.spider)\n+        self.assertEqual(req, None)\n+        # Retry\n+        self.mw.exceptions_to_retry = self.mw.exceptions_to_retry + (exc,)\n+        req = Request(\"http://www.scrapytest.org/%s\" % exc.__name__)\n+        self._test_retry_exception(req, exc(\"foo\"))\n+\n+    def test_exception_to_retry_customMiddleware(self):\n+        exc = ValueError\n+\n+        class MyRetryMiddleware(RetryMiddleware):\n+            EXCEPTIONS_TO_RETRY = RetryMiddleware.EXCEPTIONS_TO_RETRY + (exc,)",
      "comment": "As this test uses a deprecated attribute it should also check that the warning is produced.",
      "comment_id": 1188881800,
      "user": "wRAR",
      "created_at": "2023-05-09T16:51:12Z",
      "url": "https://github.com/scrapy/scrapy/pull/5929#discussion_r1188881800"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 5929,
      "file_path": "tests/test_downloadermiddleware_retry.py",
      "line": 122,
      "side": "RIGHT",
      "diff_hunk": "@@ -110,6 +110,29 @@ def test_twistederrors(self):\n             == 2\n         )\n \n+    def test_exception_to_retry_added(self):\n+        # Don't retry\n+        exc = ValueError\n+        req = Request(f\"http://www.scrapytest.org/{exc.__name__}\")\n+        req = self.mw.process_exception(req, exc(\"foo\"), self.spider)\n+        self.assertEqual(req, None)\n+        # Retry\n+        self.mw.exceptions_to_retry = self.mw.exceptions_to_retry + (exc,)\n+        req = Request(f\"http://www.scrapytest.org/{exc.__name__}\")\n+        self._test_retry_exception(req, exc(\"foo\"))",
      "comment": "It would be best to test adding it the way users should add it, e.g. (untested)\r\n\r\n```python\r\nfrom scrapy.settings.default_settings import RETRY_EXCEPTIONS\r\nsettings = {\r\n    \"RETRY_EXCEPTIONS\": RETRY_EXCEPTIONS + (ValueError,),\r\n}\r\ncrawler = get_crawler(Spider, settings=settings)\r\nmw = RetryMiddleware.from_crawler(crawler)\r\nreq = Request(f\"http://www.scrapytest.org/{exc.__name__}\")\r\nself._test_retry_exception(req, exc(\"foo\"), mw)  # Modify to accept an optional mw\r\n```",
      "comment_id": 1195048394,
      "user": "Gallaecio",
      "created_at": "2023-05-16T11:53:45Z",
      "url": "https://github.com/scrapy/scrapy/pull/5929#discussion_r1195048394"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 5929,
      "file_path": "tests/test_downloadermiddleware_retry.py",
      "line": 117,
      "side": "RIGHT",
      "diff_hunk": "@@ -110,19 +112,49 @@ def test_twistederrors(self):\n             == 2\n         )\n \n-    def _test_retry_exception(self, req, exception):\n+    def test_exception_to_retry_added(self):\n+        exc = ValueError\n+        self.mw.exceptions_to_retry = self.mw.exceptions_to_retry + (exc,)",
      "comment": "I suspect this line is pointless and can be removed completely. And maybe `ValueError` can be replaced with `exc` in the line below, to avoid repeating `ValueError`.",
      "comment_id": 1232014316,
      "user": "Gallaecio",
      "created_at": "2023-06-16T09:28:37Z",
      "url": "https://github.com/scrapy/scrapy/pull/5929#discussion_r1232014316"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 5833,
      "file_path": "scrapy/extensions/feedexport.py",
      "line": 176,
      "side": "RIGHT",
      "diff_hunk": "@@ -173,16 +173,39 @@ def __init__(\n         self.keyname = u.path[1:]  # remove first \"/\"\n         self.acl = acl\n         self.endpoint_url = endpoint_url\n-        import botocore.session\n-\n-        session = botocore.session.get_session()\n-        self.s3_client = session.create_client(\n-            \"s3\",\n-            aws_access_key_id=self.access_key,\n-            aws_secret_access_key=self.secret_key,\n-            aws_session_token=self.session_token,\n-            endpoint_url=self.endpoint_url,\n-        )\n+        self._using_boto3 = is_boto3_available()",
      "comment": "Wanted to limit the number of import checks without moving the `raise` above, couldn't think of anything better than just using a variable.",
      "comment_id": 1109962400,
      "user": "jazzthief",
      "created_at": "2023-02-17T15:19:00Z",
      "url": "https://github.com/scrapy/scrapy/pull/5833#discussion_r1109962400"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 5833,
      "file_path": "scrapy/extensions/feedexport.py",
      "line": 176,
      "side": "RIGHT",
      "diff_hunk": "@@ -173,16 +173,39 @@ def __init__(\n         self.keyname = u.path[1:]  # remove first \"/\"\n         self.acl = acl\n         self.endpoint_url = endpoint_url\n-        import botocore.session\n-\n-        session = botocore.session.get_session()\n-        self.s3_client = session.create_client(\n-            \"s3\",\n-            aws_access_key_id=self.access_key,\n-            aws_secret_access_key=self.secret_key,\n-            aws_session_token=self.session_token,\n-            endpoint_url=self.endpoint_url,\n-        )\n+        self._using_boto3 = is_boto3_available()",
      "comment": "Maybe what we should do is, instead of defining an `is_boto3_available` function, define an `IS_BOTO3_AVAILABLE` constant at the module level.\r\n\r\nI don\u2019t imagine the value could change at run time.",
      "comment_id": 1137024638,
      "user": "Gallaecio",
      "created_at": "2023-03-15T12:59:24Z",
      "url": "https://github.com/scrapy/scrapy/pull/5833#discussion_r1137024638"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 3450,
      "file_path": "scrapy/core/downloader/tls.py",
      "line": 103,
      "side": "RIGHT",
      "diff_hunk": "@@ -65,13 +81,51 @@ class ScrapyClientTLSOptions(ClientTLSOptions):\n         Same as Twisted's private _sslverify.ClientTLSOptions,\n         except that VerificationError, CertificateError and ValueError\n         exceptions are caught, so that the connection is not closed, only\n-        logging warnings.\n+        logging warnings. Also, HTTPS connection parameters logging is added.\n         \"\"\"\n \n         def _identityVerifyingInfoCallback(self, connection, where, ret):\n             if where & SSL_CB_HANDSHAKE_START:\n                 set_tlsext_host_name(connection, self._hostnameBytes)\n             elif where & SSL_CB_HANDSHAKE_DONE:\n+                logger.debug('SSL connection to %s using protocol %s, cipher %s',\n+                             self._hostnameASCII,\n+                             connection.get_protocol_version_name(),\n+                             connection.get_cipher_name(),\n+                             )\n+                server_cert = connection.get_peer_certificate()\n+                logger.debug('SSL connection certificate: issuer \"%s\", subject \"%s\"',\n+                             x509name_to_string(server_cert.get_issuer()),\n+                             x509name_to_string(server_cert.get_subject()),\n+                             )\n+\n+                if hasattr(pyOpenSSLutil.lib, 'SSL_get_server_tmp_key'):  # requires OpenSSL 1.0.2\n+                    # adapted from OpenSSL apps/s_cb.c::ssl_print_tmp_key()",
      "comment": "hey! Wopuld you mind moving it to a function? Not logging itself, just collecting all the information, likely with OpenSSL compatibility check.",
      "comment_id": 223089505,
      "user": "kmike",
      "created_at": "2018-10-05T17:49:28Z",
      "url": "https://github.com/scrapy/scrapy/pull/3450#discussion_r223089505"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 3450,
      "file_path": "scrapy/core/downloader/tls.py",
      "line": 103,
      "side": "RIGHT",
      "diff_hunk": "@@ -65,13 +81,51 @@ class ScrapyClientTLSOptions(ClientTLSOptions):\n         Same as Twisted's private _sslverify.ClientTLSOptions,\n         except that VerificationError, CertificateError and ValueError\n         exceptions are caught, so that the connection is not closed, only\n-        logging warnings.\n+        logging warnings. Also, HTTPS connection parameters logging is added.\n         \"\"\"\n \n         def _identityVerifyingInfoCallback(self, connection, where, ret):\n             if where & SSL_CB_HANDSHAKE_START:\n                 set_tlsext_host_name(connection, self._hostnameBytes)\n             elif where & SSL_CB_HANDSHAKE_DONE:\n+                logger.debug('SSL connection to %s using protocol %s, cipher %s',\n+                             self._hostnameASCII,\n+                             connection.get_protocol_version_name(),\n+                             connection.get_cipher_name(),\n+                             )\n+                server_cert = connection.get_peer_certificate()\n+                logger.debug('SSL connection certificate: issuer \"%s\", subject \"%s\"',\n+                             x509name_to_string(server_cert.get_issuer()),\n+                             x509name_to_string(server_cert.get_subject()),\n+                             )\n+\n+                if hasattr(pyOpenSSLutil.lib, 'SSL_get_server_tmp_key'):  # requires OpenSSL 1.0.2\n+                    # adapted from OpenSSL apps/s_cb.c::ssl_print_tmp_key()",
      "comment": "I think we can create scrapy.util.ssl or scrapy.util.openssl with such helpers (x509name_to_string, etc.)",
      "comment_id": 223090090,
      "user": "kmike",
      "created_at": "2018-10-05T17:51:39Z",
      "url": "https://github.com/scrapy/scrapy/pull/3450#discussion_r223090090"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 3450,
      "file_path": "scrapy/core/downloader/contextfactory.py",
      "line": 36,
      "side": "RIGHT",
      "diff_hunk": "@@ -28,9 +29,17 @@ class ScrapyClientContextFactory(BrowserLikePolicyForHTTPS):\n          understand the SSLv3, TLSv1, TLSv1.1 and TLSv1.2 protocols.'\n         \"\"\"\n \n-        def __init__(self, method=SSL.SSLv23_METHOD, *args, **kwargs):\n+        def __init__(self, method=SSL.SSLv23_METHOD, settings=None, *args, **kwargs):\n             super(ScrapyClientContextFactory, self).__init__(*args, **kwargs)\n             self._ssl_method = method\n+            if settings:\n+                self.tls_verbose_logging = settings['DOWNLOADER_CLIENT_TLS_VERBOSE_LOGGING']",
      "comment": "```suggestion\r\n                self.tls_verbose_logging = settings.getbool('DOWNLOADER_CLIENT_TLS_VERBOSE_LOGGING')\r\n```\r\n\r\nWithout it, `-s DOWNLOADER_CLIENT_TLS_VERBOSE_LOGGING=0` in command-line may be evaluated as True, because self.tls_verbose_logging will be '0'.",
      "comment_id": 303753950,
      "user": "kmike",
      "created_at": "2019-07-16T07:03:23Z",
      "url": "https://github.com/scrapy/scrapy/pull/3450#discussion_r303753950"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 3450,
      "file_path": "scrapy/core/downloader/contextfactory.py",
      "line": 32,
      "side": "RIGHT",
      "diff_hunk": "@@ -28,9 +29,17 @@ class ScrapyClientContextFactory(BrowserLikePolicyForHTTPS):\n          understand the SSLv3, TLSv1, TLSv1.1 and TLSv1.2 protocols.'\n         \"\"\"\n \n-        def __init__(self, method=SSL.SSLv23_METHOD, *args, **kwargs):\n+        def __init__(self, method=SSL.SSLv23_METHOD, settings=None, *args, **kwargs):",
      "comment": "I think a common practice is to pass tls_verbose_logging, not Settings instance, and extract option value in from_settings / from_crawler.",
      "comment_id": 303754318,
      "user": "kmike",
      "created_at": "2019-07-16T07:04:51Z",
      "url": "https://github.com/scrapy/scrapy/pull/3450#discussion_r303754318"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 3450,
      "file_path": "scrapy/core/downloader/contextfactory.py",
      "line": 32,
      "side": "RIGHT",
      "diff_hunk": "@@ -28,9 +29,17 @@ class ScrapyClientContextFactory(BrowserLikePolicyForHTTPS):\n          understand the SSLv3, TLSv1, TLSv1.1 and TLSv1.2 protocols.'\n         \"\"\"\n \n-        def __init__(self, method=SSL.SSLv23_METHOD, *args, **kwargs):\n+        def __init__(self, method=SSL.SSLv23_METHOD, settings=None, *args, **kwargs):",
      "comment": "I'm fine with changing this, though I don't like that we need to list all optional args in the documentation and the error message, as I was going to pass yet another setting here in a different PR, maybe we can rephrase the messages.",
      "comment_id": 304844925,
      "user": "wRAR",
      "created_at": "2019-07-18T10:24:45Z",
      "url": "https://github.com/scrapy/scrapy/pull/3450#discussion_r304844925"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 3442,
      "file_path": "scrapy/core/downloader/contextfactory.py",
      "line": 38,
      "side": "RIGHT",
      "diff_hunk": "@@ -28,9 +29,13 @@ class ScrapyClientContextFactory(BrowserLikePolicyForHTTPS):\n          understand the SSLv3, TLSv1, TLSv1.1 and TLSv1.2 protocols.'\n         \"\"\"\n \n-        def __init__(self, method=SSL.SSLv23_METHOD, *args, **kwargs):\n+        def __init__(self, method=SSL.SSLv23_METHOD, ciphers_string=None, *args, **kwargs):\n             super(ScrapyClientContextFactory, self).__init__(*args, **kwargs)\n             self._ssl_method = method\n+            if ciphers_string:\n+                self._ssl_ciphers = AcceptableCiphers.fromOpenSSLCipherString(ciphers_string)\n+            else:\n+                self._ssl_ciphers = DEFAULT_CIPHERS",
      "comment": "`DEFAULT_CIPHERS` is a singleton so I kept it as it maybe improves the performance.",
      "comment_id": 221871153,
      "user": "wRAR",
      "created_at": "2018-10-02T08:52:43Z",
      "url": "https://github.com/scrapy/scrapy/pull/3442#discussion_r221871153"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 3442,
      "file_path": "tests/mockserver.py",
      "line": 230,
      "side": "RIGHT",
      "diff_hunk": "@@ -222,6 +224,14 @@ def ssl_context_factory(keyfile='keys/localhost.key', certfile='keys/localhost.c\n          )\n \n \n+def broken_ssl_context_factory(keyfile='keys/localhost.key', certfile='keys/localhost.crt', cipher_string='DEFAULT'):\n+    factory = ssl_context_factory(keyfile, certfile)\n+    ctx = factory.getContext()\n+    ctx.set_options(SSL.OP_CIPHER_SERVER_PREFERENCE | SSL.OP_NO_TLSv1_2)",
      "comment": "TLS 1.2 has it's own always enabled ciphers so I disable it.\r\n\r\nTwisted recommends using `CertificateOptions` instead of `DefaultOpenSSLContextFactory`, and its API is cleaner, but it requires file-like objects for certs and also I don't know if all supported Twisted versions support this API.",
      "comment_id": 221871776,
      "user": "wRAR",
      "created_at": "2018-10-02T08:54:37Z",
      "url": "https://github.com/scrapy/scrapy/pull/3442#discussion_r221871776"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 3442,
      "file_path": "tests/mockserver.py",
      "line": 7,
      "side": "RIGHT",
      "diff_hunk": "@@ -3,6 +3,8 @@\n from six.moves.urllib.parse import urlencode\n from subprocess import Popen, PIPE\n \n+from OpenSSL import SSL\n+",
      "comment": "a nitpick: this import should be with twisted imports according to pep8 (3 groups: stdlib imports, third-party imports, internal imports)",
      "comment_id": 223100938,
      "user": "kmike",
      "created_at": "2018-10-05T18:29:20Z",
      "url": "https://github.com/scrapy/scrapy/pull/3442#discussion_r223100938"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 3442,
      "file_path": "tests/mockserver.py",
      "line": 230,
      "side": "RIGHT",
      "diff_hunk": "@@ -222,6 +224,14 @@ def ssl_context_factory(keyfile='keys/localhost.key', certfile='keys/localhost.c\n          )\n \n \n+def broken_ssl_context_factory(keyfile='keys/localhost.key', certfile='keys/localhost.crt', cipher_string='DEFAULT'):\n+    factory = ssl_context_factory(keyfile, certfile)\n+    ctx = factory.getContext()\n+    ctx.set_options(SSL.OP_CIPHER_SERVER_PREFERENCE | SSL.OP_NO_TLSv1_2)",
      "comment": "`CertificateOptions` was there at least in twisted 9.0.0 (https://twistedmatrix.com/documents/9.0.0/api/twisted.internet.ssl.CertificateOptions.html), so it should be fine to use. But I have no idea what I'm talking about, or what is better in this particular case :)",
      "comment_id": 223102680,
      "user": "kmike",
      "created_at": "2018-10-05T18:35:26Z",
      "url": "https://github.com/scrapy/scrapy/pull/3442#discussion_r223102680"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 3442,
      "file_path": "tests/mockserver.py",
      "line": 227,
      "side": "RIGHT",
      "diff_hunk": "@@ -222,6 +224,14 @@ def ssl_context_factory(keyfile='keys/localhost.key', certfile='keys/localhost.c\n          )\n \n \n+def broken_ssl_context_factory(keyfile='keys/localhost.key', certfile='keys/localhost.crt', cipher_string='DEFAULT'):",
      "comment": "Could you please explain what this code does? Does it 1) add cipher_string support, and 2) disables default ciphers which come from TLSv1_2? And the purpose is to create servers which use outdated ciphers not supported by current http clients by default?\r\n\r\nIf so, what do you think about \r\n\r\n1) removing this function,\r\n2) adding cipher_string argument to ssl_context_factory, None by default,\r\n3) when cipher_string is not None, ssl_context_factory becomes broken_ssl_context_factory,\r\n4) add a comment which explains why `ctx.set_options(SSL.OP_CIPHER_SERVER_PREFERENCE | SSL.OP_NO_TLSv1_2)` line exists.",
      "comment_id": 223104305,
      "user": "kmike",
      "created_at": "2018-10-05T18:41:13Z",
      "url": "https://github.com/scrapy/scrapy/pull/3442#discussion_r223104305"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 3442,
      "file_path": "tests/test_downloader_handlers.py",
      "line": 576,
      "side": "RIGHT",
      "diff_hunk": "@@ -520,6 +520,47 @@ def setUp(self):\n         super(Https11InvalidDNSPattern, self).setUp()\n \n \n+class Https11BadCiphers(unittest.TestCase):\n+    scheme = 'https'\n+    download_handler_cls = HTTP11DownloadHandler\n+\n+    keyfile = 'keys/localhost.key'\n+    certfile = 'keys/localhost.crt'\n+\n+    def setUp(self):\n+        self.tmpname = self.mktemp()\n+        os.mkdir(self.tmpname)\n+        FilePath(self.tmpname).child(\"file\").setContent(b\"0123456789\")\n+        r = static.File(self.tmpname)\n+        self.site = server.Site(r, timeout=None)\n+        self.wrapper = WrappingFactory(self.site)\n+        self.host = 'localhost'\n+        self.port = reactor.listenSSL(\n+            0, self.wrapper, broken_ssl_context_factory(self.keyfile, self.certfile, cipher_string='CAMELLIA256-SHA'),\n+            interface=self.host)\n+        self.portno = self.port.getHost().port\n+        self.download_handler = self.download_handler_cls(\n+            Settings({'DOWNLOADER_CLIENT_TLS_CIPHERS': 'CAMELLIA256-SHA'}))",
      "comment": "could you please also add a test which shows that downloading doesn't work with default DOWNLOADER_CLIENT_TLS_CIPHERS, to make sure the other test is valid?",
      "comment_id": 223104976,
      "user": "kmike",
      "created_at": "2018-10-05T18:42:53Z",
      "url": "https://github.com/scrapy/scrapy/pull/3442#discussion_r223104976"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 3442,
      "file_path": "scrapy/core/downloader/contextfactory.py",
      "line": 38,
      "side": "RIGHT",
      "diff_hunk": "@@ -28,9 +29,13 @@ class ScrapyClientContextFactory(BrowserLikePolicyForHTTPS):\n          understand the SSLv3, TLSv1, TLSv1.1 and TLSv1.2 protocols.'\n         \"\"\"\n \n-        def __init__(self, method=SSL.SSLv23_METHOD, *args, **kwargs):\n+        def __init__(self, method=SSL.SSLv23_METHOD, ciphers_string=None, *args, **kwargs):\n             super(ScrapyClientContextFactory, self).__init__(*args, **kwargs)\n             self._ssl_method = method\n+            if ciphers_string:\n+                self._ssl_ciphers = AcceptableCiphers.fromOpenSSLCipherString(ciphers_string)\n+            else:\n+                self._ssl_ciphers = DEFAULT_CIPHERS",
      "comment": "I'm not sure it helps, as download handler always pass ciphers_string, which is \"DEFAULT\" by default. ",
      "comment_id": 223107734,
      "user": "kmike",
      "created_at": "2018-10-05T18:51:25Z",
      "url": "https://github.com/scrapy/scrapy/pull/3442#discussion_r223107734"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 3442,
      "file_path": "scrapy/core/downloader/contextfactory.py",
      "line": 63,
      "side": "RIGHT",
      "diff_hunk": "@@ -54,7 +60,7 @@ def getCertificateOptions(self):\n                         method=getattr(self, 'method',\n                                        getattr(self, '_ssl_method', None)),\n                         fixBrokenPeers=True,\n-                        acceptableCiphers=DEFAULT_CIPHERS)\n+                        acceptableCiphers=self.tls_ciphers)",
      "comment": "We should remove or deprecate the `DEFAULT_CIPHERS` import in this file, and probably also its definition in `scrapy/core/downloader/tls.py`.",
      "comment_id": 312873294,
      "user": "Gallaecio",
      "created_at": "2019-08-12T11:09:33Z",
      "url": "https://github.com/scrapy/scrapy/pull/3442#discussion_r312873294"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 3442,
      "file_path": "scrapy/core/downloader/contextfactory.py",
      "line": 63,
      "side": "RIGHT",
      "diff_hunk": "@@ -54,7 +60,7 @@ def getCertificateOptions(self):\n                         method=getattr(self, 'method',\n                                        getattr(self, '_ssl_method', None)),\n                         fixBrokenPeers=True,\n-                        acceptableCiphers=DEFAULT_CIPHERS)\n+                        acceptableCiphers=self.tls_ciphers)",
      "comment": "> We should remove or deprecate the `DEFAULT_CIPHERS` import in this file, and probably also its definition in `scrapy/core/downloader/tls.py`.\r\n\r\nAnd move the default to `__init__`?",
      "comment_id": 313012319,
      "user": "wRAR",
      "created_at": "2019-08-12T16:26:21Z",
      "url": "https://github.com/scrapy/scrapy/pull/3442#discussion_r313012319"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 3442,
      "file_path": "scrapy/core/downloader/contextfactory.py",
      "line": 63,
      "side": "RIGHT",
      "diff_hunk": "@@ -54,7 +60,7 @@ def getCertificateOptions(self):\n                         method=getattr(self, 'method',\n                                        getattr(self, '_ssl_method', None)),\n                         fixBrokenPeers=True,\n-                        acceptableCiphers=DEFAULT_CIPHERS)\n+                        acceptableCiphers=self.tls_ciphers)",
      "comment": "I mean that `DEFAULT_CIPHERS`, after your change, is no longer used in this file, nor anywhere else in the Scrapy code base.",
      "comment_id": 313018513,
      "user": "Gallaecio",
      "created_at": "2019-08-12T16:41:19Z",
      "url": "https://github.com/scrapy/scrapy/pull/3442#discussion_r313018513"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 4198,
      "file_path": "scrapy/core/downloader/handlers/http11.py",
      "line": 294,
      "side": "RIGHT",
      "diff_hunk": "@@ -285,6 +286,12 @@ def _get_agent(self, request, timeout):\n             scheme = _parse(request.url)[0]\n             proxyHost = to_unicode(proxyHost)\n             omitConnectTunnel = b'noconnect' in proxyParams\n+            if omitConnectTunnel:\n+                warnings.warn(\"Using HTTPS proxies in the noconnect mode is deprecated. \"\n+                              \"If you use Crawlera, it doesn't require this mode anymore, \"\n+                              \"so you should update scrapy-crawlera to 1.3.0+ \"\n+                              \"and remove '?noconnect' from the Crawlera URL.\",\n+                              ScrapyDeprecationWarning)",
      "comment": "I\u2019m guessing we need to use a higher stack level to point to the user code where noconnect is used.",
      "comment_id": 351651150,
      "user": "Gallaecio",
      "created_at": "2019-11-28T08:47:48Z",
      "url": "https://github.com/scrapy/scrapy/pull/4198#discussion_r351651150"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 4198,
      "file_path": "scrapy/core/downloader/handlers/http11.py",
      "line": 294,
      "side": "RIGHT",
      "diff_hunk": "@@ -285,6 +286,12 @@ def _get_agent(self, request, timeout):\n             scheme = _parse(request.url)[0]\n             proxyHost = to_unicode(proxyHost)\n             omitConnectTunnel = b'noconnect' in proxyParams\n+            if omitConnectTunnel:\n+                warnings.warn(\"Using HTTPS proxies in the noconnect mode is deprecated. \"\n+                              \"If you use Crawlera, it doesn't require this mode anymore, \"\n+                              \"so you should update scrapy-crawlera to 1.3.0+ \"\n+                              \"and remove '?noconnect' from the Crawlera URL.\",\n+                              ScrapyDeprecationWarning)",
      "comment": "I'm afraid it's not possible as there is a lot of unrelated frames there, also the user code is usually in `settings.py`, in `CRAWLERA_URL`.",
      "comment_id": 351657555,
      "user": "wRAR",
      "created_at": "2019-11-28T09:02:13Z",
      "url": "https://github.com/scrapy/scrapy/pull/4198#discussion_r351657555"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 4198,
      "file_path": "tests/test_downloader_handlers.py",
      "line": 690,
      "side": "LEFT",
      "diff_hunk": "@@ -687,16 +687,6 @@ def _test(response):\n         request = Request('http://example.com', meta={'proxy': http_proxy})\n         return self.download_request(request, Spider('foo')).addCallback(_test)\n \n-    def test_download_with_proxy_https_noconnect(self):",
      "comment": "Can we keep this test and modify it just to verify that the warning is logged?",
      "comment_id": 351670421,
      "user": "Gallaecio",
      "created_at": "2019-11-28T09:29:39Z",
      "url": "https://github.com/scrapy/scrapy/pull/4198#discussion_r351670421"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 5100,
      "file_path": "scrapy/core/scraper.py",
      "line": 6,
      "side": "RIGHT",
      "diff_hunk": "@@ -3,11 +3,10 @@\n \n import logging\n from collections import deque\n-from collections.abc import Iterable\n-from typing import Union\n+from typing import Union, Optional, Tuple, Set, Deque, Any, Iterable",
      "comment": "```suggestion\r\nfrom typing import Any, Deque, Iterable, Optional, Set, Tuple, Union\r\n```",
      "comment_id": 613335926,
      "user": "Gallaecio",
      "created_at": "2021-04-14T15:10:08Z",
      "url": "https://github.com/scrapy/scrapy/pull/5100#discussion_r613335926"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 5100,
      "file_path": "scrapy/core/scraper.py",
      "line": 22,
      "side": "RIGHT",
      "diff_hunk": "@@ -20,6 +19,9 @@\n from scrapy.utils.spider import iterate_spider_output\n \n \n+QUEUE_TUPLE = Tuple[Union[Response, Failure], Request, Deferred]",
      "comment": "I would use the same letter case as other classes and types, in line with https://docs.python.org/3/library/typing.html\r\n\r\n```suggestion\r\nQueueTuple = Tuple[Union[Response, Failure], Request, Deferred]\r\n```",
      "comment_id": 613338926,
      "user": "Gallaecio",
      "created_at": "2021-04-14T15:13:37Z",
      "url": "https://github.com/scrapy/scrapy/pull/5100#discussion_r613338926"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 5100,
      "file_path": "scrapy/core/scraper.py",
      "line": 251,
      "side": "RIGHT",
      "diff_hunk": "@@ -230,10 +246,12 @@ def _log_download_errors(self, spider_failure, download_failure, request, spider\n \n         if spider_failure is not download_failure:\n             return spider_failure\n+        return None\n \n-    def _itemproc_finished(self, output, item, response, spider):\n+    def _itemproc_finished(self, output: Any, item: Any, response: Response, spider: Spider) -> None:",
      "comment": "I don\u2019t think it needs to be done in this pull request, but I\u2019m thinking that it may be good to have a type alias for all `itemadapter`-supported item types, and use it in scenarios like this one instead of `Any`. It probably makes sense to implement that type alias in `itemadapter`, though.",
      "comment_id": 613342988,
      "user": "Gallaecio",
      "created_at": "2021-04-14T15:18:06Z",
      "url": "https://github.com/scrapy/scrapy/pull/5100#discussion_r613342988"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 5288,
      "file_path": "scrapy/utils/defer.py",
      "line": 16,
      "side": "RIGHT",
      "diff_hunk": "@@ -3,10 +3,16 @@\n \"\"\"\n import asyncio\n import inspect\n-from collections.abc import Coroutine\n+from asyncio import Future\n from functools import wraps\n-from typing import Any, Callable, Generator, Iterable\n-\n+from typing import (\n+    Any,\n+    Callable,\n+    Coroutine,\n+    Generator,\n+    Iterable,\n+    Union\n+)\n from twisted.internet import defer",
      "comment": "```suggestion\r\n)\r\n\r\nfrom twisted.internet import defer\r\n```",
      "comment_id": 734272027,
      "user": "Gallaecio",
      "created_at": "2021-10-22T06:40:01Z",
      "url": "https://github.com/scrapy/scrapy/pull/5288#discussion_r734272027"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 5288,
      "file_path": "scrapy/utils/defer.py",
      "line": 184,
      "side": "RIGHT",
      "diff_hunk": "@@ -171,3 +177,21 @@ def maybeDeferred_coro(f: Callable, *args, **kw) -> Deferred:\n         return defer.fail(result)\n     else:\n         return defer.succeed(result)\n+\n+\n+def deferred_to_future(d: Deferred) -> Future:\n+    \"\"\" Wraps a Deferred into a Future. Requires the asyncio reactor.\n+    \"\"\"",
      "comment": "```suggestion\r\n    \"\"\"Return an :class:`asyncio.Future` object that wraps *d*.\r\n    \r\n    When :ref:`using the asyncio reactor <install-asyncio>`, you cannot await \r\n    on :class:`~twisted.internet.defer.Deferred` objects from :ref:`Scrapy \r\n    callables defined as coroutines <coroutine-support>`, you can only await on \r\n    ``Future`` objects. Wrapping ``Deferred`` objects into ``Future`` objects \r\n    allows you to wait on them::\r\n    \r\n        class MySpider(Spider):\r\n            ...\r\n            async def parse(self, response):\r\n                d = treq.get('https://example.com/additional')\r\n                additional_response = await deferred_to_future(d)\r\n    \"\"\"\r\n```",
      "comment_id": 734284395,
      "user": "Gallaecio",
      "created_at": "2021-10-22T07:04:20Z",
      "url": "https://github.com/scrapy/scrapy/pull/5288#discussion_r734284395"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 5288,
      "file_path": "scrapy/utils/defer.py",
      "line": 193,
      "side": "RIGHT",
      "diff_hunk": "@@ -171,3 +177,21 @@ def maybeDeferred_coro(f: Callable, *args, **kw) -> Deferred:\n         return defer.fail(result)\n     else:\n         return defer.succeed(result)\n+\n+\n+def deferred_to_future(d: Deferred) -> Future:\n+    \"\"\" Wraps a Deferred into a Future. Requires the asyncio reactor.\n+    \"\"\"\n+    return d.asFuture(asyncio.get_event_loop())\n+\n+\n+def maybe_deferred_to_future(d: Deferred) -> Union[Deferred, Future]:\n+    \"\"\" Converts a Deferred to something that can be awaited in a callback or other user coroutine.\n+    If the asyncio reactor is installed, coroutines are wrapped into Futures, and only Futures can be\n+    awaited inside them. Otherwise, coroutines are wrapped into Deferreds and Deferreds can be awaited\n+    directly inside them.\n+    \"\"\"",
      "comment": "```suggestion\r\n    \"\"\"Return *d* as an object that can be awaited from a :ref:`Scrapy callable\r\n    defined as a coroutine <coroutine-support>`.\r\n    \r\n    What you can await in Scrapy callables defined as coroutines depends on the \r\n    value of :setting:`TWISTED_REACTOR`:\r\n    \r\n    -   When not using the asyncio reactor, you can only await on\r\n        :class:`~twisted.internet.defer.Deferred` objects.\r\n        \r\n    -   When :ref:`using the asyncio reactor <install-asyncio>`, you can only \r\n        await on :class:`asyncio.Future` objects.\r\n        \r\n    If you want to write code that uses ``Deferred`` objects but works with any \r\n    reactor, use this function on all ``Deferred`` objects::\r\n    \r\n        class MySpider(Spider):\r\n            ...\r\n            async def parse(self, response):\r\n                d = treq.get('https://example.com/additional')\r\n                extra_response = await maybe_deferred_to_future(d)\r\n    \"\"\"\r\n```",
      "comment_id": 734301410,
      "user": "Gallaecio",
      "created_at": "2021-10-22T07:33:33Z",
      "url": "https://github.com/scrapy/scrapy/pull/5288#discussion_r734301410"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 5315,
      "file_path": "scrapy/utils/reactor.py",
      "line": 62,
      "side": "RIGHT",
      "diff_hunk": "@@ -57,6 +58,10 @@ def install_reactor(reactor_path, event_loop_path=None):\n     reactor_class = load_object(reactor_path)\n     if reactor_class is asyncioreactor.AsyncioSelectorReactor:\n         with suppress(error.ReactorAlreadyInstalledError):\n+            if sys.version_info >= (3, 8) and sys.platform == \"win32\":\n+                policy = asyncio.get_event_loop_policy()",
      "comment": "Should we also load coverage data from Windows runs? ",
      "comment_id": 755100025,
      "user": "wRAR",
      "created_at": "2021-11-23T13:00:36Z",
      "url": "https://github.com/scrapy/scrapy/pull/5315#discussion_r755100025"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 5315,
      "file_path": "scrapy/utils/reactor.py",
      "line": 62,
      "side": "RIGHT",
      "diff_hunk": "@@ -57,6 +58,10 @@ def install_reactor(reactor_path, event_loop_path=None):\n     reactor_class = load_object(reactor_path)\n     if reactor_class is asyncioreactor.AsyncioSelectorReactor:\n         with suppress(error.ReactorAlreadyInstalledError):\n+            if sys.version_info >= (3, 8) and sys.platform == \"win32\":\n+                policy = asyncio.get_event_loop_policy()",
      "comment": "Ideally, but I don\u2019t think you need to worry about that as part of this pull request unless you want to. Maybe open a separate issue to address that eventually?",
      "comment_id": 776989245,
      "user": "Gallaecio",
      "created_at": "2021-12-31T11:44:24Z",
      "url": "https://github.com/scrapy/scrapy/pull/5315#discussion_r776989245"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 5315,
      "file_path": "tests/test_downloader_handlers.py",
      "line": 293,
      "side": "RIGHT",
      "diff_hunk": "@@ -287,6 +288,11 @@ def test_redirect_status_head(self):\n \n     @defer.inlineCallbacks\n     def test_timeout_download_from_spider_nodata_rcvd(self):\n+        if self.reactor_pytest == \"asyncio\" and sys.platform == \"win32\":\n+            raise unittest.SkipTest(\n+                \"This test produces DirtyReactorAggregateError on Windows with asyncio\"",
      "comment": "What about including a link to the upstream issue you reported when skipping these tests, for future reference? (either as a code comment or in the skip message).",
      "comment_id": 776989409,
      "user": "Gallaecio",
      "created_at": "2021-12-31T11:45:39Z",
      "url": "https://github.com/scrapy/scrapy/pull/5315#discussion_r776989409"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 4978,
      "file_path": "scrapy/spidermiddlewares/urllength.py",
      "line": 47,
      "side": "RIGHT",
      "diff_hunk": "@@ -37,4 +38,10 @@ def _filter(request):\n             else:\n                 return True\n \n-        return (r for r in result or () if _filter(r))\n+        @_process_iterable_universal\n+        async def process(result):\n+            async for r in result or ():\n+                if _filter(r):\n+                    yield r\n+\n+        return process(result)",
      "comment": "I see you add this decorator to several middlewares, what if I have my own middlewares without process_iterable_universal? Will it work fine? Or will I have to add things to my middleware?",
      "comment_id": 603037795,
      "user": "pawelmhm",
      "created_at": "2021-03-29T06:21:32Z",
      "url": "https://github.com/scrapy/scrapy/pull/4978#discussion_r603037795"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 4978,
      "file_path": "scrapy/spidermiddlewares/urllength.py",
      "line": 47,
      "side": "RIGHT",
      "diff_hunk": "@@ -37,4 +38,10 @@ def _filter(request):\n             else:\n                 return True\n \n-        return (r for r in result or () if _filter(r))\n+        @_process_iterable_universal\n+        async def process(result):\n+            async for r in result or ():\n+                if _filter(r):\n+                    yield r\n+\n+        return process(result)",
      "comment": "UPDATE:\r\n\r\nI tested it in one of my projects where I have some middleware added by me and it crashes. So it means users will have to update their middlewares.",
      "comment_id": 603065662,
      "user": "pawelmhm",
      "created_at": "2021-03-29T07:26:35Z",
      "url": "https://github.com/scrapy/scrapy/pull/4978#discussion_r603065662"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 4978,
      "file_path": "scrapy/spidermiddlewares/urllength.py",
      "line": 47,
      "side": "RIGHT",
      "diff_hunk": "@@ -37,4 +38,10 @@ def _filter(request):\n             else:\n                 return True\n \n-        return (r for r in result or () if _filter(r))\n+        @_process_iterable_universal\n+        async def process(result):\n+            async for r in result or ():\n+                if _filter(r):\n+                    yield r\n+\n+        return process(result)",
      "comment": "It's a tricky question and I'm going to add docs for this question and maybe do some more research when the current situation is documented. Old sync middlewares indeed cannot work with async callbacks at least with the code in this PR.\n",
      "comment_id": 603171373,
      "user": "wRAR",
      "created_at": "2021-03-29T10:10:41Z",
      "url": "https://github.com/scrapy/scrapy/pull/4978#discussion_r603171373"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 4978,
      "file_path": "scrapy/core/spidermw.py",
      "line": 7,
      "side": "RIGHT",
      "diff_hunk": "@@ -3,9 +3,8 @@\n \n See documentation in docs/topics/spider-middleware.rst\n \"\"\"\n-import collections.abc\n from itertools import islice\n-from typing import Any, Callable, Generator, Iterable, Union\n+from typing import Any, Callable, Generator, Iterable, Union, AsyncIterable, AsyncGenerator",
      "comment": ":lipstick: \r\n\r\n```suggestion\r\nfrom typing import Any, AsyncGenerator, AsyncIterable, Callable, Generator, Iterable, Union\r\n```",
      "comment_id": 613245464,
      "user": "Gallaecio",
      "created_at": "2021-04-14T13:26:32Z",
      "url": "https://github.com/scrapy/scrapy/pull/4978#discussion_r613245464"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 4978,
      "file_path": "scrapy/core/spidermw.py",
      "line": 64,
      "side": "RIGHT",
      "diff_hunk": "@@ -58,7 +60,9 @@ def _process_spider_input(self, scrape_func: ScrapeFunc, response: Response, req\n                 return scrape_func(Failure(), request, spider)\n         return scrape_func(response, request, spider)\n \n-    def _evaluate_iterable(self, response, spider, iterable, exception_processor_index, recover_to):\n+    def _evaluate_iterable(self, response: Response, spider: Spider, iterable: Union[Iterable, AsyncIterable],\n+                           exception_processor_index: int, recover_to: Union[MutableChain, MutableAsyncChain]",
      "comment": "I wonder if it would make sense to provide in `scrapy.utils.typing` aliases for some of these sync-or-async types (e.g. `AnyIterable`, `AnyMutableChain`). Although maybe it\u2019s more readable to specify them explicitly with `Union` as we do now, instead of having to go to a different module to find out what the type stands for.",
      "comment_id": 613249890,
      "user": "Gallaecio",
      "created_at": "2021-04-14T13:32:04Z",
      "url": "https://github.com/scrapy/scrapy/pull/4978#discussion_r613249890"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 4978,
      "file_path": "scrapy/core/spidermw.py",
      "line": 128,
      "side": "RIGHT",
      "diff_hunk": "@@ -82,11 +110,22 @@ def _process_spider_exception(self, response: Response, spider: Spider, _failure\n         for method_index, method in enumerate(method_list, start=start_index):\n             if method is None:\n                 continue\n+            method = cast(Callable, method)\n             result = method(response=response, exception=exception, spider=spider)\n             if _isiterable(result):\n                 # stop exception handling by handing control over to the\n                 # process_spider_output chain if an iterable has been returned\n-                return self._process_spider_output(response, spider, result, method_index + 1)\n+                dfd: Deferred = self._process_spider_output(response, spider, result, method_index + 1)\n+                # _process_spider_output() returns a Deferred only because of downgrading so this can be\n+                # simplified when downgrading is removed.\n+                if dfd.called:\n+                    # the result is available immediately if _process_spider_output didn't do downgrading\n+                    return dfd.result\n+                else:\n+                    # we forbid waiting here because otherwise we would need to return a deferred from\n+                    # _process_spider_exception too, which complicates the architecture\n+                    msg = f\"Async iterable returned from {method.__qualname__} cannot be downgraded\"\n+                    raise _InvalidOutput(msg)",
      "comment": "As I was working on a [proposal to refactor the new documentation](https://github.com/wRAR/scrapy/pull/1), I got stuck at trying to cover `process_spider_exception` properly.\r\n\r\nI was trying to understand in which scenarios trigger this exception, and I came to realize the following about `process_spider_exception`:\r\n\r\n- If defined as an asynchronous generator, it cannot return `None`. If it does not yield anything, that will count as an empty iterable. So with `async def` + `yield` we lose the ability to get Scrapy to call the next `process_spider_exception` method.\r\n- If defined as a coroutine, an exception is raised because it is neither an iterable nor `None` (it is a coroutine), so `async def` _without_ `yield` is not an option either.\r\n\r\nIn other words, `async def process_spider_exception` can never return `None` to get Scrapy to let the next `process_spider_exception` work.\r\n\r\nI wonder if it would not be better to limit `process_spider_exception` to being synchronous for now, until we can figure out an API for it that allows the `None` behavior as well. This feels similar to start_requests, i.e. we may need to define some special object that may be yielded from the asynchronous generator to indicate the same as `None` does in the synchronous version.",
      "comment_id": 828433876,
      "user": "Gallaecio",
      "created_at": "2022-03-16T20:44:50Z",
      "url": "https://github.com/scrapy/scrapy/pull/4978#discussion_r828433876"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 4978,
      "file_path": "scrapy/spidermiddlewares/depth.py",
      "line": 35,
      "side": "RIGHT",
      "diff_hunk": "@@ -28,31 +28,42 @@ def from_crawler(cls, crawler):\n         return cls(maxdepth, crawler.stats, verbose, prio)\n \n     def process_spider_output(self, response, result, spider):\n-        def _filter(request):\n-            if isinstance(request, Request):\n-                depth = response.meta['depth'] + 1\n-                request.meta['depth'] = depth\n-                if self.prio:\n-                    request.priority -= depth * self.prio\n-                if self.maxdepth and depth > self.maxdepth:\n-                    logger.debug(\n-                        \"Ignoring link (depth > %(maxdepth)d): %(requrl)s \",\n-                        {'maxdepth': self.maxdepth, 'requrl': request.url},\n-                        extra={'spider': spider}\n-                    )\n-                    return False\n-                else:\n-                    if self.verbose_stats:\n-                        self.stats.inc_value(f'request_depth_count/{depth}',\n-                                             spider=spider)\n-                    self.stats.max_value('request_depth_max', depth,\n-                                         spider=spider)\n-            return True\n+        # base case (depth=0)\n+        if 'depth' not in response.meta:\n+            response.meta['depth'] = 0\n+            if self.verbose_stats:\n+                self.stats.inc_value('request_depth_count/0', spider=spider)",
      "comment": ":lipstick: Maybe worth moving to a private method, to avoid duplication?",
      "comment_id": 931314279,
      "user": "Gallaecio",
      "created_at": "2022-07-27T17:17:31Z",
      "url": "https://github.com/scrapy/scrapy/pull/4978#discussion_r931314279"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 5918,
      "file_path": "scrapy/selector/unified.py",
      "line": 71,
      "side": "RIGHT",
      "diff_hunk": "@@ -63,7 +68,7 @@ class Selector(_ParselSelector, object_ref):\n     __slots__ = [\"response\"]\n     selectorlist_cls = SelectorList\n \n-    def __init__(self, response=None, text=None, type=None, root=None, **kwargs):\n+    def __init__(self, response=None, text=None, type=None, root=_NOT_SET, **kwargs):",
      "comment": "I would try to avoid importing Parsel\u2019s `_NOT_SET`.\r\n\r\nFor example, we could declare our own _NOT_SET, and handle root though the kwargs variable, i.e. if root is not _our_ _NOT_SET, we add it to kwargs:\r\n\r\n```python\r\n_NOT_SET = object()\r\n...\r\ndef __init__(self, response=None, text=None, type=None, root=_NOT_SET, **kwargs):\r\n...\r\nif root is not _NOT_SET:\r\n    kwargs[\"root\"] = root\r\n...\r\nsuper().__init__(text=text, type=st, **kwargs)\r\n```\r\n\r\nNot a strong opinion, though. If one project can use a private member of Parsel that\u2019s Scrapy.",
      "comment_id": 1184584434,
      "user": "Gallaecio",
      "created_at": "2023-05-04T06:21:12Z",
      "url": "https://github.com/scrapy/scrapy/pull/5918#discussion_r1184584434"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 5918,
      "file_path": "scrapy/selector/unified.py",
      "line": 71,
      "side": "RIGHT",
      "diff_hunk": "@@ -63,7 +68,7 @@ class Selector(_ParselSelector, object_ref):\n     __slots__ = [\"response\"]\n     selectorlist_cls = SelectorList\n \n-    def __init__(self, response=None, text=None, type=None, root=None, **kwargs):\n+    def __init__(self, response=None, text=None, type=None, root=_NOT_SET, **kwargs):",
      "comment": "On current parsel version(1.8.1) I definitely don't see option without import of `_NOT_SET` from parsel module. Any other internally created `object()` on root - will not pass checks against module's `_NOT_SET` on parsel side\r\n\r\nI tried similar approach\r\nhttps://github.com/scrapy/scrapy/compare/master...GeorgeA92:scrapy:warning_roottext_from_parser_jmespath\r\n",
      "comment_id": 1184599298,
      "user": "GeorgeA92",
      "created_at": "2023-05-04T06:42:22Z",
      "url": "https://github.com/scrapy/scrapy/pull/5918#discussion_r1184599298"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 5918,
      "file_path": "scrapy/selector/unified.py",
      "line": 71,
      "side": "RIGHT",
      "diff_hunk": "@@ -63,7 +68,7 @@ class Selector(_ParselSelector, object_ref):\n     __slots__ = [\"response\"]\n     selectorlist_cls = SelectorList\n \n-    def __init__(self, response=None, text=None, type=None, root=None, **kwargs):\n+    def __init__(self, response=None, text=None, type=None, root=_NOT_SET, **kwargs):",
      "comment": "The key is in _not_ passing `root` at all if set to _NOT_SET on Scrapy\u2019s end.\r\n\r\nTo elaborate on the code I shared above:\r\n\r\n```python\r\n_NOT_SET = object()\r\n\r\n...\r\n\r\ndef __init__(self, response=None, text=None, type=None, root=_NOT_SET, **kwargs):\r\n        if response is not None and text is not None:\r\n            raise ValueError(\r\n                f\"{self.__class__.__name__}.__init__() received \"\r\n                \"both response and text\"\r\n            )\r\n        st = _st(response, type)\r\n        if text is not None:\r\n            response = _response_from_text(text, st)\r\n        if response is not None:\r\n            text = response.text\r\n            kwargs.setdefault(\"base_url\", response.url)\r\n        self.response = response\r\n        if root is not _NOT_SET:\r\n            kwargs[\"root\"] = root\r\n        super().__init__(text=text, type=st, **kwargs)\r\n```",
      "comment_id": 1184623260,
      "user": "Gallaecio",
      "created_at": "2023-05-04T07:08:13Z",
      "url": "https://github.com/scrapy/scrapy/pull/5918#discussion_r1184623260"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 5918,
      "file_path": "scrapy/selector/unified.py",
      "line": 71,
      "side": "RIGHT",
      "diff_hunk": "@@ -63,7 +68,7 @@ class Selector(_ParselSelector, object_ref):\n     __slots__ = [\"response\"]\n     selectorlist_cls = SelectorList\n \n-    def __init__(self, response=None, text=None, type=None, root=None, **kwargs):\n+    def __init__(self, response=None, text=None, type=None, root=_NOT_SET, **kwargs):",
      "comment": "@Gallaecio @Laerte \r\nTechnically it will work.\r\nHovewer I don't like any option that make this check on each call of Selector `__init__`.\r\n\r\nOn spider like this:\r\n```python\r\n\r\n    def start_requests(self):\r\n        yield scrapy.Request(url='http://quotes.toscrape.com/', callback=self.parse)\r\n\r\n    def parse(self, response):\r\n        links = response.css('a::attr(href)')\r\n        if next_page := response.css(\"li.next a::attr(href)\").get():\r\n            yield scrapy.Request(url=response.urljoin(next_page), callback=self.parse)\r\n```\r\n\r\n`__init__` of selector will be called ~50 times per response. On a real case it can be hundreds or even thousands calls of `Selector.__init__` per response.\r\nOn applying this - application will make additional +hudnreds/thousands checks of `_NOT_SET` per response. While on initial proposal - related code check will be executed only one time on startup (+root assignment on init). However i din't make detailed profiler tests yet.\r\n",
      "comment_id": 1184760794,
      "user": "GeorgeA92",
      "created_at": "2023-05-04T09:17:25Z",
      "url": "https://github.com/scrapy/scrapy/pull/5918#discussion_r1184760794"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 5876,
      "file_path": "scrapy/extensions/feedexport.py",
      "line": 315,
      "side": "RIGHT",
      "diff_hunk": "@@ -310,6 +312,8 @@ def finish_exporting(self):\n \n \n class FeedExporter:\n+    pending_deferreds = []",
      "comment": "Any reason *not* to make it private?\r\n\r\n```suggestion\r\n    _pending_deferreds = []\r\n```\r\n\r\nWe usually make things private unless we have a reason to make them public. It makes it easier to implement future changes by not being bound by backward compatibility promises.",
      "comment_id": 1152314384,
      "user": "Gallaecio",
      "created_at": "2023-03-29T18:06:28Z",
      "url": "https://github.com/scrapy/scrapy/pull/5876#discussion_r1152314384"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 5876,
      "file_path": "scrapy/extensions/feedexport.py",
      "line": 415,
      "side": "RIGHT",
      "diff_hunk": "@@ -397,6 +407,15 @@ def _close_slot(self, slot, spider):\n         d.addErrback(\n             self._handle_store_error, logmsg, spider, type(slot.storage).__name__\n         )\n+\n+        self.pending_deferreds.append(d)\n+        d.addCallback(\n+            lambda _: self.crawler.signals.send_catch_log(\n+                signals.feed_slot_closed, slot=slot\n+            )",
      "comment": "No strong opinion on it, but I wonder if it would not make sense to make this signal also awaitable, like `feed_exporter_closed`, since it might not be that much extra work.",
      "comment_id": 1152317740,
      "user": "Gallaecio",
      "created_at": "2023-03-29T18:09:53Z",
      "url": "https://github.com/scrapy/scrapy/pull/5876#discussion_r1152317740"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 5876,
      "file_path": "scrapy/extensions/feedexport.py",
      "line": 415,
      "side": "RIGHT",
      "diff_hunk": "@@ -397,6 +407,15 @@ def _close_slot(self, slot, spider):\n         d.addErrback(\n             self._handle_store_error, logmsg, spider, type(slot.storage).__name__\n         )\n+\n+        self.pending_deferreds.append(d)\n+        d.addCallback(\n+            lambda _: self.crawler.signals.send_catch_log(\n+                signals.feed_slot_closed, slot=slot\n+            )",
      "comment": "I addressed the changes above and this one. I can't think of any other change than using send_catch_log_deferred, I added some tests and it works. Is that what you were referring to?",
      "comment_id": 1153340695,
      "user": "guillermo-bondonno",
      "created_at": "2023-03-30T14:21:01Z",
      "url": "https://github.com/scrapy/scrapy/pull/5876#discussion_r1153340695"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 5901,
      "file_path": "scrapy/utils/curl.py",
      "line": 14,
      "side": "RIGHT",
      "diff_hunk": "@@ -7,6 +8,13 @@\n from w3lib.http import basic_auth_header\n \n \n+class DataAction(argparse.Action):\n+    def __call__(self, parser, namespace, values, option_string=None):\n+        value = str(values).encode(\"utf-8\").decode(\"utf-8\")\n+        value = value[1::] if re.match(r\"^\\$(.+)\", value) else value",
      "comment": "This feels over complicated.\r\n\r\nWouldn\u2019t something like this work?\r\n\r\n```suggestion\r\n        value = str(values)\r\n        if value.startswith(\"$\"):\r\n            value = value[1:]\r\n```\r\n\r\n",
      "comment_id": 1170874472,
      "user": "Gallaecio",
      "created_at": "2023-04-19T06:43:31Z",
      "url": "https://github.com/scrapy/scrapy/pull/5901#discussion_r1170874472"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 5898,
      "file_path": "tests/test_feedexport.py",
      "line": 2401,
      "side": "RIGHT",
      "diff_hunk": "@@ -2398,7 +2398,7 @@ def test_export_items(self):\n         yield self.assertExported(items, header, rows, settings=settings)\n \n     def test_wrong_path(self):\n-        \"\"\"If path is without %(batch_time)s and %(batch_id) an exception must be raised\"\"\"\n+        \"\"\"If path is without %(batch_id) an exception must be raised\"\"\"",
      "comment": "Click on accept suggestion for a free merge!\r\n\r\n```suggestion\r\n        \"\"\"If path is without %(batch_time)s and %(batch_id) an exception must be raised\"\"\"\r\n```",
      "comment_id": 1170120537,
      "user": "felipeboffnunes",
      "created_at": "2023-04-18T14:23:40Z",
      "url": "https://github.com/scrapy/scrapy/pull/5898#discussion_r1170120537"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 5898,
      "file_path": "tests/test_feedexport.py",
      "line": 2401,
      "side": "RIGHT",
      "diff_hunk": "@@ -2398,7 +2398,7 @@ def test_export_items(self):\n         yield self.assertExported(items, header, rows, settings=settings)\n \n     def test_wrong_path(self):\n-        \"\"\"If path is without %(batch_time)s and %(batch_id) an exception must be raised\"\"\"\n+        \"\"\"If path is without %(batch_id) an exception must be raised\"\"\"",
      "comment": "Just saw this suggestion now, but I also added commit that does the same thing",
      "comment_id": 1170463933,
      "user": "tstauder",
      "created_at": "2023-04-18T19:07:12Z",
      "url": "https://github.com/scrapy/scrapy/pull/5898#discussion_r1170463933"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 5892,
      "file_path": "scrapy/utils/request.py",
      "line": 353,
      "side": "RIGHT",
      "diff_hunk": "@@ -327,3 +327,35 @@ def _get_method(obj, name):\n         return getattr(obj, name)\n     except AttributeError:\n         raise ValueError(f\"Method {name!r} not found in: {obj}\")\n+\n+\n+def request_to_curl(request: Request) -> str:\n+    \"\"\"\n+    Converts a :class:`~scrapy.Request` object to a curl command.\n+\n+    :param :class:`~scrapy.Request`: Request object to be converted\n+    :return: string containing the curl command\n+    \"\"\"\n+    method = request.method\n+    data = (\n+        \"--data-raw '{}'\".format(request.body.decode(\"utf-8\")) if request.body else \"\"\n+    )\n+    headers = \" \".join(\n+        \"-H '{}: {}'\".format(k.decode(), v[0].decode())\n+        for k, v in request.headers.items()\n+    )\n+    url = request.url\n+    cookies = \"\"\n+    if isinstance(request.cookies, dict) and request.cookies:\n+        cookies = \"--cookie '{}'\".format(\n+            \"; \".join(\"{}={}\".format(k, v) for k, v in request.cookies.items())\n+        )\n+    elif isinstance(request.cookies, list):",
      "comment": "Maybe this also needs a check that the list is not empty?",
      "comment_id": 1163232883,
      "user": "wRAR",
      "created_at": "2023-04-11T19:22:47Z",
      "url": "https://github.com/scrapy/scrapy/pull/5892#discussion_r1163232883"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 5892,
      "file_path": "scrapy/utils/request.py",
      "line": 353,
      "side": "RIGHT",
      "diff_hunk": "@@ -327,3 +327,35 @@ def _get_method(obj, name):\n         return getattr(obj, name)\n     except AttributeError:\n         raise ValueError(f\"Method {name!r} not found in: {obj}\")\n+\n+\n+def request_to_curl(request: Request) -> str:\n+    \"\"\"\n+    Converts a :class:`~scrapy.Request` object to a curl command.\n+\n+    :param :class:`~scrapy.Request`: Request object to be converted\n+    :return: string containing the curl command\n+    \"\"\"\n+    method = request.method\n+    data = (\n+        \"--data-raw '{}'\".format(request.body.decode(\"utf-8\")) if request.body else \"\"\n+    )\n+    headers = \" \".join(\n+        \"-H '{}: {}'\".format(k.decode(), v[0].decode())\n+        for k, v in request.headers.items()\n+    )\n+    url = request.url\n+    cookies = \"\"\n+    if isinstance(request.cookies, dict) and request.cookies:\n+        cookies = \"--cookie '{}'\".format(\n+            \"; \".join(\"{}={}\".format(k, v) for k, v in request.cookies.items())\n+        )\n+    elif isinstance(request.cookies, list):",
      "comment": "Makes sense. The default is an empty dict, but I guess it is possible that an empty list ends up there.",
      "comment_id": 1164093245,
      "user": "guillermo-bondonno",
      "created_at": "2023-04-12T12:53:04Z",
      "url": "https://github.com/scrapy/scrapy/pull/5892#discussion_r1164093245"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 5885,
      "file_path": "tests/test_utils_python.py",
      "line": 243,
      "side": "RIGHT",
      "diff_hunk": "@@ -235,20 +235,15 @@ def __call__(self, a, b, c):\n         self.assertEqual(get_func_args(partial_f3), [\"c\"])\n         self.assertEqual(get_func_args(cal), [\"a\", \"b\", \"c\"])\n         self.assertEqual(get_func_args(object), [])\n+        self.assertEqual(get_func_args(str.split, stripself=True), [\"sep\", \"maxsplit\"])\n+        self.assertEqual(get_func_args(\" \".join, stripself=True), [\"iterable\"])\n \n         if platform.python_implementation() == \"CPython\":\n-            # TODO: how do we fix this to return the actual argument names?\n-            self.assertEqual(get_func_args(str.split), [])\n-            self.assertEqual(get_func_args(\" \".join), [])\n             self.assertEqual(get_func_args(operator.itemgetter(2)), [])\n-        elif platform.python_implementation() == \"PyPy\":\n-            self.assertEqual(\n-                get_func_args(str.split, stripself=True), [\"sep\", \"maxsplit\"]\n-            )\n+        if platform.python_implementation() == \"PyPy\":",
      "comment": "```suggestion\r\n        elif platform.python_implementation() == \"PyPy\":\r\n```",
      "comment_id": 1161844082,
      "user": "Gallaecio",
      "created_at": "2023-04-10T15:57:58Z",
      "url": "https://github.com/scrapy/scrapy/pull/5885#discussion_r1161844082"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 5885,
      "file_path": "tests/test_utils_python.py",
      "line": 242,
      "side": "RIGHT",
      "diff_hunk": "@@ -235,20 +235,15 @@ def __call__(self, a, b, c):\n         self.assertEqual(get_func_args(partial_f3), [\"c\"])\n         self.assertEqual(get_func_args(cal), [\"a\", \"b\", \"c\"])\n         self.assertEqual(get_func_args(object), [])\n+        self.assertEqual(get_func_args(str.split, stripself=True), [\"sep\", \"maxsplit\"])\n+        self.assertEqual(get_func_args(\" \".join, stripself=True), [\"iterable\"])\n \n         if platform.python_implementation() == \"CPython\":\n-            # TODO: how do we fix this to return the actual argument names?\n-            self.assertEqual(get_func_args(str.split), [])\n-            self.assertEqual(get_func_args(\" \".join), [])\n             self.assertEqual(get_func_args(operator.itemgetter(2)), [])",
      "comment": "Maybe we could add a relevant link as a comment for future reference? https://bugs.python.org/issue42785 ?",
      "comment_id": 1161846199,
      "user": "Gallaecio",
      "created_at": "2023-04-10T15:59:50Z",
      "url": "https://github.com/scrapy/scrapy/pull/5885#discussion_r1161846199"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 5885,
      "file_path": "tests/test_utils_python.py",
      "line": 242,
      "side": "RIGHT",
      "diff_hunk": "@@ -235,20 +235,15 @@ def __call__(self, a, b, c):\n         self.assertEqual(get_func_args(partial_f3), [\"c\"])\n         self.assertEqual(get_func_args(cal), [\"a\", \"b\", \"c\"])\n         self.assertEqual(get_func_args(object), [])\n+        self.assertEqual(get_func_args(str.split, stripself=True), [\"sep\", \"maxsplit\"])\n+        self.assertEqual(get_func_args(\" \".join, stripself=True), [\"iterable\"])\n \n         if platform.python_implementation() == \"CPython\":\n-            # TODO: how do we fix this to return the actual argument names?\n-            self.assertEqual(get_func_args(str.split), [])\n-            self.assertEqual(get_func_args(\" \".join), [])\n             self.assertEqual(get_func_args(operator.itemgetter(2)), [])",
      "comment": "```suggestion\r\n            # doesn't work on CPython: https://bugs.python.org/issue42785\r\n            self.assertEqual(get_func_args(operator.itemgetter(2)), [])\r\n```",
      "comment_id": 1165276225,
      "user": "wRAR",
      "created_at": "2023-04-13T09:37:30Z",
      "url": "https://github.com/scrapy/scrapy/pull/5885#discussion_r1165276225"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 5581,
      "file_path": "scrapy/extensions/feedexport.py",
      "line": 356,
      "side": "RIGHT",
      "diff_hunk": "@@ -350,13 +350,19 @@ def close_spider(self, spider):\n         return defer.DeferredList(deferred_list) if deferred_list else None\n \n     def _close_slot(self, slot, spider):\n+\n+        def get_file(slot_):\n+            if isinstance(slot_.file, PostProcessingManager):\n+                return slot_.file.file",
      "comment": "After a quick glance at the failures, I am thinking we may need to close PostProcessingManager without closing the underlying file. Calling `slot_.close()` here before `return` may be enough.",
      "comment_id": 932952058,
      "user": "Gallaecio",
      "created_at": "2022-07-29T07:33:56Z",
      "url": "https://github.com/scrapy/scrapy/pull/5581#discussion_r932952058"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 5808,
      "file_path": "scrapy/utils/template.py",
      "line": 14,
      "side": "RIGHT",
      "diff_hunk": "@@ -7,10 +7,14 @@\n from typing import Union\n \n \n-def render_templatefile(path: Union[str, PathLike], **kwargs):\n+def render_templatefile(path: Union[str, PathLike], url=None, **kwargs):\n     path_obj = Path(path)\n     raw = path_obj.read_text(\"utf8\")\n \n+    if url and url.lower().startswith(\"https\"):",
      "comment": "So `httpsecurityoff.example` would use `https://` instead of `http://` after this change?",
      "comment_id": 1088982654,
      "user": "Gallaecio",
      "created_at": "2023-01-27T13:50:12Z",
      "url": "https://github.com/scrapy/scrapy/pull/5808#discussion_r1088982654"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 5808,
      "file_path": "scrapy/utils/template.py",
      "line": 14,
      "side": "RIGHT",
      "diff_hunk": "@@ -7,10 +7,14 @@\n from typing import Union\n \n \n-def render_templatefile(path: Union[str, PathLike], **kwargs):\n+def render_templatefile(path: Union[str, PathLike], url=None, **kwargs):\n     path_obj = Path(path)\n     raw = path_obj.read_text(\"utf8\")\n \n+    if url and url.lower().startswith(\"https\"):",
      "comment": "good point, I will change to properly parse the url schema.",
      "comment_id": 1089368254,
      "user": "alexpdev",
      "created_at": "2023-01-27T19:48:17Z",
      "url": "https://github.com/scrapy/scrapy/pull/5808#discussion_r1089368254"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 5808,
      "file_path": "tests/test_commands.py",
      "line": 549,
      "side": "LEFT",
      "diff_hunk": "@@ -542,13 +542,6 @@ def test_url(self, url=\"test.com\", domain=\"test.com\"):\n                 r\"allowed_domains\\s*=\\s*\\[\\'(.+)\\'\\]\",\n             ).group(1),\n         )\n-        self.assertEqual(\n-            f\"http://{domain}/\",\n-            self.find_in_file(\n-                Path(self.proj_mod_path, \"spiders\", \"test_name.py\"),\n-                r\"start_urls\\s*=\\s*\\[\\'(.+)\\'\\]\",\n-            ).group(1),\n-        )",
      "comment": "This should continue to pass, i.e. if users pass a domain things should work as before, although maybe we should use `https` by default instead of `http`.",
      "comment_id": 1090317918,
      "user": "Gallaecio",
      "created_at": "2023-01-30T08:45:16Z",
      "url": "https://github.com/scrapy/scrapy/pull/5808#discussion_r1090317918"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 5808,
      "file_path": "tests/test_commands.py",
      "line": 549,
      "side": "LEFT",
      "diff_hunk": "@@ -542,13 +542,6 @@ def test_url(self, url=\"test.com\", domain=\"test.com\"):\n                 r\"allowed_domains\\s*=\\s*\\[\\'(.+)\\'\\]\",\n             ).group(1),\n         )\n-        self.assertEqual(\n-            f\"http://{domain}/\",\n-            self.find_in_file(\n-                Path(self.proj_mod_path, \"spiders\", \"test_name.py\"),\n-                r\"start_urls\\s*=\\s*\\[\\'(.+)\\'\\]\",\n-            ).group(1),\n-        )",
      "comment": "The only reason it didn't pass was because of the test on line 559:\r\n\r\n```\r\ndef test_url_schema_path(self):\r\n        self.test_url(\"https://test.com/some/other/page\", \"test.com\")\r\n```\r\n\r\nWith my changes it would convert the `http` to a `https`  and the `assertEqual` would be false.  I suppose I should have just changed the the url in the subtest to a `http` but that didn't occur to me at the time.\r\n\r\n--------------------------------------------\r\nEDIT:\r\n\r\nThat was the original reason why I removed it, but after just attempting to add it back in I realized it also doesn't work because the new changes substitute the the full URL.  So neither of the tests below would pass because the `.../other/page` parts wouldn't be an exact match.\r\n\r\n```\r\ndef test_url_path(self):\r\n    self.test_url(\"test.com/some/other/page\", \"test.com\")\r\n\r\ndef test_url_schema_path(self):\r\n    self.test_url(\"https://test.com/some/other/page\", \"test.com\")\r\n```\r\n",
      "comment_id": 1090689160,
      "user": "alexpdev",
      "created_at": "2023-01-30T14:22:05Z",
      "url": "https://github.com/scrapy/scrapy/pull/5808#discussion_r1090689160"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 5808,
      "file_path": "tests/test_commands.py",
      "line": 549,
      "side": "LEFT",
      "diff_hunk": "@@ -542,13 +542,6 @@ def test_url(self, url=\"test.com\", domain=\"test.com\"):\n                 r\"allowed_domains\\s*=\\s*\\[\\'(.+)\\'\\]\",\n             ).group(1),\n         )\n-        self.assertEqual(\n-            f\"http://{domain}/\",\n-            self.find_in_file(\n-                Path(self.proj_mod_path, \"spiders\", \"test_name.py\"),\n-                r\"start_urls\\s*=\\s*\\[\\'(.+)\\'\\]\",\n-            ).group(1),\n-        )",
      "comment": "I added it back in but changed it to and `AssertIn` instead of `AssertEqual` statement so that it would pass.",
      "comment_id": 1092538207,
      "user": "alexpdev",
      "created_at": "2023-01-31T22:14:28Z",
      "url": "https://github.com/scrapy/scrapy/pull/5808#discussion_r1092538207"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 5808,
      "file_path": "tests/test_commands.py",
      "line": 546,
      "side": "RIGHT",
      "diff_hunk": "@@ -542,8 +542,8 @@ def test_url(self, url=\"test.com\", domain=\"test.com\"):\n                 r\"allowed_domains\\s*=\\s*\\[\\'(.+)\\'\\]\",\n             ).group(1),\n         )\n-        self.assertEqual(\n-            f\"http://{domain}/\",\n+        self.assertIn(\n+            domain,",
      "comment": "Instead of just checking that the domain is in the code, check with a protocol, but use `https` if `http` is not the right choice.\r\n\r\nMy concern here is that I think the proposed change causes something like `start_urls=[\"example.com\"]` when you pass `example.com`, and the right output would be `start_urls=[\"https://example.com\"]` or `start_urls=[\"https://example.com/\"]`. So I think you may need to check if the input parameter is a URL, and if it is a domain instead, you need to convert it into an URL before you feed it into the template.",
      "comment_id": 1093135801,
      "user": "Gallaecio",
      "created_at": "2023-02-01T12:09:28Z",
      "url": "https://github.com/scrapy/scrapy/pull/5808#discussion_r1093135801"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 5808,
      "file_path": "tests/test_commands.py",
      "line": 642,
      "side": "RIGHT",
      "diff_hunk": "@@ -550,13 +551,95 @@ def test_url(self, url=\"test.com\", domain=\"test.com\"):\n         )\n \n     def test_url_schema(self):\n-        self.test_url(\"http://test.com\", \"test.com\")\n+        self.test_url(\"http://test.com/\", \"test.com\")\n \n     def test_url_path(self):\n         self.test_url(\"test.com/some/other/page\", \"test.com\")\n \n-    def test_url_schema_path(self):\n-        self.test_url(\"https://test.com/some/other/page\", \"test.com\")\n+    def test_start_urls_schema(self, template=\"basic\", url=\"test.com\", schema=\"http\"):\n+        self.assertEqual(\n+            0, self.call(\"genspider\", \"--force\", \"-t\", template, \"test_name\", url)\n+        )\n+        self.assertEqual(\n+            schema,\n+            self.find_in_file(\n+                Path(self.proj_mod_path, \"spiders\", \"test_name.py\"),\n+                r'start_urls\\s*=\\s*\\[[\\'\"](.+)://',\n+            ).group(1),\n+        )\n+\n+    def test_https_url_schema_templates(self):\n+        self.test_start_urls_schema(\n+            template=\"basic\", url=\"https://test.com\", schema=\"https\"\n+        )\n+        self.test_start_urls_schema(\n+            template=\"crawl\", url=\"https://test.com\", schema=\"https\"\n+        )\n+        self.test_start_urls_schema(\n+            template=\"xmlfeed\", url=\"https://test.com\", schema=\"https\"\n+        )\n+        self.test_start_urls_schema(\n+            template=\"csvfeed\", url=\"https://test.com\", schema=\"https\"\n+        )\n+\n+    def test_http_url_schema_templates(self):\n+        self.test_start_urls_schema(\n+            template=\"basic\", url=\"http://test.com\", schema=\"http\"\n+        )\n+        self.test_start_urls_schema(\n+            template=\"crawl\", url=\"http://test.com\", schema=\"http\"\n+        )\n+        self.test_start_urls_schema(\n+            template=\"xmlfeed\", url=\"http://test.com\", schema=\"http\"\n+        )\n+        self.test_start_urls_schema(\n+            template=\"csvfeed\", url=\"http://test.com\", schema=\"http\"\n+        )\n+\n+    def test_start_urls_matches_input(self, template=\"basic\", url=\"https://test.com\"):\n+        self.assertEqual(\n+            0, self.call(\"genspider\", \"--force\", \"-t\", template, \"test_name\", url)\n+        )\n+        self.assertEqual(\n+            url,\n+            self.find_in_file(\n+                Path(self.proj_mod_path, \"spiders\", \"test_name.py\"),\n+                r'start_urls\\s*=\\s*\\[[\\'\"](.+)[\\'\"]\\]',\n+            ).group(1),\n+        )\n+\n+    def test_start_urls_substitution_with_schema(self):\n+        self.test_start_urls_matches_input(\n+            template=\"basic\", url=\"https://test.com/full/path\"\n+        )\n+        self.test_start_urls_matches_input(\n+            template=\"xmlfeed\", url=\"https://test.com/full/path\"\n+        )\n+        self.test_start_urls_matches_input(\n+            template=\"crawl\", url=\"https://test.com/full/path\"\n+        )\n+        self.test_start_urls_matches_input(\n+            template=\"csvfeed\", url=\"https://test.com/full/path\"\n+        )\n+\n+    def test_start_urls_no_schema(self, template=\"basic\", url=\"test.com\"):\n+        self.assertEqual(\n+            0, self.call(\"genspider\", \"--force\", \"-t\", template, \"test_name\", url)\n+        )\n+        domain = extract_domain(url)\n+        self.assertEqual(\n+            domain,\n+            self.find_in_file(\n+                Path(self.proj_mod_path, \"spiders\", \"test_name.py\"),\n+                r'start_urls\\s*=\\s*\\[[\\'\"]http://(.+)/.*?[\\'\"]\\]',\n+            ).group(1),\n+        )\n+\n+    def test_start_urls_substitution_no_schema(self):\n+        self.test_start_urls_no_schema(template=\"basic\", url=\"example.com\")\n+        self.test_start_urls_no_schema(template=\"crawl\", url=\"example.com\")\n+        self.test_start_urls_no_schema(template=\"xmlfeed\", url=\"example.com/full/path\")\n+        self.test_start_urls_no_schema(template=\"csvfeed\", url=\"example.com/full/path\")",
      "comment": "Interesting case. I wonder if we should support it differently. But it is a rare case, and the solution is simple (use a proper URL!), so it might not be worth the trouble.",
      "comment_id": 1093973715,
      "user": "Gallaecio",
      "created_at": "2023-02-02T03:23:23Z",
      "url": "https://github.com/scrapy/scrapy/pull/5808#discussion_r1093973715"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 5808,
      "file_path": "tests/test_commands.py",
      "line": 642,
      "side": "RIGHT",
      "diff_hunk": "@@ -550,13 +551,95 @@ def test_url(self, url=\"test.com\", domain=\"test.com\"):\n         )\n \n     def test_url_schema(self):\n-        self.test_url(\"http://test.com\", \"test.com\")\n+        self.test_url(\"http://test.com/\", \"test.com\")\n \n     def test_url_path(self):\n         self.test_url(\"test.com/some/other/page\", \"test.com\")\n \n-    def test_url_schema_path(self):\n-        self.test_url(\"https://test.com/some/other/page\", \"test.com\")\n+    def test_start_urls_schema(self, template=\"basic\", url=\"test.com\", schema=\"http\"):\n+        self.assertEqual(\n+            0, self.call(\"genspider\", \"--force\", \"-t\", template, \"test_name\", url)\n+        )\n+        self.assertEqual(\n+            schema,\n+            self.find_in_file(\n+                Path(self.proj_mod_path, \"spiders\", \"test_name.py\"),\n+                r'start_urls\\s*=\\s*\\[[\\'\"](.+)://',\n+            ).group(1),\n+        )\n+\n+    def test_https_url_schema_templates(self):\n+        self.test_start_urls_schema(\n+            template=\"basic\", url=\"https://test.com\", schema=\"https\"\n+        )\n+        self.test_start_urls_schema(\n+            template=\"crawl\", url=\"https://test.com\", schema=\"https\"\n+        )\n+        self.test_start_urls_schema(\n+            template=\"xmlfeed\", url=\"https://test.com\", schema=\"https\"\n+        )\n+        self.test_start_urls_schema(\n+            template=\"csvfeed\", url=\"https://test.com\", schema=\"https\"\n+        )\n+\n+    def test_http_url_schema_templates(self):\n+        self.test_start_urls_schema(\n+            template=\"basic\", url=\"http://test.com\", schema=\"http\"\n+        )\n+        self.test_start_urls_schema(\n+            template=\"crawl\", url=\"http://test.com\", schema=\"http\"\n+        )\n+        self.test_start_urls_schema(\n+            template=\"xmlfeed\", url=\"http://test.com\", schema=\"http\"\n+        )\n+        self.test_start_urls_schema(\n+            template=\"csvfeed\", url=\"http://test.com\", schema=\"http\"\n+        )\n+\n+    def test_start_urls_matches_input(self, template=\"basic\", url=\"https://test.com\"):\n+        self.assertEqual(\n+            0, self.call(\"genspider\", \"--force\", \"-t\", template, \"test_name\", url)\n+        )\n+        self.assertEqual(\n+            url,\n+            self.find_in_file(\n+                Path(self.proj_mod_path, \"spiders\", \"test_name.py\"),\n+                r'start_urls\\s*=\\s*\\[[\\'\"](.+)[\\'\"]\\]',\n+            ).group(1),\n+        )\n+\n+    def test_start_urls_substitution_with_schema(self):\n+        self.test_start_urls_matches_input(\n+            template=\"basic\", url=\"https://test.com/full/path\"\n+        )\n+        self.test_start_urls_matches_input(\n+            template=\"xmlfeed\", url=\"https://test.com/full/path\"\n+        )\n+        self.test_start_urls_matches_input(\n+            template=\"crawl\", url=\"https://test.com/full/path\"\n+        )\n+        self.test_start_urls_matches_input(\n+            template=\"csvfeed\", url=\"https://test.com/full/path\"\n+        )\n+\n+    def test_start_urls_no_schema(self, template=\"basic\", url=\"test.com\"):\n+        self.assertEqual(\n+            0, self.call(\"genspider\", \"--force\", \"-t\", template, \"test_name\", url)\n+        )\n+        domain = extract_domain(url)\n+        self.assertEqual(\n+            domain,\n+            self.find_in_file(\n+                Path(self.proj_mod_path, \"spiders\", \"test_name.py\"),\n+                r'start_urls\\s*=\\s*\\[[\\'\"]http://(.+)/.*?[\\'\"]\\]',\n+            ).group(1),\n+        )\n+\n+    def test_start_urls_substitution_no_schema(self):\n+        self.test_start_urls_no_schema(template=\"basic\", url=\"example.com\")\n+        self.test_start_urls_no_schema(template=\"crawl\", url=\"example.com\")\n+        self.test_start_urls_no_schema(template=\"xmlfeed\", url=\"example.com/full/path\")\n+        self.test_start_urls_no_schema(template=\"csvfeed\", url=\"example.com/full/path\")",
      "comment": "I actually didn't mean to leave the `full/path` part on those.  I don't think it's necessary to handle differently.  \r\n\r\nI am going to remove the path extensions.",
      "comment_id": 1094075578,
      "user": "alexpdev",
      "created_at": "2023-02-02T06:06:25Z",
      "url": "https://github.com/scrapy/scrapy/pull/5808#discussion_r1094075578"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 5832,
      "file_path": "scrapy/utils/reactor.py",
      "line": 93,
      "side": "LEFT",
      "diff_hunk": "@@ -90,7 +90,6 @@ def _get_asyncio_event_loop():\n \n def set_asyncio_event_loop(event_loop_path):\n     \"\"\"Sets and returns the event loop with specified import path.\"\"\"\n-    policy = get_asyncio_event_loop_policy()",
      "comment": "Not calling this function will break Windows. This is actually visible in the tests.",
      "comment_id": 1108155669,
      "user": "wRAR",
      "created_at": "2023-02-16T08:29:35Z",
      "url": "https://github.com/scrapy/scrapy/pull/5832#discussion_r1108155669"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 5832,
      "file_path": "scrapy/utils/reactor.py",
      "line": 93,
      "side": "LEFT",
      "diff_hunk": "@@ -90,7 +90,6 @@ def _get_asyncio_event_loop():\n \n def set_asyncio_event_loop(event_loop_path):\n     \"\"\"Sets and returns the event loop with specified import path.\"\"\"\n-    policy = get_asyncio_event_loop_policy()",
      "comment": "It should work with acb62ea595a5cf8f4ec5fd97c17f03150de9d331.\r\n\r\nThe main problem at the moment is that testing these changes is tricky, as I don't use Windows. The only relevant and easy unit test I can think of is to check if `set_asyncio_event_loop() is asyncio.get_running_loop()`, but this tests some semantics more than anything else.",
      "comment_id": 1109920842,
      "user": "auxsvr",
      "created_at": "2023-02-17T14:51:36Z",
      "url": "https://github.com/scrapy/scrapy/pull/5832#discussion_r1109920842"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 5832,
      "file_path": "scrapy/utils/reactor.py",
      "line": 57,
      "side": "RIGHT",
      "diff_hunk": "@@ -54,7 +54,7 @@ def __call__(self):\n         return self._func(*self._a, **self._kw)\n \n \n-def get_asyncio_event_loop_policy():\n+def set_asyncio_event_loop_policy():",
      "comment": "For backward compatibility reasons, we should keep the old function around, and log a deprecation warning when called.",
      "comment_id": 1127575117,
      "user": "Gallaecio",
      "created_at": "2023-03-07T09:23:01Z",
      "url": "https://github.com/scrapy/scrapy/pull/5832#discussion_r1127575117"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 5328,
      "file_path": "scrapy/core/downloader/__init__.py",
      "line": 89,
      "side": "RIGHT",
      "diff_hunk": "@@ -83,6 +86,7 @@ def __init__(self, crawler):\n         self.middleware = DownloaderMiddlewareManager.from_crawler(crawler)\n         self._slot_gc_loop = task.LoopingCall(self._slot_gc)\n         self._slot_gc_loop.start(60)\n+        self.per_slot_settings = self.settings.getdict('PER_SLOT_SETTINGS', {})",
      "comment": "I\u2018m thinking that we could just name the setting `DOWNLOAD_SLOTS`, in line with the `FEEDS` setting and the `download_slot` meta key. I\u2018m not against something like `DOWNLOAD_SLOT_SETTINGS`, and I think an argument could me made that adding `SETTINGS` makes it clear that there may be more slots that those defined there (since we are not defining slots, but slot settings), but `DOWNLOAD_SLOTS` is shorter and seems to be unambiguous enough (we probably should still clarify in the documentation that slots not in the setting may still be used).",
      "comment_id": 755558817,
      "user": "Gallaecio",
      "created_at": "2021-11-23T22:42:56Z",
      "url": "https://github.com/scrapy/scrapy/pull/5328#discussion_r755558817"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 5328,
      "file_path": "scrapy/core/downloader/__init__.py",
      "line": 113,
      "side": "RIGHT",
      "diff_hunk": "@@ -99,9 +103,14 @@ def needs_backout(self):\n     def _get_slot(self, request, spider):\n         key = self._get_slot_key(request, spider)\n         if key not in self.slots:\n-            conc = self.ip_concurrency if self.ip_concurrency else self.domain_concurrency\n+            conc = self.per_slot_settings.get(key, {}).get('concurrency', self.ip_concurrency if self.ip_concurrency else self.domain_concurrency)\n             conc, delay = _get_concurrency_delay(conc, spider, self.settings)\n-            self.slots[key] = Slot(conc, delay, self.randomize_delay)\n+            delay = self.per_slot_settings.get(key, {}).get('delay', delay)\n+            randomize_delay = self.per_slot_settings.get(key, {}).get('randomize_delay', self.randomize_delay)\n+            new_slot = Slot(conc, delay, randomize_delay)\n+            self.slots[key] = new_slot\n+            logger.debug(\n+                f\"Downloader slot '{key}' - created {'(from per slot settings)' if key in self.per_slot_settings.keys() else ''}: {new_slot}\")",
      "comment": "I understand this may have helped while implementing this feature, but I am not sure we should keep these debug messages around.\r\n\r\nSame for the message below.",
      "comment_id": 755559874,
      "user": "Gallaecio",
      "created_at": "2021-11-23T22:45:13Z",
      "url": "https://github.com/scrapy/scrapy/pull/5328#discussion_r755559874"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 5328,
      "file_path": "scrapy/core/downloader/__init__.py",
      "line": 17,
      "side": "RIGHT",
      "diff_hunk": "@@ -12,6 +13,8 @@\n from scrapy.core.downloader.middleware import DownloaderMiddlewareManager\n from scrapy.core.downloader.handlers import DownloadHandlers\n \n+logger = logging.getLogger(__name__)\n+",
      "comment": "This and the corresponding import are not needed anymore.",
      "comment_id": 804581877,
      "user": "Gallaecio",
      "created_at": "2022-02-11T11:53:48Z",
      "url": "https://github.com/scrapy/scrapy/pull/5328#discussion_r804581877"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 5328,
      "file_path": "scrapy/core/downloader/__init__.py",
      "line": 106,
      "side": "RIGHT",
      "diff_hunk": "@@ -99,9 +100,14 @@ def needs_backout(self):\n     def _get_slot(self, request, spider):\n         key = self._get_slot_key(request, spider)\n         if key not in self.slots:\n-            conc = self.ip_concurrency if self.ip_concurrency else self.domain_concurrency\n+            conc = self.per_slot_settings.get(key, {}).get(\n+                'concurrency', self.ip_concurrency if self.ip_concurrency else self.domain_concurrency\n+            )\n             conc, delay = _get_concurrency_delay(conc, spider, self.settings)",
      "comment": "I believe this line can override per-slot concurrency if `spider.max_concurrent_requests` is defined, which I don\u2019t think is desirable. (I don\u2019t even think that attribute should exist, but that is a [separate issue](https://github.com/scrapy/scrapy/issues/5584)).\r\n\r\nIn addition to addressing this, it would be great to cover the issue with a test.",
      "comment_id": 933163347,
      "user": "Gallaecio",
      "created_at": "2022-07-29T11:58:09Z",
      "url": "https://github.com/scrapy/scrapy/pull/5328#discussion_r933163347"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 5328,
      "file_path": "scrapy/core/downloader/__init__.py",
      "line": 208,
      "side": "RIGHT",
      "diff_hunk": "@@ -198,4 +204,5 @@ def _slot_gc(self, age=60):\n         mintime = time() - age\n         for key, slot in list(self.slots.items()):\n             if not slot.active and slot.lastseen + slot.delay < mintime:\n-                self.slots.pop(key).close()\n+                inactive_slot = self.slots.pop(key)\n+                inactive_slot.close()",
      "comment": "According to Codecov this part is not covered by tests (it probably was not covered by tests before.\r\n\r\nIt seems functionally equivalent to the code before the change, so maybe you could just revert this change.\r\n\r\nI am OK with the change though, it is more readable. But if you are going to change it, it would be great if you could also extend test coverage for it. Although that may not be trivial.",
      "comment_id": 933167276,
      "user": "Gallaecio",
      "created_at": "2022-07-29T12:02:06Z",
      "url": "https://github.com/scrapy/scrapy/pull/5328#discussion_r933167276"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 5328,
      "file_path": "scrapy/core/downloader/__init__.py",
      "line": 208,
      "side": "RIGHT",
      "diff_hunk": "@@ -198,4 +204,5 @@ def _slot_gc(self, age=60):\n         mintime = time() - age\n         for key, slot in list(self.slots.items()):\n             if not slot.active and slot.lastseen + slot.delay < mintime:\n-                self.slots.pop(key).close()\n+                inactive_slot = self.slots.pop(key)\n+                inactive_slot.close()",
      "comment": "Yes. Sure (reverted changes). I previously made this change(assigning inactive slot to variable) for logging which is removed as result of previous feedback.",
      "comment_id": 944421255,
      "user": "GeorgeA92",
      "created_at": "2022-08-12T12:38:07Z",
      "url": "https://github.com/scrapy/scrapy/pull/5328#discussion_r944421255"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 5328,
      "file_path": "scrapy/core/downloader/__init__.py",
      "line": 108,
      "side": "RIGHT",
      "diff_hunk": "@@ -99,9 +100,14 @@ def needs_backout(self):\n     def _get_slot(self, request, spider):\n         key = self._get_slot_key(request, spider)\n         if key not in self.slots:\n-            conc = self.ip_concurrency if self.ip_concurrency else self.domain_concurrency\n+            conc = self.per_slot_settings.get(key, {}).get(\n+                'concurrency', self.ip_concurrency if self.ip_concurrency else self.domain_concurrency\n+            )\n             conc, delay = _get_concurrency_delay(conc, spider, self.settings)\n-            self.slots[key] = Slot(conc, delay, self.randomize_delay)\n+            delay = self.per_slot_settings.get(key, {}).get('delay', delay)\n+            randomize_delay = self.per_slot_settings.get(key, {}).get('randomize_delay', self.randomize_delay)",
      "comment": "A nitpick: what do you think about adding this variable:\r\n```py\r\nslot_settings = self.per_slot_settings.get(key, {})\r\n```\r\nIt seems it's used a few times here.",
      "comment_id": 996468254,
      "user": "kmike",
      "created_at": "2022-10-16T17:12:37Z",
      "url": "https://github.com/scrapy/scrapy/pull/5328#discussion_r996468254"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 5328,
      "file_path": "tests/test_downloaderslotssettings.py",
      "line": 73,
      "side": "RIGHT",
      "diff_hunk": "@@ -0,0 +1,75 @@\n+import time\n+\n+from scrapy.crawler import CrawlerRunner\n+from scrapy.http import Request\n+\n+from tests.mockserver import MockServer\n+from tests.spiders import MetaSpider\n+\n+from twisted.internet import defer\n+from twisted.trial.unittest import TestCase\n+\n+\n+class DownloaderSlotsSettingsTestSpider(MetaSpider):\n+\n+    name = 'downloader_slots'\n+\n+    custom_settings = {\n+        \"DOWNLOAD_DELAY\": 1,\n+        \"RANDOMIZE_DOWNLOAD_DELAY\": False,\n+        \"DOWNLOAD_SLOTS\": {\n+            'quotes.toscrape.com': {\n+                'concurrency': 1,\n+                'delay': 1.5,\n+                'randomize_delay': False\n+            },\n+            'books.toscrape.com': {\n+                'delay': 2,\n+                'randomize_delay': False\n+            }\n+        }\n+    }\n+\n+    def start_requests(self):\n+        self.times = {None: []}\n+\n+        slots = list(self.custom_settings.get('DOWNLOAD_SLOTS', {}).keys()) + [None]\n+\n+        for slot in slots:\n+            url = self.mockserver.url(f\"/?downloader_slot={slot}\")\n+            self.times[slot] = []\n+            yield Request(url, callback=self.parse, meta={'download_slot': slot})\n+\n+    def parse(self, response):\n+        slot = response.meta.get('download_slot', None)\n+        self.times[slot].append(time.time())\n+        url = self.mockserver.url(f\"/?downloader_slot={slot}&req=2\")\n+        yield Request(url, callback=self.not_parse, meta={'download_slot': slot})\n+\n+    def not_parse(self, response):\n+        slot = response.meta.get('download_slot', None)\n+        self.times[slot].append(time.time())\n+\n+\n+class CrawlTestCase(TestCase):\n+\n+    def setUp(self):\n+        self.mockserver = MockServer()\n+        self.mockserver.__enter__()\n+        self.runner = CrawlerRunner()\n+\n+    def tearDown(self):\n+        self.mockserver.__exit__(None, None, None)\n+\n+    @defer.inlineCallbacks\n+    def test_delay(self):\n+        crawler = CrawlerRunner().create_crawler(DownloaderSlotsSettingsTestSpider)\n+        yield crawler.crawl(mockserver=self.mockserver)\n+        slots = crawler.engine.downloader.slots\n+        times = crawler.spider.times\n+        tolerance = 0.3\n+\n+        delays_real = {k: v[1] - v[0] for k, v in times.items()}\n+        error_delta = {k: 1 - delays_real[k] / v.delay for k, v in slots.items()}",
      "comment": "So, for one slot in the tests the delay is 2s, for another it's 1.5s, and it's 1s for the default. Let's say implementation is incorrect, and in all cases delay of 2s is used. error_delta values would be `1 - 2/1.5 = -0.33` and `(1-2/1 = 01)`. The assertion below will pass: `max(-0.33, -1) = -0.33 < 0.3` is True.\r\n\r\nIf the 1.5s delay is used instead of 2s delay, then error_delta values would be `1 - 1.5/2 = 0.25`. `0.25 < 0.3` is True again. It may catch the default 1s download delay though.\r\n\r\nMaybe there are reasons these tests may detect an issue (e.g. default DOWNLOAD_DELAY), but I think it could make sense to try improving them. Have you encountered issues with a simpler implementation, something like `abs(delays_real[k] - v.delay) < tolerance`?",
      "comment_id": 996470278,
      "user": "kmike",
      "created_at": "2022-10-16T17:30:29Z",
      "url": "https://github.com/scrapy/scrapy/pull/5328#discussion_r996470278"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 5328,
      "file_path": "tests/test_downloaderslotssettings.py",
      "line": 73,
      "side": "RIGHT",
      "diff_hunk": "@@ -0,0 +1,75 @@\n+import time\n+\n+from scrapy.crawler import CrawlerRunner\n+from scrapy.http import Request\n+\n+from tests.mockserver import MockServer\n+from tests.spiders import MetaSpider\n+\n+from twisted.internet import defer\n+from twisted.trial.unittest import TestCase\n+\n+\n+class DownloaderSlotsSettingsTestSpider(MetaSpider):\n+\n+    name = 'downloader_slots'\n+\n+    custom_settings = {\n+        \"DOWNLOAD_DELAY\": 1,\n+        \"RANDOMIZE_DOWNLOAD_DELAY\": False,\n+        \"DOWNLOAD_SLOTS\": {\n+            'quotes.toscrape.com': {\n+                'concurrency': 1,\n+                'delay': 1.5,\n+                'randomize_delay': False\n+            },\n+            'books.toscrape.com': {\n+                'delay': 2,\n+                'randomize_delay': False\n+            }\n+        }\n+    }\n+\n+    def start_requests(self):\n+        self.times = {None: []}\n+\n+        slots = list(self.custom_settings.get('DOWNLOAD_SLOTS', {}).keys()) + [None]\n+\n+        for slot in slots:\n+            url = self.mockserver.url(f\"/?downloader_slot={slot}\")\n+            self.times[slot] = []\n+            yield Request(url, callback=self.parse, meta={'download_slot': slot})\n+\n+    def parse(self, response):\n+        slot = response.meta.get('download_slot', None)\n+        self.times[slot].append(time.time())\n+        url = self.mockserver.url(f\"/?downloader_slot={slot}&req=2\")\n+        yield Request(url, callback=self.not_parse, meta={'download_slot': slot})\n+\n+    def not_parse(self, response):\n+        slot = response.meta.get('download_slot', None)\n+        self.times[slot].append(time.time())\n+\n+\n+class CrawlTestCase(TestCase):\n+\n+    def setUp(self):\n+        self.mockserver = MockServer()\n+        self.mockserver.__enter__()\n+        self.runner = CrawlerRunner()\n+\n+    def tearDown(self):\n+        self.mockserver.__exit__(None, None, None)\n+\n+    @defer.inlineCallbacks\n+    def test_delay(self):\n+        crawler = CrawlerRunner().create_crawler(DownloaderSlotsSettingsTestSpider)\n+        yield crawler.crawl(mockserver=self.mockserver)\n+        slots = crawler.engine.downloader.slots\n+        times = crawler.spider.times\n+        tolerance = 0.3\n+\n+        delays_real = {k: v[1] - v[0] for k, v in times.items()}\n+        error_delta = {k: 1 - delays_real[k] / v.delay for k, v in slots.items()}",
      "comment": "This test implemented directly in the same way as existing test for `DOWNLOAD_DELAY` setting (counting that we need to test multiple downloader slots now)\r\nhttps://github.com/scrapy/scrapy/blob/80040758236ba1e35a4aa499faf33ed96fc12a92/tests/test_crawl.py#L85-L95\r\n\r\nOn my local tests `delays_real` calculated from `time.time` calls in spider by some unknown reason always a bit lower that delays from settings:\r\nfor delays [1, 1.5, 2] - I received [~0.90, ~1.43, ~ 1.90] in `delays_real`. So on this condition I don't expect issues from value that became negative.\r\nAnyway error calculation method updated to be sure that it will not happen.\r\n\r\nI also thought about increasing delay for test from [1, 1.5, 2] to for example [3, 5, 7] in this case with increased delays in test we can safely reduce `tolerance`.\r\n\r\nThe main question what is acceptable total time for this test?",
      "comment_id": 1026406781,
      "user": "GeorgeA92",
      "created_at": "2022-11-18T13:00:46Z",
      "url": "https://github.com/scrapy/scrapy/pull/5328#discussion_r1026406781"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 5328,
      "file_path": "tests/test_downloaderslotssettings.py",
      "line": 73,
      "side": "RIGHT",
      "diff_hunk": "@@ -0,0 +1,75 @@\n+import time\n+\n+from scrapy.crawler import CrawlerRunner\n+from scrapy.http import Request\n+\n+from tests.mockserver import MockServer\n+from tests.spiders import MetaSpider\n+\n+from twisted.internet import defer\n+from twisted.trial.unittest import TestCase\n+\n+\n+class DownloaderSlotsSettingsTestSpider(MetaSpider):\n+\n+    name = 'downloader_slots'\n+\n+    custom_settings = {\n+        \"DOWNLOAD_DELAY\": 1,\n+        \"RANDOMIZE_DOWNLOAD_DELAY\": False,\n+        \"DOWNLOAD_SLOTS\": {\n+            'quotes.toscrape.com': {\n+                'concurrency': 1,\n+                'delay': 1.5,\n+                'randomize_delay': False\n+            },\n+            'books.toscrape.com': {\n+                'delay': 2,\n+                'randomize_delay': False\n+            }\n+        }\n+    }\n+\n+    def start_requests(self):\n+        self.times = {None: []}\n+\n+        slots = list(self.custom_settings.get('DOWNLOAD_SLOTS', {}).keys()) + [None]\n+\n+        for slot in slots:\n+            url = self.mockserver.url(f\"/?downloader_slot={slot}\")\n+            self.times[slot] = []\n+            yield Request(url, callback=self.parse, meta={'download_slot': slot})\n+\n+    def parse(self, response):\n+        slot = response.meta.get('download_slot', None)\n+        self.times[slot].append(time.time())\n+        url = self.mockserver.url(f\"/?downloader_slot={slot}&req=2\")\n+        yield Request(url, callback=self.not_parse, meta={'download_slot': slot})\n+\n+    def not_parse(self, response):\n+        slot = response.meta.get('download_slot', None)\n+        self.times[slot].append(time.time())\n+\n+\n+class CrawlTestCase(TestCase):\n+\n+    def setUp(self):\n+        self.mockserver = MockServer()\n+        self.mockserver.__enter__()\n+        self.runner = CrawlerRunner()\n+\n+    def tearDown(self):\n+        self.mockserver.__exit__(None, None, None)\n+\n+    @defer.inlineCallbacks\n+    def test_delay(self):\n+        crawler = CrawlerRunner().create_crawler(DownloaderSlotsSettingsTestSpider)\n+        yield crawler.crawl(mockserver=self.mockserver)\n+        slots = crawler.engine.downloader.slots\n+        times = crawler.spider.times\n+        tolerance = 0.3\n+\n+        delays_real = {k: v[1] - v[0] for k, v in times.items()}\n+        error_delta = {k: 1 - delays_real[k] / v.delay for k, v in slots.items()}",
      "comment": "> The main question what is acceptable total time for this test?\r\n\r\nThe minimum value that still makes the test reliable, both in the sense that it does not break randomly, and that it indeed validates what it is meant to validate. If we need 30 seconds for that, so be it. But if it can be done in 5 seconds, that would be better.\r\n\r\n",
      "comment_id": 1027725321,
      "user": "Gallaecio",
      "created_at": "2022-11-21T08:49:40Z",
      "url": "https://github.com/scrapy/scrapy/pull/5328#discussion_r1027725321"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 5328,
      "file_path": "scrapy/core/downloader/__init__.py",
      "line": 106,
      "side": "RIGHT",
      "diff_hunk": "@@ -99,9 +100,14 @@ def needs_backout(self):\n     def _get_slot(self, request, spider):\n         key = self._get_slot_key(request, spider)\n         if key not in self.slots:\n-            conc = self.ip_concurrency if self.ip_concurrency else self.domain_concurrency\n+            conc = self.per_slot_settings.get(key, {}).get(\n+                'concurrency', self.ip_concurrency if self.ip_concurrency else self.domain_concurrency\n+            )\n             conc, delay = _get_concurrency_delay(conc, spider, self.settings)",
      "comment": "@Gallaecio \r\nNow per-slot settings takes precedence over settings from all other places. (Assuming that on https://github.com/scrapy/scrapy/issues/5584 we will have final decision about `spider.max_concurrent_request`)",
      "comment_id": 1108465690,
      "user": "GeorgeA92",
      "created_at": "2023-02-16T13:22:17Z",
      "url": "https://github.com/scrapy/scrapy/pull/5328#discussion_r1108465690"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 5801,
      "file_path": "scrapy/pipelines/files.py",
      "line": 75,
      "side": "RIGHT",
      "diff_hunk": "@@ -65,8 +71,8 @@ def stat_file(self, path: str, info):\n \n         return {\"last_modified\": last_modified, \"checksum\": checksum}\n \n-    def _get_filesystem_path(self, path: str) -> Path:\n-        path_comps = path.split(\"/\")\n+    def _get_filesystem_path(self, path: Union[str, PathLike]) -> Path:\n+        path_comps = _to_string(path).split(\"/\")",
      "comment": "Type-hint wise, I think this change also implies that code calling this function (e.g. the 2 methods above) now would also accept `Union[str, PathLike]`, so we should update their type hints accordingly.",
      "comment_id": 1093994431,
      "user": "Gallaecio",
      "created_at": "2023-02-02T04:18:05Z",
      "url": "https://github.com/scrapy/scrapy/pull/5801#discussion_r1093994431"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 5801,
      "file_path": "scrapy/pipelines/files.py",
      "line": 12,
      "side": "RIGHT",
      "diff_hunk": "@@ -9,12 +9,13 @@\n import mimetypes\n import os\n import time\n+from os import PathLike",
      "comment": "Note that the latest `master` has introduced `isort` and CI will fail due to this line. See https://docs.scrapy.org/en/latest/contributing.html#pre-commit, it will fix this when you merge or rebase from the latest `master`.",
      "comment_id": 1093995895,
      "user": "Gallaecio",
      "created_at": "2023-02-02T04:22:01Z",
      "url": "https://github.com/scrapy/scrapy/pull/5801#discussion_r1093995895"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 5805,
      "file_path": "scrapy/core/http2/agent.py",
      "line": 91,
      "side": "RIGHT",
      "diff_hunk": "@@ -83,7 +88,7 @@ def _remove_connection(self, errors: List[BaseException], key: Tuple) -> None:\n         pending_requests = self._pending_requests.pop(key, None)\n         while pending_requests:\n             d = pending_requests.popleft()\n-            d.errback(errors)\n+            d.errback(ResponseFailed(errors))",
      "comment": "This is indeed not covered and I guess this is why it wasn't caught by tests. ",
      "comment_id": 1116606576,
      "user": "wRAR",
      "created_at": "2023-02-24T07:34:23Z",
      "url": "https://github.com/scrapy/scrapy/pull/5805#discussion_r1116606576"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 5805,
      "file_path": "scrapy/core/scraper.py",
      "line": 206,
      "side": "RIGHT",
      "diff_hunk": "@@ -203,10 +203,12 @@ def call_spider(\n                 callback=callback, callbackKeywords=result.request.cb_kwargs\n             )\n         else:  # result is a Failure\n-            result.request = request\n+            # TODO: properly type adding this attribute to a Failure",
      "comment": "Is this TODO for this pull request or for a future one? (I\u2019m OK with both)",
      "comment_id": 1116607695,
      "user": "Gallaecio",
      "created_at": "2023-02-24T07:36:02Z",
      "url": "https://github.com/scrapy/scrapy/pull/5805#discussion_r1116607695"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 5805,
      "file_path": "scrapy/core/scraper.py",
      "line": 211,
      "side": "RIGHT",
      "diff_hunk": "@@ -203,10 +203,12 @@ def call_spider(\n                 callback=callback, callbackKeywords=result.request.cb_kwargs\n             )\n         else:  # result is a Failure\n-            result.request = request\n+            # TODO: properly type adding this attribute to a Failure\n+            result.request = request  # type: ignore[attr-defined]\n             warn_on_generator_with_return_value(spider, request.errback)\n             dfd = defer_fail(result)\n-            dfd.addErrback(request.errback)\n+            if request.errback:\n+                dfd.addErrback(request.errback)",
      "comment": "`addErrback(None)` is allowed and does nothing, but it's not documented (there is a comment saying \"Default value used to be None\" so maybe it was documented before but is now kept for backwards compativility) so I changed this.",
      "comment_id": 1116608341,
      "user": "wRAR",
      "created_at": "2023-02-24T07:36:50Z",
      "url": "https://github.com/scrapy/scrapy/pull/5805#discussion_r1116608341"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 5814,
      "file_path": "tests/test_commands.py",
      "line": 548,
      "side": "RIGHT",
      "diff_hunk": "@@ -538,14 +538,14 @@ def test_url(self, url=\"test.com\", domain=\"test.com\"):\n             domain,\n             self.find_in_file(\n                 Path(self.proj_mod_path, \"spiders\", \"test_name.py\"),\n-                r\"allowed_domains\\s*=\\s*\\[\\'(.+)\\'\\]\",\n+                r\"allowed_domains\\s*=\\s*\\[['\\\"](.+)['\\\"]\\]\",\n             ).group(1),\n         )\n         self.assertEqual(\n             f\"http://{domain}/\",\n             self.find_in_file(\n                 Path(self.proj_mod_path, \"spiders\", \"test_name.py\"),\n-                r\"start_urls\\s*=\\s*\\[\\'(.+)\\'\\]\",\n+                r\"start_urls\\s*=\\s*\\[['\\\"](.+)['\\\"]\\]\",",
      "comment": "Looks like something accidental happened with this file.",
      "comment_id": 1093124462,
      "user": "Gallaecio",
      "created_at": "2023-02-01T11:57:40Z",
      "url": "https://github.com/scrapy/scrapy/pull/5814#discussion_r1093124462"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 5814,
      "file_path": "tests/test_commands.py",
      "line": 548,
      "side": "RIGHT",
      "diff_hunk": "@@ -538,14 +538,14 @@ def test_url(self, url=\"test.com\", domain=\"test.com\"):\n             domain,\n             self.find_in_file(\n                 Path(self.proj_mod_path, \"spiders\", \"test_name.py\"),\n-                r\"allowed_domains\\s*=\\s*\\[\\'(.+)\\'\\]\",\n+                r\"allowed_domains\\s*=\\s*\\[['\\\"](.+)['\\\"]\\]\",\n             ).group(1),\n         )\n         self.assertEqual(\n             f\"http://{domain}/\",\n             self.find_in_file(\n                 Path(self.proj_mod_path, \"spiders\", \"test_name.py\"),\n-                r\"start_urls\\s*=\\s*\\[\\'(.+)\\'\\]\",\n+                r\"start_urls\\s*=\\s*\\[['\\\"](.+)['\\\"]\\]\",",
      "comment": "No that was done intentionally... The regex now will detect single and double quotes.  The test fails otherwise, because it only tests for single quotes.",
      "comment_id": 1093777233,
      "user": "alexpdev",
      "created_at": "2023-02-01T22:01:56Z",
      "url": "https://github.com/scrapy/scrapy/pull/5814#discussion_r1093777233"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 5799,
      "file_path": "scrapy/http/request/__init__.py",
      "line": 32,
      "side": "RIGHT",
      "diff_hunk": "@@ -25,6 +25,12 @@ def NO_CALLBACK(*args, **kwargs):\n     :class:`~scrapy.http.Request`, it indicates that the request is not meant\n     to have a spider callback at all.\n \n+    For example:\n+\n+    .. code-block:: python\n+\n+       Request(\"https://example.com\", callback=NO_CALLBACK)",
      "comment": "I thought it best to add an example to make it clear that `()` should not be appended to the function name when assigning it to the `callback` parameter.",
      "comment_id": 1091707172,
      "user": "Gallaecio",
      "created_at": "2023-01-31T10:05:37Z",
      "url": "https://github.com/scrapy/scrapy/pull/5799#discussion_r1091707172"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 5798,
      "file_path": "tests/test_pipeline_images.py",
      "line": 45,
      "side": "LEFT",
      "diff_hunk": "@@ -31,18 +31,13 @@\n         skip_pillow = None\n \n \n-def _mocked_download_func(request, info):\n-    response = request.meta.get('response')\n-    return response() if callable(response) else response\n-\n-\n class ImagesPipelineTestCase(unittest.TestCase):\n \n     skip = skip_pillow\n \n     def setUp(self):\n         self.tempdir = mkdtemp()\n-        self.pipeline = ImagesPipeline(self.tempdir, download_func=_mocked_download_func)",
      "comment": "It is unused. I tried raising an exception from the download function, and the tests passed nonetheless, indicating that it is not actually used.",
      "comment_id": 1081686136,
      "user": "Gallaecio",
      "created_at": "2023-01-19T18:50:47Z",
      "url": "https://github.com/scrapy/scrapy/pull/5798#discussion_r1081686136"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 5798,
      "file_path": "scrapy/http/request/__init__.py",
      "line": 32,
      "side": "RIGHT",
      "diff_hunk": "@@ -21,6 +23,23 @@\n RequestTypeVar = TypeVar(\"RequestTypeVar\", bound=\"Request\")\n \n \n+# https://github.com/python/typing/issues/689#issuecomment-561425237\n+class _NoCallback(Enum):\n+    NO_CALLBACK = 0\n+\n+\n+#: When assigned to the ``callback`` parameter of\n+#: :class:`~scrapy.http.Request`, it indicates that the request it not meant to",
      "comment": "```suggestion\r\n#: :class:`~scrapy.http.Request`, it indicates that the request is not meant to\r\n```",
      "comment_id": 1082272262,
      "user": "wRAR",
      "created_at": "2023-01-20T09:21:09Z",
      "url": "https://github.com/scrapy/scrapy/pull/5798#discussion_r1082272262"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 5798,
      "file_path": "scrapy/http/request/__init__.py",
      "line": 103,
      "side": "RIGHT",
      "diff_hunk": "@@ -78,6 +95,15 @@ def __init__(\n         self._cb_kwargs = dict(cb_kwargs) if cb_kwargs else None\n         self.flags = [] if flags is None else list(flags)\n \n+    def _set_xback(self, name: str, value: Optional[Callable]) -> None:\n+        if (\n+            value is not None\n+            and (name != \"callback\" or value is not NO_CALLBACK)\n+            and not callable(value)\n+        ):",
      "comment": "I wonder if the below is slightly easier to understand:\r\n\r\n```suggestion\r\n        if not (\r\n            callable(value)\r\n            or value is None\r\n            or (name == \"callback\" and value is NO_CALLBACK)\r\n        ):\r\n```\r\n\r\nFeel free to ignore.",
      "comment_id": 1082952307,
      "user": "kmike",
      "created_at": "2023-01-20T19:09:16Z",
      "url": "https://github.com/scrapy/scrapy/pull/5798#discussion_r1082952307"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 5798,
      "file_path": "scrapy/pipelines/media.py",
      "line": 95,
      "side": "LEFT",
      "diff_hunk": "@@ -93,7 +94,7 @@ def _process_request(self, request, info, item):\n         fp = self._fingerprinter.fingerprint(request)\n         cb = request.callback or (lambda _: _)\n         eb = request.errback\n-        request.callback = None",
      "comment": "We need to update the `FilesPipeline` as well: https://github.com/scrapy/scrapy/blob/master/scrapy/pipelines/files.py#L520",
      "comment_id": 1086175098,
      "user": "BurnzZ",
      "created_at": "2023-01-25T03:32:14Z",
      "url": "https://github.com/scrapy/scrapy/pull/5798#discussion_r1086175098"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 5798,
      "file_path": "scrapy/pipelines/media.py",
      "line": 95,
      "side": "LEFT",
      "diff_hunk": "@@ -93,7 +94,7 @@ def _process_request(self, request, info, item):\n         fp = self._fingerprinter.fingerprint(request)\n         cb = request.callback or (lambda _: _)\n         eb = request.errback\n-        request.callback = None",
      "comment": "Since tests were actually passing for files, I had a deeper look at it, and I think tests pass because those `Request(u)` objects are later parsed with the very method here, so the callback gets set before the request object leaves the middleware. So I think no further changes may be necessary specific to files or images.",
      "comment_id": 1086895008,
      "user": "Gallaecio",
      "created_at": "2023-01-25T16:48:37Z",
      "url": "https://github.com/scrapy/scrapy/pull/5798#discussion_r1086895008"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 5798,
      "file_path": "scrapy/pipelines/media.py",
      "line": 95,
      "side": "LEFT",
      "diff_hunk": "@@ -93,7 +94,7 @@ def _process_request(self, request, info, item):\n         fp = self._fingerprinter.fingerprint(request)\n         cb = request.callback or (lambda _: _)\n         eb = request.errback\n-        request.callback = None",
      "comment": "Hm, it might still be cleaner to add the no callback marker to these requests, as they're not supposed to use \"parse\" callback.",
      "comment_id": 1086975090,
      "user": "kmike",
      "created_at": "2023-01-25T17:53:38Z",
      "url": "https://github.com/scrapy/scrapy/pull/5798#discussion_r1086975090"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 5798,
      "file_path": "scrapy/pipelines/media.py",
      "line": 95,
      "side": "LEFT",
      "diff_hunk": "@@ -93,7 +94,7 @@ def _process_request(self, request, info, item):\n         fp = self._fingerprinter.fingerprint(request)\n         cb = request.callback or (lambda _: _)\n         eb = request.errback\n-        request.callback = None",
      "comment": "So we set callback to `NO_CALLBACK` twice, in `get_media_requests` and in `_process_request` (both called from `process_item`, one after the other)?\r\n\r\nI am not against it, I just want to be certain that I made it clear enough that the reason the callback is not set here is because these request objects are processed further before they leave the pipeline, so with the current code there is no risk of anything outside the pipeline itself to receive a request with `callback=None`.",
      "comment_id": 1089103602,
      "user": "Gallaecio",
      "created_at": "2023-01-27T15:38:29Z",
      "url": "https://github.com/scrapy/scrapy/pull/5798#discussion_r1089103602"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 5798,
      "file_path": "scrapy/pipelines/media.py",
      "line": 95,
      "side": "LEFT",
      "diff_hunk": "@@ -93,7 +94,7 @@ def _process_request(self, request, info, item):\n         fp = self._fingerprinter.fingerprint(request)\n         cb = request.callback or (lambda _: _)\n         eb = request.errback\n-        request.callback = None",
      "comment": "> So we set callback to NO\\_CALLBACK twice, in get\\_media\\_requests and in \\_process\\_request (both called from process\\_item, one after the other)?\r\n\r\nYes. I think if the reader sees `FilesPipeline.get_media_requests()` with `Request(u, callback=NO_CALLBACK)`, it helps re-assure the idea that the `parse()` method isn't supposed to be involved here.\r\n\r\nAlthough they could also further inspect `MediaPipeline._process_request()` and see that `NO_CALLBACK` is assigned, they won't have to if `FilesPipeline.get_media_requests()` already shows it.",
      "comment_id": 1090204896,
      "user": "BurnzZ",
      "created_at": "2023-01-30T06:07:53Z",
      "url": "https://github.com/scrapy/scrapy/pull/5798#discussion_r1090204896"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 5798,
      "file_path": "scrapy/pipelines/media.py",
      "line": 95,
      "side": "LEFT",
      "diff_hunk": "@@ -93,7 +94,7 @@ def _process_request(self, request, info, item):\n         fp = self._fingerprinter.fingerprint(request)\n         cb = request.callback or (lambda _: _)\n         eb = request.errback\n-        request.callback = None",
      "comment": "I\u2019m making the change, then.\r\n\r\nI wonder if we should go further, though, by changing `_process_request` to:\r\n- Log a deprecation warning if `callback` is `None`.\r\n- Raise an exception if `callback` is anything other than `None` or `NO_CALLBACK`. Or the same behavior as above, to avoid a backward-incompatible change. But I think it may be wise to actually break such code, to force users to not set a callback that is being reset in `_process_request`.",
      "comment_id": 1090435963,
      "user": "Gallaecio",
      "created_at": "2023-01-30T10:28:01Z",
      "url": "https://github.com/scrapy/scrapy/pull/5798#discussion_r1090435963"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 5798,
      "file_path": "scrapy/http/request/__init__.py",
      "line": 30,
      "side": "RIGHT",
      "diff_hunk": "@@ -20,6 +20,24 @@\n RequestTypeVar = TypeVar(\"RequestTypeVar\", bound=\"Request\")\n \n \n+def NO_CALLBACK(*args, **kwargs):\n+    \"\"\"When assigned to the ``callback`` parameter of\n+    :class:`~scrapy.http.Request`, it indicates that the request is not meant\n+    to have a spider callback at all.\n+\n+    This value should be used by :ref:`components <topics-components>` that\n+    create and handle their own requests, e.g. through\n+    :meth:`scrapy.core.engine.ExecutionEngine.download`, so that download",
      "comment": "```suggestion\r\n    :meth:`scrapy.core.engine.ExecutionEngine.download`, so that downloader\r\n```",
      "comment_id": 1090454770,
      "user": "wRAR",
      "created_at": "2023-01-30T10:44:54Z",
      "url": "https://github.com/scrapy/scrapy/pull/5798#discussion_r1090454770"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 5798,
      "file_path": "scrapy/pipelines/media.py",
      "line": 95,
      "side": "LEFT",
      "diff_hunk": "@@ -93,7 +94,7 @@ def _process_request(self, request, info, item):\n         fp = self._fingerprinter.fingerprint(request)\n         cb = request.callback or (lambda _: _)\n         eb = request.errback\n-        request.callback = None",
      "comment": "> Log a deprecation warning if `callback` is `None`.\r\n\r\n+1\u00a0\r\n\r\n> Raise an exception if `callback` is anything other than `None` or `NO_CALLBACK`. Or the same behavior as above, to avoid a backward-incompatible change. But I think it may be wise to actually break such code, to force users to not set a callback that is being reset in `_process_request`.\r\n\r\nI'm not quite sure about this, since there might be some Scrapy project out there that does things differently with their MediaPipeline/FilePipeline. For example, they've overridden `_process_request` to not directly use the downloader.",
      "comment_id": 1090457777,
      "user": "BurnzZ",
      "created_at": "2023-01-30T10:47:38Z",
      "url": "https://github.com/scrapy/scrapy/pull/5798#discussion_r1090457777"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 5798,
      "file_path": "scrapy/pipelines/media.py",
      "line": 95,
      "side": "LEFT",
      "diff_hunk": "@@ -93,7 +94,7 @@ def _process_request(self, request, info, item):\n         fp = self._fingerprinter.fingerprint(request)\n         cb = request.callback or (lambda _: _)\n         eb = request.errback\n-        request.callback = None",
      "comment": "> But I think it may be wise to actually break such code, to force users to not set a callback that is being reset in _process_request.\r\n\r\nThe callback is actually not just reset, but stored and used. So maybe my point is void, we should continue to support callbacks on requests from `get_media_requests()` as usual. `_process_request` will make sure that the request leaves the pipeline with `callback=NO_CALLBACK`, but the original callback will be called nonetheless by the pipeline.",
      "comment_id": 1090462554,
      "user": "Gallaecio",
      "created_at": "2023-01-30T10:52:12Z",
      "url": "https://github.com/scrapy/scrapy/pull/5798#discussion_r1090462554"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 5806,
      "file_path": "scrapy/__init__.py",
      "line": 16,
      "side": "RIGHT",
      "diff_hunk": "@@ -8,12 +8,12 @@\n \n from twisted import version as _txv\n \n-# Declare top-level shortcuts\n-from scrapy.spiders import Spider\n-from scrapy.http import Request, FormRequest\n+from scrapy.http import FormRequest, Request\n+from scrapy.item import Field, Item\n from scrapy.selector import Selector\n-from scrapy.item import Item, Field\n \n+# Declare top-level shortcuts\n+from scrapy.spiders import Spider",
      "comment": "I think you may need to manually change this, i.e. move the comment line above `from scrapy.http import FormRequest, Request` now so that isort moves `from scrapy.spiders import Spider` back with the rest of the imports.",
      "comment_id": 1088923287,
      "user": "Gallaecio",
      "created_at": "2023-01-27T12:46:35Z",
      "url": "https://github.com/scrapy/scrapy/pull/5806#discussion_r1088923287"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 5806,
      "file_path": "scrapy/__init__.py",
      "line": 16,
      "side": "RIGHT",
      "diff_hunk": "@@ -8,12 +8,12 @@\n \n from twisted import version as _txv\n \n-# Declare top-level shortcuts\n-from scrapy.spiders import Spider\n-from scrapy.http import Request, FormRequest\n+from scrapy.http import FormRequest, Request\n+from scrapy.item import Field, Item\n from scrapy.selector import Selector\n-from scrapy.item import Item, Field\n \n+# Declare top-level shortcuts\n+from scrapy.spiders import Spider",
      "comment": "I did some tests with isort to avoid this in the future, but no luck. I'm going to make this change manually.",
      "comment_id": 1089440713,
      "user": "jxlil",
      "created_at": "2023-01-27T21:17:49Z",
      "url": "https://github.com/scrapy/scrapy/pull/5806#discussion_r1089440713"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 5734,
      "file_path": "tests/test_utils_misc/test_return_with_argument_inside_generator.py",
      "line": 18,
      "side": "RIGHT",
      "diff_hunk": "@@ -12,7 +15,7 @@ def _indentation_error(*args, **kwargs):\n \n def top_level_return_something():\n     \"\"\"\n-docstring\n+    docstring",
      "comment": "We need to disable this in some way, because these tests are for testing such code.",
      "comment_id": 1032775791,
      "user": "wRAR",
      "created_at": "2022-11-26T11:34:08Z",
      "url": "https://github.com/scrapy/scrapy/pull/5734#discussion_r1032775791"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 5734,
      "file_path": "tests/test_request_cb_kwargs.py",
      "line": 110,
      "side": "RIGHT",
      "diff_hunk": "@@ -12,98 +12,114 @@ class InjectArgumentsDownloaderMiddleware:\n     \"\"\"\n     Make sure downloader middlewares are able to update the keyword arguments\n     \"\"\"\n+\n     def process_request(self, request, spider):\n-        if request.callback.__name__ == 'parse_downloader_mw':\n-            request.cb_kwargs['from_process_request'] = True\n+        if request.callback.__name__ == \"parse_downloader_mw\":\n+            request.cb_kwargs[\"from_process_request\"] = True\n         return None\n \n     def process_response(self, request, response, spider):\n-        if request.callback.__name__ == 'parse_downloader_mw':\n-            request.cb_kwargs['from_process_response'] = True\n+        if request.callback.__name__ == \"parse_downloader_mw\":\n+            request.cb_kwargs[\"from_process_response\"] = True\n         return response\n \n \n class InjectArgumentsSpiderMiddleware:\n     \"\"\"\n     Make sure spider middlewares are able to update the keyword arguments\n     \"\"\"\n+\n     def process_start_requests(self, start_requests, spider):\n         for request in start_requests:\n-            if request.callback.__name__ == 'parse_spider_mw':\n-                request.cb_kwargs['from_process_start_requests'] = True\n+            if request.callback.__name__ == \"parse_spider_mw\":\n+                request.cb_kwargs[\"from_process_start_requests\"] = True\n             yield request\n \n     def process_spider_input(self, response, spider):\n         request = response.request\n-        if request.callback.__name__ == 'parse_spider_mw':\n-            request.cb_kwargs['from_process_spider_input'] = True\n+        if request.callback.__name__ == \"parse_spider_mw\":\n+            request.cb_kwargs[\"from_process_spider_input\"] = True\n         return None\n \n     def process_spider_output(self, response, result, spider):\n         for element in result:\n-            if isinstance(element, Request) and element.callback.__name__ == 'parse_spider_mw_2':\n-                element.cb_kwargs['from_process_spider_output'] = True\n+            if (\n+                isinstance(element, Request)\n+                and element.callback.__name__ == \"parse_spider_mw_2\"\n+            ):\n+                element.cb_kwargs[\"from_process_spider_output\"] = True\n             yield element\n \n \n class KeywordArgumentsSpider(MockServerSpider):\n-    name = 'kwargs'\n+    name = \"kwargs\"\n     custom_settings = {\n-        'DOWNLOADER_MIDDLEWARES': {\n+        \"DOWNLOADER_MIDDLEWARES\": {\n             InjectArgumentsDownloaderMiddleware: 750,\n         },\n-        'SPIDER_MIDDLEWARES': {\n+        \"SPIDER_MIDDLEWARES\": {\n             InjectArgumentsSpiderMiddleware: 750,\n         },\n     }\n \n     checks = []\n \n     def start_requests(self):\n-        data = {'key': 'value', 'number': 123, 'callback': 'some_callback'}\n-        yield Request(self.mockserver.url('/first'), self.parse_first, cb_kwargs=data)\n-        yield Request(self.mockserver.url('/general_with'), self.parse_general, cb_kwargs=data)\n-        yield Request(self.mockserver.url('/general_without'), self.parse_general)\n-        yield Request(self.mockserver.url('/no_kwargs'), self.parse_no_kwargs)\n-        yield Request(self.mockserver.url('/default'), self.parse_default, cb_kwargs=data)\n-        yield Request(self.mockserver.url('/takes_less'), self.parse_takes_less, cb_kwargs=data)\n-        yield Request(self.mockserver.url('/takes_more'), self.parse_takes_more, cb_kwargs=data)\n-        yield Request(self.mockserver.url('/downloader_mw'), self.parse_downloader_mw)\n-        yield Request(self.mockserver.url('/spider_mw'), self.parse_spider_mw)\n+        data = {\"key\": \"value\", \"number\": 123, \"callback\": \"some_callback\"}\n+        yield Request(self.mockserver.url(\"/first\"), self.parse_first, cb_kwargs=data)\n+        yield Request(\n+            self.mockserver.url(\"/general_with\"), self.parse_general, cb_kwargs=data\n+        )\n+        yield Request(self.mockserver.url(\"/general_without\"), self.parse_general)\n+        yield Request(self.mockserver.url(\"/no_kwargs\"), self.parse_no_kwargs)\n+        yield Request(\n+            self.mockserver.url(\"/default\"), self.parse_default, cb_kwargs=data\n+        )\n+        yield Request(\n+            self.mockserver.url(\"/takes_less\"), self.parse_takes_less, cb_kwargs=data\n+        )\n+        yield Request(\n+            self.mockserver.url(\"/takes_more\"), self.parse_takes_more, cb_kwargs=data\n+        )\n+        yield Request(self.mockserver.url(\"/downloader_mw\"), self.parse_downloader_mw)\n+        yield Request(self.mockserver.url(\"/spider_mw\"), self.parse_spider_mw)\n \n     def parse_first(self, response, key, number):\n-        self.checks.append(key == 'value')\n+        self.checks.append(key == \"value\")\n         self.checks.append(number == 123)\n-        self.crawler.stats.inc_value('boolean_checks', 2)\n+        self.crawler.stats.inc_value(\"boolean_checks\", 2)\n         yield response.follow(\n-            self.mockserver.url('/two'),\n+            self.mockserver.url(\"/two\"),\n             self.parse_second,\n-            cb_kwargs={'new_key': 'new_value'})\n+            cb_kwargs={\"new_key\": \"new_value\"},\n+        )\n \n     def parse_second(self, response, new_key):\n-        self.checks.append(new_key == 'new_value')\n-        self.crawler.stats.inc_value('boolean_checks')\n+        self.checks.append(new_key == \"new_value\")\n+        self.crawler.stats.inc_value(\"boolean_checks\")\n \n     def parse_general(self, response, **kwargs):\n-        if response.url.endswith('/general_with'):\n-            self.checks.append(kwargs['key'] == 'value')\n-            self.checks.append(kwargs['number'] == 123)\n-            self.checks.append(kwargs['callback'] == 'some_callback')\n-            self.crawler.stats.inc_value('boolean_checks', 3)\n-        elif response.url.endswith('/general_without'):\n-            self.checks.append(kwargs == {})  # pylint: disable=use-implicit-booleaness-not-comparison\n-            self.crawler.stats.inc_value('boolean_checks')\n+        if response.url.endswith(\"/general_with\"):\n+            self.checks.append(kwargs[\"key\"] == \"value\")\n+            self.checks.append(kwargs[\"number\"] == 123)\n+            self.checks.append(kwargs[\"callback\"] == \"some_callback\")\n+            self.crawler.stats.inc_value(\"boolean_checks\", 3)\n+        elif response.url.endswith(\"/general_without\"):\n+            self.checks.append(\n+                kwargs == {}\n+            )  # pylint: disable=use-implicit-booleaness-not-comparison",
      "comment": "This comment needs to be moved to the previous line to work properly.",
      "comment_id": 1034989885,
      "user": "wRAR",
      "created_at": "2022-11-29T16:35:28Z",
      "url": "https://github.com/scrapy/scrapy/pull/5734#discussion_r1034989885"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 5406,
      "file_path": "scrapy/mail.py",
      "line": 137,
      "side": "RIGHT",
      "diff_hunk": "@@ -129,12 +129,29 @@ def _sendmail(self, to_addrs, msg):\n         # Import twisted.mail here because it is not available in python3\n         from twisted.internet import reactor\n         from twisted.mail.smtp import ESMTPSenderFactory\n-        msg = BytesIO(msg)\n+        from twisted import version as twisted_version\n+        from distutils.version import Version\n+\n         d = defer.Deferred()\n-        factory = ESMTPSenderFactory(\n-            self.smtpuser, self.smtppass, self.mailfrom, to_addrs, msg, d,\n-            heloFallback=True, requireAuthentication=False, requireTransportSecurity=self.smtptls,\n-        )\n+\n+        factory_config = {",
      "comment": "I would make a dict only for keyword arguments, not for all of them, but I guess that's a style question",
      "comment_id": 809696374,
      "user": "wRAR",
      "created_at": "2022-02-18T05:57:46Z",
      "url": "https://github.com/scrapy/scrapy/pull/5406#discussion_r809696374"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 5406,
      "file_path": "scrapy/mail.py",
      "line": 132,
      "side": "RIGHT",
      "diff_hunk": "@@ -129,12 +129,29 @@ def _sendmail(self, to_addrs, msg):\n         # Import twisted.mail here because it is not available in python3\n         from twisted.internet import reactor\n         from twisted.mail.smtp import ESMTPSenderFactory\n-        msg = BytesIO(msg)\n+        from twisted import version as twisted_version",
      "comment": "I did it to conform to the code that was already there. You think it's better to move them all up?",
      "comment_id": 810668132,
      "user": "TobiMayr",
      "created_at": "2022-02-20T18:48:58Z",
      "url": "https://github.com/scrapy/scrapy/pull/5406#discussion_r810668132"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 5406,
      "file_path": "scrapy/mail.py",
      "line": 132,
      "side": "RIGHT",
      "diff_hunk": "@@ -129,12 +129,29 @@ def _sendmail(self, to_addrs, msg):\n         # Import twisted.mail here because it is not available in python3\n         from twisted.internet import reactor\n         from twisted.mail.smtp import ESMTPSenderFactory\n-        msg = BytesIO(msg)\n+        from twisted import version as twisted_version",
      "comment": "Those two imports are local because we shouldn't import the reactor globally (`twisted.mail.smtp` imports it too). Also looks like that comment is misleading and obsolete.",
      "comment_id": 811023014,
      "user": "wRAR",
      "created_at": "2022-02-21T11:13:05Z",
      "url": "https://github.com/scrapy/scrapy/pull/5406#discussion_r811023014"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 5406,
      "file_path": "scrapy/mail.py",
      "line": 137,
      "side": "RIGHT",
      "diff_hunk": "@@ -129,12 +129,29 @@ def _sendmail(self, to_addrs, msg):\n         # Import twisted.mail here because it is not available in python3\n         from twisted.internet import reactor\n         from twisted.mail.smtp import ESMTPSenderFactory\n-        msg = BytesIO(msg)\n+        from twisted import version as twisted_version\n+        from distutils.version import Version\n+\n         d = defer.Deferred()\n-        factory = ESMTPSenderFactory(\n-            self.smtpuser, self.smtppass, self.mailfrom, to_addrs, msg, d,\n-            heloFallback=True, requireAuthentication=False, requireTransportSecurity=self.smtptls,\n-        )\n+\n+        factory_config = {",
      "comment": "I agree, it makes it shorter as well. I will adjust it",
      "comment_id": 813322597,
      "user": "TobiMayr",
      "created_at": "2022-02-23T21:13:14Z",
      "url": "https://github.com/scrapy/scrapy/pull/5406#discussion_r813322597"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 5406,
      "file_path": "scrapy/mail.py",
      "line": 15,
      "side": "RIGHT",
      "diff_hunk": "@@ -12,7 +12,9 @@\n from email.utils import formatdate\n from io import BytesIO\n \n+from incremental import Version",
      "comment": "We usually do `from twisted.python.versions import Version` (even though it's the same class)",
      "comment_id": 813721570,
      "user": "wRAR",
      "created_at": "2022-02-24T09:59:27Z",
      "url": "https://github.com/scrapy/scrapy/pull/5406#discussion_r813721570"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 5028,
      "file_path": "tests/test_webclient.py",
      "line": 421,
      "side": "RIGHT",
      "diff_hunk": "@@ -418,7 +418,7 @@ def testPayload(self):\n \n     def testPayloadDisabledCipher(self):\n         if sys.implementation.name == \"pypy\" and parse_version(cryptography.__version__) <= parse_version(\"2.3.1\"):\n-            self.skipTest(\"This does work in PyPy with cryptography<=2.3.1\")\n+            self.skipTest(\"This does not work in PyPy with cryptography<=2.3.1\")",
      "comment": "```suggestion\r\n            self.skipTest(\"This test expects a failure, but the code does work in PyPy with cryptography<=2.3.1\")\r\n```\r\nHopefully this is clearer than my original phrasing.",
      "comment_id": 595212534,
      "user": "elacuesta",
      "created_at": "2021-03-16T14:18:20Z",
      "url": "https://github.com/scrapy/scrapy/pull/5028#discussion_r595212534"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 5790,
      "file_path": "scrapy/utils/ssl.py",
      "line": 9,
      "side": "LEFT",
      "diff_hunk": "@@ -1,14 +1,9 @@\n-import OpenSSL\n+import OpenSSL.SSL\n import OpenSSL._util as pyOpenSSLutil\n \n from scrapy.utils.python import to_unicode\n \n \n-# The OpenSSL symbol is present since 1.1.1 but it's not currently supported in any version of pyOpenSSL.\n-# Using the binding directly, as this code does, requires cryptography 2.4.\n-SSL_OP_NO_TLSv1_3 = getattr(pyOpenSSLutil.lib, 'SSL_OP_NO_TLSv1_3', 0)",
      "comment": "We can't deprecate this without some magic (probably the least magic way is the module-level `__getattr__`).\r\n\r\nIf we decide to deprecate it, this line can be changed into `SSL_OP_NO_TLSv1_3 = OpenSSL.SSL.OP_NO_TLSv1_3` and the deprecation will be done separately.",
      "comment_id": 1069693893,
      "user": "wRAR",
      "created_at": "2023-01-13T16:55:47Z",
      "url": "https://github.com/scrapy/scrapy/pull/5790#discussion_r1069693893"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 5458,
      "file_path": "scrapy/linkextractors/lxmlhtml.py",
      "line": 198,
      "side": "RIGHT",
      "diff_hunk": "@@ -195,7 +195,8 @@ def extract_links(self, response):\n         Only links that match the settings passed to the ``__init__`` method of\n         the link extractor are returned.\n \n-        Duplicate links are omitted.\n+        Duplicate links are omitted if the ``unique`` parameter is set to ``True``, ",
      "comment": "```suggestion\r\n        Duplicate links are omitted if the ``unique`` attribute is set to ``True``, \r\n```",
      "comment_id": 1067381294,
      "user": "Gallaecio",
      "created_at": "2023-01-11T19:29:39Z",
      "url": "https://github.com/scrapy/scrapy/pull/5458#discussion_r1067381294"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 5764,
      "file_path": "tests/test_commands.py",
      "line": 319,
      "side": "RIGHT",
      "diff_hunk": "@@ -316,7 +316,7 @@ def _make_read_only(path: Path):\n         self.assertEqual(actual_permissions, expected_permissions)\n \n     def test_startproject_permissions_unchanged_in_destination(self):\n-        \"\"\"Check that pre-existing folders and files in the destination folder\n+        \"\"\"Check that preexisting folders and files in the destination folder",
      "comment": "This one seems arguable, but no strong opinion either way.\r\n\r\nSame applies to \u201cnonexistent\u201d later on.",
      "comment_id": 1067013068,
      "user": "Gallaecio",
      "created_at": "2023-01-11T13:48:36Z",
      "url": "https://github.com/scrapy/scrapy/pull/5764#discussion_r1067013068"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 5758,
      "file_path": "tests/test_feedexport.py",
      "line": 703,
      "side": "RIGHT",
      "diff_hunk": "@@ -680,6 +681,47 @@ def _load_until_eof(self, data, load_func):\n         return result\n \n \n+class InstrumentedFeedSlot(_FeedSlot):\n+    \"\"\"Instrumented _FeedSlot subclass for keeping track of calls to\n+    start_exporting and finish_exporting.\"\"\"\n+    def start_exporting(self):\n+        self.update_listener('start')\n+        super().start_exporting()\n+\n+    def finish_exporting(self):\n+        self.update_listener('finish')\n+        super().finish_exporting()\n+\n+    @classmethod\n+    def subscribe__listener(cls, listener):\n+        cls.update_listener = listener.update\n+\n+\n+class IsExportingListener:\n+    \"\"\"When subscribed to InstrumentedFeedSlot, keeps track of when\n+    a call to start_exporting has been made without a closing call to\n+    finish_exporting and when a call to finis_exporting has been made",
      "comment": ":lipstick: \r\n\r\n```suggestion\r\n    finish_exporting and when a call to finish_exporting has been made\r\n```",
      "comment_id": 1066934458,
      "user": "Gallaecio",
      "created_at": "2023-01-11T12:29:02Z",
      "url": "https://github.com/scrapy/scrapy/pull/5758#discussion_r1066934458"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 3869,
      "file_path": "scrapy/utils/misc.py",
      "line": 178,
      "side": "RIGHT",
      "diff_hunk": "@@ -162,3 +164,49 @@ def set_environ(**kwargs):\n                 del os.environ[k]\n             else:\n                 os.environ[k] = v\n+\n+\n+_trailing_whitespaces_re = re.compile(r'^(\\s*)')\n+\n+\n+def scan_generator_for_return_statement(callable):\n+    \"\"\"\n+    Returns True if a callable is a generator function and includes a\n+    'return' statement with a value different than None, False otherwise\n+    \"\"\"\n+\n+    def reduce_indentation_level(callable_lines):",
      "comment": "I'm not really fond of this, suggestions are welcome.",
      "comment_id": 302829025,
      "user": "elacuesta",
      "created_at": "2019-07-12T05:06:38Z",
      "url": "https://github.com/scrapy/scrapy/pull/3869#discussion_r302829025"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 3869,
      "file_path": "scrapy/utils/misc.py",
      "line": 178,
      "side": "RIGHT",
      "diff_hunk": "@@ -162,3 +164,49 @@ def set_environ(**kwargs):\n                 del os.environ[k]\n             else:\n                 os.environ[k] = v\n+\n+\n+_trailing_whitespaces_re = re.compile(r'^(\\s*)')\n+\n+\n+def scan_generator_for_return_statement(callable):\n+    \"\"\"\n+    Returns True if a callable is a generator function and includes a\n+    'return' statement with a value different than None, False otherwise\n+    \"\"\"\n+\n+    def reduce_indentation_level(callable_lines):",
      "comment": "Maybe it\u2019s better to use [dedent](https://docs.python.org/3/library/textwrap.html#textwrap.dedent), but other than that\u2026",
      "comment_id": 303397557,
      "user": "Gallaecio",
      "created_at": "2019-07-15T11:54:04Z",
      "url": "https://github.com/scrapy/scrapy/pull/3869#discussion_r303397557"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 3869,
      "file_path": "tests/test_utils_misc/test_return_with_argument_inside_generator.py",
      "line": 41,
      "side": "RIGHT",
      "diff_hunk": "@@ -0,0 +1,39 @@\n+import unittest\n+\n+from scrapy.utils.misc import is_generator_with_return_value\n+\n+\n+class UtilsMiscPy3TestCase(unittest.TestCase):\n+\n+    def test_generators_with_return_statements(self):\n+        \"\"\"\n+        'return with argument inside generator' is a SyntaxError before Python 3.3\n+        \"\"\"\n+        def f():\n+            yield 1\n+            return 2\n+\n+        def g():\n+            yield 1\n+            return 'asdf'\n+\n+        def h():\n+            yield 1\n+            return None\n+\n+        def i():\n+            yield 1\n+            return\n+\n+        def j():\n+            yield 1\n+\n+        assert is_generator_with_return_value(f)\n+        assert is_generator_with_return_value(g)\n+        assert not is_generator_with_return_value(h)\n+        assert not is_generator_with_return_value(i)\n+        assert not is_generator_with_return_value(j)\n+",
      "comment": "I can think of a test case (expected failure?) that we might want to cover here: A test that verifies that, if something like `yield from` is used and this issue affects the nested generator, we will still not detect it because we do not inspect callbacks recursively (which I assume would make things much more complicated and/or have a potentially-significant negative impact on performance).",
      "comment_id": 303400904,
      "user": "Gallaecio",
      "created_at": "2019-07-15T12:04:23Z",
      "url": "https://github.com/scrapy/scrapy/pull/3869#discussion_r303400904"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 3869,
      "file_path": "tests/test_utils_misc/test_return_with_argument_inside_generator.py",
      "line": 41,
      "side": "RIGHT",
      "diff_hunk": "@@ -0,0 +1,39 @@\n+import unittest\n+\n+from scrapy.utils.misc import is_generator_with_return_value\n+\n+\n+class UtilsMiscPy3TestCase(unittest.TestCase):\n+\n+    def test_generators_with_return_statements(self):\n+        \"\"\"\n+        'return with argument inside generator' is a SyntaxError before Python 3.3\n+        \"\"\"\n+        def f():\n+            yield 1\n+            return 2\n+\n+        def g():\n+            yield 1\n+            return 'asdf'\n+\n+        def h():\n+            yield 1\n+            return None\n+\n+        def i():\n+            yield 1\n+            return\n+\n+        def j():\n+            yield 1\n+\n+        assert is_generator_with_return_value(f)\n+        assert is_generator_with_return_value(g)\n+        assert not is_generator_with_return_value(h)\n+        assert not is_generator_with_return_value(i)\n+        assert not is_generator_with_return_value(j)\n+",
      "comment": "You're absolutely right. The nested generator could even be defined in a different module, it could get messy to get the source code to build the AST.",
      "comment_id": 303440716,
      "user": "elacuesta",
      "created_at": "2019-07-15T13:41:34Z",
      "url": "https://github.com/scrapy/scrapy/pull/3869#discussion_r303440716"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 3869,
      "file_path": "scrapy/utils/misc.py",
      "line": 178,
      "side": "RIGHT",
      "diff_hunk": "@@ -162,3 +164,49 @@ def set_environ(**kwargs):\n                 del os.environ[k]\n             else:\n                 os.environ[k] = v\n+\n+\n+_trailing_whitespaces_re = re.compile(r'^(\\s*)')\n+\n+\n+def scan_generator_for_return_statement(callable):\n+    \"\"\"\n+    Returns True if a callable is a generator function and includes a\n+    'return' statement with a value different than None, False otherwise\n+    \"\"\"\n+\n+    def reduce_indentation_level(callable_lines):",
      "comment": "Exactly what I needed, thanks! Too bad it's not available on py2, but hopefully that won't be an issue for too long :crossed_fingers: ",
      "comment_id": 303441867,
      "user": "elacuesta",
      "created_at": "2019-07-15T13:43:49Z",
      "url": "https://github.com/scrapy/scrapy/pull/3869#discussion_r303441867"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 3869,
      "file_path": "scrapy/utils/misc.py",
      "line": 178,
      "side": "RIGHT",
      "diff_hunk": "@@ -162,3 +164,49 @@ def set_environ(**kwargs):\n                 del os.environ[k]\n             else:\n                 os.environ[k] = v\n+\n+\n+_trailing_whitespaces_re = re.compile(r'^(\\s*)')\n+\n+\n+def scan_generator_for_return_statement(callable):\n+    \"\"\"\n+    Returns True if a callable is a generator function and includes a\n+    'return' statement with a value different than None, False otherwise\n+    \"\"\"\n+\n+    def reduce_indentation_level(callable_lines):",
      "comment": "Well, actually there's no need to worry about that, precisely because of https://github.com/scrapy/scrapy/pull/3869#issuecomment-510744562",
      "comment_id": 303472700,
      "user": "elacuesta",
      "created_at": "2019-07-15T14:42:38Z",
      "url": "https://github.com/scrapy/scrapy/pull/3869#discussion_r303472700"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 3869,
      "file_path": "scrapy/core/scraper.py",
      "line": 23,
      "side": "RIGHT",
      "diff_hunk": "@@ -18,6 +19,11 @@\n from scrapy.core.spidermw import SpiderMiddlewareManager\n from scrapy.utils.request import referer_str\n \n+\n+if six.PY3:",
      "comment": "As @kmike mentioned in other pull requests, ``if not six.PY2:`` would be more future-proof. Same a few lines below.",
      "comment_id": 303845360,
      "user": "Gallaecio",
      "created_at": "2019-07-16T10:53:59Z",
      "url": "https://github.com/scrapy/scrapy/pull/3869#discussion_r303845360"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 3869,
      "file_path": "scrapy/utils/misc.py",
      "line": 195,
      "side": "RIGHT",
      "diff_hunk": "@@ -162,3 +164,38 @@ def set_environ(**kwargs):\n                 del os.environ[k]\n             else:\n                 os.environ[k] = v\n+\n+\n+if not six.PY2:\n+    from textwrap import dedent\n+\n+    def is_generator_with_return_value(callable):\n+        \"\"\"\n+        Returns True if a callable is a generator function which includes a\n+        'return' statement with a value different than None, False otherwise\n+        \"\"\"\n+\n+        def returns_none(return_node):\n+            value = return_node.value\n+            return value is None or isinstance(value, ast.NameConstant) and value.value is None\n+\n+        if inspect.isgeneratorfunction(callable):\n+            tree = ast.parse(dedent(inspect.getsource(callable)))\n+            for node in ast.walk(tree):\n+                if isinstance(node, ast.Return) and not returns_none(node):\n+                    return True\n+        return False\n+\n+    def warn_on_generator_with_return_value(spider, callable, logger):\n+        \"\"\"\n+        Logs a warning if a callable is a generator function and includes\n+        a 'return' statement with a value different than None\n+        \"\"\"\n+        if is_generator_with_return_value(callable):\n+            logger.warning(",
      "comment": "What do you think about using warnings.warn instead? Otherwise this message will be logged at each request. By using warnings you'll also avoid passing logger argument.",
      "comment_id": 304315127,
      "user": "kmike",
      "created_at": "2019-07-17T09:51:22Z",
      "url": "https://github.com/scrapy/scrapy/pull/3869#discussion_r304315127"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 3869,
      "file_path": "scrapy/core/scraper.py",
      "line": 156,
      "side": "RIGHT",
      "diff_hunk": "@@ -142,7 +150,11 @@ def _scrape2(self, request_result, request, spider):\n     def call_spider(self, result, request, spider):\n         result.request = request\n         dfd = defer_result(result)\n-        dfd.addCallbacks(callback=request.callback or spider.parse,\n+        callback = request.callback or spider.parse\n+        if not six.PY2:\n+            warn_on_generator_with_return_value(spider, callback, logger)\n+            warn_on_generator_with_return_value(spider, request.errback, logger)",
      "comment": "Do you know if there is any pefrormance hit of doing code inspection on each request? I'm mostly concerned about pypy.",
      "comment_id": 304316229,
      "user": "kmike",
      "created_at": "2019-07-17T09:54:11Z",
      "url": "https://github.com/scrapy/scrapy/pull/3869#discussion_r304316229"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 3869,
      "file_path": "scrapy/utils/misc.py",
      "line": 195,
      "side": "RIGHT",
      "diff_hunk": "@@ -162,3 +164,38 @@ def set_environ(**kwargs):\n                 del os.environ[k]\n             else:\n                 os.environ[k] = v\n+\n+\n+if not six.PY2:\n+    from textwrap import dedent\n+\n+    def is_generator_with_return_value(callable):\n+        \"\"\"\n+        Returns True if a callable is a generator function which includes a\n+        'return' statement with a value different than None, False otherwise\n+        \"\"\"\n+\n+        def returns_none(return_node):\n+            value = return_node.value\n+            return value is None or isinstance(value, ast.NameConstant) and value.value is None\n+\n+        if inspect.isgeneratorfunction(callable):\n+            tree = ast.parse(dedent(inspect.getsource(callable)))\n+            for node in ast.walk(tree):\n+                if isinstance(node, ast.Return) and not returns_none(node):\n+                    return True\n+        return False\n+\n+    def warn_on_generator_with_return_value(spider, callable, logger):\n+        \"\"\"\n+        Logs a warning if a callable is a generator function and includes\n+        a 'return' statement with a value different than None\n+        \"\"\"\n+        if is_generator_with_return_value(callable):\n+            logger.warning(",
      "comment": "Good point. I was passing the logger so the warning would come from `scrapy.core.scraper`, but I guess that's really not relevant. About the multiple warnings, I hadn't realized about that, thanks. Will `warnings.warn` be issued only once?\r\n",
      "comment_id": 304368870,
      "user": "elacuesta",
      "created_at": "2019-07-17T12:16:16Z",
      "url": "https://github.com/scrapy/scrapy/pull/3869#discussion_r304368870"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 3869,
      "file_path": "scrapy/utils/misc.py",
      "line": 195,
      "side": "RIGHT",
      "diff_hunk": "@@ -162,3 +164,38 @@ def set_environ(**kwargs):\n                 del os.environ[k]\n             else:\n                 os.environ[k] = v\n+\n+\n+if not six.PY2:\n+    from textwrap import dedent\n+\n+    def is_generator_with_return_value(callable):\n+        \"\"\"\n+        Returns True if a callable is a generator function which includes a\n+        'return' statement with a value different than None, False otherwise\n+        \"\"\"\n+\n+        def returns_none(return_node):\n+            value = return_node.value\n+            return value is None or isinstance(value, ast.NameConstant) and value.value is None\n+\n+        if inspect.isgeneratorfunction(callable):\n+            tree = ast.parse(dedent(inspect.getsource(callable)))\n+            for node in ast.walk(tree):\n+                if isinstance(node, ast.Return) and not returns_none(node):\n+                    return True\n+        return False\n+\n+    def warn_on_generator_with_return_value(spider, callable, logger):\n+        \"\"\"\n+        Logs a warning if a callable is a generator function and includes\n+        a 'return' statement with a value different than None\n+        \"\"\"\n+        if is_generator_with_return_value(callable):\n+            logger.warning(",
      "comment": "yes, warning.warn is only displayed once with the same message. So there will be separate warnings for different callbacks, but not for the same callback.",
      "comment_id": 304427251,
      "user": "kmike",
      "created_at": "2019-07-17T14:18:18Z",
      "url": "https://github.com/scrapy/scrapy/pull/3869#discussion_r304427251"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 3869,
      "file_path": "scrapy/utils/misc.py",
      "line": 195,
      "side": "RIGHT",
      "diff_hunk": "@@ -162,3 +164,38 @@ def set_environ(**kwargs):\n                 del os.environ[k]\n             else:\n                 os.environ[k] = v\n+\n+\n+if not six.PY2:\n+    from textwrap import dedent\n+\n+    def is_generator_with_return_value(callable):\n+        \"\"\"\n+        Returns True if a callable is a generator function which includes a\n+        'return' statement with a value different than None, False otherwise\n+        \"\"\"\n+\n+        def returns_none(return_node):\n+            value = return_node.value\n+            return value is None or isinstance(value, ast.NameConstant) and value.value is None\n+\n+        if inspect.isgeneratorfunction(callable):\n+            tree = ast.parse(dedent(inspect.getsource(callable)))\n+            for node in ast.walk(tree):\n+                if isinstance(node, ast.Return) and not returns_none(node):\n+                    return True\n+        return False\n+\n+    def warn_on_generator_with_return_value(spider, callable, logger):\n+        \"\"\"\n+        Logs a warning if a callable is a generator function and includes\n+        a 'return' statement with a value different than None\n+        \"\"\"\n+        if is_generator_with_return_value(callable):\n+            logger.warning(",
      "comment": "Updated, thanks for the suggestion. Seems like the default class is [`UserWarning`](https://docs.python.org/3/library/exceptions.html#UserWarning), which seems reasonable enough to me according to its description \"Base class for warnings generated by user code.\"",
      "comment_id": 304471345,
      "user": "elacuesta",
      "created_at": "2019-07-17T15:23:47Z",
      "url": "https://github.com/scrapy/scrapy/pull/3869#discussion_r304471345"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 3869,
      "file_path": "scrapy/core/scraper.py",
      "line": 156,
      "side": "RIGHT",
      "diff_hunk": "@@ -142,7 +150,11 @@ def _scrape2(self, request_result, request, spider):\n     def call_spider(self, result, request, spider):\n         result.request = request\n         dfd = defer_result(result)\n-        dfd.addCallbacks(callback=request.callback or spider.parse,\n+        callback = request.callback or spider.parse\n+        if not six.PY2:\n+            warn_on_generator_with_return_value(spider, callback, logger)\n+            warn_on_generator_with_return_value(spider, request.errback, logger)",
      "comment": "Maybe we can cache calls to warn_on_generator_with_return_value with the same spider and callback?",
      "comment_id": 304846383,
      "user": "Gallaecio",
      "created_at": "2019-07-18T10:29:07Z",
      "url": "https://github.com/scrapy/scrapy/pull/3869#discussion_r304846383"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 3869,
      "file_path": "scrapy/core/scraper.py",
      "line": 156,
      "side": "RIGHT",
      "diff_hunk": "@@ -142,7 +150,11 @@ def _scrape2(self, request_result, request, spider):\n     def call_spider(self, result, request, spider):\n         result.request = request\n         dfd = defer_result(result)\n-        dfd.addCallbacks(callback=request.callback or spider.parse,\n+        callback = request.callback or spider.parse\n+        if not six.PY2:\n+            warn_on_generator_with_return_value(spider, callback, logger)\n+            warn_on_generator_with_return_value(spider, request.errback, logger)",
      "comment": "Great idea. I often forget about `lru_cache`. The default maxsize is 128, which seems perhaps a bit too much (I don't think I have seen spiders with that many callbacks). I don't have a strong opinion on it, so feel free to suggest other values.",
      "comment_id": 304963746,
      "user": "elacuesta",
      "created_at": "2019-07-18T14:56:19Z",
      "url": "https://github.com/scrapy/scrapy/pull/3869#discussion_r304963746"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 3869,
      "file_path": "scrapy/core/scraper.py",
      "line": 156,
      "side": "RIGHT",
      "diff_hunk": "@@ -142,7 +150,11 @@ def _scrape2(self, request_result, request, spider):\n     def call_spider(self, result, request, spider):\n         result.request = request\n         dfd = defer_result(result)\n-        dfd.addCallbacks(callback=request.callback or spider.parse,\n+        callback = request.callback or spider.parse\n+        if not six.PY2:\n+            warn_on_generator_with_return_value(spider, callback, logger)\n+            warn_on_generator_with_return_value(spider, request.errback, logger)",
      "comment": "Mind https://stackoverflow.com/questions/11815873/memoization-library-for-python-2-7",
      "comment_id": 304975164,
      "user": "Gallaecio",
      "created_at": "2019-07-18T15:17:32Z",
      "url": "https://github.com/scrapy/scrapy/pull/3869#discussion_r304975164"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 3869,
      "file_path": "scrapy/core/scraper.py",
      "line": 156,
      "side": "RIGHT",
      "diff_hunk": "@@ -142,7 +150,11 @@ def _scrape2(self, request_result, request, spider):\n     def call_spider(self, result, request, spider):\n         result.request = request\n         dfd = defer_result(result)\n-        dfd.addCallbacks(callback=request.callback or spider.parse,\n+        callback = request.callback or spider.parse\n+        if not six.PY2:\n+            warn_on_generator_with_return_value(spider, callback, logger)\n+            warn_on_generator_with_return_value(spider, request.errback, logger)",
      "comment": "Waiting until we drop Python 2 support makes more sense now :)",
      "comment_id": 304975409,
      "user": "Gallaecio",
      "created_at": "2019-07-18T15:18:02Z",
      "url": "https://github.com/scrapy/scrapy/pull/3869#discussion_r304975409"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 3869,
      "file_path": "scrapy/core/scraper.py",
      "line": 156,
      "side": "RIGHT",
      "diff_hunk": "@@ -142,7 +150,11 @@ def _scrape2(self, request_result, request, spider):\n     def call_spider(self, result, request, spider):\n         result.request = request\n         dfd = defer_result(result)\n-        dfd.addCallbacks(callback=request.callback or spider.parse,\n+        callback = request.callback or spider.parse\n+        if not six.PY2:\n+            warn_on_generator_with_return_value(spider, callback, logger)\n+            warn_on_generator_with_return_value(spider, request.errback, logger)",
      "comment": "Actually the whole PR works only in PY3, returns with values in generators are syntax errors in PY2",
      "comment_id": 304976951,
      "user": "elacuesta",
      "created_at": "2019-07-18T15:21:05Z",
      "url": "https://github.com/scrapy/scrapy/pull/3869#discussion_r304976951"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 3869,
      "file_path": "scrapy/core/scraper.py",
      "line": 156,
      "side": "RIGHT",
      "diff_hunk": "@@ -142,7 +150,11 @@ def _scrape2(self, request_result, request, spider):\n     def call_spider(self, result, request, spider):\n         result.request = request\n         dfd = defer_result(result)\n-        dfd.addCallbacks(callback=request.callback or spider.parse,\n+        callback = request.callback or spider.parse\n+        if not six.PY2:\n+            warn_on_generator_with_return_value(spider, callback, logger)\n+            warn_on_generator_with_return_value(spider, request.errback, logger)",
      "comment": "That's why I'm skipping the tests in py2 and importing/defining the functions in py3 only.",
      "comment_id": 304977839,
      "user": "elacuesta",
      "created_at": "2019-07-18T15:22:48Z",
      "url": "https://github.com/scrapy/scrapy/pull/3869#discussion_r304977839"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 3869,
      "file_path": "scrapy/core/scraper.py",
      "line": 156,
      "side": "RIGHT",
      "diff_hunk": "@@ -142,7 +150,11 @@ def _scrape2(self, request_result, request, spider):\n     def call_spider(self, result, request, spider):\n         result.request = request\n         dfd = defer_result(result)\n-        dfd.addCallbacks(callback=request.callback or spider.parse,\n+        callback = request.callback or spider.parse\n+        if not six.PY2:\n+            warn_on_generator_with_return_value(spider, callback, logger)\n+            warn_on_generator_with_return_value(spider, request.errback, logger)",
      "comment": "But since v1.7 was just released I can just remove all of those checks now :-)",
      "comment_id": 304980331,
      "user": "elacuesta",
      "created_at": "2019-07-18T15:27:31Z",
      "url": "https://github.com/scrapy/scrapy/pull/3869#discussion_r304980331"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 3869,
      "file_path": "scrapy/core/scraper.py",
      "line": 156,
      "side": "RIGHT",
      "diff_hunk": "@@ -142,7 +150,11 @@ def _scrape2(self, request_result, request, spider):\n     def call_spider(self, result, request, spider):\n         result.request = request\n         dfd = defer_result(result)\n-        dfd.addCallbacks(callback=request.callback or spider.parse,\n+        callback = request.callback or spider.parse\n+        if not six.PY2:\n+            warn_on_generator_with_return_value(spider, callback, logger)\n+            warn_on_generator_with_return_value(spider, request.errback, logger)",
      "comment": "Right, I forgot about the `six.PY2` ifs!\r\n\r\n> But since v1.7 was just released I can just remove all of those checks now :-)\r\n\r\nActually, there might be a 1.8, so don\u2019t start removing `six` references just yet :slightly_smiling_face: ",
      "comment_id": 304981992,
      "user": "Gallaecio",
      "created_at": "2019-07-18T15:30:39Z",
      "url": "https://github.com/scrapy/scrapy/pull/3869#discussion_r304981992"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 3869,
      "file_path": "scrapy/core/scraper.py",
      "line": 156,
      "side": "RIGHT",
      "diff_hunk": "@@ -142,7 +150,11 @@ def _scrape2(self, request_result, request, spider):\n     def call_spider(self, result, request, spider):\n         result.request = request\n         dfd = defer_result(result)\n-        dfd.addCallbacks(callback=request.callback or spider.parse,\n+        callback = request.callback or spider.parse\n+        if not six.PY2:\n+            warn_on_generator_with_return_value(spider, callback, logger)\n+            warn_on_generator_with_return_value(spider, request.errback, logger)",
      "comment": "Oh I just did hahaha. Nevermind, I can just revert the commit :-)",
      "comment_id": 304987333,
      "user": "elacuesta",
      "created_at": "2019-07-18T15:41:07Z",
      "url": "https://github.com/scrapy/scrapy/pull/3869#discussion_r304987333"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 3869,
      "file_path": "scrapy/utils/misc.py",
      "line": 174,
      "side": "RIGHT",
      "diff_hunk": "@@ -162,3 +165,40 @@ def set_environ(**kwargs):\n                 del os.environ[k]\n             else:\n                 os.environ[k] = v\n+\n+\n+if not six.PY2:\n+    from functools import lru_cache\n+    from textwrap import dedent\n+\n+    @lru_cache(maxsize=128)",
      "comment": "My only concern is this cache function: I wonder how it works with e.g. partial functions passed as callbacks - sometimes people use them to pass additional data. Won't it keep bound arguments of these functions for a long time? E.g. imagine something like `Request(url, partial(self.parse2, prev_response=response))` - would ~128 responses be kept alive in is_generator_with_return_value cache after requests are processed? I haven't check it, but I'm not sure lru_cache uses weakrefs for keys by default.\r\n\r\nWriting such code in spiders is not a good style, but here the tradeoff is a nice-to-have warning vs increased memory usage (and probably a failure) of some spiders.",
      "comment_id": 315350102,
      "user": "kmike",
      "created_at": "2019-08-19T18:27:38Z",
      "url": "https://github.com/scrapy/scrapy/pull/3869#discussion_r315350102"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 3869,
      "file_path": "scrapy/utils/misc.py",
      "line": 174,
      "side": "RIGHT",
      "diff_hunk": "@@ -162,3 +165,40 @@ def set_environ(**kwargs):\n                 del os.environ[k]\n             else:\n                 os.environ[k] = v\n+\n+\n+if not six.PY2:\n+    from functools import lru_cache\n+    from textwrap import dedent\n+\n+    @lru_cache(maxsize=128)",
      "comment": "Indeed, `lru_cache` does keep references to the cached objects (https://bugs.python.org/issue19859).\r\nI'm working on a weak referenced cache implementation (based on `scrapy.utils.datatypes.LocalCache`) that does not add much overhead IMHO, will update shortly.",
      "comment_id": 316189812,
      "user": "elacuesta",
      "created_at": "2019-08-21T13:39:40Z",
      "url": "https://github.com/scrapy/scrapy/pull/3869#discussion_r316189812"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 3869,
      "file_path": "scrapy/utils/misc.py",
      "line": 174,
      "side": "RIGHT",
      "diff_hunk": "@@ -162,3 +165,40 @@ def set_environ(**kwargs):\n                 del os.environ[k]\n             else:\n                 os.environ[k] = v\n+\n+\n+if not six.PY2:\n+    from functools import lru_cache\n+    from textwrap import dedent\n+\n+    @lru_cache(maxsize=128)",
      "comment": "Updated, please see [`scrapy.utils.datatypes.LocalWeakReferencedCache`](https://github.com/scrapy/scrapy/pull/3869/files#diff-2f75773d25e485f98def0ba43b0ce78eR324)",
      "comment_id": 316272773,
      "user": "elacuesta",
      "created_at": "2019-08-21T16:09:38Z",
      "url": "https://github.com/scrapy/scrapy/pull/3869#discussion_r316272773"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 3869,
      "file_path": "scrapy/utils/misc.py",
      "line": 174,
      "side": "RIGHT",
      "diff_hunk": "@@ -162,3 +165,40 @@ def set_environ(**kwargs):\n                 del os.environ[k]\n             else:\n                 os.environ[k] = v\n+\n+\n+if not six.PY2:\n+    from functools import lru_cache\n+    from textwrap import dedent\n+\n+    @lru_cache(maxsize=128)",
      "comment": "Not working 100% as I expected.\r\nTests are failing in py2, and even though they're easy to fix, I believe this PR doesn't really make sense there because returns in generators are SyntaxError.\r\nI'm marking it as py3-only and moving it to the 2.0 milestone.\r\nThere are also some pypy3-specific details, I need to take a look at that.",
      "comment_id": 317755242,
      "user": "elacuesta",
      "created_at": "2019-08-26T19:14:31Z",
      "url": "https://github.com/scrapy/scrapy/pull/3869#discussion_r317755242"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 3869,
      "file_path": "scrapy/utils/datatypes.py",
      "line": 251,
      "side": "RIGHT",
      "diff_hunk": "@@ -307,19 +308,48 @@ class LocalCache(collections.OrderedDict):\n     \"\"\"Dictionary with a finite number of keys.\n \n     Older items expires first.\n-\n     \"\"\"\n \n     def __init__(self, limit=None):\n         super(LocalCache, self).__init__()\n         self.limit = limit\n \n     def __setitem__(self, key, value):\n-        while len(self) >= self.limit:\n-            self.popitem(last=False)\n+        if self.limit:",
      "comment": "This is a bugfix: without the `if` statement, it can fail with `TypeError: '>=' not supported between instances of 'int' and 'NoneType'`",
      "comment_id": 342049190,
      "user": "elacuesta",
      "created_at": "2019-11-04T13:31:31Z",
      "url": "https://github.com/scrapy/scrapy/pull/3869#discussion_r342049190"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 4859,
      "file_path": "tests/test_commands.py",
      "line": 683,
      "side": "RIGHT",
      "diff_hunk": "@@ -680,9 +680,14 @@ def start_requests(self):\n         )\n         return []\n \"\"\"\n+        with open(os.path.join(self.cwd, \"example.json\"), \"w\") as file:",
      "comment": "`file` is a built-in in Python, should we change it to something like `fp`?",
      "comment_id": 514431960,
      "user": "kmike",
      "created_at": "2020-10-29T17:17:42Z",
      "url": "https://github.com/scrapy/scrapy/pull/4859#discussion_r514431960"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 5782,
      "file_path": "scrapy/utils/reactor.py",
      "line": 102,
      "side": "RIGHT",
      "diff_hunk": "@@ -90,11 +90,16 @@ def set_asyncio_event_loop(event_loop_path):\n         asyncio.set_event_loop(event_loop)\n     else:\n         try:\n+            asyncio.get_running_loop()\n             event_loop = policy.get_event_loop()\n         except RuntimeError:\n-            # `get_event_loop` is expected to fail when called from a new thread\n+            # Raised by policy.get_running_loop() when called from a new thread\n             # with no asyncio event loop yet installed. Such is the case when\n-            # called from `scrapy shell`\n+            # called from `scrapy shell`.\n+            # In Python 3.10, but not in 3.11, policy.get_event_loop() seems to\n+            # log a warning when called from the main thread, so we use\n+            # asyncio.get_running_loop() to get an earlier RuntimeError as a\n+            # workaround.",
      "comment": "I think this is happening, it feels like a Python 3.10 bug, but I have found no information about it.\r\n\r\nIf you comment out `asyncio.get_running_loop()` above, `test_install_asyncio_reactor` fails in Python 3.10 but _not_ in Python 3.11. You can try for yourself with:\r\n\r\n```\r\ntox -e py311,py310 -- tests/test_utils_asyncio.py::AsyncioTest tests/test_command_shell.py::ShellTest::test_shell_fetch_async\r\n```",
      "comment_id": 1060141846,
      "user": "Gallaecio",
      "created_at": "2023-01-02T17:30:50Z",
      "url": "https://github.com/scrapy/scrapy/pull/5782#discussion_r1060141846"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 5782,
      "file_path": "scrapy/utils/reactor.py",
      "line": 102,
      "side": "RIGHT",
      "diff_hunk": "@@ -90,11 +90,16 @@ def set_asyncio_event_loop(event_loop_path):\n         asyncio.set_event_loop(event_loop)\n     else:\n         try:\n+            asyncio.get_running_loop()\n             event_loop = policy.get_event_loop()\n         except RuntimeError:\n-            # `get_event_loop` is expected to fail when called from a new thread\n+            # Raised by policy.get_running_loop() when called from a new thread\n             # with no asyncio event loop yet installed. Such is the case when\n-            # called from `scrapy shell`\n+            # called from `scrapy shell`.\n+            # In Python 3.10, but not in 3.11, policy.get_event_loop() seems to\n+            # log a warning when called from the main thread, so we use\n+            # asyncio.get_running_loop() to get an earlier RuntimeError as a\n+            # workaround.",
      "comment": "My Python 3.11 is 3.11.0, that explains the 3.10-3.11 difference I get locally.",
      "comment_id": 1060153194,
      "user": "Gallaecio",
      "created_at": "2023-01-02T18:14:16Z",
      "url": "https://github.com/scrapy/scrapy/pull/5782#discussion_r1060153194"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 5767,
      "file_path": "scrapy/pipelines/images.py",
      "line": 174,
      "side": "RIGHT",
      "diff_hunk": "@@ -171,7 +171,7 @@ def convert_image(self, image, size=None, response_body=None):\n                           'method called without response_body argument.',\n                           category=ScrapyDeprecationWarning, stacklevel=2)\n \n-        if image.format == 'PNG' and image.mode == 'RGBA':\n+        if image.format == 'PNG' or image.format == 'WEBP' and image.mode == 'RGBA':",
      "comment": "```suggestion\r\n        if image.format in ('PNG', 'WEBP') and image.mode == 'RGBA':\r\n```\r\nWe can simplify.",
      "comment_id": 1053249656,
      "user": "Laerte",
      "created_at": "2022-12-20T12:13:29Z",
      "url": "https://github.com/scrapy/scrapy/pull/5767#discussion_r1053249656"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 5756,
      "file_path": "tests/test_http_response.py",
      "line": 5,
      "side": "RIGHT",
      "diff_hunk": "@@ -2,14 +2,16 @@\n import unittest\n from unittest import mock\n \n+from pkg_resources import parse_version",
      "comment": "Consider using `packaging.version.Version` instead. See https://github.com/scrapy/scrapy/pull/5645/files. ",
      "comment_id": 1045696577,
      "user": "Gallaecio",
      "created_at": "2022-12-12T11:15:40Z",
      "url": "https://github.com/scrapy/scrapy/pull/5756#discussion_r1045696577"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 5756,
      "file_path": "tests/test_http_response.py",
      "line": 5,
      "side": "RIGHT",
      "diff_hunk": "@@ -2,14 +2,16 @@\n import unittest\n from unittest import mock\n \n+from pkg_resources import parse_version",
      "comment": "Thanks for explanation about URL living standard! I applied the changes suggested, the only thing i had to change is the condition to `xfail`, thanks!",
      "comment_id": 1045737757,
      "user": "Laerte",
      "created_at": "2022-12-12T12:00:55Z",
      "url": "https://github.com/scrapy/scrapy/pull/5756#discussion_r1045737757"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 5756,
      "file_path": "tests/test_http_response.py",
      "line": 5,
      "side": "RIGHT",
      "diff_hunk": "@@ -2,14 +2,16 @@\n import unittest\n from unittest import mock\n \n+from pkg_resources import parse_version",
      "comment": "My thinking here was to keep the condition I suggested, and change the test expectations to remove %20. So these tests now, instead of testing that spaces are kept and percent-encoded, would test that spaces are stripped.",
      "comment_id": 1045793793,
      "user": "Gallaecio",
      "created_at": "2022-12-12T12:53:24Z",
      "url": "https://github.com/scrapy/scrapy/pull/5756#discussion_r1045793793"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 5677,
      "file_path": "tests/test_request_cb_kwargs.py",
      "line": 94,
      "side": "RIGHT",
      "diff_hunk": "@@ -91,7 +91,7 @@ def parse_general(self, response, **kwargs):\n             self.checks.append(kwargs['callback'] == 'some_callback')\n             self.crawler.stats.inc_value('boolean_checks', 3)\n         elif response.url.endswith('/general_without'):\n-            self.checks.append(kwargs == {})\n+            self.checks.append(not kwargs)",
      "comment": "```suggestion\r\n            self.checks.append(kwargs == {})\r\n```",
      "comment_id": 1014537193,
      "user": "felipeboffnunes",
      "created_at": "2022-11-05T00:42:15Z",
      "url": "https://github.com/scrapy/scrapy/pull/5677#discussion_r1014537193"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 5677,
      "file_path": "scrapy/http/request/__init__.py",
      "line": 190,
      "side": "RIGHT",
      "diff_hunk": "@@ -187,7 +187,7 @@ def to_dict(self, *, spider: Optional[\"scrapy.Spider\"] = None) -> dict:\n         }\n         for attr in self.attributes:\n             d.setdefault(attr, getattr(self, attr))\n-        if type(self) is not Request:\n+        if not isinstance(self, Request):",
      "comment": "`E   AssertionError: <class 'scrapy.http.request.form.FormRequest'> != <class 'scrapy.http.request.Request'>`\r\n\r\nIs this the one breaking the tests? `test_request_dict` fails on the pipeline and also `isinstance` caters to inheritance, whilst `type` does not. \r\n[Difference type and isinstance](https://stackoverflow.com/questions/1549801/what-are-the-differences-between-type-and-isinstance)\r\n\r\n```suggestion\r\n        if type(self) is not Request:\r\n```",
      "comment_id": 1031754654,
      "user": "felipeboffnunes",
      "created_at": "2022-11-24T18:03:34Z",
      "url": "https://github.com/scrapy/scrapy/pull/5677#discussion_r1031754654"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 5677,
      "file_path": "tests/CrawlerRunner/ip_address.py",
      "line": 33,
      "side": "RIGHT",
      "diff_hunk": "@@ -30,9 +30,10 @@ def start_requests(self):\n \n     def parse(self, response):\n         netloc = urlparse(response.url).netloc\n-        self.logger.info(\"Host: %s\" % netloc.split(\":\")[0])\n-        self.logger.info(\"Type: %s\" % type(response.ip_address))\n-        self.logger.info(\"IP address: %s\" % response.ip_address)\n+        a = netloc.split(\":\")[0]",
      "comment": "If the tests pass, this is the last blocker from me.",
      "comment_id": 1032442010,
      "user": "wRAR",
      "created_at": "2022-11-25T13:11:34Z",
      "url": "https://github.com/scrapy/scrapy/pull/5677#discussion_r1032442010"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 5677,
      "file_path": "scrapy/core/downloader/webclient.py",
      "line": 6,
      "side": "RIGHT",
      "diff_hunk": "@@ -1,8 +1,8 @@\n import re\n from time import time\n from urllib.parse import urlparse, urlunparse, urldefrag\n-\n from twisted.web.http import HTTPClient\n+\n from twisted.internet import defer",
      "comment": "Some import sorting and grouping changes like this one look wrong to me, but I am OK with merging this as an overall improvement, and in a separate pull request introduce a CI job to check these with isort, and include isort into the pre-commit configuration that we may introduce in https://github.com/scrapy/scrapy/pull/5734.",
      "comment_id": 1032899639,
      "user": "Gallaecio",
      "created_at": "2022-11-27T09:49:55Z",
      "url": "https://github.com/scrapy/scrapy/pull/5677#discussion_r1032899639"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 5677,
      "file_path": "tests/CrawlerRunner/ip_address.py",
      "line": 33,
      "side": "RIGHT",
      "diff_hunk": "@@ -30,9 +29,10 @@ def start_requests(self):\n \n     def parse(self, response):\n         netloc = urlparse(response.url).netloc\n-        self.logger.info(\"Host: %s\" % netloc.split(\":\")[0])\n-        self.logger.info(\"Type: %s\" % type(response.ip_address))\n-        self.logger.info(\"IP address: %s\" % response.ip_address)\n+        host = netloc.split(\":\")[0]\n+        self.logger.info(f\"Host: {host}\")",
      "comment": "Just a tip for the future: using single quotes (`':'`) would have worked as well to move `netloc.split(\":\")[0]` into the f-string.",
      "comment_id": 1032900566,
      "user": "Gallaecio",
      "created_at": "2022-11-27T09:56:05Z",
      "url": "https://github.com/scrapy/scrapy/pull/5677#discussion_r1032900566"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 5682,
      "file_path": "scrapy/commands/__init__.py",
      "line": 18,
      "side": "RIGHT",
      "diff_hunk": "@@ -14,15 +15,15 @@\n class ScrapyCommand:\n \n     requires_project = False\n-    crawler_process = None\n+    crawler_process: Any = None",
      "comment": "Could it be `Optional[CrawlerProcess]` instead of Any?",
      "comment_id": 999581179,
      "user": "kmike",
      "created_at": "2022-10-19T14:55:57Z",
      "url": "https://github.com/scrapy/scrapy/pull/5682#discussion_r999581179"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 5682,
      "file_path": "scrapy/commands/genspider.py",
      "line": 160,
      "side": "RIGHT",
      "diff_hunk": "@@ -143,17 +145,18 @@ def _spider_exists(self, name):\n \n         # a file with the same name exists in the target directory\n         spiders_module = import_module(self.settings['NEWSPIDER_MODULE'])\n-        spiders_dir = dirname(spiders_module.__file__)\n-        spiders_dir_abs = abspath(spiders_dir)\n-        if exists(join(spiders_dir_abs, name + \".py\")):\n-            print(f\"{join(spiders_dir_abs, (name + '.py'))} already exists\")\n+        spiders_dir = Path(cast(str, spiders_module.__file__)).parent\n+        spiders_dir_abs = spiders_dir.resolve()\n+        path = spiders_dir_abs / (name + \".py\")\n+        if path.exists():\n+            print(f\"{path} already exists\")\n             return True\n \n         return False\n \n     @property\n-    def templates_dir(self):\n-        return join(\n-            self.settings['TEMPLATES_DIR'] or join(scrapy.__path__[0], 'templates'),\n+    def templates_dir(self) -> str:\n+        return str(Path(\n+            self.settings['TEMPLATES_DIR'] or Path(scrapy.__path__[0], 'templates'),",
      "comment": "TIL `Path.__init__` accepts multiple positional arguments, and joins them",
      "comment_id": 999604164,
      "user": "kmike",
      "created_at": "2022-10-19T15:14:42Z",
      "url": "https://github.com/scrapy/scrapy/pull/5682#discussion_r999604164"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 5682,
      "file_path": "scrapy/commands/runspider.py",
      "line": 15,
      "side": "RIGHT",
      "diff_hunk": "@@ -1,22 +1,24 @@\n import sys\n-import os\n+from os import PathLike\n+from pathlib import Path\n from importlib import import_module\n+from types import ModuleType\n+from typing import Union\n \n from scrapy.utils.spider import iter_spider_classes\n from scrapy.exceptions import UsageError\n from scrapy.commands import BaseRunSpiderCommand\n \n \n-def _import_file(filepath):\n-    abspath = os.path.abspath(filepath)\n-    dirname, file = os.path.split(abspath)\n-    fname, fext = os.path.splitext(file)\n-    if fext not in ('.py', '.pyw'):\n+def _import_file(filepath: Union[str, PathLike]) -> ModuleType:\n+    abspath = Path(filepath).resolve()\n+    dirname = str(abspath.parent)",
      "comment": "very minor: probably it makes sense to move this line after the abspath.suffix check",
      "comment_id": 999607183,
      "user": "kmike",
      "created_at": "2022-10-19T15:16:59Z",
      "url": "https://github.com/scrapy/scrapy/pull/5682#discussion_r999607183"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 5682,
      "file_path": "tests/test_dependencies.py",
      "line": 33,
      "side": "RIGHT",
      "diff_hunk": "@@ -29,11 +30,7 @@ def test_pinned_twisted_version(self):\n         if not os.environ.get('_SCRAPY_PINNED', None):\n             self.skipTest('Not in a pinned environment')\n \n-        tox_config_file_path = os.path.join(\n-            os.path.dirname(__file__),\n-            '..',\n-            'tox.ini',\n-        )\n+        tox_config_file_path = Path(__file__) / '..' / 'tox.ini'",
      "comment": "I think there is a mistake here: `os.path.dirname(__file__)` is the dir of the file while `Path(__file__)` is the file itself. This must be the reason for the test failure (ConfigParser just ignores not existing files by design).",
      "comment_id": 1000229866,
      "user": "wRAR",
      "created_at": "2022-10-20T07:14:30Z",
      "url": "https://github.com/scrapy/scrapy/pull/5682#discussion_r1000229866"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 5682,
      "file_path": "scrapy/commands/startproject.py",
      "line": 112,
      "side": "RIGHT",
      "diff_hunk": "@@ -90,36 +90,36 @@ def run(self, args, opts):\n             raise UsageError()\n \n         project_name = args[0]\n-        project_dir = args[0]\n \n         if len(args) == 2:\n-            project_dir = args[1]\n+            project_dir = Path(args[1])\n+        else:\n+            project_dir = Path(args[0])\n \n-        if exists(join(project_dir, 'scrapy.cfg')):\n+        if (project_dir / 'scrapy.cfg').exists():\n             self.exitcode = 1\n-            print(f'Error: scrapy.cfg already exists in {abspath(project_dir)}')\n+            print(f'Error: scrapy.cfg already exists in {project_dir.resolve()}')\n             return\n \n         if not self._is_valid_name(project_name):\n             self.exitcode = 1\n             return\n \n-        self._copytree(self.templates_dir, abspath(project_dir))\n-        move(join(project_dir, 'module'), join(project_dir, project_name))\n+        self._copytree(Path(self.templates_dir), project_dir.resolve())\n+        move(project_dir / 'module', project_dir / project_name)\n         for paths in TEMPLATES_TO_RENDER:\n-            path = join(*paths)\n-            tplfile = join(project_dir, string.Template(path).substitute(project_name=project_name))\n-            render_templatefile(tplfile, project_name=project_name, ProjectName=string_camelcase(project_name))\n+            tplfile = Path(project_dir, *(string.Template(s).substitute(project_name=project_name) for s in paths))\n+            render_templatefile(str(tplfile), project_name=project_name, ProjectName=string_camelcase(project_name))",
      "comment": "It seems we can avoid calling `str(tplfile)` (here and in tests) if the first argument of render_teplatefile would be type annotated as `Union[str, PathLike]`; it seems it won't need code changes, just annotation changes.",
      "comment_id": 1000348449,
      "user": "kmike",
      "created_at": "2022-10-20T08:58:33Z",
      "url": "https://github.com/scrapy/scrapy/pull/5682#discussion_r1000348449"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 5682,
      "file_path": "scrapy/extensions/httpcache.py",
      "line": 335,
      "side": "RIGHT",
      "diff_hunk": "@@ -303,41 +305,41 @@ def retrieve_response(self, spider, request):\n         response = respcls(url=url, headers=headers, status=status, body=body)\n         return response\n \n-    def store_response(self, spider, request, response):\n+    def store_response(self, spider: Spider, request: Request, response):\n         \"\"\"Store the given response in the cache.\"\"\"\n         rpath = self._get_request_path(spider, request)\n-        if not os.path.exists(rpath):\n-            os.makedirs(rpath)\n+        if not rpath.exists():\n+            rpath.mkdir(parents=True)\n         metadata = {\n             'url': request.url,\n             'method': request.method,\n             'status': response.status,\n             'response_url': response.url,\n             'timestamp': time(),\n         }\n-        with self._open(os.path.join(rpath, 'meta'), 'wb') as f:\n+        with self._open(rpath / 'meta', 'wb') as f:\n             f.write(to_bytes(repr(metadata)))\n-        with self._open(os.path.join(rpath, 'pickled_meta'), 'wb') as f:\n+        with self._open(rpath / 'pickled_meta', 'wb') as f:\n             pickle.dump(metadata, f, protocol=4)\n-        with self._open(os.path.join(rpath, 'response_headers'), 'wb') as f:\n+        with self._open(rpath / 'response_headers', 'wb') as f:\n             f.write(headers_dict_to_raw(response.headers))\n-        with self._open(os.path.join(rpath, 'response_body'), 'wb') as f:\n+        with self._open(rpath / 'response_body', 'wb') as f:\n             f.write(response.body)\n-        with self._open(os.path.join(rpath, 'request_headers'), 'wb') as f:\n+        with self._open(rpath / 'request_headers', 'wb') as f:\n             f.write(headers_dict_to_raw(request.headers))\n-        with self._open(os.path.join(rpath, 'request_body'), 'wb') as f:\n+        with self._open(rpath / 'request_body', 'wb') as f:\n             f.write(request.body)\n \n-    def _get_request_path(self, spider, request):\n+    def _get_request_path(self, spider: Spider, request: Request) -> Path:\n         key = self._fingerprinter.fingerprint(request).hex()\n-        return os.path.join(self.cachedir, spider.name, key[0:2], key)\n+        return Path(self.cachedir, spider.name, key[0:2], key)",
      "comment": "That's a risky change; even if a method is declared as private, it's still overridden in the wild, e.g. https://github.com/scrapy-plugins/scrapy-splash/blob/f5273b3a0ef15a9f6809d305a1dbe8f3efd12c5f/scrapy_splash/cache.py#L17",
      "comment_id": 1000653920,
      "user": "kmike",
      "created_at": "2022-10-20T13:45:04Z",
      "url": "https://github.com/scrapy/scrapy/pull/5682#discussion_r1000653920"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 5682,
      "file_path": "scrapy/spiders/__init__.py",
      "line": 25,
      "side": "RIGHT",
      "diff_hunk": "@@ -3,21 +3,26 @@\n \n See documentation in docs/topics/spiders.rst\n \"\"\"\n+from __future__ import annotations\n+\n import logging\n-from typing import Optional\n+from typing import TYPE_CHECKING, Optional\n \n from scrapy import signals\n from scrapy.http import Request\n from scrapy.utils.trackref import object_ref\n from scrapy.utils.url import url_is_from_spider\n \n+if TYPE_CHECKING:\n+    from scrapy.crawler import Crawler\n+\n \n class Spider(object_ref):\n     \"\"\"Base class for scrapy spiders. All spiders must inherit from this\n     class.\n     \"\"\"\n \n-    name: Optional[str] = None\n+    name: str",
      "comment": "This is a change in behavior. It looks fine, but I'm not sure I understand the consequences fully. Would it make sense to keep it as it was, or should we investigate further? ",
      "comment_id": 1000812867,
      "user": "kmike",
      "created_at": "2022-10-20T15:44:15Z",
      "url": "https://github.com/scrapy/scrapy/pull/5682#discussion_r1000812867"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 5682,
      "file_path": "scrapy/spiders/__init__.py",
      "line": 25,
      "side": "RIGHT",
      "diff_hunk": "@@ -3,21 +3,26 @@\n \n See documentation in docs/topics/spiders.rst\n \"\"\"\n+from __future__ import annotations\n+\n import logging\n-from typing import Optional\n+from typing import TYPE_CHECKING, Optional\n \n from scrapy import signals\n from scrapy.http import Request\n from scrapy.utils.trackref import object_ref\n from scrapy.utils.url import url_is_from_spider\n \n+if TYPE_CHECKING:\n+    from scrapy.crawler import Crawler\n+\n \n class Spider(object_ref):\n     \"\"\"Base class for scrapy spiders. All spiders must inherit from this\n     class.\n     \"\"\"\n \n-    name: Optional[str] = None\n+    name: str",
      "comment": "This indeed looks wrong as base spider classes usually don't have the name attribute set.",
      "comment_id": 1000874869,
      "user": "wRAR",
      "created_at": "2022-10-20T16:41:14Z",
      "url": "https://github.com/scrapy/scrapy/pull/5682#discussion_r1000874869"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 5682,
      "file_path": "scrapy/commands/__init__.py",
      "line": 18,
      "side": "RIGHT",
      "diff_hunk": "@@ -14,15 +15,15 @@\n class ScrapyCommand:\n \n     requires_project = False\n-    crawler_process = None\n+    crawler_process: Any = None",
      "comment": "I originally tried it when mypy activated for this file and decided that `crawler_process` was of type `None`, but it exposes potential type errors in other parts of the code:\r\n```\r\nscrapy\\commands\\genspider.py:137: error: Item \"None\" of \"Optional[CrawlerProcess]\" has no attribute \"spider_loader\"  [union-attr]\r\n```",
      "comment_id": 1001226447,
      "user": "mdonoughe",
      "created_at": "2022-10-20T23:54:06Z",
      "url": "https://github.com/scrapy/scrapy/pull/5682#discussion_r1001226447"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 5682,
      "file_path": "scrapy/extensions/httpcache.py",
      "line": 335,
      "side": "RIGHT",
      "diff_hunk": "@@ -303,41 +305,41 @@ def retrieve_response(self, spider, request):\n         response = respcls(url=url, headers=headers, status=status, body=body)\n         return response\n \n-    def store_response(self, spider, request, response):\n+    def store_response(self, spider: Spider, request: Request, response):\n         \"\"\"Store the given response in the cache.\"\"\"\n         rpath = self._get_request_path(spider, request)\n-        if not os.path.exists(rpath):\n-            os.makedirs(rpath)\n+        if not rpath.exists():\n+            rpath.mkdir(parents=True)\n         metadata = {\n             'url': request.url,\n             'method': request.method,\n             'status': response.status,\n             'response_url': response.url,\n             'timestamp': time(),\n         }\n-        with self._open(os.path.join(rpath, 'meta'), 'wb') as f:\n+        with self._open(rpath / 'meta', 'wb') as f:\n             f.write(to_bytes(repr(metadata)))\n-        with self._open(os.path.join(rpath, 'pickled_meta'), 'wb') as f:\n+        with self._open(rpath / 'pickled_meta', 'wb') as f:\n             pickle.dump(metadata, f, protocol=4)\n-        with self._open(os.path.join(rpath, 'response_headers'), 'wb') as f:\n+        with self._open(rpath / 'response_headers', 'wb') as f:\n             f.write(headers_dict_to_raw(response.headers))\n-        with self._open(os.path.join(rpath, 'response_body'), 'wb') as f:\n+        with self._open(rpath / 'response_body', 'wb') as f:\n             f.write(response.body)\n-        with self._open(os.path.join(rpath, 'request_headers'), 'wb') as f:\n+        with self._open(rpath / 'request_headers', 'wb') as f:\n             f.write(headers_dict_to_raw(request.headers))\n-        with self._open(os.path.join(rpath, 'request_body'), 'wb') as f:\n+        with self._open(rpath / 'request_body', 'wb') as f:\n             f.write(request.body)\n \n-    def _get_request_path(self, spider, request):\n+    def _get_request_path(self, spider: Spider, request: Request) -> Path:\n         key = self._fingerprinter.fingerprint(request).hex()\n-        return os.path.join(self.cachedir, spider.name, key[0:2], key)\n+        return Path(self.cachedir, spider.name, key[0:2], key)",
      "comment": "I guess the question is, is it private as in it's not supposed to be called by other types or is it private as in it's part of Scrapy and if you touch it you're accepting the risk of it unexpectedly changing? I can put a `str()` around it.",
      "comment_id": 1001228259,
      "user": "mdonoughe",
      "created_at": "2022-10-20T23:57:59Z",
      "url": "https://github.com/scrapy/scrapy/pull/5682#discussion_r1001228259"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 5682,
      "file_path": "scrapy/pipelines/files.py",
      "line": 49,
      "side": "RIGHT",
      "diff_hunk": "@@ -39,41 +41,40 @@ class FileException(Exception):\n \n \n class FSFilesStore:\n-    def __init__(self, basedir):\n+    def __init__(self, basedir: str):\n         if '://' in basedir:\n             basedir = basedir.split('://', 1)[1]\n         self.basedir = basedir\n-        self._mkdir(self.basedir)\n-        self.created_directories = defaultdict(set)\n+        self._mkdir(Path(self.basedir))\n+        self.created_directories: defaultdict[str, set[str]] = defaultdict(set)",
      "comment": "You are right, but the tests somehow pass on 3.7? There are two instances of this in this file.",
      "comment_id": 1001230650,
      "user": "mdonoughe",
      "created_at": "2022-10-21T00:02:19Z",
      "url": "https://github.com/scrapy/scrapy/pull/5682#discussion_r1001230650"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 5682,
      "file_path": "scrapy/spiders/__init__.py",
      "line": 25,
      "side": "RIGHT",
      "diff_hunk": "@@ -3,21 +3,26 @@\n \n See documentation in docs/topics/spiders.rst\n \"\"\"\n+from __future__ import annotations\n+\n import logging\n-from typing import Optional\n+from typing import TYPE_CHECKING, Optional\n \n from scrapy import signals\n from scrapy.http import Request\n from scrapy.utils.trackref import object_ref\n from scrapy.utils.url import url_is_from_spider\n \n+if TYPE_CHECKING:\n+    from scrapy.crawler import Crawler\n+\n \n class Spider(object_ref):\n     \"\"\"Base class for scrapy spiders. All spiders must inherit from this\n     class.\n     \"\"\"\n \n-    name: Optional[str] = None\n+    name: str",
      "comment": "It's required not to be `None` by `httpcache.py`.\r\n```\r\nscrapy\\extensions\\httpcache.py:335: error: Argument 2 to \"Path\" has incompatible type \"Optional[str]\"; expected \"Union[str, PathLike[str]]\"  [arg-type]\r\n```",
      "comment_id": 1001232719,
      "user": "mdonoughe",
      "created_at": "2022-10-21T00:07:18Z",
      "url": "https://github.com/scrapy/scrapy/pull/5682#discussion_r1001232719"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 5682,
      "file_path": "scrapy/commands/runspider.py",
      "line": 15,
      "side": "RIGHT",
      "diff_hunk": "@@ -1,22 +1,24 @@\n import sys\n-import os\n+from os import PathLike\n+from pathlib import Path\n from importlib import import_module\n+from types import ModuleType\n+from typing import Union\n \n from scrapy.utils.spider import iter_spider_classes\n from scrapy.exceptions import UsageError\n from scrapy.commands import BaseRunSpiderCommand\n \n \n-def _import_file(filepath):\n-    abspath = os.path.abspath(filepath)\n-    dirname, file = os.path.split(abspath)\n-    fname, fext = os.path.splitext(file)\n-    if fext not in ('.py', '.pyw'):\n+def _import_file(filepath: Union[str, PathLike]) -> ModuleType:\n+    abspath = Path(filepath).resolve()\n+    dirname = str(abspath.parent)",
      "comment": "I moved it, but now I'm looking at `if dirname:` and thinking it can never fail. In both the old code and the new code, `abspath` is an absolute path to a file. Files must be contained within directories, so the absolute path will always have some parent path component. Even if you provide as input the absolute path to a path root, the parent of the root is the root itself.\r\n\r\nThe only way it could be false is if `abspath` were not an absolute path, in which case the old code would have returned an empty string and the new code would return `\".\"`.\r\n\r\n```\r\n>>> from pathlib import PurePosixPath, PureWindowsPath\r\n>>> PurePosixPath('/').parent\r\nPurePosixPath('/')\r\n>>> PureWindowsPath('c:\\\\').parent\r\nPureWindowsPath('c:/')\r\n>>> import os\r\n>>> os.path.split('/')\r\n('/', '')\r\n>>> os.path.split('c:\\\\') \r\n('c:\\\\', '')\r\n>>> PureWindowsPath('a').parent            \r\nPureWindowsPath('.')\r\n>>> os.path.split('a')                     \r\n('', 'a')\r\n```",
      "comment_id": 1001241942,
      "user": "mdonoughe",
      "created_at": "2022-10-21T00:25:55Z",
      "url": "https://github.com/scrapy/scrapy/pull/5682#discussion_r1001241942"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 5682,
      "file_path": "scrapy/pipelines/files.py",
      "line": 49,
      "side": "RIGHT",
      "diff_hunk": "@@ -39,41 +41,40 @@ class FileException(Exception):\n \n \n class FSFilesStore:\n-    def __init__(self, basedir):\n+    def __init__(self, basedir: str):\n         if '://' in basedir:\n             basedir = basedir.split('://', 1)[1]\n         self.basedir = basedir\n-        self._mkdir(self.basedir)\n-        self.created_directories = defaultdict(set)\n+        self._mkdir(Path(self.basedir))\n+        self.created_directories: defaultdict[str, set[str]] = defaultdict(set)",
      "comment": "This is not the first time I hear \"this typing syntax shouldn't be supported on the oldest version but the tests pass for it\". Not sure why is it so.",
      "comment_id": 1001441042,
      "user": "wRAR",
      "created_at": "2022-10-21T07:07:18Z",
      "url": "https://github.com/scrapy/scrapy/pull/5682#discussion_r1001441042"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 5682,
      "file_path": "scrapy/spiders/__init__.py",
      "line": 25,
      "side": "RIGHT",
      "diff_hunk": "@@ -3,21 +3,26 @@\n \n See documentation in docs/topics/spiders.rst\n \"\"\"\n+from __future__ import annotations\n+\n import logging\n-from typing import Optional\n+from typing import TYPE_CHECKING, Optional\n \n from scrapy import signals\n from scrapy.http import Request\n from scrapy.utils.trackref import object_ref\n from scrapy.utils.url import url_is_from_spider\n \n+if TYPE_CHECKING:\n+    from scrapy.crawler import Crawler\n+\n \n class Spider(object_ref):\n     \"\"\"Base class for scrapy spiders. All spiders must inherit from this\n     class.\n     \"\"\"\n \n-    name: Optional[str] = None\n+    name: str",
      "comment": "Well.\r\nThe base spiders I mentioned aren't supposed to be run so middlewares won't be executed :) Maybe it's enough to add a cast/assert to the middleware.\r\nOTOH there is a WIP PR #4327 that would make the name optional even for spiders that can be run.",
      "comment_id": 1001443734,
      "user": "wRAR",
      "created_at": "2022-10-21T07:11:01Z",
      "url": "https://github.com/scrapy/scrapy/pull/5682#discussion_r1001443734"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 5682,
      "file_path": "scrapy/spiders/__init__.py",
      "line": 25,
      "side": "RIGHT",
      "diff_hunk": "@@ -3,21 +3,26 @@\n \n See documentation in docs/topics/spiders.rst\n \"\"\"\n+from __future__ import annotations\n+\n import logging\n-from typing import Optional\n+from typing import TYPE_CHECKING, Optional\n \n from scrapy import signals\n from scrapy.http import Request\n from scrapy.utils.trackref import object_ref\n from scrapy.utils.url import url_is_from_spider\n \n+if TYPE_CHECKING:\n+    from scrapy.crawler import Crawler\n+\n \n class Spider(object_ref):\n     \"\"\"Base class for scrapy spiders. All spiders must inherit from this\n     class.\n     \"\"\"\n \n-    name: Optional[str] = None\n+    name: str",
      "comment": "Isn't it required that there is a name, even for the base `Spider`s? `InitSpider` does not have a name, but when you construct it you must provide a name as a parameter or else `Spider`'s `__init__` will raise an exception. It's these lines being removed in the other PR: https://github.com/scrapy/scrapy/pull/4327/files#diff-bfeaff1ed9c7b0a9a61d76bca0e46e4e34289df77cbc1a5143c31e4d1be6fcadL28-L29",
      "comment_id": 1002269548,
      "user": "mdonoughe",
      "created_at": "2022-10-22T00:14:15Z",
      "url": "https://github.com/scrapy/scrapy/pull/5682#discussion_r1002269548"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 5682,
      "file_path": "scrapy/pipelines/files.py",
      "line": 49,
      "side": "RIGHT",
      "diff_hunk": "@@ -39,41 +41,40 @@ class FileException(Exception):\n \n \n class FSFilesStore:\n-    def __init__(self, basedir):\n+    def __init__(self, basedir: str):\n         if '://' in basedir:\n             basedir = basedir.split('://', 1)[1]\n         self.basedir = basedir\n-        self._mkdir(self.basedir)\n-        self.created_directories = defaultdict(set)\n+        self._mkdir(Path(self.basedir))\n+        self.created_directories: defaultdict[str, set[str]] = defaultdict(set)",
      "comment": "I thought maybe there could be missing tests, but there are tests for that code, and they pass on 3.7 even if I put the annotations back to how they were. It works, even when not running the tests.\r\n\r\nIt turns out, Python 3.7 doesn't care what's written here at all. It doesn't need to be a real type.\r\n\r\n```\r\nPython 3.7.9 (tags/v3.7.9:13c94747c7, Aug 17 2020, 18:58:18) [MSC v.1900 64 bit (AMD64)] on win32\r\nType \"help\", \"copyright\", \"credits\" or \"license\" for more information.\r\n>>> a: aoeaoeaoe = None\r\nTraceback (most recent call last):\r\n  File \"<stdin>\", line 1, in <module>\r\nNameError: name 'aoeaoeaoe' is not defined\r\n>>> class A:     \r\n...     def __init__(self):\r\n...         self.a: aoeaoeaoe = None\r\n...\r\n>>> A()\r\n<__main__.A object at 0x0000019C495C8F08>\r\n>>>\r\n```",
      "comment_id": 1002288297,
      "user": "mdonoughe",
      "created_at": "2022-10-22T00:45:38Z",
      "url": "https://github.com/scrapy/scrapy/pull/5682#discussion_r1002288297"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 5682,
      "file_path": "scrapy/spiders/__init__.py",
      "line": 25,
      "side": "RIGHT",
      "diff_hunk": "@@ -3,21 +3,26 @@\n \n See documentation in docs/topics/spiders.rst\n \"\"\"\n+from __future__ import annotations\n+\n import logging\n-from typing import Optional\n+from typing import TYPE_CHECKING, Optional\n \n from scrapy import signals\n from scrapy.http import Request\n from scrapy.utils.trackref import object_ref\n from scrapy.utils.url import url_is_from_spider\n \n+if TYPE_CHECKING:\n+    from scrapy.crawler import Crawler\n+\n \n class Spider(object_ref):\n     \"\"\"Base class for scrapy spiders. All spiders must inherit from this\n     class.\n     \"\"\"\n \n-    name: Optional[str] = None\n+    name: str",
      "comment": "The `Spider` class itself does not have a `name` defined, and that is not an error. And subclasses do not need a name either, as long as they are not instantiated (which is when `Spider.__init__` gets called, though a subclass could actually override its `__init__` to prevent that exception in the first place).",
      "comment_id": 1002381767,
      "user": "Gallaecio",
      "created_at": "2022-10-22T06:59:39Z",
      "url": "https://github.com/scrapy/scrapy/pull/5682#discussion_r1002381767"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 5682,
      "file_path": "scrapy/spiders/__init__.py",
      "line": 25,
      "side": "RIGHT",
      "diff_hunk": "@@ -3,21 +3,26 @@\n \n See documentation in docs/topics/spiders.rst\n \"\"\"\n+from __future__ import annotations\n+\n import logging\n-from typing import Optional\n+from typing import TYPE_CHECKING, Optional\n \n from scrapy import signals\n from scrapy.http import Request\n from scrapy.utils.trackref import object_ref\n from scrapy.utils.url import url_is_from_spider\n \n+if TYPE_CHECKING:\n+    from scrapy.crawler import Crawler\n+\n \n class Spider(object_ref):\n     \"\"\"Base class for scrapy spiders. All spiders must inherit from this\n     class.\n     \"\"\"\n \n-    name: Optional[str] = None\n+    name: str",
      "comment": "If a subclass doesn't call the base `__init__` that seems like all promises made by the base class are off and functions provided by the base class may not work. Python doesn't enforce type hints at runtime so the code will work the same as before even if somebody skips over the code that asserts there is always a name.",
      "comment_id": 1002495612,
      "user": "mdonoughe",
      "created_at": "2022-10-22T14:30:35Z",
      "url": "https://github.com/scrapy/scrapy/pull/5682#discussion_r1002495612"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 5682,
      "file_path": "scrapy/spiders/__init__.py",
      "line": 25,
      "side": "RIGHT",
      "diff_hunk": "@@ -3,21 +3,26 @@\n \n See documentation in docs/topics/spiders.rst\n \"\"\"\n+from __future__ import annotations\n+\n import logging\n-from typing import Optional\n+from typing import TYPE_CHECKING, Optional\n \n from scrapy import signals\n from scrapy.http import Request\n from scrapy.utils.trackref import object_ref\n from scrapy.utils.url import url_is_from_spider\n \n+if TYPE_CHECKING:\n+    from scrapy.crawler import Crawler\n+\n \n class Spider(object_ref):\n     \"\"\"Base class for scrapy spiders. All spiders must inherit from this\n     class.\n     \"\"\"\n \n-    name: Optional[str] = None\n+    name: str",
      "comment": "I'm thinking this is correct as `str`. `name` is intended not to be `None`. If the type checker is really smart, having it declared to be `str` could generate a warning if somebody does create a special subclass that doesn't call the base `__init__` to set it (I haven't checked this, but I doubt it). The type checker will definitely generate a warning if somebody writes code that explicitly sets it to `None`.",
      "comment_id": 1002722144,
      "user": "mdonoughe",
      "created_at": "2022-10-23T14:46:01Z",
      "url": "https://github.com/scrapy/scrapy/pull/5682#discussion_r1002722144"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 5682,
      "file_path": "tests/test_downloader_handlers.py",
      "line": 111,
      "side": "RIGHT",
      "diff_hunk": "@@ -108,14 +108,13 @@ def test_lazy_handlers(self):\n class FileTestCase(unittest.TestCase):\n \n     def setUp(self):\n-        self.tmpname = self.mktemp()\n-        with open(self.tmpname + '^', 'w') as f:\n-            f.write('0123456789')\n+        self.tmpname = Path(self.mktemp() + '^')",
      "comment": "Note to self: find (again) why is this ^ needed in this test suite and add a comment. Or remove it if it's not actually needed.",
      "comment_id": 1027288466,
      "user": "wRAR",
      "created_at": "2022-11-20T13:16:21Z",
      "url": "https://github.com/scrapy/scrapy/pull/5682#discussion_r1027288466"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 5682,
      "file_path": "tests/test_downloader_handlers.py",
      "line": 111,
      "side": "RIGHT",
      "diff_hunk": "@@ -108,14 +108,13 @@ def test_lazy_handlers(self):\n class FileTestCase(unittest.TestCase):\n \n     def setUp(self):\n-        self.tmpname = self.mktemp()\n-        with open(self.tmpname + '^', 'w') as f:\n-            f.write('0123456789')\n+        self.tmpname = Path(self.mktemp() + '^')",
      "comment": "Previous time I've noticed it: https://github.com/scrapy/scrapy/pull/5285/files#r844017508",
      "comment_id": 1030092597,
      "user": "wRAR",
      "created_at": "2022-11-23T07:11:28Z",
      "url": "https://github.com/scrapy/scrapy/pull/5682#discussion_r1030092597"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 5682,
      "file_path": "tests/test_dependencies.py",
      "line": 33,
      "side": "RIGHT",
      "diff_hunk": "@@ -29,11 +30,7 @@ def test_pinned_twisted_version(self):\n         if not os.environ.get('_SCRAPY_PINNED', None):\n             self.skipTest('Not in a pinned environment')\n \n-        tox_config_file_path = os.path.join(\n-            os.path.dirname(__file__),\n-            '..',\n-            'tox.ini',\n-        )\n+        tox_config_file_path = Path(__file__).parent / '..' / 'tox.ini'",
      "comment": "```suggestion\r\n        tox_config_file_path = Path(__file__).parent.parent / 'tox.ini'\r\n```",
      "comment_id": 1032557458,
      "user": "kmike",
      "created_at": "2022-11-25T15:37:05Z",
      "url": "https://github.com/scrapy/scrapy/pull/5682#discussion_r1032557458"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 5682,
      "file_path": "scrapy/utils/test.py",
      "line": 79,
      "side": "RIGHT",
      "diff_hunk": "@@ -71,11 +72,11 @@ def get_crawler(spidercls=None, settings_dict=None, prevent_warnings=True):\n     return runner.create_crawler(spidercls or Spider)\n \n \n-def get_pythonpath():\n+def get_pythonpath() -> str:\n     \"\"\"Return a PYTHONPATH suitable to use in processes so that they find this\n     installation of Scrapy\"\"\"\n     scrapy_path = import_module('scrapy').__path__[0]\n-    return os.path.dirname(scrapy_path) + os.pathsep + os.environ.get('PYTHONPATH', '')\n+    return str(Path(scrapy_path).parent) + os.pathsep + os.environ.get('PYTHONPATH', '')",
      "comment": "Not related to this PR, but this code looks suspicious; I wonder why path is not just joined, and os.pathsep is used instead.",
      "comment_id": 1032562780,
      "user": "kmike",
      "created_at": "2022-11-25T15:44:04Z",
      "url": "https://github.com/scrapy/scrapy/pull/5682#discussion_r1032562780"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 5682,
      "file_path": "tests/test_downloader_handlers.py",
      "line": 1081,
      "side": "RIGHT",
      "diff_hunk": "@@ -1065,28 +1063,28 @@ def _test(r):\n \n     def test_ftp_local_filename(self):\n         f, local_fname = tempfile.mkstemp()\n-        local_fname = to_bytes(local_fname)\n+        fname_bytes = to_bytes(local_fname)\n+        local_fname = Path(local_fname)\n         os.close(f)\n-        meta = {\"ftp_local_filename\": local_fname}\n+        meta = {\"ftp_local_filename\": fname_bytes}\n         meta.update(self.req_meta)\n         request = Request(url=f\"ftp://127.0.0.1:{self.portNum}/file.txt\",\n                           meta=meta)\n         d = self.download_handler.download_request(request, None)\n \n         def _test(r):\n-            self.assertEqual(r.body, local_fname)\n-            self.assertEqual(r.headers, {b'Local Filename': [local_fname],\n+            self.assertEqual(r.body, fname_bytes)\n+            self.assertEqual(r.headers, {b'Local Filename': [fname_bytes],\n                                          b'Size': [b'17']})\n-            self.assertTrue(os.path.exists(local_fname))\n-            with open(local_fname, \"rb\") as f:\n-                self.assertEqual(f.read(), b\"I have the power!\")\n-            os.remove(local_fname)\n+            self.assertTrue(local_fname.exists())\n+            self.assertEqual(local_fname.read_bytes(), b\"I have the power!\")\n+            local_fname.unlink()",
      "comment": "not related to this PR: if a previous asserts fails, the file is not removed",
      "comment_id": 1032601194,
      "user": "kmike",
      "created_at": "2022-11-25T16:49:18Z",
      "url": "https://github.com/scrapy/scrapy/pull/5682#discussion_r1032601194"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 5682,
      "file_path": "scrapy/utils/test.py",
      "line": 79,
      "side": "RIGHT",
      "diff_hunk": "@@ -71,11 +72,11 @@ def get_crawler(spidercls=None, settings_dict=None, prevent_warnings=True):\n     return runner.create_crawler(spidercls or Spider)\n \n \n-def get_pythonpath():\n+def get_pythonpath() -> str:\n     \"\"\"Return a PYTHONPATH suitable to use in processes so that they find this\n     installation of Scrapy\"\"\"\n     scrapy_path = import_module('scrapy').__path__[0]\n-    return os.path.dirname(scrapy_path) + os.pathsep + os.environ.get('PYTHONPATH', '')\n+    return str(Path(scrapy_path).parent) + os.pathsep + os.environ.get('PYTHONPATH', '')",
      "comment": "`os.pathsep` is a separator of paths (: or ;) as opposed to `os.sep`. It's a list of paths, not a single path.",
      "comment_id": 1032649552,
      "user": "wRAR",
      "created_at": "2022-11-25T18:52:58Z",
      "url": "https://github.com/scrapy/scrapy/pull/5682#discussion_r1032649552"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 5682,
      "file_path": "tests/test_dependencies.py",
      "line": 33,
      "side": "RIGHT",
      "diff_hunk": "@@ -29,11 +30,7 @@ def test_pinned_twisted_version(self):\n         if not os.environ.get('_SCRAPY_PINNED', None):\n             self.skipTest('Not in a pinned environment')\n \n-        tox_config_file_path = os.path.join(\n-            os.path.dirname(__file__),\n-            '..',\n-            'tox.ini',\n-        )\n+        tox_config_file_path = Path(__file__).parent / '..' / 'tox.ini'",
      "comment": "The old code was like this so I didn't change it. `'..'` and `.parent` are slightly different if there are symbolic links. It'd probably be okay to change it here.",
      "comment_id": 1032656058,
      "user": "mdonoughe",
      "created_at": "2022-11-25T19:14:03Z",
      "url": "https://github.com/scrapy/scrapy/pull/5682#discussion_r1032656058"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 5736,
      "file_path": "tests/test_downloader_handlers.py",
      "line": 112,
      "side": "RIGHT",
      "diff_hunk": "@@ -109,6 +109,7 @@ class FileTestCase(unittest.TestCase):\n \n     def setUp(self):\n         self.tmpname = self.mktemp()\n+        # add a special char to check that they are handled correctly",
      "comment": "Maybe be more specific?\r\n\r\n```suggestion\r\n        # add a URL-unsafe char to check that they are handled correctly\r\n```",
      "comment_id": 1032448926,
      "user": "Gallaecio",
      "created_at": "2022-11-25T13:20:23Z",
      "url": "https://github.com/scrapy/scrapy/pull/5736#discussion_r1032448926"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 5730,
      "file_path": "scrapy/utils/deprecate.py",
      "line": 132,
      "side": "RIGHT",
      "diff_hunk": "@@ -126,9 +126,7 @@ def _clspath(cls, forced=None):\n     return f'{cls.__module__}.{cls.__name__}'\n \n \n-DEPRECATION_RULES = [\n-    ('scrapy.telnet.', 'scrapy.extensions.telnet.'),\n-]\n+DEPRECATION_RULES = []\n \n \n def update_classpath(path):",
      "comment": "I think we should remove this function as well, since now it will just return the provided path, make sense @wRAR?\r\n\r\nAnd probably pass a lambda function to `convert` parameter below (and remove from tests).\r\nhttps://github.com/scrapy/scrapy/blob/45c2bd7d9c1d6adf0e051842c422c5d6af1d0a17/scrapy/utils/conf.py#L15\r\n",
      "comment_id": 1030278437,
      "user": "Laerte",
      "created_at": "2022-11-23T10:39:19Z",
      "url": "https://github.com/scrapy/scrapy/pull/5730#discussion_r1030278437"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 5730,
      "file_path": "scrapy/utils/deprecate.py",
      "line": 132,
      "side": "RIGHT",
      "diff_hunk": "@@ -126,9 +126,7 @@ def _clspath(cls, forced=None):\n     return f'{cls.__module__}.{cls.__name__}'\n \n \n-DEPRECATION_RULES = [\n-    ('scrapy.telnet.', 'scrapy.extensions.telnet.'),\n-]\n+DEPRECATION_RULES = []\n \n \n def update_classpath(path):",
      "comment": "If there is a possibility of the `DEPRECATION_RULES` list being repopulated in the future due to further deprecation of packages then I would recommend to keep the `update_classpath` method otherwise similar logic will need to be re-written.",
      "comment_id": 1030286625,
      "user": "burneyh",
      "created_at": "2022-11-23T10:47:14Z",
      "url": "https://github.com/scrapy/scrapy/pull/5730#discussion_r1030286625"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 5730,
      "file_path": "scrapy/utils/deprecate.py",
      "line": 132,
      "side": "RIGHT",
      "diff_hunk": "@@ -126,9 +126,7 @@ def _clspath(cls, forced=None):\n     return f'{cls.__module__}.{cls.__name__}'\n \n \n-DEPRECATION_RULES = [\n-    ('scrapy.telnet.', 'scrapy.extensions.telnet.'),\n-]\n+DEPRECATION_RULES = []\n \n \n def update_classpath(path):",
      "comment": "I think it will be not the case since `@deprecated` decorator already have this functionality:\r\nhttps://github.com/scrapy/scrapy/blob/45c2bd7d9c1d6adf0e051842c422c5d6af1d0a17/scrapy/utils/decorators.py#L9\r\n\r\nBut let's see what Scrapy team has to say about.",
      "comment_id": 1030292140,
      "user": "Laerte",
      "created_at": "2022-11-23T10:52:46Z",
      "url": "https://github.com/scrapy/scrapy/pull/5730#discussion_r1030292140"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 5730,
      "file_path": "scrapy/utils/deprecate.py",
      "line": 132,
      "side": "RIGHT",
      "diff_hunk": "@@ -126,9 +126,7 @@ def _clspath(cls, forced=None):\n     return f'{cls.__module__}.{cls.__name__}'\n \n \n-DEPRECATION_RULES = [\n-    ('scrapy.telnet.', 'scrapy.extensions.telnet.'),\n-]\n+DEPRECATION_RULES = []\n \n \n def update_classpath(path):",
      "comment": "`update_classpath` is used in the code that parses object dicts such as `DOWNLOADER_MIDDLEWARES`: https://github.com/scrapy/scrapy/blob/45c2bd7d9c1d6adf0e051842c422c5d6af1d0a17/scrapy/utils/conf.py#L15\r\n\r\nI think you can't use `@deprecated` for this. ",
      "comment_id": 1030298179,
      "user": "wRAR",
      "created_at": "2022-11-23T10:58:43Z",
      "url": "https://github.com/scrapy/scrapy/pull/5730#discussion_r1030298179"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 5730,
      "file_path": "scrapy/utils/deprecate.py",
      "line": 132,
      "side": "RIGHT",
      "diff_hunk": "@@ -126,9 +126,7 @@ def _clspath(cls, forced=None):\n     return f'{cls.__module__}.{cls.__name__}'\n \n \n-DEPRECATION_RULES = [\n-    ('scrapy.telnet.', 'scrapy.extensions.telnet.'),\n-]\n+DEPRECATION_RULES = []\n \n \n def update_classpath(path):",
      "comment": "Yeah but the logic depends all on `DEPRECATION_RULES` variable right?\r\n\r\n```python\r\n    for prefix, replacement in DEPRECATION_RULES:\r\n        if isinstance(path, str) and path.startswith(prefix):\r\n            new_path = path.replace(prefix, replacement, 1)\r\n            warnings.warn(f\"`{path}` class is deprecated, use `{new_path}` instead\",\r\n                          ScrapyDeprecationWarning)\r\n            return new_path\r\n    return path\r\n```\r\nIf nothing is provided it will just return what was originally send by parameter right?",
      "comment_id": 1030303840,
      "user": "Laerte",
      "created_at": "2022-11-23T11:04:29Z",
      "url": "https://github.com/scrapy/scrapy/pull/5730#discussion_r1030303840"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 5730,
      "file_path": "scrapy/utils/deprecate.py",
      "line": 132,
      "side": "RIGHT",
      "diff_hunk": "@@ -126,9 +126,7 @@ def _clspath(cls, forced=None):\n     return f'{cls.__module__}.{cls.__name__}'\n \n \n-DEPRECATION_RULES = [\n-    ('scrapy.telnet.', 'scrapy.extensions.telnet.'),\n-]\n+DEPRECATION_RULES = []\n \n \n def update_classpath(path):",
      "comment": "I am not against removing it.\r\n\r\nHowever, then we would need to restore it if we deprecate a component path in the future, and chances are whoever does it will not realize there was a previous implementation that can be restored, and will waste time coming up with a new implementation, possibly worse than this one.\r\n\r\nSo keeping this code around, even if currently unused, may be the lesser evil.",
      "comment_id": 1030398794,
      "user": "Gallaecio",
      "created_at": "2022-11-23T12:45:47Z",
      "url": "https://github.com/scrapy/scrapy/pull/5730#discussion_r1030398794"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 5730,
      "file_path": "scrapy/utils/deprecate.py",
      "line": 129,
      "side": "RIGHT",
      "diff_hunk": "@@ -126,9 +126,7 @@ def _clspath(cls, forced=None):\n     return f'{cls.__module__}.{cls.__name__}'\n \n \n-DEPRECATION_RULES = [\n-    ('scrapy.telnet.', 'scrapy.extensions.telnet.'),\n-]\n+DEPRECATION_RULES = []",
      "comment": "Based on the failing `typing` job, we need to mark this with the `List[Tuple[str, str]]` type hint now that the type cannot be inferred from the value.",
      "comment_id": 1030407998,
      "user": "Gallaecio",
      "created_at": "2022-11-23T12:55:40Z",
      "url": "https://github.com/scrapy/scrapy/pull/5730#discussion_r1030407998"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 5730,
      "file_path": "scrapy/utils/deprecate.py",
      "line": 129,
      "side": "RIGHT",
      "diff_hunk": "@@ -126,9 +126,7 @@ def _clspath(cls, forced=None):\n     return f'{cls.__module__}.{cls.__name__}'\n \n \n-DEPRECATION_RULES = [\n-    ('scrapy.telnet.', 'scrapy.extensions.telnet.'),\n-]\n+DEPRECATION_RULES = []",
      "comment": "@Gallaecio I have now added the type annotations to the PR.",
      "comment_id": 1030429073,
      "user": "burneyh",
      "created_at": "2022-11-23T13:13:52Z",
      "url": "https://github.com/scrapy/scrapy/pull/5730#discussion_r1030429073"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 5722,
      "file_path": "scrapy/extensions/memusage.py",
      "line": 96,
      "side": "RIGHT",
      "diff_hunk": "@@ -92,6 +92,8 @@ def _check_limit(self):\n                 self.crawler.engine.close_spider(self.crawler.engine.spider, 'memusage_exceeded')\n             else:\n                 self.crawler.stop()\n+        else:\n+            logger.info(\"Current memory usage is %(virtualsize)dM\", {'virtualsize': self.get_virtual_size()})",
      "comment": "Rather than calling `self.get_virtual_size()` twice, why not declare a variable with its value at the beginning of the method, and use that value here and on the `if` statement?\r\n\r\nAlso, you are logging bytes as megabytes. You need to do `size / 1024 / 1024` as done above with the `mem` variable, but for the outcome of `self.get_virtual_size()`.\r\n\r\nAlso, for precision, maybe we should change the existing logging messages and your own message to use `MiB` instead of `M` as unit for [mebibytes](https://en.wikipedia.org/wiki/Byte#Multiple-byte_units).",
      "comment_id": 1028894956,
      "user": "Gallaecio",
      "created_at": "2022-11-22T05:57:15Z",
      "url": "https://github.com/scrapy/scrapy/pull/5722#discussion_r1028894956"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 5722,
      "file_path": "scrapy/extensions/memusage.py",
      "line": 96,
      "side": "RIGHT",
      "diff_hunk": "@@ -92,6 +92,8 @@ def _check_limit(self):\n                 self.crawler.engine.close_spider(self.crawler.engine.spider, 'memusage_exceeded')\n             else:\n                 self.crawler.stop()\n+        else:\n+            logger.info(\"Current memory usage is %(virtualsize)dM\", {'virtualsize': self.get_virtual_size()})",
      "comment": "Pushed changes to address the use of a variable and correctly converting bytes -> megabytes. I did not convert before the mem check to maintain as much precision as possible. \r\n\r\nNot so sure about the switch to mebibytes and how that scopes to this particular issue. Granted, isn't this already in mebibytes since we're doing `size / 1024 / 1024` instead of `size / 1000 / 1000` ? If so, this would just require the label be changed in the logging.",
      "comment_id": 1029018840,
      "user": "JazzGlobal",
      "created_at": "2022-11-22T08:37:40Z",
      "url": "https://github.com/scrapy/scrapy/pull/5722#discussion_r1029018840"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 5722,
      "file_path": "scrapy/extensions/memusage.py",
      "line": 96,
      "side": "RIGHT",
      "diff_hunk": "@@ -92,6 +92,8 @@ def _check_limit(self):\n                 self.crawler.engine.close_spider(self.crawler.engine.spider, 'memusage_exceeded')\n             else:\n                 self.crawler.stop()\n+        else:\n+            logger.info(\"Current memory usage is %(virtualsize)dM\", {'virtualsize': self.get_virtual_size()})",
      "comment": "> If so, this would just require the label be changed in the logging.\r\n\r\nYes, my point is that we are logging the value as e.g. 100M, but `M` is not a valid unit, it should be MB or, better yet, MiB.\r\n\r\nBut it is an issue from the original code, so I am OK with not addressing it here.",
      "comment_id": 1029041849,
      "user": "Gallaecio",
      "created_at": "2022-11-22T08:58:49Z",
      "url": "https://github.com/scrapy/scrapy/pull/5722#discussion_r1029041849"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 5722,
      "file_path": "scrapy/extensions/memusage.py",
      "line": 97,
      "side": "RIGHT",
      "diff_hunk": "@@ -92,6 +93,8 @@ def _check_limit(self):\n                 self.crawler.engine.close_spider(self.crawler.engine.spider, 'memusage_exceeded')\n             else:\n                 self.crawler.stop()\n+        else:\n+            logger.info(\"Current memory usage is %(virtualsize)dM\", {'virtualsize': current_mem_usage / 1024 / 1024})",
      "comment": "I think this message might be misleading. We're reporting ru_maxrss, which is the max memory used by the current process over its lifetime, not the current memory usage.",
      "comment_id": 1029378724,
      "user": "kmike",
      "created_at": "2022-11-22T14:10:31Z",
      "url": "https://github.com/scrapy/scrapy/pull/5722#discussion_r1029378724"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 5722,
      "file_path": "scrapy/extensions/memusage.py",
      "line": 78,
      "side": "RIGHT",
      "diff_hunk": "@@ -75,7 +75,8 @@ def update(self):\n         self.crawler.stats.max_value('memusage/max', self.get_virtual_size())\n \n     def _check_limit(self):\n-        if self.get_virtual_size() > self.limit:\n+        current_mem_usage = self.get_virtual_size()",
      "comment": "similarly to the other comment, that's not the current memory usage, it's max memory usage",
      "comment_id": 1029387035,
      "user": "kmike",
      "created_at": "2022-11-22T14:17:16Z",
      "url": "https://github.com/scrapy/scrapy/pull/5722#discussion_r1029387035"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 5722,
      "file_path": "scrapy/extensions/memusage.py",
      "line": 96,
      "side": "RIGHT",
      "diff_hunk": "@@ -92,6 +92,8 @@ def _check_limit(self):\n                 self.crawler.engine.close_spider(self.crawler.engine.spider, 'memusage_exceeded')\n             else:\n                 self.crawler.stop()\n+        else:\n+            logger.info(\"Current memory usage is %(virtualsize)dM\", {'virtualsize': self.get_virtual_size()})",
      "comment": "Makes sense to me. Thank you for the clarification",
      "comment_id": 1029529924,
      "user": "JazzGlobal",
      "created_at": "2022-11-22T16:02:22Z",
      "url": "https://github.com/scrapy/scrapy/pull/5722#discussion_r1029529924"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 4115,
      "file_path": "scrapy/downloadermiddlewares/decompression.py",
      "line": 7,
      "side": "RIGHT",
      "diff_hunk": "@@ -4,18 +4,14 @@\n \n import bz2\n import gzip\n+from io import BytesIO",
      "comment": "Nitpick: could you group the `^import ...` and `^from ...` lines together? There are a couple other occurrences of this in PR.",
      "comment_id": 341180674,
      "user": "elacuesta",
      "created_at": "2019-10-31T14:47:31Z",
      "url": "https://github.com/scrapy/scrapy/pull/4115#discussion_r341180674"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 4115,
      "file_path": "scrapy/downloadermiddlewares/decompression.py",
      "line": 7,
      "side": "RIGHT",
      "diff_hunk": "@@ -4,18 +4,14 @@\n \n import bz2\n import gzip\n+from io import BytesIO",
      "comment": "All `^import` together and then all `^from` together? I've noticed only recently that @Gallaecio is promoting this style, I didn't use it before.",
      "comment_id": 341242543,
      "user": "wRAR",
      "created_at": "2019-10-31T16:31:55Z",
      "url": "https://github.com/scrapy/scrapy/pull/4115#discussion_r341242543"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 4115,
      "file_path": "scrapy/downloadermiddlewares/decompression.py",
      "line": 7,
      "side": "RIGHT",
      "diff_hunk": "@@ -4,18 +4,14 @@\n \n import bz2\n import gzip\n+from io import BytesIO",
      "comment": "I must say I didn\u2019t use it either until recently. I think I found about it in some pull request, and https://stackoverflow.com/a/20763446/939364 seems to confirm that this is the convention.",
      "comment_id": 341499149,
      "user": "Gallaecio",
      "created_at": "2019-11-01T09:15:53Z",
      "url": "https://github.com/scrapy/scrapy/pull/4115#discussion_r341499149"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 4114,
      "file_path": "tests/test_proxy_connect.py",
      "line": 5,
      "side": "RIGHT",
      "diff_hunk": "@@ -1,63 +1,78 @@\n import json\n import os\n+import re\n+from subprocess import Popen, PIPE\n+import sys",
      "comment": ":lipstick: I think the `subprocess` import should be below `sys`, being in the `from \u2026 import \u2026` form. See https://stackoverflow.com/a/20763446/939364",
      "comment_id": 341055144,
      "user": "Gallaecio",
      "created_at": "2019-10-31T10:19:13Z",
      "url": "https://github.com/scrapy/scrapy/pull/4114#discussion_r341055144"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 4114,
      "file_path": "tests/test_proxy_connect.py",
      "line": 52,
      "side": "RIGHT",
      "diff_hunk": "@@ -1,63 +1,78 @@\n import json\n import os\n+import re\n+from subprocess import Popen, PIPE\n+import sys\n import time\n \n+import pytest\n from six.moves.urllib.parse import urlsplit, urlunsplit\n-from threading import Thread\n-from libmproxy import controller, proxy\n-from netlib import http_auth\n from testfixtures import LogCapture\n \n from twisted.internet import defer\n from twisted.trial.unittest import TestCase\n+\n from scrapy.utils.test import get_crawler\n from scrapy.http import Request\n from tests.spiders import SimpleSpider, SingleRequestSpider\n from tests.mockserver import MockServer\n \n \n-class HTTPSProxy(controller.Master, Thread):\n+class MitmProxy:\n+    auth_user = 'scrapy'\n+    auth_pass = 'scrapy'\n \n-    def __init__(self):\n-        password_manager = http_auth.PassManSingleUser('scrapy', 'scrapy')\n-        authenticator = http_auth.BasicProxyAuth(password_manager, \"mitmproxy\")\n+    def start(self):\n+        from scrapy.utils.test import get_testenv\n+        script = \"\"\"\n+import sys\n+from mitmproxy.tools.main import mitmdump\n+sys.argv[0] = \"mitmdump\"\n+sys.exit(mitmdump())\n+        \"\"\"\n         cert_path = os.path.join(os.path.abspath(os.path.dirname(__file__)),\n             'keys', 'mitmproxy-ca.pem')\n-        server = proxy.ProxyServer(proxy.ProxyConfig(\n-            authenticator = authenticator,\n-            cacert = cert_path),\n-            0)\n-        self.server = server\n-        Thread.__init__(self)\n-        controller.Master.__init__(self, server)\n-\n-    def http_address(self):\n-        return 'http://scrapy:scrapy@%s:%d' % self.server.socket.getsockname()\n+        self.proc = Popen([sys.executable,\n+                           '-c', script,\n+                           '--listen-host', '127.0.0.1',\n+                           '--listen-port', '0',\n+                           '--proxyauth', '%s:%s' % (self.auth_user, self.auth_pass),\n+                           '--certs', cert_path,\n+                           '--ssl-insecure',\n+                           ],\n+                           stdout=PIPE, env=get_testenv())\n+        line = self.proc.stdout.readline().decode('utf-8')\n+        host_port = re.search(r'listening at http://([^:]+:\\d+)', line).group(1)\n+        address = 'http://%s:%s@%s' % (self.auth_user, self.auth_pass, host_port)\n+        return address\n+\n+    def stop(self):\n+        self.proc.kill()\n+        self.proc.wait()\n+        time.sleep(0.2)",
      "comment": "From recent experience, I think we need to change these last two lines to `self.proc.communicate()` :slightly_smiling_face: ",
      "comment_id": 341506916,
      "user": "Gallaecio",
      "created_at": "2019-11-01T09:42:00Z",
      "url": "https://github.com/scrapy/scrapy/pull/4114#discussion_r341506916"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 4114,
      "file_path": "tests/test_proxy_connect.py",
      "line": 120,
      "side": "RIGHT",
      "diff_hunk": "@@ -100,9 +117,10 @@ def test_https_tunnel_without_leak_proxy_authorization_header(self):\n         with LogCapture() as l:\n             yield crawler.crawl(seed=request)\n         self._assert_got_response_code(200, l)\n-        echo = json.loads(crawler.spider.meta['responses'][0].body)\n+        echo = json.loads(crawler.spider.meta['responses'][0].body.decode('utf-8'))",
      "comment": "Is this a Scrapy `Response` object? Because then:\r\n\r\n```suggestion\r\n        echo = json.loads(crawler.spider.meta['responses'][0].text)\r\n```",
      "comment_id": 341507272,
      "user": "Gallaecio",
      "created_at": "2019-11-01T09:43:06Z",
      "url": "https://github.com/scrapy/scrapy/pull/4114#discussion_r341507272"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 4114,
      "file_path": "conftest.py",
      "line": 10,
      "side": "RIGHT",
      "diff_hunk": "@@ -8,11 +7,10 @@\n ]\n \n \n-if six.PY3:\n-    for line in open('tests/py3-ignores.txt'):\n-        file_path = line.strip()\n-        if file_path and file_path[0] != '#':\n-            collect_ignore.append(file_path)\n+for line in open('tests/py3-ignores.txt'):",
      "comment": "Should we take the chance to rename that file to simply `ignores.txt`?",
      "comment_id": 341507463,
      "user": "Gallaecio",
      "created_at": "2019-11-01T09:43:41Z",
      "url": "https://github.com/scrapy/scrapy/pull/4114#discussion_r341507463"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 4114,
      "file_path": "tests/test_proxy_connect.py",
      "line": 84,
      "side": "RIGHT",
      "diff_hunk": "@@ -67,6 +81,7 @@ def test_https_connect_tunnel(self):\n             yield crawler.crawl(self.mockserver.url(\"/status?n=200\", is_secure=True))\n         self._assert_got_response_code(200, l)\n \n+    @pytest.mark.xfail(reason='mitmproxy gives an error for noconnect requests')",
      "comment": "What error is that? Is it some feature missing in mitmproxy, which was present before? If so, it'd be good to open a ticket in their issue tracker, and add a link  here.",
      "comment_id": 341840393,
      "user": "kmike",
      "created_at": "2019-11-03T09:21:54Z",
      "url": "https://github.com/scrapy/scrapy/pull/4114#discussion_r341840393"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 4114,
      "file_path": "tests/test_proxy_connect.py",
      "line": 84,
      "side": "RIGHT",
      "diff_hunk": "@@ -67,6 +81,7 @@ def test_https_connect_tunnel(self):\n             yield crawler.crawl(self.mockserver.url(\"/status?n=200\", is_secure=True))\n         self._assert_got_response_code(200, l)\n \n+    @pytest.mark.xfail(reason='mitmproxy gives an error for noconnect requests')",
      "comment": " \"Invalid request scheme: https\" like in https://github.com/mitmproxy/mitmproxy/issues/848.\r\n\r\nSee https://github.com/scrapy/scrapy/issues/2545#issuecomment-532153176\r\n\r\nNote that the mitmproxy issue above is open but I'm not 100% sure it's the same use case. Actually, I'm not sure *what* is the use case for the Scrapy code to skip CONNECT.",
      "comment_id": 343761466,
      "user": "wRAR",
      "created_at": "2019-11-07T16:54:39Z",
      "url": "https://github.com/scrapy/scrapy/pull/4114#discussion_r343761466"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 4114,
      "file_path": "tests/test_proxy_connect.py",
      "line": 84,
      "side": "RIGHT",
      "diff_hunk": "@@ -67,6 +81,7 @@ def test_https_connect_tunnel(self):\n             yield crawler.crawl(self.mockserver.url(\"/status?n=200\", is_secure=True))\n         self._assert_got_response_code(200, l)\n \n+    @pytest.mark.xfail(reason='mitmproxy gives an error for noconnect requests')",
      "comment": "https://github.com/scrapy-plugins/scrapy-crawlera/pull/44",
      "comment_id": 346455485,
      "user": "wRAR",
      "created_at": "2019-11-14T17:46:11Z",
      "url": "https://github.com/scrapy/scrapy/pull/4114#discussion_r346455485"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 4114,
      "file_path": "tests/test_proxy_connect.py",
      "line": 84,
      "side": "RIGHT",
      "diff_hunk": "@@ -67,6 +81,7 @@ def test_https_connect_tunnel(self):\n             yield crawler.crawl(self.mockserver.url(\"/status?n=200\", is_secure=True))\n         self._assert_got_response_code(200, l)\n \n+    @pytest.mark.xfail(reason='mitmproxy gives an error for noconnect requests')",
      "comment": "@kmike I've added a comment about this as requested",
      "comment_id": 347480887,
      "user": "wRAR",
      "created_at": "2019-11-18T16:30:20Z",
      "url": "https://github.com/scrapy/scrapy/pull/4114#discussion_r347480887"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 4753,
      "file_path": "scrapy/pipelines/images.py",
      "line": 21,
      "side": "RIGHT",
      "diff_hunk": "@@ -5,19 +5,20 @@\n \"\"\"\n import functools\n import hashlib\n+import warnings\n from contextlib import suppress\n from io import BytesIO\n \n from itemadapter import ItemAdapter\n from PIL import Image\n \n-from scrapy.exceptions import DropItem\n+from scrapy.exceptions import DropItem, ScrapyDeprecationWarning\n from scrapy.http import Request\n from scrapy.pipelines.files import FileException, FilesPipeline\n # TODO: from scrapy.pipelines.media import MediaPipeline\n from scrapy.settings import Settings\n from scrapy.utils.misc import md5sum\n-from scrapy.utils.python import to_bytes\n+from scrapy.utils.python import to_bytes, get_func_args",
      "comment": ":lipstick: \r\n\r\n```suggestion\r\nfrom scrapy.utils.python import get_func_args, to_bytes\r\n```",
      "comment_id": 476334871,
      "user": "Gallaecio",
      "created_at": "2020-08-25T10:08:37Z",
      "url": "https://github.com/scrapy/scrapy/pull/4753#discussion_r476334871"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 4753,
      "file_path": "scrapy/pipelines/images.py",
      "line": 139,
      "side": "RIGHT",
      "diff_hunk": "@@ -128,15 +131,33 @@ def get_images(self, response, request, info, *, item=None):\n             raise ImageException(\"Image too small (%dx%d < %dx%d)\" %\n                                  (width, height, self.min_width, self.min_height))\n \n-        image, buf = self.convert_image(orig_image)\n+        if self._deprecated_convert_image is None:\n+            self._deprecated_convert_image = 'response_body' not in get_func_args(self.convert_image)\n+            if self._deprecated_convert_image:\n+                warnings.warn('ImagesPipeline.convert_image() method overriden in a deprecated way, '\n+                              'overriden method does not accept response_body argument.',\n+                              category=ScrapyDeprecationWarning, stacklevel=1)",
      "comment": ":lipstick: `1` is the default stack level.\r\n\r\n```suggestion\r\n                              category=ScrapyDeprecationWarning)\r\n```",
      "comment_id": 476337473,
      "user": "Gallaecio",
      "created_at": "2020-08-25T10:13:27Z",
      "url": "https://github.com/scrapy/scrapy/pull/4753#discussion_r476337473"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 4753,
      "file_path": "scrapy/pipelines/images.py",
      "line": 159,
      "side": "RIGHT",
      "diff_hunk": "@@ -128,15 +131,33 @@ def get_images(self, response, request, info, *, item=None):\n             raise ImageException(\"Image too small (%dx%d < %dx%d)\" %\n                                  (width, height, self.min_width, self.min_height))\n \n-        image, buf = self.convert_image(orig_image)\n+        if self._deprecated_convert_image is None:\n+            self._deprecated_convert_image = 'response_body' not in get_func_args(self.convert_image)\n+            if self._deprecated_convert_image:\n+                warnings.warn('ImagesPipeline.convert_image() method overriden in a deprecated way, '\n+                              'overriden method does not accept response_body argument.',\n+                              category=ScrapyDeprecationWarning, stacklevel=1)\n+\n+        if self._deprecated_convert_image:\n+            image, buf = self.convert_image(orig_image)\n+        else:\n+            image, buf = self.convert_image(orig_image, response_body=BytesIO(response.body))\n         yield path, image, buf\n \n         for thumb_id, size in self.thumbs.items():\n             thumb_path = self.thumb_path(request, thumb_id, response=response, info=info)\n-            thumb_image, thumb_buf = self.convert_image(image, size)\n+            if self._deprecated_convert_image:\n+                thumb_image, thumb_buf = self.convert_image(image, size)\n+            else:\n+                thumb_image, thumb_buf = self.convert_image(image, size, buf)\n             yield thumb_path, thumb_image, thumb_buf\n \n-    def convert_image(self, image, size=None):\n+    def convert_image(self, image, size=None, response_body=None):\n+        if response_body is None:\n+            warnings.warn('ImagesPipeline.convert_image() method called in a deprecated way, '\n+                          'method called without response_body argument.',\n+                          category=ScrapyDeprecationWarning, stacklevel=1)",
      "comment": ":lipstick: Since the issue is in the calling code, `2` is probably a more useful stack level here. \r\n\r\n```suggestion\r\n                          category=ScrapyDeprecationWarning, stacklevel=2)\r\n```",
      "comment_id": 476337971,
      "user": "Gallaecio",
      "created_at": "2020-08-25T10:14:22Z",
      "url": "https://github.com/scrapy/scrapy/pull/4753#discussion_r476337971"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 4753,
      "file_path": "scrapy/pipelines/images.py",
      "line": 138,
      "side": "RIGHT",
      "diff_hunk": "@@ -129,15 +132,33 @@ def get_images(self, response, request, info, *, item=None):\n                                  f\"({width}x{height} < \"\n                                  f\"{self.min_width}x{self.min_height})\")\n \n-        image, buf = self.convert_image(orig_image)\n+        if self._deprecated_convert_image is None:\n+            self._deprecated_convert_image = 'response_body' not in get_func_args(self.convert_image)\n+            if self._deprecated_convert_image:\n+                warnings.warn('ImagesPipeline.convert_image() method overriden in a deprecated way, '",
      "comment": "What do you think about using the exact class name here instead of ImagesPipeline?",
      "comment_id": 498457081,
      "user": "kmike",
      "created_at": "2020-10-01T19:05:45Z",
      "url": "https://github.com/scrapy/scrapy/pull/4753#discussion_r498457081"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 4753,
      "file_path": "scrapy/pipelines/images.py",
      "line": 138,
      "side": "RIGHT",
      "diff_hunk": "@@ -129,15 +132,33 @@ def get_images(self, response, request, info, *, item=None):\n                                  f\"({width}x{height} < \"\n                                  f\"{self.min_width}x{self.min_height})\")\n \n-        image, buf = self.convert_image(orig_image)\n+        if self._deprecated_convert_image is None:\n+            self._deprecated_convert_image = 'response_body' not in get_func_args(self.convert_image)\n+            if self._deprecated_convert_image:\n+                warnings.warn('ImagesPipeline.convert_image() method overriden in a deprecated way, '",
      "comment": "By exact class name you mean the name of the class instance variable? I didn't quite get that.",
      "comment_id": 498734032,
      "user": "drs-11",
      "created_at": "2020-10-02T10:11:24Z",
      "url": "https://github.com/scrapy/scrapy/pull/4753#discussion_r498734032"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 4753,
      "file_path": "scrapy/pipelines/images.py",
      "line": 138,
      "side": "RIGHT",
      "diff_hunk": "@@ -129,15 +132,33 @@ def get_images(self, response, request, info, *, item=None):\n                                  f\"({width}x{height} < \"\n                                  f\"{self.min_width}x{self.min_height})\")\n \n-        image, buf = self.convert_image(orig_image)\n+        if self._deprecated_convert_image is None:\n+            self._deprecated_convert_image = 'response_body' not in get_func_args(self.convert_image)\n+            if self._deprecated_convert_image:\n+                warnings.warn('ImagesPipeline.convert_image() method overriden in a deprecated way, '",
      "comment": "The warning would fire if user creates a subclass of ImagesPipeline and overrides convert_image method. So it would be `MyImagesPipeline.convert_image` method which we should warn about, not `ImagesPipeline.convert_image`. Something like `self.__class__.__name__` + \".convert_images()\" (haven't checked it).",
      "comment_id": 498799717,
      "user": "kmike",
      "created_at": "2020-10-02T12:48:46Z",
      "url": "https://github.com/scrapy/scrapy/pull/4753#discussion_r498799717"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 5689,
      "file_path": "scrapy/utils/reactor.py",
      "line": 62,
      "side": "RIGHT",
      "diff_hunk": "@@ -58,16 +58,19 @@ def install_reactor(reactor_path, event_loop_path=None):\n     reactor_class = load_object(reactor_path)\n     if reactor_class is asyncioreactor.AsyncioSelectorReactor:\n         with suppress(error.ReactorAlreadyInstalledError):\n+            policy = asyncio.get_event_loop_policy()\n             if sys.version_info >= (3, 8) and sys.platform == \"win32\":",
      "comment": "This condition could now be refactored as\r\n```python\r\nif (\r\n    sys.version_info >= (3, 8)\r\n    and sys.platform == \"win32\"\r\n    and not isinstance(policy, asyncio.WindowsSelectorEventLoopPolicy)\r\n):\r\n```",
      "comment_id": 1003554041,
      "user": "elacuesta",
      "created_at": "2022-10-24T17:03:52Z",
      "url": "https://github.com/scrapy/scrapy/pull/5689#discussion_r1003554041"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 5691,
      "file_path": "scrapy/utils/misc.py",
      "line": 229,
      "side": "RIGHT",
      "diff_hunk": "@@ -226,7 +226,14 @@ def returns_none(return_node):\n         return value is None or isinstance(value, ast.NameConstant) and value.value is None\n \n     if inspect.isgeneratorfunction(callable):\n-        code = re.sub(r\"^[\\t ]+\", \"\", inspect.getsource(callable))\n+        pattern = r\"(^[\\t ]+)\"",
      "comment": "Can this pattern be compiled? It wasn't in the original version, but I guess it could mean a slight performance improvement.",
      "comment_id": 1004926937,
      "user": "elacuesta",
      "created_at": "2022-10-25T20:18:19Z",
      "url": "https://github.com/scrapy/scrapy/pull/5691#discussion_r1004926937"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 5691,
      "file_path": "scrapy/utils/misc.py",
      "line": 235,
      "side": "RIGHT",
      "diff_hunk": "@@ -226,7 +226,14 @@ def returns_none(return_node):\n         return value is None or isinstance(value, ast.NameConstant) and value.value is None\n \n     if inspect.isgeneratorfunction(callable):\n-        code = re.sub(r\"^[\\t ]+\", \"\", inspect.getsource(callable))\n+        pattern = r\"(^[\\t ]+)\"\n+        src = inspect.getsource(callable)\n+        match = re.match(pattern, src)  # Find indentation\n+        code = re.sub(pattern, \"\", src)\n+        if match:\n+            # Remove indentation\n+            code = re.sub(f\"\\n{match.group(0)}\", \"\\n\", code)",
      "comment": "Nitpick 2:\r\n```suggestion\r\n            code = re.sub(f\"\\n{match.group(0)}\", \"\\n\", code)  # remove indentation\r\n```\r\nMore concise IMHO, and still respects the max line length",
      "comment_id": 1004930642,
      "user": "elacuesta",
      "created_at": "2022-10-25T20:23:06Z",
      "url": "https://github.com/scrapy/scrapy/pull/5691#discussion_r1004930642"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 5691,
      "file_path": "scrapy/utils/misc.py",
      "line": 232,
      "side": "RIGHT",
      "diff_hunk": "@@ -226,7 +226,14 @@ def returns_none(return_node):\n         return value is None or isinstance(value, ast.NameConstant) and value.value is None\n \n     if inspect.isgeneratorfunction(callable):\n-        code = re.sub(r\"^[\\t ]+\", \"\", inspect.getsource(callable))\n+        pattern = r\"(^[\\t ]+)\"\n+        src = inspect.getsource(callable)\n+        match = re.match(pattern, src)  # Find indentation\n+        code = re.sub(pattern, \"\", src)",
      "comment": "Nitpick 1:\r\n```suggestion\r\n        code = re.sub(pattern, \"\", src)\r\n        match = re.match(pattern, src)  # find indentation\r\n```\r\n\r\nJust swapping the two lines. For me it looks a little bit more readable, in the sense that `match` is only used within the next `if` block. In fact, this would be even better with the walrus operator if we had Python 3.8 as minimum version.",
      "comment_id": 1004932529,
      "user": "elacuesta",
      "created_at": "2022-10-25T20:25:26Z",
      "url": "https://github.com/scrapy/scrapy/pull/5691#discussion_r1004932529"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 5589,
      "file_path": "scrapy/core/engine.py",
      "line": 270,
      "side": "RIGHT",
      "diff_hunk": "@@ -257,19 +257,17 @@ def _schedule_request(self, request: Request, spider: Spider) -> None:\n \n     def download(self, request: Request, spider: Optional[Spider] = None) -> Deferred:\n         \"\"\"Return a Deferred which fires with a Response as result, only downloader middlewares are applied\"\"\"\n-        if spider is None:\n-            spider = self.spider\n-        else:\n+        if spider is not None:\n             warnings.warn(\n                 \"Passing a 'spider' argument to ExecutionEngine.download is deprecated\",\n                 category=ScrapyDeprecationWarning,\n                 stacklevel=2,\n             )\n             if spider is not self.spider:\n                 logger.warning(\"The spider '%s' does not match the open spider\", spider.name)\n-        if spider is None:\n+        if self.spider is None:\n             raise RuntimeError(f\"No open spider to crawl: {request}\")\n-        return self._download(request, spider).addBoth(self._downloaded, request, spider)\n+        return self._download(request, self.spider).addBoth(self._downloaded, request, self.spider)",
      "comment": "I have not tested it, but I believe here we should be passing `spider`, as before, and if it is `None` the corresponding callees will already use `self.spider` in that case.",
      "comment_id": 936841156,
      "user": "Gallaecio",
      "created_at": "2022-08-03T15:59:06Z",
      "url": "https://github.com/scrapy/scrapy/pull/5589#discussion_r936841156"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 5589,
      "file_path": "scrapy/core/engine.py",
      "line": 270,
      "side": "RIGHT",
      "diff_hunk": "@@ -257,19 +257,17 @@ def _schedule_request(self, request: Request, spider: Spider) -> None:\n \n     def download(self, request: Request, spider: Optional[Spider] = None) -> Deferred:\n         \"\"\"Return a Deferred which fires with a Response as result, only downloader middlewares are applied\"\"\"\n-        if spider is None:\n-            spider = self.spider\n-        else:\n+        if spider is not None:\n             warnings.warn(\n                 \"Passing a 'spider' argument to ExecutionEngine.download is deprecated\",\n                 category=ScrapyDeprecationWarning,\n                 stacklevel=2,\n             )\n             if spider is not self.spider:\n                 logger.warning(\"The spider '%s' does not match the open spider\", spider.name)\n-        if spider is None:\n+        if self.spider is None:\n             raise RuntimeError(f\"No open spider to crawl: {request}\")\n-        return self._download(request, spider).addBoth(self._downloaded, request, spider)\n+        return self._download(request, self.spider).addBoth(self._downloaded, request, self.spider)",
      "comment": "I changed because i got a type hint error in 3.7 check, i'm rolling back this change.",
      "comment_id": 936846801,
      "user": "Laerte",
      "created_at": "2022-08-03T16:03:27Z",
      "url": "https://github.com/scrapy/scrapy/pull/5589#discussion_r936846801"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 5589,
      "file_path": "scrapy/core/engine.py",
      "line": 270,
      "side": "RIGHT",
      "diff_hunk": "@@ -257,19 +257,17 @@ def _schedule_request(self, request: Request, spider: Spider) -> None:\n \n     def download(self, request: Request, spider: Optional[Spider] = None) -> Deferred:\n         \"\"\"Return a Deferred which fires with a Response as result, only downloader middlewares are applied\"\"\"\n-        if spider is None:\n-            spider = self.spider\n-        else:\n+        if spider is not None:\n             warnings.warn(\n                 \"Passing a 'spider' argument to ExecutionEngine.download is deprecated\",\n                 category=ScrapyDeprecationWarning,\n                 stacklevel=2,\n             )\n             if spider is not self.spider:\n                 logger.warning(\"The spider '%s' does not match the open spider\", spider.name)\n-        if spider is None:\n+        if self.spider is None:\n             raise RuntimeError(f\"No open spider to crawl: {request}\")\n-        return self._download(request, spider).addBoth(self._downloaded, request, spider)\n+        return self._download(request, spider).addBoth(self._downloaded, request, spider)  # type: ignore",
      "comment": "I see\u2026\r\n\r\nIt looks like we should change the typing of `Spider` in those 2 methods to `Optional[Spider]`, instead of ignoring the typing issue.\r\n\r\nIt also seems like `_download` should get the `if spider is None: spider = self.spider` logic.",
      "comment_id": 936925849,
      "user": "Gallaecio",
      "created_at": "2022-08-03T16:51:05Z",
      "url": "https://github.com/scrapy/scrapy/pull/5589#discussion_r936925849"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 5589,
      "file_path": "scrapy/core/engine.py",
      "line": 268,
      "side": "RIGHT",
      "diff_hunk": "@@ -257,17 +257,15 @@ def _schedule_request(self, request: Request, spider: Spider) -> None:\n \n     def download(self, request: Request, spider: Optional[Spider] = None) -> Deferred:\n         \"\"\"Return a Deferred which fires with a Response as result, only downloader middlewares are applied\"\"\"\n-        if spider is None:\n-            spider = self.spider\n-        else:\n+        if spider is not None:\n             warnings.warn(\n                 \"Passing a 'spider' argument to ExecutionEngine.download is deprecated\",\n                 category=ScrapyDeprecationWarning,\n                 stacklevel=2,\n             )\n             if spider is not self.spider:\n                 logger.warning(\"The spider '%s' does not match the open spider\", spider.name)\n-        if spider is None:\n+        if self.spider is None:",
      "comment": "Hm, it looks like the behavior is changed in this PR. Previously, if `spider` is passed to `download` method, it is always used. Now a RuntimeError could be raised if `spider` is passed, and `self.spider` is None. Is it a problem?",
      "comment_id": 937357620,
      "user": "kmike",
      "created_at": "2022-08-04T05:21:42Z",
      "url": "https://github.com/scrapy/scrapy/pull/5589#discussion_r937357620"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 5589,
      "file_path": "scrapy/core/engine.py",
      "line": 268,
      "side": "RIGHT",
      "diff_hunk": "@@ -257,17 +257,15 @@ def _schedule_request(self, request: Request, spider: Spider) -> None:\n \n     def download(self, request: Request, spider: Optional[Spider] = None) -> Deferred:\n         \"\"\"Return a Deferred which fires with a Response as result, only downloader middlewares are applied\"\"\"\n-        if spider is None:\n-            spider = self.spider\n-        else:\n+        if spider is not None:\n             warnings.warn(\n                 \"Passing a 'spider' argument to ExecutionEngine.download is deprecated\",\n                 category=ScrapyDeprecationWarning,\n                 stacklevel=2,\n             )\n             if spider is not self.spider:\n                 logger.warning(\"The spider '%s' does not match the open spider\", spider.name)\n-        if spider is None:\n+        if self.spider is None:",
      "comment": "I am unsure, but I will look into that when I find some time to work on tests.",
      "comment_id": 937470786,
      "user": "Gallaecio",
      "created_at": "2022-08-04T08:01:09Z",
      "url": "https://github.com/scrapy/scrapy/pull/5589#discussion_r937470786"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 5589,
      "file_path": "scrapy/core/engine.py",
      "line": 268,
      "side": "RIGHT",
      "diff_hunk": "@@ -257,17 +257,15 @@ def _schedule_request(self, request: Request, spider: Spider) -> None:\n \n     def download(self, request: Request, spider: Optional[Spider] = None) -> Deferred:\n         \"\"\"Return a Deferred which fires with a Response as result, only downloader middlewares are applied\"\"\"\n-        if spider is None:\n-            spider = self.spider\n-        else:\n+        if spider is not None:\n             warnings.warn(\n                 \"Passing a 'spider' argument to ExecutionEngine.download is deprecated\",\n                 category=ScrapyDeprecationWarning,\n                 stacklevel=2,\n             )\n             if spider is not self.spider:\n                 logger.warning(\"The spider '%s' does not match the open spider\", spider.name)\n-        if spider is None:\n+        if self.spider is None:",
      "comment": "For what i understood from PR:\r\n\r\n- #5090 \r\n\r\nThis will be never the case it seems, since the spider instance saved `ExecutionEngine.spider` after calling `open_spider` will be always available, did i get correctly?",
      "comment_id": 937634799,
      "user": "Laerte",
      "created_at": "2022-08-04T10:43:38Z",
      "url": "https://github.com/scrapy/scrapy/pull/5589#discussion_r937634799"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 5589,
      "file_path": "scrapy/core/engine.py",
      "line": 268,
      "side": "RIGHT",
      "diff_hunk": "@@ -257,17 +257,15 @@ def _schedule_request(self, request: Request, spider: Spider) -> None:\n \n     def download(self, request: Request, spider: Optional[Spider] = None) -> Deferred:\n         \"\"\"Return a Deferred which fires with a Response as result, only downloader middlewares are applied\"\"\"\n-        if spider is None:\n-            spider = self.spider\n-        else:\n+        if spider is not None:\n             warnings.warn(\n                 \"Passing a 'spider' argument to ExecutionEngine.download is deprecated\",\n                 category=ScrapyDeprecationWarning,\n                 stacklevel=2,\n             )\n             if spider is not self.spider:\n                 logger.warning(\"The spider '%s' does not match the open spider\", spider.name)\n-        if spider is None:\n+        if self.spider is None:",
      "comment": "@kmike @Gallaecio Lookin in all the tests we always pass the spider instance in `open_spider` (except `tests/test_pipeline_files`, `tests/test_pipeline_media.py`), the test that we can add should be the one to test `RuntimeError` exception then?",
      "comment_id": 951841669,
      "user": "Laerte",
      "created_at": "2022-08-22T19:37:42Z",
      "url": "https://github.com/scrapy/scrapy/pull/5589#discussion_r951841669"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 5450,
      "file_path": "scrapy/utils/url.py",
      "line": 34,
      "side": "RIGHT",
      "diff_hunk": "@@ -31,8 +30,8 @@ def url_is_from_spider(url, spider):\n \n \n def url_has_any_extension(url, extensions):\n-    return posixpath.splitext(parse_url(url).path)[1].lower() in extensions\n-\n+    \"\"\"Return True if the url ends with one of the extensions provided\"\"\"\n+    return any(parse_url(url).path.lower().endswith(ext) for ext in extensions)",
      "comment": "```suggestion\r\n    lowercase_path = parse_url(url).path.lower()\r\n    return any(lowercase_path.endswith(ext) for ext in extensions)\r\n```",
      "comment_id": 828948030,
      "user": "Gallaecio",
      "created_at": "2022-03-17T10:02:29Z",
      "url": "https://github.com/scrapy/scrapy/pull/5450#discussion_r828948030"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 5529,
      "file_path": "scrapy/utils/reactor.py",
      "line": 106,
      "side": "RIGHT",
      "diff_hunk": "@@ -90,6 +90,24 @@ def verify_installed_reactor(reactor_path):\n         raise Exception(msg)\n \n \n+def verify_installed_loop(loop_path):\n+    from twisted.internet import reactor\n+    loop_class = load_object(loop_path)\n+    if isinstance(reactor._asyncioEventloop, loop_class):\n+        return\n+    installed = (\n+        f\"{reactor._asyncioEventloop.__class__.__module__}\"\n+        f\".{reactor._asyncioEventloop.__class__.__qualname__}\"\n+    )\n+    specified = f\"{loop_class.__module__}.{loop_class.__qualname__}\"\n+    raise Exception(\n+        f\"Scrapy found an asyncio Twisted reactor already \"\n+        f\"installed, and its event loop class ({installed}) does \"\n+        f\"not match the one specified in the ASYNCIO_EVENT_LOOP \"",
      "comment": "```suggestion\r\n        \"Scrapy found an asyncio Twisted reactor already \"\r\n        f\"installed, and its event loop class ({installed}) does \"\r\n        \"not match the one specified in the ASYNCIO_EVENT_LOOP \"\r\n```\r\nNitpicking. \ud83e\udd13",
      "comment_id": 896849609,
      "user": "Laerte",
      "created_at": "2022-06-14T13:52:56Z",
      "url": "https://github.com/scrapy/scrapy/pull/5529#discussion_r896849609"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 5529,
      "file_path": "scrapy/utils/reactor.py",
      "line": 106,
      "side": "RIGHT",
      "diff_hunk": "@@ -90,6 +90,24 @@ def verify_installed_reactor(reactor_path):\n         raise Exception(msg)\n \n \n+def verify_installed_loop(loop_path):\n+    from twisted.internet import reactor\n+    loop_class = load_object(loop_path)\n+    if isinstance(reactor._asyncioEventloop, loop_class):\n+        return\n+    installed = (\n+        f\"{reactor._asyncioEventloop.__class__.__module__}\"\n+        f\".{reactor._asyncioEventloop.__class__.__qualname__}\"\n+    )\n+    specified = f\"{loop_class.__module__}.{loop_class.__qualname__}\"\n+    raise Exception(\n+        f\"Scrapy found an asyncio Twisted reactor already \"\n+        f\"installed, and its event loop class ({installed}) does \"\n+        f\"not match the one specified in the ASYNCIO_EVENT_LOOP \"",
      "comment": "I am applying the change, but I must say I am not aware of style guidelines on how to handle this, and as long as [there is no performance or functional reason to do otherwise](https://stackoverflow.com/a/48471223/939364), my personal preference remains to always use the prefix for symmetry :smile: ",
      "comment_id": 896935667,
      "user": "Gallaecio",
      "created_at": "2022-06-14T14:57:48Z",
      "url": "https://github.com/scrapy/scrapy/pull/5529#discussion_r896935667"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 5529,
      "file_path": "scrapy/utils/reactor.py",
      "line": 106,
      "side": "RIGHT",
      "diff_hunk": "@@ -90,6 +90,24 @@ def verify_installed_reactor(reactor_path):\n         raise Exception(msg)\n \n \n+def verify_installed_loop(loop_path):\n+    from twisted.internet import reactor\n+    loop_class = load_object(loop_path)\n+    if isinstance(reactor._asyncioEventloop, loop_class):\n+        return\n+    installed = (\n+        f\"{reactor._asyncioEventloop.__class__.__module__}\"\n+        f\".{reactor._asyncioEventloop.__class__.__qualname__}\"\n+    )\n+    specified = f\"{loop_class.__module__}.{loop_class.__qualname__}\"\n+    raise Exception(\n+        f\"Scrapy found an asyncio Twisted reactor already \"\n+        f\"installed, and its event loop class ({installed}) does \"\n+        f\"not match the one specified in the ASYNCIO_EVENT_LOOP \"",
      "comment": "Cool! I was not aware that this produce the same byte code, basically this is cosmetic preference then. \ud83d\udc85\ud83c\udffb I tend to use this way because is explicit that you have a string interporlation in that line.",
      "comment_id": 896946745,
      "user": "Laerte",
      "created_at": "2022-06-14T15:05:35Z",
      "url": "https://github.com/scrapy/scrapy/pull/5529#discussion_r896946745"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 5529,
      "file_path": "scrapy/utils/reactor.py",
      "line": 93,
      "side": "RIGHT",
      "diff_hunk": "@@ -90,6 +90,24 @@ def verify_installed_reactor(reactor_path):\n         raise Exception(msg)\n \n \n+def verify_installed_loop(loop_path):",
      "comment": "What do you think about adding \"asyncio\" to the name? This function seems to be asyncio-specific.",
      "comment_id": 906863504,
      "user": "kmike",
      "created_at": "2022-06-26T19:49:40Z",
      "url": "https://github.com/scrapy/scrapy/pull/5529#discussion_r906863504"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 5529,
      "file_path": "scrapy/utils/reactor.py",
      "line": 93,
      "side": "RIGHT",
      "diff_hunk": "@@ -90,6 +90,24 @@ def verify_installed_reactor(reactor_path):\n         raise Exception(msg)\n \n \n+def verify_installed_loop(loop_path):",
      "comment": "Looking at the rest of the code, `verify_installed_asyncio_event_loop` would be the most consistent naming. Would it be too verbose?",
      "comment_id": 907265714,
      "user": "Gallaecio",
      "created_at": "2022-06-27T11:12:04Z",
      "url": "https://github.com/scrapy/scrapy/pull/5529#discussion_r907265714"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 5529,
      "file_path": "scrapy/utils/reactor.py",
      "line": 93,
      "side": "RIGHT",
      "diff_hunk": "@@ -90,6 +90,24 @@ def verify_installed_reactor(reactor_path):\n         raise Exception(msg)\n \n \n+def verify_installed_loop(loop_path):",
      "comment": "Sounds good. That's not a function which users are going to call often, that's fine to have a long name for it.",
      "comment_id": 907400779,
      "user": "kmike",
      "created_at": "2022-06-27T13:38:05Z",
      "url": "https://github.com/scrapy/scrapy/pull/5529#discussion_r907400779"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 5645,
      "file_path": "scrapy/utils/display.py",
      "line": 8,
      "side": "RIGHT",
      "diff_hunk": "@@ -5,7 +5,7 @@\n import ctypes\n import platform\n import sys\n-from distutils.version import LooseVersion as parse_version\n+from packaging.version import Version as parse_version",
      "comment": "I think it'd be nice to make `packaging` an explicit dependency in setup.py (add it to install_requires), even if it's usually available. distutils is an stdlib module.",
      "comment_id": 985234301,
      "user": "kmike",
      "created_at": "2022-10-02T12:45:18Z",
      "url": "https://github.com/scrapy/scrapy/pull/5645#discussion_r985234301"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 5657,
      "file_path": "tests/spiders.py",
      "line": 381,
      "side": "RIGHT",
      "diff_hunk": "@@ -369,6 +369,18 @@ def parse(self, response, foo=None):\n         yield Request(self.mockserver.url(\"/status?n=202\"), self.parse, cb_kwargs={\"foo\": \"bar\"})\n \n \n+class CrawlSpiderWithAsyncCallback(CrawlSpiderWithParseMethod):\n+    \"\"\"A CrawlSpider with an async def callback\"\"\"\n+    name = 'crawl_spider_with_async_callback'\n+    rules = (\n+        Rule(LinkExtractor(), callback='parse_async', follow=True),\n+    )\n+\n+    async def parse_async(self, response, foo=None):\n+        self.logger.info('[parse_async] status %i (foo: %s)', response.status, foo)\n+        return Request(self.mockserver.url(\"/status?n=202\"), self.parse_async, cb_kwargs={\"foo\": \"bar\"})",
      "comment": "Could you please also add a test for async generator callback?",
      "comment_id": 985283337,
      "user": "kmike",
      "created_at": "2022-10-02T19:15:54Z",
      "url": "https://github.com/scrapy/scrapy/pull/5657#discussion_r985283337"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 5657,
      "file_path": "tests/spiders.py",
      "line": 381,
      "side": "RIGHT",
      "diff_hunk": "@@ -369,6 +369,18 @@ def parse(self, response, foo=None):\n         yield Request(self.mockserver.url(\"/status?n=202\"), self.parse, cb_kwargs={\"foo\": \"bar\"})\n \n \n+class CrawlSpiderWithAsyncCallback(CrawlSpiderWithParseMethod):\n+    \"\"\"A CrawlSpider with an async def callback\"\"\"\n+    name = 'crawl_spider_with_async_callback'\n+    rules = (\n+        Rule(LinkExtractor(), callback='parse_async', follow=True),\n+    )\n+\n+    async def parse_async(self, response, foo=None):\n+        self.logger.info('[parse_async] status %i (foo: %s)', response.status, foo)\n+        return Request(self.mockserver.url(\"/status?n=202\"), self.parse_async, cb_kwargs={\"foo\": \"bar\"})",
      "comment": "Great point, I missed that. Updated, thanks for the suggestion!",
      "comment_id": 985293579,
      "user": "elacuesta",
      "created_at": "2022-10-02T20:38:54Z",
      "url": "https://github.com/scrapy/scrapy/pull/5657#discussion_r985293579"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 5657,
      "file_path": "scrapy/spiders/crawl.py",
      "line": 117,
      "side": "RIGHT",
      "diff_hunk": "@@ -109,9 +110,13 @@ def _errback(self, failure):\n         rule = self._rules[failure.request.meta['rule']]\n         return self._handle_failure(failure, rule.errback)\n \n-    def _parse_response(self, response, callback, cb_kwargs, follow=True):\n+    async def _parse_response(self, response, callback, cb_kwargs, follow=True):\n         if callback:\n             cb_res = callback(response, **cb_kwargs) or ()\n+            if isinstance(cb_res, AsyncIterable):\n+                cb_res = await collect_asyncgen(cb_res)",
      "comment": "Should we document that for CrawlSpider behavior of async callbacks is different from regular spiders? \r\n\r\nIf I'm not mistaken, here the behavior is similar to Scrapy < 2.7, where the complete output of a callback is awaited before the processing started, while after https://github.com/scrapy/scrapy/pull/4978/ the output (items, requests) is processed as soon as it's sent.",
      "comment_id": 985779888,
      "user": "kmike",
      "created_at": "2022-10-03T13:26:10Z",
      "url": "https://github.com/scrapy/scrapy/pull/5657#discussion_r985779888"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 5657,
      "file_path": "scrapy/spiders/crawl.py",
      "line": 117,
      "side": "RIGHT",
      "diff_hunk": "@@ -109,9 +110,13 @@ def _errback(self, failure):\n         rule = self._rules[failure.request.meta['rule']]\n         return self._handle_failure(failure, rule.errback)\n \n-    def _parse_response(self, response, callback, cb_kwargs, follow=True):\n+    async def _parse_response(self, response, callback, cb_kwargs, follow=True):\n         if callback:\n             cb_res = callback(response, **cb_kwargs) or ()\n+            if isinstance(cb_res, AsyncIterable):\n+                cb_res = await collect_asyncgen(cb_res)",
      "comment": "Makes sense, thanks for pointing it out. Please note that this is coherent with `CrawlSpider.process_results`, which is documented to receive a list (although said docs only mention it in the context of the [XMLFeedSpider](https://docs.scrapy.org/en/latest/topics/spiders.html#scrapy.spiders.XMLFeedSpider.process_results))",
      "comment_id": 986110758,
      "user": "elacuesta",
      "created_at": "2022-10-03T18:42:48Z",
      "url": "https://github.com/scrapy/scrapy/pull/5657#discussion_r986110758"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 5617,
      "file_path": "tests/test_spider.py",
      "line": 370,
      "side": "RIGHT",
      "diff_hunk": "@@ -360,10 +362,12 @@ def process_request_upper(self, request, response):\n         output = list(spider._requests_to_follow(response))\n         self.assertEqual(len(output), 3)\n         self.assertTrue(all(map(lambda r: isinstance(r, Request), output)))\n-        self.assertEqual([r.url for r in output],\n-                         ['http://EXAMPLE.ORG/SOMEPAGE/ITEM/12.HTML',\n-                          'http://EXAMPLE.ORG/ABOUT.HTML',\n-                          'http://EXAMPLE.ORG/NOFOLLOW.HTML'])\n+        urls = ['http://EXAMPLE.ORG/SOMEPAGE/ITEM/12.HTML',\n+                'http://EXAMPLE.ORG/ABOUT.HTML',\n+                'http://EXAMPLE.ORG/NOFOLLOW.HTML']\n+        if parse_version(w3lib_version) >= parse_version('2.0.0'):\n+            urls = list(map(lambda u: u.replace(\"EXAMPLE.ORG\", \"example.org\"), urls))\n+        self.assertEqual([r.url for r in output], urls)",
      "comment": "I ask as someone completely unfamiliar with this test: would it make sense to change the test so that valid domains are used? Or is the use of invalid domains page of what the test is checking for? And, if the later, why? Should we also skip this test with w3lib 2+ and plan to think of a way to test this on w3lib 2+ later?",
      "comment_id": 963624153,
      "user": "Gallaecio",
      "created_at": "2022-09-06T12:10:24Z",
      "url": "https://github.com/scrapy/scrapy/pull/5617#discussion_r963624153"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 5617,
      "file_path": "tests/test_spider.py",
      "line": 370,
      "side": "RIGHT",
      "diff_hunk": "@@ -360,10 +362,12 @@ def process_request_upper(self, request, response):\n         output = list(spider._requests_to_follow(response))\n         self.assertEqual(len(output), 3)\n         self.assertTrue(all(map(lambda r: isinstance(r, Request), output)))\n-        self.assertEqual([r.url for r in output],\n-                         ['http://EXAMPLE.ORG/SOMEPAGE/ITEM/12.HTML',\n-                          'http://EXAMPLE.ORG/ABOUT.HTML',\n-                          'http://EXAMPLE.ORG/NOFOLLOW.HTML'])\n+        urls = ['http://EXAMPLE.ORG/SOMEPAGE/ITEM/12.HTML',\n+                'http://EXAMPLE.ORG/ABOUT.HTML',\n+                'http://EXAMPLE.ORG/NOFOLLOW.HTML']\n+        if parse_version(w3lib_version) >= parse_version('2.0.0'):\n+            urls = list(map(lambda u: u.replace(\"EXAMPLE.ORG\", \"example.org\"), urls))\n+        self.assertEqual([r.url for r in output], urls)",
      "comment": "I've looked at the test and thought that it just tests that the `process_request_upper()` method actually ran, by checking that the URLs were modified. Assuming this is true, it can be changed to some other modification.",
      "comment_id": 963626192,
      "user": "wRAR",
      "created_at": "2022-09-06T12:12:34Z",
      "url": "https://github.com/scrapy/scrapy/pull/5617#discussion_r963626192"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 5617,
      "file_path": "tests/test_spider.py",
      "line": 370,
      "side": "RIGHT",
      "diff_hunk": "@@ -360,10 +362,12 @@ def process_request_upper(self, request, response):\n         output = list(spider._requests_to_follow(response))\n         self.assertEqual(len(output), 3)\n         self.assertTrue(all(map(lambda r: isinstance(r, Request), output)))\n-        self.assertEqual([r.url for r in output],\n-                         ['http://EXAMPLE.ORG/SOMEPAGE/ITEM/12.HTML',\n-                          'http://EXAMPLE.ORG/ABOUT.HTML',\n-                          'http://EXAMPLE.ORG/NOFOLLOW.HTML'])\n+        urls = ['http://EXAMPLE.ORG/SOMEPAGE/ITEM/12.HTML',\n+                'http://EXAMPLE.ORG/ABOUT.HTML',\n+                'http://EXAMPLE.ORG/NOFOLLOW.HTML']\n+        if parse_version(w3lib_version) >= parse_version('2.0.0'):\n+            urls = list(map(lambda u: u.replace(\"EXAMPLE.ORG\", \"example.org\"), urls))\n+        self.assertEqual([r.url for r in output], urls)",
      "comment": "@wRAR @Gallaecio  Maybe we can use `safe_url_string` for each url, with this the output will be standarized for all `w3lib` versions. What you guys think?",
      "comment_id": 963636276,
      "user": "Laerte",
      "created_at": "2022-09-06T12:21:11Z",
      "url": "https://github.com/scrapy/scrapy/pull/5617#discussion_r963636276"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 5617,
      "file_path": "tests/test_spider.py",
      "line": 370,
      "side": "RIGHT",
      "diff_hunk": "@@ -360,10 +362,12 @@ def process_request_upper(self, request, response):\n         output = list(spider._requests_to_follow(response))\n         self.assertEqual(len(output), 3)\n         self.assertTrue(all(map(lambda r: isinstance(r, Request), output)))\n-        self.assertEqual([r.url for r in output],\n-                         ['http://EXAMPLE.ORG/SOMEPAGE/ITEM/12.HTML',\n-                          'http://EXAMPLE.ORG/ABOUT.HTML',\n-                          'http://EXAMPLE.ORG/NOFOLLOW.HTML'])\n+        urls = ['http://EXAMPLE.ORG/SOMEPAGE/ITEM/12.HTML',\n+                'http://EXAMPLE.ORG/ABOUT.HTML',\n+                'http://EXAMPLE.ORG/NOFOLLOW.HTML']\n+        if parse_version(w3lib_version) >= parse_version('2.0.0'):\n+            urls = list(map(lambda u: u.replace(\"EXAMPLE.ORG\", \"example.org\"), urls))\n+        self.assertEqual([r.url for r in output], urls)",
      "comment": "https://github.com/scrapy/scrapy/pull/5617/commits/582a6bf6dbcb01da40cbec6b51269add2db39cf1 is not what I thought you meant, I thought you meant using safe_url_string in the method that uppercases the URLs originally.\r\n\r\nThat said, it seems like a very valid alternative to me. Great job!",
      "comment_id": 964380305,
      "user": "Gallaecio",
      "created_at": "2022-09-07T04:54:02Z",
      "url": "https://github.com/scrapy/scrapy/pull/5617#discussion_r964380305"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 5617,
      "file_path": "tests/test_spider.py",
      "line": 370,
      "side": "RIGHT",
      "diff_hunk": "@@ -360,10 +362,12 @@ def process_request_upper(self, request, response):\n         output = list(spider._requests_to_follow(response))\n         self.assertEqual(len(output), 3)\n         self.assertTrue(all(map(lambda r: isinstance(r, Request), output)))\n-        self.assertEqual([r.url for r in output],\n-                         ['http://EXAMPLE.ORG/SOMEPAGE/ITEM/12.HTML',\n-                          'http://EXAMPLE.ORG/ABOUT.HTML',\n-                          'http://EXAMPLE.ORG/NOFOLLOW.HTML'])\n+        urls = ['http://EXAMPLE.ORG/SOMEPAGE/ITEM/12.HTML',\n+                'http://EXAMPLE.ORG/ABOUT.HTML',\n+                'http://EXAMPLE.ORG/NOFOLLOW.HTML']\n+        if parse_version(w3lib_version) >= parse_version('2.0.0'):\n+            urls = list(map(lambda u: u.replace(\"EXAMPLE.ORG\", \"example.org\"), urls))\n+        self.assertEqual([r.url for r in output], urls)",
      "comment": "@wRAR Feel free to merge if you are also OK with the change.",
      "comment_id": 964380602,
      "user": "Gallaecio",
      "created_at": "2022-09-07T04:54:45Z",
      "url": "https://github.com/scrapy/scrapy/pull/5617#discussion_r964380602"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 5225,
      "file_path": "tests/test_utils_misc/__init__.py",
      "line": 169,
      "side": "RIGHT",
      "diff_hunk": "@@ -162,6 +162,12 @@ def test_set_environ(self):\n             assert os.environ.get('some_test_environ') == 'test_value'\n         assert os.environ.get('some_test_environ') == 'test'\n \n+    def test_rel_has_nofollow(self):\n+        assert os.environ.get('some_test_environ') is None\n+        asert rel_has_nofollow('ugc nofollow') == True\n+        asert rel_has_nofollow('ugc,nofollow') == True\n+        asert rel_has_nofollow('ugc') == False",
      "comment": "What about also testing some more combinations?\r\n\r\n```\r\nnofollow True\r\nnofollow foo True\r\nnofollow,foo True\r\nfoo,  ,  nofollow True\r\nfoonofollow False\r\nnofollowfoo False\r\n```",
      "comment_id": 686290192,
      "user": "Gallaecio",
      "created_at": "2021-08-10T20:14:35Z",
      "url": "https://github.com/scrapy/scrapy/pull/5225#discussion_r686290192"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 5526,
      "file_path": "scrapy/http/headers.py",
      "line": 4,
      "side": "RIGHT",
      "diff_hunk": "@@ -1,6 +1,7 @@\n from w3lib.http import headers_dict_to_raw\n from scrapy.utils.datatypes import CaselessDict\n from scrapy.utils.python import to_unicode\n+from collections.abc import Mapping",
      "comment": ":lipstick: \r\n\r\n```suggestion\r\nfrom collections.abc import Mapping\r\n\r\nfrom w3lib.http import headers_dict_to_raw\r\nfrom scrapy.utils.datatypes import CaselessDict\r\nfrom scrapy.utils.python import to_unicode\r\n```",
      "comment_id": 895547569,
      "user": "Gallaecio",
      "created_at": "2022-06-13T10:05:22Z",
      "url": "https://github.com/scrapy/scrapy/pull/5526#discussion_r895547569"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 5526,
      "file_path": "tests/test_http_headers.py",
      "line": 46,
      "side": "RIGHT",
      "diff_hunk": "@@ -38,6 +38,13 @@ def test_multivalue(self):\n         self.assertEqual(h.getlist('X-Forwarded-For'), [b'ip1', b'ip2'])\n         assert h.getlist('X-Forwarded-For') is not hlist\n \n+    def test_multivalue_for_one_header(self):\n+        h = Headers(((\"a\", \"b\"), (\"a\", \"c\")))\n+        self.assertEqual(h[\"a\"], b\"c\")\n+        self.assertEqual(h.get(\"a\"), b\"c\")\n+        self.assertEqual(h.getlist(\"a\"), [b\"b\", b\"c\"])\n+        assert h.getlist(\"a\") is not [\"b\", \"c\"]",
      "comment": "this check always returns True:\r\n\r\n```py\r\nIn [1]: [\"b\", \"c\"] is not [\"b\", \"c\"]\r\nOut[1]: True\r\n```",
      "comment_id": 895972813,
      "user": "kmike",
      "created_at": "2022-06-13T17:35:25Z",
      "url": "https://github.com/scrapy/scrapy/pull/5526#discussion_r895972813"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 3696,
      "file_path": "scrapy/settings/__init__.py",
      "line": 210,
      "side": "RIGHT",
      "diff_hunk": "@@ -197,6 +198,39 @@ def getdict(self, name, default=None):\n             value = json.loads(value)\n         return dict(value)\n \n+    def getdictorlist(self, name, default=None):\n+        \"\"\"Get a setting value as either an ``OrderedDict`` or a list.\n+\n+        If the setting is already a dict or a list, a copy of it will be\n+        returned.\n+\n+        If it is a string it will be evaluated as JSON, or as a comma-separated\n+        list of strings as a fallback.\n+\n+        For example, settings populated through environment variables will",
      "comment": "Do we support populating settings through environment variables? I recall there was something about it, but not sure it is documented.",
      "comment_id": 370373987,
      "user": "kmike",
      "created_at": "2020-01-23T21:51:16Z",
      "url": "https://github.com/scrapy/scrapy/pull/3696#discussion_r370373987"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 3696,
      "file_path": "tests/test_feedexport.py",
      "line": 639,
      "side": "RIGHT",
      "diff_hunk": "@@ -606,6 +607,62 @@ class MyItem2(scrapy.Item):\n         yield self.assertExported(items, header, rows,\n                                   settings=settings, ordered=True)\n \n+        # fields may be defined as a comma-separated list\n+        header = [\"foo\", \"baz\", \"hello\"]\n+        settings = {'FEED_EXPORT_FIELDS': \",\".join(header)}\n+        rows = [\n+            {'foo': 'bar1', 'baz': '',      'hello': ''},\n+            {'foo': 'bar2', 'baz': '',      'hello': 'world2'},\n+            {'foo': 'bar3', 'baz': 'quux3', 'hello': ''},\n+            {'foo': '',     'baz': '',      'hello': 'world4'},\n+        ]\n+        yield self.assertExported(items, header, rows,\n+                                  settings=settings, ordered=True)\n+\n+        # fields may also be defined as a JSON array\n+        header = [\"foo\", \"baz\", \"hello\"]\n+        settings = {'FEED_EXPORT_FIELDS': json.dumps(header)}\n+        rows = [\n+            {'foo': 'bar1', 'baz': '',      'hello': ''},\n+            {'foo': 'bar2', 'baz': '',      'hello': 'world2'},\n+            {'foo': 'bar3', 'baz': 'quux3', 'hello': ''},\n+            {'foo': '',     'baz': '',      'hello': 'world4'},\n+        ]\n+        yield self.assertExported(items, header, rows,\n+                                  settings=settings, ordered=True)\n+\n+        # custom output field names can be specified\n+        header = OrderedDict((\n+            (\"foo\", \"Foo\"),\n+            (\"baz\", \"Baz\"),\n+            (\"hello\", \"Hello\"),\n+        ))",
      "comment": "Could you please add a test for a regular dict, and ensure that order is preserved in Python 3.7+?",
      "comment_id": 370375426,
      "user": "kmike",
      "created_at": "2020-01-23T21:54:51Z",
      "url": "https://github.com/scrapy/scrapy/pull/3696#discussion_r370375426"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 3696,
      "file_path": "scrapy/settings/__init__.py",
      "line": 202,
      "side": "RIGHT",
      "diff_hunk": "@@ -197,6 +198,38 @@ def getdict(self, name, default=None):\n             value = json.loads(value)\n         return dict(value)\n \n+    def getdictorlist(self, name, default=None):\n+        \"\"\"Get a setting value as either an ``OrderedDict`` or a list.",
      "comment": "I wonder if OrderedDict support is needed, given that Scrapy requires Python 3.6+",
      "comment_id": 883516527,
      "user": "kmike",
      "created_at": "2022-05-27T11:15:51Z",
      "url": "https://github.com/scrapy/scrapy/pull/3696#discussion_r883516527"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 3696,
      "file_path": "tests/test_feedexport.py",
      "line": 1172,
      "side": "RIGHT",
      "diff_hunk": "@@ -1118,7 +1169,7 @@ def test_export_feed_export_fields(self):\n                 {'egg': 'spam2', 'foo': 'bar2', 'baz': 'quux2'}\n             ]\n             yield self.assertExported(items, ['foo', 'baz', 'egg'], rows,\n-                                      settings=settings, ordered=True)\n+                                      settings=settings)",
      "comment": "Do we still need \"ordered\" parameter in assertExported / assertExportedCsv, or can we remove code for handling ordered=False?",
      "comment_id": 899457839,
      "user": "kmike",
      "created_at": "2022-06-16T19:32:43Z",
      "url": "https://github.com/scrapy/scrapy/pull/3696#discussion_r899457839"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 3696,
      "file_path": "tests/test_feedexport.py",
      "line": 1172,
      "side": "RIGHT",
      "diff_hunk": "@@ -1118,7 +1169,7 @@ def test_export_feed_export_fields(self):\n                 {'egg': 'spam2', 'foo': 'bar2', 'baz': 'quux2'}\n             ]\n             yield self.assertExported(items, ['foo', 'baz', 'egg'], rows,\n-                                      settings=settings, ordered=True)\n+                                      settings=settings)",
      "comment": "It seems so, https://github.com/scrapy/scrapy/pull/3696/commits/24f382fa459434cccfa4c0a8884a48d09d75e243 caused at least 3 tests to fail due to a different output order.",
      "comment_id": 899820601,
      "user": "Gallaecio",
      "created_at": "2022-06-17T06:57:37Z",
      "url": "https://github.com/scrapy/scrapy/pull/3696#discussion_r899820601"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 3696,
      "file_path": "tests/test_feedexport.py",
      "line": 1172,
      "side": "RIGHT",
      "diff_hunk": "@@ -1118,7 +1169,7 @@ def test_export_feed_export_fields(self):\n                 {'egg': 'spam2', 'foo': 'bar2', 'baz': 'quux2'}\n             ]\n             yield self.assertExported(items, ['foo', 'baz', 'egg'], rows,\n-                                      settings=settings, ordered=True)\n+                                      settings=settings)",
      "comment": "Hmm\u2026 Looking in more detail, maybe the issues are solvable without allowing a different order\u2026",
      "comment_id": 899822327,
      "user": "Gallaecio",
      "created_at": "2022-06-17T07:00:28Z",
      "url": "https://github.com/scrapy/scrapy/pull/3696#discussion_r899822327"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 5482,
      "file_path": "scrapy/commands/parse.py",
      "line": 54,
      "side": "RIGHT",
      "diff_hunk": "@@ -51,7 +51,7 @@ def add_options(self, parser):\n         parser.add_argument(\"--cbkwargs\", dest=\"cbkwargs\",\n                             help=\"inject extra callback kwargs into the Request, it must be a valid raw json string\")\n         parser.add_argument(\"-d\", \"--depth\", dest=\"depth\", type=int, default=1,\n-                            help=\"maximum depth for parsing requests [default: %default]\")\n+                            help=\"maximum depth for parsing requests [default: 1]\")",
      "comment": "```suggestion\r\n                            help=\"maximum depth for parsing requests [default: %(default)s]\")\r\n```\r\nThis way you don't need to define twice. Syntax is from documentation<sup>[1](https://docs.python.org/3/library/argparse.html)</sup>. Tested locally and it works!\r\n\r\n> Replace strings with implicit arguments such as %default or %prog with the standard Python syntax to use dictionaries to format strings, that is, %(default)s and %(prog)s.\r\n\r\n",
      "comment_id": 851739683,
      "user": "Laerte",
      "created_at": "2022-04-17T11:05:08Z",
      "url": "https://github.com/scrapy/scrapy/pull/5482#discussion_r851739683"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 5514,
      "file_path": "setup.py",
      "line": 45,
      "side": "RIGHT",
      "diff_hunk": "@@ -19,35 +19,30 @@ def has_environment_marker_platform_impl_support():\n \n \n install_requires = [\n-    'Twisted>=17.9.0',\n-    'cryptography>=2.0',\n+    'Twisted>=18.9.0',\n+    'cryptography>=2.8',\n     'cssselect>=0.9.1',\n     'itemloaders>=1.0.1',\n     'parsel>=1.5.0',\n-    'pyOpenSSL>=16.2.0',\n+    'pyOpenSSL>=19.1.0',\n     'queuelib>=1.4.2',\n     'service_identity>=16.0.0',\n     'w3lib>=1.17.0',\n-    'zope.interface>=4.1.3',\n+    'zope.interface>=5.1.0',\n     'protego>=0.1.15',\n     'itemadapter>=0.1.0',\n     'setuptools',\n     'tldextract',\n ]\n extras_require = {}\n cpython_dependencies = [\n-    'lxml>=3.5.0',\n+    'lxml>=4.3.0',\n     'PyDispatcher>=2.0.5',\n ]\n if has_environment_marker_platform_impl_support():\n     extras_require[':platform_python_implementation == \"CPython\"'] = cpython_dependencies\n     extras_require[':platform_python_implementation == \"PyPy\"'] = [\n-        # Earlier lxml versions are affected by\n-        # https://foss.heptapod.net/pypy/pypy/-/issues/2498,\n-        # which was fixed in Cython 0.26, released on 2017-06-19, and used to\n-        # generate the C headers of lxml release tarballs published since then, the\n-        # first of which was:\n-        'lxml>=4.0.0',\n+        'lxml>=4.3.0',",
      "comment": "The 2 `'lxml>=4.3.0'` can now be removed and replaced by a single `'lxml>=4.3.0'` in `install_requires` above.",
      "comment_id": 890087807,
      "user": "Gallaecio",
      "created_at": "2022-06-06T12:13:03Z",
      "url": "https://github.com/scrapy/scrapy/pull/5514#discussion_r890087807"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 4524,
      "file_path": "scrapy/dupefilters.py",
      "line": 67,
      "side": "RIGHT",
      "diff_hunk": "@@ -38,10 +39,32 @@ def __init__(self, path=None, debug=False):\n             self.file.seek(0)\n             self.fingerprints.update(x.rstrip() for x in self.file)\n \n+    @classmethod\n+    def from_crawler(cls, crawler):\n+        try:\n+            dupefilter = cls.from_settings(crawler.settings)\n+        except AttributeError:\n+            debug = crawler.settings.getbool('DUPEFILTER_DEBUG')\n+            fingerprinter = crawler.settings.getinstance(\n+                'REQUEST_FINGERPRINTER',\n+                crawler=crawler,\n+                singleton=True,\n+            )\n+            dupefilter = cls(\n+                job_dir(crawler.settings),\n+                debug,\n+                fingerprinter=fingerprinter,\n+            )\n+        return dupefilter\n+\n     @classmethod\n     def from_settings(cls, settings):\n         debug = settings.getbool('DUPEFILTER_DEBUG')\n-        return cls(job_dir(settings), debug)\n+        fingerprinter = settings.getinstance(\n+            'REQUEST_FINGERPRINTER',\n+            singleton=True,\n+        )\n+        return cls(job_dir(settings), debug, fingerprinter=fingerprinter)",
      "comment": "Is from_settings method required just for backwards compatibility, or is there another reason code is duplicated here?",
      "comment_id": 416922924,
      "user": "kmike",
      "created_at": "2020-04-28T21:07:06Z",
      "url": "https://github.com/scrapy/scrapy/pull/4524#discussion_r416922924"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 4524,
      "file_path": "scrapy/settings/__init__.py",
      "line": 238,
      "side": "RIGHT",
      "diff_hunk": "@@ -233,6 +235,47 @@ def maxpriority(self):\n         else:\n             return get_settings_priority('default')\n \n+    def getinstance(self, name, *, crawler=None, singleton=False):",
      "comment": "Aha, I see the problem now: you can't just create RequestFingerprinter in a dupefilter, because other components also may need to access it.\r\n\r\nI'm not sure though that settings is a best place to handle this singleton. \r\n\r\n1) All other settings return simple values at the moment - str, list, dict.\r\n2) You need to pass crawler here, but only once - on a first call. On all other calls crawler is not necessary. But we need to ensure that the first call was a call which passed a crawler.\r\n\r\nI haven't checked it in detail, but what do you think about making fingerprinter a more \"fundamental\" thing, maybe a Crawler attribute, similar to logformatter or stats? In this case logic around singletons won't be needed.\r\n",
      "comment_id": 416927742,
      "user": "kmike",
      "created_at": "2020-04-28T21:15:53Z",
      "url": "https://github.com/scrapy/scrapy/pull/4524#discussion_r416927742"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 4524,
      "file_path": "scrapy/settings/__init__.py",
      "line": 238,
      "side": "RIGHT",
      "diff_hunk": "@@ -233,6 +235,47 @@ def maxpriority(self):\n         else:\n             return get_settings_priority('default')\n \n+    def getinstance(self, name, *, crawler=None, singleton=False):",
      "comment": "This may require an access to Crawler in some places where it was not possible before though; it could make the scope of this PR larger.",
      "comment_id": 416930750,
      "user": "kmike",
      "created_at": "2020-04-28T21:21:41Z",
      "url": "https://github.com/scrapy/scrapy/pull/4524#discussion_r416930750"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 4524,
      "file_path": "scrapy/dupefilters.py",
      "line": 67,
      "side": "RIGHT",
      "diff_hunk": "@@ -38,10 +39,32 @@ def __init__(self, path=None, debug=False):\n             self.file.seek(0)\n             self.fingerprints.update(x.rstrip() for x in self.file)\n \n+    @classmethod\n+    def from_crawler(cls, crawler):\n+        try:\n+            dupefilter = cls.from_settings(crawler.settings)\n+        except AttributeError:\n+            debug = crawler.settings.getbool('DUPEFILTER_DEBUG')\n+            fingerprinter = crawler.settings.getinstance(\n+                'REQUEST_FINGERPRINTER',\n+                crawler=crawler,\n+                singleton=True,\n+            )\n+            dupefilter = cls(\n+                job_dir(crawler.settings),\n+                debug,\n+                fingerprinter=fingerprinter,\n+            )\n+        return dupefilter\n+\n     @classmethod\n     def from_settings(cls, settings):\n         debug = settings.getbool('DUPEFILTER_DEBUG')\n-        return cls(job_dir(settings), debug)\n+        fingerprinter = settings.getinstance(\n+            'REQUEST_FINGERPRINTER',\n+            singleton=True,\n+        )\n+        return cls(job_dir(settings), debug, fingerprinter=fingerprinter)",
      "comment": "Backward compatibility (subclasses calling `super().from_settings()`?). I must say that it is not that clear to me how inheritance and these class methods should be handled.\r\n\r\nIf you are OK with it, I\u2019ll just drop the class method. Otherwise, things get really messy.",
      "comment_id": 420801063,
      "user": "Gallaecio",
      "created_at": "2020-05-06T13:43:50Z",
      "url": "https://github.com/scrapy/scrapy/pull/4524#discussion_r420801063"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 4524,
      "file_path": "scrapy/crawler.py",
      "line": 54,
      "side": "RIGHT",
      "diff_hunk": "@@ -50,6 +50,12 @@ def __init__(self, spidercls, settings=None):\n         self.spidercls.update_settings(self.settings)\n \n         self.signals = SignalManager(self)\n+\n+        self.request_fingerprinter = create_instance(",
      "comment": "Any reason for putting it before creation of logging and stats component? I wonder if there is a use case for having access to them in fingerprinter's from_crawler / init methods.",
      "comment_id": 420901135,
      "user": "kmike",
      "created_at": "2020-05-06T15:52:49Z",
      "url": "https://github.com/scrapy/scrapy/pull/4524#discussion_r420901135"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 4524,
      "file_path": "scrapy/crawler.py",
      "line": 54,
      "side": "RIGHT",
      "diff_hunk": "@@ -50,6 +50,12 @@ def __init__(self, spidercls, settings=None):\n         self.spidercls.update_settings(self.settings)\n \n         self.signals = SignalManager(self)\n+\n+        self.request_fingerprinter = create_instance(",
      "comment": "No, I simply wanted to make sure signals were available. I\u2019ll move it further down.",
      "comment_id": 420904790,
      "user": "Gallaecio",
      "created_at": "2020-05-06T15:57:35Z",
      "url": "https://github.com/scrapy/scrapy/pull/4524#discussion_r420904790"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 4524,
      "file_path": "scrapy/settings/__init__.py",
      "line": 86,
      "side": "RIGHT",
      "diff_hunk": "@@ -83,6 +83,7 @@ class BaseSettings(MutableMapping):\n     def __init__(self, values=None, priority='project'):\n         self.frozen = False\n         self.attributes = {}\n+        self._singletons = {}",
      "comment": "Is this a leftover from a previous implementation? There seems to be no other occurrence in this diff at the moment.",
      "comment_id": 423726562,
      "user": "elacuesta",
      "created_at": "2020-05-12T13:20:35Z",
      "url": "https://github.com/scrapy/scrapy/pull/4524#discussion_r423726562"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 4524,
      "file_path": "scrapy/utils/request.py",
      "line": 107,
      "side": "RIGHT",
      "diff_hunk": "@@ -48,6 +104,7 @@ def request_fingerprint(request, include_headers=None, keep_fragments=False):\n     If you want to include them, set the keep_fragments argument to True\n     (for instance when handling requests with a headless browser).\n \n+    :rtype: bytes",
      "comment": "What do you think about using type annotations instead? ",
      "comment_id": 474891969,
      "user": "kmike",
      "created_at": "2020-08-21T19:27:54Z",
      "url": "https://github.com/scrapy/scrapy/pull/4524#discussion_r474891969"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 4524,
      "file_path": "scrapy/dupefilters.py",
      "line": 64,
      "side": "RIGHT",
      "diff_hunk": "@@ -27,32 +27,42 @@ def log(self, request, spider):  # log that a request has been filtered\n class RFPDupeFilter(BaseDupeFilter):\n     \"\"\"Request Fingerprint duplicates filter\"\"\"\n \n-    def __init__(self, path=None, debug=False):\n+    def __init__(self, path=None, debug=False, *, fingerprinter=None):\n         self.file = None\n+        self.fingerprinter = fingerprinter or RequestFingerprinter()\n         self.fingerprints = set()\n         self.logdupes = True\n         self.debug = debug\n         self.logger = logging.getLogger(__name__)\n         if path:\n             self.file = open(os.path.join(path, 'requests.seen'), 'a+')\n             self.file.seek(0)\n-            self.fingerprints.update(x.rstrip() for x in self.file)\n+            self.fingerprints.update(bytes.fromhex(x.rstrip())\n+                                     for x in self.file)\n \n     @classmethod\n-    def from_settings(cls, settings):\n-        debug = settings.getbool('DUPEFILTER_DEBUG')\n-        return cls(job_dir(settings), debug)\n+    def from_crawler(cls, crawler):\n+        path = job_dir(crawler.settings)\n+        debug = crawler.settings.getbool('DUPEFILTER_DEBUG')\n+        fingerprinter = crawler.request_fingerprinter\n+        try:\n+            result = cls.from_settings(crawler.settings)\n+        except AttributeError:\n+            return cls(path=path, debug=debug, fingerprinter=fingerprinter)\n+        else:\n+            result.fingerprinter = fingerprinter\n+            return result\n \n     def request_seen(self, request):\n         fp = self.request_fingerprint(request)\n         if fp in self.fingerprints:\n             return True\n         self.fingerprints.add(fp)\n         if self.file:\n-            self.file.write(fp + '\\n')\n+            self.file.write(fp.hex() + '\\n')\n \n     def request_fingerprint(self, request):",
      "comment": "These changes could be backwards incompatible for RFPDupeFilter subclasses which override request_fingerprint method. These overridden methods are going to return str, which could fail later (e.g. when storing to a file in request_seen method).",
      "comment_id": 474900832,
      "user": "kmike",
      "created_at": "2020-08-21T19:38:58Z",
      "url": "https://github.com/scrapy/scrapy/pull/4524#discussion_r474900832"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 4524,
      "file_path": "scrapy/dupefilters.py",
      "line": 64,
      "side": "RIGHT",
      "diff_hunk": "@@ -59,10 +58,10 @@ def request_seen(self, request):\n             return True\n         self.fingerprints.add(fp)\n         if self.file:\n-            self.file.write(fp.hex() + '\\n')\n+            self.file.write(fp + '\\n')\n \n     def request_fingerprint(self, request):\n-        return self.fingerprinter.fingerprint(request)\n+        return self.fingerprinter.fingerprint(request).hex()",
      "comment": "That's unfortunate we won't be able to get efficiency gains from switching to bytes (less memory usage). So we're making a step in a right direction, but not actually fixing the issue. \r\n\r\nWe would still need to make a backwards-incompatible change to RFPDupeFilter (or figure out a workaround) to actually make use of the new bytes interface. I think that's fine to handle this separately, if we're sure the current code changes allow us to do that easier. What do you think @Gallaecio?",
      "comment_id": 477515464,
      "user": "kmike",
      "created_at": "2020-08-26T18:52:08Z",
      "url": "https://github.com/scrapy/scrapy/pull/4524#discussion_r477515464"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 4524,
      "file_path": "scrapy/dupefilters.py",
      "line": 64,
      "side": "RIGHT",
      "diff_hunk": "@@ -59,10 +58,10 @@ def request_seen(self, request):\n             return True\n         self.fingerprints.add(fp)\n         if self.file:\n-            self.file.write(fp.hex() + '\\n')\n+            self.file.write(fp + '\\n')\n \n     def request_fingerprint(self, request):\n-        return self.fingerprinter.fingerprint(request)\n+        return self.fingerprinter.fingerprint(request).hex()",
      "comment": "I agree with changing it separately.\r\n\r\nGiven the duplicate filter class API (which made sense before centralized fingerprings), the only backward-compatible way forward I can think of would be to deprecate the class in favor of a new one that uses binary fingerprints.",
      "comment_id": 478222751,
      "user": "Gallaecio",
      "created_at": "2020-08-27T07:46:14Z",
      "url": "https://github.com/scrapy/scrapy/pull/4524#discussion_r478222751"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 4524,
      "file_path": "scrapy/utils/request.py",
      "line": 76,
      "side": "RIGHT",
      "diff_hunk": "@@ -68,6 +70,67 @@ def request_fingerprint(request, include_headers=None, keep_fragments=False):\n     return cache[cache_key]\n \n \n+_fingerprint_cache = weakref.WeakKeyDictionary()\n+\n+\n+def fingerprint(request, include_headers=None, keep_fragments=False) -> bytes:",
      "comment": "A chance for a clean-up :)\r\n\r\n```suggestion\r\ndef fingerprint(request, *, include_headers=None, keep_fragments=False) -> bytes:\r\n```",
      "comment_id": 478228081,
      "user": "kmike",
      "created_at": "2020-08-27T07:56:10Z",
      "url": "https://github.com/scrapy/scrapy/pull/4524#discussion_r478228081"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 4524,
      "file_path": "scrapy/utils/request.py",
      "line": 121,
      "side": "RIGHT",
      "diff_hunk": "@@ -68,6 +70,67 @@ def request_fingerprint(request, include_headers=None, keep_fragments=False):\n     return cache[cache_key]\n \n \n+_fingerprint_cache = weakref.WeakKeyDictionary()\n+\n+\n+def fingerprint(request, *, include_headers=None, keep_fragments=False) -> bytes:\n+    \"\"\"\n+    Return the request fingerprint.\n+\n+    The request fingerprint is a hash that uniquely identifies the resource the\n+    request points to. For example, take the following two urls:\n+\n+    http://www.example.com/query?id=111&cat=222\n+    http://www.example.com/query?cat=222&id=111\n+\n+    Even though those are two different URLs both point to the same resource\n+    and are equivalent (i.e. they should return the same response).\n+\n+    Another example are cookies used to store session ids. Suppose the\n+    following page is only accessible to authenticated users:\n+\n+    http://www.example.com/members/offers.html\n+\n+    Lots of sites use a cookie to store the session id, which adds a random\n+    component to the HTTP Request and thus should be ignored when calculating\n+    the fingerprint.\n+\n+    For this reason, request headers are ignored by default when calculating\n+    the fingeprint. If you want to include specific headers use the\n+    include_headers argument, which is a list of Request headers to include.\n+\n+    Also, servers usually ignore fragments in urls when handling requests,\n+    so they are also ignored by default when calculating the fingerprint.\n+    If you want to include them, set the keep_fragments argument to True\n+    (for instance when handling requests with a headless browser).\n+    \"\"\"\n+    if include_headers:\n+        include_headers = tuple(to_bytes(h.lower()) for h in sorted(include_headers))\n+    cache = _fingerprint_cache.setdefault(request, {})\n+    cache_key = (include_headers, keep_fragments)\n+    if cache_key not in cache:\n+        fp = hashlib.sha1()\n+        fp.update(to_bytes(request.method))\n+        fp.update(to_bytes(canonicalize_url(request.url, keep_fragments=keep_fragments)))\n+        fp.update(request.body or b'')\n+        if include_headers:\n+            for hdr in include_headers:\n+                if hdr in request.headers:\n+                    fp.update(hdr)\n+                    for v in request.headers.getlist(hdr):\n+                        fp.update(v)",
      "comment": "Sorry, I'm getting more an more unrelated comments on this PR :) This is a nitpick, but it looks like body & headers & values are not separated where fp is being built. So e.g. a request with header with \"foo\" and \"bar\" values would get the same fingerprint as a request with \"fo\" and \"obar\" values. The same applies for body, etc. URL is joined with the body, for example, so a POST request to http://example.com with empty body may get the same fingerprint as a POST request to http://example.co with \"m\" body.\r\n\r\nMaybe it was not invisible in past, because such cases are rare, and because include_headers was a bit tricky to use. Now we're documenting how to use it, so the issue may become a bit more important. \r\n\r\nChanging the fingerprint for a request should be considered a backwards incompatible change - e.g. disk cache will be effectively emptied after Scrapy upgrade. Here we're introducing a new function, so there can be an argument that we should make the change now, to not change the new function in future. But I think this can be done separately - a real breaking change is not the output of fingerprint function per se, but fingerprints requests get by default, so we can't avoid making this non-breaking. Opened a placeholder https://github.com/scrapy/scrapy/issues/4762 for that.\r\n\r\n\r\n",
      "comment_id": 478646061,
      "user": "kmike",
      "created_at": "2020-08-27T19:28:14Z",
      "url": "https://github.com/scrapy/scrapy/pull/4524#discussion_r478646061"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 4524,
      "file_path": "tests/test_utils_request.py",
      "line": 107,
      "side": "RIGHT",
      "diff_hunk": "@@ -35,62 +70,51 @@ def test_request_fingerprint(self):\n         r3.headers['Accept-Language'] = b'en'\n         r3.headers['SESSIONID'] = b\"somehash\"\n \n-        self.assertEqual(request_fingerprint(r1), request_fingerprint(r2), request_fingerprint(r3))\n+        self.assertEqual(self.function(r1), self.function(r2), self.function(r3))\n \n-        self.assertEqual(request_fingerprint(r1),\n-                         request_fingerprint(r1, include_headers=['Accept-Language']))\n+        self.assertEqual(self.function(r1),\n+                         self.function(r1, include_headers=['Accept-Language']))\n \n         self.assertNotEqual(\n-            request_fingerprint(r1),\n-            request_fingerprint(r2, include_headers=['Accept-Language']))\n+            self.function(r1),\n+            self.function(r2, include_headers=['Accept-Language']))\n \n-        self.assertEqual(request_fingerprint(r3, include_headers=['accept-language', 'sessionid']),\n-                         request_fingerprint(r3, include_headers=['SESSIONID', 'Accept-Language']))\n+        self.assertEqual(self.function(r3, include_headers=['accept-language', 'sessionid']),\n+                         self.function(r3, include_headers=['SESSIONID', 'Accept-Language']))\n \n         r1 = Request(\"http://www.example.com/test.html\")\n         r2 = Request(\"http://www.example.com/test.html#fragment\")\n-        self.assertEqual(request_fingerprint(r1), request_fingerprint(r2))\n-        self.assertEqual(request_fingerprint(r1), request_fingerprint(r1, keep_fragments=True))\n-        self.assertNotEqual(request_fingerprint(r2), request_fingerprint(r2, keep_fragments=True))\n-        self.assertNotEqual(request_fingerprint(r1), request_fingerprint(r2, keep_fragments=True))\n+        self.assertEqual(self.function(r1), self.function(r2))\n+        self.assertEqual(self.function(r1), self.function(r1, keep_fragments=True))\n+        self.assertNotEqual(self.function(r2), self.function(r2, keep_fragments=True))\n+        self.assertNotEqual(self.function(r1), self.function(r2, keep_fragments=True))\n \n         r1 = Request(\"http://www.example.com\")\n         r2 = Request(\"http://www.example.com\", method='POST')\n         r3 = Request(\"http://www.example.com\", method='POST', body=b'request body')\n \n-        self.assertNotEqual(request_fingerprint(r1), request_fingerprint(r2))\n-        self.assertNotEqual(request_fingerprint(r2), request_fingerprint(r3))\n+        self.assertNotEqual(self.function(r1), self.function(r2))\n+        self.assertNotEqual(self.function(r2), self.function(r3))\n \n         # cached fingerprint must be cleared on request copy\n         r1 = Request(\"http://www.example.com\")\n-        fp1 = request_fingerprint(r1)\n+        fp1 = self.function(r1)\n         r2 = r1.replace(url=\"http://www.example.com/other\")\n-        fp2 = request_fingerprint(r2)\n+        fp2 = self.function(r2)\n         self.assertNotEqual(fp1, fp2)\n \n-    def test_request_authenticate(self):\n-        r = Request(\"http://www.example.com\")\n-        request_authenticate(r, 'someuser', 'somepass')\n-        self.assertEqual(r.headers['Authorization'], b'Basic c29tZXVzZXI6c29tZXBhc3M=')\n-\n-    def test_request_httprepr(self):\n-        r1 = Request(\"http://www.example.com\")\n-        self.assertEqual(request_httprepr(r1), b'GET / HTTP/1.1\\r\\nHost: www.example.com\\r\\n\\r\\n')\n-\n-        r1 = Request(\"http://www.example.com/some/page.html?arg=1\")\n-        self.assertEqual(request_httprepr(r1), b'GET /some/page.html?arg=1 HTTP/1.1\\r\\nHost: www.example.com\\r\\n\\r\\n')\n \n-        r1 = Request(\"http://www.example.com\", method='POST',\n-                     headers={\"Content-type\": b\"text/html\"}, body=b\"Some body\")\n-        self.assertEqual(\n-            request_httprepr(r1),\n-            b'POST / HTTP/1.1\\r\\nHost: www.example.com\\r\\nContent-Type: text/html\\r\\n\\r\\nSome body'\n-        )\n+class RequestFingerprintTest(FingerprintTest):",
      "comment": "Would it be possibile to test that the fingerprint returned by the new function is exactly the same as a fingerprint which was returned before? Non-matching fingerprints may affect media uploads, cache, etc.; that'd be a backwards incompatible change.",
      "comment_id": 478650911,
      "user": "kmike",
      "created_at": "2020-08-27T19:37:39Z",
      "url": "https://github.com/scrapy/scrapy/pull/4524#discussion_r478650911"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 4524,
      "file_path": "tests/test_dupefilters.py",
      "line": 123,
      "side": "RIGHT",
      "diff_hunk": "@@ -120,14 +120,14 @@ def test_request_fingerprint(self):\n \n         dupefilter.close('finished')\n \n-        class CaseInsensitiveRFPDupeFilter(RFPDupeFilter):\n+        class RequestFingerprinter:",
      "comment": "How hard would it be to check that from_crawler or from_settings methods are really called for RequestFingerprinters?",
      "comment_id": 478651542,
      "user": "kmike",
      "created_at": "2020-08-27T19:38:58Z",
      "url": "https://github.com/scrapy/scrapy/pull/4524#discussion_r478651542"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 4524,
      "file_path": "scrapy/utils/request.py",
      "line": 121,
      "side": "RIGHT",
      "diff_hunk": "@@ -68,6 +70,67 @@ def request_fingerprint(request, include_headers=None, keep_fragments=False):\n     return cache[cache_key]\n \n \n+_fingerprint_cache = weakref.WeakKeyDictionary()\n+\n+\n+def fingerprint(request, *, include_headers=None, keep_fragments=False) -> bytes:\n+    \"\"\"\n+    Return the request fingerprint.\n+\n+    The request fingerprint is a hash that uniquely identifies the resource the\n+    request points to. For example, take the following two urls:\n+\n+    http://www.example.com/query?id=111&cat=222\n+    http://www.example.com/query?cat=222&id=111\n+\n+    Even though those are two different URLs both point to the same resource\n+    and are equivalent (i.e. they should return the same response).\n+\n+    Another example are cookies used to store session ids. Suppose the\n+    following page is only accessible to authenticated users:\n+\n+    http://www.example.com/members/offers.html\n+\n+    Lots of sites use a cookie to store the session id, which adds a random\n+    component to the HTTP Request and thus should be ignored when calculating\n+    the fingerprint.\n+\n+    For this reason, request headers are ignored by default when calculating\n+    the fingeprint. If you want to include specific headers use the\n+    include_headers argument, which is a list of Request headers to include.\n+\n+    Also, servers usually ignore fragments in urls when handling requests,\n+    so they are also ignored by default when calculating the fingerprint.\n+    If you want to include them, set the keep_fragments argument to True\n+    (for instance when handling requests with a headless browser).\n+    \"\"\"\n+    if include_headers:\n+        include_headers = tuple(to_bytes(h.lower()) for h in sorted(include_headers))\n+    cache = _fingerprint_cache.setdefault(request, {})\n+    cache_key = (include_headers, keep_fragments)\n+    if cache_key not in cache:\n+        fp = hashlib.sha1()\n+        fp.update(to_bytes(request.method))\n+        fp.update(to_bytes(canonicalize_url(request.url, keep_fragments=keep_fragments)))\n+        fp.update(request.body or b'')\n+        if include_headers:\n+            for hdr in include_headers:\n+                if hdr in request.headers:\n+                    fp.update(hdr)\n+                    for v in request.headers.getlist(hdr):\n+                        fp.update(v)",
      "comment": "The main problem is that the new function is used by the (new) default request fingerprinter.\r\n\r\nTo avoid users using this function for their custom request fingerprinters, we could:\r\n\r\n1. Create a private copy of the function, for the default fingerprinter to use to keep backward compatibility.\r\n2. Fix the function.\r\n\r\nThat\u2019s something that I believe would make sense to do as part of this pull request. Thoughts?\r\n\r\nThen there\u2019s the issue of moving users from the bugged, default fingerprinter logic, to one that is not bugged. I think that whether we make that change as part of this pull request or we handle it as part of #4762 depends on how we want to approach it:\r\n\r\n- We could modify this pull request to introduce 2 different fingerprinter classes, one with the deprecated behavior (e.g. `DeprecatedRequestFingerprinter`, `Unsafe\u2026`, `Bogus\u2026`, `Old\u2026`, `Pre2Dot4\u2026`), and one with the fixed behavior (i.e. `RequestFingerprinter`), and use the deprecated class by default, and have it log a warning asking users to switch to the new one. For projects generated with `startproject`, we could set that automatically.\r\n- We could do something similar, but using a setting which the default fingerprinter reads. In that case, we _can_ handle it separately as a fix for #4762, although I would not mind fixing it here.",
      "comment_id": 479180040,
      "user": "Gallaecio",
      "created_at": "2020-08-28T11:43:36Z",
      "url": "https://github.com/scrapy/scrapy/pull/4524#discussion_r479180040"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 4524,
      "file_path": "tests/test_utils_request.py",
      "line": 107,
      "side": "RIGHT",
      "diff_hunk": "@@ -35,62 +70,51 @@ def test_request_fingerprint(self):\n         r3.headers['Accept-Language'] = b'en'\n         r3.headers['SESSIONID'] = b\"somehash\"\n \n-        self.assertEqual(request_fingerprint(r1), request_fingerprint(r2), request_fingerprint(r3))\n+        self.assertEqual(self.function(r1), self.function(r2), self.function(r3))\n \n-        self.assertEqual(request_fingerprint(r1),\n-                         request_fingerprint(r1, include_headers=['Accept-Language']))\n+        self.assertEqual(self.function(r1),\n+                         self.function(r1, include_headers=['Accept-Language']))\n \n         self.assertNotEqual(\n-            request_fingerprint(r1),\n-            request_fingerprint(r2, include_headers=['Accept-Language']))\n+            self.function(r1),\n+            self.function(r2, include_headers=['Accept-Language']))\n \n-        self.assertEqual(request_fingerprint(r3, include_headers=['accept-language', 'sessionid']),\n-                         request_fingerprint(r3, include_headers=['SESSIONID', 'Accept-Language']))\n+        self.assertEqual(self.function(r3, include_headers=['accept-language', 'sessionid']),\n+                         self.function(r3, include_headers=['SESSIONID', 'Accept-Language']))\n \n         r1 = Request(\"http://www.example.com/test.html\")\n         r2 = Request(\"http://www.example.com/test.html#fragment\")\n-        self.assertEqual(request_fingerprint(r1), request_fingerprint(r2))\n-        self.assertEqual(request_fingerprint(r1), request_fingerprint(r1, keep_fragments=True))\n-        self.assertNotEqual(request_fingerprint(r2), request_fingerprint(r2, keep_fragments=True))\n-        self.assertNotEqual(request_fingerprint(r1), request_fingerprint(r2, keep_fragments=True))\n+        self.assertEqual(self.function(r1), self.function(r2))\n+        self.assertEqual(self.function(r1), self.function(r1, keep_fragments=True))\n+        self.assertNotEqual(self.function(r2), self.function(r2, keep_fragments=True))\n+        self.assertNotEqual(self.function(r1), self.function(r2, keep_fragments=True))\n \n         r1 = Request(\"http://www.example.com\")\n         r2 = Request(\"http://www.example.com\", method='POST')\n         r3 = Request(\"http://www.example.com\", method='POST', body=b'request body')\n \n-        self.assertNotEqual(request_fingerprint(r1), request_fingerprint(r2))\n-        self.assertNotEqual(request_fingerprint(r2), request_fingerprint(r3))\n+        self.assertNotEqual(self.function(r1), self.function(r2))\n+        self.assertNotEqual(self.function(r2), self.function(r3))\n \n         # cached fingerprint must be cleared on request copy\n         r1 = Request(\"http://www.example.com\")\n-        fp1 = request_fingerprint(r1)\n+        fp1 = self.function(r1)\n         r2 = r1.replace(url=\"http://www.example.com/other\")\n-        fp2 = request_fingerprint(r2)\n+        fp2 = self.function(r2)\n         self.assertNotEqual(fp1, fp2)\n \n-    def test_request_authenticate(self):\n-        r = Request(\"http://www.example.com\")\n-        request_authenticate(r, 'someuser', 'somepass')\n-        self.assertEqual(r.headers['Authorization'], b'Basic c29tZXVzZXI6c29tZXBhc3M=')\n-\n-    def test_request_httprepr(self):\n-        r1 = Request(\"http://www.example.com\")\n-        self.assertEqual(request_httprepr(r1), b'GET / HTTP/1.1\\r\\nHost: www.example.com\\r\\n\\r\\n')\n-\n-        r1 = Request(\"http://www.example.com/some/page.html?arg=1\")\n-        self.assertEqual(request_httprepr(r1), b'GET /some/page.html?arg=1 HTTP/1.1\\r\\nHost: www.example.com\\r\\n\\r\\n')\n \n-        r1 = Request(\"http://www.example.com\", method='POST',\n-                     headers={\"Content-type\": b\"text/html\"}, body=b\"Some body\")\n-        self.assertEqual(\n-            request_httprepr(r1),\n-            b'POST / HTTP/1.1\\r\\nHost: www.example.com\\r\\nContent-Type: text/html\\r\\n\\r\\nSome body'\n-        )\n+class RequestFingerprintTest(FingerprintTest):",
      "comment": "The output is the same at the moment, however if we decide to fix the fingerprint generation in the new function it will not be. Assuming we will fix the fingerprint generation in the new function, what about extending the deprecation message to indicate that the new function not only returns bytes, but also a different fingerprint?",
      "comment_id": 479185813,
      "user": "Gallaecio",
      "created_at": "2020-08-28T11:48:31Z",
      "url": "https://github.com/scrapy/scrapy/pull/4524#discussion_r479185813"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 4524,
      "file_path": "scrapy/dupefilters.py",
      "line": 12,
      "side": "LEFT",
      "diff_hunk": "@@ -7,10 +7,6 @@\n \n class BaseDupeFilter:\n \n-    @classmethod\n-    def from_settings(cls, settings):\n-        return cls()",
      "comment": "Come to think of it, this is technically backward incompatible, as users may be calling `super().from_settings()` in their subclasses.",
      "comment_id": 485469295,
      "user": "Gallaecio",
      "created_at": "2020-09-09T09:23:52Z",
      "url": "https://github.com/scrapy/scrapy/pull/4524#discussion_r485469295"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 4524,
      "file_path": "scrapy/dupefilters.py",
      "line": 68,
      "side": "RIGHT",
      "diff_hunk": "@@ -51,9 +58,26 @@ def __init__(self, path: Optional[str] = None, debug: bool = False) -> None:\n             self.fingerprints.update(x.rstrip() for x in self.file)\n \n     @classmethod\n-    def from_settings(cls: Type[RFPDupeFilterTV], settings: BaseSettings) -> RFPDupeFilterTV:\n+    def from_settings(cls: Type[RFPDupeFilterTV], settings: BaseSettings, *, fingerprinter=None) -> RFPDupeFilterTV:\n         debug = settings.getbool('DUPEFILTER_DEBUG')\n-        return cls(job_dir(settings), debug)\n+        try:\n+            return cls(job_dir(settings), debug, fingerprinter=fingerprinter)\n+        except TypeError:\n+            result = cls(job_dir(settings), debug)\n+            result.fingerprinter = fingerprinter\n+            return result",
      "comment": "Is the idea to support RFPDupeFilter subclasses which don't have fingerprint argument in `__init__` method? If so, would it make sense to show some kind of deprecation warning, and ask users to update the code?",
      "comment_id": 889304119,
      "user": "kmike",
      "created_at": "2022-06-03T20:04:21Z",
      "url": "https://github.com/scrapy/scrapy/pull/4524#discussion_r889304119"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 4524,
      "file_path": "scrapy/dupefilters.py",
      "line": 80,
      "side": "RIGHT",
      "diff_hunk": "@@ -51,9 +58,26 @@ def __init__(self, path: Optional[str] = None, debug: bool = False) -> None:\n             self.fingerprints.update(x.rstrip() for x in self.file)\n \n     @classmethod\n-    def from_settings(cls: Type[RFPDupeFilterTV], settings: BaseSettings) -> RFPDupeFilterTV:\n+    def from_settings(cls: Type[RFPDupeFilterTV], settings: BaseSettings, *, fingerprinter=None) -> RFPDupeFilterTV:\n         debug = settings.getbool('DUPEFILTER_DEBUG')\n-        return cls(job_dir(settings), debug)\n+        try:\n+            return cls(job_dir(settings), debug, fingerprinter=fingerprinter)\n+        except TypeError:\n+            result = cls(job_dir(settings), debug)\n+            result.fingerprinter = fingerprinter\n+            return result\n+\n+    @classmethod\n+    def from_crawler(cls, crawler):\n+        try:\n+            return cls.from_settings(\n+                crawler.settings,\n+                fingerprinter=crawler.request_fingerprinter,\n+            )\n+        except TypeError:\n+            result = cls.from_settings(crawler.settings)\n+            result.fingerprinter = crawler.request_fingerprinter\n+            return result",
      "comment": "The same question - would it make sense to show a warning if \"fingerprint\" argument is not supported?",
      "comment_id": 889304616,
      "user": "kmike",
      "created_at": "2022-06-03T20:05:15Z",
      "url": "https://github.com/scrapy/scrapy/pull/4524#discussion_r889304616"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 4524,
      "file_path": "tests/test_dupefilters.py",
      "line": 69,
      "side": "RIGHT",
      "diff_hunk": "@@ -64,7 +64,9 @@ def test_df_direct_scheduler(self):\n         self.assertEqual(scheduler.df.method, 'n/a')\n \n     def test_filter(self):\n-        dupefilter = RFPDupeFilter()\n+        crawler = get_crawler()\n+        scheduler = Scheduler.from_crawler(crawler)\n+        dupefilter = scheduler.df",
      "comment": "Would it make sense to extract an utility function? Something like\r\n\r\n```py\r\ndef _get_crawler_dupefilter(crawler):\r\n    scheduler = Scheduler.from_crawler(crawler)\r\n    return scheduler.df    \r\n```",
      "comment_id": 889312979,
      "user": "kmike",
      "created_at": "2022-06-03T20:13:25Z",
      "url": "https://github.com/scrapy/scrapy/pull/4524#discussion_r889312979"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 4524,
      "file_path": "tests/test_utils_request.py",
      "line": 368,
      "side": "RIGHT",
      "diff_hunk": "@@ -1,96 +1,679 @@\n import unittest\n+import warnings\n+from hashlib import sha1\n+from typing import Dict, Mapping, Optional, Tuple, Union\n+from weakref import WeakKeyDictionary\n+\n+import pytest\n+from w3lib.url import canonicalize_url\n+\n from scrapy.http import Request\n+from scrapy.utils.deprecate import ScrapyDeprecationWarning\n+from scrapy.utils.python import to_bytes\n from scrapy.utils.request import (\n+    _deprecated_fingerprint_cache,\n     _fingerprint_cache,\n+    _request_fingerprint_as_bytes,\n+    fingerprint,\n     request_authenticate,\n     request_fingerprint,\n     request_httprepr,\n )\n+from scrapy.utils.test import get_crawler\n \n \n class UtilsRequestTest(unittest.TestCase):\n \n-    def test_request_fingerprint(self):\n+    def test_request_authenticate(self):\n+        r = Request(\"http://www.example.com\")\n+        request_authenticate(r, 'someuser', 'somepass')\n+        self.assertEqual(r.headers['Authorization'], b'Basic c29tZXVzZXI6c29tZXBhc3M=')\n+\n+    def test_request_httprepr(self):\n+        r1 = Request(\"http://www.example.com\")\n+        self.assertEqual(request_httprepr(r1), b'GET / HTTP/1.1\\r\\nHost: www.example.com\\r\\n\\r\\n')\n+\n+        r1 = Request(\"http://www.example.com/some/page.html?arg=1\")\n+        self.assertEqual(request_httprepr(r1), b'GET /some/page.html?arg=1 HTTP/1.1\\r\\nHost: www.example.com\\r\\n\\r\\n')\n+\n+        r1 = Request(\"http://www.example.com\", method='POST',\n+                     headers={\"Content-type\": b\"text/html\"}, body=b\"Some body\")\n+        self.assertEqual(\n+            request_httprepr(r1),\n+            b'POST / HTTP/1.1\\r\\nHost: www.example.com\\r\\nContent-Type: text/html\\r\\n\\r\\nSome body'\n+        )\n+\n+    def test_request_httprepr_for_non_http_request(self):\n+        # the representation is not important but it must not fail.\n+        request_httprepr(Request(\"file:///tmp/foo.txt\"))\n+        request_httprepr(Request(\"ftp://localhost/tmp/foo.txt\"))\n+\n+\n+class FingerprintTest(unittest.TestCase):\n+    maxDiff = None\n+\n+    function = staticmethod(fingerprint)\n+    cache: Union[\n+        \"WeakKeyDictionary[Request, Dict[Tuple[Optional[Tuple[bytes, ...]], bool], bytes]]\",\n+        \"WeakKeyDictionary[Request, Dict[Tuple[Optional[Tuple[bytes, ...]], bool], str]]\",\n+    ] = _fingerprint_cache\n+    default_cache_key = (None, False)\n+    known_hashes: Tuple[Tuple[Request, Union[bytes, str], Dict], ...] = (\n+        (\n+            Request(\"http://example.org\"),\n+            b'xs\\xd7\\x0c3uj\\x15\\xfe\\xd7d\\x9b\\xa9\\t\\xe0d\\xbf\\x9cXD',\n+            {},\n+        ),\n+        (\n+            Request(\"https://example.org\"),\n+            b'\\xc04\\x85P,\\xaa\\x91\\x06\\xf8t\\xb4\\xbd*\\xd9\\xe9\\x8a:m\\xc3l',\n+            {},\n+        ),\n+        (\n+            Request(\"https://example.org?a\"),\n+            b'G\\xad\\xb8Ck\\x19\\x1c\\xed\\x838,\\x01\\xc4\\xde;\\xee\\xa5\\x94a\\x0c',\n+            {},\n+        ),\n+        (\n+            Request(\"https://example.org?a=b\"),\n+            b'\\x024MYb\\x8a\\xc2\\x1e\\xbc>\\xd6\\xac*\\xda\\x9cF\\xc1r\\x7f\\x17',\n+            {},\n+        ),\n+        (\n+            Request(\"https://example.org?a=b&a\"),\n+            b't+\\xe8*\\xfb\\x84\\xe3v\\x1a}\\x88p\\xc0\\xccB\\xd7\\x9d\\xfez\\x96',\n+            {},\n+        ),\n+        (\n+            Request(\"https://example.org?a=b&a=c\"),\n+            b'\\xda\\x1ec\\xd0\\x9c\\x08s`\\xb4\\x9b\\xe2\\xb6R\\xf8k\\xef\\xeaQG\\xef',\n+            {},\n+        ),\n+        (\n+            Request(\"https://example.org\", method='POST'),\n+            b'\\x9d\\xcdA\\x0fT\\x02:\\xca\\xa0}\\x90\\xda\\x05B\\xded\\x8aN7\\x1d',\n+            {},\n+        ),\n+        (\n+            Request(\"https://example.org\", body=b'a'),\n+            b'\\xc34z>\\xd8\\x99\\x8b\\xda7\\x05r\\x99I\\xa8\\xa0x;\\xa41_',\n+            {},\n+        ),\n+        (\n+            Request(\"https://example.org\", method='POST', body=b'a'),\n+            b'5`\\xe2y4\\xd0\\x9d\\xee\\xe0\\xbatw\\x87Q\\xe8O\\xd78\\xfc\\xe7',\n+            {},\n+        ),\n+        (\n+            Request(\"https://example.org#a\", headers={'A': b'B'}),\n+            b'\\xc04\\x85P,\\xaa\\x91\\x06\\xf8t\\xb4\\xbd*\\xd9\\xe9\\x8a:m\\xc3l',\n+            {},\n+        ),\n+        (\n+            Request(\"https://example.org#a\", headers={'A': b'B'}),\n+            b']\\xc7\\x1f\\xf2\\xafG2\\xbc\\xa4\\xfa\\x99\\n33\\xda\\x18\\x94\\x81U.',\n+            {'include_headers': ['A']},\n+        ),\n+        (\n+            Request(\"https://example.org#a\", headers={'A': b'B'}),\n+            b'<\\x1a\\xeb\\x85y\\xdeW\\xfb\\xdcq\\x88\\xee\\xaf\\x17\\xdd\\x0c\\xbfH\\x18\\x1f',\n+            {'keep_fragments': True},\n+        ),\n+        (\n+            Request(\"https://example.org#a\", headers={'A': b'B'}),\n+            b'\\xc1\\xef~\\x94\\x9bS\\xc1\\x83\\t\\xdcz8\\x9f\\xdc{\\x11\\x16I.\\x11',\n+            {'include_headers': ['A'], 'keep_fragments': True},\n+        ),\n+        (\n+            Request(\"https://example.org/ab\"),\n+            b'N\\xe5l\\xb8\\x12@iw\\xe2\\xf3\\x1bp\\xea\\xffp!u\\xe2\\x8a\\xc6',\n+            {},\n+        ),\n+        (\n+            Request(\"https://example.org/a\", body=b'b'),\n+            b'_NOv\\xbco$6\\xfcW\\x9f\\xb24g\\x9f\\xbb\\xdd\\xa82\\xc5',\n+            {},\n+        ),\n+    )\n+\n+    def test_query_string_key_order(self):\n         r1 = Request(\"http://www.example.com/query?id=111&cat=222\")\n         r2 = Request(\"http://www.example.com/query?cat=222&id=111\")\n-        self.assertEqual(request_fingerprint(r1), request_fingerprint(r1))\n-        self.assertEqual(request_fingerprint(r1), request_fingerprint(r2))\n+        self.assertEqual(self.function(r1), self.function(r1))\n+        self.assertEqual(self.function(r1), self.function(r2))\n \n+    def test_query_string_key_without_value(self):\n         r1 = Request('http://www.example.com/hnnoticiaj1.aspx?78132,199')\n         r2 = Request('http://www.example.com/hnnoticiaj1.aspx?78160,199')\n-        self.assertNotEqual(request_fingerprint(r1), request_fingerprint(r2))\n+        self.assertNotEqual(self.function(r1), self.function(r2))\n \n-        # make sure caching is working\n-        self.assertEqual(request_fingerprint(r1), _fingerprint_cache[r1][(None, False)])\n+    def test_caching(self):\n+        r1 = Request('http://www.example.com/hnnoticiaj1.aspx?78160,199')\n+        self.assertEqual(\n+            self.function(r1),\n+            self.cache[r1][self.default_cache_key]\n+        )\n \n+    def test_header(self):\n         r1 = Request(\"http://www.example.com/members/offers.html\")\n         r2 = Request(\"http://www.example.com/members/offers.html\")\n         r2.headers['SESSIONID'] = b\"somehash\"\n-        self.assertEqual(request_fingerprint(r1), request_fingerprint(r2))\n+        self.assertEqual(self.function(r1), self.function(r2))\n \n+    def test_headers(self):\n         r1 = Request(\"http://www.example.com/\")\n         r2 = Request(\"http://www.example.com/\")\n         r2.headers['Accept-Language'] = b'en'\n         r3 = Request(\"http://www.example.com/\")\n         r3.headers['Accept-Language'] = b'en'\n         r3.headers['SESSIONID'] = b\"somehash\"\n \n-        self.assertEqual(request_fingerprint(r1), request_fingerprint(r2), request_fingerprint(r3))\n+        self.assertEqual(self.function(r1), self.function(r2), self.function(r3))\n \n-        self.assertEqual(request_fingerprint(r1),\n-                         request_fingerprint(r1, include_headers=['Accept-Language']))\n+        self.assertEqual(self.function(r1),\n+                         self.function(r1, include_headers=['Accept-Language']))\n \n         self.assertNotEqual(\n-            request_fingerprint(r1),\n-            request_fingerprint(r2, include_headers=['Accept-Language']))\n+            self.function(r1),\n+            self.function(r2, include_headers=['Accept-Language']))\n \n-        self.assertEqual(request_fingerprint(r3, include_headers=['accept-language', 'sessionid']),\n-                         request_fingerprint(r3, include_headers=['SESSIONID', 'Accept-Language']))\n+        self.assertEqual(self.function(r3, include_headers=['accept-language', 'sessionid']),\n+                         self.function(r3, include_headers=['SESSIONID', 'Accept-Language']))\n \n+    def test_fragment(self):\n         r1 = Request(\"http://www.example.com/test.html\")\n         r2 = Request(\"http://www.example.com/test.html#fragment\")\n-        self.assertEqual(request_fingerprint(r1), request_fingerprint(r2))\n-        self.assertEqual(request_fingerprint(r1), request_fingerprint(r1, keep_fragments=True))\n-        self.assertNotEqual(request_fingerprint(r2), request_fingerprint(r2, keep_fragments=True))\n-        self.assertNotEqual(request_fingerprint(r1), request_fingerprint(r2, keep_fragments=True))\n+        self.assertEqual(self.function(r1), self.function(r2))\n+        self.assertEqual(self.function(r1), self.function(r1, keep_fragments=True))\n+        self.assertNotEqual(self.function(r2), self.function(r2, keep_fragments=True))\n+        self.assertNotEqual(self.function(r1), self.function(r2, keep_fragments=True))\n \n+    def test_method_and_body(self):\n         r1 = Request(\"http://www.example.com\")\n         r2 = Request(\"http://www.example.com\", method='POST')\n         r3 = Request(\"http://www.example.com\", method='POST', body=b'request body')\n \n-        self.assertNotEqual(request_fingerprint(r1), request_fingerprint(r2))\n-        self.assertNotEqual(request_fingerprint(r2), request_fingerprint(r3))\n+        self.assertNotEqual(self.function(r1), self.function(r2))\n+        self.assertNotEqual(self.function(r2), self.function(r3))\n \n+    def test_request_replace(self):\n         # cached fingerprint must be cleared on request copy\n         r1 = Request(\"http://www.example.com\")\n-        fp1 = request_fingerprint(r1)\n+        fp1 = self.function(r1)\n         r2 = r1.replace(url=\"http://www.example.com/other\")\n-        fp2 = request_fingerprint(r2)\n+        fp2 = self.function(r2)\n         self.assertNotEqual(fp1, fp2)\n \n-    def test_request_authenticate(self):\n-        r = Request(\"http://www.example.com\")\n-        request_authenticate(r, 'someuser', 'somepass')\n-        self.assertEqual(r.headers['Authorization'], b'Basic c29tZXVzZXI6c29tZXBhc3M=')\n+    def test_part_separation(self):\n+        # An old implementation used to serialize request data in a way that\n+        # would put the body right after the URL.\n+        r1 = Request(\"http://www.example.com/foo\")\n+        fp1 = self.function(r1)\n+        r2 = Request(\"http://www.example.com/f\", body=b'oo')\n+        fp2 = self.function(r2)\n+        self.assertNotEqual(fp1, fp2)\n \n-    def test_request_httprepr(self):\n-        r1 = Request(\"http://www.example.com\")\n-        self.assertEqual(request_httprepr(r1), b'GET / HTTP/1.1\\r\\nHost: www.example.com\\r\\n\\r\\n')\n+    def test_hashes(self):\n+        \"\"\"Test hardcoded hashes, to make sure future changes to not introduce\n+        backward incompatibilities.\"\"\"\n+        actual = [\n+            self.function(request, **kwargs)\n+            for request, _, kwargs in self.known_hashes\n+        ]\n+        expected = [\n+            _fingerprint\n+            for _, _fingerprint, _ in self.known_hashes\n+        ]\n+        self.assertEqual(actual, expected)\n \n-        r1 = Request(\"http://www.example.com/some/page.html?arg=1\")\n-        self.assertEqual(request_httprepr(r1), b'GET /some/page.html?arg=1 HTTP/1.1\\r\\nHost: www.example.com\\r\\n\\r\\n')\n \n-        r1 = Request(\"http://www.example.com\", method='POST',\n-                     headers={\"Content-type\": b\"text/html\"}, body=b\"Some body\")\n+class RequestFingerprintTest(FingerprintTest):\n+    function = staticmethod(request_fingerprint)\n+    cache = _deprecated_fingerprint_cache\n+    known_hashes: Tuple[Tuple[Request, Union[bytes, str], Dict], ...] = (\n+        (\n+            Request(\"http://example.org\"),\n+            'b2e5245ef826fd9576c93bd6e392fce3133fab62',\n+            {},\n+        ),\n+        (\n+            Request(\"https://example.org\"),\n+            'bd10a0a89ea32cdee77917320f1309b0da87e892',\n+            {},\n+        ),\n+        (\n+            Request(\"https://example.org?a\"),\n+            '2fb7d48ae02f04b749f40caa969c0bc3c43204ce',\n+            {},\n+        ),\n+        (\n+            Request(\"https://example.org?a=b\"),\n+            '42e5fe149b147476e3f67ad0670c57b4cc57856a',\n+            {},\n+        ),\n+        (\n+            Request(\"https://example.org?a=b&a\"),\n+            'd23a9787cb56c6375c2cae4453c5a8c634526942',\n+            {},\n+        ),\n+        (\n+            Request(\"https://example.org?a=b&a=c\"),\n+            '9a18a7a8552a9182b7f1e05d33876409e421e5c5',\n+            {},\n+        ),\n+        (\n+            Request(\"https://example.org\", method='POST'),\n+            'ba20a80cb5c5ca460021ceefb3c2467b2bfd1bc6',\n+            {},\n+        ),\n+        (\n+            Request(\"https://example.org\", body=b'a'),\n+            '4bb136e54e715a4ea7a9dd1101831765d33f2d60',\n+            {},\n+        ),\n+        (\n+            Request(\"https://example.org\", method='POST', body=b'a'),\n+            '6c6595374a304b293be762f7b7be3f54e9947c65',\n+            {},\n+        ),\n+        (\n+            Request(\"https://example.org#a\", headers={'A': b'B'}),\n+            'bd10a0a89ea32cdee77917320f1309b0da87e892',\n+            {},\n+        ),\n+        (\n+            Request(\"https://example.org#a\", headers={'A': b'B'}),\n+            '515b633cb3ca502a33a9d8c890e889ec1e425e65',\n+            {'include_headers': ['A']},\n+        ),\n+        (\n+            Request(\"https://example.org#a\", headers={'A': b'B'}),\n+            '505c96e7da675920dfef58725e8c957dfdb38f47',\n+            {'keep_fragments': True},\n+        ),\n+        (\n+            Request(\"https://example.org#a\", headers={'A': b'B'}),\n+            'd6f673cdcb661b7970c2b9a00ee63e87d1e2e5da',\n+            {'include_headers': ['A'], 'keep_fragments': True},\n+        ),\n+        (\n+            Request(\"https://example.org/ab\"),\n+            '4e2870fee58582d6f81755e9b8fdefe3cba0c951',\n+            {},\n+        ),\n+        (\n+            Request(\"https://example.org/a\", body=b'b'),\n+            '4e2870fee58582d6f81755e9b8fdefe3cba0c951',\n+            {},\n+        ),\n+    )\n+\n+    @pytest.mark.xfail(reason='known bug kept for backward compatibility', strict=True)\n+    def test_part_separation(self):\n+        super().test_part_separation()\n+\n+    def test_deprecation_default_parameters(self):\n+        with pytest.warns(ScrapyDeprecationWarning) as warnings:\n+            self.function(Request(\"http://www.example.com\"))\n+        messages = [str(warning.message) for warning in warnings]\n+        self.assertTrue(\n+            any(\n+                'Call to deprecated function' in message\n+                for message in messages\n+            )\n+        )\n+        self.assertFalse(any('non-default' in message for message in messages))\n+\n+    def test_deprecation_non_default_parameters(self):\n+        with pytest.warns(ScrapyDeprecationWarning) as warnings:\n+            self.function(Request(\"http://www.example.com\"), keep_fragments=True)\n+        messages = [str(warning.message) for warning in warnings]\n+        self.assertTrue(\n+            any(\n+                'Call to deprecated function' in message\n+                for message in messages\n+            )\n+        )\n+        self.assertTrue(any('non-default' in message for message in messages))\n+\n+\n+class RequestFingerprintAsBytesTest(FingerprintTest):\n+    function = staticmethod(_request_fingerprint_as_bytes)\n+    cache = _deprecated_fingerprint_cache\n+    known_hashes = RequestFingerprintTest.known_hashes\n+\n+    def test_caching(self):\n+        r1 = Request('http://www.example.com/hnnoticiaj1.aspx?78160,199')\n         self.assertEqual(\n-            request_httprepr(r1),\n-            b'POST / HTTP/1.1\\r\\nHost: www.example.com\\r\\nContent-Type: text/html\\r\\n\\r\\nSome body'\n+            self.function(r1),\n+            bytes.fromhex(self.cache[r1][self.default_cache_key])\n         )\n \n-    def test_request_httprepr_for_non_http_request(self):\n-        # the representation is not important but it must not fail.\n-        request_httprepr(Request(\"file:///tmp/foo.txt\"))\n-        request_httprepr(Request(\"ftp://localhost/tmp/foo.txt\"))\n+    @pytest.mark.xfail(reason='known bug kept for backward compatibility', strict=True)\n+    def test_part_separation(self):\n+        super().test_part_separation()\n+\n+    def test_hashes(self):\n+        actual = [\n+            self.function(request, **kwargs)\n+            for request, _, kwargs in self.known_hashes\n+        ]\n+        expected = [\n+            bytes.fromhex(_fingerprint)\n+            for _, _fingerprint, _ in self.known_hashes\n+        ]\n+        self.assertEqual(actual, expected)\n+\n+\n+_fingerprint_cache_2_3: Mapping[Request, Tuple[None, bool]] = WeakKeyDictionary()",
      "comment": "should this and similar objects be renamed to `..._2_6`?",
      "comment_id": 889621461,
      "user": "kmike",
      "created_at": "2022-06-04T22:20:45Z",
      "url": "https://github.com/scrapy/scrapy/pull/4524#discussion_r889621461"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 5497,
      "file_path": "tests/test_command_parse.py",
      "line": 228,
      "side": "RIGHT",
      "diff_hunk": "@@ -222,6 +223,10 @@ def test_crawlspider_no_matching_rule(self):\n         self.assertRegex(_textmode(out), r\"\"\"# Scraped Items  -+\\n\\[\\]\"\"\")\n         self.assertIn(\"\"\"Cannot find a rule that matches\"\"\", _textmode(stderr))\n \n+        status, out, stderr = yield self.execute([self.url('/invalid_url')])\n+        self.assertEqual(status, 0)\n+        self.assertIn(\"\"\"\"\"\", _textmode(stderr))",
      "comment": "This is checking that there is an empty string somewhere in the stderr string. There is always an empty string in any string. So this line can be removed.",
      "comment_id": 873054786,
      "user": "Gallaecio",
      "created_at": "2022-05-14T17:24:39Z",
      "url": "https://github.com/scrapy/scrapy/pull/5497#discussion_r873054786"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 5497,
      "file_path": "tests/test_command_parse.py",
      "line": 226,
      "side": "RIGHT",
      "diff_hunk": "@@ -222,6 +223,10 @@ def test_crawlspider_no_matching_rule(self):\n         self.assertRegex(_textmode(out), r\"\"\"# Scraped Items  -+\\n\\[\\]\"\"\")\n         self.assertIn(\"\"\"Cannot find a rule that matches\"\"\", _textmode(stderr))\n \n+        status, out, stderr = yield self.execute([self.url('/invalid_url')])",
      "comment": "Please, give this test its own test method instead of running it within the existing `test_crawlspider_no_matching_rule`.",
      "comment_id": 873054874,
      "user": "Gallaecio",
      "created_at": "2022-05-14T17:25:32Z",
      "url": "https://github.com/scrapy/scrapy/pull/5497#discussion_r873054874"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 5497,
      "file_path": "tests/test_command_parse.py",
      "line": 226,
      "side": "RIGHT",
      "diff_hunk": "@@ -222,6 +223,10 @@ def test_crawlspider_no_matching_rule(self):\n         self.assertRegex(_textmode(out), r\"\"\"# Scraped Items  -+\\n\\[\\]\"\"\")\n         self.assertIn(\"\"\"Cannot find a rule that matches\"\"\", _textmode(stderr))\n \n+        status, out, stderr = yield self.execute([self.url('/invalid_url')])",
      "comment": "Thanks @Gallaecio , should I use also the decorator @defer.inlineCallbacks in my new test? ",
      "comment_id": 878827414,
      "user": "andreastziortz",
      "created_at": "2022-05-22T09:10:35Z",
      "url": "https://github.com/scrapy/scrapy/pull/5497#discussion_r878827414"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 5318,
      "file_path": "tests/test_pipeline_files.py",
      "line": 538,
      "side": "RIGHT",
      "diff_hunk": "@@ -526,6 +527,26 @@ def test_persist(self):\n         self.assertIn(expected_policy, acl)\n \n \n+    @defer.inlineCallbacks\n+    def test_blob_path_consistency(self):\n+        \"\"\"Test to make sure that paths used to store files is the same as the one used to get\n+        already uploaded files.\n+        \"\"\"\n+        assert_gcs_environ()\n+        import google.cloud.storage\n+        with mock.patch('google.cloud.storage') as _ :\n+            with mock.patch('scrapy.pipelines.files.time') as _ :",
      "comment": "Are these needed for the test to work as expected? I\u2019m not used to patching without then using the patched object to define output and side effects.",
      "comment_id": 750016761,
      "user": "Gallaecio",
      "created_at": "2021-11-16T08:17:09Z",
      "url": "https://github.com/scrapy/scrapy/pull/5318#discussion_r750016761"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 5318,
      "file_path": "tests/test_pipeline_files.py",
      "line": 538,
      "side": "RIGHT",
      "diff_hunk": "@@ -526,6 +527,26 @@ def test_persist(self):\n         self.assertIn(expected_policy, acl)\n \n \n+    @defer.inlineCallbacks\n+    def test_blob_path_consistency(self):\n+        \"\"\"Test to make sure that paths used to store files is the same as the one used to get\n+        already uploaded files.\n+        \"\"\"\n+        assert_gcs_environ()\n+        import google.cloud.storage\n+        with mock.patch('google.cloud.storage') as _ :\n+            with mock.patch('scrapy.pipelines.files.time') as _ :",
      "comment": "it may not be the best way of using monkeypatch but my idea was that I only care about making sure that `bucket.blob` & `bucket.get_blob` are called with the same `path`.\r\nThe problem with patching objects here is that we would need to patch a couple of them if we don't want to refactor GCSFilesStore.\r\nI may be missing something but it's looks that we would need to patch is the following methods\r\n- storage.Client \r\n- client.bucket\r\n- bucket.test_iam_permissions\r\n- bucket.get_blob\r\n- bucket.blob\r\n- blob.upload_from_string\r\n\r\nif we would like to micmic that it works well but in practice this test is achieved by `test_persist`\r\n\r\nThe main advantage of using `mock.patch` here is that `storage` and all the above mentionned method will be [Mock](https://docs.python.org/3/library/unittest.mock.html#unittest.mock.Mock) objects which means that everytime you call an attritube or a method it will return a Mock object and will accept any arguments.\r\nAfter that you can check which method has been called with which argument \r\n```\r\n store.bucket.blob.assert_called_with(expected_blob_path)\r\n store.bucket.get_blob.assert_called_with(expected_blob_path)\r\n```\r\nWith those two lines I can make sure that `self.get_blob` from `stat_file` and `self.bucket.blob` from `persist_file` are called with the same and the right parameter.\r\n\r\nPatching `time` is required because of `last_modified = time.mktime(blob.updated.timetuple())` but an alternative would have been to patch `blob.updated.timetuple` in order to return something that can be processed by `time.mktime`\r\n",
      "comment_id": 750733897,
      "user": "mnannan",
      "created_at": "2021-11-16T23:09:14Z",
      "url": "https://github.com/scrapy/scrapy/pull/5318#discussion_r750733897"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 1214,
      "file_path": "scrapy/linkextractors/lxmlhtml.py",
      "line": null,
      "side": "RIGHT",
      "diff_hunk": "@@ -57,8 +57,9 @@ def _extract_links(self, selector, response_url, response_encoding, base_url):\n                 url = url.encode(response_encoding)\n             # to fix relative links after process_value\n             url = urljoin(response_url, url)\n+            rel = el.get('rel')\n             link = Link(url, _collect_string_content(el) or u'',\n-                nofollow=True if el.get('rel') == 'nofollow' else False)\n+                nofollow=True if rel is not None and 'nofollow' in rel.split() else False)",
      "comment": "What do you think about creating a small utility function or method for it? Something like `has_nofollow(rel_value)`.\n",
      "comment_id": 29853667,
      "user": "kmike",
      "created_at": "2015-05-07T13:57:33Z",
      "url": "https://github.com/scrapy/scrapy/pull/1214#discussion_r29853667"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 1214,
      "file_path": "scrapy/linkextractors/lxmlhtml.py",
      "line": null,
      "side": "RIGHT",
      "diff_hunk": "@@ -57,8 +57,9 @@ def _extract_links(self, selector, response_url, response_encoding, base_url):\n                 url = url.encode(response_encoding)\n             # to fix relative links after process_value\n             url = urljoin(response_url, url)\n+            rel = el.get('rel')\n             link = Link(url, _collect_string_content(el) or u'',\n-                nofollow=True if el.get('rel') == 'nofollow' else False)\n+                nofollow=True if rel is not None and 'nofollow' in rel.split() else False)",
      "comment": "I believe that utility functions will be more flexible. Would putting it in new package `scrapy.utils.link` sufficient?\n",
      "comment_id": 29939728,
      "user": "nounder",
      "created_at": "2015-05-08T13:37:58Z",
      "url": "https://github.com/scrapy/scrapy/pull/1214#discussion_r29939728"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 1214,
      "file_path": "scrapy/linkextractors/lxmlhtml.py",
      "line": null,
      "side": "RIGHT",
      "diff_hunk": "@@ -57,8 +57,9 @@ def _extract_links(self, selector, response_url, response_encoding, base_url):\n                 url = url.encode(response_encoding)\n             # to fix relative links after process_value\n             url = urljoin(response_url, url)\n+            rel = el.get('rel')\n             link = Link(url, _collect_string_content(el) or u'',\n-                nofollow=True if el.get('rel') == 'nofollow' else False)\n+                nofollow=True if rel is not None and 'nofollow' in rel.split() else False)",
      "comment": "Just a nitpick, that whole line setting `nofollow` can be condensed into a more readable:\n\n``` python\nnofollow='nofollow' in (rel or '').split()\n```\n",
      "comment_id": 29984726,
      "user": "curita",
      "created_at": "2015-05-08T23:25:22Z",
      "url": "https://github.com/scrapy/scrapy/pull/1214#discussion_r29984726"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 5440,
      "file_path": "scrapy/core/engine.py",
      "line": 140,
      "side": "RIGHT",
      "diff_hunk": "@@ -136,7 +136,9 @@ def unpause(self) -> None:\n         self.paused = False\n \n     def _next_request(self) -> None:\n-        assert self.slot is not None  # typing\n+        if self.slot is None:\n+            return",
      "comment": "This is necessary because `close_spider` uses `setattr` to set `self.slot` to `None`. However, I wonder if we can make it so that `_next_request` in not called in the first place, in those scenarios.",
      "comment_id": 820599834,
      "user": "Gallaecio",
      "created_at": "2022-03-07T11:04:53Z",
      "url": "https://github.com/scrapy/scrapy/pull/5440#discussion_r820599834"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 5440,
      "file_path": "scrapy/core/engine.py",
      "line": 190,
      "side": "RIGHT",
      "diff_hunk": "@@ -184,7 +186,8 @@ def _next_request_from_scheduler(self) -> Optional[Deferred]:\n         d.addErrback(lambda f: logger.info('Error while removing request from slot',\n                                            exc_info=failure_to_exc_info(f),\n                                            extra={'spider': self.spider}))\n-        d.addBoth(lambda _: self.slot.nextcall.schedule())\n+        slot = self.slot\n+        d.addBoth(lambda _: slot.nextcall.schedule())",
      "comment": "This is also necessary for the same reason, because `close_spider` uses `setattr` to set `self.slot` to `None`. However, I wonder if we can handle this differently, or somehow prevent that `setattr` call to happen before this code is called.",
      "comment_id": 820600768,
      "user": "Gallaecio",
      "created_at": "2022-03-07T11:06:16Z",
      "url": "https://github.com/scrapy/scrapy/pull/5440#discussion_r820600768"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 5352,
      "file_path": "scrapy/crawler.py",
      "line": 84,
      "side": "RIGHT",
      "diff_hunk": "@@ -69,6 +70,19 @@ def __init__(self, spidercls, settings=None):\n \n         lf_cls = load_object(self.settings['LOG_FORMATTER'])\n         self.logformatter = lf_cls.from_crawler(self)\n+\n+        if init_reactor:\n+            # this needs to be done after the spider settings are merged,\n+            # but before something imports twisted.internet.reactor\n+            if self.settings.get(\"TWISTED_REACTOR\"):\n+                install_reactor(self.settings[\"TWISTED_REACTOR\"], self.settings[\"ASYNCIO_EVENT_LOOP\"])\n+            else:\n+                from twisted.internet import default\n+                default.install()\n+            log_reactor_info()\n+        if self.settings.get(\"TWISTED_REACTOR\"):\n+            verify_installed_reactor(self.settings[\"TWISTED_REACTOR\"])",
      "comment": "works fine, tested this in my project. Minor thing, you could probably simplify this to something like this to avoid repeatedly calling self.settings.get('TWISTED_REACTOR')\r\n\r\n```python\r\nreactor_class = self.settings.get(\"TWISTED_REACTOR\")\r\nif init_reactor:\r\n    if reactor_class:\r\n        install_reactor(reactor_class, self.settings[\"ASYNCIO_EVENT_LOOP\"])\r\n... etc\r\n\r\n```\r\n\r\nI also wonder if default value for init_reactor should be False? Are there any legitimate cases when you don't want to init reactor if you have it in settings?",
      "comment_id": 776952244,
      "user": "pawelmhm",
      "created_at": "2021-12-31T08:22:24Z",
      "url": "https://github.com/scrapy/scrapy/pull/5352#discussion_r776952244"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 5352,
      "file_path": "scrapy/crawler.py",
      "line": 84,
      "side": "RIGHT",
      "diff_hunk": "@@ -69,6 +70,19 @@ def __init__(self, spidercls, settings=None):\n \n         lf_cls = load_object(self.settings['LOG_FORMATTER'])\n         self.logformatter = lf_cls.from_crawler(self)\n+\n+        if init_reactor:\n+            # this needs to be done after the spider settings are merged,\n+            # but before something imports twisted.internet.reactor\n+            if self.settings.get(\"TWISTED_REACTOR\"):\n+                install_reactor(self.settings[\"TWISTED_REACTOR\"], self.settings[\"ASYNCIO_EVENT_LOOP\"])\n+            else:\n+                from twisted.internet import default\n+                default.install()\n+            log_reactor_info()\n+        if self.settings.get(\"TWISTED_REACTOR\"):\n+            verify_installed_reactor(self.settings[\"TWISTED_REACTOR\"])",
      "comment": "Thanks, I'll implement this simplification. As for the flag, it was the default behavior before this change, and the use case to not init the reactor is CrawlerRunner. ",
      "comment_id": 776957796,
      "user": "wRAR",
      "created_at": "2021-12-31T08:53:03Z",
      "url": "https://github.com/scrapy/scrapy/pull/5352#discussion_r776957796"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 4966,
      "file_path": "scrapy/extensions/feedexport.py",
      "line": 488,
      "side": "RIGHT",
      "diff_hunk": "@@ -485,4 +485,4 @@ def _get_uri_params(self, spider, uri_params, slot=None):\n         params['batch_id'] = slot.batch_id + 1 if slot is not None else 1\n         uripar_function = load_object(uri_params) if uri_params else lambda x, y: None\n         uripar_function(params, spider)\n-        return params\n+        return uripar_function(params, spider)",
      "comment": "Maybe it is not as straightforward as I thought. Also, I think we may need to be careful to ensure backward compatibility.\r\n\r\nI wonder what would happen if we only return the result of `uripar_function` if it is not `None`:\r\n\r\n```python\r\n        new_params = uripar_function(params, spider)\r\n        return new_params if new_params is not None else params\r\n```\r\n\r\nSo, if someone wrote a `uripar` function that returns nothing and instead simply edits the input params, this code should work as well.\r\n\r\nAssuming this code works, then we probably just need to extend it to log a deprecation warning if `uripar_function` returns `None`, and we should update our tests to cover both use cases.",
      "comment_id": 566454804,
      "user": "Gallaecio",
      "created_at": "2021-01-28T22:36:49Z",
      "url": "https://github.com/scrapy/scrapy/pull/4966#discussion_r566454804"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 4966,
      "file_path": "scrapy/extensions/feedexport.py",
      "line": 488,
      "side": "RIGHT",
      "diff_hunk": "@@ -485,4 +485,4 @@ def _get_uri_params(self, spider, uri_params, slot=None):\n         params['batch_id'] = slot.batch_id + 1 if slot is not None else 1\n         uripar_function = load_object(uri_params) if uri_params else lambda x, y: None\n         uripar_function(params, spider)\n-        return params\n+        return uripar_function(params, spider)",
      "comment": "Thanks for the reply! I will try this later and see how it goes. ",
      "comment_id": 566465426,
      "user": "inspurwusixuan",
      "created_at": "2021-01-28T22:59:17Z",
      "url": "https://github.com/scrapy/scrapy/pull/4966#discussion_r566465426"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 4966,
      "file_path": "scrapy/extensions/feedexport.py",
      "line": 488,
      "side": "RIGHT",
      "diff_hunk": "@@ -485,4 +485,4 @@ def _get_uri_params(self, spider, uri_params, slot=None):\n         params['batch_id'] = slot.batch_id + 1 if slot is not None else 1\n         uripar_function = load_object(uri_params) if uri_params else lambda x, y: None\n         uripar_function(params, spider)\n-        return params\n+        return uripar_function(params, spider)",
      "comment": "It seems like `return new_params if new_params is not None else params` passed all the checks. Thanks for the advice! Let me know if there is anything I can help. :)",
      "comment_id": 567149185,
      "user": "inspurwusixuan",
      "created_at": "2021-01-29T23:30:44Z",
      "url": "https://github.com/scrapy/scrapy/pull/4966#discussion_r567149185"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 4966,
      "file_path": "scrapy/extensions/feedexport.py",
      "line": 487,
      "side": "RIGHT",
      "diff_hunk": "@@ -483,6 +483,14 @@ def _get_uri_params(self, spider, uri_params, slot=None):\n         params['time'] = utc_now.replace(microsecond=0).isoformat().replace(':', '-')\n         params['batch_time'] = utc_now.isoformat().replace(':', '-')\n         params['batch_id'] = slot.batch_id + 1 if slot is not None else 1\n-        uripar_function = load_object(uri_params) if uri_params else lambda x, y: None\n-        uripar_function(params, spider)\n-        return params\n+        uripar_function = load_object(uri_params) if uri_params else lambda x, y: x\n+        new_params = uripar_function(params, spider)",
      "comment": "I\u2019m just leaving a note that it is technically possible for this change to break code if the user was modifying `params` but returning a dict with a different content from that of `params`. I don\u2019t think this should stop this change, but it may be worth mentioning in the release notes.",
      "comment_id": 573517714,
      "user": "Gallaecio",
      "created_at": "2021-02-10T08:02:20Z",
      "url": "https://github.com/scrapy/scrapy/pull/4966#discussion_r573517714"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 4966,
      "file_path": "scrapy/extensions/feedexport.py",
      "line": 487,
      "side": "RIGHT",
      "diff_hunk": "@@ -483,6 +483,14 @@ def _get_uri_params(self, spider, uri_params, slot=None):\n         params['time'] = utc_now.replace(microsecond=0).isoformat().replace(':', '-')\n         params['batch_time'] = utc_now.isoformat().replace(':', '-')\n         params['batch_id'] = slot.batch_id + 1 if slot is not None else 1\n-        uripar_function = load_object(uri_params) if uri_params else lambda x, y: None\n-        uripar_function(params, spider)\n-        return params\n+        uripar_function = load_object(uri_params) if uri_params else lambda x, y: x\n+        new_params = uripar_function(params, spider)",
      "comment": "What if we checked this? Making a shallow copy of the original `params` dict and making sure it didn't change after calling the `uripar_function`. Something like:\r\n\r\n```python\r\noriginal_params = params.copy()\r\nnew_params = uripar_function(params, spider)\r\nif new_params is None or original_params != params:\r\n   warnings.warn(...)\r\n```",
      "comment_id": 669587622,
      "user": "elacuesta",
      "created_at": "2021-07-14T12:54:11Z",
      "url": "https://github.com/scrapy/scrapy/pull/4966#discussion_r669587622"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 4966,
      "file_path": "scrapy/extensions/feedexport.py",
      "line": 487,
      "side": "RIGHT",
      "diff_hunk": "@@ -483,6 +483,14 @@ def _get_uri_params(self, spider, uri_params, slot=None):\n         params['time'] = utc_now.replace(microsecond=0).isoformat().replace(':', '-')\n         params['batch_time'] = utc_now.isoformat().replace(':', '-')\n         params['batch_id'] = slot.batch_id + 1 if slot is not None else 1\n-        uripar_function = load_object(uri_params) if uri_params else lambda x, y: None\n-        uripar_function(params, spider)\n-        return params\n+        uripar_function = load_object(uri_params) if uri_params else lambda x, y: x\n+        new_params = uripar_function(params, spider)",
      "comment": "I think it makes sense, though then we must document that as well, before people start using `.pop()` on the original to build the new one and things stop behaving as expected. Once we remove support for editing the dictionary in place, we can start allowing people to do that.",
      "comment_id": 669614141,
      "user": "Gallaecio",
      "created_at": "2021-07-14T13:27:17Z",
      "url": "https://github.com/scrapy/scrapy/pull/4966#discussion_r669614141"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 4966,
      "file_path": "scrapy/extensions/feedexport.py",
      "line": 551,
      "side": "RIGHT",
      "diff_hunk": "@@ -524,17 +524,31 @@ def build_instance(builder, *preargs):\n             raise TypeError(f\"{feedcls.__qualname__}.{method_name} returned None\")\n         return instance\n \n-    def _get_uri_params(self, spider, uri_params, slot=None):\n+    def _get_uri_params(\n+        self,\n+        spider: Spider,\n+        uri_params_function: Optional[Union[str, Callable[[dict, Spider], dict]]],\n+        slot: Optional[_FeedSlot] = None,\n+    ) -> dict:\n         params = {}\n         for k in dir(spider):\n             params[k] = getattr(spider, k)\n         utc_now = datetime.utcnow()\n         params['time'] = utc_now.replace(microsecond=0).isoformat().replace(':', '-')\n         params['batch_time'] = utc_now.isoformat().replace(':', '-')\n         params['batch_id'] = slot.batch_id + 1 if slot is not None else 1\n-        uripar_function = load_object(uri_params) if uri_params else lambda x, y: None\n-        uripar_function(params, spider)\n-        return params\n+        original_params = params.copy()\n+        uripar_function = load_object(uri_params_function) if uri_params_function else lambda params, _: params\n+        new_params = uripar_function(params, spider)\n+        if new_params is None or original_params != params:\n+            warnings.warn(\n+                'Modifying the params dictionary in-place in the function defined in '\n+                'the FEED_URI_PARAMS setting or in the uri_params key of the FEEDS '\n+                'setting is deprecated. The function must return a new dictionary '\n+                'instead.',\n+                category=ScrapyDeprecationWarning\n+            )\n+        return new_params if new_params is not None else params",
      "comment": "@Gallaecio Given this `if`, should we remove the `backward-incompatible` label?",
      "comment_id": 793680243,
      "user": "elacuesta",
      "created_at": "2022-01-27T14:47:22Z",
      "url": "https://github.com/scrapy/scrapy/pull/4966#discussion_r793680243"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 4966,
      "file_path": "scrapy/extensions/feedexport.py",
      "line": 530,
      "side": "RIGHT",
      "diff_hunk": "@@ -524,17 +524,31 @@ def build_instance(builder, *preargs):\n             raise TypeError(f\"{feedcls.__qualname__}.{method_name} returned None\")\n         return instance\n \n-    def _get_uri_params(self, spider, uri_params, slot=None):\n+    def _get_uri_params(\n+        self,\n+        spider: Spider,\n+        uri_params_function: Optional[Union[str, Callable[[dict, Spider], dict]]],",
      "comment": "`Union[str, Callable[[dict, Spider], dict], None]`?",
      "comment_id": 794429257,
      "user": "wRAR",
      "created_at": "2022-01-28T11:36:39Z",
      "url": "https://github.com/scrapy/scrapy/pull/4966#discussion_r794429257"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 4966,
      "file_path": "scrapy/extensions/feedexport.py",
      "line": 530,
      "side": "RIGHT",
      "diff_hunk": "@@ -524,17 +524,31 @@ def build_instance(builder, *preargs):\n             raise TypeError(f\"{feedcls.__qualname__}.{method_name} returned None\")\n         return instance\n \n-    def _get_uri_params(self, spider, uri_params, slot=None):\n+    def _get_uri_params(\n+        self,\n+        spider: Spider,\n+        uri_params_function: Optional[Union[str, Callable[[dict, Spider], dict]]],",
      "comment": "I would think `Optional[Union[\u2026]]` is more Pythonic than `Union[\u2026, None]`, even if longer. I don\u2019t really know, though.",
      "comment_id": 794473059,
      "user": "Gallaecio",
      "created_at": "2022-01-28T12:45:08Z",
      "url": "https://github.com/scrapy/scrapy/pull/4966#discussion_r794473059"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 4966,
      "file_path": "scrapy/extensions/feedexport.py",
      "line": 551,
      "side": "RIGHT",
      "diff_hunk": "@@ -524,17 +524,31 @@ def build_instance(builder, *preargs):\n             raise TypeError(f\"{feedcls.__qualname__}.{method_name} returned None\")\n         return instance\n \n-    def _get_uri_params(self, spider, uri_params, slot=None):\n+    def _get_uri_params(\n+        self,\n+        spider: Spider,\n+        uri_params_function: Optional[Union[str, Callable[[dict, Spider], dict]]],\n+        slot: Optional[_FeedSlot] = None,\n+    ) -> dict:\n         params = {}\n         for k in dir(spider):\n             params[k] = getattr(spider, k)\n         utc_now = datetime.utcnow()\n         params['time'] = utc_now.replace(microsecond=0).isoformat().replace(':', '-')\n         params['batch_time'] = utc_now.isoformat().replace(':', '-')\n         params['batch_id'] = slot.batch_id + 1 if slot is not None else 1\n-        uripar_function = load_object(uri_params) if uri_params else lambda x, y: None\n-        uripar_function(params, spider)\n-        return params\n+        original_params = params.copy()\n+        uripar_function = load_object(uri_params_function) if uri_params_function else lambda params, _: params\n+        new_params = uripar_function(params, spider)\n+        if new_params is None or original_params != params:\n+            warnings.warn(\n+                'Modifying the params dictionary in-place in the function defined in '\n+                'the FEED_URI_PARAMS setting or in the uri_params key of the FEEDS '\n+                'setting is deprecated. The function must return a new dictionary '\n+                'instead.',\n+                category=ScrapyDeprecationWarning\n+            )\n+        return new_params if new_params is not None else params",
      "comment": "No. https://github.com/scrapy/scrapy/pull/4966#discussion_r573517714 still applies.\r\n\r\nI\u2019m not sure we can make this backward-compatible for every single case, e.g. if someone is doing something unexpected (and pointless) like returning an empty dict, or returning a dict with content A but having their code actually rely on content B from `params` (what they currently get).\r\n\r\nI am OK, however, with things breaking in these rare scenarios, as long as we mention this in the release notes.",
      "comment_id": 794479779,
      "user": "Gallaecio",
      "created_at": "2022-01-28T12:55:09Z",
      "url": "https://github.com/scrapy/scrapy/pull/4966#discussion_r794479779"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 5334,
      "file_path": "scrapy/middleware.py",
      "line": 75,
      "side": "RIGHT",
      "diff_hunk": "@@ -64,14 +65,17 @@ def _add_middleware(self, mw) -> None:\n             self.methods['close_spider'].appendleft(mw.close_spider)\n \n     def _process_parallel(self, methodname: str, obj, *args) -> Deferred:\n-        return process_parallel(self.methods[methodname], obj, *args)\n+        methods = cast(Iterable[Callable], self.methods[methodname])\n+        return process_parallel(methods, obj, *args)\n \n     def _process_chain(self, methodname: str, obj, *args) -> Deferred:\n-        return process_chain(self.methods[methodname], obj, *args)\n+        methods = cast(Iterable[Callable], self.methods[methodname])\n+        return process_chain(methods, obj, *args)\n \n     def _process_chain_both(self, cb_methodname: str, eb_methodname: str, obj, *args) -> Deferred:",
      "comment": "This method is not covered because it's never used. I think we can drop it?",
      "comment_id": 758274435,
      "user": "wRAR",
      "created_at": "2021-11-29T11:30:39Z",
      "url": "https://github.com/scrapy/scrapy/pull/5334#discussion_r758274435"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 5320,
      "file_path": "scrapy/utils/response.py",
      "line": 6,
      "side": "RIGHT",
      "diff_hunk": "@@ -5,6 +5,7 @@\n import os\n import webbrowser\n import tempfile\n+import re",
      "comment": ":lipstick: \r\n\r\n```suggestion\r\nimport os\r\nimport re\r\nimport tempfile\r\nimport webbrowser\r\n```",
      "comment_id": 749185579,
      "user": "Gallaecio",
      "created_at": "2021-11-15T10:22:31Z",
      "url": "https://github.com/scrapy/scrapy/pull/5320#discussion_r749185579"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 5320,
      "file_path": "scrapy/utils/response.py",
      "line": 84,
      "side": "RIGHT",
      "diff_hunk": "@@ -80,8 +81,8 @@ def open_in_browser(\n     body = response.body\n     if isinstance(response, HtmlResponse):\n         if b'<base' not in body:\n-            repl = f'<head><base href=\"{response.url}\">'\n-            body = body.replace(b'<head>', to_bytes(repl))\n+            repl = f'\\\\1<base href=\"{response.url}\">'",
      "comment": ":lipstick: \r\n\r\n```suggestion\r\n            repl = fr'\\1<base href=\"{response.url}\">'\r\n```",
      "comment_id": 749186012,
      "user": "Gallaecio",
      "created_at": "2021-11-15T10:23:05Z",
      "url": "https://github.com/scrapy/scrapy/pull/5320#discussion_r749186012"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 5320,
      "file_path": "scrapy/utils/response.py",
      "line": 85,
      "side": "RIGHT",
      "diff_hunk": "@@ -80,8 +81,8 @@ def open_in_browser(\n     body = response.body\n     if isinstance(response, HtmlResponse):\n         if b'<base' not in body:\n-            repl = f'<head><base href=\"{response.url}\">'\n-            body = body.replace(b'<head>', to_bytes(repl))\n+            repl = f'\\\\1<base href=\"{response.url}\">'\n+            body = re.sub(b\"(<head.*?>)\", to_bytes(repl), body)",
      "comment": "```suggestion\r\n            body = re.sub(b\"(<head(?:>|\\s.*?>))\", to_bytes(repl), body)\r\n```\r\n\r\nOnly allows `<head` to be followed by `>` or a space-like character, so that things like `<header>` would not be matched. It would be great to include a test for this scenario.\r\n\r\nI also thought of specifying `count=0`, but then if there\u2019s a `<head>` between HTML comments before the actual one things would fail. This scenario would also be nice to cover in tests.",
      "comment_id": 749191784,
      "user": "Gallaecio",
      "created_at": "2021-11-15T10:30:11Z",
      "url": "https://github.com/scrapy/scrapy/pull/5320#discussion_r749191784"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 5320,
      "file_path": "scrapy/utils/response.py",
      "line": 85,
      "side": "RIGHT",
      "diff_hunk": "@@ -80,8 +81,9 @@ def open_in_browser(\n     body = response.body\n     if isinstance(response, HtmlResponse):\n         if b'<base' not in body:\n-            repl = f'<head><base href=\"{response.url}\">'\n-            body = body.replace(b'<head>', to_bytes(repl))\n+            repl = fr'\\1<base href=\"{response.url}\">'\n+            body = re.sub(b\"<!--.*?-->\", b\"\", body, flags=re.DOTALL)",
      "comment": "I don\u2019t think this is needed, worst case scenario we replace the head in comments as well, which should not be a huge problem.",
      "comment_id": 749366088,
      "user": "Gallaecio",
      "created_at": "2021-11-15T14:17:00Z",
      "url": "https://github.com/scrapy/scrapy/pull/5320#discussion_r749366088"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 5320,
      "file_path": "scrapy/utils/response.py",
      "line": 85,
      "side": "RIGHT",
      "diff_hunk": "@@ -80,8 +81,9 @@ def open_in_browser(\n     body = response.body\n     if isinstance(response, HtmlResponse):\n         if b'<base' not in body:\n-            repl = f'<head><base href=\"{response.url}\">'\n-            body = body.replace(b'<head>', to_bytes(repl))\n+            repl = fr'\\1<base href=\"{response.url}\">'\n+            body = re.sub(b\"<!--.*?-->\", b\"\", body, flags=re.DOTALL)",
      "comment": "I agree, it is not an issue for the feature itself, but it makes testing quite hard, to ensure there is a single `<base>` tag.",
      "comment_id": 749391773,
      "user": "zessx",
      "created_at": "2021-11-15T14:45:42Z",
      "url": "https://github.com/scrapy/scrapy/pull/5320#discussion_r749391773"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 5269,
      "file_path": "scrapy/loader/__init__.py",
      "line": 87,
      "side": "RIGHT",
      "diff_hunk": "@@ -83,6 +84,6 @@ class ItemLoader(itemloaders.ItemLoader):\n \n     def __init__(self, item=None, selector=None, response=None, parent=None, **context):\n         if selector is None and response is not None:\n-            selector = self.default_selector_class(response)\n+            selector = None if not (isinstance(response, HtmlResponse) or isinstance(response, XmlResponse)) else self.default_selector_class(response)",
      "comment": "The problem I see with this approach is that it seems more restrictive that it needs to be. It does not account for custom response classes inheriting from `TextResponse`, which would currently provide an HTML-based selector, but after this change would get no selector. So this change has the potential of breaking existing code.\r\n\r\nAt the moment, all a response object needs to have to get a valid Scrapy selector is to have a `text` attribute. I feel we should not impose any requirement on top of that.\r\n\r\nFurthermore, if in the future the selector class of Scrapy gains support for an alternative logic, e.g. reading the `body` attribute instead of `text` (BSON support, to follow the upcoming JSON support?), we would need to change the code here as well to make things work. Because of that, I\u2019m inclined to suggest that, instead of checking anything in `response` here, we should always pass it to the default selector class, and upon an AttributeError exception (or some new, custom exception?) set `selector` to `None`.",
      "comment_id": 725596236,
      "user": "Gallaecio",
      "created_at": "2021-10-10T07:54:01Z",
      "url": "https://github.com/scrapy/scrapy/pull/5269#discussion_r725596236"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 5246,
      "file_path": "scrapy/extensions/httpcache.py",
      "line": 229,
      "side": "RIGHT",
      "diff_hunk": "@@ -226,7 +226,7 @@ def open_spider(self, spider):\n         dbpath = os.path.join(self.cachedir, f'{spider.name}.db')\n         self.db = self.dbmodule.open(dbpath, 'c')\n \n-        logger.debug(\"Using DBM cache storage in %(cachepath)s\" % {'cachepath': dbpath}, extra={'spider': spider})\n+        logger.debug(f\"Using DBM cache storage in {dbpath}\", extra={'spider': spider})",
      "comment": "Old message from `pylint` related to this code line:\r\n`scrapy/extensions/httpcache.py:229:21: C0209: Formatting a regular string which could be a f-string (consider-using-f-string)`\r\nNew message from `pylint` related to this code line:\r\n`scrapy/extensions/httpcache.py:229:8: W1203: Use lazy % or .format() or % formatting in logging functions (logging-fstring-interpolation)`",
      "comment_id": 714869748,
      "user": "GeorgeA92",
      "created_at": "2021-09-23T14:43:01Z",
      "url": "https://github.com/scrapy/scrapy/pull/5246#discussion_r714869748"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 5246,
      "file_path": "scrapy/downloadermiddlewares/httpcache.py",
      "line": 73,
      "side": "RIGHT",
      "diff_hunk": "@@ -70,7 +70,7 @@ def process_request(self, request: Request, spider: Spider) -> Optional[Response\n             self.stats.inc_value('httpcache/miss', spider=spider)\n             if self.ignore_missing:\n                 self.stats.inc_value('httpcache/ignore', spider=spider)\n-                raise IgnoreRequest(\"Ignored request not in cache: %s\" % request)\n+                raise IgnoreRequest(f\"Ignored request not in cache: {str(request)}\")",
      "comment": "```suggestion\r\n                raise IgnoreRequest(f\"Ignored request not in cache: {request}\")\r\n```\r\nUse `str` inside a f-string is redudant, same for others places.",
      "comment_id": 714986529,
      "user": "Laerte",
      "created_at": "2021-09-23T16:57:35Z",
      "url": "https://github.com/scrapy/scrapy/pull/5246#discussion_r714986529"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 5246,
      "file_path": "scrapy/core/downloader/contextfactory.py",
      "line": 139,
      "side": "RIGHT",
      "diff_hunk": "@@ -135,11 +135,11 @@ def load_context_factory_from_settings(settings, crawler):\n             settings=settings,\n             crawler=crawler,\n         )\n-        msg = \"\"\"\n-            '%s' does not accept `method` argument (type OpenSSL.SSL method,\\\n-            e.g. OpenSSL.SSL.SSLv23_METHOD) and/or `tls_verbose_logging` argument and/or `tls_ciphers` argument.\\\n-            Please upgrade your context factory class to handle them or ignore them.\"\"\" % (\n-            settings['DOWNLOADER_CLIENTCONTEXTFACTORY'],)\n+        msg = f\"\"\"\n+        {str(settings['DOWNLOADER_CLIENTCONTEXTFACTORY'],)} \\",
      "comment": "I think we don't need a tuple here, not sure why it was used before though.",
      "comment_id": 715442654,
      "user": "wRAR",
      "created_at": "2021-09-24T09:02:03Z",
      "url": "https://github.com/scrapy/scrapy/pull/5246#discussion_r715442654"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 5246,
      "file_path": "scrapy/extensions/feedexport.py",
      "line": 358,
      "side": "RIGHT",
      "diff_hunk": "@@ -356,32 +355,28 @@ def _close_slot(self, slot, spider):\n             # properly closed.\n             return defer.maybeDeferred(slot.storage.store, slot.file)\n         slot.finish_exporting()\n-        logfmt = \"%s %%(format)s feed (%%(itemcount)d items) in: %%(uri)s\"\n-        log_args = {'format': slot.format,\n-                    'itemcount': slot.itemcount,\n-                    'uri': slot.uri}\n+        logfmt = f\"{slot.format} feed ({str(slot.itemcount)} items) in: {slot.uri}\"",
      "comment": "As this is no longer a format string, it can be renamed to something like \"logmsg\" I think.",
      "comment_id": 715444218,
      "user": "wRAR",
      "created_at": "2021-09-24T09:04:18Z",
      "url": "https://github.com/scrapy/scrapy/pull/5246#discussion_r715444218"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 5246,
      "file_path": "scrapy/core/downloader/contextfactory.py",
      "line": 139,
      "side": "RIGHT",
      "diff_hunk": "@@ -135,11 +135,11 @@ def load_context_factory_from_settings(settings, crawler):\n             settings=settings,\n             crawler=crawler,\n         )\n-        msg = \"\"\"\n-            '%s' does not accept `method` argument (type OpenSSL.SSL method,\\\n-            e.g. OpenSSL.SSL.SSLv23_METHOD) and/or `tls_verbose_logging` argument and/or `tls_ciphers` argument.\\\n-            Please upgrade your context factory class to handle them or ignore them.\"\"\" % (\n-            settings['DOWNLOADER_CLIENTCONTEXTFACTORY'],)\n+        msg = f\"\"\"\n+        {str(settings['DOWNLOADER_CLIENTCONTEXTFACTORY'],)} \\",
      "comment": "@wRAR,  fixed -> https://github.com/scrapy/scrapy/pull/5246/commits/2a1faec1dabee5011698c5aade263dfa378c11f6 ",
      "comment_id": 715481979,
      "user": "GeorgeA92",
      "created_at": "2021-09-24T09:59:35Z",
      "url": "https://github.com/scrapy/scrapy/pull/5246#discussion_r715481979"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 5246,
      "file_path": "scrapy/extensions/feedexport.py",
      "line": 358,
      "side": "RIGHT",
      "diff_hunk": "@@ -356,32 +355,28 @@ def _close_slot(self, slot, spider):\n             # properly closed.\n             return defer.maybeDeferred(slot.storage.store, slot.file)\n         slot.finish_exporting()\n-        logfmt = \"%s %%(format)s feed (%%(itemcount)d items) in: %%(uri)s\"\n-        log_args = {'format': slot.format,\n-                    'itemcount': slot.itemcount,\n-                    'uri': slot.uri}\n+        logfmt = f\"{slot.format} feed ({str(slot.itemcount)} items) in: {slot.uri}\"",
      "comment": "@wRAR , fixed https://github.com/scrapy/scrapy/pull/5246/commits/91b776e47287ddcbce2f675041ef5b6366d748a8",
      "comment_id": 715482010,
      "user": "GeorgeA92",
      "created_at": "2021-09-24T09:59:39Z",
      "url": "https://github.com/scrapy/scrapy/pull/5246#discussion_r715482010"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 5246,
      "file_path": "scrapy/core/downloader/contextfactory.py",
      "line": 142,
      "side": "RIGHT",
      "diff_hunk": "@@ -135,11 +135,11 @@ def load_context_factory_from_settings(settings, crawler):\n             settings=settings,\n             crawler=crawler,\n         )\n-        msg = \"\"\"\n-            '%s' does not accept `method` argument (type OpenSSL.SSL method,\\\n-            e.g. OpenSSL.SSL.SSLv23_METHOD) and/or `tls_verbose_logging` argument and/or `tls_ciphers` argument.\\\n-            Please upgrade your context factory class to handle them or ignore them.\"\"\" % (\n-            settings['DOWNLOADER_CLIENTCONTEXTFACTORY'],)\n+        msg = f\"\"\"\n+        {str(settings['DOWNLOADER_CLIENTCONTEXTFACTORY'])} \\\n+        does not accept `method` argument (type OpenSSL.SSL method,\\\n+        e.g. OpenSSL.SSL.SSLv23_METHOD) and/or `tls_verbose_logging` argument and/or `tls_ciphers` argument.\\\n+        Please upgrade your context factory class to handle them or ignore them.\"\"\"",
      "comment": "Can we take the opportunity to stop using triple quotes here? I expect them to mess up spaces when the message is displayed:\r\n\r\n```suggestion\r\n        msg = (\r\n            f\"{settings['DOWNLOADER_CLIENTCONTEXTFACTORY']} does not accept \"\r\n            \"a `method` argument (type OpenSSL.SSL method, e.g. \"\r\n            \"OpenSSL.SSL.SSLv23_METHOD) and/or a `tls_verbose_logging` \"\r\n            \"argument and/or a `tls_ciphers` argument. Please, upgrade your \"\r\n            \"context factory class to handle them or ignore them.\"\r\n        )\r\n```\r\n\r\n(I also took the liberty of including some articles and a comma, and removing the unneeded `str()`)",
      "comment_id": 716078394,
      "user": "Gallaecio",
      "created_at": "2021-09-25T18:05:35Z",
      "url": "https://github.com/scrapy/scrapy/pull/5246#discussion_r716078394"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 5246,
      "file_path": "scrapy/core/downloader/tls.py",
      "line": 75,
      "side": "RIGHT",
      "diff_hunk": "@@ -65,14 +65,14 @@ def _identityVerifyingInfoCallback(self, connection, where, ret):\n                 verifyHostname(connection, self._hostnameASCII)\n             except (CertificateError, VerificationError) as e:\n                 logger.warning(\n-                    'Remote certificate is not valid for hostname \"{}\"; {}'.format(\n-                        self._hostnameASCII, e))\n+                    'Remote certificate is not valid for hostname \"%s\"; %s',\n+                    self._hostnameASCII, e)\n \n             except ValueError as e:\n                 logger.warning(\n                     'Ignoring error while verifying certificate '\n-                    'from host \"{}\" (exception: {})'.format(\n-                        self._hostnameASCII, repr(e)))\n+                    'from host \"%s\" (exception: %s)',\n+                    self._hostnameASCII, repr(e))",
      "comment": "```suggestion\r\n                    'from host \"%s\" (exception: %r)',\r\n                    self._hostnameASCII, e)\r\n```",
      "comment_id": 716078702,
      "user": "Gallaecio",
      "created_at": "2021-09-25T18:08:31Z",
      "url": "https://github.com/scrapy/scrapy/pull/5246#discussion_r716078702"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 5246,
      "file_path": "scrapy/extensions/feedexport.py",
      "line": 358,
      "side": "RIGHT",
      "diff_hunk": "@@ -356,32 +355,28 @@ def _close_slot(self, slot, spider):\n             # properly closed.\n             return defer.maybeDeferred(slot.storage.store, slot.file)\n         slot.finish_exporting()\n-        logfmt = \"%s %%(format)s feed (%%(itemcount)d items) in: %%(uri)s\"\n-        log_args = {'format': slot.format,\n-                    'itemcount': slot.itemcount,\n-                    'uri': slot.uri}\n+        logmsg = f\"{slot.format} feed ({str(slot.itemcount)} items) in: {slot.uri}\"",
      "comment": "```suggestion\r\n        logmsg = f\"{slot.format} feed ({slot.itemcount} items) in: {slot.uri}\"\r\n```",
      "comment_id": 716079396,
      "user": "Gallaecio",
      "created_at": "2021-09-25T18:15:04Z",
      "url": "https://github.com/scrapy/scrapy/pull/5246#discussion_r716079396"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 5246,
      "file_path": "scrapy/utils/misc.py",
      "line": 53,
      "side": "RIGHT",
      "diff_hunk": "@@ -50,7 +50,7 @@ def load_object(path):\n             return path\n         else:\n             raise TypeError(\"Unexpected argument type, expected string \"\n-                            \"or object, got: %s\" % type(path))\n+                            f\"or object, got: {str(type(path))}\")",
      "comment": "```suggestion\r\n                            f\"or object, got: {type(path)}\")\r\n```",
      "comment_id": 716080552,
      "user": "Gallaecio",
      "created_at": "2021-09-25T18:17:06Z",
      "url": "https://github.com/scrapy/scrapy/pull/5246#discussion_r716080552"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 5246,
      "file_path": "tests/test_http_request.py",
      "line": 1222,
      "side": "LEFT",
      "diff_hunk": "@@ -1217,16 +1217,23 @@ def test_from_response_css(self):\n                           response, formcss=\"input[name='abc']\")\n \n     def test_from_response_valid_form_methods(self):\n-        body = \"\"\"<form action=\"post.php\" method=\"%s\">\n-            <input type=\"hidden\" name=\"one\" value=\"1\">\n-            </form>\"\"\"",
      "comment": "I think in this case the point is to avoid repeating the string, so I would switch to `.format()` instead of f-string.",
      "comment_id": 716080918,
      "user": "Gallaecio",
      "created_at": "2021-09-25T18:19:19Z",
      "url": "https://github.com/scrapy/scrapy/pull/5246#discussion_r716080918"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 5246,
      "file_path": "scrapy/core/downloader/contextfactory.py",
      "line": 142,
      "side": "RIGHT",
      "diff_hunk": "@@ -135,11 +135,11 @@ def load_context_factory_from_settings(settings, crawler):\n             settings=settings,\n             crawler=crawler,\n         )\n-        msg = \"\"\"\n-            '%s' does not accept `method` argument (type OpenSSL.SSL method,\\\n-            e.g. OpenSSL.SSL.SSLv23_METHOD) and/or `tls_verbose_logging` argument and/or `tls_ciphers` argument.\\\n-            Please upgrade your context factory class to handle them or ignore them.\"\"\" % (\n-            settings['DOWNLOADER_CLIENTCONTEXTFACTORY'],)\n+        msg = f\"\"\"\n+        {str(settings['DOWNLOADER_CLIENTCONTEXTFACTORY'])} \\\n+        does not accept `method` argument (type OpenSSL.SSL method,\\\n+        e.g. OpenSSL.SSL.SSLv23_METHOD) and/or `tls_verbose_logging` argument and/or `tls_ciphers` argument.\\\n+        Please upgrade your context factory class to handle them or ignore them.\"\"\"",
      "comment": "@Gallaecio,  fixed -> https://github.com/scrapy/scrapy/pull/5246/commits/9c6b2b916dfa7efa9bd736144c0a64d2b5beccbd",
      "comment_id": 716657518,
      "user": "GeorgeA92",
      "created_at": "2021-09-27T12:48:05Z",
      "url": "https://github.com/scrapy/scrapy/pull/5246#discussion_r716657518"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 5246,
      "file_path": "scrapy/core/downloader/tls.py",
      "line": 75,
      "side": "RIGHT",
      "diff_hunk": "@@ -65,14 +65,14 @@ def _identityVerifyingInfoCallback(self, connection, where, ret):\n                 verifyHostname(connection, self._hostnameASCII)\n             except (CertificateError, VerificationError) as e:\n                 logger.warning(\n-                    'Remote certificate is not valid for hostname \"{}\"; {}'.format(\n-                        self._hostnameASCII, e))\n+                    'Remote certificate is not valid for hostname \"%s\"; %s',\n+                    self._hostnameASCII, e)\n \n             except ValueError as e:\n                 logger.warning(\n                     'Ignoring error while verifying certificate '\n-                    'from host \"{}\" (exception: {})'.format(\n-                        self._hostnameASCII, repr(e)))\n+                    'from host \"%s\" (exception: %s)',\n+                    self._hostnameASCII, repr(e))",
      "comment": "@Gallaecio, fixed -> https://github.com/scrapy/scrapy/pull/5246/commits/3ce0fad06336f1438be9eb5d0ebe5aac74f0b3ec",
      "comment_id": 716657625,
      "user": "GeorgeA92",
      "created_at": "2021-09-27T12:48:13Z",
      "url": "https://github.com/scrapy/scrapy/pull/5246#discussion_r716657625"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 5246,
      "file_path": "scrapy/extensions/feedexport.py",
      "line": 358,
      "side": "RIGHT",
      "diff_hunk": "@@ -356,32 +355,28 @@ def _close_slot(self, slot, spider):\n             # properly closed.\n             return defer.maybeDeferred(slot.storage.store, slot.file)\n         slot.finish_exporting()\n-        logfmt = \"%s %%(format)s feed (%%(itemcount)d items) in: %%(uri)s\"\n-        log_args = {'format': slot.format,\n-                    'itemcount': slot.itemcount,\n-                    'uri': slot.uri}\n+        logmsg = f\"{slot.format} feed ({str(slot.itemcount)} items) in: {slot.uri}\"",
      "comment": "@Gallaecio, fixed ->https://github.com/scrapy/scrapy/pull/5246/commits/0f27f1b12fb9296183d0e25072f5b56091782769",
      "comment_id": 716657699,
      "user": "GeorgeA92",
      "created_at": "2021-09-27T12:48:18Z",
      "url": "https://github.com/scrapy/scrapy/pull/5246#discussion_r716657699"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 5246,
      "file_path": "scrapy/utils/misc.py",
      "line": 53,
      "side": "RIGHT",
      "diff_hunk": "@@ -50,7 +50,7 @@ def load_object(path):\n             return path\n         else:\n             raise TypeError(\"Unexpected argument type, expected string \"\n-                            \"or object, got: %s\" % type(path))\n+                            f\"or object, got: {str(type(path))}\")",
      "comment": "@Gallaecio , fixed -> https://github.com/scrapy/scrapy/pull/5246/commits/bb62afd749cb0c871de6fc732803fc70e4c0f7f1",
      "comment_id": 716657914,
      "user": "GeorgeA92",
      "created_at": "2021-09-27T12:48:34Z",
      "url": "https://github.com/scrapy/scrapy/pull/5246#discussion_r716657914"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 5246,
      "file_path": "tests/test_http_request.py",
      "line": 1222,
      "side": "LEFT",
      "diff_hunk": "@@ -1217,16 +1217,23 @@ def test_from_response_css(self):\n                           response, formcss=\"input[name='abc']\")\n \n     def test_from_response_valid_form_methods(self):\n-        body = \"\"\"<form action=\"post.php\" method=\"%s\">\n-            <input type=\"hidden\" name=\"one\" value=\"1\">\n-            </form>\"\"\"",
      "comment": "@Gallaecio,  `test_from_response_valid_form_methods` updated https://github.com/scrapy/scrapy/pull/5246/commits/67ce305046398d08d626436c0d23376309cc4d67",
      "comment_id": 716658235,
      "user": "GeorgeA92",
      "created_at": "2021-09-27T12:48:57Z",
      "url": "https://github.com/scrapy/scrapy/pull/5246#discussion_r716658235"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 5246,
      "file_path": "tests/test_http_request.py",
      "line": 1221,
      "side": "RIGHT",
      "diff_hunk": "@@ -1217,25 +1217,17 @@ def test_from_response_css(self):\n                           response, formcss=\"input[name='abc']\")\n \n     def test_from_response_valid_form_methods(self):\n+        form_methods = [[method, method] for method in self.request_class.valid_form_methods] + \\\n+                       [['UNKNOWN', 'GET']]",
      "comment": "Note that we tend to avoid using `\\` for line continuation, and instead use parentheses. For example:\r\n\r\n```suggestion\r\n        form_methods = (\r\n            [[method, method] for method in self.request_class.valid_form_methods]\r\n            + [['UNKNOWN', 'GET']]\r\n        )\r\n```\r\n\r\nThat said, we will eventually switch to Black I think, so it probably does not matter much.",
      "comment_id": 717248151,
      "user": "Gallaecio",
      "created_at": "2021-09-28T06:00:25Z",
      "url": "https://github.com/scrapy/scrapy/pull/5246#discussion_r717248151"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 5246,
      "file_path": "scrapy/extensions/feedexport.py",
      "line": 379,
      "side": "RIGHT",
      "diff_hunk": "@@ -356,32 +355,28 @@ def _close_slot(self, slot, spider):\n             # properly closed.\n             return defer.maybeDeferred(slot.storage.store, slot.file)\n         slot.finish_exporting()\n-        logfmt = \"%s %%(format)s feed (%%(itemcount)d items) in: %%(uri)s\"\n-        log_args = {'format': slot.format,\n-                    'itemcount': slot.itemcount,\n-                    'uri': slot.uri}\n+        logmsg = f\"{slot.format} feed ({slot.itemcount} items) in: {slot.uri}\"\n         d = defer.maybeDeferred(slot.storage.store, slot.file)\n \n-        # Use `largs=log_args` to copy log_args into function's scope\n-        # instead of using `log_args` from the outer scope\n         d.addCallback(\n-            self._handle_store_success, log_args, logfmt, spider, type(slot.storage).__name__\n+            self._handle_store_success, logmsg, spider, type(slot.storage).__name__\n         )\n         d.addErrback(\n-            self._handle_store_error, log_args, logfmt, spider, type(slot.storage).__name__\n+            self._handle_store_error, logmsg, spider, type(slot.storage).__name__\n         )\n         return d\n \n-    def _handle_store_error(self, f, largs, logfmt, spider, slot_type):\n+    def _handle_store_error(self, f, logmsg, spider, slot_type):\n         logger.error(\n-            logfmt % \"Error storing\", largs,\n+            \"Error storing %s\", logmsg,\n             exc_info=failure_to_exc_info(f), extra={'spider': spider}\n         )\n         self.crawler.stats.inc_value(f\"feedexport/failed_count/{slot_type}\")\n \n-    def _handle_store_success(self, f, largs, logfmt, spider, slot_type):\n+    def _handle_store_success(self, f, logmsg, spider, slot_type):\n         logger.info(\n-            logfmt % \"Stored\", largs, extra={'spider': spider}\n+            \"Stored %s\", logmsg,\n+            extra={'spider': spider}",
      "comment": "(Nitpick) I would suggest either putting everything in the same line (which should be ok given our current line length), or each argument in its own line.",
      "comment_id": 718867416,
      "user": "elacuesta",
      "created_at": "2021-09-29T20:39:14Z",
      "url": "https://github.com/scrapy/scrapy/pull/5246#discussion_r718867416"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 5246,
      "file_path": "tests/test_http_request.py",
      "line": 1221,
      "side": "RIGHT",
      "diff_hunk": "@@ -1217,25 +1217,17 @@ def test_from_response_css(self):\n                           response, formcss=\"input[name='abc']\")\n \n     def test_from_response_valid_form_methods(self):\n+        form_methods = [[method, method] for method in self.request_class.valid_form_methods] + \\\n+                       [['UNKNOWN', 'GET']]",
      "comment": "fixed https://github.com/scrapy/scrapy/pull/5246/commits/d3be17b87f29d91f402884bf4bf96da8af93d225",
      "comment_id": 720534650,
      "user": "GeorgeA92",
      "created_at": "2021-10-01T20:53:05Z",
      "url": "https://github.com/scrapy/scrapy/pull/5246#discussion_r720534650"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 4691,
      "file_path": "tests/spiders.py",
      "line": 258,
      "side": "RIGHT",
      "diff_hunk": "@@ -255,7 +255,7 @@ class CrawlSpiderWithParseMethod(MockServerSpider, CrawlSpider):\n     A CrawlSpider which overrides the 'parse' method\n     \"\"\"\n     name = 'crawl_spider_with_parse_method'\n-    custom_settings = {\n+    custom_settings: dict = {",
      "comment": "I don't really know why this is necessary, since `custom_settings` is annotated in the base class :shrug: ",
      "comment_id": 459437498,
      "user": "elacuesta",
      "created_at": "2020-07-23T13:12:05Z",
      "url": "https://github.com/scrapy/scrapy/pull/4691#discussion_r459437498"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 4691,
      "file_path": "scrapy/spiders/__init__.py",
      "line": 22,
      "side": "RIGHT",
      "diff_hunk": "@@ -18,8 +19,8 @@ class Spider(object_ref):\n     class.\n     \"\"\"\n \n-    name = None\n-    custom_settings = None\n+    name: Optional[str] = None",
      "comment": "Indeed, it's not supported, that's why the PR is under the Python 3.6+ milestone.",
      "comment_id": 461527416,
      "user": "elacuesta",
      "created_at": "2020-07-28T12:05:01Z",
      "url": "https://github.com/scrapy/scrapy/pull/4691#discussion_r461527416"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 4691,
      "file_path": "scrapy/spiders/__init__.py",
      "line": 22,
      "side": "RIGHT",
      "diff_hunk": "@@ -18,8 +19,8 @@ class Spider(object_ref):\n     class.\n     \"\"\"\n \n-    name = None\n-    custom_settings = None\n+    name: Optional[str] = None",
      "comment": ":facepalm:\r\n\r\nServes me right for reviewing draft pull requests.",
      "comment_id": 461793350,
      "user": "Gallaecio",
      "created_at": "2020-07-28T18:41:03Z",
      "url": "https://github.com/scrapy/scrapy/pull/4691#discussion_r461793350"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 4691,
      "file_path": "scrapy/spiders/crawl.py",
      "line": 76,
      "side": "RIGHT",
      "diff_hunk": "@@ -72,7 +73,7 @@ def _process_request(self, request, response):\n \n class CrawlSpider(Spider):\n \n-    rules = ()\n+    rules: Union[List[Rule], List, Tuple[Rule], Tuple] = ()",
      "comment": "I don't like having `List/Tuple` here, but `Incompatible types in assignment (expression has type \"Tuple[]\", variable has type \"Union[List[Rule], Tuple[Rule]]\")` occurs otherwise. I think it would be much more reasonable for `mypy` to consider an empty tuplr as a valid object.\r\nAn alternative would be `rules: Union[List[Rule], Tuple[Rule]] = ()  # type: ignore`, but that would mean the type hint is not actually being evaluated, it'd be there just for documentation purposes. Any thoughts?\r\n\r\nSee also https://www.python.org/dev/peps/pep-0484/#type-comments",
      "comment_id": 475275802,
      "user": "elacuesta",
      "created_at": "2020-08-23T22:37:31Z",
      "url": "https://github.com/scrapy/scrapy/pull/4691#discussion_r475275802"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 4691,
      "file_path": "scrapy/spiders/crawl.py",
      "line": 76,
      "side": "RIGHT",
      "diff_hunk": "@@ -72,7 +73,7 @@ def _process_request(self, request, response):\n \n class CrawlSpider(Spider):\n \n-    rules = ()\n+    rules: Union[List[Rule], List, Tuple[Rule], Tuple] = ()",
      "comment": "From what I\u2019m reading, maybe `List[Rule, ...]` could replace `List[Rule], List`.",
      "comment_id": 476465129,
      "user": "Gallaecio",
      "created_at": "2020-08-25T13:52:06Z",
      "url": "https://github.com/scrapy/scrapy/pull/4691#discussion_r476465129"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 4691,
      "file_path": "scrapy/spiders/crawl.py",
      "line": 76,
      "side": "RIGHT",
      "diff_hunk": "@@ -72,7 +73,7 @@ def _process_request(self, request, response):\n \n class CrawlSpider(Spider):\n \n-    rules = ()\n+    rules: Union[List[Rule], List, Tuple[Rule], Tuple] = ()",
      "comment": "I wonder if we should use only `Sequence[Rule, ...]` here.",
      "comment_id": 476469337,
      "user": "Gallaecio",
      "created_at": "2020-08-25T13:57:38Z",
      "url": "https://github.com/scrapy/scrapy/pull/4691#discussion_r476469337"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 5190,
      "file_path": "scrapy/extensions/postprocessing.py",
      "line": 60,
      "side": "RIGHT",
      "diff_hunk": "@@ -0,0 +1,76 @@\n+\"\"\"\n+Extension for processing data before they are exported to feeds.\n+\"\"\"\n+\n+from scrapy.utils.misc import load_object\n+from zope.interface import Interface\n+\n+\n+class PostProcessorPlugin(Interface):\n+    \"\"\"\n+    Interface for plugin which will be used by PostProcessingManager\n+    for pre-export data processing.\n+    \"\"\"\n+\n+    def __init__(self, file):\n+        \"\"\"\n+        Initialize plugin with target file to which post-processed\n+        data will be written\n+        \"\"\"\n+\n+    def write(self, data):\n+        \"\"\"\n+        Write `data` to plugin's target file.\n+        :param data: data passed to be written to file\n+        :type data: bytes\n+        :return: returns number of bytes written\n+        :rtype: int\n+        \"\"\"\n+\n+    def close(self):\n+        \"\"\"\n+        Close this plugin.\n+        \"\"\"\n+\n+\n+class PostProcessingManager:\n+    \"\"\"\n+    This will manage and use declared plugins to process data in a\n+    pipeline-ish way.\n+    :param plugins: all the declared plugins for the feed\n+    :type plugins: list\n+    :param file: final target file where the processed data will be written\n+    :type file: file like object\n+    \"\"\"\n+\n+    def __init__(self, plugins, file):\n+        self.plugins = self._load_plugins(plugins)\n+        self.file = file\n+        self.head_plugin = self._get_head_plugin()\n+\n+    def write(self, data):\n+        \"\"\"\n+        Uses all the declared plugins to process data first, then writes\n+        the processed data to target file.\n+        :param data: data passed to be written to target file\n+        :type data: bytes\n+        :return: returns number of bytes written\n+        :rtype: int\n+        \"\"\"\n+        return self.head_plugin.write(data)",
      "comment": "What do you plan to do with the returned value (the number of bytes written)?",
      "comment_id": 657249510,
      "user": "Gallaecio",
      "created_at": "2021-06-23T15:57:54Z",
      "url": "https://github.com/scrapy/scrapy/pull/5190#discussion_r657249510"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 5190,
      "file_path": "scrapy/extensions/postprocessing.py",
      "line": 60,
      "side": "RIGHT",
      "diff_hunk": "@@ -0,0 +1,76 @@\n+\"\"\"\n+Extension for processing data before they are exported to feeds.\n+\"\"\"\n+\n+from scrapy.utils.misc import load_object\n+from zope.interface import Interface\n+\n+\n+class PostProcessorPlugin(Interface):\n+    \"\"\"\n+    Interface for plugin which will be used by PostProcessingManager\n+    for pre-export data processing.\n+    \"\"\"\n+\n+    def __init__(self, file):\n+        \"\"\"\n+        Initialize plugin with target file to which post-processed\n+        data will be written\n+        \"\"\"\n+\n+    def write(self, data):\n+        \"\"\"\n+        Write `data` to plugin's target file.\n+        :param data: data passed to be written to file\n+        :type data: bytes\n+        :return: returns number of bytes written\n+        :rtype: int\n+        \"\"\"\n+\n+    def close(self):\n+        \"\"\"\n+        Close this plugin.\n+        \"\"\"\n+\n+\n+class PostProcessingManager:\n+    \"\"\"\n+    This will manage and use declared plugins to process data in a\n+    pipeline-ish way.\n+    :param plugins: all the declared plugins for the feed\n+    :type plugins: list\n+    :param file: final target file where the processed data will be written\n+    :type file: file like object\n+    \"\"\"\n+\n+    def __init__(self, plugins, file):\n+        self.plugins = self._load_plugins(plugins)\n+        self.file = file\n+        self.head_plugin = self._get_head_plugin()\n+\n+    def write(self, data):\n+        \"\"\"\n+        Uses all the declared plugins to process data first, then writes\n+        the processed data to target file.\n+        :param data: data passed to be written to target file\n+        :type data: bytes\n+        :return: returns number of bytes written\n+        :rtype: int\n+        \"\"\"\n+        return self.head_plugin.write(data)",
      "comment": "I thought I should have the return value similar to file object's ```write``` because if in some other part of feed code, the code has been written in such a way to use the returned number of bytes written, that existing code doesn't break while applying a plugin wrapper.",
      "comment_id": 657351488,
      "user": "drs-11",
      "created_at": "2021-06-23T18:13:13Z",
      "url": "https://github.com/scrapy/scrapy/pull/5190#discussion_r657351488"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 5190,
      "file_path": "scrapy/extensions/postprocessing.py",
      "line": 96,
      "side": "RIGHT",
      "diff_hunk": "@@ -0,0 +1,140 @@\n+\"\"\"\n+Extension for processing data before they are exported to feeds.\n+\"\"\"\n+from io import IOBase\n+from bz2 import BZ2File\n+from gzip import GzipFile\n+from lzma import LZMAFile\n+\n+from scrapy.utils.misc import load_object\n+from zope.interface import Interface, implementer\n+\n+\n+class PostProcessorPlugin(Interface):\n+    \"\"\"\n+    Interface for plugin which will be used by PostProcessingManager\n+    for pre-export data processing.\n+    \"\"\"\n+\n+    def __init__(self, file, feed_options):\n+        \"\"\"\n+        Initialize plugin with target file to which post-processed\n+        data will be written and the feed-specific options (see :setting:`FEEDS`).\n+        \"\"\"\n+\n+    def write(self, data):\n+        \"\"\"\n+        Write `data` to plugin's target file.\n+        :param data: data passed to be written to file\n+        :type data: bytes\n+        :return: returns number of bytes written\n+        :rtype: int\n+        \"\"\"\n+\n+    def close(self):\n+        \"\"\"\n+        Close this plugin.\n+        \"\"\"\n+\n+\n+@implementer(PostProcessorPlugin)\n+class GzipPlugin:\n+\n+    def __init__(self, file, feed_options):\n+        self.file = file\n+        self.feed_options = feed_options\n+        compress_level = self.feed_options.get(\"gzip_compresslevel\", 9)\n+        self.gzipfile = GzipFile(fileobj=self.file, mode=\"wb\", compresslevel=compress_level)\n+\n+    def write(self, data):\n+        return self.gzipfile.write(data)\n+\n+    def close(self):\n+        self.gzipfile.close()\n+        self.file.close()\n+\n+\n+@implementer(PostProcessorPlugin)\n+class Bz2Plugin:\n+\n+    def __init__(self, file, feed_options):\n+        self.file = file\n+        self.feed_options = feed_options\n+        compress_level = self.feed_options.get(\"bz2_compresslevel\", 9)\n+        self.bz2file = BZ2File(filename=self.file, mode=\"wb\", compresslevel=compress_level)\n+\n+    def write(self, data):\n+        return self.bz2file.write(data)\n+\n+    def close(self):\n+        self.bz2file.close()\n+        self.file.close()\n+\n+\n+@implementer(PostProcessorPlugin)\n+class LZMAPlugin:\n+\n+    def __init__(self, file, feed_options):\n+        self.file = file\n+        self.feed_options = feed_options\n+\n+        format = self.feed_options.get(\"lzma_format\")\n+        check = self.feed_options.get(\"lzma_check\", -1)\n+        preset = self.feed_options.get(\"lzma_preset\")\n+        filters = self.feed_options.get(\"lzma_filter\")\n+        self.lzmafile = LZMAFile(filename=self.file, mode=\"wb\", format=format,\n+                                 check=check, preset=preset, filters=filters)\n+\n+    def write(self, data):\n+        return self.lzmafile.write(data)\n+\n+    def close(self):\n+        self.lzmafile.close()\n+        self.file.close()\n+\n+\n+class PostProcessingManager(IOBase):",
      "comment": "`CsvItemExporter` actually wrapped the storage with `io.TextIOWrapper`, and `io.TextIOWrapper` expects to have a file like object having at least the attributes and methods of `io.IOBase`. So there was some error when it only got an object with `write` and `close` methods. Subclassing `io.IOBase` fixed this in addition to declaring this object as writable with the help of `writable` method.",
      "comment_id": 659363721,
      "user": "drs-11",
      "created_at": "2021-06-27T19:10:37Z",
      "url": "https://github.com/scrapy/scrapy/pull/5190#discussion_r659363721"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 5190,
      "file_path": "scrapy/extensions/feedexport.py",
      "line": 358,
      "side": "RIGHT",
      "diff_hunk": "@@ -350,7 +351,12 @@ def _start_new_batch(self, batch_id, uri, feed_options, spider, uri_template):\n         :param uri_template: template of uri which contains %(batch_time)s or %(batch_id)d to create new uri\n         \"\"\"\n         storage = self._get_storage(uri, feed_options)\n-        file = storage.open(spider)\n+\n+        if \"postprocessing\" in feed_options:\n+            file = PostProcessingManager(feed_options[\"postprocessing\"], storage.open(spider), feed_options)\n+        else:\n+            file = storage.open(spider)",
      "comment": "- `file` definition could be simplified, and made slightly more readable.\r\n- Seeing it in action now, I see it probably makes sense to simplify the signature of `PostProcessingManager`.\r\n\r\n```suggestion\r\n        file = storage.open(spider)\r\n        if \"postprocessing\" in feed_options:\r\n            file = PostProcessingManager(file, feed_options)\r\n```",
      "comment_id": 659515130,
      "user": "Gallaecio",
      "created_at": "2021-06-28T06:37:36Z",
      "url": "https://github.com/scrapy/scrapy/pull/5190#discussion_r659515130"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 5190,
      "file_path": "scrapy/extensions/postprocessing.py",
      "line": 7,
      "side": "RIGHT",
      "diff_hunk": "@@ -1,7 +1,7 @@\n \"\"\"\n Extension for processing data before they are exported to feeds.\n \"\"\"\n-\n+from io import IOBase\n from bz2 import BZ2File\n from gzip import GzipFile\n from lzma import LZMAFile",
      "comment": "```suggestion\r\nfrom bz2 import BZ2File\r\nfrom gzip import GzipFile\r\nfrom io import IOBase\r\nfrom lzma import LZMAFile\r\n```",
      "comment_id": 659515349,
      "user": "Gallaecio",
      "created_at": "2021-06-28T06:38:00Z",
      "url": "https://github.com/scrapy/scrapy/pull/5190#discussion_r659515349"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 5190,
      "file_path": "scrapy/extensions/postprocessing.py",
      "line": 96,
      "side": "RIGHT",
      "diff_hunk": "@@ -0,0 +1,140 @@\n+\"\"\"\n+Extension for processing data before they are exported to feeds.\n+\"\"\"\n+from io import IOBase\n+from bz2 import BZ2File\n+from gzip import GzipFile\n+from lzma import LZMAFile\n+\n+from scrapy.utils.misc import load_object\n+from zope.interface import Interface, implementer\n+\n+\n+class PostProcessorPlugin(Interface):\n+    \"\"\"\n+    Interface for plugin which will be used by PostProcessingManager\n+    for pre-export data processing.\n+    \"\"\"\n+\n+    def __init__(self, file, feed_options):\n+        \"\"\"\n+        Initialize plugin with target file to which post-processed\n+        data will be written and the feed-specific options (see :setting:`FEEDS`).\n+        \"\"\"\n+\n+    def write(self, data):\n+        \"\"\"\n+        Write `data` to plugin's target file.\n+        :param data: data passed to be written to file\n+        :type data: bytes\n+        :return: returns number of bytes written\n+        :rtype: int\n+        \"\"\"\n+\n+    def close(self):\n+        \"\"\"\n+        Close this plugin.\n+        \"\"\"\n+\n+\n+@implementer(PostProcessorPlugin)\n+class GzipPlugin:\n+\n+    def __init__(self, file, feed_options):\n+        self.file = file\n+        self.feed_options = feed_options\n+        compress_level = self.feed_options.get(\"gzip_compresslevel\", 9)\n+        self.gzipfile = GzipFile(fileobj=self.file, mode=\"wb\", compresslevel=compress_level)\n+\n+    def write(self, data):\n+        return self.gzipfile.write(data)\n+\n+    def close(self):\n+        self.gzipfile.close()\n+        self.file.close()\n+\n+\n+@implementer(PostProcessorPlugin)\n+class Bz2Plugin:\n+\n+    def __init__(self, file, feed_options):\n+        self.file = file\n+        self.feed_options = feed_options\n+        compress_level = self.feed_options.get(\"bz2_compresslevel\", 9)\n+        self.bz2file = BZ2File(filename=self.file, mode=\"wb\", compresslevel=compress_level)\n+\n+    def write(self, data):\n+        return self.bz2file.write(data)\n+\n+    def close(self):\n+        self.bz2file.close()\n+        self.file.close()\n+\n+\n+@implementer(PostProcessorPlugin)\n+class LZMAPlugin:\n+\n+    def __init__(self, file, feed_options):\n+        self.file = file\n+        self.feed_options = feed_options\n+\n+        format = self.feed_options.get(\"lzma_format\")\n+        check = self.feed_options.get(\"lzma_check\", -1)\n+        preset = self.feed_options.get(\"lzma_preset\")\n+        filters = self.feed_options.get(\"lzma_filter\")\n+        self.lzmafile = LZMAFile(filename=self.file, mode=\"wb\", format=format,\n+                                 check=check, preset=preset, filters=filters)\n+\n+    def write(self, data):\n+        return self.lzmafile.write(data)\n+\n+    def close(self):\n+        self.lzmafile.close()\n+        self.file.close()\n+\n+\n+class PostProcessingManager(IOBase):",
      "comment": "Nice. I did not realize this change only needed to affect the manager and not the plugins. This is definitely the cleanest solution, great job!\r\n\r\nI would include, however, a comment above the class definition explaining why we inherit from `IOBase` here, for future reference. Indicate that it\u2019s so that exporters can treat the result of the post-processing as a file-like writable object, and you could mention the example of CsvItemExporter using TextIOWrapper.\r\n\r\nWe should also make sure, when updating the documentation, to also review the documentation of exporters and make sure that it is clearly stated what the API of the file-like object exporters get is: that of an open, writable, non-seekable IOBase object without a `fileno` property.",
      "comment_id": 659525702,
      "user": "Gallaecio",
      "created_at": "2021-06-28T06:57:39Z",
      "url": "https://github.com/scrapy/scrapy/pull/5190#discussion_r659525702"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 5190,
      "file_path": "tests/test_feedexport.py",
      "line": 1391,
      "side": "RIGHT",
      "diff_hunk": "@@ -1320,6 +1320,76 @@ def test_extend_kwargs(self):\n             data = yield self.exported_data(items, settings)\n             self.assertEqual(row['expected'], data[feed_options['format']])\n \n+    @defer.inlineCallbacks\n+    def test_postprocessed_exports(self):\n+        items = [\n+            {'foo': 'bar1', 'baz': ''},\n+            {'egg': 'bar2', 'baz': 'quux'},\n+        ]\n+\n+        import gzip\n+        import lzma\n+        import bz2\n+        format_to_decompressor = {\n+            'csv': gzip,\n+            'json': lzma,\n+            'jsonlines': bz2,\n+            'xml': gzip,\n+        }\n+\n+        format_to_expected = {\n+            'csv': b'foo,baz\\r\\nbar1,\\r\\n,quux\\r\\n',\n+            'json': b'[\\n{\"foo\": \"bar1\", \"baz\": \"\"},\\n{\"egg\": \"bar2\", \"baz\": \"quux\"}\\n]',\n+            'jsonlines': b'{\"foo\": \"bar1\", \"baz\": \"\"}\\n{\"egg\": \"bar2\", \"baz\": \"quux\"}\\n',\n+            'xml': b'XXXX<?xml version=\"1.0\" encoding=\"utf-8\"?>\\nXXXX<itemsXXXX>XXXX\\nX'\n+                   b'XXX<itemXXXX>XXXX<fooXXXX>XXXXbar1XXXX</foo>XXXX<bazXXXX>XXXX</baz'\n+                   b'>XXXX</item>XXXX\\nXXXX<itemXXXX>XXXX<eggXXXX>XXXXbar2XXXX</egg>XXX'\n+                   b'X<bazXXXX>XXXXquuxXXXX</baz>XXXX</item>XXXX\\nXXXX</items>',\n+        }\n+\n+        class MyPlugin1:\n+            def __init__(self, file, feed_options):\n+                self.file = file\n+                self.feed_options = feed_options\n+\n+            def write(self, data):\n+                return self.file.write(b\"XXXX\" + data)\n+\n+            def close(self):\n+                self.file.close()\n+\n+        settings = {\n+            'FEEDS': {\n+                self._random_temp_filename(): {\n+                    'format': 'csv',\n+                    'postprocessing': ['scrapy.extensions.postprocessing.GzipPlugin'],\n+                    'gzip_compresslevel': random.randint(1, 9),\n+                },\n+                self._random_temp_filename(): {\n+                    'format': 'json',\n+                    'postprocessing': ['scrapy.extensions.postprocessing.LZMAPlugin'],\n+                    'lzma_preset': random.randint(0, 9),\n+                    'lzma_check': random.choice([lzma.CHECK_CRC32, lzma.CHECK_CRC64,\n+                                                 lzma.CHECK_NONE, lzma.CHECK_SHA256]),\n+                },\n+                self._random_temp_filename(): {\n+                    'format': 'jsonlines',\n+                    'postprocessing': ['scrapy.extensions.postprocessing.Bz2Plugin'],\n+                    'bz2_compresslevel': random.randint(1, 9),\n+                },\n+                self._random_temp_filename(): {\n+                    'format': 'xml',\n+                    'postprocessing': [MyPlugin1, 'scrapy.extensions.postprocessing.GzipPlugin'],\n+                },\n+            }\n+        }\n+\n+        data = yield self.exported_data(items, settings)\n+\n+        for fmt, decompressor in format_to_decompressor.items():\n+            result = decompressor.decompress(data[fmt])\n+            self.assertEqual(format_to_expected[fmt], result)",
      "comment": "The test looks great overall. It should serve to make sure that all built-in compression plugins work.\r\n\r\nThey do not hurt, but I don\u2019t think the (random) extra parameters add much to the test. For example, if you set `gzip_compresslevel` to `4` in this test, but the plugin were not processing the parameter at all, the test would still pass. It may be better to remove extra plugin parameters from this test method.\r\n\r\nTo test plugin parameters, you need tests that would break if parameters were misinterpreted. You want to make sure that the parameters have an impact on the output. I think it would be enough to test that the output changes when passing a non-default value for a parameter. You don\u2019t need to test the underlying library (e.g. you don\u2019t need to test that Python\u2019s GZipFile makes files smaller with 9 than with 0), but you do need to test somehow that the plugin is passing the parameter (e.g. from feed options to GZipFile).\r\n\r\nYou also need to mind that some compressors may not be deterministic (e.g. [GZipFile seems to not be deterministic unless you set `mtime` to a fixed value](https://discuss.python.org/t/gzip-py-allow-deterministic-compression-without-time-stamp/8221)), so it may not always be enough to test that the output is different with a different value in a parameter. In these cases, you\u2019ll need to either make the output deterministic or check for something more. For example, with GZipFile, you can either expose the `mtime` option and use it in tests in combination with the options that you are actually testing, or you can test an option like compression level by verifying that the higher the compression the smaller the file.",
      "comment_id": 661589990,
      "user": "Gallaecio",
      "created_at": "2021-06-30T15:33:32Z",
      "url": "https://github.com/scrapy/scrapy/pull/5190#discussion_r661589990"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 5190,
      "file_path": "scrapy/extensions/postprocessing.py",
      "line": 13,
      "side": "RIGHT",
      "diff_hunk": "@@ -0,0 +1,151 @@\n+\"\"\"\n+Extension for processing data before they are exported to feeds.\n+\"\"\"\n+from bz2 import BZ2File\n+from gzip import GzipFile\n+from io import IOBase\n+from lzma import LZMAFile\n+from typing import Any, BinaryIO, Dict, List\n+\n+from scrapy.utils.misc import load_object\n+\n+\n+class GzipPlugin:",
      "comment": "Since all post-processing plugins have a common structure, how about declaring an interface (eg. `IPostProcessingPlugin`) with the `write` and `close` methods? ",
      "comment_id": 663646925,
      "user": "adityaa30",
      "created_at": "2021-07-05T05:29:17Z",
      "url": "https://github.com/scrapy/scrapy/pull/5190#discussion_r663646925"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 5190,
      "file_path": "scrapy/extensions/postprocessing.py",
      "line": 13,
      "side": "RIGHT",
      "diff_hunk": "@@ -0,0 +1,151 @@\n+\"\"\"\n+Extension for processing data before they are exported to feeds.\n+\"\"\"\n+from bz2 import BZ2File\n+from gzip import GzipFile\n+from io import IOBase\n+from lzma import LZMAFile\n+from typing import Any, BinaryIO, Dict, List\n+\n+from scrapy.utils.misc import load_object\n+\n+\n+class GzipPlugin:",
      "comment": "While there is 1 case in similar Scrapy code where we use an interface, in most similar cases we tend to instead document the interface, so the current approach I think is the one most in line with the current code base.\r\n\r\nIn Python, interfaces are seldom used, and I don\u2019t see much benefit for them being used here.",
      "comment_id": 663670282,
      "user": "Gallaecio",
      "created_at": "2021-07-05T06:32:08Z",
      "url": "https://github.com/scrapy/scrapy/pull/5190#discussion_r663670282"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 5190,
      "file_path": "scrapy/extensions/postprocessing.py",
      "line": 41,
      "side": "RIGHT",
      "diff_hunk": "@@ -22,14 +32,24 @@ def __init__(self, file: BinaryIO, feed_options: Dict[str, Any]) -> None:\n                                  mtime=mtime, filename=filename)\n \n     def write(self, data: bytes) -> int:\n+        \"\"\"Compress and write the `data` into the target file.\"\"\"\n         return self.gzipfile.write(data)\n \n     def close(self) -> None:\n+        \"\"\"Close target file.\"\"\"\n         self.gzipfile.close()\n         self.file.close()",
      "comment": "Since the purpose of the `write` and `close` methods of any plugin is described in the Custom Plugin section, there is no need to document them.\r\n\r\n```suggestion\r\n    def write(self, data: bytes) -> int:\r\n        return self.gzipfile.write(data)\r\n\r\n    def close(self) -> None:\r\n        self.gzipfile.close()\r\n        self.file.close()\r\n```\r\n\r\nIf after removing their documentation they still show up when using `autoclass`, use autoclass Sphinx options to hide these 2 methods in the documentation.",
      "comment_id": 663672111,
      "user": "Gallaecio",
      "created_at": "2021-07-05T06:35:38Z",
      "url": "https://github.com/scrapy/scrapy/pull/5190#discussion_r663672111"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 5190,
      "file_path": "scrapy/extensions/postprocessing.py",
      "line": 15,
      "side": "RIGHT",
      "diff_hunk": "@@ -11,6 +11,16 @@\n \n \n class GzipPlugin:\n+    \"\"\"\n+    Compresses received data with with :py:mod:`gzip` module.",
      "comment": "The plugins should be about compressing in a specific file format.\r\n\r\n```suggestion\r\n    Compresses received data using `gzip <https://en.wikipedia.org/wiki/Gzip>`_.\r\n```\r\n\r\nThe use of a Python module from the standard library is an implementation detail, and should not be covered in the documentation. Even if we link to the Python documentation about parameters, we could technically reimplement the plugin in the future without relying on the standard library module, while supporting the same option names and values (hence it being OK to link to that documentation for option reference).\r\n",
      "comment_id": 663675054,
      "user": "Gallaecio",
      "created_at": "2021-07-05T06:42:14Z",
      "url": "https://github.com/scrapy/scrapy/pull/5190#discussion_r663675054"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 5190,
      "file_path": "tests/test_feedexport.py",
      "line": 1332,
      "side": "RIGHT",
      "diff_hunk": "@@ -1320,96 +1323,271 @@ def test_extend_kwargs(self):\n             data = yield self.exported_data(items, settings)\n             self.assertEqual(row['expected'], data[feed_options['format']])\n \n+\n+class FeedPostProcessedExportsTest(FeedExportTestBase):\n+    __test__ = True\n+    items = [\n+        {'foo': 'bar1', 'baz': ''},\n+        {'egg': 'bar2', 'baz': 'quux'},\n+    ]",
      "comment": "I don\u2019t _think_ multiple items and multiple fields can affect post-processing. So, to keep things minimal, maybe it would make sense to keep a single item with a single field.",
      "comment_id": 663676587,
      "user": "Gallaecio",
      "created_at": "2021-07-05T06:45:27Z",
      "url": "https://github.com/scrapy/scrapy/pull/5190#discussion_r663676587"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 5190,
      "file_path": "tests/test_feedexport.py",
      "line": 1382,
      "side": "RIGHT",
      "diff_hunk": "@@ -1320,96 +1323,271 @@ def test_extend_kwargs(self):\n             data = yield self.exported_data(items, settings)\n             self.assertEqual(row['expected'], data[feed_options['format']])\n \n+\n+class FeedPostProcessedExportsTest(FeedExportTestBase):\n+    __test__ = True\n+    items = [\n+        {'foo': 'bar1', 'baz': ''},\n+        {'egg': 'bar2', 'baz': 'quux'},\n+    ]\n+    format_to_expected = {\n+        'csv': b'foo,baz\\r\\nbar1,\\r\\n,quux\\r\\n',\n+        'jsonlines': b'{\"foo\": \"bar1\", \"baz\": \"\"}\\n{\"egg\": \"bar2\", \"baz\": \"quux\"}\\n',\n+        'xml': b'<?xml version=\"1.0\" encoding=\"utf-8\"?>\\n<items>\\n<item><foo>bar1</foo>'\n+               b'<baz></baz></item>\\n<item><egg>bar2</egg><baz>quux</baz></item>\\n</items>',\n+    }\n+\n     @defer.inlineCallbacks\n-    def test_postprocessed_exports(self):\n-        items = [\n-            {'foo': 'bar1', 'baz': ''},\n-            {'egg': 'bar2', 'baz': 'quux'},\n-        ]\n+    def run_and_export(self, spider_cls, settings):\n+        \"\"\" Run spider with specified settings; return exported data. \"\"\"\n \n-        import gzip\n-        import lzma\n-        import bz2\n-        format_to_decompressor = {\n-            'csv': gzip,\n-            'json': lzma,\n-            'jsonlines': bz2,\n-            'xml': gzip,\n+        FEEDS = settings.get('FEEDS') or {}\n+        settings['FEEDS'] = {\n+            printf_escape(path_to_url(file_path)): feed_options\n+            for file_path, feed_options in FEEDS.items()\n         }\n \n-        format_to_expected = {\n-            'csv': b'foo,baz\\r\\nbar1,\\r\\n,quux\\r\\n',\n-            'json': b'[\\n{\"foo\": \"bar1\", \"baz\": \"\"},\\n{\"egg\": \"bar2\", \"baz\": \"quux\"}\\n]',\n-            'jsonlines': b'{\"foo\": \"bar1\", \"baz\": \"\"}\\n{\"egg\": \"bar2\", \"baz\": \"quux\"}\\n',\n-            'xml': b'XXXX<?xml version=\"1.0\" encoding=\"utf-8\"?>\\nXXXX<itemsXXXX>XXXX\\nX'\n-                   b'XXX<itemXXXX>XXXX<fooXXXX>XXXXbar1XXXX</foo>XXXX<bazXXXX>XXXX</baz'\n-                   b'>XXXX</item>XXXX\\nXXXX<itemXXXX>XXXX<eggXXXX>XXXXbar2XXXX</egg>XXX'\n-                   b'X<bazXXXX>XXXXquuxXXXX</baz>XXXX</item>XXXX\\nXXXX</items>',\n+        content = {}\n+        try:\n+            with MockServer() as s:\n+                runner = CrawlerRunner(Settings(settings))\n+                spider_cls.start_urls = [s.url('/')]\n+                yield runner.crawl(spider_cls)\n+\n+            for file_path, feed_options in FEEDS.items():\n+                if not os.path.exists(str(file_path)):\n+                    continue\n+\n+                with open(str(file_path), 'rb') as f:\n+                    content[feed_options['format']] = f.read()\n+\n+        finally:\n+            for file_path in FEEDS.keys():\n+                if not os.path.exists(str(file_path)):\n+                    continue\n+\n+                os.remove(str(file_path))\n+\n+        return content\n+\n+    def get_gzip_compressed(self, data, compresslevel):\n+        data_stream = BytesIO()\n+        gzipf = gzip.GzipFile(fileobj=data_stream, filename=\"\", mtime=0, compresslevel=compresslevel, mode=\"wb\")\n+        gzipf.write(data)\n+        gzipf.close()\n+        data_stream.seek(0)\n+        return data_stream.read()\n+\n+    @defer.inlineCallbacks\n+    def test_gzip_plugin(self):",
      "comment": "Instead of a single method per plugin, you could have several methods, each to test different aspects:\r\n- Enabling the plugin results in gzip-compressed output\r\n- A non-default value for a plugin option has the expected effect (1 test method per option)\r\n\r\nI see no reason to test different output formats (i.e. csv, jsonlines, xml). Plugins should work the same with any, so to make things minimal you could use a single one.\r\n\r\nWhat we should have is tests that verify that each of the Scrapy export plugins (for csv, jsonlines, etc.) work with the file-like interface of the plugin manager. In other words, tests that would have failed if the plugin manager was not inheriting from IOBase.",
      "comment_id": 663681169,
      "user": "Gallaecio",
      "created_at": "2021-07-05T06:54:42Z",
      "url": "https://github.com/scrapy/scrapy/pull/5190#discussion_r663681169"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 5190,
      "file_path": "tests/test_feedexport.py",
      "line": 1700,
      "side": "RIGHT",
      "diff_hunk": "@@ -1321,6 +1324,420 @@ def test_extend_kwargs(self):\n             self.assertEqual(row['expected'], data[feed_options['format']])\n \n \n+class FeedPostProcessedExportsTest(FeedExportTestBase):\n+    __test__ = True\n+\n+    items = [{'foo': 'bar'}]\n+    expected = b'foo\\r\\nbar\\r\\n'\n+\n+    class MyPlugin1:\n+        def __init__(self, file, feed_options):\n+            self.file = file\n+            self.feed_options = feed_options\n+            self.char = self.feed_options.get('plugin1_char', b'')\n+\n+        def write(self, data):\n+            return self.file.write(data + self.char)\n+\n+        def close(self):\n+            self.file.close()\n+\n+    def _named_tempfile(self, name):\n+        return os.path.join(self.temp_dir, name)\n+\n+    @defer.inlineCallbacks\n+    def run_and_export(self, spider_cls, settings):\n+        \"\"\" Run spider with specified settings; return exported data with filename. \"\"\"\n+\n+        FEEDS = settings.get('FEEDS') or {}\n+        settings['FEEDS'] = {\n+            printf_escape(path_to_url(file_path)): feed_options\n+            for file_path, feed_options in FEEDS.items()\n+        }\n+\n+        content = {}\n+        try:\n+            with MockServer() as s:\n+                runner = CrawlerRunner(Settings(settings))\n+                spider_cls.start_urls = [s.url('/')]\n+                yield runner.crawl(spider_cls)\n+\n+            for file_path, feed_options in FEEDS.items():\n+                if not os.path.exists(str(file_path)):\n+                    continue\n+\n+                with open(str(file_path), 'rb') as f:\n+                    content[str(file_path)] = f.read()\n+\n+        finally:\n+            for file_path in FEEDS.keys():\n+                if not os.path.exists(str(file_path)):\n+                    continue\n+\n+                os.remove(str(file_path))\n+\n+        return content\n+\n+    def get_gzip_compressed(self, data, compresslevel=9, mtime=0, filename=''):\n+        data_stream = BytesIO()\n+        gzipf = gzip.GzipFile(fileobj=data_stream, filename=filename, mtime=mtime,\n+                              compresslevel=compresslevel, mode=\"wb\")\n+        gzipf.write(data)\n+        gzipf.close()\n+        data_stream.seek(0)\n+        return data_stream.read()\n+\n+    @defer.inlineCallbacks\n+    def test_gzip_plugin_compresslevel(self):\n+\n+        filename_to_compressed = {\n+            self._named_tempfile('compresslevel_0'): self.get_gzip_compressed(self.expected, compresslevel=0),\n+            self._named_tempfile('compresslevel_9'): self.get_gzip_compressed(self.expected, compresslevel=9),\n+        }\n+\n+        settings = {\n+            'FEEDS': {\n+                self._named_tempfile('compresslevel_0'): {\n+                    'format': 'csv',\n+                    'postprocessing': ['scrapy.extensions.postprocessing.GzipPlugin'],\n+                    'gzip_compresslevel': 0,\n+                    'gzip_mtime': 0,\n+                    'gzip_filename': \"\",\n+                },\n+                self._named_tempfile('compresslevel_9'): {\n+                    'format': 'csv',\n+                    'postprocessing': ['scrapy.extensions.postprocessing.GzipPlugin'],\n+                    'gzip_compresslevel': 9,\n+                    'gzip_mtime': 0,\n+                    'gzip_filename': \"\",\n+                },\n+            },\n+        }\n+\n+        data = yield self.exported_data(self.items, settings)\n+\n+        for filename, compressed in filename_to_compressed.items():\n+            result = gzip.decompress(data[filename])\n+            self.assertEqual(compressed, data[filename])\n+            self.assertEqual(self.expected, result)\n+\n+    @defer.inlineCallbacks\n+    def test_gzip_plugin_mtime(self):\n+        filename_to_compressed = {\n+            self._named_tempfile('mtime_123'): self.get_gzip_compressed(self.expected, mtime=123),\n+            self._named_tempfile('mtime_123456789'): self.get_gzip_compressed(self.expected, mtime=123456789),\n+        }\n+\n+        settings = {\n+            'FEEDS': {\n+                self._named_tempfile('mtime_123'): {\n+                    'format': 'csv',\n+                    'postprocessing': ['scrapy.extensions.postprocessing.GzipPlugin'],\n+                    'gzip_mtime': 123,\n+                    'gzip_filename': \"\",\n+                },\n+                self._named_tempfile('mtime_123456789'): {\n+                    'format': 'csv',\n+                    'postprocessing': ['scrapy.extensions.postprocessing.GzipPlugin'],\n+                    'gzip_mtime': 123456789,\n+                    'gzip_filename': \"\",\n+                },\n+            },\n+        }\n+\n+        data = yield self.exported_data(self.items, settings)\n+\n+        for filename, compressed in filename_to_compressed.items():\n+            result = gzip.decompress(data[filename])\n+            self.assertEqual(compressed, data[filename])\n+            self.assertEqual(self.expected, result)\n+\n+    @defer.inlineCallbacks\n+    def test_gzip_plugin_filename(self):\n+        filename_to_compressed = {\n+            self._named_tempfile('filename_FILE1'): self.get_gzip_compressed(self.expected, filename=\"FILE1\"),\n+            self._named_tempfile('filename_FILE2'): self.get_gzip_compressed(self.expected, filename=\"FILE2\"),\n+        }\n+\n+        settings = {\n+            'FEEDS': {\n+                self._named_tempfile('filename_FILE1'): {\n+                    'format': 'csv',\n+                    'postprocessing': ['scrapy.extensions.postprocessing.GzipPlugin'],\n+                    'gzip_mtime': 0,\n+                    'gzip_filename': \"FILE1\",\n+                },\n+                self._named_tempfile('filename_FILE2'): {\n+                    'format': 'csv',\n+                    'postprocessing': ['scrapy.extensions.postprocessing.GzipPlugin'],\n+                    'gzip_mtime': 0,\n+                    'gzip_filename': \"FILE2\",\n+                },\n+            },\n+        }\n+\n+        data = yield self.exported_data(self.items, settings)\n+\n+        for filename, compressed in filename_to_compressed.items():\n+            result = gzip.decompress(data[filename])\n+            self.assertEqual(compressed, data[filename])\n+            self.assertEqual(self.expected, result)\n+\n+    @defer.inlineCallbacks\n+    def test_lzma_plugin_format(self):\n+\n+        filename_to_compressed = {\n+            self._named_tempfile('format_FORMAT_XZ'): lzma.compress(self.expected, format=lzma.FORMAT_XZ),\n+            self._named_tempfile('format_FORMAT_ALONE'): lzma.compress(self.expected, format=lzma.FORMAT_ALONE),\n+        }\n+\n+        settings = {\n+            'FEEDS': {\n+                self._named_tempfile('format_FORMAT_XZ'): {\n+                    'format': 'csv',\n+                    'postprocessing': ['scrapy.extensions.postprocessing.LZMAPlugin'],\n+                    'lzma_format': lzma.FORMAT_XZ,\n+                },\n+                self._named_tempfile('format_FORMAT_ALONE'): {\n+                    'format': 'csv',\n+                    'postprocessing': ['scrapy.extensions.postprocessing.LZMAPlugin'],\n+                    'lzma_format': lzma.FORMAT_ALONE,\n+                },\n+            },\n+        }\n+\n+        data = yield self.exported_data(self.items, settings)\n+\n+        for filename, compressed in filename_to_compressed.items():\n+            result = lzma.decompress(data[filename])\n+            self.assertEqual(compressed, data[filename])\n+            self.assertEqual(self.expected, result)\n+\n+    @defer.inlineCallbacks\n+    def test_lzma_plugin_check(self):\n+\n+        filename_to_compressed = {\n+            self._named_tempfile('check_CHECK_NONE'): lzma.compress(self.expected, check=lzma.CHECK_NONE),\n+            self._named_tempfile('check_CHECK_CRC256'): lzma.compress(self.expected, check=lzma.CHECK_SHA256),\n+        }\n+\n+        settings = {\n+            'FEEDS': {\n+                self._named_tempfile('check_CHECK_NONE'): {\n+                    'format': 'csv',\n+                    'postprocessing': ['scrapy.extensions.postprocessing.LZMAPlugin'],\n+                    'lzma_check': lzma.CHECK_NONE,\n+                },\n+                self._named_tempfile('check_CHECK_CRC256'): {\n+                    'format': 'csv',\n+                    'postprocessing': ['scrapy.extensions.postprocessing.LZMAPlugin'],\n+                    'lzma_check': lzma.CHECK_SHA256,\n+                },\n+            },\n+        }\n+\n+        data = yield self.exported_data(self.items, settings)\n+\n+        for filename, compressed in filename_to_compressed.items():\n+            result = lzma.decompress(data[filename])\n+            self.assertEqual(compressed, data[filename])\n+            self.assertEqual(self.expected, result)\n+\n+    @defer.inlineCallbacks\n+    def test_lzma_plugin_preset(self):\n+\n+        filename_to_compressed = {\n+            self._named_tempfile('preset_PRESET_0'): lzma.compress(self.expected, preset=0),\n+            self._named_tempfile('preset_PRESET_9'): lzma.compress(self.expected, preset=9),\n+        }\n+\n+        settings = {\n+            'FEEDS': {\n+                self._named_tempfile('preset_PRESET_0'): {\n+                    'format': 'csv',\n+                    'postprocessing': ['scrapy.extensions.postprocessing.LZMAPlugin'],\n+                    'lzma_preset': 0,\n+                },\n+                self._named_tempfile('preset_PRESET_9'): {\n+                    'format': 'csv',\n+                    'postprocessing': ['scrapy.extensions.postprocessing.LZMAPlugin'],\n+                    'lzma_preset': 9,\n+                },\n+            },\n+        }\n+\n+        data = yield self.exported_data(self.items, settings)\n+\n+        for filename, compressed in filename_to_compressed.items():\n+            result = lzma.decompress(data[filename])\n+            self.assertEqual(compressed, data[filename])\n+            self.assertEqual(self.expected, result)\n+\n+    @defer.inlineCallbacks\n+    def test_lzma_plugin_filters(self):\n+        filters = [{'id': lzma.FILTER_LZMA2}]\n+        compressed = lzma.compress(self.expected, filters=filters)\n+        filename = self._named_tempfile('filters')\n+\n+        settings = {\n+            'FEEDS': {\n+                filename: {\n+                    'format': 'csv',\n+                    'postprocessing': ['scrapy.extensions.postprocessing.LZMAPlugin'],\n+                    'lzma_filters': filters,\n+                },\n+            },\n+        }\n+\n+        data = yield self.exported_data(self.items, settings)\n+        self.assertEqual(compressed, data[filename])\n+        result = lzma.decompress(data[filename])\n+        self.assertEqual(self.expected, result)\n+\n+    @defer.inlineCallbacks\n+    def test_bz2_plugin_compresslevel(self):\n+\n+        filename_to_compressed = {\n+            self._named_tempfile('compresslevel_1'): bz2.compress(self.expected, compresslevel=1),\n+            self._named_tempfile('compresslevel_9'): bz2.compress(self.expected, compresslevel=9),\n+        }\n+\n+        settings = {\n+            'FEEDS': {\n+                self._named_tempfile('compresslevel_1'): {\n+                    'format': 'csv',\n+                    'postprocessing': ['scrapy.extensions.postprocessing.Bz2Plugin'],\n+                    'bz2_compresslevel': 1,\n+                },\n+                self._named_tempfile('compresslevel_9'): {\n+                    'format': 'csv',\n+                    'postprocessing': ['scrapy.extensions.postprocessing.Bz2Plugin'],\n+                    'bz2_compresslevel': 9,\n+                },\n+            },\n+        }\n+\n+        data = yield self.exported_data(self.items, settings)\n+\n+        for filename, compressed in filename_to_compressed.items():\n+            result = bz2.decompress(data[filename])\n+            self.assertEqual(compressed, data[filename])\n+            self.assertEqual(self.expected, result)\n+\n+    @defer.inlineCallbacks\n+    def test_custom_plugin(self):\n+\n+        filename_to_processed = {\n+            self._named_tempfile('newline'): b'foo\\r\\n\\nbar\\r\\n\\n',\n+            self._named_tempfile('tab'): b'foo\\r\\n\\tbar\\r\\n\\t',\n+        }\n+\n+        settings = {\n+            'FEEDS': {\n+                self._named_tempfile('newline'): {\n+                    'format': 'csv',\n+                    'postprocessing': [self.MyPlugin1],\n+                    'plugin1_char': b'\\n'\n+                },\n+                self._named_tempfile('tab'): {\n+                    'format': 'csv',\n+                    'postprocessing': [self.MyPlugin1],\n+                    'plugin1_char': b'\\t',\n+                },\n+            },\n+        }\n+\n+        data = yield self.exported_data(self.items, settings)\n+\n+        for filename, expected in filename_to_processed.items():\n+            self.assertEqual(expected, data[filename])\n+\n+    @defer.inlineCallbacks\n+    def test_custom_plugin_with_compression(self):\n+\n+        expected = b'foo\\r\\n\\nbar\\r\\n\\n'\n+\n+        filename_to_decompressor = {\n+            self._named_tempfile('bz2'): bz2.decompress,\n+            self._named_tempfile('lzma'): lzma.decompress,\n+            self._named_tempfile('gzip'): gzip.decompress,\n+        }\n+\n+        settings = {\n+            'FEEDS': {\n+                self._named_tempfile('bz2'): {\n+                    'format': 'csv',\n+                    'postprocessing': [self.MyPlugin1, 'scrapy.extensions.postprocessing.Bz2Plugin'],\n+                    'plugin1_char': b'\\n',\n+                },\n+                self._named_tempfile('lzma'): {\n+                    'format': 'csv',\n+                    'postprocessing': [self.MyPlugin1, 'scrapy.extensions.postprocessing.LZMAPlugin'],\n+                    'plugin1_char': b'\\n',\n+                },\n+                self._named_tempfile('gzip'): {\n+                    'format': 'csv',\n+                    'postprocessing': [self.MyPlugin1, 'scrapy.extensions.postprocessing.GzipPlugin'],\n+                    'plugin1_char': b'\\n',\n+                },\n+            },\n+        }\n+\n+        data = yield self.exported_data(self.items, settings)\n+\n+        for filename, decompressor in filename_to_decompressor.items():\n+            result = decompressor(data[filename])\n+            self.assertEqual(expected, result)\n+\n+    @defer.inlineCallbacks\n+    def test_exports_compatibility_with_postproc(self):\n+\n+        format_to_expected = {\n+            'csv': b'foo\\r\\nbar\\r\\n',\n+            'json': b'[\\n{\"foo\": \"bar\"}\\n]',\n+            'jsonlines': b'{\"foo\": \"bar\"}\\n',\n+            'xml': b'<?xml version=\"1.0\" encoding=\"utf-8\"?>\\n<items>\\n<item><foo>bar</foo></item>\\n</items>',\n+            'marshal': b'{\\xda\\x03foo\\xda\\x03bar0',",
      "comment": "Even `marshal.dumps` is not giving consistent data. I'll look into this.",
      "comment_id": 666111067,
      "user": "drs-11",
      "created_at": "2021-07-08T11:34:17Z",
      "url": "https://github.com/scrapy/scrapy/pull/5190#discussion_r666111067"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 5190,
      "file_path": "tests/test_feedexport.py",
      "line": 1391,
      "side": "RIGHT",
      "diff_hunk": "@@ -1370,79 +1378,158 @@ def run_and_export(self, spider_cls, settings):\n \n         return content\n \n-    def get_gzip_compressed(self, data, compresslevel):\n+    def get_gzip_compressed(self, data, compresslevel=9, mtime=0, filename=''):\n         data_stream = BytesIO()\n-        gzipf = gzip.GzipFile(fileobj=data_stream, filename=\"\", mtime=0, compresslevel=compresslevel, mode=\"wb\")\n+        gzipf = gzip.GzipFile(fileobj=data_stream, filename=filename, mtime=mtime,\n+                              compresslevel=compresslevel, mode=\"wb\")\n         gzipf.write(data)\n         gzipf.close()\n         data_stream.seek(0)\n         return data_stream.read()\n \n     @defer.inlineCallbacks\n-    def test_gzip_plugin(self):\n+    def test_gzip_plugin_compresslevel(self):",
      "comment": "You replaced the existing test function with parameter-specific functions. As a result, now there\u2019s one scenario not being tested: when no parameter is passed.\r\n\r\nCould you add an additional test function that verifies that passing no parameters also generates a valid ZIP? For this test you would not need to compare the result to anything, just verify that it can be decompressed.\r\n\r\nThe same applies to the other plugins.",
      "comment_id": 666212237,
      "user": "Gallaecio",
      "created_at": "2021-07-08T13:51:00Z",
      "url": "https://github.com/scrapy/scrapy/pull/5190#discussion_r666212237"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 5190,
      "file_path": "tests/test_feedexport.py",
      "line": 1700,
      "side": "RIGHT",
      "diff_hunk": "@@ -1321,6 +1324,420 @@ def test_extend_kwargs(self):\n             self.assertEqual(row['expected'], data[feed_options['format']])\n \n \n+class FeedPostProcessedExportsTest(FeedExportTestBase):\n+    __test__ = True\n+\n+    items = [{'foo': 'bar'}]\n+    expected = b'foo\\r\\nbar\\r\\n'\n+\n+    class MyPlugin1:\n+        def __init__(self, file, feed_options):\n+            self.file = file\n+            self.feed_options = feed_options\n+            self.char = self.feed_options.get('plugin1_char', b'')\n+\n+        def write(self, data):\n+            return self.file.write(data + self.char)\n+\n+        def close(self):\n+            self.file.close()\n+\n+    def _named_tempfile(self, name):\n+        return os.path.join(self.temp_dir, name)\n+\n+    @defer.inlineCallbacks\n+    def run_and_export(self, spider_cls, settings):\n+        \"\"\" Run spider with specified settings; return exported data with filename. \"\"\"\n+\n+        FEEDS = settings.get('FEEDS') or {}\n+        settings['FEEDS'] = {\n+            printf_escape(path_to_url(file_path)): feed_options\n+            for file_path, feed_options in FEEDS.items()\n+        }\n+\n+        content = {}\n+        try:\n+            with MockServer() as s:\n+                runner = CrawlerRunner(Settings(settings))\n+                spider_cls.start_urls = [s.url('/')]\n+                yield runner.crawl(spider_cls)\n+\n+            for file_path, feed_options in FEEDS.items():\n+                if not os.path.exists(str(file_path)):\n+                    continue\n+\n+                with open(str(file_path), 'rb') as f:\n+                    content[str(file_path)] = f.read()\n+\n+        finally:\n+            for file_path in FEEDS.keys():\n+                if not os.path.exists(str(file_path)):\n+                    continue\n+\n+                os.remove(str(file_path))\n+\n+        return content\n+\n+    def get_gzip_compressed(self, data, compresslevel=9, mtime=0, filename=''):\n+        data_stream = BytesIO()\n+        gzipf = gzip.GzipFile(fileobj=data_stream, filename=filename, mtime=mtime,\n+                              compresslevel=compresslevel, mode=\"wb\")\n+        gzipf.write(data)\n+        gzipf.close()\n+        data_stream.seek(0)\n+        return data_stream.read()\n+\n+    @defer.inlineCallbacks\n+    def test_gzip_plugin_compresslevel(self):\n+\n+        filename_to_compressed = {\n+            self._named_tempfile('compresslevel_0'): self.get_gzip_compressed(self.expected, compresslevel=0),\n+            self._named_tempfile('compresslevel_9'): self.get_gzip_compressed(self.expected, compresslevel=9),\n+        }\n+\n+        settings = {\n+            'FEEDS': {\n+                self._named_tempfile('compresslevel_0'): {\n+                    'format': 'csv',\n+                    'postprocessing': ['scrapy.extensions.postprocessing.GzipPlugin'],\n+                    'gzip_compresslevel': 0,\n+                    'gzip_mtime': 0,\n+                    'gzip_filename': \"\",\n+                },\n+                self._named_tempfile('compresslevel_9'): {\n+                    'format': 'csv',\n+                    'postprocessing': ['scrapy.extensions.postprocessing.GzipPlugin'],\n+                    'gzip_compresslevel': 9,\n+                    'gzip_mtime': 0,\n+                    'gzip_filename': \"\",\n+                },\n+            },\n+        }\n+\n+        data = yield self.exported_data(self.items, settings)\n+\n+        for filename, compressed in filename_to_compressed.items():\n+            result = gzip.decompress(data[filename])\n+            self.assertEqual(compressed, data[filename])\n+            self.assertEqual(self.expected, result)\n+\n+    @defer.inlineCallbacks\n+    def test_gzip_plugin_mtime(self):\n+        filename_to_compressed = {\n+            self._named_tempfile('mtime_123'): self.get_gzip_compressed(self.expected, mtime=123),\n+            self._named_tempfile('mtime_123456789'): self.get_gzip_compressed(self.expected, mtime=123456789),\n+        }\n+\n+        settings = {\n+            'FEEDS': {\n+                self._named_tempfile('mtime_123'): {\n+                    'format': 'csv',\n+                    'postprocessing': ['scrapy.extensions.postprocessing.GzipPlugin'],\n+                    'gzip_mtime': 123,\n+                    'gzip_filename': \"\",\n+                },\n+                self._named_tempfile('mtime_123456789'): {\n+                    'format': 'csv',\n+                    'postprocessing': ['scrapy.extensions.postprocessing.GzipPlugin'],\n+                    'gzip_mtime': 123456789,\n+                    'gzip_filename': \"\",\n+                },\n+            },\n+        }\n+\n+        data = yield self.exported_data(self.items, settings)\n+\n+        for filename, compressed in filename_to_compressed.items():\n+            result = gzip.decompress(data[filename])\n+            self.assertEqual(compressed, data[filename])\n+            self.assertEqual(self.expected, result)\n+\n+    @defer.inlineCallbacks\n+    def test_gzip_plugin_filename(self):\n+        filename_to_compressed = {\n+            self._named_tempfile('filename_FILE1'): self.get_gzip_compressed(self.expected, filename=\"FILE1\"),\n+            self._named_tempfile('filename_FILE2'): self.get_gzip_compressed(self.expected, filename=\"FILE2\"),\n+        }\n+\n+        settings = {\n+            'FEEDS': {\n+                self._named_tempfile('filename_FILE1'): {\n+                    'format': 'csv',\n+                    'postprocessing': ['scrapy.extensions.postprocessing.GzipPlugin'],\n+                    'gzip_mtime': 0,\n+                    'gzip_filename': \"FILE1\",\n+                },\n+                self._named_tempfile('filename_FILE2'): {\n+                    'format': 'csv',\n+                    'postprocessing': ['scrapy.extensions.postprocessing.GzipPlugin'],\n+                    'gzip_mtime': 0,\n+                    'gzip_filename': \"FILE2\",\n+                },\n+            },\n+        }\n+\n+        data = yield self.exported_data(self.items, settings)\n+\n+        for filename, compressed in filename_to_compressed.items():\n+            result = gzip.decompress(data[filename])\n+            self.assertEqual(compressed, data[filename])\n+            self.assertEqual(self.expected, result)\n+\n+    @defer.inlineCallbacks\n+    def test_lzma_plugin_format(self):\n+\n+        filename_to_compressed = {\n+            self._named_tempfile('format_FORMAT_XZ'): lzma.compress(self.expected, format=lzma.FORMAT_XZ),\n+            self._named_tempfile('format_FORMAT_ALONE'): lzma.compress(self.expected, format=lzma.FORMAT_ALONE),\n+        }\n+\n+        settings = {\n+            'FEEDS': {\n+                self._named_tempfile('format_FORMAT_XZ'): {\n+                    'format': 'csv',\n+                    'postprocessing': ['scrapy.extensions.postprocessing.LZMAPlugin'],\n+                    'lzma_format': lzma.FORMAT_XZ,\n+                },\n+                self._named_tempfile('format_FORMAT_ALONE'): {\n+                    'format': 'csv',\n+                    'postprocessing': ['scrapy.extensions.postprocessing.LZMAPlugin'],\n+                    'lzma_format': lzma.FORMAT_ALONE,\n+                },\n+            },\n+        }\n+\n+        data = yield self.exported_data(self.items, settings)\n+\n+        for filename, compressed in filename_to_compressed.items():\n+            result = lzma.decompress(data[filename])\n+            self.assertEqual(compressed, data[filename])\n+            self.assertEqual(self.expected, result)\n+\n+    @defer.inlineCallbacks\n+    def test_lzma_plugin_check(self):\n+\n+        filename_to_compressed = {\n+            self._named_tempfile('check_CHECK_NONE'): lzma.compress(self.expected, check=lzma.CHECK_NONE),\n+            self._named_tempfile('check_CHECK_CRC256'): lzma.compress(self.expected, check=lzma.CHECK_SHA256),\n+        }\n+\n+        settings = {\n+            'FEEDS': {\n+                self._named_tempfile('check_CHECK_NONE'): {\n+                    'format': 'csv',\n+                    'postprocessing': ['scrapy.extensions.postprocessing.LZMAPlugin'],\n+                    'lzma_check': lzma.CHECK_NONE,\n+                },\n+                self._named_tempfile('check_CHECK_CRC256'): {\n+                    'format': 'csv',\n+                    'postprocessing': ['scrapy.extensions.postprocessing.LZMAPlugin'],\n+                    'lzma_check': lzma.CHECK_SHA256,\n+                },\n+            },\n+        }\n+\n+        data = yield self.exported_data(self.items, settings)\n+\n+        for filename, compressed in filename_to_compressed.items():\n+            result = lzma.decompress(data[filename])\n+            self.assertEqual(compressed, data[filename])\n+            self.assertEqual(self.expected, result)\n+\n+    @defer.inlineCallbacks\n+    def test_lzma_plugin_preset(self):\n+\n+        filename_to_compressed = {\n+            self._named_tempfile('preset_PRESET_0'): lzma.compress(self.expected, preset=0),\n+            self._named_tempfile('preset_PRESET_9'): lzma.compress(self.expected, preset=9),\n+        }\n+\n+        settings = {\n+            'FEEDS': {\n+                self._named_tempfile('preset_PRESET_0'): {\n+                    'format': 'csv',\n+                    'postprocessing': ['scrapy.extensions.postprocessing.LZMAPlugin'],\n+                    'lzma_preset': 0,\n+                },\n+                self._named_tempfile('preset_PRESET_9'): {\n+                    'format': 'csv',\n+                    'postprocessing': ['scrapy.extensions.postprocessing.LZMAPlugin'],\n+                    'lzma_preset': 9,\n+                },\n+            },\n+        }\n+\n+        data = yield self.exported_data(self.items, settings)\n+\n+        for filename, compressed in filename_to_compressed.items():\n+            result = lzma.decompress(data[filename])\n+            self.assertEqual(compressed, data[filename])\n+            self.assertEqual(self.expected, result)\n+\n+    @defer.inlineCallbacks\n+    def test_lzma_plugin_filters(self):\n+        filters = [{'id': lzma.FILTER_LZMA2}]\n+        compressed = lzma.compress(self.expected, filters=filters)\n+        filename = self._named_tempfile('filters')\n+\n+        settings = {\n+            'FEEDS': {\n+                filename: {\n+                    'format': 'csv',\n+                    'postprocessing': ['scrapy.extensions.postprocessing.LZMAPlugin'],\n+                    'lzma_filters': filters,\n+                },\n+            },\n+        }\n+\n+        data = yield self.exported_data(self.items, settings)\n+        self.assertEqual(compressed, data[filename])\n+        result = lzma.decompress(data[filename])\n+        self.assertEqual(self.expected, result)\n+\n+    @defer.inlineCallbacks\n+    def test_bz2_plugin_compresslevel(self):\n+\n+        filename_to_compressed = {\n+            self._named_tempfile('compresslevel_1'): bz2.compress(self.expected, compresslevel=1),\n+            self._named_tempfile('compresslevel_9'): bz2.compress(self.expected, compresslevel=9),\n+        }\n+\n+        settings = {\n+            'FEEDS': {\n+                self._named_tempfile('compresslevel_1'): {\n+                    'format': 'csv',\n+                    'postprocessing': ['scrapy.extensions.postprocessing.Bz2Plugin'],\n+                    'bz2_compresslevel': 1,\n+                },\n+                self._named_tempfile('compresslevel_9'): {\n+                    'format': 'csv',\n+                    'postprocessing': ['scrapy.extensions.postprocessing.Bz2Plugin'],\n+                    'bz2_compresslevel': 9,\n+                },\n+            },\n+        }\n+\n+        data = yield self.exported_data(self.items, settings)\n+\n+        for filename, compressed in filename_to_compressed.items():\n+            result = bz2.decompress(data[filename])\n+            self.assertEqual(compressed, data[filename])\n+            self.assertEqual(self.expected, result)\n+\n+    @defer.inlineCallbacks\n+    def test_custom_plugin(self):\n+\n+        filename_to_processed = {\n+            self._named_tempfile('newline'): b'foo\\r\\n\\nbar\\r\\n\\n',\n+            self._named_tempfile('tab'): b'foo\\r\\n\\tbar\\r\\n\\t',\n+        }\n+\n+        settings = {\n+            'FEEDS': {\n+                self._named_tempfile('newline'): {\n+                    'format': 'csv',\n+                    'postprocessing': [self.MyPlugin1],\n+                    'plugin1_char': b'\\n'\n+                },\n+                self._named_tempfile('tab'): {\n+                    'format': 'csv',\n+                    'postprocessing': [self.MyPlugin1],\n+                    'plugin1_char': b'\\t',\n+                },\n+            },\n+        }\n+\n+        data = yield self.exported_data(self.items, settings)\n+\n+        for filename, expected in filename_to_processed.items():\n+            self.assertEqual(expected, data[filename])\n+\n+    @defer.inlineCallbacks\n+    def test_custom_plugin_with_compression(self):\n+\n+        expected = b'foo\\r\\n\\nbar\\r\\n\\n'\n+\n+        filename_to_decompressor = {\n+            self._named_tempfile('bz2'): bz2.decompress,\n+            self._named_tempfile('lzma'): lzma.decompress,\n+            self._named_tempfile('gzip'): gzip.decompress,\n+        }\n+\n+        settings = {\n+            'FEEDS': {\n+                self._named_tempfile('bz2'): {\n+                    'format': 'csv',\n+                    'postprocessing': [self.MyPlugin1, 'scrapy.extensions.postprocessing.Bz2Plugin'],\n+                    'plugin1_char': b'\\n',\n+                },\n+                self._named_tempfile('lzma'): {\n+                    'format': 'csv',\n+                    'postprocessing': [self.MyPlugin1, 'scrapy.extensions.postprocessing.LZMAPlugin'],\n+                    'plugin1_char': b'\\n',\n+                },\n+                self._named_tempfile('gzip'): {\n+                    'format': 'csv',\n+                    'postprocessing': [self.MyPlugin1, 'scrapy.extensions.postprocessing.GzipPlugin'],\n+                    'plugin1_char': b'\\n',\n+                },\n+            },\n+        }\n+\n+        data = yield self.exported_data(self.items, settings)\n+\n+        for filename, decompressor in filename_to_decompressor.items():\n+            result = decompressor(data[filename])\n+            self.assertEqual(expected, result)\n+\n+    @defer.inlineCallbacks\n+    def test_exports_compatibility_with_postproc(self):\n+\n+        format_to_expected = {\n+            'csv': b'foo\\r\\nbar\\r\\n',\n+            'json': b'[\\n{\"foo\": \"bar\"}\\n]',\n+            'jsonlines': b'{\"foo\": \"bar\"}\\n',\n+            'xml': b'<?xml version=\"1.0\" encoding=\"utf-8\"?>\\n<items>\\n<item><foo>bar</foo></item>\\n</items>',\n+            'marshal': b'{\\xda\\x03foo\\xda\\x03bar0',",
      "comment": "If the problem is across Python versions, you could use `marshal.dumps({\"foo\": \"bar\"})` here instead of hardcoding the value.",
      "comment_id": 666226550,
      "user": "Gallaecio",
      "created_at": "2021-07-08T14:06:46Z",
      "url": "https://github.com/scrapy/scrapy/pull/5190#discussion_r666226550"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 5190,
      "file_path": "tests/test_feedexport.py",
      "line": 1488,
      "side": "RIGHT",
      "diff_hunk": "@@ -1469,6 +1472,496 @@ def test_extend_kwargs(self):\n             self.assertEqual(row['expected'], data[feed_options['format']])\n \n \n+class FeedPostProcessedExportsTest(FeedExportTestBase):\n+    __test__ = True\n+\n+    items = [{'foo': 'bar'}]\n+    expected = b'foo\\r\\nbar\\r\\n'\n+\n+    class MyPlugin1:\n+        def __init__(self, file, feed_options):\n+            self.file = file\n+            self.feed_options = feed_options\n+            self.char = self.feed_options.get('plugin1_char', b'')\n+\n+        def write(self, data):\n+            return self.file.write(bytes(data) + self.char)",
      "comment": "Why is the casting needed? Who is trying to write a string instead of bytes? Maybe this should be fixed earlier in the execution.",
      "comment_id": 676150909,
      "user": "Gallaecio",
      "created_at": "2021-07-25T13:59:48Z",
      "url": "https://github.com/scrapy/scrapy/pull/5190#discussion_r676150909"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 5190,
      "file_path": "tests/test_feedexport.py",
      "line": 1768,
      "side": "RIGHT",
      "diff_hunk": "@@ -1469,6 +1472,496 @@ def test_extend_kwargs(self):\n             self.assertEqual(row['expected'], data[feed_options['format']])\n \n \n+class FeedPostProcessedExportsTest(FeedExportTestBase):\n+    __test__ = True\n+\n+    items = [{'foo': 'bar'}]\n+    expected = b'foo\\r\\nbar\\r\\n'\n+\n+    class MyPlugin1:\n+        def __init__(self, file, feed_options):\n+            self.file = file\n+            self.feed_options = feed_options\n+            self.char = self.feed_options.get('plugin1_char', b'')\n+\n+        def write(self, data):\n+            return self.file.write(bytes(data) + self.char)\n+\n+        def close(self):\n+            self.file.close()\n+\n+    def _named_tempfile(self, name):\n+        return os.path.join(self.temp_dir, name)\n+\n+    @defer.inlineCallbacks\n+    def run_and_export(self, spider_cls, settings):\n+        \"\"\" Run spider with specified settings; return exported data with filename. \"\"\"\n+\n+        FEEDS = settings.get('FEEDS') or {}\n+        settings['FEEDS'] = {\n+            printf_escape(path_to_url(file_path)): feed_options\n+            for file_path, feed_options in FEEDS.items()\n+        }\n+\n+        content = {}\n+        try:\n+            with MockServer() as s:\n+                runner = CrawlerRunner(Settings(settings))\n+                spider_cls.start_urls = [s.url('/')]\n+                yield runner.crawl(spider_cls)\n+\n+            for file_path, feed_options in FEEDS.items():\n+                if not os.path.exists(str(file_path)):\n+                    continue\n+\n+                with open(str(file_path), 'rb') as f:\n+                    content[str(file_path)] = f.read()\n+\n+        finally:\n+            for file_path in FEEDS.keys():\n+                if not os.path.exists(str(file_path)):\n+                    continue\n+\n+                os.remove(str(file_path))\n+\n+        return content\n+\n+    def get_gzip_compressed(self, data, compresslevel=9, mtime=0, filename=''):\n+        data_stream = BytesIO()\n+        gzipf = gzip.GzipFile(fileobj=data_stream, filename=filename, mtime=mtime,\n+                              compresslevel=compresslevel, mode=\"wb\")\n+        gzipf.write(data)\n+        gzipf.close()\n+        data_stream.seek(0)\n+        return data_stream.read()\n+\n+    @defer.inlineCallbacks\n+    def test_gzip_plugin(self):\n+\n+        filename = self._named_tempfile('gzip_file')\n+\n+        settings = {\n+            'FEEDS': {\n+                filename: {\n+                    'format': 'csv',\n+                    'postprocessing': ['scrapy.extensions.postprocessing.GzipPlugin'],\n+                },\n+            },\n+        }\n+\n+        data = yield self.exported_data(self.items, settings)\n+        try:\n+            gzip.decompress(data[filename])\n+        except OSError:\n+            self.fail(\"Received invalid gzip data.\")\n+\n+    @defer.inlineCallbacks\n+    def test_gzip_plugin_compresslevel(self):\n+\n+        filename_to_compressed = {\n+            self._named_tempfile('compresslevel_0'): self.get_gzip_compressed(self.expected, compresslevel=0),\n+            self._named_tempfile('compresslevel_9'): self.get_gzip_compressed(self.expected, compresslevel=9),\n+        }\n+\n+        settings = {\n+            'FEEDS': {\n+                self._named_tempfile('compresslevel_0'): {\n+                    'format': 'csv',\n+                    'postprocessing': ['scrapy.extensions.postprocessing.GzipPlugin'],\n+                    'gzip_compresslevel': 0,\n+                    'gzip_mtime': 0,\n+                    'gzip_filename': \"\",\n+                },\n+                self._named_tempfile('compresslevel_9'): {\n+                    'format': 'csv',\n+                    'postprocessing': ['scrapy.extensions.postprocessing.GzipPlugin'],\n+                    'gzip_compresslevel': 9,\n+                    'gzip_mtime': 0,\n+                    'gzip_filename': \"\",\n+                },\n+            },\n+        }\n+\n+        data = yield self.exported_data(self.items, settings)\n+\n+        for filename, compressed in filename_to_compressed.items():\n+            result = gzip.decompress(data[filename])\n+            self.assertEqual(compressed, data[filename])\n+            self.assertEqual(self.expected, result)\n+\n+    @defer.inlineCallbacks\n+    def test_gzip_plugin_mtime(self):\n+        filename_to_compressed = {\n+            self._named_tempfile('mtime_123'): self.get_gzip_compressed(self.expected, mtime=123),\n+            self._named_tempfile('mtime_123456789'): self.get_gzip_compressed(self.expected, mtime=123456789),\n+        }\n+\n+        settings = {\n+            'FEEDS': {\n+                self._named_tempfile('mtime_123'): {\n+                    'format': 'csv',\n+                    'postprocessing': ['scrapy.extensions.postprocessing.GzipPlugin'],\n+                    'gzip_mtime': 123,\n+                    'gzip_filename': \"\",\n+                },\n+                self._named_tempfile('mtime_123456789'): {\n+                    'format': 'csv',\n+                    'postprocessing': ['scrapy.extensions.postprocessing.GzipPlugin'],\n+                    'gzip_mtime': 123456789,\n+                    'gzip_filename': \"\",\n+                },\n+            },\n+        }\n+\n+        data = yield self.exported_data(self.items, settings)\n+\n+        for filename, compressed in filename_to_compressed.items():\n+            result = gzip.decompress(data[filename])\n+            self.assertEqual(compressed, data[filename])\n+            self.assertEqual(self.expected, result)\n+\n+    @defer.inlineCallbacks\n+    def test_gzip_plugin_filename(self):\n+        filename_to_compressed = {\n+            self._named_tempfile('filename_FILE1'): self.get_gzip_compressed(self.expected, filename=\"FILE1\"),\n+            self._named_tempfile('filename_FILE2'): self.get_gzip_compressed(self.expected, filename=\"FILE2\"),\n+        }\n+\n+        settings = {\n+            'FEEDS': {\n+                self._named_tempfile('filename_FILE1'): {\n+                    'format': 'csv',\n+                    'postprocessing': ['scrapy.extensions.postprocessing.GzipPlugin'],\n+                    'gzip_mtime': 0,\n+                    'gzip_filename': \"FILE1\",\n+                },\n+                self._named_tempfile('filename_FILE2'): {\n+                    'format': 'csv',\n+                    'postprocessing': ['scrapy.extensions.postprocessing.GzipPlugin'],\n+                    'gzip_mtime': 0,\n+                    'gzip_filename': \"FILE2\",\n+                },\n+            },\n+        }\n+\n+        data = yield self.exported_data(self.items, settings)\n+\n+        for filename, compressed in filename_to_compressed.items():\n+            result = gzip.decompress(data[filename])\n+            self.assertEqual(compressed, data[filename])\n+            self.assertEqual(self.expected, result)\n+\n+    @defer.inlineCallbacks\n+    def test_lzma_plugin(self):\n+\n+        filename = self._named_tempfile('lzma_file')\n+\n+        settings = {\n+            'FEEDS': {\n+                filename: {\n+                    'format': 'csv',\n+                    'postprocessing': ['scrapy.extensions.postprocessing.LZMAPlugin'],\n+                },\n+            },\n+        }\n+\n+        data = yield self.exported_data(self.items, settings)\n+        try:\n+            lzma.decompress(data[filename])\n+        except lzma.LZMAError:\n+            self.fail(\"Received invalid lzma data.\")\n+\n+    @defer.inlineCallbacks\n+    def test_lzma_plugin_format(self):\n+\n+        filename_to_compressed = {\n+            self._named_tempfile('format_FORMAT_XZ'): lzma.compress(self.expected, format=lzma.FORMAT_XZ),\n+            self._named_tempfile('format_FORMAT_ALONE'): lzma.compress(self.expected, format=lzma.FORMAT_ALONE),\n+        }\n+\n+        settings = {\n+            'FEEDS': {\n+                self._named_tempfile('format_FORMAT_XZ'): {\n+                    'format': 'csv',\n+                    'postprocessing': ['scrapy.extensions.postprocessing.LZMAPlugin'],\n+                    'lzma_format': lzma.FORMAT_XZ,\n+                },\n+                self._named_tempfile('format_FORMAT_ALONE'): {\n+                    'format': 'csv',\n+                    'postprocessing': ['scrapy.extensions.postprocessing.LZMAPlugin'],\n+                    'lzma_format': lzma.FORMAT_ALONE,\n+                },\n+            },\n+        }\n+\n+        data = yield self.exported_data(self.items, settings)\n+\n+        for filename, compressed in filename_to_compressed.items():\n+            result = lzma.decompress(data[filename])\n+            self.assertEqual(compressed, data[filename])\n+            self.assertEqual(self.expected, result)\n+\n+    @defer.inlineCallbacks\n+    def test_lzma_plugin_check(self):\n+\n+        filename_to_compressed = {\n+            self._named_tempfile('check_CHECK_NONE'): lzma.compress(self.expected, check=lzma.CHECK_NONE),\n+            self._named_tempfile('check_CHECK_CRC256'): lzma.compress(self.expected, check=lzma.CHECK_SHA256),\n+        }\n+\n+        settings = {\n+            'FEEDS': {\n+                self._named_tempfile('check_CHECK_NONE'): {\n+                    'format': 'csv',\n+                    'postprocessing': ['scrapy.extensions.postprocessing.LZMAPlugin'],\n+                    'lzma_check': lzma.CHECK_NONE,\n+                },\n+                self._named_tempfile('check_CHECK_CRC256'): {\n+                    'format': 'csv',\n+                    'postprocessing': ['scrapy.extensions.postprocessing.LZMAPlugin'],\n+                    'lzma_check': lzma.CHECK_SHA256,\n+                },\n+            },\n+        }\n+\n+        data = yield self.exported_data(self.items, settings)\n+\n+        for filename, compressed in filename_to_compressed.items():\n+            result = lzma.decompress(data[filename])\n+            self.assertEqual(compressed, data[filename])\n+            self.assertEqual(self.expected, result)\n+\n+    @defer.inlineCallbacks\n+    def test_lzma_plugin_preset(self):\n+\n+        filename_to_compressed = {\n+            self._named_tempfile('preset_PRESET_0'): lzma.compress(self.expected, preset=0),\n+            self._named_tempfile('preset_PRESET_9'): lzma.compress(self.expected, preset=9),\n+        }\n+\n+        settings = {\n+            'FEEDS': {\n+                self._named_tempfile('preset_PRESET_0'): {\n+                    'format': 'csv',\n+                    'postprocessing': ['scrapy.extensions.postprocessing.LZMAPlugin'],\n+                    'lzma_preset': 0,\n+                },\n+                self._named_tempfile('preset_PRESET_9'): {\n+                    'format': 'csv',\n+                    'postprocessing': ['scrapy.extensions.postprocessing.LZMAPlugin'],\n+                    'lzma_preset': 9,\n+                },\n+            },\n+        }\n+\n+        data = yield self.exported_data(self.items, settings)\n+\n+        for filename, compressed in filename_to_compressed.items():\n+            result = lzma.decompress(data[filename])\n+            self.assertEqual(compressed, data[filename])\n+            self.assertEqual(self.expected, result)\n+\n+    @defer.inlineCallbacks\n+    def test_lzma_plugin_filters(self):\n+        import sys\n+        if \"PyPy\" in sys.version:\n+            raise unittest.SkipTest(\"lzma filters doesn't work in PyPy\")",
      "comment": "Please, include a code comment that points to the corresponding bug report or source of information.",
      "comment_id": 676150975,
      "user": "Gallaecio",
      "created_at": "2021-07-25T14:00:23Z",
      "url": "https://github.com/scrapy/scrapy/pull/5190#discussion_r676150975"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 5190,
      "file_path": "tests/test_feedexport.py",
      "line": 1488,
      "side": "RIGHT",
      "diff_hunk": "@@ -1469,6 +1472,496 @@ def test_extend_kwargs(self):\n             self.assertEqual(row['expected'], data[feed_options['format']])\n \n \n+class FeedPostProcessedExportsTest(FeedExportTestBase):\n+    __test__ = True\n+\n+    items = [{'foo': 'bar'}]\n+    expected = b'foo\\r\\nbar\\r\\n'\n+\n+    class MyPlugin1:\n+        def __init__(self, file, feed_options):\n+            self.file = file\n+            self.feed_options = feed_options\n+            self.char = self.feed_options.get('plugin1_char', b'')\n+\n+        def write(self, data):\n+            return self.file.write(bytes(data) + self.char)",
      "comment": "Pypy's pickle implementation was writing data in `memoryview` instead of expected `bytes` (And weirdly only for pickling protocol 4). So I was getting operand error. I figured converting it to `bytes`.",
      "comment_id": 676166824,
      "user": "drs-11",
      "created_at": "2021-07-25T16:01:28Z",
      "url": "https://github.com/scrapy/scrapy/pull/5190#discussion_r676166824"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 5190,
      "file_path": "tests/test_feedexport.py",
      "line": 1488,
      "side": "RIGHT",
      "diff_hunk": "@@ -1469,6 +1472,496 @@ def test_extend_kwargs(self):\n             self.assertEqual(row['expected'], data[feed_options['format']])\n \n \n+class FeedPostProcessedExportsTest(FeedExportTestBase):\n+    __test__ = True\n+\n+    items = [{'foo': 'bar'}]\n+    expected = b'foo\\r\\nbar\\r\\n'\n+\n+    class MyPlugin1:\n+        def __init__(self, file, feed_options):\n+            self.file = file\n+            self.feed_options = feed_options\n+            self.char = self.feed_options.get('plugin1_char', b'')\n+\n+        def write(self, data):\n+            return self.file.write(bytes(data) + self.char)",
      "comment": "Then what about moving the casting to the Pickle plugin and adding a comment about this? (hopefully there\u2019s an online bug report or note somewhere that we can link)",
      "comment_id": 676333607,
      "user": "Gallaecio",
      "created_at": "2021-07-26T06:49:09Z",
      "url": "https://github.com/scrapy/scrapy/pull/5190#discussion_r676333607"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 5190,
      "file_path": "tests/test_feedexport.py",
      "line": 1488,
      "side": "RIGHT",
      "diff_hunk": "@@ -1469,6 +1472,496 @@ def test_extend_kwargs(self):\n             self.assertEqual(row['expected'], data[feed_options['format']])\n \n \n+class FeedPostProcessedExportsTest(FeedExportTestBase):\n+    __test__ = True\n+\n+    items = [{'foo': 'bar'}]\n+    expected = b'foo\\r\\nbar\\r\\n'\n+\n+    class MyPlugin1:\n+        def __init__(self, file, feed_options):\n+            self.file = file\n+            self.feed_options = feed_options\n+            self.char = self.feed_options.get('plugin1_char', b'')\n+\n+        def write(self, data):\n+            return self.file.write(bytes(data) + self.char)",
      "comment": "The `write` function of the custom plugin is being used by the `pickle.dump` method in `PickleItemExporter`. Can't really move the casting there in the `dump` method. And I can't find anything about the `memoryview` problem either. Seems like a very rare case someone would use a wrapper in the `dump` method :sweat_smile:.",
      "comment_id": 676376328,
      "user": "drs-11",
      "created_at": "2021-07-26T07:57:32Z",
      "url": "https://github.com/scrapy/scrapy/pull/5190#discussion_r676376328"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 5190,
      "file_path": "tests/test_feedexport.py",
      "line": 1769,
      "side": "RIGHT",
      "diff_hunk": "@@ -1765,7 +1765,10 @@ def test_lzma_plugin_preset(self):\n     def test_lzma_plugin_filters(self):\n         import sys\n         if \"PyPy\" in sys.version:\n-            raise unittest.SkipTest(\"lzma filters doesn't work in PyPy\")\n+            pypy_version = sys.version.split('\\n')[1].split()[1]\n+            if pypy_version <= '7.3.1':",
      "comment": "This is not a reliable way to test versions:\r\n\r\n```python\r\n>>> '10.0.0' <= '7.3.1'\r\nTrue\r\n```\r\n\r\nSee `sys.version_info` usage in the code base, something like that should work.",
      "comment_id": 676518692,
      "user": "Gallaecio",
      "created_at": "2021-07-26T11:26:43Z",
      "url": "https://github.com/scrapy/scrapy/pull/5190#discussion_r676518692"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 5190,
      "file_path": "tests/test_feedexport.py",
      "line": 1488,
      "side": "RIGHT",
      "diff_hunk": "@@ -1469,6 +1472,496 @@ def test_extend_kwargs(self):\n             self.assertEqual(row['expected'], data[feed_options['format']])\n \n \n+class FeedPostProcessedExportsTest(FeedExportTestBase):\n+    __test__ = True\n+\n+    items = [{'foo': 'bar'}]\n+    expected = b'foo\\r\\nbar\\r\\n'\n+\n+    class MyPlugin1:\n+        def __init__(self, file, feed_options):\n+            self.file = file\n+            self.feed_options = feed_options\n+            self.char = self.feed_options.get('plugin1_char', b'')\n+\n+        def write(self, data):\n+            return self.file.write(bytes(data) + self.char)",
      "comment": "Does it work if you use 2 separate write calls?\r\n\r\n```python\r\nwritten_count = self.file.write(data)\r\nwritten_count += self.file.write(self.char)\r\nreturn written_count\r\n```\r\n\r\nIf we go this route, it might be good to indicate that the input data may be a `memoryview`, and support that officially.",
      "comment_id": 676523606,
      "user": "Gallaecio",
      "created_at": "2021-07-26T11:34:54Z",
      "url": "https://github.com/scrapy/scrapy/pull/5190#discussion_r676523606"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 5190,
      "file_path": "tests/test_feedexport.py",
      "line": 1488,
      "side": "RIGHT",
      "diff_hunk": "@@ -1469,6 +1472,496 @@ def test_extend_kwargs(self):\n             self.assertEqual(row['expected'], data[feed_options['format']])\n \n \n+class FeedPostProcessedExportsTest(FeedExportTestBase):\n+    __test__ = True\n+\n+    items = [{'foo': 'bar'}]\n+    expected = b'foo\\r\\nbar\\r\\n'\n+\n+    class MyPlugin1:\n+        def __init__(self, file, feed_options):\n+            self.file = file\n+            self.feed_options = feed_options\n+            self.char = self.feed_options.get('plugin1_char', b'')\n+\n+        def write(self, data):\n+            return self.file.write(bytes(data) + self.char)",
      "comment": "> Does it work if you use 2 separate write calls?\r\n\r\nYup it works that way. It also works like this: `self.file.write(self.char + data)` weirdly.\r\n\r\n> If we go this route, it might be good to indicate that the input data may be a memoryview, and support that officially.\r\n\r\nBy that you mean we should include in the documentation to warn the users that input could be a `memoryview` while using `PickleItemExporter`?",
      "comment_id": 677492156,
      "user": "drs-11",
      "created_at": "2021-07-27T14:14:10Z",
      "url": "https://github.com/scrapy/scrapy/pull/5190#discussion_r677492156"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 5190,
      "file_path": "tests/test_feedexport.py",
      "line": 1488,
      "side": "RIGHT",
      "diff_hunk": "@@ -1469,6 +1472,496 @@ def test_extend_kwargs(self):\n             self.assertEqual(row['expected'], data[feed_options['format']])\n \n \n+class FeedPostProcessedExportsTest(FeedExportTestBase):\n+    __test__ = True\n+\n+    items = [{'foo': 'bar'}]\n+    expected = b'foo\\r\\nbar\\r\\n'\n+\n+    class MyPlugin1:\n+        def __init__(self, file, feed_options):\n+            self.file = file\n+            self.feed_options = feed_options\n+            self.char = self.feed_options.get('plugin1_char', b'')\n+\n+        def write(self, data):\n+            return self.file.write(bytes(data) + self.char)",
      "comment": "I would not put the focus on `PickleItemExporter`, and instead assume that any exporter, built-in or user-provided, may do the same.\r\n\r\nSince supporting a `memoryview` should be trivial, and we are going to support it in our post-processing plugins, it would make sense to indicate in the documentation of plugins that their `write` method may get either `memoryview` or `bytes`, and that they should be ready to handle any of those types as input.",
      "comment_id": 677512922,
      "user": "Gallaecio",
      "created_at": "2021-07-27T14:35:23Z",
      "url": "https://github.com/scrapy/scrapy/pull/5190#discussion_r677512922"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 5190,
      "file_path": "tests/test_feedexport.py",
      "line": 1772,
      "side": "RIGHT",
      "diff_hunk": "@@ -1469,6 +1472,502 @@ def test_extend_kwargs(self):\n             self.assertEqual(row['expected'], data[feed_options['format']])\n \n \n+class FeedPostProcessedExportsTest(FeedExportTestBase):\n+    __test__ = True\n+\n+    items = [{'foo': 'bar'}]\n+    expected = b'foo\\r\\nbar\\r\\n'\n+\n+    class MyPlugin1:\n+        def __init__(self, file, feed_options):\n+            self.file = file\n+            self.feed_options = feed_options\n+            self.char = self.feed_options.get('plugin1_char', b'')\n+\n+        def write(self, data):\n+            written_count = self.file.write(data)\n+            written_count += self.file.write(self.char)\n+            return written_count\n+\n+        def close(self):\n+            self.file.close()\n+\n+    def _named_tempfile(self, name):\n+        return os.path.join(self.temp_dir, name)\n+\n+    @defer.inlineCallbacks\n+    def run_and_export(self, spider_cls, settings):\n+        \"\"\" Run spider with specified settings; return exported data with filename. \"\"\"\n+\n+        FEEDS = settings.get('FEEDS') or {}\n+        settings['FEEDS'] = {\n+            printf_escape(path_to_url(file_path)): feed_options\n+            for file_path, feed_options in FEEDS.items()\n+        }\n+\n+        content = {}\n+        try:\n+            with MockServer() as s:\n+                runner = CrawlerRunner(Settings(settings))\n+                spider_cls.start_urls = [s.url('/')]\n+                yield runner.crawl(spider_cls)\n+\n+            for file_path, feed_options in FEEDS.items():\n+                if not os.path.exists(str(file_path)):\n+                    continue\n+\n+                with open(str(file_path), 'rb') as f:\n+                    content[str(file_path)] = f.read()\n+\n+        finally:\n+            for file_path in FEEDS.keys():\n+                if not os.path.exists(str(file_path)):\n+                    continue\n+\n+                os.remove(str(file_path))\n+\n+        return content\n+\n+    def get_gzip_compressed(self, data, compresslevel=9, mtime=0, filename=''):\n+        data_stream = BytesIO()\n+        gzipf = gzip.GzipFile(fileobj=data_stream, filename=filename, mtime=mtime,\n+                              compresslevel=compresslevel, mode=\"wb\")\n+        gzipf.write(data)\n+        gzipf.close()\n+        data_stream.seek(0)\n+        return data_stream.read()\n+\n+    @defer.inlineCallbacks\n+    def test_gzip_plugin(self):\n+\n+        filename = self._named_tempfile('gzip_file')\n+\n+        settings = {\n+            'FEEDS': {\n+                filename: {\n+                    'format': 'csv',\n+                    'postprocessing': ['scrapy.extensions.postprocessing.GzipPlugin'],\n+                },\n+            },\n+        }\n+\n+        data = yield self.exported_data(self.items, settings)\n+        try:\n+            gzip.decompress(data[filename])\n+        except OSError:\n+            self.fail(\"Received invalid gzip data.\")\n+\n+    @defer.inlineCallbacks\n+    def test_gzip_plugin_compresslevel(self):\n+\n+        filename_to_compressed = {\n+            self._named_tempfile('compresslevel_0'): self.get_gzip_compressed(self.expected, compresslevel=0),\n+            self._named_tempfile('compresslevel_9'): self.get_gzip_compressed(self.expected, compresslevel=9),\n+        }\n+\n+        settings = {\n+            'FEEDS': {\n+                self._named_tempfile('compresslevel_0'): {\n+                    'format': 'csv',\n+                    'postprocessing': ['scrapy.extensions.postprocessing.GzipPlugin'],\n+                    'gzip_compresslevel': 0,\n+                    'gzip_mtime': 0,\n+                    'gzip_filename': \"\",\n+                },\n+                self._named_tempfile('compresslevel_9'): {\n+                    'format': 'csv',\n+                    'postprocessing': ['scrapy.extensions.postprocessing.GzipPlugin'],\n+                    'gzip_compresslevel': 9,\n+                    'gzip_mtime': 0,\n+                    'gzip_filename': \"\",\n+                },\n+            },\n+        }\n+\n+        data = yield self.exported_data(self.items, settings)\n+\n+        for filename, compressed in filename_to_compressed.items():\n+            result = gzip.decompress(data[filename])\n+            self.assertEqual(compressed, data[filename])\n+            self.assertEqual(self.expected, result)\n+\n+    @defer.inlineCallbacks\n+    def test_gzip_plugin_mtime(self):\n+        filename_to_compressed = {\n+            self._named_tempfile('mtime_123'): self.get_gzip_compressed(self.expected, mtime=123),\n+            self._named_tempfile('mtime_123456789'): self.get_gzip_compressed(self.expected, mtime=123456789),\n+        }\n+\n+        settings = {\n+            'FEEDS': {\n+                self._named_tempfile('mtime_123'): {\n+                    'format': 'csv',\n+                    'postprocessing': ['scrapy.extensions.postprocessing.GzipPlugin'],\n+                    'gzip_mtime': 123,\n+                    'gzip_filename': \"\",\n+                },\n+                self._named_tempfile('mtime_123456789'): {\n+                    'format': 'csv',\n+                    'postprocessing': ['scrapy.extensions.postprocessing.GzipPlugin'],\n+                    'gzip_mtime': 123456789,\n+                    'gzip_filename': \"\",\n+                },\n+            },\n+        }\n+\n+        data = yield self.exported_data(self.items, settings)\n+\n+        for filename, compressed in filename_to_compressed.items():\n+            result = gzip.decompress(data[filename])\n+            self.assertEqual(compressed, data[filename])\n+            self.assertEqual(self.expected, result)\n+\n+    @defer.inlineCallbacks\n+    def test_gzip_plugin_filename(self):\n+        filename_to_compressed = {\n+            self._named_tempfile('filename_FILE1'): self.get_gzip_compressed(self.expected, filename=\"FILE1\"),\n+            self._named_tempfile('filename_FILE2'): self.get_gzip_compressed(self.expected, filename=\"FILE2\"),\n+        }\n+\n+        settings = {\n+            'FEEDS': {\n+                self._named_tempfile('filename_FILE1'): {\n+                    'format': 'csv',\n+                    'postprocessing': ['scrapy.extensions.postprocessing.GzipPlugin'],\n+                    'gzip_mtime': 0,\n+                    'gzip_filename': \"FILE1\",\n+                },\n+                self._named_tempfile('filename_FILE2'): {\n+                    'format': 'csv',\n+                    'postprocessing': ['scrapy.extensions.postprocessing.GzipPlugin'],\n+                    'gzip_mtime': 0,\n+                    'gzip_filename': \"FILE2\",\n+                },\n+            },\n+        }\n+\n+        data = yield self.exported_data(self.items, settings)\n+\n+        for filename, compressed in filename_to_compressed.items():\n+            result = gzip.decompress(data[filename])\n+            self.assertEqual(compressed, data[filename])\n+            self.assertEqual(self.expected, result)\n+\n+    @defer.inlineCallbacks\n+    def test_lzma_plugin(self):\n+\n+        filename = self._named_tempfile('lzma_file')\n+\n+        settings = {\n+            'FEEDS': {\n+                filename: {\n+                    'format': 'csv',\n+                    'postprocessing': ['scrapy.extensions.postprocessing.LZMAPlugin'],\n+                },\n+            },\n+        }\n+\n+        data = yield self.exported_data(self.items, settings)\n+        try:\n+            lzma.decompress(data[filename])\n+        except lzma.LZMAError:\n+            self.fail(\"Received invalid lzma data.\")\n+\n+    @defer.inlineCallbacks\n+    def test_lzma_plugin_format(self):\n+\n+        filename_to_compressed = {\n+            self._named_tempfile('format_FORMAT_XZ'): lzma.compress(self.expected, format=lzma.FORMAT_XZ),\n+            self._named_tempfile('format_FORMAT_ALONE'): lzma.compress(self.expected, format=lzma.FORMAT_ALONE),\n+        }\n+\n+        settings = {\n+            'FEEDS': {\n+                self._named_tempfile('format_FORMAT_XZ'): {\n+                    'format': 'csv',\n+                    'postprocessing': ['scrapy.extensions.postprocessing.LZMAPlugin'],\n+                    'lzma_format': lzma.FORMAT_XZ,\n+                },\n+                self._named_tempfile('format_FORMAT_ALONE'): {\n+                    'format': 'csv',\n+                    'postprocessing': ['scrapy.extensions.postprocessing.LZMAPlugin'],\n+                    'lzma_format': lzma.FORMAT_ALONE,\n+                },\n+            },\n+        }\n+\n+        data = yield self.exported_data(self.items, settings)\n+\n+        for filename, compressed in filename_to_compressed.items():\n+            result = lzma.decompress(data[filename])\n+            self.assertEqual(compressed, data[filename])\n+            self.assertEqual(self.expected, result)\n+\n+    @defer.inlineCallbacks\n+    def test_lzma_plugin_check(self):\n+\n+        filename_to_compressed = {\n+            self._named_tempfile('check_CHECK_NONE'): lzma.compress(self.expected, check=lzma.CHECK_NONE),\n+            self._named_tempfile('check_CHECK_CRC256'): lzma.compress(self.expected, check=lzma.CHECK_SHA256),\n+        }\n+\n+        settings = {\n+            'FEEDS': {\n+                self._named_tempfile('check_CHECK_NONE'): {\n+                    'format': 'csv',\n+                    'postprocessing': ['scrapy.extensions.postprocessing.LZMAPlugin'],\n+                    'lzma_check': lzma.CHECK_NONE,\n+                },\n+                self._named_tempfile('check_CHECK_CRC256'): {\n+                    'format': 'csv',\n+                    'postprocessing': ['scrapy.extensions.postprocessing.LZMAPlugin'],\n+                    'lzma_check': lzma.CHECK_SHA256,\n+                },\n+            },\n+        }\n+\n+        data = yield self.exported_data(self.items, settings)\n+\n+        for filename, compressed in filename_to_compressed.items():\n+            result = lzma.decompress(data[filename])\n+            self.assertEqual(compressed, data[filename])\n+            self.assertEqual(self.expected, result)\n+\n+    @defer.inlineCallbacks\n+    def test_lzma_plugin_preset(self):\n+\n+        filename_to_compressed = {\n+            self._named_tempfile('preset_PRESET_0'): lzma.compress(self.expected, preset=0),\n+            self._named_tempfile('preset_PRESET_9'): lzma.compress(self.expected, preset=9),\n+        }\n+\n+        settings = {\n+            'FEEDS': {\n+                self._named_tempfile('preset_PRESET_0'): {\n+                    'format': 'csv',\n+                    'postprocessing': ['scrapy.extensions.postprocessing.LZMAPlugin'],\n+                    'lzma_preset': 0,\n+                },\n+                self._named_tempfile('preset_PRESET_9'): {\n+                    'format': 'csv',\n+                    'postprocessing': ['scrapy.extensions.postprocessing.LZMAPlugin'],\n+                    'lzma_preset': 9,\n+                },\n+            },\n+        }\n+\n+        data = yield self.exported_data(self.items, settings)\n+\n+        for filename, compressed in filename_to_compressed.items():\n+            result = lzma.decompress(data[filename])\n+            self.assertEqual(compressed, data[filename])\n+            self.assertEqual(self.expected, result)\n+\n+    @defer.inlineCallbacks\n+    def test_lzma_plugin_filters(self):\n+        import sys\n+        if \"PyPy\" in sys.version:\n+            pypy_version_str = sys.version.split('\\n')[1].split()[1]\n+            pypy_version = tuple(map(int, pypy_version_str.split(\".\")))\n+            if pypy_version <= (7, 3, 1):",
      "comment": "I _think_ you can simplify this part by using `sys.version_info` instead:\r\n\r\n```suggestion\r\n            if sys.version_info <= (7, 3, 1):\r\n```",
      "comment_id": 677598322,
      "user": "Gallaecio",
      "created_at": "2021-07-27T16:08:38Z",
      "url": "https://github.com/scrapy/scrapy/pull/5190#discussion_r677598322"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 5190,
      "file_path": "tests/test_feedexport.py",
      "line": 1772,
      "side": "RIGHT",
      "diff_hunk": "@@ -1469,6 +1472,502 @@ def test_extend_kwargs(self):\n             self.assertEqual(row['expected'], data[feed_options['format']])\n \n \n+class FeedPostProcessedExportsTest(FeedExportTestBase):\n+    __test__ = True\n+\n+    items = [{'foo': 'bar'}]\n+    expected = b'foo\\r\\nbar\\r\\n'\n+\n+    class MyPlugin1:\n+        def __init__(self, file, feed_options):\n+            self.file = file\n+            self.feed_options = feed_options\n+            self.char = self.feed_options.get('plugin1_char', b'')\n+\n+        def write(self, data):\n+            written_count = self.file.write(data)\n+            written_count += self.file.write(self.char)\n+            return written_count\n+\n+        def close(self):\n+            self.file.close()\n+\n+    def _named_tempfile(self, name):\n+        return os.path.join(self.temp_dir, name)\n+\n+    @defer.inlineCallbacks\n+    def run_and_export(self, spider_cls, settings):\n+        \"\"\" Run spider with specified settings; return exported data with filename. \"\"\"\n+\n+        FEEDS = settings.get('FEEDS') or {}\n+        settings['FEEDS'] = {\n+            printf_escape(path_to_url(file_path)): feed_options\n+            for file_path, feed_options in FEEDS.items()\n+        }\n+\n+        content = {}\n+        try:\n+            with MockServer() as s:\n+                runner = CrawlerRunner(Settings(settings))\n+                spider_cls.start_urls = [s.url('/')]\n+                yield runner.crawl(spider_cls)\n+\n+            for file_path, feed_options in FEEDS.items():\n+                if not os.path.exists(str(file_path)):\n+                    continue\n+\n+                with open(str(file_path), 'rb') as f:\n+                    content[str(file_path)] = f.read()\n+\n+        finally:\n+            for file_path in FEEDS.keys():\n+                if not os.path.exists(str(file_path)):\n+                    continue\n+\n+                os.remove(str(file_path))\n+\n+        return content\n+\n+    def get_gzip_compressed(self, data, compresslevel=9, mtime=0, filename=''):\n+        data_stream = BytesIO()\n+        gzipf = gzip.GzipFile(fileobj=data_stream, filename=filename, mtime=mtime,\n+                              compresslevel=compresslevel, mode=\"wb\")\n+        gzipf.write(data)\n+        gzipf.close()\n+        data_stream.seek(0)\n+        return data_stream.read()\n+\n+    @defer.inlineCallbacks\n+    def test_gzip_plugin(self):\n+\n+        filename = self._named_tempfile('gzip_file')\n+\n+        settings = {\n+            'FEEDS': {\n+                filename: {\n+                    'format': 'csv',\n+                    'postprocessing': ['scrapy.extensions.postprocessing.GzipPlugin'],\n+                },\n+            },\n+        }\n+\n+        data = yield self.exported_data(self.items, settings)\n+        try:\n+            gzip.decompress(data[filename])\n+        except OSError:\n+            self.fail(\"Received invalid gzip data.\")\n+\n+    @defer.inlineCallbacks\n+    def test_gzip_plugin_compresslevel(self):\n+\n+        filename_to_compressed = {\n+            self._named_tempfile('compresslevel_0'): self.get_gzip_compressed(self.expected, compresslevel=0),\n+            self._named_tempfile('compresslevel_9'): self.get_gzip_compressed(self.expected, compresslevel=9),\n+        }\n+\n+        settings = {\n+            'FEEDS': {\n+                self._named_tempfile('compresslevel_0'): {\n+                    'format': 'csv',\n+                    'postprocessing': ['scrapy.extensions.postprocessing.GzipPlugin'],\n+                    'gzip_compresslevel': 0,\n+                    'gzip_mtime': 0,\n+                    'gzip_filename': \"\",\n+                },\n+                self._named_tempfile('compresslevel_9'): {\n+                    'format': 'csv',\n+                    'postprocessing': ['scrapy.extensions.postprocessing.GzipPlugin'],\n+                    'gzip_compresslevel': 9,\n+                    'gzip_mtime': 0,\n+                    'gzip_filename': \"\",\n+                },\n+            },\n+        }\n+\n+        data = yield self.exported_data(self.items, settings)\n+\n+        for filename, compressed in filename_to_compressed.items():\n+            result = gzip.decompress(data[filename])\n+            self.assertEqual(compressed, data[filename])\n+            self.assertEqual(self.expected, result)\n+\n+    @defer.inlineCallbacks\n+    def test_gzip_plugin_mtime(self):\n+        filename_to_compressed = {\n+            self._named_tempfile('mtime_123'): self.get_gzip_compressed(self.expected, mtime=123),\n+            self._named_tempfile('mtime_123456789'): self.get_gzip_compressed(self.expected, mtime=123456789),\n+        }\n+\n+        settings = {\n+            'FEEDS': {\n+                self._named_tempfile('mtime_123'): {\n+                    'format': 'csv',\n+                    'postprocessing': ['scrapy.extensions.postprocessing.GzipPlugin'],\n+                    'gzip_mtime': 123,\n+                    'gzip_filename': \"\",\n+                },\n+                self._named_tempfile('mtime_123456789'): {\n+                    'format': 'csv',\n+                    'postprocessing': ['scrapy.extensions.postprocessing.GzipPlugin'],\n+                    'gzip_mtime': 123456789,\n+                    'gzip_filename': \"\",\n+                },\n+            },\n+        }\n+\n+        data = yield self.exported_data(self.items, settings)\n+\n+        for filename, compressed in filename_to_compressed.items():\n+            result = gzip.decompress(data[filename])\n+            self.assertEqual(compressed, data[filename])\n+            self.assertEqual(self.expected, result)\n+\n+    @defer.inlineCallbacks\n+    def test_gzip_plugin_filename(self):\n+        filename_to_compressed = {\n+            self._named_tempfile('filename_FILE1'): self.get_gzip_compressed(self.expected, filename=\"FILE1\"),\n+            self._named_tempfile('filename_FILE2'): self.get_gzip_compressed(self.expected, filename=\"FILE2\"),\n+        }\n+\n+        settings = {\n+            'FEEDS': {\n+                self._named_tempfile('filename_FILE1'): {\n+                    'format': 'csv',\n+                    'postprocessing': ['scrapy.extensions.postprocessing.GzipPlugin'],\n+                    'gzip_mtime': 0,\n+                    'gzip_filename': \"FILE1\",\n+                },\n+                self._named_tempfile('filename_FILE2'): {\n+                    'format': 'csv',\n+                    'postprocessing': ['scrapy.extensions.postprocessing.GzipPlugin'],\n+                    'gzip_mtime': 0,\n+                    'gzip_filename': \"FILE2\",\n+                },\n+            },\n+        }\n+\n+        data = yield self.exported_data(self.items, settings)\n+\n+        for filename, compressed in filename_to_compressed.items():\n+            result = gzip.decompress(data[filename])\n+            self.assertEqual(compressed, data[filename])\n+            self.assertEqual(self.expected, result)\n+\n+    @defer.inlineCallbacks\n+    def test_lzma_plugin(self):\n+\n+        filename = self._named_tempfile('lzma_file')\n+\n+        settings = {\n+            'FEEDS': {\n+                filename: {\n+                    'format': 'csv',\n+                    'postprocessing': ['scrapy.extensions.postprocessing.LZMAPlugin'],\n+                },\n+            },\n+        }\n+\n+        data = yield self.exported_data(self.items, settings)\n+        try:\n+            lzma.decompress(data[filename])\n+        except lzma.LZMAError:\n+            self.fail(\"Received invalid lzma data.\")\n+\n+    @defer.inlineCallbacks\n+    def test_lzma_plugin_format(self):\n+\n+        filename_to_compressed = {\n+            self._named_tempfile('format_FORMAT_XZ'): lzma.compress(self.expected, format=lzma.FORMAT_XZ),\n+            self._named_tempfile('format_FORMAT_ALONE'): lzma.compress(self.expected, format=lzma.FORMAT_ALONE),\n+        }\n+\n+        settings = {\n+            'FEEDS': {\n+                self._named_tempfile('format_FORMAT_XZ'): {\n+                    'format': 'csv',\n+                    'postprocessing': ['scrapy.extensions.postprocessing.LZMAPlugin'],\n+                    'lzma_format': lzma.FORMAT_XZ,\n+                },\n+                self._named_tempfile('format_FORMAT_ALONE'): {\n+                    'format': 'csv',\n+                    'postprocessing': ['scrapy.extensions.postprocessing.LZMAPlugin'],\n+                    'lzma_format': lzma.FORMAT_ALONE,\n+                },\n+            },\n+        }\n+\n+        data = yield self.exported_data(self.items, settings)\n+\n+        for filename, compressed in filename_to_compressed.items():\n+            result = lzma.decompress(data[filename])\n+            self.assertEqual(compressed, data[filename])\n+            self.assertEqual(self.expected, result)\n+\n+    @defer.inlineCallbacks\n+    def test_lzma_plugin_check(self):\n+\n+        filename_to_compressed = {\n+            self._named_tempfile('check_CHECK_NONE'): lzma.compress(self.expected, check=lzma.CHECK_NONE),\n+            self._named_tempfile('check_CHECK_CRC256'): lzma.compress(self.expected, check=lzma.CHECK_SHA256),\n+        }\n+\n+        settings = {\n+            'FEEDS': {\n+                self._named_tempfile('check_CHECK_NONE'): {\n+                    'format': 'csv',\n+                    'postprocessing': ['scrapy.extensions.postprocessing.LZMAPlugin'],\n+                    'lzma_check': lzma.CHECK_NONE,\n+                },\n+                self._named_tempfile('check_CHECK_CRC256'): {\n+                    'format': 'csv',\n+                    'postprocessing': ['scrapy.extensions.postprocessing.LZMAPlugin'],\n+                    'lzma_check': lzma.CHECK_SHA256,\n+                },\n+            },\n+        }\n+\n+        data = yield self.exported_data(self.items, settings)\n+\n+        for filename, compressed in filename_to_compressed.items():\n+            result = lzma.decompress(data[filename])\n+            self.assertEqual(compressed, data[filename])\n+            self.assertEqual(self.expected, result)\n+\n+    @defer.inlineCallbacks\n+    def test_lzma_plugin_preset(self):\n+\n+        filename_to_compressed = {\n+            self._named_tempfile('preset_PRESET_0'): lzma.compress(self.expected, preset=0),\n+            self._named_tempfile('preset_PRESET_9'): lzma.compress(self.expected, preset=9),\n+        }\n+\n+        settings = {\n+            'FEEDS': {\n+                self._named_tempfile('preset_PRESET_0'): {\n+                    'format': 'csv',\n+                    'postprocessing': ['scrapy.extensions.postprocessing.LZMAPlugin'],\n+                    'lzma_preset': 0,\n+                },\n+                self._named_tempfile('preset_PRESET_9'): {\n+                    'format': 'csv',\n+                    'postprocessing': ['scrapy.extensions.postprocessing.LZMAPlugin'],\n+                    'lzma_preset': 9,\n+                },\n+            },\n+        }\n+\n+        data = yield self.exported_data(self.items, settings)\n+\n+        for filename, compressed in filename_to_compressed.items():\n+            result = lzma.decompress(data[filename])\n+            self.assertEqual(compressed, data[filename])\n+            self.assertEqual(self.expected, result)\n+\n+    @defer.inlineCallbacks\n+    def test_lzma_plugin_filters(self):\n+        import sys\n+        if \"PyPy\" in sys.version:\n+            pypy_version_str = sys.version.split('\\n')[1].split()[1]\n+            pypy_version = tuple(map(int, pypy_version_str.split(\".\")))\n+            if pypy_version <= (7, 3, 1):",
      "comment": "![image](https://user-images.githubusercontent.com/23308719/127197552-61b168cd-0f4c-460c-8cdf-060a277d0e5c.png)\r\n",
      "comment_id": 677642576,
      "user": "drs-11",
      "created_at": "2021-07-27T17:07:38Z",
      "url": "https://github.com/scrapy/scrapy/pull/5190#discussion_r677642576"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 5190,
      "file_path": "tests/test_feedexport.py",
      "line": 1772,
      "side": "RIGHT",
      "diff_hunk": "@@ -1469,6 +1472,502 @@ def test_extend_kwargs(self):\n             self.assertEqual(row['expected'], data[feed_options['format']])\n \n \n+class FeedPostProcessedExportsTest(FeedExportTestBase):\n+    __test__ = True\n+\n+    items = [{'foo': 'bar'}]\n+    expected = b'foo\\r\\nbar\\r\\n'\n+\n+    class MyPlugin1:\n+        def __init__(self, file, feed_options):\n+            self.file = file\n+            self.feed_options = feed_options\n+            self.char = self.feed_options.get('plugin1_char', b'')\n+\n+        def write(self, data):\n+            written_count = self.file.write(data)\n+            written_count += self.file.write(self.char)\n+            return written_count\n+\n+        def close(self):\n+            self.file.close()\n+\n+    def _named_tempfile(self, name):\n+        return os.path.join(self.temp_dir, name)\n+\n+    @defer.inlineCallbacks\n+    def run_and_export(self, spider_cls, settings):\n+        \"\"\" Run spider with specified settings; return exported data with filename. \"\"\"\n+\n+        FEEDS = settings.get('FEEDS') or {}\n+        settings['FEEDS'] = {\n+            printf_escape(path_to_url(file_path)): feed_options\n+            for file_path, feed_options in FEEDS.items()\n+        }\n+\n+        content = {}\n+        try:\n+            with MockServer() as s:\n+                runner = CrawlerRunner(Settings(settings))\n+                spider_cls.start_urls = [s.url('/')]\n+                yield runner.crawl(spider_cls)\n+\n+            for file_path, feed_options in FEEDS.items():\n+                if not os.path.exists(str(file_path)):\n+                    continue\n+\n+                with open(str(file_path), 'rb') as f:\n+                    content[str(file_path)] = f.read()\n+\n+        finally:\n+            for file_path in FEEDS.keys():\n+                if not os.path.exists(str(file_path)):\n+                    continue\n+\n+                os.remove(str(file_path))\n+\n+        return content\n+\n+    def get_gzip_compressed(self, data, compresslevel=9, mtime=0, filename=''):\n+        data_stream = BytesIO()\n+        gzipf = gzip.GzipFile(fileobj=data_stream, filename=filename, mtime=mtime,\n+                              compresslevel=compresslevel, mode=\"wb\")\n+        gzipf.write(data)\n+        gzipf.close()\n+        data_stream.seek(0)\n+        return data_stream.read()\n+\n+    @defer.inlineCallbacks\n+    def test_gzip_plugin(self):\n+\n+        filename = self._named_tempfile('gzip_file')\n+\n+        settings = {\n+            'FEEDS': {\n+                filename: {\n+                    'format': 'csv',\n+                    'postprocessing': ['scrapy.extensions.postprocessing.GzipPlugin'],\n+                },\n+            },\n+        }\n+\n+        data = yield self.exported_data(self.items, settings)\n+        try:\n+            gzip.decompress(data[filename])\n+        except OSError:\n+            self.fail(\"Received invalid gzip data.\")\n+\n+    @defer.inlineCallbacks\n+    def test_gzip_plugin_compresslevel(self):\n+\n+        filename_to_compressed = {\n+            self._named_tempfile('compresslevel_0'): self.get_gzip_compressed(self.expected, compresslevel=0),\n+            self._named_tempfile('compresslevel_9'): self.get_gzip_compressed(self.expected, compresslevel=9),\n+        }\n+\n+        settings = {\n+            'FEEDS': {\n+                self._named_tempfile('compresslevel_0'): {\n+                    'format': 'csv',\n+                    'postprocessing': ['scrapy.extensions.postprocessing.GzipPlugin'],\n+                    'gzip_compresslevel': 0,\n+                    'gzip_mtime': 0,\n+                    'gzip_filename': \"\",\n+                },\n+                self._named_tempfile('compresslevel_9'): {\n+                    'format': 'csv',\n+                    'postprocessing': ['scrapy.extensions.postprocessing.GzipPlugin'],\n+                    'gzip_compresslevel': 9,\n+                    'gzip_mtime': 0,\n+                    'gzip_filename': \"\",\n+                },\n+            },\n+        }\n+\n+        data = yield self.exported_data(self.items, settings)\n+\n+        for filename, compressed in filename_to_compressed.items():\n+            result = gzip.decompress(data[filename])\n+            self.assertEqual(compressed, data[filename])\n+            self.assertEqual(self.expected, result)\n+\n+    @defer.inlineCallbacks\n+    def test_gzip_plugin_mtime(self):\n+        filename_to_compressed = {\n+            self._named_tempfile('mtime_123'): self.get_gzip_compressed(self.expected, mtime=123),\n+            self._named_tempfile('mtime_123456789'): self.get_gzip_compressed(self.expected, mtime=123456789),\n+        }\n+\n+        settings = {\n+            'FEEDS': {\n+                self._named_tempfile('mtime_123'): {\n+                    'format': 'csv',\n+                    'postprocessing': ['scrapy.extensions.postprocessing.GzipPlugin'],\n+                    'gzip_mtime': 123,\n+                    'gzip_filename': \"\",\n+                },\n+                self._named_tempfile('mtime_123456789'): {\n+                    'format': 'csv',\n+                    'postprocessing': ['scrapy.extensions.postprocessing.GzipPlugin'],\n+                    'gzip_mtime': 123456789,\n+                    'gzip_filename': \"\",\n+                },\n+            },\n+        }\n+\n+        data = yield self.exported_data(self.items, settings)\n+\n+        for filename, compressed in filename_to_compressed.items():\n+            result = gzip.decompress(data[filename])\n+            self.assertEqual(compressed, data[filename])\n+            self.assertEqual(self.expected, result)\n+\n+    @defer.inlineCallbacks\n+    def test_gzip_plugin_filename(self):\n+        filename_to_compressed = {\n+            self._named_tempfile('filename_FILE1'): self.get_gzip_compressed(self.expected, filename=\"FILE1\"),\n+            self._named_tempfile('filename_FILE2'): self.get_gzip_compressed(self.expected, filename=\"FILE2\"),\n+        }\n+\n+        settings = {\n+            'FEEDS': {\n+                self._named_tempfile('filename_FILE1'): {\n+                    'format': 'csv',\n+                    'postprocessing': ['scrapy.extensions.postprocessing.GzipPlugin'],\n+                    'gzip_mtime': 0,\n+                    'gzip_filename': \"FILE1\",\n+                },\n+                self._named_tempfile('filename_FILE2'): {\n+                    'format': 'csv',\n+                    'postprocessing': ['scrapy.extensions.postprocessing.GzipPlugin'],\n+                    'gzip_mtime': 0,\n+                    'gzip_filename': \"FILE2\",\n+                },\n+            },\n+        }\n+\n+        data = yield self.exported_data(self.items, settings)\n+\n+        for filename, compressed in filename_to_compressed.items():\n+            result = gzip.decompress(data[filename])\n+            self.assertEqual(compressed, data[filename])\n+            self.assertEqual(self.expected, result)\n+\n+    @defer.inlineCallbacks\n+    def test_lzma_plugin(self):\n+\n+        filename = self._named_tempfile('lzma_file')\n+\n+        settings = {\n+            'FEEDS': {\n+                filename: {\n+                    'format': 'csv',\n+                    'postprocessing': ['scrapy.extensions.postprocessing.LZMAPlugin'],\n+                },\n+            },\n+        }\n+\n+        data = yield self.exported_data(self.items, settings)\n+        try:\n+            lzma.decompress(data[filename])\n+        except lzma.LZMAError:\n+            self.fail(\"Received invalid lzma data.\")\n+\n+    @defer.inlineCallbacks\n+    def test_lzma_plugin_format(self):\n+\n+        filename_to_compressed = {\n+            self._named_tempfile('format_FORMAT_XZ'): lzma.compress(self.expected, format=lzma.FORMAT_XZ),\n+            self._named_tempfile('format_FORMAT_ALONE'): lzma.compress(self.expected, format=lzma.FORMAT_ALONE),\n+        }\n+\n+        settings = {\n+            'FEEDS': {\n+                self._named_tempfile('format_FORMAT_XZ'): {\n+                    'format': 'csv',\n+                    'postprocessing': ['scrapy.extensions.postprocessing.LZMAPlugin'],\n+                    'lzma_format': lzma.FORMAT_XZ,\n+                },\n+                self._named_tempfile('format_FORMAT_ALONE'): {\n+                    'format': 'csv',\n+                    'postprocessing': ['scrapy.extensions.postprocessing.LZMAPlugin'],\n+                    'lzma_format': lzma.FORMAT_ALONE,\n+                },\n+            },\n+        }\n+\n+        data = yield self.exported_data(self.items, settings)\n+\n+        for filename, compressed in filename_to_compressed.items():\n+            result = lzma.decompress(data[filename])\n+            self.assertEqual(compressed, data[filename])\n+            self.assertEqual(self.expected, result)\n+\n+    @defer.inlineCallbacks\n+    def test_lzma_plugin_check(self):\n+\n+        filename_to_compressed = {\n+            self._named_tempfile('check_CHECK_NONE'): lzma.compress(self.expected, check=lzma.CHECK_NONE),\n+            self._named_tempfile('check_CHECK_CRC256'): lzma.compress(self.expected, check=lzma.CHECK_SHA256),\n+        }\n+\n+        settings = {\n+            'FEEDS': {\n+                self._named_tempfile('check_CHECK_NONE'): {\n+                    'format': 'csv',\n+                    'postprocessing': ['scrapy.extensions.postprocessing.LZMAPlugin'],\n+                    'lzma_check': lzma.CHECK_NONE,\n+                },\n+                self._named_tempfile('check_CHECK_CRC256'): {\n+                    'format': 'csv',\n+                    'postprocessing': ['scrapy.extensions.postprocessing.LZMAPlugin'],\n+                    'lzma_check': lzma.CHECK_SHA256,\n+                },\n+            },\n+        }\n+\n+        data = yield self.exported_data(self.items, settings)\n+\n+        for filename, compressed in filename_to_compressed.items():\n+            result = lzma.decompress(data[filename])\n+            self.assertEqual(compressed, data[filename])\n+            self.assertEqual(self.expected, result)\n+\n+    @defer.inlineCallbacks\n+    def test_lzma_plugin_preset(self):\n+\n+        filename_to_compressed = {\n+            self._named_tempfile('preset_PRESET_0'): lzma.compress(self.expected, preset=0),\n+            self._named_tempfile('preset_PRESET_9'): lzma.compress(self.expected, preset=9),\n+        }\n+\n+        settings = {\n+            'FEEDS': {\n+                self._named_tempfile('preset_PRESET_0'): {\n+                    'format': 'csv',\n+                    'postprocessing': ['scrapy.extensions.postprocessing.LZMAPlugin'],\n+                    'lzma_preset': 0,\n+                },\n+                self._named_tempfile('preset_PRESET_9'): {\n+                    'format': 'csv',\n+                    'postprocessing': ['scrapy.extensions.postprocessing.LZMAPlugin'],\n+                    'lzma_preset': 9,\n+                },\n+            },\n+        }\n+\n+        data = yield self.exported_data(self.items, settings)\n+\n+        for filename, compressed in filename_to_compressed.items():\n+            result = lzma.decompress(data[filename])\n+            self.assertEqual(compressed, data[filename])\n+            self.assertEqual(self.expected, result)\n+\n+    @defer.inlineCallbacks\n+    def test_lzma_plugin_filters(self):\n+        import sys\n+        if \"PyPy\" in sys.version:\n+            pypy_version_str = sys.version.split('\\n')[1].split()[1]\n+            pypy_version = tuple(map(int, pypy_version_str.split(\".\")))\n+            if pypy_version <= (7, 3, 1):",
      "comment": "`sys.version_info` returns the python version info not the pypy version and I couldn't find a simpler way to get pypy's version info.",
      "comment_id": 677643468,
      "user": "drs-11",
      "created_at": "2021-07-27T17:08:50Z",
      "url": "https://github.com/scrapy/scrapy/pull/5190#discussion_r677643468"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 5190,
      "file_path": "tests/test_feedexport.py",
      "line": 1772,
      "side": "RIGHT",
      "diff_hunk": "@@ -1469,6 +1472,502 @@ def test_extend_kwargs(self):\n             self.assertEqual(row['expected'], data[feed_options['format']])\n \n \n+class FeedPostProcessedExportsTest(FeedExportTestBase):\n+    __test__ = True\n+\n+    items = [{'foo': 'bar'}]\n+    expected = b'foo\\r\\nbar\\r\\n'\n+\n+    class MyPlugin1:\n+        def __init__(self, file, feed_options):\n+            self.file = file\n+            self.feed_options = feed_options\n+            self.char = self.feed_options.get('plugin1_char', b'')\n+\n+        def write(self, data):\n+            written_count = self.file.write(data)\n+            written_count += self.file.write(self.char)\n+            return written_count\n+\n+        def close(self):\n+            self.file.close()\n+\n+    def _named_tempfile(self, name):\n+        return os.path.join(self.temp_dir, name)\n+\n+    @defer.inlineCallbacks\n+    def run_and_export(self, spider_cls, settings):\n+        \"\"\" Run spider with specified settings; return exported data with filename. \"\"\"\n+\n+        FEEDS = settings.get('FEEDS') or {}\n+        settings['FEEDS'] = {\n+            printf_escape(path_to_url(file_path)): feed_options\n+            for file_path, feed_options in FEEDS.items()\n+        }\n+\n+        content = {}\n+        try:\n+            with MockServer() as s:\n+                runner = CrawlerRunner(Settings(settings))\n+                spider_cls.start_urls = [s.url('/')]\n+                yield runner.crawl(spider_cls)\n+\n+            for file_path, feed_options in FEEDS.items():\n+                if not os.path.exists(str(file_path)):\n+                    continue\n+\n+                with open(str(file_path), 'rb') as f:\n+                    content[str(file_path)] = f.read()\n+\n+        finally:\n+            for file_path in FEEDS.keys():\n+                if not os.path.exists(str(file_path)):\n+                    continue\n+\n+                os.remove(str(file_path))\n+\n+        return content\n+\n+    def get_gzip_compressed(self, data, compresslevel=9, mtime=0, filename=''):\n+        data_stream = BytesIO()\n+        gzipf = gzip.GzipFile(fileobj=data_stream, filename=filename, mtime=mtime,\n+                              compresslevel=compresslevel, mode=\"wb\")\n+        gzipf.write(data)\n+        gzipf.close()\n+        data_stream.seek(0)\n+        return data_stream.read()\n+\n+    @defer.inlineCallbacks\n+    def test_gzip_plugin(self):\n+\n+        filename = self._named_tempfile('gzip_file')\n+\n+        settings = {\n+            'FEEDS': {\n+                filename: {\n+                    'format': 'csv',\n+                    'postprocessing': ['scrapy.extensions.postprocessing.GzipPlugin'],\n+                },\n+            },\n+        }\n+\n+        data = yield self.exported_data(self.items, settings)\n+        try:\n+            gzip.decompress(data[filename])\n+        except OSError:\n+            self.fail(\"Received invalid gzip data.\")\n+\n+    @defer.inlineCallbacks\n+    def test_gzip_plugin_compresslevel(self):\n+\n+        filename_to_compressed = {\n+            self._named_tempfile('compresslevel_0'): self.get_gzip_compressed(self.expected, compresslevel=0),\n+            self._named_tempfile('compresslevel_9'): self.get_gzip_compressed(self.expected, compresslevel=9),\n+        }\n+\n+        settings = {\n+            'FEEDS': {\n+                self._named_tempfile('compresslevel_0'): {\n+                    'format': 'csv',\n+                    'postprocessing': ['scrapy.extensions.postprocessing.GzipPlugin'],\n+                    'gzip_compresslevel': 0,\n+                    'gzip_mtime': 0,\n+                    'gzip_filename': \"\",\n+                },\n+                self._named_tempfile('compresslevel_9'): {\n+                    'format': 'csv',\n+                    'postprocessing': ['scrapy.extensions.postprocessing.GzipPlugin'],\n+                    'gzip_compresslevel': 9,\n+                    'gzip_mtime': 0,\n+                    'gzip_filename': \"\",\n+                },\n+            },\n+        }\n+\n+        data = yield self.exported_data(self.items, settings)\n+\n+        for filename, compressed in filename_to_compressed.items():\n+            result = gzip.decompress(data[filename])\n+            self.assertEqual(compressed, data[filename])\n+            self.assertEqual(self.expected, result)\n+\n+    @defer.inlineCallbacks\n+    def test_gzip_plugin_mtime(self):\n+        filename_to_compressed = {\n+            self._named_tempfile('mtime_123'): self.get_gzip_compressed(self.expected, mtime=123),\n+            self._named_tempfile('mtime_123456789'): self.get_gzip_compressed(self.expected, mtime=123456789),\n+        }\n+\n+        settings = {\n+            'FEEDS': {\n+                self._named_tempfile('mtime_123'): {\n+                    'format': 'csv',\n+                    'postprocessing': ['scrapy.extensions.postprocessing.GzipPlugin'],\n+                    'gzip_mtime': 123,\n+                    'gzip_filename': \"\",\n+                },\n+                self._named_tempfile('mtime_123456789'): {\n+                    'format': 'csv',\n+                    'postprocessing': ['scrapy.extensions.postprocessing.GzipPlugin'],\n+                    'gzip_mtime': 123456789,\n+                    'gzip_filename': \"\",\n+                },\n+            },\n+        }\n+\n+        data = yield self.exported_data(self.items, settings)\n+\n+        for filename, compressed in filename_to_compressed.items():\n+            result = gzip.decompress(data[filename])\n+            self.assertEqual(compressed, data[filename])\n+            self.assertEqual(self.expected, result)\n+\n+    @defer.inlineCallbacks\n+    def test_gzip_plugin_filename(self):\n+        filename_to_compressed = {\n+            self._named_tempfile('filename_FILE1'): self.get_gzip_compressed(self.expected, filename=\"FILE1\"),\n+            self._named_tempfile('filename_FILE2'): self.get_gzip_compressed(self.expected, filename=\"FILE2\"),\n+        }\n+\n+        settings = {\n+            'FEEDS': {\n+                self._named_tempfile('filename_FILE1'): {\n+                    'format': 'csv',\n+                    'postprocessing': ['scrapy.extensions.postprocessing.GzipPlugin'],\n+                    'gzip_mtime': 0,\n+                    'gzip_filename': \"FILE1\",\n+                },\n+                self._named_tempfile('filename_FILE2'): {\n+                    'format': 'csv',\n+                    'postprocessing': ['scrapy.extensions.postprocessing.GzipPlugin'],\n+                    'gzip_mtime': 0,\n+                    'gzip_filename': \"FILE2\",\n+                },\n+            },\n+        }\n+\n+        data = yield self.exported_data(self.items, settings)\n+\n+        for filename, compressed in filename_to_compressed.items():\n+            result = gzip.decompress(data[filename])\n+            self.assertEqual(compressed, data[filename])\n+            self.assertEqual(self.expected, result)\n+\n+    @defer.inlineCallbacks\n+    def test_lzma_plugin(self):\n+\n+        filename = self._named_tempfile('lzma_file')\n+\n+        settings = {\n+            'FEEDS': {\n+                filename: {\n+                    'format': 'csv',\n+                    'postprocessing': ['scrapy.extensions.postprocessing.LZMAPlugin'],\n+                },\n+            },\n+        }\n+\n+        data = yield self.exported_data(self.items, settings)\n+        try:\n+            lzma.decompress(data[filename])\n+        except lzma.LZMAError:\n+            self.fail(\"Received invalid lzma data.\")\n+\n+    @defer.inlineCallbacks\n+    def test_lzma_plugin_format(self):\n+\n+        filename_to_compressed = {\n+            self._named_tempfile('format_FORMAT_XZ'): lzma.compress(self.expected, format=lzma.FORMAT_XZ),\n+            self._named_tempfile('format_FORMAT_ALONE'): lzma.compress(self.expected, format=lzma.FORMAT_ALONE),\n+        }\n+\n+        settings = {\n+            'FEEDS': {\n+                self._named_tempfile('format_FORMAT_XZ'): {\n+                    'format': 'csv',\n+                    'postprocessing': ['scrapy.extensions.postprocessing.LZMAPlugin'],\n+                    'lzma_format': lzma.FORMAT_XZ,\n+                },\n+                self._named_tempfile('format_FORMAT_ALONE'): {\n+                    'format': 'csv',\n+                    'postprocessing': ['scrapy.extensions.postprocessing.LZMAPlugin'],\n+                    'lzma_format': lzma.FORMAT_ALONE,\n+                },\n+            },\n+        }\n+\n+        data = yield self.exported_data(self.items, settings)\n+\n+        for filename, compressed in filename_to_compressed.items():\n+            result = lzma.decompress(data[filename])\n+            self.assertEqual(compressed, data[filename])\n+            self.assertEqual(self.expected, result)\n+\n+    @defer.inlineCallbacks\n+    def test_lzma_plugin_check(self):\n+\n+        filename_to_compressed = {\n+            self._named_tempfile('check_CHECK_NONE'): lzma.compress(self.expected, check=lzma.CHECK_NONE),\n+            self._named_tempfile('check_CHECK_CRC256'): lzma.compress(self.expected, check=lzma.CHECK_SHA256),\n+        }\n+\n+        settings = {\n+            'FEEDS': {\n+                self._named_tempfile('check_CHECK_NONE'): {\n+                    'format': 'csv',\n+                    'postprocessing': ['scrapy.extensions.postprocessing.LZMAPlugin'],\n+                    'lzma_check': lzma.CHECK_NONE,\n+                },\n+                self._named_tempfile('check_CHECK_CRC256'): {\n+                    'format': 'csv',\n+                    'postprocessing': ['scrapy.extensions.postprocessing.LZMAPlugin'],\n+                    'lzma_check': lzma.CHECK_SHA256,\n+                },\n+            },\n+        }\n+\n+        data = yield self.exported_data(self.items, settings)\n+\n+        for filename, compressed in filename_to_compressed.items():\n+            result = lzma.decompress(data[filename])\n+            self.assertEqual(compressed, data[filename])\n+            self.assertEqual(self.expected, result)\n+\n+    @defer.inlineCallbacks\n+    def test_lzma_plugin_preset(self):\n+\n+        filename_to_compressed = {\n+            self._named_tempfile('preset_PRESET_0'): lzma.compress(self.expected, preset=0),\n+            self._named_tempfile('preset_PRESET_9'): lzma.compress(self.expected, preset=9),\n+        }\n+\n+        settings = {\n+            'FEEDS': {\n+                self._named_tempfile('preset_PRESET_0'): {\n+                    'format': 'csv',\n+                    'postprocessing': ['scrapy.extensions.postprocessing.LZMAPlugin'],\n+                    'lzma_preset': 0,\n+                },\n+                self._named_tempfile('preset_PRESET_9'): {\n+                    'format': 'csv',\n+                    'postprocessing': ['scrapy.extensions.postprocessing.LZMAPlugin'],\n+                    'lzma_preset': 9,\n+                },\n+            },\n+        }\n+\n+        data = yield self.exported_data(self.items, settings)\n+\n+        for filename, compressed in filename_to_compressed.items():\n+            result = lzma.decompress(data[filename])\n+            self.assertEqual(compressed, data[filename])\n+            self.assertEqual(self.expected, result)\n+\n+    @defer.inlineCallbacks\n+    def test_lzma_plugin_filters(self):\n+        import sys\n+        if \"PyPy\" in sys.version:\n+            pypy_version_str = sys.version.split('\\n')[1].split()[1]\n+            pypy_version = tuple(map(int, pypy_version_str.split(\".\")))\n+            if pypy_version <= (7, 3, 1):",
      "comment": "Looks like it won't be needed now since we are skipping all pypy versions now.",
      "comment_id": 677646122,
      "user": "drs-11",
      "created_at": "2021-07-27T17:12:32Z",
      "url": "https://github.com/scrapy/scrapy/pull/5190#discussion_r677646122"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 4439,
      "file_path": "tests/test_commands.py",
      "line": 84,
      "side": "RIGHT",
      "diff_hunk": "@@ -79,6 +80,15 @@ def kill_proc():\n \n         return p, to_unicode(stdout), to_unicode(stderr)\n \n+    def find_in_file(self, filename, regex):\n+        '''Find first pattern occurrence in file'''",
      "comment": "```suggestion\r\n        \"\"\"Find first pattern occurrence in file\"\"\"\r\n```\r\n\r\n:lipstick: I think this is the only area were PEP8 actually makes a choice between `'` and `\"` :slightly_smiling_face: ",
      "comment_id": 396514605,
      "user": "Gallaecio",
      "created_at": "2020-03-23T14:58:06Z",
      "url": "https://github.com/scrapy/scrapy/pull/4439#discussion_r396514605"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 4439,
      "file_path": "tests/test_commands.py",
      "line": 8,
      "side": "RIGHT",
      "diff_hunk": "@@ -5,6 +5,7 @@\n import subprocess\n import sys\n import tempfile\n+import re",
      "comment": ":lipstick: Let\u2019s keep the imports sorted alphabetically.\r\n\r\n```suggestion\r\nimport re\r\nimport subprocess\r\nimport sys\r\nimport tempfile\r\n```",
      "comment_id": 396515287,
      "user": "Gallaecio",
      "created_at": "2020-03-23T14:58:58Z",
      "url": "https://github.com/scrapy/scrapy/pull/4439#discussion_r396515287"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 4178,
      "file_path": "scrapy/spiders/__init__.py",
      "line": 64,
      "side": "RIGHT",
      "diff_hunk": "@@ -57,24 +54,8 @@ def _set_crawler(self, crawler):\n         crawler.signals.connect(self.close, signals.spider_closed)\n \n     def start_requests(self):\n-        cls = self.__class__\n-        if method_is_overridden(cls, Spider, 'make_requests_from_url'):\n-            warnings.warn(\n-                \"Spider.make_requests_from_url method is deprecated; it \"\n-                \"won't be called in future Scrapy releases. Please \"\n-                \"override Spider.start_requests method instead (see %s.%s).\" % (\n-                    cls.__module__, cls.__name__\n-                ),\n-            )\n-            for url in self.start_urls:\n-                yield self.make_requests_from_url(url)\n-        else:\n-            for url in self.start_urls:\n-                yield Request(url, dont_filter=True)\n-\n-    def make_requests_from_url(self, url):\n-        \"\"\" This method is deprecated. \"\"\"\n-        return Request(url, dont_filter=True)\n+        for url in self.start_urls:\n+            yield Request(url, dont_filter=True)",
      "comment": "There is a problem in a way we deprecated `make_requests_from_url` method: if user calls this method to construct a Request, no deprecation warning is raised. This may happen in overridden start_requests, or in any other callback. \r\n\r\nSo it looks like it was never properly deprecated :( A common case was handled, but people were using it in a different way as well (as shown by our internal codesearch tool). \r\n\r\nI'm not sure what to do, but have a slight preference for starting to raise warnings in the `make_requests_from_url` method, instead of removing it. If we do this, it is probably better to keep compatibility code in start_requests as well: it seems that removing its usage in start_requests without removing the method itself can lead to unnoticed bugs in user code.",
      "comment_id": 349251133,
      "user": "kmike",
      "created_at": "2019-11-21T18:35:19Z",
      "url": "https://github.com/scrapy/scrapy/pull/4178#discussion_r349251133"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 4178,
      "file_path": "scrapy/spiders/__init__.py",
      "line": 64,
      "side": "RIGHT",
      "diff_hunk": "@@ -57,24 +54,8 @@ def _set_crawler(self, crawler):\n         crawler.signals.connect(self.close, signals.spider_closed)\n \n     def start_requests(self):\n-        cls = self.__class__\n-        if method_is_overridden(cls, Spider, 'make_requests_from_url'):\n-            warnings.warn(\n-                \"Spider.make_requests_from_url method is deprecated; it \"\n-                \"won't be called in future Scrapy releases. Please \"\n-                \"override Spider.start_requests method instead (see %s.%s).\" % (\n-                    cls.__module__, cls.__name__\n-                ),\n-            )\n-            for url in self.start_urls:\n-                yield self.make_requests_from_url(url)\n-        else:\n-            for url in self.start_urls:\n-                yield Request(url, dont_filter=True)\n-\n-    def make_requests_from_url(self, url):\n-        \"\"\" This method is deprecated. \"\"\"\n-        return Request(url, dont_filter=True)\n+        for url in self.start_urls:\n+            yield Request(url, dont_filter=True)",
      "comment": "I see your point, but I wonder if that isn't the right thing to do. I believe this is similar to https://github.com/scrapy/scrapy/pull/4170#issuecomment-556033732, in the sense that we shouldn't prevent users from defining any method they want in their spiders. My interpretation is that the deprecation meant the method would cease to be used from the _default_ `start_requests` implementation. Thoughts?",
      "comment_id": 349623810,
      "user": "elacuesta",
      "created_at": "2019-11-22T14:32:34Z",
      "url": "https://github.com/scrapy/scrapy/pull/4178#discussion_r349623810"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 4318,
      "file_path": "scrapy/utils/spider.py",
      "line": 17,
      "side": "RIGHT",
      "diff_hunk": "@@ -4,12 +4,20 @@\n from scrapy.spiders import Spider\n from scrapy.utils.defer import deferred_from_coro\n from scrapy.utils.misc import arg_to_iter\n+try:\n+    from scrapy.utils.py36 import collect_asyncgen\n+except SyntaxError:\n+    collect_asyncgen = None\n \n \n logger = logging.getLogger(__name__)\n \n \n def iterate_spider_output(result):\n+    if collect_asyncgen and hasattr(inspect, 'isasyncgen') and inspect.isasyncgen(result):",
      "comment": "~~Could you please add a comment here, something like \"workaround to support async generators in Python 3.6\"?~~",
      "comment_id": 376537828,
      "user": "kmike",
      "created_at": "2020-02-07T18:24:50Z",
      "url": "https://github.com/scrapy/scrapy/pull/4318#discussion_r376537828"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 4318,
      "file_path": "tests/py36/_test_crawl.py",
      "line": 48,
      "side": "RIGHT",
      "diff_hunk": "@@ -0,0 +1,50 @@\n+import asyncio\n+\n+from scrapy import Request\n+from tests.spiders import SimpleSpider\n+\n+\n+class AsyncDefAsyncioGenSpider(SimpleSpider):\n+\n+    name = 'asyncdef_asyncio_gen'\n+\n+    async def parse(self, response):\n+        await asyncio.sleep(0.2)\n+        yield {'foo': 42}\n+        self.logger.info(\"Got response %d\" % response.status)\n+\n+\n+class AsyncDefAsyncioGenLoopSpider(SimpleSpider):\n+\n+    name = 'asyncdef_asyncio_gen_loop'\n+\n+    async def parse(self, response):\n+        for i in range(10):\n+            await asyncio.sleep(0.1)\n+            yield {'foo': i}\n+        self.logger.info(\"Got response %d\" % response.status)\n+\n+\n+class AsyncDefAsyncioGenComplexSpider(SimpleSpider):\n+\n+    name = 'asyncdef_asyncio_gen_complex'\n+    initial_reqs = 4\n+    following_reqs = 3\n+    depth = 2\n+\n+    def _get_req(self, index):\n+        return Request(self.mockserver.url(\"/status?n=200&request=%d\" % index),\n+                       meta={'index': index})\n+\n+    def start_requests(self):\n+        for i in range(self.initial_reqs):\n+            yield self._get_req(i)\n+\n+    async def parse(self, response):\n+        index = response.meta['index']\n+        yield {'index': index}\n+        if index < 10 ** self.depth:\n+            for new_index in range(10 * index, 10 * index + self.following_reqs):\n+                yield self._get_req(new_index)",
      "comment": "For paranoid me: could you please check that non-default callback also works, and that async def works for methods other than parse?",
      "comment_id": 376540830,
      "user": "kmike",
      "created_at": "2020-02-07T18:31:20Z",
      "url": "https://github.com/scrapy/scrapy/pull/4318#discussion_r376540830"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 4271,
      "file_path": "scrapy/utils/defer.py",
      "line": 149,
      "side": "RIGHT",
      "diff_hunk": "@@ -140,3 +140,20 @@ def deferred_from_coro(o):\n             # wrapping the coroutine into a Future and then into a Deferred, this requires AsyncioSelectorReactor\n             return defer.Deferred.fromFuture(asyncio.ensure_future(o))\n     return o\n+\n+\n+def maybeDeferred_coro(f, *args, **kw):\n+    \"\"\" Copy of defer.maybeDeferred that also converts coroutines to Deferreds. \"\"\"\n+    try:\n+        result = f(*args, **kw)\n+    except:  # noqa: E722",
      "comment": "Shouldn\u2019t this at least be `except Exception`, to avoid things like catching a `KeyboardInterrupt`?",
      "comment_id": 365172374,
      "user": "Gallaecio",
      "created_at": "2020-01-10T10:38:51Z",
      "url": "https://github.com/scrapy/scrapy/pull/4271#discussion_r365172374"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 4271,
      "file_path": "scrapy/utils/defer.py",
      "line": 149,
      "side": "RIGHT",
      "diff_hunk": "@@ -140,3 +140,20 @@ def deferred_from_coro(o):\n             # wrapping the coroutine into a Future and then into a Deferred, this requires AsyncioSelectorReactor\n             return defer.Deferred.fromFuture(asyncio.ensure_future(o))\n     return o\n+\n+\n+def maybeDeferred_coro(f, *args, **kw):\n+    \"\"\" Copy of defer.maybeDeferred that also converts coroutines to Deferreds. \"\"\"\n+    try:\n+        result = f(*args, **kw)\n+    except:  # noqa: E722",
      "comment": "I guess `defer.fail` will capture whatever exception to be properly processed where it must be processed.",
      "comment_id": 365181485,
      "user": "Gallaecio",
      "created_at": "2020-01-10T11:00:53Z",
      "url": "https://github.com/scrapy/scrapy/pull/4271#discussion_r365181485"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 4271,
      "file_path": "tests/test_utils_signal.py",
      "line": 87,
      "side": "RIGHT",
      "diff_hunk": "@@ -63,8 +67,24 @@ def ok_handler(self, arg, handlers_called):\n         reactor.callLater(0, d.callback, \"OK\")\n         return d\n \n-    def _get_result(self, signal, *a, **kw):\n-        return send_catch_log_deferred(signal, *a, **kw)\n+\n+class SendCatchLogDeferredAsyncDefTest(SendCatchLogDeferredTest):\n+\n+    async def ok_handler(self, arg, handlers_called):\n+        handlers_called.add(self.ok_handler)\n+        assert arg == 'test'\n+        await defer.succeed(42)\n+        return \"OK\"\n+\n+\n+@mark.only_asyncio()\n+class SendCatchLogDeferredAsyncioTest(SendCatchLogDeferredTest):\n+\n+    async def ok_handler(self, arg, handlers_called):\n+        handlers_called.add(self.ok_handler)\n+        assert arg == 'test'\n+        await asyncio.sleep(0.2)\n+        return await get_from_asyncio_queue(\"OK\")",
      "comment": "Could you please add integration-style test for this feature, maybe not to this module? Take some real signal which Scrapy is sending, implement async def callback for it, check that it works.",
      "comment_id": 367144070,
      "user": "kmike",
      "created_at": "2020-01-15T22:36:14Z",
      "url": "https://github.com/scrapy/scrapy/pull/4271#discussion_r367144070"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 4271,
      "file_path": "tests/test_utils_signal.py",
      "line": 87,
      "side": "RIGHT",
      "diff_hunk": "@@ -63,8 +67,24 @@ def ok_handler(self, arg, handlers_called):\n         reactor.callLater(0, d.callback, \"OK\")\n         return d\n \n-    def _get_result(self, signal, *a, **kw):\n-        return send_catch_log_deferred(signal, *a, **kw)\n+\n+class SendCatchLogDeferredAsyncDefTest(SendCatchLogDeferredTest):\n+\n+    async def ok_handler(self, arg, handlers_called):\n+        handlers_called.add(self.ok_handler)\n+        assert arg == 'test'\n+        await defer.succeed(42)\n+        return \"OK\"\n+\n+\n+@mark.only_asyncio()\n+class SendCatchLogDeferredAsyncioTest(SendCatchLogDeferredTest):\n+\n+    async def ok_handler(self, arg, handlers_called):\n+        handlers_called.add(self.ok_handler)\n+        assert arg == 'test'\n+        await asyncio.sleep(0.2)\n+        return await get_from_asyncio_queue(\"OK\")",
      "comment": "I looked at the async-enabled signals and how are they used. There seem to be two groups.\r\n\r\n`item_scraped`, `item_dropped`, `item_error`: these are related to `Scraper._itemproc_finished` but as far as I can see the result of that function is ignored and nothing waits for those signal handlers to finish, but I may be wrong.\r\n\r\n`engine_started`, `engine_stopped`, `spider_opened`, `spider_closed`: these are included in the spider/engine startup/shutdown processes and the process waits for the handler to finish.",
      "comment_id": 373099559,
      "user": "wRAR",
      "created_at": "2020-01-30T17:51:03Z",
      "url": "https://github.com/scrapy/scrapy/pull/4271#discussion_r373099559"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 4270,
      "file_path": "scrapy/utils/defer.py",
      "line": 5,
      "side": "RIGHT",
      "diff_hunk": "@@ -2,6 +2,7 @@\n Helper functions for dealing with Twisted deferreds\n \"\"\"\n import asyncio\n+from functools import wraps",
      "comment": "I like @Gallaecio's style proposal a bit more than what's in the code. Merging PR anyways, this is not a blocker.",
      "comment_id": 367141031,
      "user": "kmike",
      "created_at": "2020-01-15T22:28:05Z",
      "url": "https://github.com/scrapy/scrapy/pull/4270#discussion_r367141031"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 4269,
      "file_path": "tests/spiders.py",
      "line": 117,
      "side": "RIGHT",
      "diff_hunk": "@@ -83,6 +87,36 @@ def parse(self, response):\n         self.logger.info(\"Got response %d\" % response.status)\n \n \n+class AsyncDefSpider(SimpleSpider):\n+\n+    name = 'asyncdef'\n+\n+    async def parse(self, response):\n+        await defer.succeed(42)\n+        self.logger.info(\"Got response %d\" % response.status)\n+\n+\n+class AsyncDefAsyncioSpider(SimpleSpider):\n+\n+    name = 'asyncdef_asyncio'\n+\n+    async def parse(self, response):\n+        await asyncio.sleep(0.2)\n+        status = await get_from_asyncio_queue(response.status)\n+        self.logger.info(\"Got response %d\" % status)\n+\n+\n+class AsyncDefAsyncioReturnSpider(SimpleSpider):\n+\n+    name = 'asyncdef_asyncio_return'\n+\n+    async def parse(self, response):\n+        await asyncio.sleep(0.2)\n+        status = await get_from_asyncio_queue(response.status)\n+        self.logger.info(\"Got response %d\" % status)\n+        return [{'id': 1}, {'id': 2}]",
      "comment": "Nice, so lists of items are supported. What about requests?",
      "comment_id": 373117947,
      "user": "kmike",
      "created_at": "2020-01-30T18:29:04Z",
      "url": "https://github.com/scrapy/scrapy/pull/4269#discussion_r373117947"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 4259,
      "file_path": "scrapy/utils/defer.py",
      "line": 127,
      "side": "RIGHT",
      "diff_hunk": "@@ -114,3 +118,25 @@ def iter_errback(iterable, errback, *a, **kw):\n             break\n         except Exception:\n             errback(failure.Failure(), *a, **kw)\n+\n+\n+def _isfuture(o):\n+    # workaround for Python before 3.5.3 not having asyncio.isfuture\n+    if hasattr(asyncio, 'isfuture'):\n+        return asyncio.isfuture(o)\n+    return isinstance(o, asyncio.Future)",
      "comment": "If the [coverage data](https://codecov.io/gh/scrapy/scrapy/pull/4259/diff#D2-123) is correct, `_isfuture` could be replaced by `asyncio.isfuture` and work the same. I wonder what the best approach here would be. Maybe we should just use `asyncio.isfuture`.\r\n\r\nIf we need to exclude future-like content that are not `Future` instances, such as `Task` instances, I think we may need a more complex check.",
      "comment_id": 361920475,
      "user": "Gallaecio",
      "created_at": "2019-12-30T08:03:53Z",
      "url": "https://github.com/scrapy/scrapy/pull/4259#discussion_r361920475"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 4259,
      "file_path": "tests/test_downloadermiddleware.py",
      "line": 242,
      "side": "RIGHT",
      "diff_hunk": "@@ -206,3 +209,46 @@ def process_request(self, request, spider):\n \n         self.assertIs(results[0], resp)\n         self.assertFalse(download_func.called)\n+\n+\n+class MiddlewareUsingCoro(ManagerTestCase):\n+    \"\"\"Middlewares using asyncio coroutines should work\"\"\"\n+\n+    def test_asyncdef(self):\n+        resp = Response('http://example.com/index.html')\n+\n+        class CoroMiddleware:\n+            async def process_request(self, request, spider):\n+                await defer.succeed(42)\n+                return resp\n+\n+        self.mwman._add_middleware(CoroMiddleware())\n+        req = Request('http://example.com/index.html')\n+        download_func = mock.MagicMock()\n+        dfd = self.mwman.download(download_func, req, self.spider)\n+        results = []\n+        dfd.addBoth(results.append)\n+        self._wait(dfd)\n+\n+        self.assertIs(results[0], resp)\n+        self.assertFalse(download_func.called)\n+\n+    @mark.only_asyncio()\n+    def test_asyncdef_asyncio(self):\n+        resp = Response('http://example.com/index.html')\n+\n+        class CoroMiddleware:\n+            async def process_request(self, request, spider):\n+                await asyncio.sleep(0.1)",
      "comment": "Could you please also add a test where some result is awaited?",
      "comment_id": 361937138,
      "user": "kmike",
      "created_at": "2019-12-30T09:27:54Z",
      "url": "https://github.com/scrapy/scrapy/pull/4259#discussion_r361937138"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 4259,
      "file_path": "tests/test_downloadermiddleware.py",
      "line": 242,
      "side": "RIGHT",
      "diff_hunk": "@@ -206,3 +209,46 @@ def process_request(self, request, spider):\n \n         self.assertIs(results[0], resp)\n         self.assertFalse(download_func.called)\n+\n+\n+class MiddlewareUsingCoro(ManagerTestCase):\n+    \"\"\"Middlewares using asyncio coroutines should work\"\"\"\n+\n+    def test_asyncdef(self):\n+        resp = Response('http://example.com/index.html')\n+\n+        class CoroMiddleware:\n+            async def process_request(self, request, spider):\n+                await defer.succeed(42)\n+                return resp\n+\n+        self.mwman._add_middleware(CoroMiddleware())\n+        req = Request('http://example.com/index.html')\n+        download_func = mock.MagicMock()\n+        dfd = self.mwman.download(download_func, req, self.spider)\n+        results = []\n+        dfd.addBoth(results.append)\n+        self._wait(dfd)\n+\n+        self.assertIs(results[0], resp)\n+        self.assertFalse(download_func.called)\n+\n+    @mark.only_asyncio()\n+    def test_asyncdef_asyncio(self):\n+        resp = Response('http://example.com/index.html')\n+\n+        class CoroMiddleware:\n+            async def process_request(self, request, spider):\n+                await asyncio.sleep(0.1)",
      "comment": "Such as?\r\nLooks like asyncio without 3rd-party modules supports async networking, queues and subprocesses, not sure if anything else. Or you can create a Task and manage it.\r\nWe would also want similar code in all other asyncio testcases?",
      "comment_id": 362011138,
      "user": "wRAR",
      "created_at": "2019-12-30T15:11:44Z",
      "url": "https://github.com/scrapy/scrapy/pull/4259#discussion_r362011138"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 4259,
      "file_path": "tests/test_downloadermiddleware.py",
      "line": 242,
      "side": "RIGHT",
      "diff_hunk": "@@ -206,3 +209,46 @@ def process_request(self, request, spider):\n \n         self.assertIs(results[0], resp)\n         self.assertFalse(download_func.called)\n+\n+\n+class MiddlewareUsingCoro(ManagerTestCase):\n+    \"\"\"Middlewares using asyncio coroutines should work\"\"\"\n+\n+    def test_asyncdef(self):\n+        resp = Response('http://example.com/index.html')\n+\n+        class CoroMiddleware:\n+            async def process_request(self, request, spider):\n+                await defer.succeed(42)\n+                return resp\n+\n+        self.mwman._add_middleware(CoroMiddleware())\n+        req = Request('http://example.com/index.html')\n+        download_func = mock.MagicMock()\n+        dfd = self.mwman.download(download_func, req, self.spider)\n+        results = []\n+        dfd.addBoth(results.append)\n+        self._wait(dfd)\n+\n+        self.assertIs(results[0], resp)\n+        self.assertFalse(download_func.called)\n+\n+    @mark.only_asyncio()\n+    def test_asyncdef_asyncio(self):\n+        resp = Response('http://example.com/index.html')\n+\n+        class CoroMiddleware:\n+            async def process_request(self, request, spider):\n+                await asyncio.sleep(0.1)",
      "comment": "I'm not sure which library to use and what action to perform exactly, but we need to test that results work - getting something from DB or making a HTTP request can be a standard use case for async def methods. If it is not easy to set something up using stdlib, that's fine to have additional requirements (e.g. aiohttp). That said, it should be possible to implement something using subprocess or queue.",
      "comment_id": 362111985,
      "user": "kmike",
      "created_at": "2019-12-30T22:30:31Z",
      "url": "https://github.com/scrapy/scrapy/pull/4259#discussion_r362111985"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 4259,
      "file_path": "scrapy/utils/defer.py",
      "line": 127,
      "side": "RIGHT",
      "diff_hunk": "@@ -114,3 +118,25 @@ def iter_errback(iterable, errback, *a, **kw):\n             break\n         except Exception:\n             errback(failure.Failure(), *a, **kw)\n+\n+\n+def _isfuture(o):\n+    # workaround for Python before 3.5.3 not having asyncio.isfuture\n+    if hasattr(asyncio, 'isfuture'):\n+        return asyncio.isfuture(o)\n+    return isinstance(o, asyncio.Future)",
      "comment": ":man_facepalming: \r\n\r\n:thinking: I think we should either [change that](https://github.com/scrapy/scrapy/pull/4261) or not bother supporting 3.5.3-.",
      "comment_id": 362192545,
      "user": "Gallaecio",
      "created_at": "2019-12-31T10:43:44Z",
      "url": "https://github.com/scrapy/scrapy/pull/4259#discussion_r362192545"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 4259,
      "file_path": "scrapy/utils/defer.py",
      "line": 127,
      "side": "RIGHT",
      "diff_hunk": "@@ -114,3 +118,25 @@ def iter_errback(iterable, errback, *a, **kw):\n             break\n         except Exception:\n             errback(failure.Failure(), *a, **kw)\n+\n+\n+def _isfuture(o):\n+    # workaround for Python before 3.5.3 not having asyncio.isfuture\n+    if hasattr(asyncio, 'isfuture'):\n+        return asyncio.isfuture(o)\n+    return isinstance(o, asyncio.Future)",
      "comment": "Yup.\r\nMy only concern is that the current Python3 version in Ubuntu 16.04 LTS is 3.5.2. Though I couldn't find how to make travis actually use the system Python3.",
      "comment_id": 362192958,
      "user": "wRAR",
      "created_at": "2019-12-31T10:46:43Z",
      "url": "https://github.com/scrapy/scrapy/pull/4259#discussion_r362192958"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 4259,
      "file_path": "tests/test_downloadermiddleware.py",
      "line": 242,
      "side": "RIGHT",
      "diff_hunk": "@@ -206,3 +209,46 @@ def process_request(self, request, spider):\n \n         self.assertIs(results[0], resp)\n         self.assertFalse(download_func.called)\n+\n+\n+class MiddlewareUsingCoro(ManagerTestCase):\n+    \"\"\"Middlewares using asyncio coroutines should work\"\"\"\n+\n+    def test_asyncdef(self):\n+        resp = Response('http://example.com/index.html')\n+\n+        class CoroMiddleware:\n+            async def process_request(self, request, spider):\n+                await defer.succeed(42)\n+                return resp\n+\n+        self.mwman._add_middleware(CoroMiddleware())\n+        req = Request('http://example.com/index.html')\n+        download_func = mock.MagicMock()\n+        dfd = self.mwman.download(download_func, req, self.spider)\n+        results = []\n+        dfd.addBoth(results.append)\n+        self._wait(dfd)\n+\n+        self.assertIs(results[0], resp)\n+        self.assertFalse(download_func.called)\n+\n+    @mark.only_asyncio()\n+    def test_asyncdef_asyncio(self):\n+        resp = Response('http://example.com/index.html')\n+\n+        class CoroMiddleware:\n+            async def process_request(self, request, spider):\n+                await asyncio.sleep(0.1)",
      "comment": "I've added a Queue with sync put and async get, it's not very interesting though, let me know if we should use something heavier.",
      "comment_id": 362210903,
      "user": "wRAR",
      "created_at": "2019-12-31T12:55:59Z",
      "url": "https://github.com/scrapy/scrapy/pull/4259#discussion_r362210903"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 4259,
      "file_path": "scrapy/utils/defer.py",
      "line": 127,
      "side": "RIGHT",
      "diff_hunk": "@@ -114,3 +118,25 @@ def iter_errback(iterable, errback, *a, **kw):\n             break\n         except Exception:\n             errback(failure.Failure(), *a, **kw)\n+\n+\n+def _isfuture(o):\n+    # workaround for Python before 3.5.3 not having asyncio.isfuture\n+    if hasattr(asyncio, 'isfuture'):\n+        return asyncio.isfuture(o)\n+    return isinstance(o, asyncio.Future)",
      "comment": "The proxy_connect tests will fail. In https://github.com/scrapy/scrapy/pull/4261 I\u2019ve installed 3.5.0, and it works, but I\u2019ve had to skip mitmproxy-based tests, as for Python 3.5.3 and earlier you need to use mitmproxy 2, and even after updating the command-line parameters accordingly I got timeouts.",
      "comment_id": 362224189,
      "user": "Gallaecio",
      "created_at": "2019-12-31T14:25:49Z",
      "url": "https://github.com/scrapy/scrapy/pull/4259#discussion_r362224189"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 4259,
      "file_path": "scrapy/utils/defer.py",
      "line": 127,
      "side": "RIGHT",
      "diff_hunk": "@@ -114,3 +118,25 @@ def iter_errback(iterable, errback, *a, **kw):\n             break\n         except Exception:\n             errback(failure.Failure(), *a, **kw)\n+\n+\n+def _isfuture(o):\n+    # workaround for Python before 3.5.3 not having asyncio.isfuture\n+    if hasattr(asyncio, 'isfuture'):\n+        return asyncio.isfuture(o)\n+    return isinstance(o, asyncio.Future)",
      "comment": "Yet https://travis-ci.org/scrapy/scrapy/jobs/631286391 worked with 3.5.2 ",
      "comment_id": 362228655,
      "user": "wRAR",
      "created_at": "2019-12-31T14:53:52Z",
      "url": "https://github.com/scrapy/scrapy/pull/4259#discussion_r362228655"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 4010,
      "file_path": "scrapy/utils/defer.py",
      "line": 127,
      "side": "RIGHT",
      "diff_hunk": "@@ -104,3 +109,21 @@ def iter_errback(iterable, errback, *a, **kw):\n             break\n         except Exception:\n             errback(failure.Failure(), *a, **kw)\n+\n+\n+def isfuture(o):\n+    # workaround for Python before 3.5.3 not having asyncio.isfuture\n+    if hasattr(asyncio, 'isfuture'):\n+        return asyncio.isfuture(o)\n+    return isinstance(o, asyncio.futures.Future)\n+\n+\n+def deferred_from_coro(o):\n+    \"\"\"Converts a coroutine into a Deferred, or returns the object as is if it isn't a coroutine\"\"\"\n+    if isinstance(o, defer.Deferred):\n+        return o\n+    if asyncio.iscoroutine(o) or isfuture(o) or inspect.isawaitable(o):\n+        if not is_asyncio_supported():\n+            raise TypeError('Using coroutines requires installing AsyncioSelectorReactor')",
      "comment": "One of the main points I took from [this blog post](https://snarky.ca/how-the-heck-does-async-await-work-in-python-3-5/#thinkofasyncawaitasanapiforasynchronousprogramming) is that \"`async/await` is really an API for asynchronous programming\". Based on that and considering that using a different reactor is a big change, I'm wondering: would it be possible to support `async def` coroutines without the need to install the `asyncio`-based reactor?",
      "comment_id": 323879849,
      "user": "elacuesta",
      "created_at": "2019-09-12T18:11:01Z",
      "url": "https://github.com/scrapy/scrapy/pull/4010#discussion_r323879849"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 4010,
      "file_path": "scrapy/utils/defer.py",
      "line": 127,
      "side": "RIGHT",
      "diff_hunk": "@@ -104,3 +109,21 @@ def iter_errback(iterable, errback, *a, **kw):\n             break\n         except Exception:\n             errback(failure.Failure(), *a, **kw)\n+\n+\n+def isfuture(o):\n+    # workaround for Python before 3.5.3 not having asyncio.isfuture\n+    if hasattr(asyncio, 'isfuture'):\n+        return asyncio.isfuture(o)\n+    return isinstance(o, asyncio.futures.Future)\n+\n+\n+def deferred_from_coro(o):\n+    \"\"\"Converts a coroutine into a Deferred, or returns the object as is if it isn't a coroutine\"\"\"\n+    if isinstance(o, defer.Deferred):\n+        return o\n+    if asyncio.iscoroutine(o) or isfuture(o) or inspect.isawaitable(o):\n+        if not is_asyncio_supported():\n+            raise TypeError('Using coroutines requires installing AsyncioSelectorReactor')",
      "comment": "@elacuesta yes, and it's as easy as changing this to `return defer.ensureDeferred(o)`. But we can't detect asyncio-needing coroutines at the run time to give a nice error. This is something I wanted to discuss with @kmike one day.",
      "comment_id": 323889298,
      "user": "wRAR",
      "created_at": "2019-09-12T18:32:32Z",
      "url": "https://github.com/scrapy/scrapy/pull/4010#discussion_r323889298"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 4010,
      "file_path": "scrapy/utils/asyncio.py",
      "line": 4,
      "side": "RIGHT",
      "diff_hunk": "@@ -0,0 +1,23 @@\n+def install_asyncio_reactor():\n+    \"\"\" Tries to install AsyncioSelectorReactor\n+    \"\"\"\n+    try:",
      "comment": "Could you refactor these `except: pass` ocurrences to use [`contextlib.suppress`](https://docs.python.org/3/library/contextlib.html#contextlib.suppress)?",
      "comment_id": 353901109,
      "user": "elacuesta",
      "created_at": "2019-12-04T18:11:09Z",
      "url": "https://github.com/scrapy/scrapy/pull/4010#discussion_r353901109"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 4010,
      "file_path": "scrapy/utils/asyncio.py",
      "line": 8,
      "side": "RIGHT",
      "diff_hunk": "@@ -0,0 +1,23 @@\n+def install_asyncio_reactor():\n+    \"\"\" Tries to install AsyncioSelectorReactor\n+    \"\"\"\n+    try:\n+        import asyncio\n+        from twisted.internet import asyncioreactor\n+    except ImportError:\n+        pass",
      "comment": "If asyncio is explicitly requested but not available, shouldn\u2019t we raise an Exception (maybe let the `ImportError` raise) or at the very least log an error?\r\n\r\nOr is this better done from the calling code instead?",
      "comment_id": 354159025,
      "user": "Gallaecio",
      "created_at": "2019-12-05T08:14:07Z",
      "url": "https://github.com/scrapy/scrapy/pull/4010#discussion_r354159025"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 4010,
      "file_path": "scrapy/utils/asyncio.py",
      "line": 14,
      "side": "RIGHT",
      "diff_hunk": "@@ -0,0 +1,23 @@\n+def install_asyncio_reactor():\n+    \"\"\" Tries to install AsyncioSelectorReactor\n+    \"\"\"\n+    try:\n+        import asyncio\n+        from twisted.internet import asyncioreactor\n+    except ImportError:\n+        pass\n+    else:\n+        from twisted.internet.error import ReactorAlreadyInstalledError\n+        try:\n+            asyncioreactor.install(asyncio.get_event_loop())\n+        except ReactorAlreadyInstalledError:\n+            pass",
      "comment": "Similar here. Shoudn\u2019t we call `is_asyncio_reactor_installed` here and raise or log something if the installed reactor does not provide asyncio support? (assuming we can check for this, I\u2019m guessing an alternative asyncio reactor that does not inherit from the one we use may be a problem)",
      "comment_id": 354161905,
      "user": "Gallaecio",
      "created_at": "2019-12-05T08:21:57Z",
      "url": "https://github.com/scrapy/scrapy/pull/4010#discussion_r354161905"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 4010,
      "file_path": "scrapy/utils/asyncio.py",
      "line": 4,
      "side": "RIGHT",
      "diff_hunk": "@@ -0,0 +1,23 @@\n+def install_asyncio_reactor():\n+    \"\"\" Tries to install AsyncioSelectorReactor\n+    \"\"\"\n+    try:",
      "comment": "@elacuesta one of these cases uses `else` specifically to handle the situation when there is no `ImportError`, can that still be refactored?",
      "comment_id": 354335334,
      "user": "wRAR",
      "created_at": "2019-12-05T14:14:01Z",
      "url": "https://github.com/scrapy/scrapy/pull/4010#discussion_r354335334"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 4010,
      "file_path": "scrapy/utils/asyncio.py",
      "line": 4,
      "side": "RIGHT",
      "diff_hunk": "@@ -0,0 +1,23 @@\n+def install_asyncio_reactor():\n+    \"\"\" Tries to install AsyncioSelectorReactor\n+    \"\"\"\n+    try:",
      "comment": "I don\u2019t think so, although using a `return` instead of `pass` in this specific case may be _slightly_ more readable.",
      "comment_id": 354340789,
      "user": "Gallaecio",
      "created_at": "2019-12-05T14:24:02Z",
      "url": "https://github.com/scrapy/scrapy/pull/4010#discussion_r354340789"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 4010,
      "file_path": "scrapy/utils/asyncio.py",
      "line": 8,
      "side": "RIGHT",
      "diff_hunk": "@@ -0,0 +1,23 @@\n+def install_asyncio_reactor():\n+    \"\"\" Tries to install AsyncioSelectorReactor\n+    \"\"\"\n+    try:\n+        import asyncio\n+        from twisted.internet import asyncioreactor\n+    except ImportError:\n+        pass",
      "comment": "It can be discussed.\r\n\r\n`install_asyncio_reactor` is called in various \"early\" places if ASYNCIO_ENABLED is on. If it fails, we can abort the spider or we can log the warning. Currently we log it, with ERROR, in `log_scrapy_info()` when the spider starts, which is not the place where it's installed but later.",
      "comment_id": 354344613,
      "user": "wRAR",
      "created_at": "2019-12-05T14:30:23Z",
      "url": "https://github.com/scrapy/scrapy/pull/4010#discussion_r354344613"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 4010,
      "file_path": "scrapy/utils/asyncio.py",
      "line": 8,
      "side": "RIGHT",
      "diff_hunk": "@@ -0,0 +1,23 @@\n+def install_asyncio_reactor():\n+    \"\"\" Tries to install AsyncioSelectorReactor\n+    \"\"\"\n+    try:\n+        import asyncio\n+        from twisted.internet import asyncioreactor\n+    except ImportError:\n+        pass",
      "comment": "We also compare `is_asyncio_reactor_installed()` and `ASYNCIO_ENABLED` when coroutines are used, and raise an exception (which I think will break the spider).",
      "comment_id": 354345510,
      "user": "wRAR",
      "created_at": "2019-12-05T14:32:05Z",
      "url": "https://github.com/scrapy/scrapy/pull/4010#discussion_r354345510"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 4010,
      "file_path": "scrapy/utils/asyncio.py",
      "line": 4,
      "side": "RIGHT",
      "diff_hunk": "@@ -0,0 +1,23 @@\n+def install_asyncio_reactor():\n+    \"\"\" Tries to install AsyncioSelectorReactor\n+    \"\"\"\n+    try:",
      "comment": "Right, I missed that. I agree, `return` instead of `pass` in the first occurrence does sound better to me.",
      "comment_id": 354536273,
      "user": "elacuesta",
      "created_at": "2019-12-05T20:40:44Z",
      "url": "https://github.com/scrapy/scrapy/pull/4010#discussion_r354536273"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 4010,
      "file_path": "scrapy/utils/defer.py",
      "line": 122,
      "side": "RIGHT",
      "diff_hunk": "@@ -113,3 +117,27 @@ def iter_errback(iterable, errback, *a, **kw):\n             break\n         except Exception:\n             errback(failure.Failure(), *a, **kw)\n+\n+\n+def isfuture(o):",
      "comment": "I hope this isn't too much bikeshedding, but I wonder if this function shouldn't be underscored, if it's only needed for py35",
      "comment_id": 354541682,
      "user": "elacuesta",
      "created_at": "2019-12-05T20:53:50Z",
      "url": "https://github.com/scrapy/scrapy/pull/4010#discussion_r354541682"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 5198,
      "file_path": "tests/test_feedexport.py",
      "line": 1785,
      "side": "RIGHT",
      "diff_hunk": "@@ -1780,14 +1780,15 @@ class FileFeedStoragePreFeedOptionsTest(unittest.TestCase):\n     maxDiff = None\n \n     def test_init(self):\n-        settings_dict = {\n-            'FEED_URI': 'file:///tmp/foobar',\n-            'FEED_STORAGES': {\n-                'file': FileFeedStorageWithoutFeedOptions\n-            },\n-        }\n-        crawler = get_crawler(settings_dict=settings_dict)\n-        feed_exporter = FeedExporter.from_crawler(crawler)\n+        with tempfile.NamedTemporaryFile() as temp:\n+            settings_dict = {\n+                'FEED_URI': f'file:///{temp.name}',",
      "comment": "What is the value of `temp.name` here? Aren\u2019t there 1 too many / in the URI scheme here? And if so, how are tests working nonetheless?\r\n\r\nAlso, according to https://docs.python.org/3/library/tempfile.html#tempfile.NamedTemporaryFile:\r\n\r\n> Whether the name can be used to open the file a second time, while the named temporary file is still open, varies across platforms (it can be so used on Unix; it cannot on Windows NT or later).\r\n\r\nWhich makes me wonder how tests are passing in Windows.",
      "comment_id": 676646957,
      "user": "Gallaecio",
      "created_at": "2021-07-26T14:17:36Z",
      "url": "https://github.com/scrapy/scrapy/pull/5198#discussion_r676646957"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 5198,
      "file_path": "tests/test_feedexport.py",
      "line": 1785,
      "side": "RIGHT",
      "diff_hunk": "@@ -1780,14 +1780,15 @@ class FileFeedStoragePreFeedOptionsTest(unittest.TestCase):\n     maxDiff = None\n \n     def test_init(self):\n-        settings_dict = {\n-            'FEED_URI': 'file:///tmp/foobar',\n-            'FEED_STORAGES': {\n-                'file': FileFeedStorageWithoutFeedOptions\n-            },\n-        }\n-        crawler = get_crawler(settings_dict=settings_dict)\n-        feed_exporter = FeedExporter.from_crawler(crawler)\n+        with tempfile.NamedTemporaryFile() as temp:\n+            settings_dict = {\n+                'FEED_URI': f'file:///{temp.name}',",
      "comment": "@Gallaecio temp.name returns the random name of the file. We create a new file with a random name to resolve the permissions issue at each test run, and the test is passing successfully. ",
      "comment_id": 682390879,
      "user": "Mannan2812",
      "created_at": "2021-08-04T08:12:19Z",
      "url": "https://github.com/scrapy/scrapy/pull/5198#discussion_r682390879"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 5198,
      "file_path": "tests/test_feedexport.py",
      "line": 1785,
      "side": "RIGHT",
      "diff_hunk": "@@ -1780,14 +1780,15 @@ class FileFeedStoragePreFeedOptionsTest(unittest.TestCase):\n     maxDiff = None\n \n     def test_init(self):\n-        settings_dict = {\n-            'FEED_URI': 'file:///tmp/foobar',\n-            'FEED_STORAGES': {\n-                'file': FileFeedStorageWithoutFeedOptions\n-            },\n-        }\n-        crawler = get_crawler(settings_dict=settings_dict)\n-        feed_exporter = FeedExporter.from_crawler(crawler)\n+        with tempfile.NamedTemporaryFile() as temp:\n+            settings_dict = {\n+                'FEED_URI': f'file:///{temp.name}',",
      "comment": "`f'file:///{temp.name}'` generates a URI like `file:////tmp/tmp_4p8ym67`, which seems to work but has 1 too many slashes at the beginning. Replacing `f'file:///{temp.name}'` with `f'file://{temp.name}'` gives me peace of mind and still works.\r\n\r\nAs for the platform issue, I see that the issue described in the documentation affects the file while open; what we are doing here is create a random file with a file-system path, remove it (when leaving the context manager), and pass it\u2019s path to the spider which later recreates the file. It feels a bit like a hack to me, since I am not aware of any assurances that, after the file is first removed, another call to `NamedTemporaryFile` will not create a new file on the same location, but there\u2019s probably some randomness in the file name choosing algorithm that makes that scenario very unlikely, so :+1: from me.",
      "comment_id": 683291429,
      "user": "Gallaecio",
      "created_at": "2021-08-05T09:33:03Z",
      "url": "https://github.com/scrapy/scrapy/pull/5198#discussion_r683291429"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 5198,
      "file_path": "tests/test_feedexport.py",
      "line": 1785,
      "side": "RIGHT",
      "diff_hunk": "@@ -1780,14 +1780,15 @@ class FileFeedStoragePreFeedOptionsTest(unittest.TestCase):\n     maxDiff = None\n \n     def test_init(self):\n-        settings_dict = {\n-            'FEED_URI': 'file:///tmp/foobar',\n-            'FEED_STORAGES': {\n-                'file': FileFeedStorageWithoutFeedOptions\n-            },\n-        }\n-        crawler = get_crawler(settings_dict=settings_dict)\n-        feed_exporter = FeedExporter.from_crawler(crawler)\n+        with tempfile.NamedTemporaryFile() as temp:\n+            settings_dict = {\n+                'FEED_URI': f'file:///{temp.name}',",
      "comment": "```suggestion\r\n                'FEED_URI': f'file://{temp.name}',\r\n```",
      "comment_id": 683291676,
      "user": "Gallaecio",
      "created_at": "2021-08-05T09:33:21Z",
      "url": "https://github.com/scrapy/scrapy/pull/5198#discussion_r683291676"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 5218,
      "file_path": "tests/test_http_response.py",
      "line": 851,
      "side": "RIGHT",
      "diff_hunk": "@@ -820,3 +820,42 @@ def test_selector_shortcuts_kwargs(self):\n             response.xpath(\"//s1:elem/text()\", namespaces={'s1': 'http://scrapy.org'}).getall(),\n             response.selector.xpath(\"//s2:elem/text()\").getall(),\n         )\n+\n+\n+class CustomResponse(TextResponse):\n+    attributes = TextResponse.attributes + (\"foo\", \"bar\")\n+\n+    def __init__(self, *args, **kwargs) -> None:\n+        self.foo = kwargs.pop(\"foo\", None)\n+        self.bar = kwargs.pop(\"bar\", None)\n+        self.lost = kwargs.pop(\"lost\", None)\n+        super().__init__(*args, **kwargs)\n+\n+\n+class CustomResponseTest(TextResponseTest):\n+    response_class = CustomResponse\n+\n+    def test_copy(self):\n+        super().test_copy()\n+        r1 = self.response_class(url=\"https://example.org\", status=200, foo=\"foo\", bar=\"bar\", lost=\"lost\")\n+        r2 = r1.copy()\n+        self.assertIsInstance(r2, self.response_class)\n+        self.assertEqual(r1.foo, r2.foo)\n+        self.assertEqual(r1.bar, r2.bar)\n+        self.assertEqual(r1.lost, \"lost\")\n+        self.assertIsNone(r2.lost)\n+\n+    def test_replace(self):\n+        super().test_replace()\n+        r1 = self.response_class(url=\"https://example.org\", status=200, foo=\"foo\", bar=\"bar\", lost=\"lost\")\n+        r2 = r1.replace(foo=\"new-foo\", bar=\"new-bar\", lost=\"new-lost\")",
      "comment": "This tests that overwriting `lost` works. Shouldn\u2019t we also test the same as with `copy`, that if you don\u2019t pass `lost` to `replace` the old value gets lots? And in the same test, test that _not_ passing e.g. `foo` ensures the new object has the same value as the old object.",
      "comment_id": 676385414,
      "user": "Gallaecio",
      "created_at": "2021-07-26T08:11:24Z",
      "url": "https://github.com/scrapy/scrapy/pull/5218#discussion_r676385414"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 5210,
      "file_path": "scrapy/extensions/feedexport.py",
      "line": 157,
      "side": "RIGHT",
      "diff_hunk": "@@ -153,14 +153,15 @@ def store(self, file):\n \n class S3FeedStorage(BlockingFeedStorage):\n \n-    def __init__(self, uri, access_key=None, secret_key=None, acl=None, endpoint_url=None, *,\n-                 feed_options=None):\n+    def __init__(self, uri, access_key=None, secret_key=None, session_token=None,\n+                 acl=None, endpoint_url=None, *, feed_options=None):",
      "comment": "This is a backward-incompatible change, as it changes the order of parameter that can be passed by position.\r\n\r\n```suggestion\r\n    def __init__(self, uri, access_key=None, secret_key=None, acl=None,\r\n                 endpoint_url=None, *, feed_options=None, session_token=None):\r\n```\r\n\r\nAlso affects `S3FeedStorageWithoutFeedOptions` later.",
      "comment_id": 676579026,
      "user": "Gallaecio",
      "created_at": "2021-07-26T12:57:54Z",
      "url": "https://github.com/scrapy/scrapy/pull/5210#discussion_r676579026"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 5210,
      "file_path": "tests/test_feedexport.py",
      "line": 327,
      "side": "RIGHT",
      "diff_hunk": "@@ -320,7 +324,7 @@ def test_init_with_acl(self):\n             's3://mybucket/export.csv',\n             'access_key',\n             'secret_key',\n-            'custom-acl'\n+            acl='custom-acl'",
      "comment": "This type of change should no longer be needed after fixing backward compatibility.",
      "comment_id": 676580658,
      "user": "Gallaecio",
      "created_at": "2021-07-26T12:59:58Z",
      "url": "https://github.com/scrapy/scrapy/pull/5210#discussion_r676580658"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 5210,
      "file_path": "scrapy/extensions/feedexport.py",
      "line": 157,
      "side": "RIGHT",
      "diff_hunk": "@@ -153,14 +153,15 @@ def store(self, file):\n \n class S3FeedStorage(BlockingFeedStorage):\n \n-    def __init__(self, uri, access_key=None, secret_key=None, acl=None, endpoint_url=None, *,\n-                 feed_options=None):\n+    def __init__(self, uri, access_key=None, secret_key=None, session_token=None,\n+                 acl=None, endpoint_url=None, *, feed_options=None):",
      "comment": "@Gallaecio  I noticed the backward incompatibility of `S3FeedStorage.__init__()`. At first, I implemented this API exactly as you suggested.\r\n\r\nBut keeping the position of argument `acl` unchanged and adding `session_token` as a keyword argument, breaks the consistency with `S3DownloadHandler.__init__()`, `botocore.credentials.Credentials.__init__()`. We have to break one of them anyway.",
      "comment_id": 677153622,
      "user": "laggardkernel",
      "created_at": "2021-07-27T06:25:35Z",
      "url": "https://github.com/scrapy/scrapy/pull/5210#discussion_r677153622"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 5210,
      "file_path": "scrapy/extensions/feedexport.py",
      "line": 157,
      "side": "RIGHT",
      "diff_hunk": "@@ -153,14 +153,15 @@ def store(self, file):\n \n class S3FeedStorage(BlockingFeedStorage):\n \n-    def __init__(self, uri, access_key=None, secret_key=None, acl=None, endpoint_url=None, *,\n-                 feed_options=None):\n+    def __init__(self, uri, access_key=None, secret_key=None, session_token=None,\n+                 acl=None, endpoint_url=None, *, feed_options=None):",
      "comment": "In Scrapy we usually value backward compatibility over consistency.",
      "comment_id": 677269699,
      "user": "Gallaecio",
      "created_at": "2021-07-27T09:14:51Z",
      "url": "https://github.com/scrapy/scrapy/pull/5210#discussion_r677269699"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 5210,
      "file_path": "scrapy/extensions/feedexport.py",
      "line": 157,
      "side": "RIGHT",
      "diff_hunk": "@@ -153,14 +153,15 @@ def store(self, file):\n \n class S3FeedStorage(BlockingFeedStorage):\n \n-    def __init__(self, uri, access_key=None, secret_key=None, acl=None, endpoint_url=None, *,\n-                 feed_options=None):\n+    def __init__(self, uri, access_key=None, secret_key=None, session_token=None,\n+                 acl=None, endpoint_url=None, *, feed_options=None):",
      "comment": "OK. Switched to the keyword argument implementation now.",
      "comment_id": 677368732,
      "user": "laggardkernel",
      "created_at": "2021-07-27T11:42:29Z",
      "url": "https://github.com/scrapy/scrapy/pull/5210#discussion_r677368732"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 5209,
      "file_path": "scrapy/core/downloader/handlers/s3.py",
      "line": 72,
      "side": "LEFT",
      "diff_hunk": "@@ -69,14 +67,4 @@ def download_request(self, request, spider):\n             self._signer.add_auth(awsrequest)\n             request = request.replace(\n                 url=url, headers=awsrequest.headers.items())\n-        else:",
      "comment": "The `elif` above can become an `else` now, since `self._signer` is never `None` if `self.anon` is `True`.",
      "comment_id": 676596432,
      "user": "Gallaecio",
      "created_at": "2021-07-26T13:20:18Z",
      "url": "https://github.com/scrapy/scrapy/pull/5209#discussion_r676596432"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 5191,
      "file_path": "scrapy/core/engine.py",
      "line": 19,
      "side": "RIGHT",
      "diff_hunk": "@@ -15,7 +15,8 @@\n \n from scrapy import signals\n from scrapy.core.scraper import Scraper\n-from scrapy.exceptions import DontCloseSpider, ScrapyDeprecationWarning\n+from scrapy.exceptions import DontCloseSpider, ScrapyDeprecationWarning, \\\n+    CloseSpider",
      "comment": ":lipstick:  We don\u2019t really use \\ at the end if it can be avoided.\r\n\r\n```suggestion\r\nfrom scrapy.exceptions import (\r\n    CloseSpider,\r\n    DontCloseSpider, \r\n    ScrapyDeprecationWarning,\r\n)   \r\n```",
      "comment_id": 665986380,
      "user": "Gallaecio",
      "created_at": "2021-07-08T08:34:11Z",
      "url": "https://github.com/scrapy/scrapy/pull/5191#discussion_r665986380"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 5191,
      "file_path": "scrapy/core/engine.py",
      "line": 336,
      "side": "RIGHT",
      "diff_hunk": "@@ -325,14 +326,20 @@ def _spider_idle(self) -> None:\n         Called when a spider gets idle, i.e. when there are no remaining requests to download or schedule.\n         It can be called multiple times. If a handler for the spider_idle signal raises a DontCloseSpider\n         exception, the spider is not closed until the next loop and this function is guaranteed to be called\n-        (at least) once again.\n+        (at least) once again. A handler can raise CloseSpider to provide a custom closing reason.\n         \"\"\"\n         assert self.spider is not None  # typing\n-        res = self.signals.send_catch_log(signals.spider_idle, spider=self.spider, dont_log=DontCloseSpider)\n-        if any(isinstance(x, Failure) and isinstance(x.value, DontCloseSpider) for _, x in res):\n+        expected_ex = (DontCloseSpider, CloseSpider)\n+        res = self.signals.send_catch_log(signals.spider_idle, spider=self.spider, dont_log=expected_ex)\n+        detected_ex = {ex: x.value\n+                       for _, x in res for ex in expected_ex\n+                       if isinstance(x, Failure) and isinstance(x.value, ex)}",
      "comment": ":lipstick: \r\n\r\n```suggestion\r\n        detected_ex = {\r\n            ex: x.value\r\n            for _, x in res\r\n            for ex in expected_ex\r\n            if isinstance(x, Failure) and isinstance(x.value, ex)\r\n        }\r\n```",
      "comment_id": 665996239,
      "user": "Gallaecio",
      "created_at": "2021-07-08T08:47:33Z",
      "url": "https://github.com/scrapy/scrapy/pull/5191#discussion_r665996239"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 5191,
      "file_path": "tests/test_engine.py",
      "line": 29,
      "side": "RIGHT",
      "diff_hunk": "@@ -26,7 +26,7 @@\n \n from scrapy import signals\n from scrapy.core.engine import ExecutionEngine\n-from scrapy.exceptions import ScrapyDeprecationWarning\n+from scrapy.exceptions import ScrapyDeprecationWarning, CloseSpider",
      "comment": ":lipstick: \r\n\r\n```suggestion\r\nfrom scrapy.exceptions import CloseSpider, ScrapyDeprecationWarning\r\n```",
      "comment_id": 665999540,
      "user": "Gallaecio",
      "created_at": "2021-07-08T08:51:53Z",
      "url": "https://github.com/scrapy/scrapy/pull/5191#discussion_r665999540"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 5191,
      "file_path": "scrapy/core/engine.py",
      "line": 22,
      "side": "RIGHT",
      "diff_hunk": "@@ -15,7 +15,11 @@\n \n from scrapy import signals\n from scrapy.core.scraper import Scraper\n-from scrapy.exceptions import DontCloseSpider, ScrapyDeprecationWarning\n+from scrapy.exceptions import (\n+    CloseSpider,\n+    DontCloseSpider, \n+    ScrapyDeprecationWarning,\n+)   ",
      "comment": "```suggestion\r\n    DontCloseSpider,\r\n    ScrapyDeprecationWarning,\r\n)\r\n```\r\nRemove the trailing whitespaces that are making the flake8 check fail.",
      "comment_id": 666141075,
      "user": "elacuesta",
      "created_at": "2021-07-08T12:21:47Z",
      "url": "https://github.com/scrapy/scrapy/pull/5191#discussion_r666141075"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 5178,
      "file_path": "scrapy/itemchecker.py",
      "line": 34,
      "side": "RIGHT",
      "diff_hunk": "@@ -0,0 +1,63 @@\n+\"\"\"\n+Filter for Scrapy Items to be used by Feed slots.\n+\"\"\"\n+from itemadapter import ItemAdapter\n+\n+\n+class ItemChecker:\n+    \"\"\"\n+    This will be used by FeedExporter to decide if an item should be allowed\n+    to be exported to a particular feed.\n+    :param feed_options: feed specific options passed from FeedExporter\n+    :type feed_options: dict\n+    \"\"\"\n+\n+    item_classes = ()\n+\n+    def __init__(self, feed_options):\n+        self.feed_options = feed_options\n+\n+        if 'item_classes' in self.feed_options:\n+            self.item_classes += self.feed_options['item_classes']\n+\n+    def accepts(self, item):\n+        \"\"\"\n+        Main method to be used by FeedExporter to check if the item is acceptable according\n+        to defined constraints. This method uses accepts_class and accept_fields method\n+        to decide if the item is acceptable.\n+        :param item: scraped item which user wants to check if is acceptable\n+        :type item: scrapy supported items (dictionaries, Item objects, dataclass objects, and attrs objects)\n+        :return: `True` if accepted, `False` otherwise\n+        :rtype: bool\n+        \"\"\"\n+        adapter = ItemAdapter(item)\n+        return self.accepts_item(item) and self.accepts_fields(adapter.asdict())",
      "comment": "it's supposed to be ```self.accepts_class``` instead of ```self.accepts_item```, I'll change that",
      "comment_id": 650065340,
      "user": "drs-11",
      "created_at": "2021-06-11T15:21:47Z",
      "url": "https://github.com/scrapy/scrapy/pull/5178#discussion_r650065340"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 5178,
      "file_path": "scrapy/itemchecker.py",
      "line": 21,
      "side": "RIGHT",
      "diff_hunk": "@@ -0,0 +1,63 @@\n+\"\"\"\n+Filter for Scrapy Items to be used by Feed slots.\n+\"\"\"\n+from itemadapter import ItemAdapter\n+\n+\n+class ItemChecker:\n+    \"\"\"\n+    This will be used by FeedExporter to decide if an item should be allowed\n+    to be exported to a particular feed.\n+    :param feed_options: feed specific options passed from FeedExporter\n+    :type feed_options: dict\n+    \"\"\"\n+\n+    item_classes = ()\n+\n+    def __init__(self, feed_options):\n+        self.feed_options = feed_options\n+\n+        if 'item_classes' in self.feed_options:\n+            self.item_classes += self.feed_options['item_classes']",
      "comment": "This will fail, since `self.item_classes` is a (non-mutable) tuple.\r\n\r\nIt may make sense to make `self.item_classes` a set instead of a tuple.\r\n\r\nI also wonder if we should support item classes to be import paths instead of actual classes, in case the FEEDS setting has been defined as a JSON string.\r\n\r\n",
      "comment_id": 650148419,
      "user": "Gallaecio",
      "created_at": "2021-06-11T17:15:09Z",
      "url": "https://github.com/scrapy/scrapy/pull/5178#discussion_r650148419"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 5178,
      "file_path": "scrapy/itemchecker.py",
      "line": 21,
      "side": "RIGHT",
      "diff_hunk": "@@ -0,0 +1,63 @@\n+\"\"\"\n+Filter for Scrapy Items to be used by Feed slots.\n+\"\"\"\n+from itemadapter import ItemAdapter\n+\n+\n+class ItemChecker:\n+    \"\"\"\n+    This will be used by FeedExporter to decide if an item should be allowed\n+    to be exported to a particular feed.\n+    :param feed_options: feed specific options passed from FeedExporter\n+    :type feed_options: dict\n+    \"\"\"\n+\n+    item_classes = ()\n+\n+    def __init__(self, feed_options):\n+        self.feed_options = feed_options\n+\n+        if 'item_classes' in self.feed_options:\n+            self.item_classes += self.feed_options['item_classes']",
      "comment": "My reasoning for using ```+=```: I was planning on having item_classes declared in a tuple in settings.py so I thought I would update the class's self.item_classes tuple with the operation ```+=```.",
      "comment_id": 650176808,
      "user": "drs-11",
      "created_at": "2021-06-11T18:05:17Z",
      "url": "https://github.com/scrapy/scrapy/pull/5178#discussion_r650176808"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 5178,
      "file_path": "scrapy/extensions/feedexport.py",
      "line": 501,
      "side": "RIGHT",
      "diff_hunk": "@@ -486,3 +495,8 @@ def _get_uri_params(self, spider, uri_params, slot=None):\n         uripar_function = load_object(uri_params) if uri_params else lambda x, y: None\n         uripar_function(params, spider)\n         return params\n+\n+    def _load_filter(self, feed_options):\n+        # load the item filter if declared else load the default filter class\n+        item_filter_class = load_object(feed_options.get(\"item_filter\",\"scrapy.itemchecker.ItemChecker\"))",
      "comment": ":lipstick:  You could use the actual class here, instead of a string, provided you import it first.\r\n\r\n```suggestion\r\n        item_filter_class = load_object(feed_options.get(\"item_filter\", ItemChecker))\r\n```",
      "comment_id": 650562793,
      "user": "Gallaecio",
      "created_at": "2021-06-13T18:45:20Z",
      "url": "https://github.com/scrapy/scrapy/pull/5178#discussion_r650562793"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 5178,
      "file_path": "scrapy/itemchecker.py",
      "line": 26,
      "side": "RIGHT",
      "diff_hunk": "@@ -0,0 +1,75 @@\n+\"\"\"\n+Filter for Scrapy Items to be used by Feed slots.\n+\"\"\"\n+from itemadapter import ItemAdapter\n+\n+from scrapy import Item\n+from scrapy.utils.misc import load_object\n+\n+\n+class ItemChecker:\n+    \"\"\"\n+    This will be used by FeedExporter to decide if an item should be allowed\n+    to be exported to a particular feed.\n+    :param feed_options: feed specific options passed from FeedExporter\n+    :type feed_options: dict\n+    \"\"\"\n+\n+    item_classes = ()\n+\n+    def __init__(self, feed_options):\n+        self.feed_options = feed_options\n+\n+        if 'item_classes' in self.feed_options:\n+            item_classes = self.feed_options['item_classes']\n+\n+            if isinstance(item_classes, (Item, str)):",
      "comment": "I would suggest requiring the value to be a list. It will not be much of a trouble for users, it will keep their code consistent (`'item_classes': class` seems semantically wrong, `'item_classes': [class]` seems more consistent with the option name), and it will simplify your implementation (you don\u2019t need an `if` statement here at all).\r\n\r\nInternally, because you are merging the user-input option with a class-defined variable, you may want to enforce the class-defined variable to be a set, and convert the user-input option into a set before you merge them. Or you could remove the class-defined variable, and only filter item classes defined by users.",
      "comment_id": 650565648,
      "user": "Gallaecio",
      "created_at": "2021-06-13T19:12:31Z",
      "url": "https://github.com/scrapy/scrapy/pull/5178#discussion_r650565648"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 5178,
      "file_path": "scrapy/itemchecker.py",
      "line": 46,
      "side": "RIGHT",
      "diff_hunk": "@@ -0,0 +1,75 @@\n+\"\"\"\n+Filter for Scrapy Items to be used by Feed slots.\n+\"\"\"\n+from itemadapter import ItemAdapter\n+\n+from scrapy import Item\n+from scrapy.utils.misc import load_object\n+\n+\n+class ItemChecker:\n+    \"\"\"\n+    This will be used by FeedExporter to decide if an item should be allowed\n+    to be exported to a particular feed.\n+    :param feed_options: feed specific options passed from FeedExporter\n+    :type feed_options: dict\n+    \"\"\"\n+\n+    item_classes = ()\n+\n+    def __init__(self, feed_options):\n+        self.feed_options = feed_options\n+\n+        if 'item_classes' in self.feed_options:\n+            item_classes = self.feed_options['item_classes']\n+\n+            if isinstance(item_classes, (Item, str)):\n+                self.item_classes += (load_object(item_classes),)\n+            elif isinstance(item_classes, (list,set,tuple)):\n+                for item_class in item_classes:\n+                    self.item_classes += (load_object(item_class),)\n+            else:\n+                pass\n+                # raise some warning for invalid item_classes declaration?\n+\n+    def accepts(self, item):\n+        \"\"\"\n+        Main method to be used by FeedExporter to check if the item is acceptable according\n+        to defined constraints. This method uses accepts_class and accept_fields method\n+        to decide if the item is acceptable.\n+        :param item: scraped item which user wants to check if is acceptable\n+        :type item: scrapy supported items (dictionaries, Item objects, dataclass objects, and attrs objects)\n+        :return: `True` if accepted, `False` otherwise\n+        :rtype: bool\n+        \"\"\"\n+        adapter = ItemAdapter(item)\n+        return self.accepts_class(item) and self.accepts_fields(adapter.asdict())",
      "comment": "I think here we are introducing a potential, unnecessary performance degradation: we are converting every item into a dict even if `self.accepts_fields` returns `True` for every item. That conversion into a dict may be non-trivial, specially since Scrapy supports arbitrary objects as items by extending https://github.com/scrapy/itemadapter.\r\n\r\nMoreover, `self.accept_fields` may want to check field metadata to determine whether or not to accept a field, for which it would need either the original item or the whole adapter.\r\n\r\nThe only way that I see to solve this performance issue without making `self.accepts_fields` pointless (same signature as `self.accepts_class`) is to actually remove the method.\r\n\r\nThe more I think about it, the more I see that it\u2019s best to keep this default class simple, to only have the `accepts` method and let it do what `accepts_class` would do. But if you still want to keep the function for some reason, please avoid calling `asdict()` here.",
      "comment_id": 650566700,
      "user": "Gallaecio",
      "created_at": "2021-06-13T19:22:21Z",
      "url": "https://github.com/scrapy/scrapy/pull/5178#discussion_r650566700"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 5178,
      "file_path": "tests/test_feedexport.py",
      "line": 937,
      "side": "RIGHT",
      "diff_hunk": "@@ -929,6 +929,114 @@ class MyItem2(scrapy.Item):\n         yield self.assertExported(items, header, rows,\n                                   settings=settings, ordered=True)\n \n+    @defer.inlineCallbacks\n+    def test_export_based_on_item_classes(self):\n+        items = [\n+            self.MyItem({'foo': 'bar1', 'egg': 'spam1'}),\n+            self.MyItem2({'hello': 'world2', 'foo': 'bar2'}),\n+            {'hello': 'world3', 'egg': 'spam3'},",
      "comment": "In case you plan to use these inputs for more tests, can we declare these as constants at the top? ",
      "comment_id": 655087880,
      "user": "adityaa30",
      "created_at": "2021-06-21T05:41:45Z",
      "url": "https://github.com/scrapy/scrapy/pull/5178#discussion_r655087880"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 5178,
      "file_path": "scrapy/extensions/feedexport.py",
      "line": 69,
      "side": "RIGHT",
      "diff_hunk": "@@ -46,6 +46,39 @@ def build_storage(builder, uri, *args, feed_options=None, preargs=(), **kwargs):\n     return builder(*preargs, uri, *args, **kwargs)\n \n \n+class ItemFilter:\n+    \"\"\"\n+    This will be used by FeedExporter to decide if an item should be allowed\n+    to be exported to a particular feed.\n+\n+    :param feed_options: feed specific options passed from FeedExporter\n+    :type feed_options: dict\n+    \"\"\"\n+\n+    def __init__(self, feed_options):\n+        self.feed_options = feed_options\n+        self.item_classes = set()\n+\n+        if 'item_classes' in self.feed_options:\n+            for item_class in self.feed_options['item_classes']:\n+                self.item_classes.add(load_object(item_class))\n+\n+    def accepts(self, item):\n+        \"\"\"\n+        Main method to be used by FeedExporter to check if the item is acceptable according\n+        to defined constraints.",
      "comment": "The first paragraph of a method docstring should summarize input, operation and output, and use the imperative. What about:\r\n\r\n```suggestion\r\n        Return ``True`` if `item` should be exported or ``False`` otherwise.\r\n```\r\n\r\nNote: ``` `item` ``` is not a typo, input parameters in Python documentation are usually formatted that way in docstrings.\r\n\r\nWe should not need to specify that it\u2019s the main method, it should be obvious from the fact that it\u2019s the only method.",
      "comment_id": 655121740,
      "user": "Gallaecio",
      "created_at": "2021-06-21T07:00:19Z",
      "url": "https://github.com/scrapy/scrapy/pull/5178#discussion_r655121740"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 5178,
      "file_path": "scrapy/extensions/feedexport.py",
      "line": 71,
      "side": "RIGHT",
      "diff_hunk": "@@ -46,6 +46,38 @@ def build_storage(builder, uri, *args, feed_options=None, preargs=(), **kwargs):\n     return builder(*preargs, uri, *args, **kwargs)\n \n \n+class ItemFilter:\n+    \"\"\"\n+    This will be used by FeedExporter to decide if an item should be allowed\n+    to be exported to a particular feed.\n+\n+    :param feed_options: feed specific options passed from FeedExporter\n+    :type feed_options: dict\n+    \"\"\"\n+\n+    def __init__(self, feed_options):\n+        self.feed_options = feed_options\n+        self.item_classes = set()\n+\n+        if 'item_classes' in self.feed_options:\n+            for item_class in self.feed_options['item_classes']:\n+                self.item_classes.add(load_object(item_class))\n+\n+    def accepts(self, item):\n+        \"\"\"\n+        Return ``True`` if `item` should be exported or ``False`` otherwise.\n+\n+        :param item: scraped item which user wants to check if is acceptable\n+        :type item: scrapy supported items (dictionaries, Item objects, dataclass objects, and attrs objects)",
      "comment": "Should we have this list there? It's going to be outdated soon.",
      "comment_id": 668742432,
      "user": "wRAR",
      "created_at": "2021-07-13T13:04:04Z",
      "url": "https://github.com/scrapy/scrapy/pull/5178#discussion_r668742432"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 5178,
      "file_path": "scrapy/extensions/feedexport.py",
      "line": 71,
      "side": "RIGHT",
      "diff_hunk": "@@ -46,6 +46,38 @@ def build_storage(builder, uri, *args, feed_options=None, preargs=(), **kwargs):\n     return builder(*preargs, uri, *args, **kwargs)\n \n \n+class ItemFilter:\n+    \"\"\"\n+    This will be used by FeedExporter to decide if an item should be allowed\n+    to be exported to a particular feed.\n+\n+    :param feed_options: feed specific options passed from FeedExporter\n+    :type feed_options: dict\n+    \"\"\"\n+\n+    def __init__(self, feed_options):\n+        self.feed_options = feed_options\n+        self.item_classes = set()\n+\n+        if 'item_classes' in self.feed_options:\n+            for item_class in self.feed_options['item_classes']:\n+                self.item_classes.add(load_object(item_class))\n+\n+    def accepts(self, item):\n+        \"\"\"\n+        Return ``True`` if `item` should be exported or ``False`` otherwise.\n+\n+        :param item: scraped item which user wants to check if is acceptable\n+        :type item: scrapy supported items (dictionaries, Item objects, dataclass objects, and attrs objects)",
      "comment": "Good point, it would be better to say \u201cScrapy items\u201d and link to the items documentation.",
      "comment_id": 668779550,
      "user": "Gallaecio",
      "created_at": "2021-07-13T13:46:39Z",
      "url": "https://github.com/scrapy/scrapy/pull/5178#discussion_r668779550"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 3579,
      "file_path": "scrapy/http/request/form.py",
      "line": 44,
      "side": "RIGHT",
      "diff_hunk": "@@ -33,7 +33,25 @@ def __init__(self, *args, **kwargs):\n                 self.headers.setdefault(b'Content-Type', b'application/x-www-form-urlencoded')\n                 self._set_body(querystr)\n             else:\n-                self._set_url(self.url + ('&' if '?' in self.url else '?') + querystr)\n+                url_split = urlsplit(self.url)\n+                formdata_key_list = []\n+                for k in querystr.split('&'):\n+                    formdata_key_list.append(k.split('=')[0])\n+\n+                if url_split.query:\n+                    queries = (url_split.query).split('&')\n+                    query_dict = {}\n+                    for x in queries:",
      "comment": "Why are you not using `parse_qs` or `parse_qsl` for parsing and create `query_dict ` dict?",
      "comment_id": 248953980,
      "user": "amarynets",
      "created_at": "2019-01-18T08:03:40Z",
      "url": "https://github.com/scrapy/scrapy/pull/3579#discussion_r248953980"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 3579,
      "file_path": "scrapy/http/request/form.py",
      "line": 51,
      "side": "RIGHT",
      "diff_hunk": "@@ -33,7 +33,25 @@ def __init__(self, *args, **kwargs):\n                 self.headers.setdefault(b'Content-Type', b'application/x-www-form-urlencoded')\n                 self._set_body(querystr)\n             else:\n-                self._set_url(self.url + ('&' if '?' in self.url else '?') + querystr)\n+                url_split = urlsplit(self.url)\n+                formdata_key_list = []\n+                for k in querystr.split('&'):\n+                    formdata_key_list.append(k.split('=')[0])\n+\n+                if url_split.query:\n+                    queries = (url_split.query).split('&')\n+                    query_dict = {}\n+                    for x in queries:\n+                        k = x.split('=')[0]\n+                        v = x.split('=')[1]\n+                        if formdata_key_list.count(k)==0:\n+                            query_dict[k] = v\n+                        query_str = ''\n+                        for k, v in query_dict.items():\n+                            query_str += (k + '=' + v + '&')",
      "comment": "Also you can use `urlencode` for creating qs from dict",
      "comment_id": 248954425,
      "user": "amarynets",
      "created_at": "2019-01-18T08:05:31Z",
      "url": "https://github.com/scrapy/scrapy/pull/3579#discussion_r248954425"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 3579,
      "file_path": "scrapy/http/request/form.py",
      "line": 52,
      "side": "RIGHT",
      "diff_hunk": "@@ -33,7 +33,25 @@ def __init__(self, *args, **kwargs):\n                 self.headers.setdefault(b'Content-Type', b'application/x-www-form-urlencoded')\n                 self._set_body(querystr)\n             else:\n-                self._set_url(self.url + ('&' if '?' in self.url else '?') + querystr)\n+                url_split = urlsplit(self.url)\n+                formdata_key_list = []\n+                for k in querystr.split('&'):\n+                    formdata_key_list.append(k.split('=')[0])\n+\n+                if url_split.query:\n+                    queries = (url_split.query).split('&')\n+                    query_dict = {}\n+                    for x in queries:\n+                        k = x.split('=')[0]\n+                        v = x.split('=')[1]\n+                        if formdata_key_list.count(k)==0:\n+                            query_dict[k] = v\n+                        query_str = ''\n+                        for k, v in query_dict.items():\n+                            query_str += (k + '=' + v + '&')\n+                    self._set_url(self.url[:self.url.index('?')+1] + query_str + querystr + ('#' + url_split.fragment if url_split.fragment else ''))",
      "comment": "I think would be better to use `urllib.parse.urlunparse()` for create new URL instead concatenation.\r\n",
      "comment_id": 248955630,
      "user": "amarynets",
      "created_at": "2019-01-18T08:11:30Z",
      "url": "https://github.com/scrapy/scrapy/pull/3579#discussion_r248955630"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 3579,
      "file_path": "scrapy/http/request/form.py",
      "line": 41,
      "side": "RIGHT",
      "diff_hunk": "@@ -33,7 +33,14 @@ def __init__(self, *args, **kwargs):\n                 self.headers.setdefault(b'Content-Type', b'application/x-www-form-urlencoded')\n                 self._set_body(querystr)\n             else:\n-                self._set_url(self.url + ('&' if '?' in self.url else '?') + querystr)\n+                url_split = urlsplit(self.url)\n+                formdata_key_list = []\n+                for k in querystr.split('&'):\n+                    formdata_key_list.append(k.split('=')[0])\n+                items = []\n+                items += [(k, v) for k, v in parse_qsl(url_split.query) if k not in formdata_key_list]",
      "comment": "Why create an empty ``items`` here and then add to this list? Can this be reduced to one operation?",
      "comment_id": 261942367,
      "user": "lopuhin",
      "created_at": "2019-03-04T07:18:04Z",
      "url": "https://github.com/scrapy/scrapy/pull/3579#discussion_r261942367"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 3579,
      "file_path": "scrapy/http/request/form.py",
      "line": 38,
      "side": "RIGHT",
      "diff_hunk": "@@ -33,7 +33,14 @@ def __init__(self, *args, **kwargs):\n                 self.headers.setdefault(b'Content-Type', b'application/x-www-form-urlencoded')\n                 self._set_body(querystr)\n             else:\n-                self._set_url(self.url + ('&' if '?' in self.url else '?') + querystr)\n+                url_split = urlsplit(self.url)\n+                formdata_key_list = []\n+                for k in querystr.split('&'):",
      "comment": "It's better to use functions for URL parsing from standard library and w3lib instead of doing this manually here, unless they are not doing what you need here (in that case it would make sense to leave a comment)",
      "comment_id": 261942670,
      "user": "lopuhin",
      "created_at": "2019-03-04T07:19:34Z",
      "url": "https://github.com/scrapy/scrapy/pull/3579#discussion_r261942670"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 3579,
      "file_path": "scrapy/http/request/form.py",
      "line": 43,
      "side": "RIGHT",
      "diff_hunk": "@@ -33,7 +33,14 @@ def __init__(self, *args, **kwargs):\n                 self.headers.setdefault(b'Content-Type', b'application/x-www-form-urlencoded')\n                 self._set_body(querystr)\n             else:\n-                self._set_url(self.url + ('&' if '?' in self.url else '?') + querystr)\n+                url_split = urlsplit(self.url)\n+                formdata_key_list = []\n+                for k in querystr.split('&'):\n+                    formdata_key_list.append(k.split('=')[0])\n+                items = []\n+                items += [(k, v) for k, v in parse_qsl(url_split.query) if k not in formdata_key_list]\n+                query_str = _urlencode(items, self.encoding)\n+                self._set_url(urljoin(self.url,'?'+ (query_str + '&' if query_str else '') + querystr + ('#'+ url_split.fragment if url_split.fragment else '')))",
      "comment": "Same here, I think it's better to use stdlib functions for URL construction from parts (see e.g. `urlunsplit` / `urlunparse`)",
      "comment_id": 261943134,
      "user": "lopuhin",
      "created_at": "2019-03-04T07:22:05Z",
      "url": "https://github.com/scrapy/scrapy/pull/3579#discussion_r261943134"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 3579,
      "file_path": "scrapy/http/request/form.py",
      "line": 43,
      "side": "RIGHT",
      "diff_hunk": "@@ -33,7 +33,14 @@ def __init__(self, *args, **kwargs):\n                 self.headers.setdefault(b'Content-Type', b'application/x-www-form-urlencoded')\n                 self._set_body(querystr)\n             else:\n-                self._set_url(self.url + ('&' if '?' in self.url else '?') + querystr)\n+                url_split = urlsplit(self.url)\n+                formdata_key_list = []\n+                for k in querystr.split('&'):\n+                    formdata_key_list.append(k.split('=')[0])\n+                items = []\n+                items += [(k, v) for k, v in parse_qsl(url_split.query) if k not in formdata_key_list]\n+                query_str = _urlencode(items, self.encoding)\n+                self._set_url(urljoin(self.url,'?'+ (query_str + '&' if query_str else '') + querystr + ('#'+ url_split.fragment if url_split.fragment else '')))",
      "comment": "I am not be able to do that, because I have both ```query_str``` and ```querystr``` to be appended. We can also have the case where ```query_str can be empty```. So, I explicitly defined in the urljoin. Do you have any suggestion @lopuhin ?  ",
      "comment_id": 261977176,
      "user": "maramsumanth",
      "created_at": "2019-03-04T09:27:06Z",
      "url": "https://github.com/scrapy/scrapy/pull/3579#discussion_r261977176"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 3579,
      "file_path": "scrapy/http/request/form.py",
      "line": 37,
      "side": "RIGHT",
      "diff_hunk": "@@ -33,7 +33,11 @@ def __init__(self, *args, **kwargs):\n                 self.headers.setdefault(b'Content-Type', b'application/x-www-form-urlencoded')\n                 self._set_body(querystr)\n             else:\n-                self._set_url(self.url + ('&' if '?' in self.url else '?') + querystr)\n+                url_split = urlsplit(self.url)\n+                formdata_key_list = list(dict(parse_qsl(querystr)).keys())",
      "comment": "Since this is used only for checking filtering in the next line, it would be more efficient with a set instead of a list:\r\n```\r\nformdata_keys = set(dict(parse_qsl(querystr)).keys())\r\n```",
      "comment_id": 262005815,
      "user": "lopuhin",
      "created_at": "2019-03-04T10:43:20Z",
      "url": "https://github.com/scrapy/scrapy/pull/3579#discussion_r262005815"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 3579,
      "file_path": "scrapy/http/request/form.py",
      "line": 43,
      "side": "RIGHT",
      "diff_hunk": "@@ -33,7 +33,14 @@ def __init__(self, *args, **kwargs):\n                 self.headers.setdefault(b'Content-Type', b'application/x-www-form-urlencoded')\n                 self._set_body(querystr)\n             else:\n-                self._set_url(self.url + ('&' if '?' in self.url else '?') + querystr)\n+                url_split = urlsplit(self.url)\n+                formdata_key_list = []\n+                for k in querystr.split('&'):\n+                    formdata_key_list.append(k.split('=')[0])\n+                items = []\n+                items += [(k, v) for k, v in parse_qsl(url_split.query) if k not in formdata_key_list]\n+                query_str = _urlencode(items, self.encoding)\n+                self._set_url(urljoin(self.url,'?'+ (query_str + '&' if query_str else '') + querystr + ('#'+ url_split.fragment if url_split.fragment else '')))",
      "comment": "> I am not be able to do that, because I have both query_str and querystr to be appended. We can also have the case where query_str can be empty.\r\n\r\n@maramsumanth I see, in that case you could first concatenate query strings, and then pass them to urlunsplit. Also it already has the logic to handle empty parts:\r\n\r\n```\r\nIn [1]: from urllib.parse import urlunsplit\r\n\r\nIn [2]: urlunsplit(('a', 'b', 'c', 'd', 'e'))\r\nOut[2]: 'a://b/c?d#e'\r\n\r\nIn [3]: urlunsplit(('a', 'b', 'c', 'd', ''))\r\nOut[3]: 'a://b/c?d'\r\n\r\nIn [4]: urlunsplit(('a', 'b', 'c', 'd', ''))\r\nOut[4]: 'a://b/c?d'\r\n\r\nIn [5]: urlunsplit(('a', 'b', '', '', 'foo'))\r\nOut[5]: 'a://b#foo'\r\n```",
      "comment_id": 262007190,
      "user": "lopuhin",
      "created_at": "2019-03-04T10:47:03Z",
      "url": "https://github.com/scrapy/scrapy/pull/3579#discussion_r262007190"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 3579,
      "file_path": "scrapy/http/request/form.py",
      "line": 43,
      "side": "RIGHT",
      "diff_hunk": "@@ -33,7 +33,14 @@ def __init__(self, *args, **kwargs):\n                 self.headers.setdefault(b'Content-Type', b'application/x-www-form-urlencoded')\n                 self._set_body(querystr)\n             else:\n-                self._set_url(self.url + ('&' if '?' in self.url else '?') + querystr)\n+                url_split = urlsplit(self.url)\n+                formdata_key_list = []\n+                for k in querystr.split('&'):\n+                    formdata_key_list.append(k.split('=')[0])\n+                items = []\n+                items += [(k, v) for k, v in parse_qsl(url_split.query) if k not in formdata_key_list]\n+                query_str = _urlencode(items, self.encoding)\n+                self._set_url(urljoin(self.url,'?'+ (query_str + '&' if query_str else '') + querystr + ('#'+ url_split.fragment if url_split.fragment else '')))",
      "comment": "I thought of using urlunsplit, but both urljoin and urlunsplit yield the same thing.",
      "comment_id": 262397769,
      "user": "maramsumanth",
      "created_at": "2019-03-05T08:51:46Z",
      "url": "https://github.com/scrapy/scrapy/pull/3579#discussion_r262397769"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 4649,
      "file_path": "tests/test_downloader_handlers.py",
      "line": 744,
      "side": "RIGHT",
      "diff_hunk": "@@ -733,6 +735,16 @@ def test_download_with_proxy_https_timeout(self):\n         timeout = yield self.assertFailure(d, error.TimeoutError)\n         self.assertIn(domain, timeout.osError)\n \n+    def test_download_with_proxy_without_http_scheme(self):\n+        def _test(response):\n+            self.assertEqual(response.status, 200)\n+            self.assertEqual(response.url, request.url)\n+            self.assertEqual(response.body, b'http://example.com')\n+\n+        http_proxy = self.getURL('').replace('http:', '')",
      "comment": "Shouldn\u2019t we test without the `//`? Or at least test both ways?\r\n\r\n```suggestion\r\n        http_proxy = self.getURL('').replace('http://', '')\r\n```",
      "comment_id": 446956674,
      "user": "Gallaecio",
      "created_at": "2020-06-29T13:07:55Z",
      "url": "https://github.com/scrapy/scrapy/pull/4649#discussion_r446956674"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 4649,
      "file_path": "tests/test_downloader_handlers.py",
      "line": 744,
      "side": "RIGHT",
      "diff_hunk": "@@ -733,6 +735,16 @@ def test_download_with_proxy_https_timeout(self):\n         timeout = yield self.assertFailure(d, error.TimeoutError)\n         self.assertIn(domain, timeout.osError)\n \n+    def test_download_with_proxy_without_http_scheme(self):\n+        def _test(response):\n+            self.assertEqual(response.status, 200)\n+            self.assertEqual(response.url, request.url)\n+            self.assertEqual(response.body, b'http://example.com')\n+\n+        http_proxy = self.getURL('').replace('http:', '')",
      "comment": "Then we need to change the implementation to support `test-uri.com`. It would be great to also support `//test-uri.com`, but I would consider that optional, given that users are much more likely to use `test-uri.com`.",
      "comment_id": 447007131,
      "user": "Gallaecio",
      "created_at": "2020-06-29T14:18:39Z",
      "url": "https://github.com/scrapy/scrapy/pull/4649#discussion_r447007131"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 4649,
      "file_path": "tests/test_downloader_handlers.py",
      "line": 744,
      "side": "RIGHT",
      "diff_hunk": "@@ -733,6 +735,16 @@ def test_download_with_proxy_https_timeout(self):\n         timeout = yield self.assertFailure(d, error.TimeoutError)\n         self.assertIn(domain, timeout.osError)\n \n+    def test_download_with_proxy_without_http_scheme(self):\n+        def _test(response):\n+            self.assertEqual(response.status, 200)\n+            self.assertEqual(response.url, request.url)\n+            self.assertEqual(response.body, b'http://example.com')\n+\n+        http_proxy = self.getURL('').replace('http:', '')",
      "comment": "It actually works fine on the user-end, I created the following spider and ran it. \r\n\r\n```\r\nimport scrapy\r\n\r\n\r\nclass ExampleSpider(scrapy.Spider):\r\n    name = 'example'\r\n\r\n    def start_requests(self):\r\n        proxies = [\"example-proxy.com:9999\", \"//example-proxy.com:9999\", \"http://example-proxy.com:9999\"]\r\n        for proxy in proxies:\r\n            yield scrapy.Request(url='http://quotes.toscrape.com/page/1/', callback=self.parse, meta={\"proxy\": proxy})\r\n\r\n    def parse(self, response):\r\n        print('Finished Successfully')\r\n```\r\n\r\nThe `httpproxy` middleware is able to parse the proxy url correctly because of [these 2 lines](https://github.com/scrapy/scrapy/blob/master/scrapy/downloadermiddlewares/httpproxy.py#L32-L33) (_urlunparse()_ seems to adds the '//'). \r\n\r\nNot sure if the request made in the unit test passes through this middleware, but I think the fix should be as simple as checking if the url contains a scheme and if not adding a '//' to the front in `webclient._parse`. What do you think? ",
      "comment_id": 447091099,
      "user": "ajaymittur",
      "created_at": "2020-06-29T16:15:31Z",
      "url": "https://github.com/scrapy/scrapy/pull/4649#discussion_r447091099"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 4649,
      "file_path": "tests/test_downloader_handlers.py",
      "line": 744,
      "side": "RIGHT",
      "diff_hunk": "@@ -733,6 +735,16 @@ def test_download_with_proxy_https_timeout(self):\n         timeout = yield self.assertFailure(d, error.TimeoutError)\n         self.assertIn(domain, timeout.osError)\n \n+    def test_download_with_proxy_without_http_scheme(self):\n+        def _test(response):\n+            self.assertEqual(response.status, 200)\n+            self.assertEqual(response.url, request.url)\n+            self.assertEqual(response.body, b'http://example.com')\n+\n+        http_proxy = self.getURL('').replace('http:', '')",
      "comment": "> I think the fix should be as simple as checking if the url contains a scheme and if not adding a '//' to the front in webclient._parse. What do you think?\r\n\r\nSounds good to me.",
      "comment_id": 447838534,
      "user": "Gallaecio",
      "created_at": "2020-06-30T16:58:25Z",
      "url": "https://github.com/scrapy/scrapy/pull/4649#discussion_r447838534"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 4649,
      "file_path": "tests/test_downloader_handlers.py",
      "line": 744,
      "side": "RIGHT",
      "diff_hunk": "@@ -733,6 +735,16 @@ def test_download_with_proxy_https_timeout(self):\n         timeout = yield self.assertFailure(d, error.TimeoutError)\n         self.assertIn(domain, timeout.osError)\n \n+    def test_download_with_proxy_without_http_scheme(self):\n+        def _test(response):\n+            self.assertEqual(response.status, 200)\n+            self.assertEqual(response.url, request.url)\n+            self.assertEqual(response.body, b'http://example.com')\n+\n+        http_proxy = self.getURL('').replace('http:', '')",
      "comment": "The original issue is that users enter the domain name without a protocol, so we cannot expect them to add `//`.\r\n\r\nWhat about prepending `//` if the URL does not match `^\\w+://`?",
      "comment_id": 447900065,
      "user": "Gallaecio",
      "created_at": "2020-06-30T18:39:11Z",
      "url": "https://github.com/scrapy/scrapy/pull/4649#discussion_r447900065"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 4649,
      "file_path": "tests/test_downloader_handlers.py",
      "line": 744,
      "side": "RIGHT",
      "diff_hunk": "@@ -733,6 +735,16 @@ def test_download_with_proxy_https_timeout(self):\n         timeout = yield self.assertFailure(d, error.TimeoutError)\n         self.assertIn(domain, timeout.osError)\n \n+    def test_download_with_proxy_without_http_scheme(self):\n+        def _test(response):\n+            self.assertEqual(response.status, 200)\n+            self.assertEqual(response.url, request.url)\n+            self.assertEqual(response.body, b'http://example.com')\n+\n+        http_proxy = self.getURL('').replace('http:', '')",
      "comment": "This issue **doesn't seem to exist** when a user creates a spider and runs it, only seems to exist while writing unit tests ie. when using `http_proxy = self.getURL('').replace('http://', '')`\r\n\r\n> It actually works fine on the user-end, I created the following spider and ran it.\r\n> \r\n> ```\r\n> import scrapy\r\n> \r\n> class ExampleSpider(scrapy.Spider):\r\n>     name = 'example'\r\n> \r\n>     def start_requests(self):\r\n>         proxies = [\"example-proxy.com:9999\", \"//example-proxy.com:9999\", \"http://example-proxy.com:9999\"]\r\n>         for proxy in proxies:\r\n>             yield scrapy.Request(url='http://quotes.toscrape.com/page/1/', callback=self.parse, meta={\"proxy\": proxy})\r\n> \r\n>     def parse(self, response):\r\n>         print('Finished Successfully')\r\n> ```\r\n> \r\n> The `httpproxy` middleware is able to parse the proxy url correctly in [these 2 lines](https://github.com/scrapy/scrapy/blob/master/scrapy/downloadermiddlewares/httpproxy.py#L32-L33) (found while debugging that `urlunparse` prepends the '//' while unparsing the `_parse_proxy` result).\r\n",
      "comment_id": 447938281,
      "user": "ajaymittur",
      "created_at": "2020-06-30T19:48:13Z",
      "url": "https://github.com/scrapy/scrapy/pull/4649#discussion_r447938281"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 4649,
      "file_path": "tests/test_downloader_handlers.py",
      "line": 744,
      "side": "RIGHT",
      "diff_hunk": "@@ -733,6 +735,16 @@ def test_download_with_proxy_https_timeout(self):\n         timeout = yield self.assertFailure(d, error.TimeoutError)\n         self.assertIn(domain, timeout.osError)\n \n+    def test_download_with_proxy_without_http_scheme(self):\n+        def _test(response):\n+            self.assertEqual(response.status, 200)\n+            self.assertEqual(response.url, request.url)\n+            self.assertEqual(response.body, b'http://example.com')\n+\n+        http_proxy = self.getURL('').replace('http:', '')",
      "comment": "I\u2019m guessing the reason it happens in the test is because it happens with `localhost` as proxy. You could argue that `localhost` being the proxy is uncommon, but still I think we should support it, specially if it\u2019s trivial to support.",
      "comment_id": 447965472,
      "user": "Gallaecio",
      "created_at": "2020-06-30T20:40:45Z",
      "url": "https://github.com/scrapy/scrapy/pull/4649#discussion_r447965472"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 4649,
      "file_path": "scrapy/core/downloader/handlers/http11.py",
      "line": 324,
      "side": "LEFT",
      "diff_hunk": "@@ -319,9 +319,13 @@ def _get_agent(self, request, timeout):\n                     pool=self._pool,\n                 )\n             else:\n+                proxyScheme = b'http' if not proxyScheme else proxyScheme\n+                proxyHost = to_bytes(proxyHost, encoding='ascii')\n+                proxyPort = to_bytes(str(proxyPort), encoding='ascii')\n+                proxyURI = urlunparse((proxyScheme, proxyNetloc, proxyParams, '', '', ''))\n                 return self._ProxyAgent(\n                     reactor=reactor,\n-                    proxyURI=to_bytes(proxy, encoding='ascii'),",
      "comment": "Had to construct `proxyURI` and pass it to `_ProxyAgent` since `proxy` is the schemaless url with the incorrect format (not starting with `//`)",
      "comment_id": 448190183,
      "user": "ajaymittur",
      "created_at": "2020-07-01T08:07:16Z",
      "url": "https://github.com/scrapy/scrapy/pull/4649#discussion_r448190183"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 4649,
      "file_path": "scrapy/core/downloader/webclient.py",
      "line": 3,
      "side": "RIGHT",
      "diff_hunk": "@@ -1,5 +1,6 @@\n from time import time\n from urllib.parse import urlparse, urlunparse, urldefrag\n+from re import match",
      "comment": ":lipstick: `re` is usually imported as a whole. But in any case, it should still be the first import in the file, to keep things alphabetical.",
      "comment_id": 448261987,
      "user": "Gallaecio",
      "created_at": "2020-07-01T10:13:18Z",
      "url": "https://github.com/scrapy/scrapy/pull/4649#discussion_r448261987"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 5162,
      "file_path": "scrapy/core/engine.py",
      "line": 272,
      "side": "RIGHT",
      "diff_hunk": "@@ -269,7 +269,7 @@ def _downloaded(\n     ) -> Union[Deferred, Response]:\n         assert self.slot is not None  # typing\n         self.slot.remove_request(request)\n-        return self.download(result, spider) if isinstance(result, Request) else result\n+        return self.download(result) if isinstance(result, Request) else result",
      "comment": "If I recall right, @elacuesta was working on this, and the reason that argument remains there is for backward compatibility (_downloaded is private, but callers of _downloaded that are not private pass the `spider` argumetn and that argument should be passed).\r\n\r\nI do understand that self.download must be logging a warning when called with that parameter. Maybe we could make it so that calls that come from _downloaded do not cause the warning.",
      "comment_id": 639824560,
      "user": "Gallaecio",
      "created_at": "2021-05-26T15:12:48Z",
      "url": "https://github.com/scrapy/scrapy/pull/5162#discussion_r639824560"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 5007,
      "file_path": "scrapy/core/downloader/handlers/http11.py",
      "line": 172,
      "side": "RIGHT",
      "diff_hunk": "@@ -167,7 +169,7 @@ def processProxyResponse(self, rcvd_bytes):\n                 extra = {'status': int(respm.group('status')),\n                          'reason': respm.group('reason').strip()}\n             else:\n-                extra = rcvd_bytes[:32]\n+                extra = rcvd_bytes[:_truncatedLength]",
      "comment": "I was confused as to why tests were passing, because you are using `_truncatedLength` instead of `self._truncatedLength` here.\r\n\r\nThen I saw your comment about being confused yourself, and I think you mean that you don\u2019t understand why the coverage complains. It turns out our current tests do not test this line, that\u2019s why code coverage is incomplete. It was not covered before either. And new code should be covered by tests.\r\n\r\nIn this specific case, the code would have failed, which is why tests are so important. Please, have a look at the existing tests, and see if you can create a new test that covers this line. Otherwise, please let me know, maybe I can add one myself.",
      "comment_id": 590281879,
      "user": "Gallaecio",
      "created_at": "2021-03-09T11:51:56Z",
      "url": "https://github.com/scrapy/scrapy/pull/5007#discussion_r590281879"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 5007,
      "file_path": "scrapy/core/downloader/handlers/http11.py",
      "line": 126,
      "side": "RIGHT",
      "diff_hunk": "@@ -121,8 +121,9 @@ class TunnelingTCP4ClientEndpoint(TCP4ClientEndpoint):\n     with this endpoint comes from the pool and a CONNECT has already been issued\n     for it.\n     \"\"\"\n-\n-    _responseMatcher = re.compile(br'HTTP/1\\.. (?P<status>\\d{3})(?P<reason>.{,32})')\n+    _truncatedLength = 1000\n+    _responseAnswer = 'HTTP/1\\\\.. (?P<status>\\\\d{3})(?P<reason>.{,' + str(_truncatedLength) + '})'\n+    _responseMatcher = re.compile(fr'{_responseAnswer}'.encode('utf-8'))",
      "comment": "This should be the same:\r\n\r\n```suggestion\r\n    _responseMatcher = re.compile(_responseAnswer.encode())\r\n```",
      "comment_id": 590283760,
      "user": "Gallaecio",
      "created_at": "2021-03-09T11:53:38Z",
      "url": "https://github.com/scrapy/scrapy/pull/5007#discussion_r590283760"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 5007,
      "file_path": "scrapy/core/downloader/handlers/http11.py",
      "line": 125,
      "side": "RIGHT",
      "diff_hunk": "@@ -121,8 +121,9 @@ class TunnelingTCP4ClientEndpoint(TCP4ClientEndpoint):\n     with this endpoint comes from the pool and a CONNECT has already been issued\n     for it.\n     \"\"\"\n-\n-    _responseMatcher = re.compile(br'HTTP/1\\.. (?P<status>\\d{3})(?P<reason>.{,32})')\n+    _truncatedLength = 1000\n+    _responseAnswer = 'HTTP/1\\\\.. (?P<status>\\\\d{3})(?P<reason>.{,' + str(_truncatedLength) + '})'",
      "comment": "This should be a raw string (`r''`), to make it clear that the use of `\\` is not for escape sequences.",
      "comment_id": 590284939,
      "user": "Gallaecio",
      "created_at": "2021-03-09T11:54:42Z",
      "url": "https://github.com/scrapy/scrapy/pull/5007#discussion_r590284939"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 5007,
      "file_path": "scrapy/core/downloader/handlers/http11.py",
      "line": 172,
      "side": "RIGHT",
      "diff_hunk": "@@ -167,7 +169,7 @@ def processProxyResponse(self, rcvd_bytes):\n                 extra = {'status': int(respm.group('status')),\n                          'reason': respm.group('reason').strip()}\n             else:\n-                extra = rcvd_bytes[:32]\n+                extra = rcvd_bytes[:_truncatedLength]",
      "comment": "I made the corrections for other changes you told me and went through how the tests work. It would be great if you can add a test for this particular case or give a clear idea about how to go through it. ",
      "comment_id": 594458281,
      "user": "Bhavesh0327",
      "created_at": "2021-03-15T15:51:32Z",
      "url": "https://github.com/scrapy/scrapy/pull/5007#discussion_r594458281"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 5130,
      "file_path": "scrapy/utils/reqser.py",
      "line": 14,
      "side": "RIGHT",
      "diff_hunk": "@@ -1,95 +1,18 @@\n-\"\"\"\n-Helper functions for serializing (and deserializing) requests.\n-\"\"\"\n-import inspect\n+import warnings\n+from typing import Optional\n \n-from scrapy.http import Request\n-from scrapy.utils.python import to_unicode\n-from scrapy.utils.misc import load_object\n+import scrapy\n+from scrapy.exceptions import ScrapyDeprecationWarning\n+from scrapy.utils.request import request_from_dict  # noqa: F401\n \n \n-def request_to_dict(request, spider=None):\n-    \"\"\"Convert Request object to a dict.\n+warnings.warn(\n+    (\"Module `scrapy.utils.reqser` is deprecated, please use `scrapy.Request.to_dict` \"\n+     \" and/or`scrapy.utils.request.request_from_dict` instead\"),\n+    category=ScrapyDeprecationWarning,\n+    stacklevel=2,\n+)",
      "comment": "There\u2019s a missing space, and I would use nothing, single quotes or double quotes instead of a [grave accent](https://en.wikipedia.org/wiki/Grave_accent).\r\n\r\n```suggestion\r\nwarnings.warn(\r\n    (\"Module scrapy.utils.reqser is deprecated, please use scrapy.Request.to_dict \"\r\n     \" and/or scrapy.utils.request.request_from_dict instead\"),\r\n    category=ScrapyDeprecationWarning,\r\n    stacklevel=2,\r\n)\r\n```",
      "comment_id": 625868303,
      "user": "Gallaecio",
      "created_at": "2021-05-04T15:11:50Z",
      "url": "https://github.com/scrapy/scrapy/pull/5130#discussion_r625868303"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 5130,
      "file_path": "scrapy/http/request/__init__.py",
      "line": 150,
      "side": "RIGHT",
      "diff_hunk": "@@ -136,8 +142,43 @@ def from_curl(cls, curl_command, ignore_unknown_options=True, **kwargs):\n \n         To translate a cURL command into a Scrapy request,\n         you may use `curl2scrapy <https://michael-shub.github.io/curl2scrapy/>`_.\n-\n-       \"\"\"\n+        \"\"\"\n         request_kwargs = curl_to_request_kwargs(curl_command, ignore_unknown_options)\n         request_kwargs.update(kwargs)\n         return cls(**request_kwargs)\n+\n+    def to_dict(self, spider: Optional[\"scrapy.Spider\"] = None) -> dict:",
      "comment": "I wonder if we should make the parameter keyword-only.",
      "comment_id": 625869367,
      "user": "Gallaecio",
      "created_at": "2021-05-04T15:13:03Z",
      "url": "https://github.com/scrapy/scrapy/pull/5130#discussion_r625869367"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 5130,
      "file_path": "scrapy/utils/request.py",
      "line": 119,
      "side": "RIGHT",
      "diff_hunk": "@@ -106,3 +107,26 @@ def referer_str(request: Request) -> Optional[str]:\n     if referrer is None:\n         return referrer\n     return to_unicode(referrer, errors='replace')\n+\n+\n+def request_from_dict(d: dict, spider: Optional[Spider] = None) -> Request:\n+    \"\"\"Create Request object from a dict.\n+\n+    If a spider is given, it will try to resolve the callbacks looking at the\n+    spider for methods with the same name.\n+    \"\"\"\n+    request_cls = load_object(d[\"_class\"]) if \"_class\" in d else Request\n+    kwargs = {key: value for key, value in d.items() if key in request_cls._attributes}",
      "comment": "Since we expect Request subclasses to extend that variable as needed, maybe it should not be private.",
      "comment_id": 625870698,
      "user": "Gallaecio",
      "created_at": "2021-05-04T15:14:39Z",
      "url": "https://github.com/scrapy/scrapy/pull/5130#discussion_r625870698"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 5130,
      "file_path": "scrapy/utils/reqser.py",
      "line": 14,
      "side": "RIGHT",
      "diff_hunk": "@@ -1,95 +1,18 @@\n-\"\"\"\n-Helper functions for serializing (and deserializing) requests.\n-\"\"\"\n-import inspect\n+import warnings\n+from typing import Optional\n \n-from scrapy.http import Request\n-from scrapy.utils.python import to_unicode\n-from scrapy.utils.misc import load_object\n+import scrapy\n+from scrapy.exceptions import ScrapyDeprecationWarning\n+from scrapy.utils.request import request_from_dict  # noqa: F401\n \n \n-def request_to_dict(request, spider=None):\n-    \"\"\"Convert Request object to a dict.\n+warnings.warn(\n+    (\"Module `scrapy.utils.reqser` is deprecated, please use `scrapy.Request.to_dict` \"\n+     \" and/or`scrapy.utils.request.request_from_dict` instead\"),\n+    category=ScrapyDeprecationWarning,\n+    stacklevel=2,\n+)",
      "comment": "No objections here, thanks. Just as a note, this is done in the [`scrapy.utils.py36`](https://github.com/scrapy/scrapy/blob/2.5.0/scrapy/utils/py36.py#L8) module as well.",
      "comment_id": 625918597,
      "user": "elacuesta",
      "created_at": "2021-05-04T16:15:05Z",
      "url": "https://github.com/scrapy/scrapy/pull/5130#discussion_r625918597"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 5130,
      "file_path": "scrapy/http/request/json_request.py",
      "line": 46,
      "side": "RIGHT",
      "diff_hunk": "@@ -36,6 +40,12 @@ def __init__(self, *args, **kwargs):\n         self.headers.setdefault('Content-Type', 'application/json')\n         self.headers.setdefault('Accept', 'application/json, text/javascript, */*; q=0.01')\n \n+    @property\n+    def dumps_kwargs(self):\n+        if self._dumps_kwargs is None:\n+            self._dumps_kwargs = {}",
      "comment": "Looking at [the coverage results](https://app.codecov.io/gh/scrapy/scrapy/compare/5130/diff#D5L45) and then at `__init__` above, it seems these 2 lines are unnecessary.",
      "comment_id": 626329590,
      "user": "Gallaecio",
      "created_at": "2021-05-05T07:35:43Z",
      "url": "https://github.com/scrapy/scrapy/pull/5130#discussion_r626329590"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 5130,
      "file_path": "scrapy/utils/request.py",
      "line": 112,
      "side": "RIGHT",
      "diff_hunk": "@@ -106,3 +107,27 @@ def referer_str(request: Request) -> Optional[str]:\n     if referrer is None:\n         return referrer\n     return to_unicode(referrer, errors='replace')\n+\n+\n+def request_from_dict(d: dict, spider: Optional[Spider] = None) -> Request:",
      "comment": "```suggestion\r\ndef request_from_dict(d: dict, *, spider: Optional[Spider] = None) -> Request:\r\n```",
      "comment_id": 626337390,
      "user": "Gallaecio",
      "created_at": "2021-05-05T07:47:33Z",
      "url": "https://github.com/scrapy/scrapy/pull/5130#discussion_r626337390"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 5130,
      "file_path": "tests/test_request_dict.py",
      "line": 153,
      "side": "RIGHT",
      "diff_hunk": "@@ -130,7 +138,22 @@ def parse(self, response):\n         spider = MySpider()\n         r = Request(\"http://www.example.com\", callback=spider.parse)\n         setattr(spider, 'parse', None)\n-        self.assertRaises(ValueError, request_to_dict, r, spider=spider)\n+        self.assertRaises(ValueError, r.to_dict, spider=spider)\n+\n+    def test_callback_not_available(self):\n+        \"\"\"Callback method is not available in the spider passed to from_dict\"\"\"\n+        spider = TestSpiderDelegation()\n+        r = Request(\"http://www.example.com\", callback=spider.delegated_callback)\n+        d = r.to_dict(spider=spider)\n+        self.assertRaises(ValueError, request_from_dict, d, spider=Spider(\"foo\"))\n+\n+\n+class DeprecatedMethodsRequestSerializationTest(RequestSerializationTest):\n+    def _assert_serializes_ok(self, request, spider=None):\n+        from scrapy.utils.reqser import request_from_dict as _request_from_dict, request_to_dict as _request_to_dict",
      "comment": "I\u2019m not sure it\u2019s worth it, but for completeness maybe we could catch the deprecation warning logged by this import, just for the sake of verifying it\u2019s there.",
      "comment_id": 626339784,
      "user": "Gallaecio",
      "created_at": "2021-05-05T07:51:36Z",
      "url": "https://github.com/scrapy/scrapy/pull/5130#discussion_r626339784"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 5130,
      "file_path": "tests/test_request_dict.py",
      "line": 153,
      "side": "RIGHT",
      "diff_hunk": "@@ -130,7 +138,22 @@ def parse(self, response):\n         spider = MySpider()\n         r = Request(\"http://www.example.com\", callback=spider.parse)\n         setattr(spider, 'parse', None)\n-        self.assertRaises(ValueError, request_to_dict, r, spider=spider)\n+        self.assertRaises(ValueError, r.to_dict, spider=spider)\n+\n+    def test_callback_not_available(self):\n+        \"\"\"Callback method is not available in the spider passed to from_dict\"\"\"\n+        spider = TestSpiderDelegation()\n+        r = Request(\"http://www.example.com\", callback=spider.delegated_callback)\n+        d = r.to_dict(spider=spider)\n+        self.assertRaises(ValueError, request_from_dict, d, spider=Spider(\"foo\"))\n+\n+\n+class DeprecatedMethodsRequestSerializationTest(RequestSerializationTest):\n+    def _assert_serializes_ok(self, request, spider=None):\n+        from scrapy.utils.reqser import request_from_dict as _request_from_dict, request_to_dict as _request_to_dict",
      "comment": "I actually attempted to do so, but I kept having issues with the warnings not being reset and appearing only once, which made only the first check succeed. Consider the following:\r\n```python\r\nPython 3.8.2 (default, Apr 18 2020, 17:39:30) \r\nType 'copyright', 'credits' or 'license' for more information\r\nIPython 7.22.0 -- An enhanced Interactive Python. Type '?' for help.\r\n\r\nIn [1]: import warnings\r\n\r\nIn [2]: warnings.simplefilter(\"always\")\r\n\r\nIn [3]: from scrapy.utils.reqser import request_to_dict\r\n<ipython-input-3-75e30ca4f2be>:1: ScrapyDeprecationWarning: Module scrapy.utils.reqser is deprecated, please use scrapy.Request.to_dict  and/or scrapy.utils.request.request_from_dict instead\r\n  from scrapy.utils.reqser import request_to_dict\r\n\r\nIn [4]: warnings.resetwarnings()\r\n\r\nIn [5]: del request_to_dict\r\n\r\nIn [6]: from scrapy.utils.reqser import request_to_dict  # no warning here\r\n\r\nIn [7]: \r\n```\r\n\r\nIt seems like this is caused by the warning being raised at module level. It does work if it's deleted with `del sys.modules[\"scrapy.utils.reqser\"]`, it's a bit dirty but it should be safe within a test.",
      "comment_id": 626521171,
      "user": "elacuesta",
      "created_at": "2021-05-05T12:30:31Z",
      "url": "https://github.com/scrapy/scrapy/pull/5130#discussion_r626521171"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 5130,
      "file_path": "scrapy/http/request/__init__.py",
      "line": 28,
      "side": "RIGHT",
      "diff_hunk": "@@ -4,17 +4,36 @@\n \n See documentation in docs/topics/request-response.rst\n \"\"\"\n+import inspect\n+from typing import Optional, Tuple\n+\n from w3lib.url import safe_url_string\n \n+import scrapy\n+from scrapy.http.common import obsolete_setter\n from scrapy.http.headers import Headers\n-from scrapy.utils.python import to_bytes\n+from scrapy.utils.curl import curl_to_request_kwargs\n+from scrapy.utils.python import to_bytes, to_unicode\n from scrapy.utils.trackref import object_ref\n from scrapy.utils.url import escape_ajax\n-from scrapy.http.common import obsolete_setter\n-from scrapy.utils.curl import curl_to_request_kwargs\n \n \n class Request(object_ref):\n+    \"\"\"Represents an HTTP request, which is usually generated in a Spider and\n+    executed by the Downloader, thus generating a :class:`Response`.\n+    \"\"\"\n+\n+    attributes: Tuple[str, ...] = (\n+        \"url\", \"method\", \"headers\", \"body\", \"cookies\", \"meta\", \"flags\",\n+        \"encoding\", \"priority\", \"dont_filter\", \"callback\", \"errback\", \"cb_kwargs\",",
      "comment": "A nitpick: would it make sense to use the same order as in `__init__`, to make it easier to ensure they match?",
      "comment_id": 628784689,
      "user": "kmike",
      "created_at": "2021-05-08T19:02:12Z",
      "url": "https://github.com/scrapy/scrapy/pull/5130#discussion_r628784689"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 5130,
      "file_path": "scrapy/http/request/__init__.py",
      "line": 169,
      "side": "RIGHT",
      "diff_hunk": "@@ -136,8 +152,43 @@ def from_curl(cls, curl_command, ignore_unknown_options=True, **kwargs):\n \n         To translate a cURL command into a Scrapy request,\n         you may use `curl2scrapy <https://michael-shub.github.io/curl2scrapy/>`_.\n-\n-       \"\"\"\n+        \"\"\"\n         request_kwargs = curl_to_request_kwargs(curl_command, ignore_unknown_options)\n         request_kwargs.update(kwargs)\n         return cls(**request_kwargs)\n+\n+    def to_dict(self, *, spider: Optional[\"scrapy.Spider\"] = None) -> dict:\n+        \"\"\"Return a dictionary containing the Request's data.\n+\n+        Use :func:`~scrapy.utils.request.request_from_dict` to convert back into a :class:`~scrapy.Request` object.\n+\n+        If a spider is given, this method will try to find out the name of the spider method used\n+        as callback and include it in the output dict, raising an exception if it cannot be found.\n+        \"\"\"\n+        d = {\n+            \"url\": to_unicode(self.url),  # urls are safe (safe_string_url)",
      "comment": "btw, it seems to_unicode is redundant now, becase self._set_url raises an error if url is bytes.",
      "comment_id": 628912231,
      "user": "kmike",
      "created_at": "2021-05-09T16:23:04Z",
      "url": "https://github.com/scrapy/scrapy/pull/5130#discussion_r628912231"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 5130,
      "file_path": "scrapy/utils/reqser.py",
      "line": 10,
      "side": "RIGHT",
      "diff_hunk": "@@ -1,95 +1,22 @@\n-\"\"\"\n-Helper functions for serializing (and deserializing) requests.\n-\"\"\"\n-import inspect\n+import warnings\n+from typing import Optional\n \n-from scrapy.http import Request\n-from scrapy.utils.python import to_unicode\n-from scrapy.utils.misc import load_object\n+import scrapy\n+from scrapy.exceptions import ScrapyDeprecationWarning\n+from scrapy.utils.request import request_from_dict as _from_dict\n \n \n-def request_to_dict(request, spider=None):\n-    \"\"\"Convert Request object to a dict.\n+warnings.warn(\n+    (\"Module scrapy.utils.reqser is deprecated, please use scrapy.Request.to_dict\"",
      "comment": "```suggestion\r\n    (\"Module scrapy.utils.reqser is deprecated, please use request.to_dict method\"\r\n```\r\n\r\nWhat do you think about ^^? It is a bit more confusing, but a bit more precise as well; e.g. if you're serializing a custom request, you shouldn't be using scrapy.Request.to_dict.",
      "comment_id": 628913393,
      "user": "kmike",
      "created_at": "2021-05-09T16:33:31Z",
      "url": "https://github.com/scrapy/scrapy/pull/5130#discussion_r628913393"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 5112,
      "file_path": "scrapy/pqueues.py",
      "line": 108,
      "side": "RIGHT",
      "diff_hunk": "@@ -99,6 +104,13 @@ def pop(self):\n             self.curprio = min(prios) if prios else None\n         return m\n \n+    def peek(self):\n+        \"\"\"NotImplementedError might be raised from the underlying queue\"\"\"",
      "comment": "While it\u2019s great that this is documented, it should not be the first paragraph.\r\n\r\nParaphrasing you above:\r\n\r\n```suggestion\r\n        \"\"\"Returns the next object to be returned by :meth:`pop`, but without \r\n        removing it from the queue.\r\n\r\n        Raises :exc:`NotImplementedError` if the underlying queue class does \r\n        not implement a ``peek`` method, which is optional for queues.\r\n        \"\"\"\r\n```\r\n\r\nSame applies to similar changes below.",
      "comment_id": 620377597,
      "user": "Gallaecio",
      "created_at": "2021-04-26T14:56:24Z",
      "url": "https://github.com/scrapy/scrapy/pull/5112#discussion_r620377597"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 3559,
      "file_path": "scrapy/core/scheduler.py",
      "line": 20,
      "side": "RIGHT",
      "diff_hunk": "@@ -16,17 +17,75 @@\n logger = logging.getLogger(__name__)\n \n \n-class Scheduler:\n+class BaseScheduler:",
      "comment": "I think we should either raise `NotImplementedError` or mark as `@abstractmethod` those methods that do not simply work as implemented here (all except `open` and `close`).",
      "comment_id": 601165067,
      "user": "Gallaecio",
      "created_at": "2021-03-25T07:55:58Z",
      "url": "https://github.com/scrapy/scrapy/pull/3559#discussion_r601165067"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 3559,
      "file_path": "scrapy/core/scheduler.py",
      "line": 192,
      "side": "RIGHT",
      "diff_hunk": "@@ -48,33 +153,56 @@ def __init__(self, dupefilter, jobdir=None, dqclass=None, mqclass=None,\n \n     @classmethod\n     def from_crawler(cls, crawler):\n-        settings = crawler.settings\n-        dupefilter_cls = load_object(settings['DUPEFILTER_CLASS'])\n-        dupefilter = create_instance(dupefilter_cls, settings, crawler)\n-        pqclass = load_object(settings['SCHEDULER_PRIORITY_QUEUE'])\n-        dqclass = load_object(settings['SCHEDULER_DISK_QUEUE'])\n-        mqclass = load_object(settings['SCHEDULER_MEMORY_QUEUE'])\n-        logunser = settings.getbool('SCHEDULER_DEBUG')\n-        return cls(dupefilter, jobdir=job_dir(settings), logunser=logunser,\n-                   stats=crawler.stats, pqclass=pqclass, dqclass=dqclass,\n-                   mqclass=mqclass, crawler=crawler)\n-\n-    def has_pending_requests(self):\n+        \"\"\"\n+        Factory method, initializes the scheduler with arguments taken from the crawl settings\n+        \"\"\"\n+        dupefilter_cls = load_object(crawler.settings['DUPEFILTER_CLASS'])\n+        return cls(\n+            dupefilter=create_instance(dupefilter_cls, crawler.settings, crawler),\n+            jobdir=job_dir(crawler.settings),\n+            dqclass=load_object(crawler.settings['SCHEDULER_DISK_QUEUE']),\n+            mqclass=load_object(crawler.settings['SCHEDULER_MEMORY_QUEUE']),\n+            logunser=crawler.settings.getbool('SCHEDULER_DEBUG'),\n+            stats=crawler.stats,\n+            pqclass=load_object(crawler.settings['SCHEDULER_PRIORITY_QUEUE']),\n+            crawler=crawler,\n+        )\n+\n+    def has_pending_requests(self) -> bool:\n         return len(self) > 0\n \n-    def open(self, spider):\n+    def open(self, spider: Spider) -> Optional[Deferred]:\n+        \"\"\"\n+        (1) initialize the memory queue\n+        (2) initialize the disk queue if the ``jobdir`` attribute is a valid directory\n+        (3) return the result of the dupefilter's ``open`` method\n+        \"\"\"\n         self.spider = spider\n         self.mqs = self._mq()\n         self.dqs = self._dq() if self.dqdir else None\n         return self.df.open()\n \n-    def close(self, reason):\n-        if self.dqs:\n+    def close(self, reason: str) -> Optional[Deferred]:\n+        \"\"\"\n+        (1) dump pending requests to disk if there is a disk queue\n+        (2) return the result of the dupefilter's ``close`` method\n+        \"\"\"\n+        if self.dqs is not None:\n             state = self.dqs.close()\n+            assert isinstance(self.dqdir, str)",
      "comment": "This assertion is only to avoid a typing error in the next line (`_write_dqs_state` expects a `str` but it gets `Optional[str]`). At this point, if `self.dqs is not None` it's only because `self.dqdir` is a `str`.",
      "comment_id": 601734280,
      "user": "elacuesta",
      "created_at": "2021-03-25T18:15:02Z",
      "url": "https://github.com/scrapy/scrapy/pull/3559#discussion_r601734280"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 3559,
      "file_path": "scrapy/core/engine.py",
      "line": 90,
      "side": "RIGHT",
      "diff_hunk": "@@ -73,12 +74,22 @@ def __init__(self, crawler, spider_closed_callback: Callable) -> None:\n         self.spider: Optional[Spider] = None\n         self.running = False\n         self.paused = False\n-        self.scheduler_cls = load_object(crawler.settings[\"SCHEDULER\"])\n+        self.scheduler_cls = self._get_scheduler_class(crawler.settings)\n         downloader_cls = load_object(self.settings['DOWNLOADER'])\n         self.downloader = downloader_cls(crawler)\n         self.scraper = Scraper(crawler)\n         self._spider_closed_callback = spider_closed_callback\n \n+    def _get_scheduler_class(self, settings: BaseSettings) -> type:\n+        from scrapy.core.scheduler import BaseScheduler\n+        scheduler_cls = load_object(settings[\"SCHEDULER\"])\n+        if not issubclass(scheduler_cls, BaseScheduler):\n+            raise TypeError(\n+                f\"The provided scheduler class ({settings['SCHEDULER']})\"\n+                \" does not fully implement the scheduler interface\"\n+            )",
      "comment": "This will break any existing project with a custom scheduler class :sweat_smile: ",
      "comment_id": 616964497,
      "user": "Gallaecio",
      "created_at": "2021-04-20T19:10:25Z",
      "url": "https://github.com/scrapy/scrapy/pull/3559#discussion_r616964497"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 3559,
      "file_path": "scrapy/core/scheduler.py",
      "line": 90,
      "side": "RIGHT",
      "diff_hunk": "@@ -1,42 +1,169 @@\n-import os\n import json\n import logging\n-from os.path import join, exists\n+import os\n+from abc import abstractmethod\n+from os.path import exists, join\n+from typing import Optional, Type, TypeVar\n+\n+from twisted.internet.defer import Deferred\n \n-from scrapy.utils.misc import load_object, create_instance\n+from scrapy.crawler import Crawler\n+from scrapy.http.request import Request\n+from scrapy.spiders import Spider\n from scrapy.utils.job import job_dir\n+from scrapy.utils.misc import create_instance, load_object\n \n \n logger = logging.getLogger(__name__)\n \n \n-class Scheduler:\n+class BaseSchedulerMeta(type):\n     \"\"\"\n-    Scrapy Scheduler. It allows to enqueue requests and then get\n-    a next request to download. Scheduler is also handling duplication\n-    filtering, via dupefilter.\n-\n-    Prioritization and queueing is not performed by the Scheduler.\n-    User sets ``priority`` field for each Request, and a PriorityQueue\n-    (defined by :setting:`SCHEDULER_PRIORITY_QUEUE`) uses these priorities\n-    to dequeue requests in a desired order.\n-\n-    Scheduler uses two PriorityQueue instances, configured to work in-memory\n-    and on-disk (optional). When on-disk queue is present, it is used by\n-    default, and an in-memory queue is used as a fallback for cases where\n-    a disk queue can't handle a request (can't serialize it).\n-\n-    :setting:`SCHEDULER_MEMORY_QUEUE` and\n-    :setting:`SCHEDULER_DISK_QUEUE` allow to specify lower-level queue classes\n-    which PriorityQueue instances would be instantiated with, to keep requests\n-    on disk and in memory respectively.\n-\n-    Overall, Scheduler is an object which holds several PriorityQueue instances\n-    (in-memory and on-disk) and implements fallback logic for them.\n-    Also, it handles dupefilters.\n+    Metaclass to check scheduler classes against the necessary interface\n+    \"\"\"\n+    def __instancecheck__(cls, instance):\n+        return cls.__subclasscheck__(type(instance))\n+\n+    def __subclasscheck__(cls, subclass):\n+        return (\n+            hasattr(subclass, \"has_pending_requests\") and callable(subclass.has_pending_requests)\n+            and hasattr(subclass, \"enqueue_request\") and callable(subclass.enqueue_request)\n+            and hasattr(subclass, \"next_request\") and callable(subclass.next_request)\n+        )\n+\n+\n+class BaseScheduler(metaclass=BaseSchedulerMeta):\n+    \"\"\"\n+    The scheduler component is responsible for storing requests received from\n+    the engine, and feeding them back upon request (also to the engine).\n+\n+    The original sources of said requests are:\n+    * Spider: ``start_requests`` method, requests created for URLs in the ``start_urls`` attribute, request callbacks\n+    * Spider middleware: ``process_spider_output`` and ``process_spider_exception`` methods\n+    * Downloader middleware: ``process_request``, ``process_response`` and ``process_exception`` methods\n+\n+    The order in which the scheduler returns its stored requests (via the ``next_request`` method)\n+    plays a great part in determining the order in which those requests are downloaded.\n+\n+    The methods defined in this class constitute the minimal interface that the Scrapy engine will interact with.\n     \"\"\"\n-    def __init__(self, dupefilter, jobdir=None, dqclass=None, mqclass=None,\n-                 logunser=False, stats=None, pqclass=None, crawler=None):\n+\n+    @classmethod\n+    def from_crawler(cls, crawler: Crawler):\n+        \"\"\"\n+        Factory method which receives the current :class:`~scrapy.crawler.Crawler` object as argument.\n+        \"\"\"\n+        return cls()\n+\n+    def open(self, spider: Spider) -> Optional[Deferred]:\n+        \"\"\"\n+        Called when the spider is opened by the engine. It receives the spider\n+        instance as argument and it's useful to execute initialization code.\n+\n+        :param spider: the spider object for the current crawl\n+        :type spider: :class:`~scrapy.spiders.Spider`\n+        \"\"\"\n+        pass\n+\n+    def close(self, reason: str) -> Optional[Deferred]:\n+        \"\"\"\n+        Called when the spider is closed by the engine. It receives the reason why the crawl\n+        finished as argument and it's useful to execute cleaning code.\n+\n+        :param reason: a string which describes the reason why the spider was closed\n+        :type reason: :class:`str`\n+        \"\"\"\n+        pass\n+\n+    @abstractmethod\n+    def has_pending_requests(self) -> bool:\n+        \"\"\"\n+        ``True`` if the scheduler has enqueued requests, ``False`` otherwise\n+        \"\"\"\n+        raise NotImplementedError()\n+\n+    @abstractmethod\n+    def enqueue_request(self, request: Request) -> bool:\n+        \"\"\"\n+        Process a request received by the engine.\n+\n+        Return ``True`` if the request is to be considered scheduled, ``False`` otherwise.",
      "comment": "I think it would be best to extend this to make it more clear why you would ever return `False` (e.g. your scheduler stores requests in an external service that is temporarily unreachable?), and what\u2019s the consequence of doing so (is the request discarded, force-feeded into the engine, re-enqueued later?).",
      "comment_id": 616970051,
      "user": "Gallaecio",
      "created_at": "2021-04-20T19:19:36Z",
      "url": "https://github.com/scrapy/scrapy/pull/3559#discussion_r616970051"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 3559,
      "file_path": "scrapy/core/scheduler.py",
      "line": 98,
      "side": "RIGHT",
      "diff_hunk": "@@ -1,42 +1,169 @@\n-import os\n import json\n import logging\n-from os.path import join, exists\n+import os\n+from abc import abstractmethod\n+from os.path import exists, join\n+from typing import Optional, Type, TypeVar\n+\n+from twisted.internet.defer import Deferred\n \n-from scrapy.utils.misc import load_object, create_instance\n+from scrapy.crawler import Crawler\n+from scrapy.http.request import Request\n+from scrapy.spiders import Spider\n from scrapy.utils.job import job_dir\n+from scrapy.utils.misc import create_instance, load_object\n \n \n logger = logging.getLogger(__name__)\n \n \n-class Scheduler:\n+class BaseSchedulerMeta(type):\n     \"\"\"\n-    Scrapy Scheduler. It allows to enqueue requests and then get\n-    a next request to download. Scheduler is also handling duplication\n-    filtering, via dupefilter.\n-\n-    Prioritization and queueing is not performed by the Scheduler.\n-    User sets ``priority`` field for each Request, and a PriorityQueue\n-    (defined by :setting:`SCHEDULER_PRIORITY_QUEUE`) uses these priorities\n-    to dequeue requests in a desired order.\n-\n-    Scheduler uses two PriorityQueue instances, configured to work in-memory\n-    and on-disk (optional). When on-disk queue is present, it is used by\n-    default, and an in-memory queue is used as a fallback for cases where\n-    a disk queue can't handle a request (can't serialize it).\n-\n-    :setting:`SCHEDULER_MEMORY_QUEUE` and\n-    :setting:`SCHEDULER_DISK_QUEUE` allow to specify lower-level queue classes\n-    which PriorityQueue instances would be instantiated with, to keep requests\n-    on disk and in memory respectively.\n-\n-    Overall, Scheduler is an object which holds several PriorityQueue instances\n-    (in-memory and on-disk) and implements fallback logic for them.\n-    Also, it handles dupefilters.\n+    Metaclass to check scheduler classes against the necessary interface\n+    \"\"\"\n+    def __instancecheck__(cls, instance):\n+        return cls.__subclasscheck__(type(instance))\n+\n+    def __subclasscheck__(cls, subclass):\n+        return (\n+            hasattr(subclass, \"has_pending_requests\") and callable(subclass.has_pending_requests)\n+            and hasattr(subclass, \"enqueue_request\") and callable(subclass.enqueue_request)\n+            and hasattr(subclass, \"next_request\") and callable(subclass.next_request)\n+        )\n+\n+\n+class BaseScheduler(metaclass=BaseSchedulerMeta):\n+    \"\"\"\n+    The scheduler component is responsible for storing requests received from\n+    the engine, and feeding them back upon request (also to the engine).\n+\n+    The original sources of said requests are:\n+    * Spider: ``start_requests`` method, requests created for URLs in the ``start_urls`` attribute, request callbacks\n+    * Spider middleware: ``process_spider_output`` and ``process_spider_exception`` methods\n+    * Downloader middleware: ``process_request``, ``process_response`` and ``process_exception`` methods\n+\n+    The order in which the scheduler returns its stored requests (via the ``next_request`` method)\n+    plays a great part in determining the order in which those requests are downloaded.\n+\n+    The methods defined in this class constitute the minimal interface that the Scrapy engine will interact with.\n     \"\"\"\n-    def __init__(self, dupefilter, jobdir=None, dqclass=None, mqclass=None,\n-                 logunser=False, stats=None, pqclass=None, crawler=None):\n+\n+    @classmethod\n+    def from_crawler(cls, crawler: Crawler):\n+        \"\"\"\n+        Factory method which receives the current :class:`~scrapy.crawler.Crawler` object as argument.\n+        \"\"\"\n+        return cls()\n+\n+    def open(self, spider: Spider) -> Optional[Deferred]:\n+        \"\"\"\n+        Called when the spider is opened by the engine. It receives the spider\n+        instance as argument and it's useful to execute initialization code.\n+\n+        :param spider: the spider object for the current crawl\n+        :type spider: :class:`~scrapy.spiders.Spider`\n+        \"\"\"\n+        pass\n+\n+    def close(self, reason: str) -> Optional[Deferred]:\n+        \"\"\"\n+        Called when the spider is closed by the engine. It receives the reason why the crawl\n+        finished as argument and it's useful to execute cleaning code.\n+\n+        :param reason: a string which describes the reason why the spider was closed\n+        :type reason: :class:`str`\n+        \"\"\"\n+        pass\n+\n+    @abstractmethod\n+    def has_pending_requests(self) -> bool:\n+        \"\"\"\n+        ``True`` if the scheduler has enqueued requests, ``False`` otherwise\n+        \"\"\"\n+        raise NotImplementedError()\n+\n+    @abstractmethod\n+    def enqueue_request(self, request: Request) -> bool:\n+        \"\"\"\n+        Process a request received by the engine.\n+\n+        Return ``True`` if the request is to be considered scheduled, ``False`` otherwise.\n+        \"\"\"\n+        raise NotImplementedError()\n+\n+    @abstractmethod\n+    def next_request(self) -> Optional[Request]:\n+        \"\"\"\n+        Return the next :class:`~scrapy.http.Request` to be processed, or ``None``\n+        to indicate that there are no requests to be considered ready at the moment.",
      "comment": "It would be great to be more explicit about what happens when you return `None`, and how the engine plays with this method and with `has_pending_requests`. Maybe provide an example of a scenario where it makes sense to return `None`.",
      "comment_id": 616971163,
      "user": "Gallaecio",
      "created_at": "2021-04-20T19:21:32Z",
      "url": "https://github.com/scrapy/scrapy/pull/3559#discussion_r616971163"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 3559,
      "file_path": "scrapy/core/engine.py",
      "line": 90,
      "side": "RIGHT",
      "diff_hunk": "@@ -73,12 +74,22 @@ def __init__(self, crawler, spider_closed_callback: Callable) -> None:\n         self.spider: Optional[Spider] = None\n         self.running = False\n         self.paused = False\n-        self.scheduler_cls = load_object(crawler.settings[\"SCHEDULER\"])\n+        self.scheduler_cls = self._get_scheduler_class(crawler.settings)\n         downloader_cls = load_object(self.settings['DOWNLOADER'])\n         self.downloader = downloader_cls(crawler)\n         self.scraper = Scraper(crawler)\n         self._spider_closed_callback = spider_closed_callback\n \n+    def _get_scheduler_class(self, settings: BaseSettings) -> type:\n+        from scrapy.core.scheduler import BaseScheduler\n+        scheduler_cls = load_object(settings[\"SCHEDULER\"])\n+        if not issubclass(scheduler_cls, BaseScheduler):\n+            raise TypeError(\n+                f\"The provided scheduler class ({settings['SCHEDULER']})\"\n+                \" does not fully implement the scheduler interface\"\n+            )",
      "comment": "It shouldn't, the subclass check is done via a [metaclass](https://github.com/scrapy/scrapy/pull/3559/files#diff-e957998ce47b270d8ae072df61f91368d94a20bb7bff60c337a0900eb192bf6dR27), it makes sure the necessary methods exist. ",
      "comment_id": 617032995,
      "user": "elacuesta",
      "created_at": "2021-04-20T21:08:49Z",
      "url": "https://github.com/scrapy/scrapy/pull/3559#discussion_r617032995"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 3559,
      "file_path": "scrapy/core/engine.py",
      "line": 90,
      "side": "RIGHT",
      "diff_hunk": "@@ -73,12 +74,22 @@ def __init__(self, crawler, spider_closed_callback: Callable) -> None:\n         self.spider: Optional[Spider] = None\n         self.running = False\n         self.paused = False\n-        self.scheduler_cls = load_object(crawler.settings[\"SCHEDULER\"])\n+        self.scheduler_cls = self._get_scheduler_class(crawler.settings)\n         downloader_cls = load_object(self.settings['DOWNLOADER'])\n         self.downloader = downloader_cls(crawler)\n         self.scraper = Scraper(crawler)\n         self._spider_closed_callback = spider_closed_callback\n \n+    def _get_scheduler_class(self, settings: BaseSettings) -> type:\n+        from scrapy.core.scheduler import BaseScheduler\n+        scheduler_cls = load_object(settings[\"SCHEDULER\"])\n+        if not issubclass(scheduler_cls, BaseScheduler):\n+            raise TypeError(\n+                f\"The provided scheduler class ({settings['SCHEDULER']})\"\n+                \" does not fully implement the scheduler interface\"\n+            )",
      "comment": "Cool! Today I Learn that can be done. I should have had a closer look at the metaclass implementation.",
      "comment_id": 617221246,
      "user": "Gallaecio",
      "created_at": "2021-04-21T05:57:41Z",
      "url": "https://github.com/scrapy/scrapy/pull/3559#discussion_r617221246"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 5090,
      "file_path": "scrapy/core/engine.py",
      "line": 31,
      "side": "RIGHT",
      "diff_hunk": "@@ -6,46 +6,55 @@\n \"\"\"\n import logging\n from time import time\n+from typing import Callable, Iterable, Iterator, Optional, Set, Union\n \n-from twisted.internet import defer, task\n+from twisted.internet.defer import Deferred, DeferredList, inlineCallbacks, succeed as defer_succeed\n+from twisted.internet.task import LoopingCall\n from twisted.python.failure import Failure\n \n from scrapy import signals\n from scrapy.core.scraper import Scraper\n from scrapy.exceptions import DontCloseSpider\n from scrapy.http import Response, Request\n-from scrapy.utils.misc import load_object\n-from scrapy.utils.reactor import CallLaterOnce\n+from scrapy.spiders import Spider\n from scrapy.utils.log import logformatter_adapter, failure_to_exc_info\n+from scrapy.utils.misc import create_instance, load_object\n+from scrapy.utils.reactor import CallLaterOnce\n+\n \n logger = logging.getLogger(__name__)\n \n \n class Slot:\n \n-    def __init__(self, start_requests, close_if_idle, nextcall, scheduler):\n-        self.closing = False\n-        self.inprogress = set()  # requests in progress\n-        self.start_requests = iter(start_requests)\n+    def __init__(\n+        self, start_requests: Iterable,",
      "comment": "```suggestion\r\n        self,\r\n        start_requests: Iterable,\r\n```",
      "comment_id": 609745380,
      "user": "Gallaecio",
      "created_at": "2021-04-08T14:11:50Z",
      "url": "https://github.com/scrapy/scrapy/pull/5090#discussion_r609745380"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 5090,
      "file_path": "scrapy/core/engine.py",
      "line": 37,
      "side": "RIGHT",
      "diff_hunk": "@@ -6,46 +6,55 @@\n \"\"\"\n import logging\n from time import time\n+from typing import Callable, Iterable, Iterator, Optional, Set, Union\n \n-from twisted.internet import defer, task\n+from twisted.internet.defer import Deferred, DeferredList, inlineCallbacks, succeed as defer_succeed\n+from twisted.internet.task import LoopingCall\n from twisted.python.failure import Failure\n \n from scrapy import signals\n from scrapy.core.scraper import Scraper\n from scrapy.exceptions import DontCloseSpider\n from scrapy.http import Response, Request\n-from scrapy.utils.misc import load_object\n-from scrapy.utils.reactor import CallLaterOnce\n+from scrapy.spiders import Spider\n from scrapy.utils.log import logformatter_adapter, failure_to_exc_info\n+from scrapy.utils.misc import create_instance, load_object\n+from scrapy.utils.reactor import CallLaterOnce\n+\n \n logger = logging.getLogger(__name__)\n \n \n class Slot:\n \n-    def __init__(self, start_requests, close_if_idle, nextcall, scheduler):\n-        self.closing = False\n-        self.inprogress = set()  # requests in progress\n-        self.start_requests = iter(start_requests)\n+    def __init__(\n+        self, start_requests: Iterable,\n+        close_if_idle: bool,\n+        nextcall: CallLaterOnce,\n+        scheduler,\n+    ) -> None:\n+        self.closing: Optional[Deferred] = None\n+        self.inprogress: Set[Request] = set()  # requests in progress",
      "comment": "I think type hints make the commend unnecessary here.\r\n\r\n```suggestion\r\n        self.inprogress: Set[Request] = set()\r\n```",
      "comment_id": 609747350,
      "user": "Gallaecio",
      "created_at": "2021-04-08T14:13:55Z",
      "url": "https://github.com/scrapy/scrapy/pull/5090#discussion_r609747350"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 5090,
      "file_path": "scrapy/core/engine.py",
      "line": 147,
      "side": "RIGHT",
      "diff_hunk": "@@ -102,188 +109,175 @@ def close(self):\n             # Will also close downloader\n             return self._close_all_spiders()\n         else:\n-            return defer.succeed(self.downloader.close())\n+            return defer_succeed(self.downloader.close())\n \n-    def pause(self):\n-        \"\"\"Pause the execution engine\"\"\"\n+    def pause(self) -> None:\n         self.paused = True\n \n-    def unpause(self):\n-        \"\"\"Resume the execution engine\"\"\"\n+    def unpause(self) -> None:\n         self.paused = False\n \n-    def _next_request(self, spider):\n-        slot = self.slot\n-        if not slot:\n-            return\n+    def _next_request(self, spider: Spider) -> None:\n+        if self.slot is None:\n+            return None\n \n         if self.paused:\n-            return\n+            return None\n \n-        while not self._needs_backout(spider):\n-            if not self._next_request_from_scheduler(spider):\n-                break\n+        while not self._needs_backout(spider) and self._next_request_from_scheduler(spider) is not None:\n+            pass\n \n-        if slot.start_requests and not self._needs_backout(spider):\n+        if self.slot.start_requests is not None and not self._needs_backout(spider):\n             try:\n-                request = next(slot.start_requests)\n+                request = next(self.slot.start_requests)\n             except StopIteration:\n-                slot.start_requests = None\n+                self.slot.start_requests = None\n             except Exception:\n-                slot.start_requests = None\n-                logger.error('Error while obtaining start requests',\n-                             exc_info=True, extra={'spider': spider})\n+                self.slot.start_requests = None\n+                logger.error('Error while obtaining start requests', exc_info=True, extra={'spider': spider})\n             else:\n                 self.crawl(request, spider)\n \n-        if self.spider_is_idle(spider) and slot.close_if_idle:\n+        if self.spider_is_idle(spider) and self.slot.close_if_idle:\n             self._spider_idle(spider)\n \n-    def _needs_backout(self, spider):\n-        slot = self.slot\n+    def _needs_backout(self, spider: Spider) -> bool:\n         return (\n             not self.running\n-            or slot.closing\n+            or self.slot is not None and self.slot.closing",
      "comment": "This gives the impression that `self.slot` may be `None`, which does not seem to be the case, given the implementation of `_next_request` and assuming that is the only caller of `_needs_backout`.\r\n\r\nWould an `assert` before the return be enough for mypy?\r\n\r\nSame applies to `_next_request_from_scheduler` below.",
      "comment_id": 609755076,
      "user": "Gallaecio",
      "created_at": "2021-04-08T14:21:35Z",
      "url": "https://github.com/scrapy/scrapy/pull/5090#discussion_r609755076"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 5090,
      "file_path": "scrapy/core/engine.py",
      "line": 193,
      "side": "RIGHT",
      "diff_hunk": "@@ -102,188 +109,175 @@ def close(self):\n             # Will also close downloader\n             return self._close_all_spiders()\n         else:\n-            return defer.succeed(self.downloader.close())\n+            return defer_succeed(self.downloader.close())\n \n-    def pause(self):\n-        \"\"\"Pause the execution engine\"\"\"\n+    def pause(self) -> None:\n         self.paused = True\n \n-    def unpause(self):\n-        \"\"\"Resume the execution engine\"\"\"\n+    def unpause(self) -> None:\n         self.paused = False\n \n-    def _next_request(self, spider):\n-        slot = self.slot\n-        if not slot:\n-            return\n+    def _next_request(self, spider: Spider) -> None:\n+        if self.slot is None:\n+            return None\n \n         if self.paused:\n-            return\n+            return None\n \n-        while not self._needs_backout(spider):\n-            if not self._next_request_from_scheduler(spider):\n-                break\n+        while not self._needs_backout(spider) and self._next_request_from_scheduler(spider) is not None:\n+            pass\n \n-        if slot.start_requests and not self._needs_backout(spider):\n+        if self.slot.start_requests is not None and not self._needs_backout(spider):\n             try:\n-                request = next(slot.start_requests)\n+                request = next(self.slot.start_requests)\n             except StopIteration:\n-                slot.start_requests = None\n+                self.slot.start_requests = None\n             except Exception:\n-                slot.start_requests = None\n-                logger.error('Error while obtaining start requests',\n-                             exc_info=True, extra={'spider': spider})\n+                self.slot.start_requests = None\n+                logger.error('Error while obtaining start requests', exc_info=True, extra={'spider': spider})\n             else:\n                 self.crawl(request, spider)\n \n-        if self.spider_is_idle(spider) and slot.close_if_idle:\n+        if self.spider_is_idle(spider) and self.slot.close_if_idle:\n             self._spider_idle(spider)\n \n-    def _needs_backout(self, spider):\n-        slot = self.slot\n+    def _needs_backout(self, spider: Spider) -> bool:\n         return (\n             not self.running\n-            or slot.closing\n+            or self.slot is not None and self.slot.closing\n             or self.downloader.needs_backout()\n             or self.scraper.slot.needs_backout()\n         )\n \n-    def _next_request_from_scheduler(self, spider):\n-        slot = self.slot\n-        request = slot.scheduler.next_request()\n-        if not request:\n-            return\n+    def _next_request_from_scheduler(self, spider: Spider) -> Optional[Deferred]:\n+        if self.slot is None:\n+            return None\n+        request = self.slot.scheduler.next_request()\n+        if request is None:\n+            return None\n         d = self._download(request, spider)\n         d.addBoth(self._handle_downloader_output, request, spider)\n         d.addErrback(lambda f: logger.info('Error while handling downloader output',\n                                            exc_info=failure_to_exc_info(f),\n                                            extra={'spider': spider}))\n-        d.addBoth(lambda _: slot.remove_request(request))\n+        d.addBoth(lambda _: self.slot.remove_request(request))\n         d.addErrback(lambda f: logger.info('Error while removing request from slot',\n                                            exc_info=failure_to_exc_info(f),\n                                            extra={'spider': spider}))\n-        d.addBoth(lambda _: slot.nextcall.schedule())\n+        d.addBoth(lambda _: self.slot.nextcall.schedule())\n         d.addErrback(lambda f: logger.info('Error while scheduling new request',\n                                            exc_info=failure_to_exc_info(f),\n                                            extra={'spider': spider}))\n         return d\n \n-    def _handle_downloader_output(self, response, request, spider):\n-        if not isinstance(response, (Request, Response, Failure)):\n-            raise TypeError(\n-                \"Incorrect type: expected Request, Response or Failure, got \"\n-                f\"{type(response)}: {response!r}\"\n-            )\n+    def _handle_downloader_output(\n+        self, result: Union[Request, Response, Failure], request: Request, spider: Spider\n+    ) -> Optional[Deferred]:\n+        if not isinstance(result, (Request, Response, Failure)):\n+            raise TypeError(f\"Incorrect type: expected Request, Response or Failure, got {type(result)}: {result!r}\")\n         # downloader middleware can return requests (for example, redirects)\n-        if isinstance(response, Request):\n-            self.crawl(response, spider)\n-            return\n-        # response is a Response or Failure\n-        d = self.scraper.enqueue_scrape(response, request, spider)\n+        if isinstance(result, Request):\n+            self.crawl(result, spider)\n+            return None\n+        d = self.scraper.enqueue_scrape(result, request, spider)\n         d.addErrback(lambda f: logger.error('Error while enqueuing downloader output',\n                                             exc_info=failure_to_exc_info(f),\n                                             extra={'spider': spider}))\n         return d\n \n-    def spider_is_idle(self, spider):\n+    def spider_is_idle(self, spider: Spider) -> bool:\n         if not self.scraper.slot.is_idle():\n-            # scraper is not idle\n             return False\n-\n-        if self.downloader.active:\n-            # downloader has pending requests\n+        if self.downloader.active:  # downloader has pending requests\n             return False\n-\n-        if self.slot.start_requests is not None:\n-            # not all start requests are handled\n-            return False\n-\n-        if self.slot.scheduler.has_pending_requests():\n-            # scheduler has pending requests\n-            return False\n-\n+        if self.slot is not None:",
      "comment": "I think it makes sense to check here, given `spider_is_idle` is a public method. But since all current code expects it not to be `None`, I wonder if we should instead raise an exception, e.g. a `RuntimeError` complaining about `spider_is_idle` being called before `open_spider`.\r\n\r\nSame for `crawl` and `schedule` below.",
      "comment_id": 609761116,
      "user": "Gallaecio",
      "created_at": "2021-04-08T14:27:14Z",
      "url": "https://github.com/scrapy/scrapy/pull/5090#discussion_r609761116"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 5090,
      "file_path": "scrapy/core/engine.py",
      "line": 273,
      "side": "RIGHT",
      "diff_hunk": "@@ -102,188 +109,175 @@ def close(self):\n             # Will also close downloader\n             return self._close_all_spiders()\n         else:\n-            return defer.succeed(self.downloader.close())\n+            return defer_succeed(self.downloader.close())\n \n-    def pause(self):\n-        \"\"\"Pause the execution engine\"\"\"\n+    def pause(self) -> None:\n         self.paused = True\n \n-    def unpause(self):\n-        \"\"\"Resume the execution engine\"\"\"\n+    def unpause(self) -> None:\n         self.paused = False\n \n-    def _next_request(self, spider):\n-        slot = self.slot\n-        if not slot:\n-            return\n+    def _next_request(self, spider: Spider) -> None:\n+        if self.slot is None:\n+            return None\n \n         if self.paused:\n-            return\n+            return None\n \n-        while not self._needs_backout(spider):\n-            if not self._next_request_from_scheduler(spider):\n-                break\n+        while not self._needs_backout(spider) and self._next_request_from_scheduler(spider) is not None:\n+            pass\n \n-        if slot.start_requests and not self._needs_backout(spider):\n+        if self.slot.start_requests is not None and not self._needs_backout(spider):\n             try:\n-                request = next(slot.start_requests)\n+                request = next(self.slot.start_requests)\n             except StopIteration:\n-                slot.start_requests = None\n+                self.slot.start_requests = None\n             except Exception:\n-                slot.start_requests = None\n-                logger.error('Error while obtaining start requests',\n-                             exc_info=True, extra={'spider': spider})\n+                self.slot.start_requests = None\n+                logger.error('Error while obtaining start requests', exc_info=True, extra={'spider': spider})\n             else:\n                 self.crawl(request, spider)\n \n-        if self.spider_is_idle(spider) and slot.close_if_idle:\n+        if self.spider_is_idle(spider) and self.slot.close_if_idle:\n             self._spider_idle(spider)\n \n-    def _needs_backout(self, spider):\n-        slot = self.slot\n+    def _needs_backout(self, spider: Spider) -> bool:\n         return (\n             not self.running\n-            or slot.closing\n+            or self.slot is not None and self.slot.closing\n             or self.downloader.needs_backout()\n             or self.scraper.slot.needs_backout()\n         )\n \n-    def _next_request_from_scheduler(self, spider):\n-        slot = self.slot\n-        request = slot.scheduler.next_request()\n-        if not request:\n-            return\n+    def _next_request_from_scheduler(self, spider: Spider) -> Optional[Deferred]:\n+        if self.slot is None:\n+            return None\n+        request = self.slot.scheduler.next_request()\n+        if request is None:\n+            return None\n         d = self._download(request, spider)\n         d.addBoth(self._handle_downloader_output, request, spider)\n         d.addErrback(lambda f: logger.info('Error while handling downloader output',\n                                            exc_info=failure_to_exc_info(f),\n                                            extra={'spider': spider}))\n-        d.addBoth(lambda _: slot.remove_request(request))\n+        d.addBoth(lambda _: self.slot.remove_request(request))\n         d.addErrback(lambda f: logger.info('Error while removing request from slot',\n                                            exc_info=failure_to_exc_info(f),\n                                            extra={'spider': spider}))\n-        d.addBoth(lambda _: slot.nextcall.schedule())\n+        d.addBoth(lambda _: self.slot.nextcall.schedule())\n         d.addErrback(lambda f: logger.info('Error while scheduling new request',\n                                            exc_info=failure_to_exc_info(f),\n                                            extra={'spider': spider}))\n         return d\n \n-    def _handle_downloader_output(self, response, request, spider):\n-        if not isinstance(response, (Request, Response, Failure)):\n-            raise TypeError(\n-                \"Incorrect type: expected Request, Response or Failure, got \"\n-                f\"{type(response)}: {response!r}\"\n-            )\n+    def _handle_downloader_output(\n+        self, result: Union[Request, Response, Failure], request: Request, spider: Spider\n+    ) -> Optional[Deferred]:\n+        if not isinstance(result, (Request, Response, Failure)):\n+            raise TypeError(f\"Incorrect type: expected Request, Response or Failure, got {type(result)}: {result!r}\")\n         # downloader middleware can return requests (for example, redirects)\n-        if isinstance(response, Request):\n-            self.crawl(response, spider)\n-            return\n-        # response is a Response or Failure\n-        d = self.scraper.enqueue_scrape(response, request, spider)\n+        if isinstance(result, Request):\n+            self.crawl(result, spider)\n+            return None\n+        d = self.scraper.enqueue_scrape(result, request, spider)\n         d.addErrback(lambda f: logger.error('Error while enqueuing downloader output',\n                                             exc_info=failure_to_exc_info(f),\n                                             extra={'spider': spider}))\n         return d\n \n-    def spider_is_idle(self, spider):\n+    def spider_is_idle(self, spider: Spider) -> bool:\n         if not self.scraper.slot.is_idle():\n-            # scraper is not idle\n             return False\n-\n-        if self.downloader.active:\n-            # downloader has pending requests\n+        if self.downloader.active:  # downloader has pending requests\n             return False\n-\n-        if self.slot.start_requests is not None:\n-            # not all start requests are handled\n-            return False\n-\n-        if self.slot.scheduler.has_pending_requests():\n-            # scheduler has pending requests\n-            return False\n-\n+        if self.slot is not None:\n+            if self.slot.start_requests is not None:  # not all start requests are handled\n+                return False\n+            if self.slot.scheduler.has_pending_requests():\n+                return False\n         return True\n \n     @property\n-    def open_spiders(self):\n+    def open_spiders(self) -> list:\n         return [self.spider] if self.spider else []\n \n-    def has_capacity(self):\n+    def has_capacity(self) -> bool:\n         \"\"\"Does the engine have capacity to handle more spiders\"\"\"\n         return not bool(self.slot)\n \n-    def crawl(self, request, spider):\n+    def crawl(self, request: Request, spider: Spider) -> None:\n         if spider not in self.open_spiders:\n             raise RuntimeError(f\"Spider {spider.name!r} not opened when crawling: {request}\")\n         self.schedule(request, spider)\n-        self.slot.nextcall.schedule()\n+        if self.slot is not None:\n+            self.slot.nextcall.schedule()\n \n-    def schedule(self, request, spider):\n+    def schedule(self, request: Request, spider: Spider) -> None:\n         self.signals.send_catch_log(signals.request_scheduled, request=request, spider=spider)\n-        if not self.slot.scheduler.enqueue_request(request):\n+        if self.slot is not None and not self.slot.scheduler.enqueue_request(request):\n             self.signals.send_catch_log(signals.request_dropped, request=request, spider=spider)\n \n-    def download(self, request, spider):\n+    def download(self, request: Request, spider: Spider) -> Deferred:\n         d = self._download(request, spider)\n         d.addBoth(self._downloaded, self.slot, request, spider)\n         return d\n \n-    def _downloaded(self, response, slot, request, spider):\n+    def _downloaded(\n+        self, result: Union[Response, Request], slot: Slot, request: Request, spider: Spider\n+    ) -> Union[Deferred, Response]:\n         slot.remove_request(request)\n-        return self.download(response, spider) if isinstance(response, Request) else response\n+        return self.download(result, spider) if isinstance(result, Request) else result\n \n-    def _download(self, request, spider):\n-        slot = self.slot\n-        slot.add_request(request)\n+    def _download(self, request: Request, spider: Spider) -> Deferred:\n+        assert self.slot is not None  # typing\n \n-        def _on_success(response):\n-            if not isinstance(response, (Response, Request)):\n-                raise TypeError(\n-                    \"Incorrect type: expected Response or Request, got \"\n-                    f\"{type(response)}: {response!r}\"\n-                )\n-            if isinstance(response, Response):\n-                if response.request is None:\n-                    response.request = request\n-                logkws = self.logformatter.crawled(response.request, response, spider)\n+        self.slot.add_request(request)\n+\n+        def _on_success(result: Union[Response, Request]) -> Union[Response, Request]:\n+            if not isinstance(result, (Response, Request)):\n+                raise TypeError(f\"Incorrect type: expected Response or Request, got {type(result)}: {result!r}\")\n+            if isinstance(result, Response):\n+                if result.request is None:\n+                    result.request = request\n+                logkws = self.logformatter.crawled(result.request, result, spider)\n                 if logkws is not None:\n                     logger.log(*logformatter_adapter(logkws), extra={'spider': spider})\n                 self.signals.send_catch_log(\n                     signal=signals.response_received,\n-                    response=response,\n-                    request=response.request,\n+                    response=result,\n+                    request=result.request,\n                     spider=spider,\n                 )\n-            return response\n+            return result\n \n         def _on_complete(_):\n-            slot.nextcall.schedule()\n+            self.slot.nextcall.schedule()\n             return _\n \n         dwld = self.downloader.fetch(request, spider)\n         dwld.addCallbacks(_on_success)\n         dwld.addBoth(_on_complete)\n         return dwld\n \n-    @defer.inlineCallbacks\n-    def open_spider(self, spider, start_requests=(), close_if_idle=True):\n+    @inlineCallbacks\n+    def open_spider(self, spider: Spider, start_requests: Iterable = (), close_if_idle: bool = True):\n         if not self.has_capacity():\n             raise RuntimeError(f\"No free spider slot when opening {spider.name!r}\")\n         logger.info(\"Spider opened\", extra={'spider': spider})\n         nextcall = CallLaterOnce(self._next_request, spider)\n-        scheduler = self.scheduler_cls.from_crawler(self.crawler)\n+        scheduler = create_instance(self.scheduler_cls, settings=None, crawler=self.crawler)\n         start_requests = yield self.scraper.spidermw.process_start_requests(start_requests, spider)\n-        slot = Slot(start_requests, close_if_idle, nextcall, scheduler)\n-        self.slot = slot\n+        self.slot = Slot(start_requests, close_if_idle, nextcall, scheduler)\n         self.spider = spider\n-        yield scheduler.open(spider)\n+        if hasattr(scheduler, \"open\"):\n+            yield scheduler.open(spider)",
      "comment": "I assume this and `hasattr(self.slot.scheduler, \"close\")` in line 317 below are not changes about typing, but about making those methods optional. +1.\r\n\r\nI would say we need to remember to cover that in the documentation, but this pull request is a fork of a pull request to document the scheduler, so :shrug: .",
      "comment_id": 609768146,
      "user": "Gallaecio",
      "created_at": "2021-04-08T14:33:45Z",
      "url": "https://github.com/scrapy/scrapy/pull/5090#discussion_r609768146"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 5090,
      "file_path": "scrapy/core/engine.py",
      "line": 273,
      "side": "RIGHT",
      "diff_hunk": "@@ -102,188 +109,175 @@ def close(self):\n             # Will also close downloader\n             return self._close_all_spiders()\n         else:\n-            return defer.succeed(self.downloader.close())\n+            return defer_succeed(self.downloader.close())\n \n-    def pause(self):\n-        \"\"\"Pause the execution engine\"\"\"\n+    def pause(self) -> None:\n         self.paused = True\n \n-    def unpause(self):\n-        \"\"\"Resume the execution engine\"\"\"\n+    def unpause(self) -> None:\n         self.paused = False\n \n-    def _next_request(self, spider):\n-        slot = self.slot\n-        if not slot:\n-            return\n+    def _next_request(self, spider: Spider) -> None:\n+        if self.slot is None:\n+            return None\n \n         if self.paused:\n-            return\n+            return None\n \n-        while not self._needs_backout(spider):\n-            if not self._next_request_from_scheduler(spider):\n-                break\n+        while not self._needs_backout(spider) and self._next_request_from_scheduler(spider) is not None:\n+            pass\n \n-        if slot.start_requests and not self._needs_backout(spider):\n+        if self.slot.start_requests is not None and not self._needs_backout(spider):\n             try:\n-                request = next(slot.start_requests)\n+                request = next(self.slot.start_requests)\n             except StopIteration:\n-                slot.start_requests = None\n+                self.slot.start_requests = None\n             except Exception:\n-                slot.start_requests = None\n-                logger.error('Error while obtaining start requests',\n-                             exc_info=True, extra={'spider': spider})\n+                self.slot.start_requests = None\n+                logger.error('Error while obtaining start requests', exc_info=True, extra={'spider': spider})\n             else:\n                 self.crawl(request, spider)\n \n-        if self.spider_is_idle(spider) and slot.close_if_idle:\n+        if self.spider_is_idle(spider) and self.slot.close_if_idle:\n             self._spider_idle(spider)\n \n-    def _needs_backout(self, spider):\n-        slot = self.slot\n+    def _needs_backout(self, spider: Spider) -> bool:\n         return (\n             not self.running\n-            or slot.closing\n+            or self.slot is not None and self.slot.closing\n             or self.downloader.needs_backout()\n             or self.scraper.slot.needs_backout()\n         )\n \n-    def _next_request_from_scheduler(self, spider):\n-        slot = self.slot\n-        request = slot.scheduler.next_request()\n-        if not request:\n-            return\n+    def _next_request_from_scheduler(self, spider: Spider) -> Optional[Deferred]:\n+        if self.slot is None:\n+            return None\n+        request = self.slot.scheduler.next_request()\n+        if request is None:\n+            return None\n         d = self._download(request, spider)\n         d.addBoth(self._handle_downloader_output, request, spider)\n         d.addErrback(lambda f: logger.info('Error while handling downloader output',\n                                            exc_info=failure_to_exc_info(f),\n                                            extra={'spider': spider}))\n-        d.addBoth(lambda _: slot.remove_request(request))\n+        d.addBoth(lambda _: self.slot.remove_request(request))\n         d.addErrback(lambda f: logger.info('Error while removing request from slot',\n                                            exc_info=failure_to_exc_info(f),\n                                            extra={'spider': spider}))\n-        d.addBoth(lambda _: slot.nextcall.schedule())\n+        d.addBoth(lambda _: self.slot.nextcall.schedule())\n         d.addErrback(lambda f: logger.info('Error while scheduling new request',\n                                            exc_info=failure_to_exc_info(f),\n                                            extra={'spider': spider}))\n         return d\n \n-    def _handle_downloader_output(self, response, request, spider):\n-        if not isinstance(response, (Request, Response, Failure)):\n-            raise TypeError(\n-                \"Incorrect type: expected Request, Response or Failure, got \"\n-                f\"{type(response)}: {response!r}\"\n-            )\n+    def _handle_downloader_output(\n+        self, result: Union[Request, Response, Failure], request: Request, spider: Spider\n+    ) -> Optional[Deferred]:\n+        if not isinstance(result, (Request, Response, Failure)):\n+            raise TypeError(f\"Incorrect type: expected Request, Response or Failure, got {type(result)}: {result!r}\")\n         # downloader middleware can return requests (for example, redirects)\n-        if isinstance(response, Request):\n-            self.crawl(response, spider)\n-            return\n-        # response is a Response or Failure\n-        d = self.scraper.enqueue_scrape(response, request, spider)\n+        if isinstance(result, Request):\n+            self.crawl(result, spider)\n+            return None\n+        d = self.scraper.enqueue_scrape(result, request, spider)\n         d.addErrback(lambda f: logger.error('Error while enqueuing downloader output',\n                                             exc_info=failure_to_exc_info(f),\n                                             extra={'spider': spider}))\n         return d\n \n-    def spider_is_idle(self, spider):\n+    def spider_is_idle(self, spider: Spider) -> bool:\n         if not self.scraper.slot.is_idle():\n-            # scraper is not idle\n             return False\n-\n-        if self.downloader.active:\n-            # downloader has pending requests\n+        if self.downloader.active:  # downloader has pending requests\n             return False\n-\n-        if self.slot.start_requests is not None:\n-            # not all start requests are handled\n-            return False\n-\n-        if self.slot.scheduler.has_pending_requests():\n-            # scheduler has pending requests\n-            return False\n-\n+        if self.slot is not None:\n+            if self.slot.start_requests is not None:  # not all start requests are handled\n+                return False\n+            if self.slot.scheduler.has_pending_requests():\n+                return False\n         return True\n \n     @property\n-    def open_spiders(self):\n+    def open_spiders(self) -> list:\n         return [self.spider] if self.spider else []\n \n-    def has_capacity(self):\n+    def has_capacity(self) -> bool:\n         \"\"\"Does the engine have capacity to handle more spiders\"\"\"\n         return not bool(self.slot)\n \n-    def crawl(self, request, spider):\n+    def crawl(self, request: Request, spider: Spider) -> None:\n         if spider not in self.open_spiders:\n             raise RuntimeError(f\"Spider {spider.name!r} not opened when crawling: {request}\")\n         self.schedule(request, spider)\n-        self.slot.nextcall.schedule()\n+        if self.slot is not None:\n+            self.slot.nextcall.schedule()\n \n-    def schedule(self, request, spider):\n+    def schedule(self, request: Request, spider: Spider) -> None:\n         self.signals.send_catch_log(signals.request_scheduled, request=request, spider=spider)\n-        if not self.slot.scheduler.enqueue_request(request):\n+        if self.slot is not None and not self.slot.scheduler.enqueue_request(request):\n             self.signals.send_catch_log(signals.request_dropped, request=request, spider=spider)\n \n-    def download(self, request, spider):\n+    def download(self, request: Request, spider: Spider) -> Deferred:\n         d = self._download(request, spider)\n         d.addBoth(self._downloaded, self.slot, request, spider)\n         return d\n \n-    def _downloaded(self, response, slot, request, spider):\n+    def _downloaded(\n+        self, result: Union[Response, Request], slot: Slot, request: Request, spider: Spider\n+    ) -> Union[Deferred, Response]:\n         slot.remove_request(request)\n-        return self.download(response, spider) if isinstance(response, Request) else response\n+        return self.download(result, spider) if isinstance(result, Request) else result\n \n-    def _download(self, request, spider):\n-        slot = self.slot\n-        slot.add_request(request)\n+    def _download(self, request: Request, spider: Spider) -> Deferred:\n+        assert self.slot is not None  # typing\n \n-        def _on_success(response):\n-            if not isinstance(response, (Response, Request)):\n-                raise TypeError(\n-                    \"Incorrect type: expected Response or Request, got \"\n-                    f\"{type(response)}: {response!r}\"\n-                )\n-            if isinstance(response, Response):\n-                if response.request is None:\n-                    response.request = request\n-                logkws = self.logformatter.crawled(response.request, response, spider)\n+        self.slot.add_request(request)\n+\n+        def _on_success(result: Union[Response, Request]) -> Union[Response, Request]:\n+            if not isinstance(result, (Response, Request)):\n+                raise TypeError(f\"Incorrect type: expected Response or Request, got {type(result)}: {result!r}\")\n+            if isinstance(result, Response):\n+                if result.request is None:\n+                    result.request = request\n+                logkws = self.logformatter.crawled(result.request, result, spider)\n                 if logkws is not None:\n                     logger.log(*logformatter_adapter(logkws), extra={'spider': spider})\n                 self.signals.send_catch_log(\n                     signal=signals.response_received,\n-                    response=response,\n-                    request=response.request,\n+                    response=result,\n+                    request=result.request,\n                     spider=spider,\n                 )\n-            return response\n+            return result\n \n         def _on_complete(_):\n-            slot.nextcall.schedule()\n+            self.slot.nextcall.schedule()\n             return _\n \n         dwld = self.downloader.fetch(request, spider)\n         dwld.addCallbacks(_on_success)\n         dwld.addBoth(_on_complete)\n         return dwld\n \n-    @defer.inlineCallbacks\n-    def open_spider(self, spider, start_requests=(), close_if_idle=True):\n+    @inlineCallbacks\n+    def open_spider(self, spider: Spider, start_requests: Iterable = (), close_if_idle: bool = True):\n         if not self.has_capacity():\n             raise RuntimeError(f\"No free spider slot when opening {spider.name!r}\")\n         logger.info(\"Spider opened\", extra={'spider': spider})\n         nextcall = CallLaterOnce(self._next_request, spider)\n-        scheduler = self.scheduler_cls.from_crawler(self.crawler)\n+        scheduler = create_instance(self.scheduler_cls, settings=None, crawler=self.crawler)\n         start_requests = yield self.scraper.spidermw.process_start_requests(start_requests, spider)\n-        slot = Slot(start_requests, close_if_idle, nextcall, scheduler)\n-        self.slot = slot\n+        self.slot = Slot(start_requests, close_if_idle, nextcall, scheduler)\n         self.spider = spider\n-        yield scheduler.open(spider)\n+        if hasattr(scheduler, \"open\"):\n+            yield scheduler.open(spider)",
      "comment": "Oh right, I didn't mean to include this change in this particular PR, I trimmed some changes from the initial PR but forgot about this one.",
      "comment_id": 609788595,
      "user": "elacuesta",
      "created_at": "2021-04-08T14:53:36Z",
      "url": "https://github.com/scrapy/scrapy/pull/5090#discussion_r609788595"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 5090,
      "file_path": "scrapy/core/engine.py",
      "line": 95,
      "side": "RIGHT",
      "diff_hunk": "@@ -90,56 +90,63 @@ def start(self) -> Deferred:\n         yield self._closewait\n \n     def stop(self) -> Deferred:\n-        \"\"\"Stop the execution engine gracefully\"\"\"\n+        \"\"\"\n+        Gracefully stop the execution engine\n+        \"\"\"",
      "comment": "Your docstring style changes seem to go against https://www.python.org/dev/peps/pep-0257/",
      "comment_id": 610378218,
      "user": "Gallaecio",
      "created_at": "2021-04-09T06:31:03Z",
      "url": "https://github.com/scrapy/scrapy/pull/5090#discussion_r610378218"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 5090,
      "file_path": "scrapy/core/engine.py",
      "line": 116,
      "side": "RIGHT",
      "diff_hunk": "@@ -90,56 +90,63 @@ def start(self) -> Deferred:\n         yield self._closewait\n \n     def stop(self) -> Deferred:\n-        \"\"\"Stop the execution engine gracefully\"\"\"\n+        \"\"\"\n+        Gracefully stop the execution engine\n+        \"\"\"\n+        @inlineCallbacks\n+        def _finish_stopping_engine(_) -> Deferred:\n+            yield self.signals.send_catch_log_deferred(signal=signals.engine_stopped)\n+            self._closewait.callback(None)\n+\n         if not self.running:\n             raise RuntimeError(\"Engine not running\")\n+\n         self.running = False\n         dfd = self.close_spider(self.spider, reason=\"shutdown\") if self.spider is not None else defer_succeed(None)\n-        return dfd.addBoth(lambda _: self._finish_stopping_engine())\n+        return dfd.addBoth(_finish_stopping_engine)\n \n     def close(self) -> Deferred:\n-        \"\"\"Close the execution engine gracefully.\n-\n+        \"\"\"\n+        Gracefully close the execution engine.\n         If it has already been started, stop it. In all cases, close all spiders and the downloader.\n         \"\"\"\n         if self.running:\n             return self.stop()  # will also close spiders and downloader\n         elif self.spider is not None:\n             return self.close_spider(self.spider, reason=\"shutdown\")  # will also close downloader",
      "comment": ":lipstick: \r\n\r\n```suggestion\r\n        if self.spider is not None:\r\n            return self.close_spider(self.spider, reason=\"shutdown\")  # will also close downloader\r\n```",
      "comment_id": 610378439,
      "user": "Gallaecio",
      "created_at": "2021-04-09T06:31:31Z",
      "url": "https://github.com/scrapy/scrapy/pull/5090#discussion_r610378439"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 5090,
      "file_path": "scrapy/core/engine.py",
      "line": 204,
      "side": "RIGHT",
      "diff_hunk": "@@ -148,92 +155,88 @@ def _needs_backout(self, spider: Spider) -> bool:\n             or self.scraper.slot.needs_backout()\n         )\n \n-    def _next_request_from_scheduler(self, spider: Spider) -> Optional[Deferred]:\n+    def _next_request_from_scheduler(self) -> Optional[Deferred]:\n         assert self.slot is not None  # typing\n \n         request = self.slot.scheduler.next_request()\n         if request is None:\n             return None\n \n-        d = self._download(request, spider)\n-        d.addBoth(self._handle_downloader_output, request, spider)\n+        d = self._download(request)\n+        d.addBoth(self._handle_downloader_output, request)\n         d.addErrback(lambda f: logger.info('Error while handling downloader output',\n                                            exc_info=failure_to_exc_info(f),\n-                                           extra={'spider': spider}))\n+                                           extra={'spider': self.spider}))\n         d.addBoth(lambda _: self.slot.remove_request(request))\n         d.addErrback(lambda f: logger.info('Error while removing request from slot',\n                                            exc_info=failure_to_exc_info(f),\n-                                           extra={'spider': spider}))\n+                                           extra={'spider': self.spider}))\n         d.addBoth(lambda _: self.slot.nextcall.schedule())\n         d.addErrback(lambda f: logger.info('Error while scheduling new request',\n                                            exc_info=failure_to_exc_info(f),\n-                                           extra={'spider': spider}))\n+                                           extra={'spider': self.spider}))\n         return d\n \n     def _handle_downloader_output(\n-        self, result: Union[Request, Response, Failure], request: Request, spider: Spider\n+        self, result: Union[Request, Response, Failure], request: Request\n     ) -> Optional[Deferred]:\n+        assert self.spider is not None  # typing\n+\n         if not isinstance(result, (Request, Response, Failure)):\n             raise TypeError(f\"Incorrect type: expected Request, Response or Failure, got {type(result)}: {result!r}\")\n+\n         # downloader middleware can return requests (for example, redirects)\n         if isinstance(result, Request):\n-            self.crawl(result, spider)\n+            self.crawl(result, self.spider)\n             return None\n-        d = self.scraper.enqueue_scrape(result, request, spider)\n-        d.addErrback(lambda f: logger.error('Error while enqueuing downloader output',\n-                                            exc_info=failure_to_exc_info(f),\n-                                            extra={'spider': spider}))\n+\n+        d = self.scraper.enqueue_scrape(result, request, self.spider)\n+        d.addErrback(\n+            lambda f: logger.error(\n+                'Error while enqueuing downloader output',\n+                exc_info=failure_to_exc_info(f),\n+                extra={'spider': self.spider},\n+            )\n+        )\n         return d\n \n     def spider_is_idle(self, spider: Spider) -> bool:\n+        assert self.slot is not None  # typing",
      "comment": "Since this is a public method, we cannot control whether or not `self.slot` is or not `None` by the time this method is called, so I don\u2019t think `assert` is the way here, since we should only use asserts if the code would work the same after removing them. I would raise an exception instead.\r\n\r\nSame for `crawl` and `schedule` below.",
      "comment_id": 610379960,
      "user": "Gallaecio",
      "created_at": "2021-04-09T06:35:05Z",
      "url": "https://github.com/scrapy/scrapy/pull/5090#discussion_r610379960"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 5090,
      "file_path": "scrapy/core/engine.py",
      "line": 95,
      "side": "RIGHT",
      "diff_hunk": "@@ -90,56 +90,63 @@ def start(self) -> Deferred:\n         yield self._closewait\n \n     def stop(self) -> Deferred:\n-        \"\"\"Stop the execution engine gracefully\"\"\"\n+        \"\"\"\n+        Gracefully stop the execution engine\n+        \"\"\"",
      "comment": "Interesting, I wasn't aware of that particular point. I don't really like it, but I won't go stubborn on this. Thanks!",
      "comment_id": 610573424,
      "user": "elacuesta",
      "created_at": "2021-04-09T12:06:21Z",
      "url": "https://github.com/scrapy/scrapy/pull/5090#discussion_r610573424"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 5090,
      "file_path": "scrapy/core/engine.py",
      "line": 12,
      "side": "RIGHT",
      "diff_hunk": "@@ -5,47 +5,57 @@\n \n \"\"\"\n import logging\n+import warnings\n from time import time\n+from typing import Callable, Iterable, Iterator, Optional, Set, Union\n \n-from twisted.internet import defer, task\n+from twisted.internet.defer import Deferred, inlineCallbacks, succeed as defer_succeed",
      "comment": "`utils.defer.defer_succeed` introduces a bit of delay, this renaming is because the previous usage was `defer.succed`, and I thought just `succeed` might not be as intuitive. I'll switch back to `succeed` to avoid confusion, thanks.",
      "comment_id": 610803606,
      "user": "elacuesta",
      "created_at": "2021-04-09T17:42:40Z",
      "url": "https://github.com/scrapy/scrapy/pull/5090#discussion_r610803606"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 5090,
      "file_path": "scrapy/core/engine.py",
      "line": 12,
      "side": "RIGHT",
      "diff_hunk": "@@ -5,47 +5,57 @@\n \n \"\"\"\n import logging\n+import warnings\n from time import time\n+from typing import Callable, Iterable, Iterator, Optional, Set, Union\n \n-from twisted.internet import defer, task\n+from twisted.internet.defer import Deferred, inlineCallbacks, succeed as defer_succeed",
      "comment": "Sure, I just meant that there can be confusion and also a theoretical naming clash in the future.",
      "comment_id": 610805797,
      "user": "wRAR",
      "created_at": "2021-04-09T17:46:23Z",
      "url": "https://github.com/scrapy/scrapy/pull/5090#discussion_r610805797"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 5090,
      "file_path": "scrapy/core/engine.py",
      "line": 217,
      "side": "LEFT",
      "diff_hunk": "@@ -54,269 +64,277 @@ def _maybe_fire_closing(self):\n \n \n class ExecutionEngine:\n-\n-    def __init__(self, crawler, spider_closed_callback):\n+    def __init__(self, crawler, spider_closed_callback: Callable) -> None:\n         self.crawler = crawler\n         self.settings = crawler.settings\n         self.signals = crawler.signals\n         self.logformatter = crawler.logformatter\n-        self.slot = None\n-        self.spider = None\n+        self.slot: Optional[Slot] = None\n+        self.spider: Optional[Spider] = None\n         self.running = False\n         self.paused = False\n-        self.scheduler_cls = load_object(self.settings['SCHEDULER'])\n+        self.scheduler_cls = load_object(crawler.settings[\"SCHEDULER\"])\n         downloader_cls = load_object(self.settings['DOWNLOADER'])\n         self.downloader = downloader_cls(crawler)\n         self.scraper = Scraper(crawler)\n         self._spider_closed_callback = spider_closed_callback\n \n-    @defer.inlineCallbacks\n-    def start(self):\n-        \"\"\"Start the execution engine\"\"\"\n+    @inlineCallbacks\n+    def start(self) -> Deferred:\n         if self.running:\n             raise RuntimeError(\"Engine already running\")\n         self.start_time = time()\n         yield self.signals.send_catch_log_deferred(signal=signals.engine_started)\n         self.running = True\n-        self._closewait = defer.Deferred()\n+        self._closewait = Deferred()\n         yield self._closewait\n \n-    def stop(self):\n-        \"\"\"Stop the execution engine gracefully\"\"\"\n+    def stop(self) -> Deferred:\n+        \"\"\"Gracefully stop the execution engine\"\"\"\n+        @inlineCallbacks\n+        def _finish_stopping_engine(_) -> Deferred:\n+            yield self.signals.send_catch_log_deferred(signal=signals.engine_stopped)\n+            self._closewait.callback(None)\n+\n         if not self.running:\n             raise RuntimeError(\"Engine not running\")\n-        self.running = False\n-        dfd = self._close_all_spiders()\n-        return dfd.addBoth(lambda _: self._finish_stopping_engine())\n \n-    def close(self):\n-        \"\"\"Close the execution engine gracefully.\n+        self.running = False\n+        dfd = self.close_spider(self.spider, reason=\"shutdown\") if self.spider is not None else succeed(None)\n+        return dfd.addBoth(_finish_stopping_engine)\n \n-        If it has already been started, stop it. In all cases, close all spiders\n-        and the downloader.\n+    def close(self) -> Deferred:\n+        \"\"\"\n+        Gracefully close the execution engine.\n+        If it has already been started, stop it. In all cases, close the spider and the downloader.\n         \"\"\"\n         if self.running:\n-            # Will also close spiders and downloader\n-            return self.stop()\n-        elif self.open_spiders:\n-            # Will also close downloader\n-            return self._close_all_spiders()\n-        else:\n-            return defer.succeed(self.downloader.close())\n-\n-    def pause(self):\n-        \"\"\"Pause the execution engine\"\"\"\n+            return self.stop()  # will also close spider and downloader\n+        if self.spider is not None:\n+            return self.close_spider(self.spider, reason=\"shutdown\")  # will also close downloader\n+        return succeed(self.downloader.close())\n+\n+    def pause(self) -> None:\n         self.paused = True\n \n-    def unpause(self):\n-        \"\"\"Resume the execution engine\"\"\"\n+    def unpause(self) -> None:\n         self.paused = False\n \n-    def _next_request(self, spider):\n-        slot = self.slot\n-        if not slot:\n-            return\n+    def _next_request(self) -> None:\n+        assert self.slot is not None  # typing\n+        assert self.spider is not None  # typing\n \n         if self.paused:\n-            return\n+            return None\n \n-        while not self._needs_backout(spider):\n-            if not self._next_request_from_scheduler(spider):\n-                break\n+        while not self._needs_backout() and self._next_request_from_scheduler() is not None:\n+            pass\n \n-        if slot.start_requests and not self._needs_backout(spider):\n+        if self.slot.start_requests is not None and not self._needs_backout():\n             try:\n-                request = next(slot.start_requests)\n+                request = next(self.slot.start_requests)\n             except StopIteration:\n-                slot.start_requests = None\n+                self.slot.start_requests = None\n             except Exception:\n-                slot.start_requests = None\n-                logger.error('Error while obtaining start requests',\n-                             exc_info=True, extra={'spider': spider})\n+                self.slot.start_requests = None\n+                logger.error('Error while obtaining start requests', exc_info=True, extra={'spider': self.spider})\n             else:\n-                self.crawl(request, spider)\n+                self.crawl(request)\n \n-        if self.spider_is_idle(spider) and slot.close_if_idle:\n-            self._spider_idle(spider)\n+        if self.spider_is_idle() and self.slot.close_if_idle:\n+            self._spider_idle()\n \n-    def _needs_backout(self, spider):\n-        slot = self.slot\n+    def _needs_backout(self) -> bool:\n+        assert self.slot is not None  # typing\n         return (\n             not self.running\n-            or slot.closing\n+            or self.slot.closing\n             or self.downloader.needs_backout()\n             or self.scraper.slot.needs_backout()\n         )\n \n-    def _next_request_from_scheduler(self, spider):\n-        slot = self.slot\n-        request = slot.scheduler.next_request()\n-        if not request:\n-            return\n-        d = self._download(request, spider)\n-        d.addBoth(self._handle_downloader_output, request, spider)\n+    def _next_request_from_scheduler(self) -> Optional[Deferred]:\n+        assert self.slot is not None  # typing\n+\n+        request = self.slot.scheduler.next_request()\n+        if request is None:\n+            return None\n+\n+        d = self._download(request)\n+        d.addBoth(self._handle_downloader_output, request)\n         d.addErrback(lambda f: logger.info('Error while handling downloader output',\n                                            exc_info=failure_to_exc_info(f),\n-                                           extra={'spider': spider}))\n-        d.addBoth(lambda _: slot.remove_request(request))\n+                                           extra={'spider': self.spider}))\n+        d.addBoth(lambda _: self.slot.remove_request(request))\n         d.addErrback(lambda f: logger.info('Error while removing request from slot',\n                                            exc_info=failure_to_exc_info(f),\n-                                           extra={'spider': spider}))\n-        d.addBoth(lambda _: slot.nextcall.schedule())\n+                                           extra={'spider': self.spider}))\n+        d.addBoth(lambda _: self.slot.nextcall.schedule())\n         d.addErrback(lambda f: logger.info('Error while scheduling new request',\n                                            exc_info=failure_to_exc_info(f),\n-                                           extra={'spider': spider}))\n+                                           extra={'spider': self.spider}))\n         return d\n \n-    def _handle_downloader_output(self, response, request, spider):\n-        if not isinstance(response, (Request, Response, Failure)):\n-            raise TypeError(\n-                \"Incorrect type: expected Request, Response or Failure, got \"\n-                f\"{type(response)}: {response!r}\"\n-            )\n+    def _handle_downloader_output(\n+        self, result: Union[Request, Response, Failure], request: Request\n+    ) -> Optional[Deferred]:\n+        assert self.spider is not None  # typing\n+\n+        if not isinstance(result, (Request, Response, Failure)):\n+            raise TypeError(f\"Incorrect type: expected Request, Response or Failure, got {type(result)}: {result!r}\")\n+\n         # downloader middleware can return requests (for example, redirects)\n-        if isinstance(response, Request):\n-            self.crawl(response, spider)\n-            return\n-        # response is a Response or Failure\n-        d = self.scraper.enqueue_scrape(response, request, spider)\n-        d.addErrback(lambda f: logger.error('Error while enqueuing downloader output',\n-                                            exc_info=failure_to_exc_info(f),\n-                                            extra={'spider': spider}))\n+        if isinstance(result, Request):\n+            self.crawl(result)\n+            return None\n+\n+        d = self.scraper.enqueue_scrape(result, request, self.spider)\n+        d.addErrback(\n+            lambda f: logger.error(\n+                \"Error while enqueuing downloader output\",\n+                exc_info=failure_to_exc_info(f),\n+                extra={'spider': self.spider},\n+            )\n+        )\n         return d\n \n-    def spider_is_idle(self, spider):\n+    def spider_is_idle(self, spider: Optional[Spider] = None) -> bool:\n+        if spider is not None:\n+            warnings.warn(\n+                \"Passing a 'spider' argument to ExecutionEngine.spider_is_idle is deprecated\",\n+                category=ScrapyDeprecationWarning,\n+                stacklevel=2,\n+            )\n+        if self.slot is None:\n+            raise RuntimeError(\"Engine slot not assigned\")\n         if not self.scraper.slot.is_idle():\n-            # scraper is not idle\n             return False\n-\n-        if self.downloader.active:\n-            # downloader has pending requests\n+        if self.downloader.active:  # downloader has pending requests\n             return False\n-\n-        if self.slot.start_requests is not None:\n-            # not all start requests are handled\n+        if self.slot.start_requests is not None:  # not all start requests are handled\n             return False\n-\n         if self.slot.scheduler.has_pending_requests():\n-            # scheduler has pending requests\n             return False\n-\n         return True\n \n-    @property\n-    def open_spiders(self):\n-        return [self.spider] if self.spider else []\n-\n-    def has_capacity(self):\n-        \"\"\"Does the engine have capacity to handle more spiders\"\"\"\n-        return not bool(self.slot)\n-\n-    def crawl(self, request, spider):\n-        if spider not in self.open_spiders:\n-            raise RuntimeError(f\"Spider {spider.name!r} not opened when crawling: {request}\")",
      "comment": "Shouldn\u2019t this error still be caught, if the spider argument does not match `self.spider`? (maybe with a better error message that explicitly says so, instead of the old message)",
      "comment_id": 611588090,
      "user": "Gallaecio",
      "created_at": "2021-04-12T12:34:50Z",
      "url": "https://github.com/scrapy/scrapy/pull/5090#discussion_r611588090"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 5090,
      "file_path": "scrapy/core/engine.py",
      "line": 391,
      "side": "RIGHT",
      "diff_hunk": "@@ -349,12 +366,26 @@ def errback(failure):\n \n         return dfd\n \n-    def _close_all_spiders(self):\n-        dfds = [self.close_spider(s, reason='shutdown') for s in self.open_spiders]\n-        dlist = defer.DeferredList(dfds)\n-        return dlist\n+    @property\n+    def open_spiders(self) -> list:\n+        warnings.warn(\n+            \"ExecutionEngine.open_spiders is deprecated, please use ExecutionEngine.spider instead\",\n+            category=ScrapyDeprecationWarning,\n+            stacklevel=2,\n+        )\n+        return [self.spider] if self.spider is not None else []\n \n-    @defer.inlineCallbacks\n-    def _finish_stopping_engine(self):\n-        yield self.signals.send_catch_log_deferred(signal=signals.engine_stopped)\n-        self._closewait.callback(None)\n+    def has_capacity(self) -> bool:\n+        warnings.warn(\"ExecutionEngine.has_capacity is deprecated\", ScrapyDeprecationWarning, stacklevel=2)\n+        return not bool(self.slot)\n+\n+    def schedule(self, request: Request, spider: Spider) -> None:\n+        warnings.warn(\n+            \"ExecutionEngine.schedule is deprecated, please use \"\n+            \"ExecutionEngine.crawl or ExecutionEngine.download instead\",\n+            category=ScrapyDeprecationWarning,\n+            stacklevel=2,\n+        )\n+        if self.slot is None:\n+            raise RuntimeError(\"Engine slot not assigned\")\n+        self._schedule_request(request)",
      "comment": "A potential issue I see here and in public methods where the `spider` argument is deprecated is that there is a slight behavior change that, while unlikely to affect many, if any, still happens without a deprecation period: we are just assuming that the `spider` argument, if passed, is the same as `self.spider`. And while that is what _should_ be happening, code-wise we cannot be sure of that.\r\n\r\nSo I\u2019m thinking that, to deprecate things properly, we may need to add a check specifically for that, and have things work as before in those cases (i.e. pass the `spider` argument forward to subsequent calls, instead of letting `self.spider` be used) but log a deprecation warning about it.",
      "comment_id": 611596888,
      "user": "Gallaecio",
      "created_at": "2021-04-12T12:47:32Z",
      "url": "https://github.com/scrapy/scrapy/pull/5090#discussion_r611596888"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 5090,
      "file_path": "scrapy/core/engine.py",
      "line": 326,
      "side": "RIGHT",
      "diff_hunk": "@@ -54,269 +64,277 @@ def _maybe_fire_closing(self):\n \n \n class ExecutionEngine:\n-\n-    def __init__(self, crawler, spider_closed_callback):\n+    def __init__(self, crawler, spider_closed_callback: Callable) -> None:\n         self.crawler = crawler\n         self.settings = crawler.settings\n         self.signals = crawler.signals\n         self.logformatter = crawler.logformatter\n-        self.slot = None\n-        self.spider = None\n+        self.slot: Optional[Slot] = None\n+        self.spider: Optional[Spider] = None\n         self.running = False\n         self.paused = False\n-        self.scheduler_cls = load_object(self.settings['SCHEDULER'])\n+        self.scheduler_cls = load_object(crawler.settings[\"SCHEDULER\"])\n         downloader_cls = load_object(self.settings['DOWNLOADER'])\n         self.downloader = downloader_cls(crawler)\n         self.scraper = Scraper(crawler)\n         self._spider_closed_callback = spider_closed_callback\n \n-    @defer.inlineCallbacks\n-    def start(self):\n-        \"\"\"Start the execution engine\"\"\"\n+    @inlineCallbacks\n+    def start(self) -> Deferred:\n         if self.running:\n             raise RuntimeError(\"Engine already running\")\n         self.start_time = time()\n         yield self.signals.send_catch_log_deferred(signal=signals.engine_started)\n         self.running = True\n-        self._closewait = defer.Deferred()\n+        self._closewait = Deferred()\n         yield self._closewait\n \n-    def stop(self):\n-        \"\"\"Stop the execution engine gracefully\"\"\"\n+    def stop(self) -> Deferred:\n+        \"\"\"Gracefully stop the execution engine\"\"\"\n+        @inlineCallbacks\n+        def _finish_stopping_engine(_) -> Deferred:\n+            yield self.signals.send_catch_log_deferred(signal=signals.engine_stopped)\n+            self._closewait.callback(None)\n+\n         if not self.running:\n             raise RuntimeError(\"Engine not running\")\n-        self.running = False\n-        dfd = self._close_all_spiders()\n-        return dfd.addBoth(lambda _: self._finish_stopping_engine())\n \n-    def close(self):\n-        \"\"\"Close the execution engine gracefully.\n+        self.running = False\n+        dfd = self.close_spider(self.spider, reason=\"shutdown\") if self.spider is not None else succeed(None)\n+        return dfd.addBoth(_finish_stopping_engine)\n \n-        If it has already been started, stop it. In all cases, close all spiders\n-        and the downloader.\n+    def close(self) -> Deferred:\n+        \"\"\"\n+        Gracefully close the execution engine.\n+        If it has already been started, stop it. In all cases, close the spider and the downloader.\n         \"\"\"\n         if self.running:\n-            # Will also close spiders and downloader\n-            return self.stop()\n-        elif self.open_spiders:\n-            # Will also close downloader\n-            return self._close_all_spiders()\n-        else:\n-            return defer.succeed(self.downloader.close())\n-\n-    def pause(self):\n-        \"\"\"Pause the execution engine\"\"\"\n+            return self.stop()  # will also close spider and downloader\n+        if self.spider is not None:\n+            return self.close_spider(self.spider, reason=\"shutdown\")  # will also close downloader\n+        return succeed(self.downloader.close())\n+\n+    def pause(self) -> None:\n         self.paused = True\n \n-    def unpause(self):\n-        \"\"\"Resume the execution engine\"\"\"\n+    def unpause(self) -> None:\n         self.paused = False\n \n-    def _next_request(self, spider):\n-        slot = self.slot\n-        if not slot:\n-            return\n+    def _next_request(self) -> None:\n+        assert self.slot is not None  # typing\n+        assert self.spider is not None  # typing\n \n         if self.paused:\n-            return\n+            return None\n \n-        while not self._needs_backout(spider):\n-            if not self._next_request_from_scheduler(spider):\n-                break\n+        while not self._needs_backout() and self._next_request_from_scheduler() is not None:\n+            pass\n \n-        if slot.start_requests and not self._needs_backout(spider):\n+        if self.slot.start_requests is not None and not self._needs_backout():\n             try:\n-                request = next(slot.start_requests)\n+                request = next(self.slot.start_requests)\n             except StopIteration:\n-                slot.start_requests = None\n+                self.slot.start_requests = None\n             except Exception:\n-                slot.start_requests = None\n-                logger.error('Error while obtaining start requests',\n-                             exc_info=True, extra={'spider': spider})\n+                self.slot.start_requests = None\n+                logger.error('Error while obtaining start requests', exc_info=True, extra={'spider': self.spider})\n             else:\n-                self.crawl(request, spider)\n+                self.crawl(request)\n \n-        if self.spider_is_idle(spider) and slot.close_if_idle:\n-            self._spider_idle(spider)\n+        if self.spider_is_idle() and self.slot.close_if_idle:\n+            self._spider_idle()\n \n-    def _needs_backout(self, spider):\n-        slot = self.slot\n+    def _needs_backout(self) -> bool:\n+        assert self.slot is not None  # typing\n         return (\n             not self.running\n-            or slot.closing\n+            or self.slot.closing\n             or self.downloader.needs_backout()\n             or self.scraper.slot.needs_backout()\n         )\n \n-    def _next_request_from_scheduler(self, spider):\n-        slot = self.slot\n-        request = slot.scheduler.next_request()\n-        if not request:\n-            return\n-        d = self._download(request, spider)\n-        d.addBoth(self._handle_downloader_output, request, spider)\n+    def _next_request_from_scheduler(self) -> Optional[Deferred]:\n+        assert self.slot is not None  # typing\n+\n+        request = self.slot.scheduler.next_request()\n+        if request is None:\n+            return None\n+\n+        d = self._download(request)\n+        d.addBoth(self._handle_downloader_output, request)\n         d.addErrback(lambda f: logger.info('Error while handling downloader output',\n                                            exc_info=failure_to_exc_info(f),\n-                                           extra={'spider': spider}))\n-        d.addBoth(lambda _: slot.remove_request(request))\n+                                           extra={'spider': self.spider}))\n+        d.addBoth(lambda _: self.slot.remove_request(request))\n         d.addErrback(lambda f: logger.info('Error while removing request from slot',\n                                            exc_info=failure_to_exc_info(f),\n-                                           extra={'spider': spider}))\n-        d.addBoth(lambda _: slot.nextcall.schedule())\n+                                           extra={'spider': self.spider}))\n+        d.addBoth(lambda _: self.slot.nextcall.schedule())\n         d.addErrback(lambda f: logger.info('Error while scheduling new request',\n                                            exc_info=failure_to_exc_info(f),\n-                                           extra={'spider': spider}))\n+                                           extra={'spider': self.spider}))\n         return d\n \n-    def _handle_downloader_output(self, response, request, spider):\n-        if not isinstance(response, (Request, Response, Failure)):\n-            raise TypeError(\n-                \"Incorrect type: expected Request, Response or Failure, got \"\n-                f\"{type(response)}: {response!r}\"\n-            )\n+    def _handle_downloader_output(\n+        self, result: Union[Request, Response, Failure], request: Request\n+    ) -> Optional[Deferred]:\n+        assert self.spider is not None  # typing\n+\n+        if not isinstance(result, (Request, Response, Failure)):\n+            raise TypeError(f\"Incorrect type: expected Request, Response or Failure, got {type(result)}: {result!r}\")\n+\n         # downloader middleware can return requests (for example, redirects)\n-        if isinstance(response, Request):\n-            self.crawl(response, spider)\n-            return\n-        # response is a Response or Failure\n-        d = self.scraper.enqueue_scrape(response, request, spider)\n-        d.addErrback(lambda f: logger.error('Error while enqueuing downloader output',\n-                                            exc_info=failure_to_exc_info(f),\n-                                            extra={'spider': spider}))\n+        if isinstance(result, Request):\n+            self.crawl(result)\n+            return None\n+\n+        d = self.scraper.enqueue_scrape(result, request, self.spider)\n+        d.addErrback(\n+            lambda f: logger.error(\n+                \"Error while enqueuing downloader output\",\n+                exc_info=failure_to_exc_info(f),\n+                extra={'spider': self.spider},\n+            )\n+        )\n         return d\n \n-    def spider_is_idle(self, spider):\n+    def spider_is_idle(self, spider: Optional[Spider] = None) -> bool:\n+        if spider is not None:\n+            warnings.warn(\n+                \"Passing a 'spider' argument to ExecutionEngine.spider_is_idle is deprecated\",\n+                category=ScrapyDeprecationWarning,\n+                stacklevel=2,\n+            )\n+        if self.slot is None:\n+            raise RuntimeError(\"Engine slot not assigned\")\n         if not self.scraper.slot.is_idle():\n-            # scraper is not idle\n             return False\n-\n-        if self.downloader.active:\n-            # downloader has pending requests\n+        if self.downloader.active:  # downloader has pending requests\n             return False\n-\n-        if self.slot.start_requests is not None:\n-            # not all start requests are handled\n+        if self.slot.start_requests is not None:  # not all start requests are handled\n             return False\n-\n         if self.slot.scheduler.has_pending_requests():\n-            # scheduler has pending requests\n             return False\n-\n         return True\n \n-    @property\n-    def open_spiders(self):\n-        return [self.spider] if self.spider else []\n-\n-    def has_capacity(self):\n-        \"\"\"Does the engine have capacity to handle more spiders\"\"\"\n-        return not bool(self.slot)\n-\n-    def crawl(self, request, spider):\n-        if spider not in self.open_spiders:\n-            raise RuntimeError(f\"Spider {spider.name!r} not opened when crawling: {request}\")\n-        self.schedule(request, spider)\n+    def crawl(self, request: Request, spider: Optional[Spider] = None) -> None:\n+        \"\"\"Inject the request into the spider <-> downloader pipeline\"\"\"\n+        if spider is not None:\n+            warnings.warn(\n+                \"Passing a 'spider' argument to ExecutionEngine.crawl is deprecated\",\n+                category=ScrapyDeprecationWarning,\n+                stacklevel=2,\n+            )\n+        if self.slot is None:\n+            raise RuntimeError(\"Engine slot not assigned\")\n+        if self.spider is None:\n+            raise RuntimeError(f\"Spider not opened when crawling: {request}\")\n+        self._schedule_request(request)\n         self.slot.nextcall.schedule()\n \n-    def schedule(self, request, spider):\n-        self.signals.send_catch_log(signals.request_scheduled, request=request, spider=spider)\n+    def _schedule_request(self, request: Request) -> None:\n+        assert self.slot is not None  # typing\n+        self.signals.send_catch_log(signals.request_scheduled, request=request, spider=self.spider)\n         if not self.slot.scheduler.enqueue_request(request):\n-            self.signals.send_catch_log(signals.request_dropped, request=request, spider=spider)\n-\n-    def download(self, request, spider):\n-        d = self._download(request, spider)\n-        d.addBoth(self._downloaded, self.slot, request, spider)\n-        return d\n-\n-    def _downloaded(self, response, slot, request, spider):\n-        slot.remove_request(request)\n-        return self.download(response, spider) if isinstance(response, Request) else response\n-\n-    def _download(self, request, spider):\n-        slot = self.slot\n-        slot.add_request(request)\n-\n-        def _on_success(response):\n-            if not isinstance(response, (Response, Request)):\n-                raise TypeError(\n-                    \"Incorrect type: expected Response or Request, got \"\n-                    f\"{type(response)}: {response!r}\"\n-                )\n-            if isinstance(response, Response):\n-                if response.request is None:\n-                    response.request = request\n-                logkws = self.logformatter.crawled(response.request, response, spider)\n+            self.signals.send_catch_log(signals.request_dropped, request=request, spider=self.spider)\n+\n+    def download(self, request: Request, spider: Optional[Spider] = None) -> Deferred:\n+        \"\"\"Return a Deferred which fires with a Response as result, only downloader middlewares are applied\"\"\"\n+        if spider is not None:\n+            warnings.warn(\n+                \"Passing a 'spider' argument to ExecutionEngine.download is deprecated\",\n+                category=ScrapyDeprecationWarning,\n+                stacklevel=2,\n+            )\n+        return self._download(request).addBoth(self._downloaded, request)\n+\n+    def _downloaded(\n+        self, result: Union[Response, Request], request: Request\n+    ) -> Union[Deferred, Response]:\n+        assert self.slot is not None  # typing\n+        assert self.spider is not None  # typing\n+        self.slot.remove_request(request)\n+        return self.download(result) if isinstance(result, Request) else result\n+\n+    def _download(self, request: Request) -> Deferred:\n+        assert self.slot is not None  # typing\n+\n+        self.slot.add_request(request)\n+\n+        def _on_success(result: Union[Response, Request]) -> Union[Response, Request]:\n+            if not isinstance(result, (Response, Request)):\n+                raise TypeError(f\"Incorrect type: expected Response or Request, got {type(result)}: {result!r}\")\n+            if isinstance(result, Response):\n+                if result.request is None:\n+                    result.request = request\n+                logkws = self.logformatter.crawled(result.request, result, self.spider)\n                 if logkws is not None:\n-                    logger.log(*logformatter_adapter(logkws), extra={'spider': spider})\n+                    logger.log(*logformatter_adapter(logkws), extra={\"spider\": self.spider})\n                 self.signals.send_catch_log(\n                     signal=signals.response_received,\n-                    response=response,\n-                    request=response.request,\n-                    spider=spider,\n+                    response=result,\n+                    request=result.request,\n+                    spider=self.spider,\n                 )\n-            return response\n+            return result\n \n         def _on_complete(_):\n-            slot.nextcall.schedule()\n+            self.slot.nextcall.schedule()\n             return _\n \n-        dwld = self.downloader.fetch(request, spider)\n+        dwld = self.downloader.fetch(request, self.spider)\n         dwld.addCallbacks(_on_success)\n         dwld.addBoth(_on_complete)\n         return dwld\n \n-    @defer.inlineCallbacks\n-    def open_spider(self, spider, start_requests=(), close_if_idle=True):\n-        if not self.has_capacity():\n+    @inlineCallbacks\n+    def open_spider(self, spider: Spider, start_requests: Iterable = (), close_if_idle: bool = True):\n+        if self.slot is not None:\n             raise RuntimeError(f\"No free spider slot when opening {spider.name!r}\")\n         logger.info(\"Spider opened\", extra={'spider': spider})\n-        nextcall = CallLaterOnce(self._next_request, spider)\n-        scheduler = self.scheduler_cls.from_crawler(self.crawler)\n+        nextcall = CallLaterOnce(self._next_request)\n+        scheduler = create_instance(self.scheduler_cls, settings=None, crawler=self.crawler)\n         start_requests = yield self.scraper.spidermw.process_start_requests(start_requests, spider)\n-        slot = Slot(start_requests, close_if_idle, nextcall, scheduler)\n-        self.slot = slot\n+        self.slot = Slot(start_requests, close_if_idle, nextcall, scheduler)\n         self.spider = spider\n         yield scheduler.open(spider)\n         yield self.scraper.open_spider(spider)\n         self.crawler.stats.open_spider(spider)\n         yield self.signals.send_catch_log_deferred(signals.spider_opened, spider=spider)\n-        slot.nextcall.schedule()\n-        slot.heartbeat.start(5)\n-\n-    def _spider_idle(self, spider):\n-        \"\"\"Called when a spider gets idle. This function is called when there\n-        are no remaining pages to download or schedule. It can be called\n-        multiple times. If some extension raises a DontCloseSpider exception\n-        (in the spider_idle signal handler) the spider is not closed until the\n-        next loop and this function is guaranteed to be called (at least) once\n-        again for this spider.\n+        self.slot.nextcall.schedule()\n+        self.slot.heartbeat.start(5)\n+\n+    def _spider_idle(self) -> None:\n         \"\"\"\n-        res = self.signals.send_catch_log(signals.spider_idle, spider=spider, dont_log=DontCloseSpider)\n+        Called when a spider gets idle, i.e. when there are no remaining requests to download or schedule.\n+        It can be called multiple times. If a handler for the spider_idle signal raises a DontCloseSpider\n+        exception, the spider is not closed until the next loop and this function is guaranteed to be called\n+        (at least) once again.\n+        \"\"\"\n+        assert self.spider is not None  # typing\n+\n+        res = self.signals.send_catch_log(signals.spider_idle, spider=self.spider, dont_log=DontCloseSpider)\n         if any(isinstance(x, Failure) and isinstance(x.value, DontCloseSpider) for _, x in res):\n-            return\n+            return None\n \n-        if self.spider_is_idle(spider):\n-            self.close_spider(spider, reason='finished')\n+        if self.spider_is_idle():\n+            self.close_spider(self.spider, reason='finished')\n \n-    def close_spider(self, spider, reason='cancelled'):\n+    def close_spider(self, spider: Spider, reason: str = \"cancelled\") -> Deferred:\n         \"\"\"Close (cancel) spider and clear all its outstanding requests\"\"\"\n+        if self.slot is None:\n+            raise RuntimeError(\"Engine slot not assigned\")",
      "comment": "This change makes a lot of sense, much better than the exception that `if slot.closing` would raise otherwise. But we should probably mention it in the release notes, even if briefly.\r\n\r\nI wonder if we should start adding a \u201crelease notes notes\u201d section to the description of some pull requests, to make sure we do not miss these small things.",
      "comment_id": 611600028,
      "user": "Gallaecio",
      "created_at": "2021-04-12T12:52:01Z",
      "url": "https://github.com/scrapy/scrapy/pull/5090#discussion_r611600028"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 5090,
      "file_path": "scrapy/core/engine.py",
      "line": 391,
      "side": "RIGHT",
      "diff_hunk": "@@ -349,12 +366,26 @@ def errback(failure):\n \n         return dfd\n \n-    def _close_all_spiders(self):\n-        dfds = [self.close_spider(s, reason='shutdown') for s in self.open_spiders]\n-        dlist = defer.DeferredList(dfds)\n-        return dlist\n+    @property\n+    def open_spiders(self) -> list:\n+        warnings.warn(\n+            \"ExecutionEngine.open_spiders is deprecated, please use ExecutionEngine.spider instead\",\n+            category=ScrapyDeprecationWarning,\n+            stacklevel=2,\n+        )\n+        return [self.spider] if self.spider is not None else []\n \n-    @defer.inlineCallbacks\n-    def _finish_stopping_engine(self):\n-        yield self.signals.send_catch_log_deferred(signal=signals.engine_stopped)\n-        self._closewait.callback(None)\n+    def has_capacity(self) -> bool:\n+        warnings.warn(\"ExecutionEngine.has_capacity is deprecated\", ScrapyDeprecationWarning, stacklevel=2)\n+        return not bool(self.slot)\n+\n+    def schedule(self, request: Request, spider: Spider) -> None:\n+        warnings.warn(\n+            \"ExecutionEngine.schedule is deprecated, please use \"\n+            \"ExecutionEngine.crawl or ExecutionEngine.download instead\",\n+            category=ScrapyDeprecationWarning,\n+            stacklevel=2,\n+        )\n+        if self.slot is None:\n+            raise RuntimeError(\"Engine slot not assigned\")\n+        self._schedule_request(request)",
      "comment": "Makes sense, I added the arguments back to the underscored methods that are called from public ones.\r\nNote that this doesn't include `_spider_idle`, `_next_request`, `_next_request_from_scheduler`. `_spider_idle` and `_next_request_from_scheduler` are only called from `_next_request`, which is in turn only \"called\" (set to be called later, that is) from `open_spider`, the method which sets `self.spider`.",
      "comment_id": 614264119,
      "user": "elacuesta",
      "created_at": "2021-04-15T17:31:27Z",
      "url": "https://github.com/scrapy/scrapy/pull/5090#discussion_r614264119"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 5090,
      "file_path": "scrapy/core/engine.py",
      "line": 217,
      "side": "LEFT",
      "diff_hunk": "@@ -54,269 +64,277 @@ def _maybe_fire_closing(self):\n \n \n class ExecutionEngine:\n-\n-    def __init__(self, crawler, spider_closed_callback):\n+    def __init__(self, crawler, spider_closed_callback: Callable) -> None:\n         self.crawler = crawler\n         self.settings = crawler.settings\n         self.signals = crawler.signals\n         self.logformatter = crawler.logformatter\n-        self.slot = None\n-        self.spider = None\n+        self.slot: Optional[Slot] = None\n+        self.spider: Optional[Spider] = None\n         self.running = False\n         self.paused = False\n-        self.scheduler_cls = load_object(self.settings['SCHEDULER'])\n+        self.scheduler_cls = load_object(crawler.settings[\"SCHEDULER\"])\n         downloader_cls = load_object(self.settings['DOWNLOADER'])\n         self.downloader = downloader_cls(crawler)\n         self.scraper = Scraper(crawler)\n         self._spider_closed_callback = spider_closed_callback\n \n-    @defer.inlineCallbacks\n-    def start(self):\n-        \"\"\"Start the execution engine\"\"\"\n+    @inlineCallbacks\n+    def start(self) -> Deferred:\n         if self.running:\n             raise RuntimeError(\"Engine already running\")\n         self.start_time = time()\n         yield self.signals.send_catch_log_deferred(signal=signals.engine_started)\n         self.running = True\n-        self._closewait = defer.Deferred()\n+        self._closewait = Deferred()\n         yield self._closewait\n \n-    def stop(self):\n-        \"\"\"Stop the execution engine gracefully\"\"\"\n+    def stop(self) -> Deferred:\n+        \"\"\"Gracefully stop the execution engine\"\"\"\n+        @inlineCallbacks\n+        def _finish_stopping_engine(_) -> Deferred:\n+            yield self.signals.send_catch_log_deferred(signal=signals.engine_stopped)\n+            self._closewait.callback(None)\n+\n         if not self.running:\n             raise RuntimeError(\"Engine not running\")\n-        self.running = False\n-        dfd = self._close_all_spiders()\n-        return dfd.addBoth(lambda _: self._finish_stopping_engine())\n \n-    def close(self):\n-        \"\"\"Close the execution engine gracefully.\n+        self.running = False\n+        dfd = self.close_spider(self.spider, reason=\"shutdown\") if self.spider is not None else succeed(None)\n+        return dfd.addBoth(_finish_stopping_engine)\n \n-        If it has already been started, stop it. In all cases, close all spiders\n-        and the downloader.\n+    def close(self) -> Deferred:\n+        \"\"\"\n+        Gracefully close the execution engine.\n+        If it has already been started, stop it. In all cases, close the spider and the downloader.\n         \"\"\"\n         if self.running:\n-            # Will also close spiders and downloader\n-            return self.stop()\n-        elif self.open_spiders:\n-            # Will also close downloader\n-            return self._close_all_spiders()\n-        else:\n-            return defer.succeed(self.downloader.close())\n-\n-    def pause(self):\n-        \"\"\"Pause the execution engine\"\"\"\n+            return self.stop()  # will also close spider and downloader\n+        if self.spider is not None:\n+            return self.close_spider(self.spider, reason=\"shutdown\")  # will also close downloader\n+        return succeed(self.downloader.close())\n+\n+    def pause(self) -> None:\n         self.paused = True\n \n-    def unpause(self):\n-        \"\"\"Resume the execution engine\"\"\"\n+    def unpause(self) -> None:\n         self.paused = False\n \n-    def _next_request(self, spider):\n-        slot = self.slot\n-        if not slot:\n-            return\n+    def _next_request(self) -> None:\n+        assert self.slot is not None  # typing\n+        assert self.spider is not None  # typing\n \n         if self.paused:\n-            return\n+            return None\n \n-        while not self._needs_backout(spider):\n-            if not self._next_request_from_scheduler(spider):\n-                break\n+        while not self._needs_backout() and self._next_request_from_scheduler() is not None:\n+            pass\n \n-        if slot.start_requests and not self._needs_backout(spider):\n+        if self.slot.start_requests is not None and not self._needs_backout():\n             try:\n-                request = next(slot.start_requests)\n+                request = next(self.slot.start_requests)\n             except StopIteration:\n-                slot.start_requests = None\n+                self.slot.start_requests = None\n             except Exception:\n-                slot.start_requests = None\n-                logger.error('Error while obtaining start requests',\n-                             exc_info=True, extra={'spider': spider})\n+                self.slot.start_requests = None\n+                logger.error('Error while obtaining start requests', exc_info=True, extra={'spider': self.spider})\n             else:\n-                self.crawl(request, spider)\n+                self.crawl(request)\n \n-        if self.spider_is_idle(spider) and slot.close_if_idle:\n-            self._spider_idle(spider)\n+        if self.spider_is_idle() and self.slot.close_if_idle:\n+            self._spider_idle()\n \n-    def _needs_backout(self, spider):\n-        slot = self.slot\n+    def _needs_backout(self) -> bool:\n+        assert self.slot is not None  # typing\n         return (\n             not self.running\n-            or slot.closing\n+            or self.slot.closing\n             or self.downloader.needs_backout()\n             or self.scraper.slot.needs_backout()\n         )\n \n-    def _next_request_from_scheduler(self, spider):\n-        slot = self.slot\n-        request = slot.scheduler.next_request()\n-        if not request:\n-            return\n-        d = self._download(request, spider)\n-        d.addBoth(self._handle_downloader_output, request, spider)\n+    def _next_request_from_scheduler(self) -> Optional[Deferred]:\n+        assert self.slot is not None  # typing\n+\n+        request = self.slot.scheduler.next_request()\n+        if request is None:\n+            return None\n+\n+        d = self._download(request)\n+        d.addBoth(self._handle_downloader_output, request)\n         d.addErrback(lambda f: logger.info('Error while handling downloader output',\n                                            exc_info=failure_to_exc_info(f),\n-                                           extra={'spider': spider}))\n-        d.addBoth(lambda _: slot.remove_request(request))\n+                                           extra={'spider': self.spider}))\n+        d.addBoth(lambda _: self.slot.remove_request(request))\n         d.addErrback(lambda f: logger.info('Error while removing request from slot',\n                                            exc_info=failure_to_exc_info(f),\n-                                           extra={'spider': spider}))\n-        d.addBoth(lambda _: slot.nextcall.schedule())\n+                                           extra={'spider': self.spider}))\n+        d.addBoth(lambda _: self.slot.nextcall.schedule())\n         d.addErrback(lambda f: logger.info('Error while scheduling new request',\n                                            exc_info=failure_to_exc_info(f),\n-                                           extra={'spider': spider}))\n+                                           extra={'spider': self.spider}))\n         return d\n \n-    def _handle_downloader_output(self, response, request, spider):\n-        if not isinstance(response, (Request, Response, Failure)):\n-            raise TypeError(\n-                \"Incorrect type: expected Request, Response or Failure, got \"\n-                f\"{type(response)}: {response!r}\"\n-            )\n+    def _handle_downloader_output(\n+        self, result: Union[Request, Response, Failure], request: Request\n+    ) -> Optional[Deferred]:\n+        assert self.spider is not None  # typing\n+\n+        if not isinstance(result, (Request, Response, Failure)):\n+            raise TypeError(f\"Incorrect type: expected Request, Response or Failure, got {type(result)}: {result!r}\")\n+\n         # downloader middleware can return requests (for example, redirects)\n-        if isinstance(response, Request):\n-            self.crawl(response, spider)\n-            return\n-        # response is a Response or Failure\n-        d = self.scraper.enqueue_scrape(response, request, spider)\n-        d.addErrback(lambda f: logger.error('Error while enqueuing downloader output',\n-                                            exc_info=failure_to_exc_info(f),\n-                                            extra={'spider': spider}))\n+        if isinstance(result, Request):\n+            self.crawl(result)\n+            return None\n+\n+        d = self.scraper.enqueue_scrape(result, request, self.spider)\n+        d.addErrback(\n+            lambda f: logger.error(\n+                \"Error while enqueuing downloader output\",\n+                exc_info=failure_to_exc_info(f),\n+                extra={'spider': self.spider},\n+            )\n+        )\n         return d\n \n-    def spider_is_idle(self, spider):\n+    def spider_is_idle(self, spider: Optional[Spider] = None) -> bool:\n+        if spider is not None:\n+            warnings.warn(\n+                \"Passing a 'spider' argument to ExecutionEngine.spider_is_idle is deprecated\",\n+                category=ScrapyDeprecationWarning,\n+                stacklevel=2,\n+            )\n+        if self.slot is None:\n+            raise RuntimeError(\"Engine slot not assigned\")\n         if not self.scraper.slot.is_idle():\n-            # scraper is not idle\n             return False\n-\n-        if self.downloader.active:\n-            # downloader has pending requests\n+        if self.downloader.active:  # downloader has pending requests\n             return False\n-\n-        if self.slot.start_requests is not None:\n-            # not all start requests are handled\n+        if self.slot.start_requests is not None:  # not all start requests are handled\n             return False\n-\n         if self.slot.scheduler.has_pending_requests():\n-            # scheduler has pending requests\n             return False\n-\n         return True\n \n-    @property\n-    def open_spiders(self):\n-        return [self.spider] if self.spider else []\n-\n-    def has_capacity(self):\n-        \"\"\"Does the engine have capacity to handle more spiders\"\"\"\n-        return not bool(self.slot)\n-\n-    def crawl(self, request, spider):\n-        if spider not in self.open_spiders:\n-            raise RuntimeError(f\"Spider {spider.name!r} not opened when crawling: {request}\")",
      "comment": "Good call. It's updated, hopefully this is more explicit:\r\n```python\r\ndef crawl(self, request: Request, spider: Optional[Spider] = None) -> None:\r\n    \"\"\"Inject the request into the spider <-> downloader pipeline\"\"\"\r\n    if spider is not None:\r\n        warnings.warn(\r\n            \"Passing a 'spider' argument to ExecutionEngine.crawl is deprecated\",\r\n            category=ScrapyDeprecationWarning,\r\n            stacklevel=2,\r\n        )\r\n        if spider is not self.spider:\r\n            raise RuntimeError(f\"The spider '{spider.name!r}' does not match the open spider\")\r\n    if self.spider is None:\r\n        raise RuntimeError(f\"No open spider to crawl: {request}\")\r\n    self._schedule_request(request, self.spider)\r\n    self.slot.nextcall.schedule()  # type: ignore[union-attr]\r\n```\r\n\r\nNote that I added the same verification code at `download`, which at the moment does not check if the passed spider matches the open one. This is technically backward-incompatible, but I think it's a reasonable thing to do.",
      "comment_id": 614277741,
      "user": "elacuesta",
      "created_at": "2021-04-15T17:52:59Z",
      "url": "https://github.com/scrapy/scrapy/pull/5090#discussion_r614277741"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 5090,
      "file_path": "scrapy/core/engine.py",
      "line": 391,
      "side": "RIGHT",
      "diff_hunk": "@@ -349,12 +366,26 @@ def errback(failure):\n \n         return dfd\n \n-    def _close_all_spiders(self):\n-        dfds = [self.close_spider(s, reason='shutdown') for s in self.open_spiders]\n-        dlist = defer.DeferredList(dfds)\n-        return dlist\n+    @property\n+    def open_spiders(self) -> list:\n+        warnings.warn(\n+            \"ExecutionEngine.open_spiders is deprecated, please use ExecutionEngine.spider instead\",\n+            category=ScrapyDeprecationWarning,\n+            stacklevel=2,\n+        )\n+        return [self.spider] if self.spider is not None else []\n \n-    @defer.inlineCallbacks\n-    def _finish_stopping_engine(self):\n-        yield self.signals.send_catch_log_deferred(signal=signals.engine_stopped)\n-        self._closewait.callback(None)\n+    def has_capacity(self) -> bool:\n+        warnings.warn(\"ExecutionEngine.has_capacity is deprecated\", ScrapyDeprecationWarning, stacklevel=2)\n+        return not bool(self.slot)\n+\n+    def schedule(self, request: Request, spider: Spider) -> None:\n+        warnings.warn(\n+            \"ExecutionEngine.schedule is deprecated, please use \"\n+            \"ExecutionEngine.crawl or ExecutionEngine.download instead\",\n+            category=ScrapyDeprecationWarning,\n+            stacklevel=2,\n+        )\n+        if self.slot is None:\n+            raise RuntimeError(\"Engine slot not assigned\")\n+        self._schedule_request(request)",
      "comment": "Actually, the only risk is with `download`: `spider_is_idle` was not using the spider to begin with and `crawl` was checking if the spider was in `self.open_spiders` (now it checks if it matches `self.spider`). As I mentioned in https://github.com/scrapy/scrapy/pull/5090#discussion_r614277741, I added the same check to `download`. ",
      "comment_id": 614287520,
      "user": "elacuesta",
      "created_at": "2021-04-15T18:08:51Z",
      "url": "https://github.com/scrapy/scrapy/pull/5090#discussion_r614287520"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 5090,
      "file_path": "scrapy/core/engine.py",
      "line": 217,
      "side": "LEFT",
      "diff_hunk": "@@ -54,269 +64,277 @@ def _maybe_fire_closing(self):\n \n \n class ExecutionEngine:\n-\n-    def __init__(self, crawler, spider_closed_callback):\n+    def __init__(self, crawler, spider_closed_callback: Callable) -> None:\n         self.crawler = crawler\n         self.settings = crawler.settings\n         self.signals = crawler.signals\n         self.logformatter = crawler.logformatter\n-        self.slot = None\n-        self.spider = None\n+        self.slot: Optional[Slot] = None\n+        self.spider: Optional[Spider] = None\n         self.running = False\n         self.paused = False\n-        self.scheduler_cls = load_object(self.settings['SCHEDULER'])\n+        self.scheduler_cls = load_object(crawler.settings[\"SCHEDULER\"])\n         downloader_cls = load_object(self.settings['DOWNLOADER'])\n         self.downloader = downloader_cls(crawler)\n         self.scraper = Scraper(crawler)\n         self._spider_closed_callback = spider_closed_callback\n \n-    @defer.inlineCallbacks\n-    def start(self):\n-        \"\"\"Start the execution engine\"\"\"\n+    @inlineCallbacks\n+    def start(self) -> Deferred:\n         if self.running:\n             raise RuntimeError(\"Engine already running\")\n         self.start_time = time()\n         yield self.signals.send_catch_log_deferred(signal=signals.engine_started)\n         self.running = True\n-        self._closewait = defer.Deferred()\n+        self._closewait = Deferred()\n         yield self._closewait\n \n-    def stop(self):\n-        \"\"\"Stop the execution engine gracefully\"\"\"\n+    def stop(self) -> Deferred:\n+        \"\"\"Gracefully stop the execution engine\"\"\"\n+        @inlineCallbacks\n+        def _finish_stopping_engine(_) -> Deferred:\n+            yield self.signals.send_catch_log_deferred(signal=signals.engine_stopped)\n+            self._closewait.callback(None)\n+\n         if not self.running:\n             raise RuntimeError(\"Engine not running\")\n-        self.running = False\n-        dfd = self._close_all_spiders()\n-        return dfd.addBoth(lambda _: self._finish_stopping_engine())\n \n-    def close(self):\n-        \"\"\"Close the execution engine gracefully.\n+        self.running = False\n+        dfd = self.close_spider(self.spider, reason=\"shutdown\") if self.spider is not None else succeed(None)\n+        return dfd.addBoth(_finish_stopping_engine)\n \n-        If it has already been started, stop it. In all cases, close all spiders\n-        and the downloader.\n+    def close(self) -> Deferred:\n+        \"\"\"\n+        Gracefully close the execution engine.\n+        If it has already been started, stop it. In all cases, close the spider and the downloader.\n         \"\"\"\n         if self.running:\n-            # Will also close spiders and downloader\n-            return self.stop()\n-        elif self.open_spiders:\n-            # Will also close downloader\n-            return self._close_all_spiders()\n-        else:\n-            return defer.succeed(self.downloader.close())\n-\n-    def pause(self):\n-        \"\"\"Pause the execution engine\"\"\"\n+            return self.stop()  # will also close spider and downloader\n+        if self.spider is not None:\n+            return self.close_spider(self.spider, reason=\"shutdown\")  # will also close downloader\n+        return succeed(self.downloader.close())\n+\n+    def pause(self) -> None:\n         self.paused = True\n \n-    def unpause(self):\n-        \"\"\"Resume the execution engine\"\"\"\n+    def unpause(self) -> None:\n         self.paused = False\n \n-    def _next_request(self, spider):\n-        slot = self.slot\n-        if not slot:\n-            return\n+    def _next_request(self) -> None:\n+        assert self.slot is not None  # typing\n+        assert self.spider is not None  # typing\n \n         if self.paused:\n-            return\n+            return None\n \n-        while not self._needs_backout(spider):\n-            if not self._next_request_from_scheduler(spider):\n-                break\n+        while not self._needs_backout() and self._next_request_from_scheduler() is not None:\n+            pass\n \n-        if slot.start_requests and not self._needs_backout(spider):\n+        if self.slot.start_requests is not None and not self._needs_backout():\n             try:\n-                request = next(slot.start_requests)\n+                request = next(self.slot.start_requests)\n             except StopIteration:\n-                slot.start_requests = None\n+                self.slot.start_requests = None\n             except Exception:\n-                slot.start_requests = None\n-                logger.error('Error while obtaining start requests',\n-                             exc_info=True, extra={'spider': spider})\n+                self.slot.start_requests = None\n+                logger.error('Error while obtaining start requests', exc_info=True, extra={'spider': self.spider})\n             else:\n-                self.crawl(request, spider)\n+                self.crawl(request)\n \n-        if self.spider_is_idle(spider) and slot.close_if_idle:\n-            self._spider_idle(spider)\n+        if self.spider_is_idle() and self.slot.close_if_idle:\n+            self._spider_idle()\n \n-    def _needs_backout(self, spider):\n-        slot = self.slot\n+    def _needs_backout(self) -> bool:\n+        assert self.slot is not None  # typing\n         return (\n             not self.running\n-            or slot.closing\n+            or self.slot.closing\n             or self.downloader.needs_backout()\n             or self.scraper.slot.needs_backout()\n         )\n \n-    def _next_request_from_scheduler(self, spider):\n-        slot = self.slot\n-        request = slot.scheduler.next_request()\n-        if not request:\n-            return\n-        d = self._download(request, spider)\n-        d.addBoth(self._handle_downloader_output, request, spider)\n+    def _next_request_from_scheduler(self) -> Optional[Deferred]:\n+        assert self.slot is not None  # typing\n+\n+        request = self.slot.scheduler.next_request()\n+        if request is None:\n+            return None\n+\n+        d = self._download(request)\n+        d.addBoth(self._handle_downloader_output, request)\n         d.addErrback(lambda f: logger.info('Error while handling downloader output',\n                                            exc_info=failure_to_exc_info(f),\n-                                           extra={'spider': spider}))\n-        d.addBoth(lambda _: slot.remove_request(request))\n+                                           extra={'spider': self.spider}))\n+        d.addBoth(lambda _: self.slot.remove_request(request))\n         d.addErrback(lambda f: logger.info('Error while removing request from slot',\n                                            exc_info=failure_to_exc_info(f),\n-                                           extra={'spider': spider}))\n-        d.addBoth(lambda _: slot.nextcall.schedule())\n+                                           extra={'spider': self.spider}))\n+        d.addBoth(lambda _: self.slot.nextcall.schedule())\n         d.addErrback(lambda f: logger.info('Error while scheduling new request',\n                                            exc_info=failure_to_exc_info(f),\n-                                           extra={'spider': spider}))\n+                                           extra={'spider': self.spider}))\n         return d\n \n-    def _handle_downloader_output(self, response, request, spider):\n-        if not isinstance(response, (Request, Response, Failure)):\n-            raise TypeError(\n-                \"Incorrect type: expected Request, Response or Failure, got \"\n-                f\"{type(response)}: {response!r}\"\n-            )\n+    def _handle_downloader_output(\n+        self, result: Union[Request, Response, Failure], request: Request\n+    ) -> Optional[Deferred]:\n+        assert self.spider is not None  # typing\n+\n+        if not isinstance(result, (Request, Response, Failure)):\n+            raise TypeError(f\"Incorrect type: expected Request, Response or Failure, got {type(result)}: {result!r}\")\n+\n         # downloader middleware can return requests (for example, redirects)\n-        if isinstance(response, Request):\n-            self.crawl(response, spider)\n-            return\n-        # response is a Response or Failure\n-        d = self.scraper.enqueue_scrape(response, request, spider)\n-        d.addErrback(lambda f: logger.error('Error while enqueuing downloader output',\n-                                            exc_info=failure_to_exc_info(f),\n-                                            extra={'spider': spider}))\n+        if isinstance(result, Request):\n+            self.crawl(result)\n+            return None\n+\n+        d = self.scraper.enqueue_scrape(result, request, self.spider)\n+        d.addErrback(\n+            lambda f: logger.error(\n+                \"Error while enqueuing downloader output\",\n+                exc_info=failure_to_exc_info(f),\n+                extra={'spider': self.spider},\n+            )\n+        )\n         return d\n \n-    def spider_is_idle(self, spider):\n+    def spider_is_idle(self, spider: Optional[Spider] = None) -> bool:\n+        if spider is not None:\n+            warnings.warn(\n+                \"Passing a 'spider' argument to ExecutionEngine.spider_is_idle is deprecated\",\n+                category=ScrapyDeprecationWarning,\n+                stacklevel=2,\n+            )\n+        if self.slot is None:\n+            raise RuntimeError(\"Engine slot not assigned\")\n         if not self.scraper.slot.is_idle():\n-            # scraper is not idle\n             return False\n-\n-        if self.downloader.active:\n-            # downloader has pending requests\n+        if self.downloader.active:  # downloader has pending requests\n             return False\n-\n-        if self.slot.start_requests is not None:\n-            # not all start requests are handled\n+        if self.slot.start_requests is not None:  # not all start requests are handled\n             return False\n-\n         if self.slot.scheduler.has_pending_requests():\n-            # scheduler has pending requests\n             return False\n-\n         return True\n \n-    @property\n-    def open_spiders(self):\n-        return [self.spider] if self.spider else []\n-\n-    def has_capacity(self):\n-        \"\"\"Does the engine have capacity to handle more spiders\"\"\"\n-        return not bool(self.slot)\n-\n-    def crawl(self, request, spider):\n-        if spider not in self.open_spiders:\n-            raise RuntimeError(f\"Spider {spider.name!r} not opened when crawling: {request}\")",
      "comment": "> Note that I added the same verification code at download, which at the moment does not check if the passed spider matches the open one. This is technically backward-incompatible, but I think it's a reasonable thing to do.\r\n\r\nWhy not just log an additional warning instead, or even an error? It should still catch the attention of anyone actually doing this (hopefully no one), while still remaining backward compatible during the deprecation period.",
      "comment_id": 614335879,
      "user": "Gallaecio",
      "created_at": "2021-04-15T19:27:27Z",
      "url": "https://github.com/scrapy/scrapy/pull/5090#discussion_r614335879"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 5077,
      "file_path": "scrapy/core/downloader/middleware.py",
      "line": 52,
      "side": "RIGHT",
      "diff_hunk": "@@ -44,7 +48,7 @@ def process_request(request):\n             return (yield download_func(request=request, spider=spider))\n \n         @defer.inlineCallbacks\n-        def process_response(response):\n+        def process_response(response: Union[Response, Request]):\n             if response is None:",
      "comment": "if respone can be None, shouldn't it be optional in the type?",
      "comment_id": 608611188,
      "user": "kmike",
      "created_at": "2021-04-07T12:34:54Z",
      "url": "https://github.com/scrapy/scrapy/pull/5077#discussion_r608611188"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 5077,
      "file_path": "scrapy/core/scraper.py",
      "line": 6,
      "side": "RIGHT",
      "diff_hunk": "@@ -3,12 +3,14 @@\n \n import logging\n from collections import deque\n+from collections.abc import Iterable",
      "comment": "What's your motivation for importing it from collections.abc, and not from typing?",
      "comment_id": 608612820,
      "user": "kmike",
      "created_at": "2021-04-07T12:37:17Z",
      "url": "https://github.com/scrapy/scrapy/pull/5077#discussion_r608612820"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 5077,
      "file_path": "scrapy/core/spidermw.py",
      "line": 73,
      "side": "RIGHT",
      "diff_hunk": "@@ -62,7 +70,7 @@ def _evaluate_iterable(self, response, spider, iterable, exception_processor_ind\n                 raise\n             recover_to.extend(exception_result)\n \n-    def _process_spider_exception(self, response, spider, _failure, start_index=0):\n+    def _process_spider_exception(self, response: Response, spider: Spider, _failure: Failure, start_index=0):",
      "comment": "```suggestion\r\n    def _process_spider_exception(self, response: Response, spider: Spider, _failure: Failure, start_index: int = 0):\r\n```",
      "comment_id": 608614157,
      "user": "kmike",
      "created_at": "2021-04-07T12:39:00Z",
      "url": "https://github.com/scrapy/scrapy/pull/5077#discussion_r608614157"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 5077,
      "file_path": "scrapy/middleware.py",
      "line": 20,
      "side": "RIGHT",
      "diff_hunk": "@@ -16,7 +17,7 @@ class MiddlewareManager:\n \n     def __init__(self, *middlewares):\n         self.middlewares = middlewares\n-        self.methods = defaultdict(deque)\n+        self.methods: dict[str, deque[Callable]] = defaultdict(deque)",
      "comment": "I'm surprised this syntax works (`dict[str, ...]`), it is supposed to be Python 3.9+ feature, or Python 3.7+ with `from future import __annotations__` import",
      "comment_id": 608615975,
      "user": "kmike",
      "created_at": "2021-04-07T12:41:42Z",
      "url": "https://github.com/scrapy/scrapy/pull/5077#discussion_r608615975"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 5077,
      "file_path": "scrapy/core/downloader/middleware.py",
      "line": 36,
      "side": "RIGHT",
      "diff_hunk": "@@ -29,9 +33,9 @@ def _add_middleware(self, mw):\n         if hasattr(mw, 'process_exception'):\n             self.methods['process_exception'].appendleft(mw.process_exception)\n \n-    def download(self, download_func, request, spider):\n+    def download(self, download_func: Callable, request: Request, spider: Spider):",
      "comment": "Actually, I'm not sure how much info should I add when some of it can be inferred from code.",
      "comment_id": 608616572,
      "user": "wRAR",
      "created_at": "2021-04-07T12:42:30Z",
      "url": "https://github.com/scrapy/scrapy/pull/5077#discussion_r608616572"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 5077,
      "file_path": "scrapy/core/scraper.py",
      "line": 6,
      "side": "RIGHT",
      "diff_hunk": "@@ -3,12 +3,14 @@\n \n import logging\n from collections import deque\n+from collections.abc import Iterable",
      "comment": "Just a habit, and it doesn't seem to make a difference unless `Iterable[foo]` is needed but I can change this to use `typing`.",
      "comment_id": 608637718,
      "user": "wRAR",
      "created_at": "2021-04-07T13:10:02Z",
      "url": "https://github.com/scrapy/scrapy/pull/5077#discussion_r608637718"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 5077,
      "file_path": "scrapy/core/downloader/middleware.py",
      "line": 36,
      "side": "RIGHT",
      "diff_hunk": "@@ -29,9 +33,9 @@ def _add_middleware(self, mw):\n         if hasattr(mw, 'process_exception'):\n             self.methods['process_exception'].appendleft(mw.process_exception)\n \n-    def download(self, download_func, request, spider):\n+    def download(self, download_func: Callable, request: Request, spider: Spider):",
      "comment": "I think we should be annotating public interfaces even if the data types can be inferred, so that Scrapy users can check their code against types provided by Scrapy.\r\n\r\nFor internal code it is a judgment call if an annotation is needed or not. I'd say there are 2 reasons to annotate, and 2 reasons not to annotate: \r\n\r\n* (+) if it makes code more readable / easy to understand. For example, sometimes type can be inferred from the code, but you don't want to spend your time doing this, it is faster to read the definition.\r\n* (+) if it is likely to prevent errors. For example, you may have some assumptions on what the function should be returning, and if you add e.g. output type information, the assumption would be checked by mypy, including cases when refactoring happens.\r\n* (-) type-annotated code is more verbose, so there is an argument not to overuse it\r\n* (-) it requires effort to add type annotations, which can be spent elsewhere; if the code piece is not complex and not public, or maybe not toched much, the effort might not be justified",
      "comment_id": 608782740,
      "user": "kmike",
      "created_at": "2021-04-07T15:52:43Z",
      "url": "https://github.com/scrapy/scrapy/pull/5077#discussion_r608782740"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 5077,
      "file_path": "scrapy/middleware.py",
      "line": 20,
      "side": "RIGHT",
      "diff_hunk": "@@ -16,7 +17,7 @@ class MiddlewareManager:\n \n     def __init__(self, *middlewares):\n         self.middlewares = middlewares\n-        self.methods = defaultdict(deque)\n+        self.methods: dict[str, deque[Callable]] = defaultdict(deque)",
      "comment": "That's really strange! Python 3.6:\r\n\r\n```\r\n>>> def foo(x: dict[str, str]): pass\r\n...\r\nTraceback (most recent call last):\r\n  File \"<stdin>\", line 1, in <module>\r\nTypeError: 'type' object is not subscriptable\r\n```",
      "comment_id": 608783817,
      "user": "kmike",
      "created_at": "2021-04-07T15:53:59Z",
      "url": "https://github.com/scrapy/scrapy/pull/5077#discussion_r608783817"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 5077,
      "file_path": "scrapy/middleware.py",
      "line": 20,
      "side": "RIGHT",
      "diff_hunk": "@@ -16,7 +17,7 @@ class MiddlewareManager:\n \n     def __init__(self, *middlewares):\n         self.middlewares = middlewares\n-        self.methods = defaultdict(deque)\n+        self.methods: dict[str, deque[Callable]] = defaultdict(deque)",
      "comment": "Nice, new PyCharm flags my code and proposes a replacement from `dict` to `typing.Dict`, is this the correct fix?",
      "comment_id": 610785575,
      "user": "wRAR",
      "created_at": "2021-04-09T17:11:03Z",
      "url": "https://github.com/scrapy/scrapy/pull/5077#discussion_r610785575"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 5077,
      "file_path": "scrapy/core/spidermw.py",
      "line": 7,
      "side": "RIGHT",
      "diff_hunk": "@@ -3,10 +3,10 @@\n \n See documentation in docs/topics/spider-middleware.rst\n \"\"\"\n-from collections.abc import Iterable\n from itertools import islice\n-from typing import Callable, Union, Any\n+from typing import Callable, Union, Any, Generator, Iterable",
      "comment": "```suggestion\r\nfrom typing import Any, Callable, Generator, Iterable, Union\r\n```",
      "comment_id": 612571697,
      "user": "Gallaecio",
      "created_at": "2021-04-13T15:50:19Z",
      "url": "https://github.com/scrapy/scrapy/pull/5077#discussion_r612571697"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 5077,
      "file_path": "scrapy/middleware.py",
      "line": 4,
      "side": "RIGHT",
      "diff_hunk": "@@ -1,9 +1,13 @@\n import logging\n import pprint\n from collections import defaultdict, deque\n-from typing import Callable\n+from typing import Callable, Dict, Deque",
      "comment": "```suggestion\r\nfrom typing import Callable, Deque, Dict\r\n```",
      "comment_id": 612573015,
      "user": "Gallaecio",
      "created_at": "2021-04-13T15:52:02Z",
      "url": "https://github.com/scrapy/scrapy/pull/5077#discussion_r612573015"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 5077,
      "file_path": "scrapy/utils/defer.py",
      "line": 8,
      "side": "RIGHT",
      "diff_hunk": "@@ -5,7 +5,7 @@\n import inspect\n from collections.abc import Coroutine\n from functools import wraps\n-from typing import Callable, Iterable, Any\n+from typing import Callable, Iterable, Any, Generator",
      "comment": "```suggestion\r\nfrom typing import Any, Callable, Generator, Iterable\r\n```",
      "comment_id": 612573682,
      "user": "Gallaecio",
      "created_at": "2021-04-13T15:52:49Z",
      "url": "https://github.com/scrapy/scrapy/pull/5077#discussion_r612573682"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 5077,
      "file_path": "scrapy/middleware.py",
      "line": 6,
      "side": "RIGHT",
      "diff_hunk": "@@ -1,9 +1,13 @@\n import logging\n import pprint\n from collections import defaultdict, deque\n-from typing import Callable\n+from typing import Callable, Dict, Deque\n \n+from twisted.internet import defer",
      "comment": "What about `from twisted.internet.defer import Deferred` as you did in the first file? I would rather use `Deferred` than `defer.Deferred`. I would even add such an import to `scrapy.utils.defer`, which was already importing `defer`.",
      "comment_id": 612576229,
      "user": "Gallaecio",
      "created_at": "2021-04-13T15:56:01Z",
      "url": "https://github.com/scrapy/scrapy/pull/5077#discussion_r612576229"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 5077,
      "file_path": "scrapy/middleware.py",
      "line": 6,
      "side": "RIGHT",
      "diff_hunk": "@@ -1,9 +1,13 @@\n import logging\n import pprint\n from collections import defaultdict, deque\n-from typing import Callable\n+from typing import Callable, Dict, Deque\n \n+from twisted.internet import defer",
      "comment": "`scrapy.utils.defer` is harder as it uses `succeed` and `fail` and I don't like aliases or importing these names as is.",
      "comment_id": 612587040,
      "user": "wRAR",
      "created_at": "2021-04-13T16:09:04Z",
      "url": "https://github.com/scrapy/scrapy/pull/5077#discussion_r612587040"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 5077,
      "file_path": "scrapy/middleware.py",
      "line": 6,
      "side": "RIGHT",
      "diff_hunk": "@@ -1,9 +1,13 @@\n import logging\n import pprint\n from collections import defaultdict, deque\n-from typing import Callable\n+from typing import Callable, Dict, Deque\n \n+from twisted.internet import defer",
      "comment": "Makes sense to me, but still it may be best to have both imports than to use `defer.Deferred` everywhere.",
      "comment_id": 612642901,
      "user": "Gallaecio",
      "created_at": "2021-04-13T17:26:33Z",
      "url": "https://github.com/scrapy/scrapy/pull/5077#discussion_r612642901"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 5094,
      "file_path": "tests/test_engine.py",
      "line": 105,
      "side": "RIGHT",
      "diff_hunk": "@@ -97,14 +97,12 @@ class AttrsItemsSpider(TestSpider):\n else:\n     TestDataClass = make_dataclass(\"TestDataClass\", [(\"name\", str), (\"url\", str), (\"price\", int)])\n \n-    class DataClassItemsSpider(DictItemsSpider):\n+    class _dataclass_spider(DictItemsSpider):\n         def parse_item(self, response):\n             item = super().parse_item(response)\n-            return TestDataClass(\n-                name=item.get('name'),\n-                url=item.get('url'),\n-                price=item.get('price'),\n-            )\n+            return TestDataClass(**item)\n+\n+    DataClassItemsSpider = _dataclass_spider",
      "comment": "This is to prevent mypy from complaining about DataClassItemsSpider alredy being defined",
      "comment_id": 610749057,
      "user": "elacuesta",
      "created_at": "2021-04-09T16:10:25Z",
      "url": "https://github.com/scrapy/scrapy/pull/5094#discussion_r610749057"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 5094,
      "file_path": "tests/test_engine.py",
      "line": 105,
      "side": "RIGHT",
      "diff_hunk": "@@ -97,14 +97,12 @@ class AttrsItemsSpider(TestSpider):\n else:\n     TestDataClass = make_dataclass(\"TestDataClass\", [(\"name\", str), (\"url\", str), (\"price\", int)])\n \n-    class DataClassItemsSpider(DictItemsSpider):\n+    class _dataclass_spider(DictItemsSpider):\n         def parse_item(self, response):\n             item = super().parse_item(response)\n-            return TestDataClass(\n-                name=item.get('name'),\n-                url=item.get('url'),\n-                price=item.get('price'),\n-            )\n+            return TestDataClass(**item)\n+\n+    DataClassItemsSpider = _dataclass_spider",
      "comment": "I wonder if there\u2019s a more readable way to handle this.\r\n\r\nAfter reading https://github.com/python/mypy/issues/1191#issuecomment-780471195 , I wonder if it would not be better to annotate the first definition of `DataClassItemsSpider` (`DataClassItemsSpider = None`) as an optional subclass of `DictItemsSpider`, assuming that is enough to silence mypy about this.\r\n\r\nOtherwise, I think it may be better to silence mypy with a comment (assuming that\u2019s possible) rather than defining a class with one name and later renaming it. The last thing I would think if I find this code in the future is that this has been done for mypy, I would instead wonder how the code would work differently if the class was defined with its final name directly.",
      "comment_id": 611579133,
      "user": "Gallaecio",
      "created_at": "2021-04-12T12:21:18Z",
      "url": "https://github.com/scrapy/scrapy/pull/5094#discussion_r611579133"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 5094,
      "file_path": "tests/test_engine.py",
      "line": 105,
      "side": "RIGHT",
      "diff_hunk": "@@ -97,14 +97,12 @@ class AttrsItemsSpider(TestSpider):\n else:\n     TestDataClass = make_dataclass(\"TestDataClass\", [(\"name\", str), (\"url\", str), (\"price\", int)])\n \n-    class DataClassItemsSpider(DictItemsSpider):\n+    class _dataclass_spider(DictItemsSpider):\n         def parse_item(self, response):\n             item = super().parse_item(response)\n-            return TestDataClass(\n-                name=item.get('name'),\n-                url=item.get('url'),\n-                price=item.get('price'),\n-            )\n+            return TestDataClass(**item)\n+\n+    DataClassItemsSpider = _dataclass_spider",
      "comment": "Right, without context it's a little hard to know why this is done this way. Since this is a test, we can probably do well with just `# type: ignore` \ud83d\udc4d ",
      "comment_id": 611623922,
      "user": "elacuesta",
      "created_at": "2021-04-12T13:23:09Z",
      "url": "https://github.com/scrapy/scrapy/pull/5094#discussion_r611623922"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 4902,
      "file_path": "scrapy/downloadermiddlewares/retry.py",
      "line": 37,
      "side": "RIGHT",
      "diff_hunk": "@@ -31,6 +31,105 @@\n logger = logging.getLogger(__name__)\n \n \n+def get_retry_request(\n+    request,\n+    *,\n+    reason,",
      "comment": "what about adding a default reason? (i.e.: `reason='retry'` or `'default_retry'` or something similar...) in that way you don't need to give a name if you don't need to differentiate them.",
      "comment_id": 530972930,
      "user": "noviluni",
      "created_at": "2020-11-26T11:46:19Z",
      "url": "https://github.com/scrapy/scrapy/pull/4902#discussion_r530972930"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 4902,
      "file_path": "scrapy/downloadermiddlewares/retry.py",
      "line": 93,
      "side": "RIGHT",
      "diff_hunk": "@@ -31,6 +31,105 @@\n logger = logging.getLogger(__name__)\n \n \n+def get_retry_request(\n+    request,\n+    *,\n+    reason,\n+    spider,\n+    max_retry_times=None,\n+    priority_adjust=None,\n+):\n+    settings = spider.crawler.settings\n+    stats = spider.crawler.stats\n+    retry_times = request.meta.get('retry_times', 0) + 1\n+    request_max_retry_times = request.meta.get(\n+        'max_retry_times',\n+        max_retry_times,\n+    )\n+    if request_max_retry_times is None:\n+        request_max_retry_times = settings.getint('RETRY_TIMES')\n+    if retry_times <= request_max_retry_times:\n+        logger.debug(\n+            \"Retrying %(request)s (failed %(retry_times)d times): %(reason)s\",\n+            {'request': request, 'retry_times': retry_times, 'reason': reason},\n+            extra={'spider': spider}\n+        )\n+        new_request = request.copy()\n+        new_request.meta['retry_times'] = retry_times\n+        new_request.dont_filter = True\n+        if priority_adjust is None:\n+            priority_adjust = settings.getint('RETRY_PRIORITY_ADJUST')\n+        new_request.priority = request.priority + priority_adjust\n+\n+        if isinstance(reason, Exception):\n+            reason = global_object_name(reason.__class__)\n+\n+        stats.inc_value('retry/count')\n+        stats.inc_value(f'retry/reason_count/{reason}')\n+        return new_request\n+    else:\n+        stats.inc_value('retry/max_reached')\n+        logger.error(\"Gave up retrying %(request)s (failed %(retry_times)d times): %(reason)s\",\n+                        {'request': request, 'retry_times': retry_times, 'reason': reason},\n+                        extra={'spider': spider})\n+        return None\n+\n+\n+def retry_request(\n+    request,\n+    *,\n+    reason,\n+    spider,\n+    max_retry_times=None,\n+    priority_adjust=None,\n+):\n+    new_request = get_retry_request(\n+        request,\n+        reason=reason,\n+        spider=spider,\n+        max_retry_times=max_retry_times,\n+        priority_adjust=priority_adjust,\n+    )\n+    if new_request:",
      "comment": "not sure if this is necessary, as we can just do this by yielding the result of `get_retry_request` (first approach in the description). I would prefer to have a good example on the docs over providing this function.",
      "comment_id": 530979590,
      "user": "noviluni",
      "created_at": "2020-11-26T11:58:26Z",
      "url": "https://github.com/scrapy/scrapy/pull/4902#discussion_r530979590"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 4902,
      "file_path": "scrapy/downloadermiddlewares/retry.py",
      "line": 75,
      "side": "RIGHT",
      "diff_hunk": "@@ -31,6 +31,105 @@\n logger = logging.getLogger(__name__)\n \n \n+def get_retry_request(\n+    request,\n+    *,\n+    reason,\n+    spider,\n+    max_retry_times=None,\n+    priority_adjust=None,\n+):\n+    settings = spider.crawler.settings\n+    stats = spider.crawler.stats\n+    retry_times = request.meta.get('retry_times', 0) + 1\n+    request_max_retry_times = request.meta.get(\n+        'max_retry_times',\n+        max_retry_times,\n+    )\n+    if request_max_retry_times is None:\n+        request_max_retry_times = settings.getint('RETRY_TIMES')\n+    if retry_times <= request_max_retry_times:\n+        logger.debug(\n+            \"Retrying %(request)s (failed %(retry_times)d times): %(reason)s\",\n+            {'request': request, 'retry_times': retry_times, 'reason': reason},\n+            extra={'spider': spider}\n+        )\n+        new_request = request.copy()\n+        new_request.meta['retry_times'] = retry_times\n+        new_request.dont_filter = True\n+        if priority_adjust is None:\n+            priority_adjust = settings.getint('RETRY_PRIORITY_ADJUST')\n+        new_request.priority = request.priority + priority_adjust\n+\n+        if isinstance(reason, Exception):\n+            reason = global_object_name(reason.__class__)\n+\n+        stats.inc_value('retry/count')\n+        stats.inc_value(f'retry/reason_count/{reason}')\n+        return new_request\n+    else:\n+        stats.inc_value('retry/max_reached')\n+        logger.error(\"Gave up retrying %(request)s (failed %(retry_times)d times): %(reason)s\",\n+                        {'request': request, 'retry_times': retry_times, 'reason': reason},\n+                        extra={'spider': spider})\n+        return None",
      "comment": "I did it [on purpose](https://stackoverflow.com/a/15300671/939364), for readability, to make it clear that the calling code expects a return value.",
      "comment_id": 532615820,
      "user": "Gallaecio",
      "created_at": "2020-11-30T13:59:13Z",
      "url": "https://github.com/scrapy/scrapy/pull/4902#discussion_r532615820"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 4902,
      "file_path": "scrapy/downloadermiddlewares/retry.py",
      "line": 165,
      "side": "RIGHT",
      "diff_hunk": "@@ -67,31 +162,12 @@ def process_exception(self, request, exception, spider):\n             return self._retry(request, exception, spider)\n \n     def _retry(self, request, reason, spider):\n-        retries = request.meta.get('retry_times', 0) + 1\n-\n-        retry_times = self.max_retry_times\n-\n-        if 'max_retry_times' in request.meta:\n-            retry_times = request.meta['max_retry_times']\n-\n-        stats = spider.crawler.stats\n-        if retries <= retry_times:\n-            logger.debug(\"Retrying %(request)s (failed %(retries)d times): %(reason)s\",\n-                         {'request': request, 'retries': retries, 'reason': reason},\n-                         extra={'spider': spider})\n-            retryreq = request.copy()\n-            retryreq.meta['retry_times'] = retries\n-            retryreq.dont_filter = True\n-            retryreq.priority = request.priority + self.priority_adjust\n-\n-            if isinstance(reason, Exception):\n-                reason = global_object_name(reason.__class__)\n-\n-            stats.inc_value('retry/count')\n-            stats.inc_value(f'retry/reason_count/{reason}')\n-            return retryreq\n-        else:\n-            stats.inc_value('retry/max_reached')\n-            logger.error(\"Gave up retrying %(request)s (failed %(retries)d times): %(reason)s\",\n-                         {'request': request, 'retries': retries, 'reason': reason},\n-                         extra={'spider': spider})\n+        max_retry_times = request.meta.get('max_retry_times', self.max_retry_times)",
      "comment": "This is a weird change in the API.\r\nFrom the middleware point of view, we allow `max_retry_times` in `meta`.\r\nBut from `parse` in the spider, we allow it in that function.\r\nSo, who is responsible from setting the required amount of retries, the function making the request or the function handling the response?\r\n ",
      "comment_id": 595412239,
      "user": "ejulio",
      "created_at": "2021-03-16T17:55:21Z",
      "url": "https://github.com/scrapy/scrapy/pull/4902#discussion_r595412239"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 4902,
      "file_path": "scrapy/downloadermiddlewares/retry.py",
      "line": 63,
      "side": "RIGHT",
      "diff_hunk": "@@ -23,12 +24,106 @@\n )\n from twisted.web.client import ResponseFailed\n \n-from scrapy.exceptions import NotConfigured\n-from scrapy.utils.response import response_status_message\n from scrapy.core.downloader.handlers.http11 import TunnelError\n+from scrapy.exceptions import NotConfigured\n+from scrapy.http.request import Request\n+from scrapy.spiders import Spider\n from scrapy.utils.python import global_object_name\n+from scrapy.utils.response import response_status_message\n+\n \n-logger = logging.getLogger(__name__)\n+retry_logger = getLogger(__name__)\n+\n+\n+def get_retry_request(\n+    request: Request,\n+    *,\n+    spider: Spider,\n+    reason: Union[str, Exception] = 'unspecified',\n+    max_retry_times: Optional[int] = None,\n+    priority_adjust: Union[int, float, None] = None,\n+    logger: Logger = retry_logger,\n+    stats_base_key: str = 'retry',\n+):\n+    \"\"\"\n+    Returns a new :class:`~scrapy.Request` object to retry the specified\n+    request, or ``None`` if retries of the specified request have been\n+    exhausted.\n+\n+    For example, in a :class:`~scrapy.Spider` callback, you could use it as\n+    follows::\n+\n+        def parse(self, response):\n+            if not response.text:\n+                new_request = get_retry_request(\n+                    response.request,\n+                    spider=self,\n+                    reason='empty',\n+                )\n+                if new_request:",
      "comment": "Considering that we can `yield None`, maybe you don't need the `if`",
      "comment_id": 595418262,
      "user": "ejulio",
      "created_at": "2021-03-16T18:03:07Z",
      "url": "https://github.com/scrapy/scrapy/pull/4902#discussion_r595418262"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 4902,
      "file_path": "scrapy/downloadermiddlewares/retry.py",
      "line": 165,
      "side": "RIGHT",
      "diff_hunk": "@@ -67,31 +162,12 @@ def process_exception(self, request, exception, spider):\n             return self._retry(request, exception, spider)\n \n     def _retry(self, request, reason, spider):\n-        retries = request.meta.get('retry_times', 0) + 1\n-\n-        retry_times = self.max_retry_times\n-\n-        if 'max_retry_times' in request.meta:\n-            retry_times = request.meta['max_retry_times']\n-\n-        stats = spider.crawler.stats\n-        if retries <= retry_times:\n-            logger.debug(\"Retrying %(request)s (failed %(retries)d times): %(reason)s\",\n-                         {'request': request, 'retries': retries, 'reason': reason},\n-                         extra={'spider': spider})\n-            retryreq = request.copy()\n-            retryreq.meta['retry_times'] = retries\n-            retryreq.dont_filter = True\n-            retryreq.priority = request.priority + self.priority_adjust\n-\n-            if isinstance(reason, Exception):\n-                reason = global_object_name(reason.__class__)\n-\n-            stats.inc_value('retry/count')\n-            stats.inc_value(f'retry/reason_count/{reason}')\n-            return retryreq\n-        else:\n-            stats.inc_value('retry/max_reached')\n-            logger.error(\"Gave up retrying %(request)s (failed %(retries)d times): %(reason)s\",\n-                         {'request': request, 'retries': retries, 'reason': reason},\n-                         extra={'spider': spider})\n+        max_retry_times = request.meta.get('max_retry_times', self.max_retry_times)",
      "comment": "The algorithm of the function is: use meta, else settings, else function parameter. So I first considered to just not pass anything from the middleware about this, and let the function handle it, as the function has access to both meta and settings, and at first sight it has the same algorithm as the middleware.\r\n\r\nHowever, then I thought of backward compatibility and inheritance. `self.max_retry_times` is not a private attribute of the middleware, it\u2019s public. So there may be subclasses out there that override this attribute, for example setting a different hardcoded value or reading the value from a different source (a different setting name, multiple settings, a configuration file, etc.). In order to keep backward compatibility, I wrote this logic here and pass the value explicitly to the function.",
      "comment_id": 595836446,
      "user": "Gallaecio",
      "created_at": "2021-03-17T09:15:23Z",
      "url": "https://github.com/scrapy/scrapy/pull/4902#discussion_r595836446"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 4902,
      "file_path": "scrapy/downloadermiddlewares/retry.py",
      "line": 63,
      "side": "RIGHT",
      "diff_hunk": "@@ -23,12 +24,106 @@\n )\n from twisted.web.client import ResponseFailed\n \n-from scrapy.exceptions import NotConfigured\n-from scrapy.utils.response import response_status_message\n from scrapy.core.downloader.handlers.http11 import TunnelError\n+from scrapy.exceptions import NotConfigured\n+from scrapy.http.request import Request\n+from scrapy.spiders import Spider\n from scrapy.utils.python import global_object_name\n+from scrapy.utils.response import response_status_message\n+\n \n-logger = logging.getLogger(__name__)\n+retry_logger = getLogger(__name__)\n+\n+\n+def get_retry_request(\n+    request: Request,\n+    *,\n+    spider: Spider,\n+    reason: Union[str, Exception] = 'unspecified',\n+    max_retry_times: Optional[int] = None,\n+    priority_adjust: Union[int, float, None] = None,\n+    logger: Logger = retry_logger,\n+    stats_base_key: str = 'retry',\n+):\n+    \"\"\"\n+    Returns a new :class:`~scrapy.Request` object to retry the specified\n+    request, or ``None`` if retries of the specified request have been\n+    exhausted.\n+\n+    For example, in a :class:`~scrapy.Spider` callback, you could use it as\n+    follows::\n+\n+        def parse(self, response):\n+            if not response.text:\n+                new_request = get_retry_request(\n+                    response.request,\n+                    spider=self,\n+                    reason='empty',\n+                )\n+                if new_request:",
      "comment": "You definitely could write it without the `if`. My main concern here is readability. What about doing what you suggest and renaming the variable as `new_request_or_none`?",
      "comment_id": 595841532,
      "user": "Gallaecio",
      "created_at": "2021-03-17T09:21:59Z",
      "url": "https://github.com/scrapy/scrapy/pull/4902#discussion_r595841532"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 4902,
      "file_path": "scrapy/downloadermiddlewares/retry.py",
      "line": 44,
      "side": "RIGHT",
      "diff_hunk": "@@ -23,12 +24,104 @@\n )\n from twisted.web.client import ResponseFailed\n \n-from scrapy.exceptions import NotConfigured\n-from scrapy.utils.response import response_status_message\n from scrapy.core.downloader.handlers.http11 import TunnelError\n+from scrapy.exceptions import NotConfigured\n+from scrapy.http.request import Request\n+from scrapy.spiders import Spider\n from scrapy.utils.python import global_object_name\n+from scrapy.utils.response import response_status_message\n+\n \n-logger = logging.getLogger(__name__)\n+retry_logger = getLogger(__name__)\n+\n+\n+def get_retry_request(\n+    request: Request,\n+    *,\n+    spider: Spider,\n+    reason: Union[str, Exception] = 'unspecified',\n+    max_retry_times: Optional[int] = None,\n+    priority_adjust: Union[int, float, None] = None,",
      "comment": "`Request.priority` [can only be int](https://github.com/scrapy/scrapy/blob/2.4.1/scrapy/http/request/__init__.py#L27-L28), `new_request.priority = request.priority + priority_adjust` would make it a float if `priority_adjust` were a float. Updated at d458ccff3b2d6df94df1aa86eeb7d2505d62f2d6.\r\n\r\n/cc @wRAR ",
      "comment_id": 605752120,
      "user": "elacuesta",
      "created_at": "2021-04-01T15:32:59Z",
      "url": "https://github.com/scrapy/scrapy/pull/4902#discussion_r605752120"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 4769,
      "file_path": "scrapy/core/http2/stream.py",
      "line": 435,
      "side": "RIGHT",
      "diff_hunk": "@@ -431,7 +431,8 @@ def close(\n             errors.insert(0, InactiveStreamClosed(self._request))\n             self._deferred_response.errback(ResponseFailed(errors))\n \n-        elif reason is StreamCloseReason.INVALID_HOSTNAME:\n+        else:\n+            assert reason is StreamCloseReason.INVALID_HOSTNAME",
      "comment": "That was triggered by [this comment by me](https://github.com/scrapy/scrapy/pull/4054#discussion_r351514071) (emphasis added):\r\n\r\n> We should not use assert statements in production code, outside tests, **where we know the assertion may fail**.\r\n\r\nIn this case, no input could ever make that `assert` raise an `AssertionError`. The code is written so that this condition will always be `True`. If that ever changes, the cause will be a bug in the code, not unexpected input.\r\n\r\n*But*, if you prefer, we could just replace it with a comment besides the `else`. However, if we ever extend the possible values of `StreamCloseReason` and forget to update this part of the code accordingly, an `assert` could cause tests to fail; a comment could cause us to forge to update this code.",
      "comment_id": 581919550,
      "user": "Gallaecio",
      "created_at": "2021-02-24T12:31:13Z",
      "url": "https://github.com/scrapy/scrapy/pull/4769#discussion_r581919550"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 4769,
      "file_path": "scrapy/core/http2/stream.py",
      "line": 435,
      "side": "RIGHT",
      "diff_hunk": "@@ -431,7 +431,8 @@ def close(\n             errors.insert(0, InactiveStreamClosed(self._request))\n             self._deferred_response.errback(ResponseFailed(errors))\n \n-        elif reason is StreamCloseReason.INVALID_HOSTNAME:\n+        else:\n+            assert reason is StreamCloseReason.INVALID_HOSTNAME",
      "comment": "Fair enough, thanks for the explanation :slightly_smiling_face: ",
      "comment_id": 582158624,
      "user": "elacuesta",
      "created_at": "2021-02-24T17:31:40Z",
      "url": "https://github.com/scrapy/scrapy/pull/4769#discussion_r582158624"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 4895,
      "file_path": "scrapy/http/cookies.py",
      "line": 11,
      "side": "RIGHT",
      "diff_hunk": "@@ -1,10 +1,14 @@\n+import re\n import time\n-from http.cookiejar import CookieJar as _CookieJar, DefaultCookiePolicy, IPV4_RE\n+from http.cookiejar import CookieJar as _CookieJar, DefaultCookiePolicy\n \n from scrapy.utils.httpobj import urlparse_cached\n from scrapy.utils.python import to_unicode\n \n \n+IPV4_RE = re.compile(r\"\\.\\d+$\", re.ASCII)",
      "comment": "Taken from https://github.com/python/cpython/blob/3.9/Lib/http/cookiejar.py#L527\r\n\r\nThe `mypy` check fails with `scrapy/http/cookies.py:2: error: Module 'http.cookiejar' has no attribute 'IPV4_RE'`\r\n\r\n`IPV4_RE` is neither in [`__all__`](https://github.com/python/cpython/blob/3.9/Lib/http/cookiejar.py#L28-L29) nor in the [docs](https://docs.python.org/3/library/http.cookiejar.html).",
      "comment_id": 526900233,
      "user": "elacuesta",
      "created_at": "2020-11-19T13:49:10Z",
      "url": "https://github.com/scrapy/scrapy/pull/4895#discussion_r526900233"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 4895,
      "file_path": "scrapy/http/cookies.py",
      "line": 11,
      "side": "RIGHT",
      "diff_hunk": "@@ -1,10 +1,14 @@\n+import re\n import time\n-from http.cookiejar import CookieJar as _CookieJar, DefaultCookiePolicy, IPV4_RE\n+from http.cookiejar import CookieJar as _CookieJar, DefaultCookiePolicy\n \n from scrapy.utils.httpobj import urlparse_cached\n from scrapy.utils.python import to_unicode\n \n \n+IPV4_RE = re.compile(r\"\\.\\d+$\", re.ASCII)",
      "comment": "Would you mind adding something simiilar as a code comment?",
      "comment_id": 527122988,
      "user": "kmike",
      "created_at": "2020-11-19T18:55:01Z",
      "url": "https://github.com/scrapy/scrapy/pull/4895#discussion_r527122988"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 4895,
      "file_path": "scrapy/__init__.py",
      "line": 25,
      "side": "RIGHT",
      "diff_hunk": "@@ -22,7 +22,7 @@\n \n \n # Scrapy and Twisted versions\n-__version__ = pkgutil.get_data(__package__, 'VERSION').decode('ascii').strip()\n+__version__ = (pkgutil.get_data(__package__, \"VERSION\") or b\"\").decode(\"ascii\").strip()",
      "comment": ":lipstick: Why the change of quotes? I see the line below also uses single quotes.",
      "comment_id": 529044483,
      "user": "Gallaecio",
      "created_at": "2020-11-23T22:45:11Z",
      "url": "https://github.com/scrapy/scrapy/pull/4895#discussion_r529044483"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 4895,
      "file_path": "scrapy/utils/httpobj.py",
      "line": 7,
      "side": "RIGHT",
      "diff_hunk": "@@ -1,10 +1,10 @@\n \"\"\"Helper functions for scrapy.http objects (Request, Response)\"\"\"\n \n-import weakref\n from urllib.parse import urlparse\n+from weakref import WeakKeyDictionary\n \n \n-_urlparse_cache = weakref.WeakKeyDictionary()\n+_urlparse_cache: WeakKeyDictionary = WeakKeyDictionary()",
      "comment": "Would it be possible to type annotate keys/values here, and for other caches (`_fingerprint_cache`, etc.)? It is a chance to make type annotations a bit more useful for reading (and probably using) the code; otherwise I suspect we'll never get to this - mypy error is silenced, all is good :)",
      "comment_id": 529919791,
      "user": "kmike",
      "created_at": "2020-11-24T22:07:17Z",
      "url": "https://github.com/scrapy/scrapy/pull/4895#discussion_r529919791"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 4895,
      "file_path": "scrapy/utils/httpobj.py",
      "line": 7,
      "side": "RIGHT",
      "diff_hunk": "@@ -1,10 +1,10 @@\n \"\"\"Helper functions for scrapy.http objects (Request, Response)\"\"\"\n \n-import weakref\n from urllib.parse import urlparse\n+from weakref import WeakKeyDictionary\n \n \n-_urlparse_cache = weakref.WeakKeyDictionary()\n+_urlparse_cache: WeakKeyDictionary = WeakKeyDictionary()",
      "comment": "I looked into [`typing`](https://docs.python.org/3/library/typing.html) and couldn't find it, so I decided to only annotate the \"outer\" type. \r\nAccording to [this comment](https://bugs.python.org/issue38756#msg356318), it should be possible to annotate it as a string (`from __future__ import annotations` doesn't work in py36).\r\nI'll update this shortly.",
      "comment_id": 530040191,
      "user": "elacuesta",
      "created_at": "2020-11-25T00:58:07Z",
      "url": "https://github.com/scrapy/scrapy/pull/4895#discussion_r530040191"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 4895,
      "file_path": "scrapy/commands/__init__.py",
      "line": 20,
      "side": "RIGHT",
      "diff_hunk": "@@ -15,7 +17,7 @@ class ScrapyCommand:\n     crawler_process = None\n \n     # default settings to be used for this command instead of global defaults\n-    default_settings = {}\n+    default_settings: Dict[str, Any] = {}",
      "comment": "Should keys be str? We support callables as keys in settings now.",
      "comment_id": 532245846,
      "user": "kmike",
      "created_at": "2020-11-29T18:14:24Z",
      "url": "https://github.com/scrapy/scrapy/pull/4895#discussion_r532245846"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 4895,
      "file_path": "scrapy/utils/response.py",
      "line": 70,
      "side": "RIGHT",
      "diff_hunk": "@@ -60,7 +67,7 @@ def response_httprepr(response):\n     return b\"\".join(values)\n \n \n-def open_in_browser(response, _openfunc=webbrowser.open):\n+def open_in_browser(response: Response, _openfunc: Callable[[str], Any] = webbrowser.open) -> Any:",
      "comment": "Nitpick: return type is not Any, but whatever _openfunc returns. TypeVar would be more precise here.",
      "comment_id": 532247492,
      "user": "kmike",
      "created_at": "2020-11-29T18:28:48Z",
      "url": "https://github.com/scrapy/scrapy/pull/4895#discussion_r532247492"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 4895,
      "file_path": "scrapy/commands/__init__.py",
      "line": 20,
      "side": "RIGHT",
      "diff_hunk": "@@ -15,7 +17,7 @@ class ScrapyCommand:\n     crawler_process = None\n \n     # default settings to be used for this command instead of global defaults\n-    default_settings = {}\n+    default_settings: Dict[str, Any] = {}",
      "comment": "Do you mean after #3873? Those are values, keys can be other objects but only as sub-keys within other settings (`ITEM_PIPELINES`, `SPIDER_MIDDLEWARES`, etc)",
      "comment_id": 534105900,
      "user": "elacuesta",
      "created_at": "2020-12-02T11:47:31Z",
      "url": "https://github.com/scrapy/scrapy/pull/4895#discussion_r534105900"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 4895,
      "file_path": "scrapy/utils/response.py",
      "line": 70,
      "side": "RIGHT",
      "diff_hunk": "@@ -60,7 +67,7 @@ def response_httprepr(response):\n     return b\"\".join(values)\n \n \n-def open_in_browser(response, _openfunc=webbrowser.open):\n+def open_in_browser(response: Response, _openfunc: Callable[[str], Any] = webbrowser.open) -> Any:",
      "comment": "Makes sense, but I think I need a bit of assistance. If I do:\r\n```python\r\nOpenInBrowserTypeVar = TypeVar(\"OpenInBrowserTypeVar\")\r\n\r\ndef open_in_browser(\r\n    response: Union[HtmlResponse, TextResponse],\r\n    _openfunc: Callable[[str], OpenInBrowserTypeVar] = webbrowser.open,\r\n) -> OpenInBrowserTypeVar:\r\n```\r\nI get\r\n```\r\nerror: Incompatible default for argument \"_openfunc\" (default has type \"Callable[[str, int, bool], bool]\", argument has type \"Callable[[str], OpenInBrowserTypeVar]\")\r\n```\r\nbecause [`webbrowser.open`](https://docs.python.org/3/library/webbrowser.html) takes `url, new=0, autoraise=True`. However, the function is called with `_openfunc(f\"file://{fname}\")`, passing only a `str`. Of course I could do\r\n```\r\n_openfunc: Callable[[str], OpenInBrowserTypeVar] = webbrowser.open,  # type: ignore\r\n```\r\nbut I'd like to avoid that.\r\n\r\nI haven't found a solution so far, my next step would be to ask in SO, but maybe you know a way to solve it.",
      "comment_id": 534125019,
      "user": "elacuesta",
      "created_at": "2020-12-02T12:21:20Z",
      "url": "https://github.com/scrapy/scrapy/pull/4895#discussion_r534125019"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 4799,
      "file_path": "scrapy/downloadermiddlewares/httpcompression.py",
      "line": 28,
      "side": "RIGHT",
      "diff_hunk": "@@ -18,11 +18,14 @@\n class HttpCompressionMiddleware:\n     \"\"\"This middleware allows compressed (gzip, deflate) traffic to be\n     sent/received from web sites\"\"\"\n+    def __init__(self, stats=None):\n+        self.stats = stats\n+\n     @classmethod\n     def from_crawler(cls, crawler):\n         if not crawler.settings.getbool('COMPRESSION_ENABLED'):\n             raise NotConfigured\n-        return cls()\n+        return cls(crawler.stats)",
      "comment": "This is the other change I mentioned, in case of existing subclasses without `from_crawler` overwritten but with an `__init__` method that takes no parameters:\r\n\r\n```suggestion\r\n        try:\r\n            return cls(stats=crawler.stats)\r\n        except TypeError:\r\n            result = cls()\r\n            result.stats = crawler.stats\r\n            return result\r\n```",
      "comment_id": 514983147,
      "user": "Gallaecio",
      "created_at": "2020-10-30T09:55:10Z",
      "url": "https://github.com/scrapy/scrapy/pull/4799#discussion_r514983147"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 4694,
      "file_path": "scrapy/spidermiddlewares/httperror.py",
      "line": 35,
      "side": "RIGHT",
      "diff_hunk": "@@ -32,7 +32,7 @@ def process_spider_input(self, response, spider):\n         if 200 <= response.status < 300:  # common case\n             return\n         meta = response.meta\n-        if 'handle_httpstatus_all' in meta:\n+        if 'handle_httpstatus_all' in meta and meta['handle_httpstatus_all']:",
      "comment": ":lipstick: \r\n\r\n```suggestion\r\n        if meta.get('handle_httpstatus_all', False):\r\n```",
      "comment_id": 461450020,
      "user": "Gallaecio",
      "created_at": "2020-07-28T09:34:16Z",
      "url": "https://github.com/scrapy/scrapy/pull/4694#discussion_r461450020"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 4935,
      "file_path": "tests/test_utils_misc/test_return_with_argument_inside_generator.py",
      "line": 25,
      "side": "RIGHT",
      "diff_hunk": "@@ -3,6 +3,28 @@\n from scrapy.utils.misc import is_generator_with_return_value\n \n \n+def top_level_function_with():\n+    \"\"\"\n+docstring\n+    \"\"\"\n+    url = \"\"\"\n+https://example.org\n+\"\"\"\n+    yield 1\n+    return 2\n+\n+\n+def top_level_function_without():\n+    \"\"\"\n+docstring\n+    \"\"\"\n+    url = \"\"\"\n+https://example.org\n+\"\"\"\n+    yield 1\n+    return",
      "comment": "My suggestion from https://github.com/scrapy/scrapy/issues/4477#issuecomment-611018866 was not working correctly for these top-level defined functions.",
      "comment_id": 546808312,
      "user": "elacuesta",
      "created_at": "2020-12-21T16:37:52Z",
      "url": "https://github.com/scrapy/scrapy/pull/4935#discussion_r546808312"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 4935,
      "file_path": "scrapy/utils/misc.py",
      "line": 247,
      "side": "RIGHT",
      "diff_hunk": "@@ -242,7 +242,11 @@ def warn_on_generator_with_return_value(spider, callable):\n     Logs a warning if a callable is a generator function and includes\n     a 'return' statement with a value different than None\n     \"\"\"\n-    if is_generator_with_return_value(callable):\n+    try:\n+        should_warn = is_generator_with_return_value(callable)\n+    except SyntaxError:  # includes IndentationError",
      "comment": "I guess this cannot be tested without unclean mocking, so :heavy_check_mark: ",
      "comment_id": 552126146,
      "user": "Gallaecio",
      "created_at": "2021-01-05T18:50:43Z",
      "url": "https://github.com/scrapy/scrapy/pull/4935#discussion_r552126146"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 4935,
      "file_path": "scrapy/utils/misc.py",
      "line": 247,
      "side": "RIGHT",
      "diff_hunk": "@@ -242,7 +242,11 @@ def warn_on_generator_with_return_value(spider, callable):\n     Logs a warning if a callable is a generator function and includes\n     a 'return' statement with a value different than None\n     \"\"\"\n-    if is_generator_with_return_value(callable):\n+    try:\n+        should_warn = is_generator_with_return_value(callable)\n+    except SyntaxError:  # includes IndentationError",
      "comment": "Here it would be better to capture `except SyntaxError as e:` and find a way to include `e` in the reporting.",
      "comment_id": 583913019,
      "user": "apalala",
      "created_at": "2021-02-26T20:56:06Z",
      "url": "https://github.com/scrapy/scrapy/pull/4935#discussion_r583913019"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 4935,
      "file_path": "scrapy/utils/misc.py",
      "line": 247,
      "side": "RIGHT",
      "diff_hunk": "@@ -242,7 +242,11 @@ def warn_on_generator_with_return_value(spider, callable):\n     Logs a warning if a callable is a generator function and includes\n     a 'return' statement with a value different than None\n     \"\"\"\n-    if is_generator_with_return_value(callable):\n+    try:\n+        should_warn = is_generator_with_return_value(callable)\n+    except SyntaxError:  # includes IndentationError",
      "comment": "I beg to differ, this function only takes care of warning if the passed function is a generator with a return value different than `None`. Other pieces of code will fail loudly in case of `SyntaxError` (and probably even fail earlier, this is likely a safety net that's not even going to be reached - the function code has already been loaded by this point).\r\n",
      "comment_id": 583948162,
      "user": "elacuesta",
      "created_at": "2021-02-26T22:13:48Z",
      "url": "https://github.com/scrapy/scrapy/pull/4935#discussion_r583948162"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 5036,
      "file_path": "scrapy/spidermiddlewares/urllength.py",
      "line": 17,
      "side": "RIGHT",
      "diff_hunk": "@@ -14,22 +14,27 @@\n \n class UrlLengthMiddleware:\n \n-    def __init__(self, maxlength):\n+    def __init__(self, maxlength, stats):",
      "comment": "Can we make the parameter optional, to maintain backward compatibility? (think of class inheritance and calls to `super().__init__(maxlength)`).",
      "comment_id": 593056038,
      "user": "Gallaecio",
      "created_at": "2021-03-12T10:09:21Z",
      "url": "https://github.com/scrapy/scrapy/pull/5036#discussion_r593056038"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 5036,
      "file_path": "scrapy/spidermiddlewares/urllength.py",
      "line": 22,
      "side": "RIGHT",
      "diff_hunk": "@@ -14,22 +14,27 @@\n \n class UrlLengthMiddleware:\n \n-    def __init__(self, maxlength):\n+    def __init__(self, maxlength, stats):\n         self.maxlength = maxlength\n+        self.stats = stats\n \n     @classmethod\n-    def from_settings(cls, settings):\n+    def from_crawler(cls, crawler):",
      "comment": "I find it hard to figure out how to handle this for backward compatibility (and this is not the first time I face this issue), but I know this is backward incompatible, because [if a subclass defines `from_settings`, that `from_settings` will no longer be called due to this `from_crawler`](https://github.com/scrapy/scrapy/blob/2.4.1/scrapy/utils/misc.py#L145).",
      "comment_id": 593060413,
      "user": "Gallaecio",
      "created_at": "2021-03-12T10:16:12Z",
      "url": "https://github.com/scrapy/scrapy/pull/5036#discussion_r593060413"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 5036,
      "file_path": "scrapy/spidermiddlewares/urllength.py",
      "line": 22,
      "side": "RIGHT",
      "diff_hunk": "@@ -14,22 +14,27 @@\n \n class UrlLengthMiddleware:\n \n-    def __init__(self, maxlength):\n+    def __init__(self, maxlength, stats):\n         self.maxlength = maxlength\n+        self.stats = stats\n \n     @classmethod\n-    def from_settings(cls, settings):\n+    def from_crawler(cls, crawler):",
      "comment": "@Gallaecio we might not inject `stats` instance to a mw, but instead access it by `spider.crawler.stats` so no need to change signatures, and backward compatibility will be kept. \r\n\r\nIs that fine?",
      "comment_id": 593074824,
      "user": "dmiwell",
      "created_at": "2021-03-12T10:38:45Z",
      "url": "https://github.com/scrapy/scrapy/pull/5036#discussion_r593074824"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 5036,
      "file_path": "scrapy/spidermiddlewares/urllength.py",
      "line": 22,
      "side": "RIGHT",
      "diff_hunk": "@@ -14,22 +14,27 @@\n \n class UrlLengthMiddleware:\n \n-    def __init__(self, maxlength):\n+    def __init__(self, maxlength, stats):\n         self.maxlength = maxlength\n+        self.stats = stats\n \n     @classmethod\n-    def from_settings(cls, settings):\n+    def from_crawler(cls, crawler):",
      "comment": "Sounds great to me, it removes all the backward compatibility headaches :slightly_smiling_face: ",
      "comment_id": 593078017,
      "user": "Gallaecio",
      "created_at": "2021-03-12T10:44:04Z",
      "url": "https://github.com/scrapy/scrapy/pull/5036#discussion_r593078017"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 5027,
      "file_path": "tests/test_pipeline_images.py",
      "line": 14,
      "side": "LEFT",
      "diff_hunk": "@@ -11,7 +11,6 @@\n \n from scrapy.http import Request, Response\n from scrapy.item import Field, Item\n-from scrapy.pipelines.images import ImagesPipeline",
      "comment": "I think it's no longer needed to more this import as that file doesn't import PIL anymore?",
      "comment_id": 596655786,
      "user": "wRAR",
      "created_at": "2021-03-18T08:48:14Z",
      "url": "https://github.com/scrapy/scrapy/pull/5027#discussion_r596655786"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 4897,
      "file_path": "scrapy/core/downloader/handlers/http11.py",
      "line": 395,
      "side": "RIGHT",
      "diff_hunk": "@@ -382,6 +382,27 @@ def _cb_latency(self, result, request, start_time):\n         return result\n \n     def _cb_bodyready(self, txresponse, request):\n+        headers_received_result = self._crawler.signals.send_catch_log(\n+            signal=signals.headers_received,\n+            headers=Headers(txresponse.headers.getAllRawHeaders()),\n+            request=request,\n+            spider=self._crawler.spider,\n+        )\n+        for handler, result in headers_received_result:\n+            if isinstance(result, Failure) and isinstance(result.value, StopDownload):\n+                logger.debug(\"Download stopped for %(request)s from signal handler %(handler)s\",\n+                             {\"request\": request, \"handler\": handler.__qualname__})\n+                with suppress(AttributeError):",
      "comment": "Do you know in which circumstances this happens? Maybe it would be worth indicating in a comment here.",
      "comment_id": 578344512,
      "user": "Gallaecio",
      "created_at": "2021-02-18T11:33:39Z",
      "url": "https://github.com/scrapy/scrapy/pull/4897#discussion_r578344512"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 4897,
      "file_path": "scrapy/core/downloader/handlers/http11.py",
      "line": 403,
      "side": "RIGHT",
      "diff_hunk": "@@ -382,6 +382,27 @@ def _cb_latency(self, result, request, start_time):\n         return result\n \n     def _cb_bodyready(self, txresponse, request):\n+        headers_received_result = self._crawler.signals.send_catch_log(\n+            signal=signals.headers_received,\n+            headers=Headers(txresponse.headers.getAllRawHeaders()),\n+            request=request,\n+            spider=self._crawler.spider,\n+        )\n+        for handler, result in headers_received_result:\n+            if isinstance(result, Failure) and isinstance(result.value, StopDownload):\n+                logger.debug(\"Download stopped for %(request)s from signal handler %(handler)s\",\n+                             {\"request\": request, \"handler\": handler.__qualname__})\n+                with suppress(AttributeError):\n+                    txresponse._transport._producer.loseConnection()\n+                return {\n+                    \"txresponse\": txresponse,\n+                    \"body\": b\"\",\n+                    \"flags\": [\"download_stopped\"],\n+                    \"certificate\": None,\n+                    \"ip_address\": None,\n+                    \"failure\": result if result.value.fail else None,",
      "comment": "This serves the same purpose as [this line](https://github.com/scrapy/scrapy/blob/2.4.1/scrapy/core/downloader/handlers/http11.py#L524),  from the `bytes_received` part, and it's evaluated [here](https://github.com/scrapy/scrapy/blob/2.4.1/scrapy/core/downloader/handlers/http11.py#L446-L448) to determine whether the final result is handled by the request's callback or errback.",
      "comment_id": 578382392,
      "user": "elacuesta",
      "created_at": "2021-02-18T12:36:24Z",
      "url": "https://github.com/scrapy/scrapy/pull/4897#discussion_r578382392"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 4897,
      "file_path": "scrapy/core/downloader/handlers/http11.py",
      "line": 395,
      "side": "RIGHT",
      "diff_hunk": "@@ -382,6 +382,27 @@ def _cb_latency(self, result, request, start_time):\n         return result\n \n     def _cb_bodyready(self, txresponse, request):\n+        headers_received_result = self._crawler.signals.send_catch_log(\n+            signal=signals.headers_received,\n+            headers=Headers(txresponse.headers.getAllRawHeaders()),\n+            request=request,\n+            spider=self._crawler.spider,\n+        )\n+        for handler, result in headers_received_result:\n+            if isinstance(result, Failure) and isinstance(result.value, StopDownload):\n+                logger.debug(\"Download stopped for %(request)s from signal handler %(handler)s\",\n+                             {\"request\": request, \"handler\": handler.__qualname__})\n+                with suppress(AttributeError):",
      "comment": "To be honest, I didn't dig too much into this part. I would much rather do `Transport.loseConnection`, which [does this check](https://github.com/twisted/twisted/blob/twisted-18.4.0/src/twisted/web/_newclient.py#L1359-L1365) and saves me one call to a private member, but it's not available in the minimum Twisted version we currently support (17.9.0)",
      "comment_id": 578405193,
      "user": "elacuesta",
      "created_at": "2021-02-18T13:12:51Z",
      "url": "https://github.com/scrapy/scrapy/pull/4897#discussion_r578405193"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 5002,
      "file_path": "scrapy/utils/curl.py",
      "line": 36,
      "side": "RIGHT",
      "diff_hunk": "@@ -33,6 +33,44 @@ def error(self, message):\n for argument in safe_to_ignore_arguments:\n     curl_parser.add_argument(*argument, action='store_true')\n \n+def extract_headers_cookies(parsed_args):",
      "comment": "Please, use `_` as a prefix for functions like these that are not meant to be imported by users.",
      "comment_id": 581667446,
      "user": "Gallaecio",
      "created_at": "2021-02-24T06:38:57Z",
      "url": "https://github.com/scrapy/scrapy/pull/5002#discussion_r581667446"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 5002,
      "file_path": "scrapy/utils/curl.py",
      "line": 91,
      "side": "RIGHT",
      "diff_hunk": "@@ -70,21 +88,7 @@ def curl_to_request_kwargs(curl_command, ignore_unknown_options=True):\n \n     result = {'method': method.upper(), 'url': url}\n \n-    headers = []\n-    cookies = {}\n-    for header in parsed_args.headers or ():\n-        name, val = header.split(':', 1)\n-        name = name.strip()\n-        val = val.strip()\n-        if name.title() == 'Cookie':\n-            for name, morsel in SimpleCookie(val).items():\n-                cookies[name] = morsel.value\n-        else:\n-            headers.append((name, val))\n-\n-    if parsed_args.auth:\n-        user, password = parsed_args.auth.split(':', 1)\n-        headers.append(('Authorization', basic_auth_header(user, password)))\n+    headers, cookies = _parse_headers_cookies(parsed_args)",
      "comment": "```suggestion\r\n    headers, cookies = _parse_headers_and_cookies(parsed_args)\r\n```",
      "comment_id": 581759326,
      "user": "Gallaecio",
      "created_at": "2021-02-24T08:41:34Z",
      "url": "https://github.com/scrapy/scrapy/pull/5002#discussion_r581759326"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 4036,
      "file_path": "tests/test_loader.py",
      "line": 70,
      "side": "RIGHT",
      "diff_hunk": "@@ -61,7 +67,7 @@ def test_load_item_using_default_loader(self):\n         il.add_value('name', u'marta')\n         item = il.load_item()\n         assert item is i\n-        self.assertEqual(item['summary'], u'lala')\n+        self.assertEqual(item['summary'], [u'lala'])",
      "comment": "I think this line technically makes the PR backward incompatible. I believe this is a reasonable price to pay, considering that the current code breaks if one wants to add more values to the same field, i.e. adding `il.add_value('summary', u'foobar')` after creating this loader results in\r\n```\r\nERROR: test_load_item_using_default_loader (__main__.BasicItemLoaderTest)\r\n----------------------------------------------------------------------\r\nTraceback (most recent call last):\r\n  File \"tests/test_loader.py\", line 62, in test_load_item_using_default_loader\r\n    il.add_value('summary', u'foobar')\r\n  File \"/.../scrapy/loader/__init__.py\", line 79, in add_value\r\n    self._add_value(field_name, value)\r\n  File \"/.../scrapy/loader/__init__.py\", line 95, in _add_value\r\n    self._values[field_name] += arg_to_iter(processed_value)\r\nTypeError: can only concatenate str (not \"list\") to str",
      "comment_id": 327927988,
      "user": "elacuesta",
      "created_at": "2019-09-25T04:33:02Z",
      "url": "https://github.com/scrapy/scrapy/pull/4036#discussion_r327927988"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 4036,
      "file_path": "tests/test_loader.py",
      "line": 562,
      "side": "RIGHT",
      "diff_hunk": "@@ -493,6 +464,213 @@ class TestItemLoader(ItemLoader):\n                           [u'marta', u'other'], Compose(float))\n \n \n+class InitializationTestMixin(object):\n+\n+    item_class = None\n+\n+    def test_keep_single_value(self):\n+        \"\"\"Loaded item should contain values from the initial item\"\"\"\n+        input_item = self.item_class(name='foo')\n+        il = ItemLoader(item=input_item)\n+        loaded_item = il.load_item()\n+        self.assertIsInstance(loaded_item, self.item_class)\n+        self.assertEqual(dict(loaded_item), {'name': ['foo']})\n+\n+    def test_keep_list(self):\n+        \"\"\"Loaded item should contain values from the initial item\"\"\"\n+        input_item = self.item_class(name=['foo', 'bar'])\n+        il = ItemLoader(item=input_item)\n+        loaded_item = il.load_item()\n+        self.assertIsInstance(loaded_item, self.item_class)\n+        self.assertEqual(dict(loaded_item), {'name': ['foo', 'bar']})\n+\n+    def test_add_value_singlevalue_singlevalue(self):\n+        \"\"\"Values added after initialization should be appended\"\"\"\n+        input_item = self.item_class(name='foo')\n+        il = ItemLoader(item=input_item)\n+        il.add_value('name', 'bar')\n+        loaded_item = il.load_item()\n+        self.assertIsInstance(loaded_item, self.item_class)\n+        self.assertEqual(dict(loaded_item), {'name': ['foo', 'bar']})\n+\n+    def test_add_value_singlevalue_list(self):\n+        \"\"\"Values added after initialization should be appended\"\"\"\n+        input_item = self.item_class(name='foo')\n+        il = ItemLoader(item=input_item)\n+        il.add_value('name', ['item', 'loader'])\n+        loaded_item = il.load_item()\n+        self.assertIsInstance(loaded_item, self.item_class)\n+        self.assertEqual(dict(loaded_item), {'name': ['foo', 'item', 'loader']})\n+\n+    def test_add_value_list_singlevalue(self):\n+        \"\"\"Values added after initialization should be appended\"\"\"\n+        input_item = self.item_class(name=['foo', 'bar'])\n+        il = ItemLoader(item=input_item)\n+        il.add_value('name', 'qwerty')\n+        loaded_item = il.load_item()\n+        self.assertIsInstance(loaded_item, self.item_class)\n+        self.assertEqual(dict(loaded_item), {'name': ['foo', 'bar', 'qwerty']})\n+\n+    def test_add_value_list_list(self):\n+        \"\"\"Values added after initialization should be appended\"\"\"\n+        input_item = self.item_class(name=['foo', 'bar'])\n+        il = ItemLoader(item=input_item)\n+        il.add_value('name', ['item', 'loader'])\n+        loaded_item = il.load_item()\n+        self.assertIsInstance(loaded_item, self.item_class)\n+        self.assertEqual(dict(loaded_item), {'name': ['foo', 'bar', 'item', 'loader']})\n+\n+    def test_get_output_value_singlevalue(self):\n+        \"\"\"Getting output value must not remove value from item\"\"\"\n+        input_item = self.item_class(name='foo')\n+        il = ItemLoader(item=input_item)\n+        self.assertEqual(il.get_output_value('name'), ['foo'])\n+        loaded_item = il.load_item()\n+        self.assertIsInstance(loaded_item, self.item_class)\n+        self.assertEqual(loaded_item, dict({'name': ['foo']}))\n+\n+    def test_get_output_value_list(self):\n+        \"\"\"Getting output value must not remove value from item\"\"\"\n+        input_item = self.item_class(name=['foo', 'bar'])\n+        il = ItemLoader(item=input_item)\n+        self.assertEqual(il.get_output_value('name'), ['foo', 'bar'])\n+        loaded_item = il.load_item()\n+        self.assertIsInstance(loaded_item, self.item_class)\n+        self.assertEqual(loaded_item, dict({'name': ['foo', 'bar']}))\n+\n+    def test_values_single(self):\n+        \"\"\"Values from initial item must be added to loader._values\"\"\"\n+        input_item = self.item_class(name='foo')\n+        il = ItemLoader(item=input_item)\n+        self.assertEqual(il._values.get('name'), ['foo'])\n+\n+    def test_values_list(self):\n+        \"\"\"Values from initial item must be added to loader._values\"\"\"\n+        input_item = self.item_class(name=['foo', 'bar'])\n+        il = ItemLoader(item=input_item)\n+        self.assertEqual(il._values.get('name'), ['foo', 'bar'])\n+\n+\n+class InitializationFromDictTest(InitializationTestMixin, unittest.TestCase):\n+    item_class = dict\n+\n+\n+class InitializationFromItemTest(InitializationTestMixin, unittest.TestCase):\n+    item_class = NameItem\n+\n+\n+class NoInputReprocessingFromDictTest(unittest.TestCase):",
      "comment": "I'd say that `NoInputReprocessingFromDictTest` and `NoInputReprocessingFromItemTest` should use the same loader definition. To make the behavior clear.",
      "comment_id": 332117976,
      "user": "ejulio",
      "created_at": "2019-10-07T16:32:18Z",
      "url": "https://github.com/scrapy/scrapy/pull/4036#discussion_r332117976"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 4036,
      "file_path": "tests/test_loader.py",
      "line": 562,
      "side": "RIGHT",
      "diff_hunk": "@@ -493,6 +464,213 @@ class TestItemLoader(ItemLoader):\n                           [u'marta', u'other'], Compose(float))\n \n \n+class InitializationTestMixin(object):\n+\n+    item_class = None\n+\n+    def test_keep_single_value(self):\n+        \"\"\"Loaded item should contain values from the initial item\"\"\"\n+        input_item = self.item_class(name='foo')\n+        il = ItemLoader(item=input_item)\n+        loaded_item = il.load_item()\n+        self.assertIsInstance(loaded_item, self.item_class)\n+        self.assertEqual(dict(loaded_item), {'name': ['foo']})\n+\n+    def test_keep_list(self):\n+        \"\"\"Loaded item should contain values from the initial item\"\"\"\n+        input_item = self.item_class(name=['foo', 'bar'])\n+        il = ItemLoader(item=input_item)\n+        loaded_item = il.load_item()\n+        self.assertIsInstance(loaded_item, self.item_class)\n+        self.assertEqual(dict(loaded_item), {'name': ['foo', 'bar']})\n+\n+    def test_add_value_singlevalue_singlevalue(self):\n+        \"\"\"Values added after initialization should be appended\"\"\"\n+        input_item = self.item_class(name='foo')\n+        il = ItemLoader(item=input_item)\n+        il.add_value('name', 'bar')\n+        loaded_item = il.load_item()\n+        self.assertIsInstance(loaded_item, self.item_class)\n+        self.assertEqual(dict(loaded_item), {'name': ['foo', 'bar']})\n+\n+    def test_add_value_singlevalue_list(self):\n+        \"\"\"Values added after initialization should be appended\"\"\"\n+        input_item = self.item_class(name='foo')\n+        il = ItemLoader(item=input_item)\n+        il.add_value('name', ['item', 'loader'])\n+        loaded_item = il.load_item()\n+        self.assertIsInstance(loaded_item, self.item_class)\n+        self.assertEqual(dict(loaded_item), {'name': ['foo', 'item', 'loader']})\n+\n+    def test_add_value_list_singlevalue(self):\n+        \"\"\"Values added after initialization should be appended\"\"\"\n+        input_item = self.item_class(name=['foo', 'bar'])\n+        il = ItemLoader(item=input_item)\n+        il.add_value('name', 'qwerty')\n+        loaded_item = il.load_item()\n+        self.assertIsInstance(loaded_item, self.item_class)\n+        self.assertEqual(dict(loaded_item), {'name': ['foo', 'bar', 'qwerty']})\n+\n+    def test_add_value_list_list(self):\n+        \"\"\"Values added after initialization should be appended\"\"\"\n+        input_item = self.item_class(name=['foo', 'bar'])\n+        il = ItemLoader(item=input_item)\n+        il.add_value('name', ['item', 'loader'])\n+        loaded_item = il.load_item()\n+        self.assertIsInstance(loaded_item, self.item_class)\n+        self.assertEqual(dict(loaded_item), {'name': ['foo', 'bar', 'item', 'loader']})\n+\n+    def test_get_output_value_singlevalue(self):\n+        \"\"\"Getting output value must not remove value from item\"\"\"\n+        input_item = self.item_class(name='foo')\n+        il = ItemLoader(item=input_item)\n+        self.assertEqual(il.get_output_value('name'), ['foo'])\n+        loaded_item = il.load_item()\n+        self.assertIsInstance(loaded_item, self.item_class)\n+        self.assertEqual(loaded_item, dict({'name': ['foo']}))\n+\n+    def test_get_output_value_list(self):\n+        \"\"\"Getting output value must not remove value from item\"\"\"\n+        input_item = self.item_class(name=['foo', 'bar'])\n+        il = ItemLoader(item=input_item)\n+        self.assertEqual(il.get_output_value('name'), ['foo', 'bar'])\n+        loaded_item = il.load_item()\n+        self.assertIsInstance(loaded_item, self.item_class)\n+        self.assertEqual(loaded_item, dict({'name': ['foo', 'bar']}))\n+\n+    def test_values_single(self):\n+        \"\"\"Values from initial item must be added to loader._values\"\"\"\n+        input_item = self.item_class(name='foo')\n+        il = ItemLoader(item=input_item)\n+        self.assertEqual(il._values.get('name'), ['foo'])\n+\n+    def test_values_list(self):\n+        \"\"\"Values from initial item must be added to loader._values\"\"\"\n+        input_item = self.item_class(name=['foo', 'bar'])\n+        il = ItemLoader(item=input_item)\n+        self.assertEqual(il._values.get('name'), ['foo', 'bar'])\n+\n+\n+class InitializationFromDictTest(InitializationTestMixin, unittest.TestCase):\n+    item_class = dict\n+\n+\n+class InitializationFromItemTest(InitializationTestMixin, unittest.TestCase):\n+    item_class = NameItem\n+\n+\n+class NoInputReprocessingFromDictTest(unittest.TestCase):",
      "comment": "Updated. The loaders are still defined separately because they need different `default_item_class` attributes, but now they both inherit from `BaseNoInputReprocessingLoader`. Thanks!",
      "comment_id": 332617203,
      "user": "elacuesta",
      "created_at": "2019-10-08T16:41:16Z",
      "url": "https://github.com/scrapy/scrapy/pull/4036#discussion_r332617203"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 4036,
      "file_path": "scrapy/loader/__init__.py",
      "line": 38,
      "side": "RIGHT",
      "diff_hunk": "@@ -33,10 +33,9 @@ def __init__(self, item=None, selector=None, response=None, parent=None, **conte\n         self.parent = parent\n         self._local_item = context['item'] = item\n         self._local_values = defaultdict(list)\n-        # Preprocess values if item built from dict\n-        # Values need to be added to item._values if added them from dict (not with add_values)\n+        # values from initial item\n         for field_name, value in item.items():\n-            self._values[field_name] = self._process_input_value(field_name, value)\n+            self._values[field_name] += arg_to_iter(value)",
      "comment": "I know this is old commit, but I'm now in the process of understanding this whole issue, and chain of events started with this https://github.com/scrapy/scrapy/pull/3819 and this is still a breaking change for many projects, people were certainly getting different data in many cases after all these changes. See below code as example, I have several spiders relying on old behavior and now looking for workaround.\r\n\r\n```python\r\n\r\nfrom scrapy import Item, Field\r\nfrom scrapy.loader import ItemLoader\r\n\r\n\r\nclass AItem(Item):\r\n    name = Field()\r\n\r\n\r\nclass ALoader(ItemLoader):\r\n    default_item_class = AItem\r\n\r\n\r\n# Breaking change between scrapy 1.7 and 2.4.\r\n# Below is shown behavior that several spiders rely on, this was behavior up until 1.7.4.\r\n# And it is not how loader works by default in Scrapy after 1.7.4 version.\r\ndef test_loader_breaking_change_scrapy_v17_v24():\r\n    # To see this run this test in different environment, one with Scrapy 1.7\r\n    # and old loader library, other with Scrapy 2.4.1 and itemloader library.\r\n    loader = ALoader()\r\n    loader.add_value('name', 'hello world')\r\n    l = loader.load_item()\r\n    new_loader = ALoader(l)\r\n    new_loader.add_value(\"name\", \"lovely\")\r\n    l = new_loader.load_item()\r\n    # after Scrapy 1.7.4 it gives: {'name': ['hello world', 'lovely']} \r\n    # until Scrapy 1.7.4 it was {'name': ['lovely']}\r\n    assert l['name'] == ['lovely']\r\n```",
      "comment_id": 580909810,
      "user": "pawelmhm",
      "created_at": "2021-02-23T10:09:39Z",
      "url": "https://github.com/scrapy/scrapy/pull/4036#discussion_r580909810"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 4036,
      "file_path": "scrapy/loader/__init__.py",
      "line": 38,
      "side": "RIGHT",
      "diff_hunk": "@@ -33,10 +33,9 @@ def __init__(self, item=None, selector=None, response=None, parent=None, **conte\n         self.parent = parent\n         self._local_item = context['item'] = item\n         self._local_values = defaultdict(list)\n-        # Preprocess values if item built from dict\n-        # Values need to be added to item._values if added them from dict (not with add_values)\n+        # values from initial item\n         for field_name, value in item.items():\n-            self._values[field_name] = self._process_input_value(field_name, value)\n+            self._values[field_name] += arg_to_iter(value)",
      "comment": "Would using a \u201cTakeLast\u201d output processor (e.g. `lambda v: v[-1]`) work for your scenario?",
      "comment_id": 580915419,
      "user": "Gallaecio",
      "created_at": "2021-02-23T10:18:25Z",
      "url": "https://github.com/scrapy/scrapy/pull/4036#discussion_r580915419"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 4036,
      "file_path": "scrapy/loader/__init__.py",
      "line": 38,
      "side": "RIGHT",
      "diff_hunk": "@@ -33,10 +33,9 @@ def __init__(self, item=None, selector=None, response=None, parent=None, **conte\n         self.parent = parent\n         self._local_item = context['item'] = item\n         self._local_values = defaultdict(list)\n-        # Preprocess values if item built from dict\n-        # Values need to be added to item._values if added them from dict (not with add_values)\n+        # values from initial item\n         for field_name, value in item.items():\n-            self._values[field_name] = self._process_input_value(field_name, value)\n+            self._values[field_name] += arg_to_iter(value)",
      "comment": "I have TakeFirst processor defined for this specific field where I spotted this, and different spiders are doing different things, some of them are fine after this change, but some are not. Changing output processors will change several things. I wonder if we could add some option for loader to keep old behavior? It seems dirty, but would make things easier. I could also refactor spiders, but there is many of them and even finding which one is affected is not that easy",
      "comment_id": 580925689,
      "user": "pawelmhm",
      "created_at": "2021-02-23T10:33:37Z",
      "url": "https://github.com/scrapy/scrapy/pull/4036#discussion_r580925689"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 4036,
      "file_path": "scrapy/loader/__init__.py",
      "line": 38,
      "side": "RIGHT",
      "diff_hunk": "@@ -33,10 +33,9 @@ def __init__(self, item=None, selector=None, response=None, parent=None, **conte\n         self.parent = parent\n         self._local_item = context['item'] = item\n         self._local_values = defaultdict(list)\n-        # Preprocess values if item built from dict\n-        # Values need to be added to item._values if added them from dict (not with add_values)\n+        # values from initial item\n         for field_name, value in item.items():\n-            self._values[field_name] = self._process_input_value(field_name, value)\n+            self._values[field_name] += arg_to_iter(value)",
      "comment": "What kind of change do you have in mind? Something like a parameter to `ItemLoader` that sets the old behavior? Our would it work for you if we simply extended the `ItemLoader` API with something like `set_value` to replace any value added so far?",
      "comment_id": 580951177,
      "user": "Gallaecio",
      "created_at": "2021-02-23T11:13:16Z",
      "url": "https://github.com/scrapy/scrapy/pull/4036#discussion_r580951177"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 4036,
      "file_path": "scrapy/loader/__init__.py",
      "line": 38,
      "side": "RIGHT",
      "diff_hunk": "@@ -33,10 +33,9 @@ def __init__(self, item=None, selector=None, response=None, parent=None, **conte\n         self.parent = parent\n         self._local_item = context['item'] = item\n         self._local_values = defaultdict(list)\n-        # Preprocess values if item built from dict\n-        # Values need to be added to item._values if added them from dict (not with add_values)\n+        # values from initial item\n         for field_name, value in item.items():\n-            self._values[field_name] = self._process_input_value(field_name, value)\n+            self._values[field_name] += arg_to_iter(value)",
      "comment": "> Something like a parameter to ItemLoader that sets the old behavior?\r\n\r\nI was thinking about parameter or attribute of Loader. I could set this when defining my subclass of ItemLoader. But I see potential problem from library point of view - it can be hard to maintain in the future, there will be 2 different logics, not sure how many people will even think about this attribute or parameter. If I will be only project using it - it is not much sense, I can just subclass ItemLoader my side and change some things. I could also stick to old ItemLoader library but there is no easy way, because itemloaders were moved to separate repo, so I cannot simply use some old version of itemLoader with Scrapy 2.4.1. First release of itemloaders is after this change and scrapy 2.4.1 imports itemloaders.\r\n\r\n> Our would it work for you if we simply extended the ItemLoader API with something like set_value to replace any value added so far?\r\n\r\nThere is already replace_value, which is doing what I would need here. I guess the problem is because in the past in many cases loader.add_value was actually replacing value when people intended to add_value, now code relies on this and this creates mess when situation is cleared up. ",
      "comment_id": 580967534,
      "user": "pawelmhm",
      "created_at": "2021-02-23T11:41:12Z",
      "url": "https://github.com/scrapy/scrapy/pull/4036#discussion_r580967534"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 4994,
      "file_path": "scrapy/core/http2/protocol.py",
      "line": 46,
      "side": "RIGHT",
      "diff_hunk": "@@ -33,13 +33,17 @@\n logger = logging.getLogger(__name__)\n \n \n+ACCEPTABLE_PROTOCOL = b\"h2\"\n+\n+\n class InvalidNegotiatedProtocol(H2Error):\n \n-    def __init__(self, negotiated_protocol: str) -> None:\n+    def __init__(self, negotiated_protocol: bytes) -> None:\n         self.negotiated_protocol = negotiated_protocol\n \n     def __str__(self) -> str:\n-        return f'InvalidNegotiatedProtocol: Expected h2 as negotiated protocol, received {self.negotiated_protocol!r}'\n+        return (f\"Expected {ACCEPTABLE_PROTOCOL.decode('utf-8')} as negotiated protocol,\"\n+                f\" received {self.negotiated_protocol.decode('utf-8')}\")",
      "comment": ":lipstick: Instead of decoding, maybe we could use `!r` and let it be shown as `b'\u2026'`. Otherwise, this will break on non-UTF-8 stuff, which while unlikely is still possible.",
      "comment_id": 579752278,
      "user": "Gallaecio",
      "created_at": "2021-02-21T05:11:47Z",
      "url": "https://github.com/scrapy/scrapy/pull/4994#discussion_r579752278"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 4994,
      "file_path": "scrapy/core/http2/protocol.py",
      "line": 36,
      "side": "RIGHT",
      "diff_hunk": "@@ -33,13 +33,17 @@\n logger = logging.getLogger(__name__)\n \n \n+ACCEPTABLE_PROTOCOL = b\"h2\"",
      "comment": ":lipstick: Maybe simply `PROTOCOL`? I\u2019m definitely [bikeshedding](https://en.wikipedia.org/wiki/Law_of_triviality) here, so feel free to mark this as solved without any change.",
      "comment_id": 579752426,
      "user": "Gallaecio",
      "created_at": "2021-02-21T05:14:18Z",
      "url": "https://github.com/scrapy/scrapy/pull/4994#discussion_r579752426"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 4994,
      "file_path": "scrapy/core/http2/protocol.py",
      "line": 36,
      "side": "RIGHT",
      "diff_hunk": "@@ -33,13 +33,17 @@\n logger = logging.getLogger(__name__)\n \n \n+ACCEPTABLE_PROTOCOL = b\"h2\"",
      "comment": "I don't much like `ACCEPTABLE_PROTOCOL` to be honest, but I think I'd prefer to go with `PROTOCOL_NAME`, for extra explicitness.",
      "comment_id": 580278507,
      "user": "elacuesta",
      "created_at": "2021-02-22T14:11:30Z",
      "url": "https://github.com/scrapy/scrapy/pull/4994#discussion_r580278507"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 4924,
      "file_path": "tests/test_webclient.py",
      "line": 421,
      "side": "RIGHT",
      "diff_hunk": "@@ -414,6 +417,8 @@ def testPayload(self):\n         ).addCallback(self.assertEqual, to_bytes(s))\n \n     def testPayloadDisabledCipher(self):\n+        if sys.implementation.name == \"pypy\" and parse_version(cryptography.__version__) <= parse_version(\"2.3.1\"):\n+            self.skipTest(\"This does work in PyPy with cryptography<=2.3.1\")",
      "comment": "Well this is awkward, but I don't really know why this happens :shrug: ",
      "comment_id": 544643365,
      "user": "elacuesta",
      "created_at": "2020-12-16T21:42:12Z",
      "url": "https://github.com/scrapy/scrapy/pull/4924#discussion_r544643365"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 4924,
      "file_path": "tests/test_webclient.py",
      "line": 421,
      "side": "RIGHT",
      "diff_hunk": "@@ -414,6 +417,8 @@ def testPayload(self):\n         ).addCallback(self.assertEqual, to_bytes(s))\n \n     def testPayloadDisabledCipher(self):\n+        if sys.implementation.name == \"pypy\" and parse_version(cryptography.__version__) <= parse_version(\"2.3.1\"):\n+            self.skipTest(\"This does work in PyPy with cryptography<=2.3.1\")",
      "comment": "Is a \u201cnot\u201d missing in the skip message?\r\n\r\nAs for the reason, it would be ideal to find it out and mention it. I\u2019ve found https://github.com/pyca/cryptography/commit/ce6fe07632c17f16221f02ad19c6875327cdd10a , but it was not introduced in 2.3.1, but in 2.3. Could it be the cause? It seems like it would cause things to break starting with 2.3, not to be fixed starting from 2.3.1.\r\n\r\nThe only change specific to 2.3.1 was [the rebuild of wheels with a newer OpenSSL version](https://github.com/pyca/cryptography/blob/master/CHANGELOG.rst#231---2018-08-14): 1.1.0g \u2192 1.1.0h. From the [OpenSSL changelog](https://www.openssl.org/news/openssl-1.1.0-notes.html) I cannot tell much, but if we are sure that 2.3.1 is the point where things change, I guess we can assume that the new wheels are what fixes things, and we can mention that in the test.",
      "comment_id": 545021464,
      "user": "Gallaecio",
      "created_at": "2020-12-17T11:35:19Z",
      "url": "https://github.com/scrapy/scrapy/pull/4924#discussion_r545021464"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 4646,
      "file_path": "scrapy/commands/runspider.py",
      "line": 14,
      "side": "RIGHT",
      "diff_hunk": "@@ -11,7 +11,7 @@ def _import_file(filepath):\n     abspath = os.path.abspath(filepath)\n     dirname, file = os.path.split(abspath)\n     fname, fext = os.path.splitext(file)\n-    if fext != '.py':\n+    if fext != '.py' and fext != '.pyw':",
      "comment": ":lipstick: \r\n\r\n```suggestion\r\n    if fext not in ('.py', '.pyw'):\r\n```",
      "comment_id": 444825866,
      "user": "Gallaecio",
      "created_at": "2020-06-24T11:25:47Z",
      "url": "https://github.com/scrapy/scrapy/pull/4646#discussion_r444825866"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 4646,
      "file_path": "tests/test_commands.py",
      "line": 584,
      "side": "LEFT",
      "diff_hunk": "@@ -273,31 +298,52 @@ class MySpider(scrapy.Spider):\n \n     def parse(self, response):\n         return {'test': 'value'}\n-\"\"\",\n-                           args=('-s', 'DNSCACHE_ENABLED=False'))\n-        print(log)\n+\"\"\"\n+        log = self.get_log(dnscache_spider, args=('-s', 'DNSCACHE_ENABLED=False'))\n         self.assertNotIn(\"DNSLookupError\", log)\n         self.assertIn(\"INFO: Spider opened\", log)\n \n+        if sys.platform == 'win32':\n+            log = self.get_log(dnscache_spider, name='myspider,pyw', args=('-s', 'DNSCACHE_ENABLED=False'))\n+            self.assertNotIn(\"DNSLookupError\", log)\n+            self.assertIn(\"INFO: Spider opened\", log)\n+\n     def test_runspider_log_short_names(self):\n         log1 = self.get_log(self.debug_log_spider,\n                             args=('-s', 'LOG_SHORT_NAMES=1'))\n-        print(log1)\n         self.assertIn(\"[myspider] DEBUG: It Works!\", log1)\n         self.assertIn(\"[scrapy]\", log1)\n         self.assertNotIn(\"[scrapy.core.engine]\", log1)\n \n         log2 = self.get_log(self.debug_log_spider,\n                             args=('-s', 'LOG_SHORT_NAMES=0'))\n-        print(log2)",
      "comment": "I don't think we need them, they can be useful when finding why a test fails but in that case you can add them locally",
      "comment_id": 446839094,
      "user": "wRAR",
      "created_at": "2020-06-29T07:56:05Z",
      "url": "https://github.com/scrapy/scrapy/pull/4646#discussion_r446839094"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 4646,
      "file_path": "tests/test_commands.py",
      "line": 315,
      "side": "RIGHT",
      "diff_hunk": "@@ -321,74 +303,53 @@ def test_runspider_log_short_names(self):\n         self.assertNotIn(\"[scrapy]\", log2)\n         self.assertIn(\"[scrapy.core.engine]\", log2)\n \n-        if sys.platform == 'win32':\n-            log1 = self.get_log(self.debug_log_spider,\n-                                name='myspider.pyw',\n-                                args=('-s', 'LOG_SHORT_NAMES=1'))\n-            self.assertIn(\"[myspider] DEBUG: It Works!\", log1)\n-            self.assertIn(\"[scrapy]\", log1)\n-            self.assertNotIn(\"[scrapy.core.engine]\", log1)\n-\n-            log2 = self.get_log(self.debug_log_spider,\n-                                name='myspider.pyw',\n-                                args=('-s', 'LOG_SHORT_NAMES=0'))\n-            self.assertIn(\"[myspider] DEBUG: It Works!\", log2)\n-            self.assertNotIn(\"[scrapy]\", log2)\n-            self.assertIn(\"[scrapy.core.engine]\", log2)\n-\n     def test_runspider_no_spider_found(self):\n         log = self.get_log(\"from scrapy.spiders import Spider\\n\")\n         self.assertIn(\"No spider found in file\", log)\n \n-        if sys.platform == 'win32':\n-            log = self.get_log(\"from scrapy.spiders import Spider\\n\", name='myspider.pyw')\n-            self.assertIn(\"No spider found in file\", log)\n-\n     def test_runspider_file_not_found(self):\n         _, _, log = self.proc('runspider', 'some_non_existent_file')\n         self.assertIn(\"File not found: some_non_existent_file\", log)\n \n     def test_runspider_unable_to_load(self):\n-        log = self.get_log('', name='myspider.txt')\n+        self.spider_filename = 'myspider.txt'",
      "comment": "I think it would be better not to modify `self.spider_filename` as part of this test. Maybe you can define `self.get_log` so that it only uses `self.spider_filename` if the `name` is `None` (default), so that it can accept this name as a parameter. Or maybe, since it does not make sense to run this test twice (for `.py` and for `.pyw`), maybe this test should be in a separate class, on its own.",
      "comment_id": 448293913,
      "user": "Gallaecio",
      "created_at": "2020-07-01T11:18:01Z",
      "url": "https://github.com/scrapy/scrapy/pull/4646#discussion_r448293913"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 4646,
      "file_path": "tests/test_commands.py",
      "line": 343,
      "side": "RIGHT",
      "diff_hunk": "@@ -330,6 +334,24 @@ def test_asyncio_enabled_false(self):\n         self.assertNotIn(\"Using reactor: twisted.internet.asyncioreactor.AsyncioSelectorReactor\", log)\n \n \n+class WindowsRunSpiderCommandTest(RunSpiderCommandTest):\n+\n+    spider_filename = 'myspider.pyw'\n+\n+    def setUp(self):\n+        if platform != 'win32':\n+            raise unittest.SkipTest(\".pyw file extension only supported in Windows\")",
      "comment": "Do all tests fail in Linux? I think we should try to run as many of them as possible also in Linux, at least until we have Windows support in the CI.",
      "comment_id": 448432723,
      "user": "Gallaecio",
      "created_at": "2020-07-01T15:11:44Z",
      "url": "https://github.com/scrapy/scrapy/pull/4646#discussion_r448432723"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 4646,
      "file_path": "tests/test_commands.py",
      "line": 343,
      "side": "RIGHT",
      "diff_hunk": "@@ -330,6 +334,24 @@ def test_asyncio_enabled_false(self):\n         self.assertNotIn(\"Using reactor: twisted.internet.asyncioreactor.AsyncioSelectorReactor\", log)\n \n \n+class WindowsRunSpiderCommandTest(RunSpiderCommandTest):\n+\n+    spider_filename = 'myspider.pyw'\n+\n+    def setUp(self):\n+        if platform != 'win32':\n+            raise unittest.SkipTest(\".pyw file extension only supported in Windows\")",
      "comment": "I checked it now 6 of them are failing maybe I should run the rest for linux too.",
      "comment_id": 448439575,
      "user": "akshaysharmajs",
      "created_at": "2020-07-01T15:22:12Z",
      "url": "https://github.com/scrapy/scrapy/pull/4646#discussion_r448439575"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 4646,
      "file_path": "tests/test_commands.py",
      "line": 362,
      "side": "RIGHT",
      "diff_hunk": "@@ -339,10 +339,27 @@ class WindowsRunSpiderCommandTest(RunSpiderCommandTest):\n     spider_filename = 'myspider.pyw'\n \n     def setUp(self):\n-        if platform != 'win32':\n-            raise unittest.SkipTest(\".pyw file extension only supported in Windows\")\n         super(WindowsRunSpiderCommandTest, self).setUp()\n \n+    if platform != 'win32':\n+        def test_run_good_spider(self):\n+            raise unittest.SkipTest(\"Windows required\")\n+\n+        def test_runspider(self):\n+            raise unittest.SkipTest(\"Windows required\")\n+\n+        def test_runspider_dnscache_disabled(self):\n+            raise unittest.SkipTest(\"Windows required\")\n+\n+        def test_runspider_log_level(self):\n+            raise unittest.SkipTest(\"Windows required\")\n+\n+        def test_runspider_log_short_names(self):\n+            raise unittest.SkipTest(\"Windows required\")\n+\n+        def test_runspider_no_spider_found(self):\n+            raise unittest.SkipTest(\"Windows required\")\n+",
      "comment": "I think it would be better to use `@skipif` instead, in each method, and have their implementation be `super().<method_name>()`.\r\n\r\nIn any case, do all of those test fail on Linux?",
      "comment_id": 448932519,
      "user": "Gallaecio",
      "created_at": "2020-07-02T11:24:26Z",
      "url": "https://github.com/scrapy/scrapy/pull/4646#discussion_r448932519"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 4646,
      "file_path": "tests/test_commands.py",
      "line": 362,
      "side": "RIGHT",
      "diff_hunk": "@@ -339,10 +339,27 @@ class WindowsRunSpiderCommandTest(RunSpiderCommandTest):\n     spider_filename = 'myspider.pyw'\n \n     def setUp(self):\n-        if platform != 'win32':\n-            raise unittest.SkipTest(\".pyw file extension only supported in Windows\")\n         super(WindowsRunSpiderCommandTest, self).setUp()\n \n+    if platform != 'win32':\n+        def test_run_good_spider(self):\n+            raise unittest.SkipTest(\"Windows required\")\n+\n+        def test_runspider(self):\n+            raise unittest.SkipTest(\"Windows required\")\n+\n+        def test_runspider_dnscache_disabled(self):\n+            raise unittest.SkipTest(\"Windows required\")\n+\n+        def test_runspider_log_level(self):\n+            raise unittest.SkipTest(\"Windows required\")\n+\n+        def test_runspider_log_short_names(self):\n+            raise unittest.SkipTest(\"Windows required\")\n+\n+        def test_runspider_no_spider_found(self):\n+            raise unittest.SkipTest(\"Windows required\")\n+",
      "comment": "> I think it would be better to use `@skipif` instead, in each method, and have their implementation be `super().<method_name>()`.\r\n\r\nFor that I have to import `unittest` separately as `twisted.trial.unittest` doesn't have `@skipif`",
      "comment_id": 449263401,
      "user": "akshaysharmajs",
      "created_at": "2020-07-02T21:00:04Z",
      "url": "https://github.com/scrapy/scrapy/pull/4646#discussion_r449263401"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 4646,
      "file_path": "tests/test_commands.py",
      "line": 362,
      "side": "RIGHT",
      "diff_hunk": "@@ -339,10 +339,27 @@ class WindowsRunSpiderCommandTest(RunSpiderCommandTest):\n     spider_filename = 'myspider.pyw'\n \n     def setUp(self):\n-        if platform != 'win32':\n-            raise unittest.SkipTest(\".pyw file extension only supported in Windows\")\n         super(WindowsRunSpiderCommandTest, self).setUp()\n \n+    if platform != 'win32':\n+        def test_run_good_spider(self):\n+            raise unittest.SkipTest(\"Windows required\")\n+\n+        def test_runspider(self):\n+            raise unittest.SkipTest(\"Windows required\")\n+\n+        def test_runspider_dnscache_disabled(self):\n+            raise unittest.SkipTest(\"Windows required\")\n+\n+        def test_runspider_log_level(self):\n+            raise unittest.SkipTest(\"Windows required\")\n+\n+        def test_runspider_log_short_names(self):\n+            raise unittest.SkipTest(\"Windows required\")\n+\n+        def test_runspider_no_spider_found(self):\n+            raise unittest.SkipTest(\"Windows required\")\n+",
      "comment": "> In any case, do all of those test fail on Linux?\r\n\r\nI don't think there is any case for it.",
      "comment_id": 449263696,
      "user": "akshaysharmajs",
      "created_at": "2020-07-02T21:00:52Z",
      "url": "https://github.com/scrapy/scrapy/pull/4646#discussion_r449263696"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 4646,
      "file_path": "tests/test_commands.py",
      "line": 362,
      "side": "RIGHT",
      "diff_hunk": "@@ -339,10 +339,27 @@ class WindowsRunSpiderCommandTest(RunSpiderCommandTest):\n     spider_filename = 'myspider.pyw'\n \n     def setUp(self):\n-        if platform != 'win32':\n-            raise unittest.SkipTest(\".pyw file extension only supported in Windows\")\n         super(WindowsRunSpiderCommandTest, self).setUp()\n \n+    if platform != 'win32':\n+        def test_run_good_spider(self):\n+            raise unittest.SkipTest(\"Windows required\")\n+\n+        def test_runspider(self):\n+            raise unittest.SkipTest(\"Windows required\")\n+\n+        def test_runspider_dnscache_disabled(self):\n+            raise unittest.SkipTest(\"Windows required\")\n+\n+        def test_runspider_log_level(self):\n+            raise unittest.SkipTest(\"Windows required\")\n+\n+        def test_runspider_log_short_names(self):\n+            raise unittest.SkipTest(\"Windows required\")\n+\n+        def test_runspider_no_spider_found(self):\n+            raise unittest.SkipTest(\"Windows required\")\n+",
      "comment": "If the tests are going to be Windows-only then, maybe this should wait until #4458 is merged. I\u2019m hoping to be done with that soon\u2122.",
      "comment_id": 449280104,
      "user": "Gallaecio",
      "created_at": "2020-07-02T21:45:25Z",
      "url": "https://github.com/scrapy/scrapy/pull/4646#discussion_r449280104"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 4646,
      "file_path": "tests/test_commands.py",
      "line": 362,
      "side": "RIGHT",
      "diff_hunk": "@@ -339,10 +339,27 @@ class WindowsRunSpiderCommandTest(RunSpiderCommandTest):\n     spider_filename = 'myspider.pyw'\n \n     def setUp(self):\n-        if platform != 'win32':\n-            raise unittest.SkipTest(\".pyw file extension only supported in Windows\")\n         super(WindowsRunSpiderCommandTest, self).setUp()\n \n+    if platform != 'win32':\n+        def test_run_good_spider(self):\n+            raise unittest.SkipTest(\"Windows required\")\n+\n+        def test_runspider(self):\n+            raise unittest.SkipTest(\"Windows required\")\n+\n+        def test_runspider_dnscache_disabled(self):\n+            raise unittest.SkipTest(\"Windows required\")\n+\n+        def test_runspider_log_level(self):\n+            raise unittest.SkipTest(\"Windows required\")\n+\n+        def test_runspider_log_short_names(self):\n+            raise unittest.SkipTest(\"Windows required\")\n+\n+        def test_runspider_no_spider_found(self):\n+            raise unittest.SkipTest(\"Windows required\")\n+",
      "comment": "Should I use `@skipIf` or current implementation is fine for tests to be skipped?",
      "comment_id": 456796747,
      "user": "akshaysharmajs",
      "created_at": "2020-07-18T14:46:15Z",
      "url": "https://github.com/scrapy/scrapy/pull/4646#discussion_r456796747"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 4646,
      "file_path": "tests/test_commands.py",
      "line": 362,
      "side": "RIGHT",
      "diff_hunk": "@@ -339,10 +339,27 @@ class WindowsRunSpiderCommandTest(RunSpiderCommandTest):\n     spider_filename = 'myspider.pyw'\n \n     def setUp(self):\n-        if platform != 'win32':\n-            raise unittest.SkipTest(\".pyw file extension only supported in Windows\")\n         super(WindowsRunSpiderCommandTest, self).setUp()\n \n+    if platform != 'win32':\n+        def test_run_good_spider(self):\n+            raise unittest.SkipTest(\"Windows required\")\n+\n+        def test_runspider(self):\n+            raise unittest.SkipTest(\"Windows required\")\n+\n+        def test_runspider_dnscache_disabled(self):\n+            raise unittest.SkipTest(\"Windows required\")\n+\n+        def test_runspider_log_level(self):\n+            raise unittest.SkipTest(\"Windows required\")\n+\n+        def test_runspider_log_short_names(self):\n+            raise unittest.SkipTest(\"Windows required\")\n+\n+        def test_runspider_no_spider_found(self):\n+            raise unittest.SkipTest(\"Windows required\")\n+",
      "comment": "I think you should use a decorator, `if` statements for method definition seem rather unidiomatic.\r\n\r\nI wonder if you can use a skipping decorator or similar at the class level, though.",
      "comment_id": 461483654,
      "user": "Gallaecio",
      "created_at": "2020-07-28T10:35:40Z",
      "url": "https://github.com/scrapy/scrapy/pull/4646#discussion_r461483654"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 4814,
      "file_path": "setup.py",
      "line": 27,
      "side": "LEFT",
      "diff_hunk": "@@ -24,7 +24,6 @@ def has_environment_marker_platform_impl_support():\n     'cssselect>=0.9.1',\n     'itemloaders>=1.0.1',\n     'parsel>=1.5.0',\n-    'PyDispatcher>=2.0.5',",
      "comment": "Does it mean that if `has_environment_marker_platform_impl_support()` rerturns False, than PyDispatcher is not installed? ",
      "comment_id": 507238169,
      "user": "kmike",
      "created_at": "2020-10-18T22:55:55Z",
      "url": "https://github.com/scrapy/scrapy/pull/4814#discussion_r507238169"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 4814,
      "file_path": "setup.py",
      "line": 27,
      "side": "LEFT",
      "diff_hunk": "@@ -24,7 +24,6 @@ def has_environment_marker_platform_impl_support():\n     'cssselect>=0.9.1',\n     'itemloaders>=1.0.1',\n     'parsel>=1.5.0',\n-    'PyDispatcher>=2.0.5',",
      "comment": "Oops, right, we also need to add `'PyDispatcher>=2.0.5'` in the `else` below, nice catch! :sweat_smile: \r\n\r\nMaybe we could refactor a bit so that we define the CPython-specific dependencies as a variable, and use that in both places of the `if` statement, to reduce the chance of similar mistakes in the future.",
      "comment_id": 511587956,
      "user": "Gallaecio",
      "created_at": "2020-10-25T12:07:32Z",
      "url": "https://github.com/scrapy/scrapy/pull/4814#discussion_r511587956"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 4814,
      "file_path": "setup.py",
      "line": 27,
      "side": "LEFT",
      "diff_hunk": "@@ -24,7 +24,6 @@ def has_environment_marker_platform_impl_support():\n     'cssselect>=0.9.1',\n     'itemloaders>=1.0.1',\n     'parsel>=1.5.0',\n-    'PyDispatcher>=2.0.5',",
      "comment": "Nice catch, and great suggestion. Due to some circumstances, I am currently unable to do the suggestion in the near future though.",
      "comment_id": 511918806,
      "user": "dswij",
      "created_at": "2020-10-26T12:22:11Z",
      "url": "https://github.com/scrapy/scrapy/pull/4814#discussion_r511918806"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 4300,
      "file_path": "scrapy/utils/project.py",
      "line": 73,
      "side": "RIGHT",
      "diff_hunk": "@@ -68,18 +66,10 @@ def get_project_settings():\n     if settings_module_path:\n         settings.setmodule(settings_module_path, priority='project')\n \n-    # XXX: remove this hack\n-    pickled_settings = os.environ.get(\"SCRAPY_PICKLED_SETTINGS_TO_OVERRIDE\")\n-    if pickled_settings:\n-        warnings.warn(\"Use of environment variable \"\n-                      \"'SCRAPY_PICKLED_SETTINGS_TO_OVERRIDE' \"\n-                      \"is deprecated.\", ScrapyDeprecationWarning)\n-        settings.setdict(pickle.loads(pickled_settings), priority='project')\n-\n-    # XXX: deprecate and remove this functionality\n+    # XXX: deprecating the block below\n     env_overrides = {k[7:]: v for k, v in os.environ.items() if\n                      k.startswith('SCRAPY_')}\n     if env_overrides:\n+        warnings.warn(\"Use of environment variable 'SCRAPY_' is deprecated.\", ScrapyDeprecationWarning)",
      "comment": "I'd rephrase this a bit to clearly indicate the purpose of the variables. Something like `Use of 'SCRAPY_'-prefixed environment variables to override settings is deprecated`",
      "comment_id": 375873279,
      "user": "elacuesta",
      "created_at": "2020-02-06T14:43:00Z",
      "url": "https://github.com/scrapy/scrapy/pull/4300#discussion_r375873279"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 4300,
      "file_path": "scrapy/utils/project.py",
      "line": 73,
      "side": "RIGHT",
      "diff_hunk": "@@ -68,18 +66,10 @@ def get_project_settings():\n     if settings_module_path:\n         settings.setmodule(settings_module_path, priority='project')\n \n-    # XXX: remove this hack\n-    pickled_settings = os.environ.get(\"SCRAPY_PICKLED_SETTINGS_TO_OVERRIDE\")\n-    if pickled_settings:\n-        warnings.warn(\"Use of environment variable \"\n-                      \"'SCRAPY_PICKLED_SETTINGS_TO_OVERRIDE' \"\n-                      \"is deprecated.\", ScrapyDeprecationWarning)\n-        settings.setdict(pickle.loads(pickled_settings), priority='project')\n-\n-    # XXX: deprecate and remove this functionality\n+    # XXX: deprecating the block below\n     env_overrides = {k[7:]: v for k, v in os.environ.items() if\n                      k.startswith('SCRAPY_')}\n     if env_overrides:\n+        warnings.warn(\"Use of environment variable 'SCRAPY_' is deprecated.\", ScrapyDeprecationWarning)",
      "comment": "Would `usage` be better here? I'm not a native speaker, I read a few comments about use/usage but I'm still not sure.",
      "comment_id": 375877156,
      "user": "elacuesta",
      "created_at": "2020-02-06T14:49:11Z",
      "url": "https://github.com/scrapy/scrapy/pull/4300#discussion_r375877156"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 4300,
      "file_path": "scrapy/utils/project.py",
      "line": 76,
      "side": "RIGHT",
      "diff_hunk": "@@ -68,18 +68,16 @@ def get_project_settings():\n     if settings_module_path:\n         settings.setmodule(settings_module_path, priority='project')\n \n-    # XXX: remove this hack\n     pickled_settings = os.environ.get(\"SCRAPY_PICKLED_SETTINGS_TO_OVERRIDE\")\n     if pickled_settings:\n         warnings.warn(\"Use of environment variable \"\n                       \"'SCRAPY_PICKLED_SETTINGS_TO_OVERRIDE' \"\n                       \"is deprecated.\", ScrapyDeprecationWarning)\n-        settings.setdict(pickle.loads(pickled_settings), priority='project')\n+    settings.setdict(pickle.loads(pickled_settings), priority='project')",
      "comment": "I\u2019m guessing this indentation change was accidental :)",
      "comment_id": 377254990,
      "user": "Gallaecio",
      "created_at": "2020-02-10T19:00:24Z",
      "url": "https://github.com/scrapy/scrapy/pull/4300#discussion_r377254990"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 4300,
      "file_path": "scrapy/utils/project.py",
      "line": 76,
      "side": "RIGHT",
      "diff_hunk": "@@ -68,18 +68,16 @@ def get_project_settings():\n     if settings_module_path:\n         settings.setmodule(settings_module_path, priority='project')\n \n-    # XXX: remove this hack\n     pickled_settings = os.environ.get(\"SCRAPY_PICKLED_SETTINGS_TO_OVERRIDE\")\n     if pickled_settings:\n         warnings.warn(\"Use of environment variable \"\n                       \"'SCRAPY_PICKLED_SETTINGS_TO_OVERRIDE' \"\n                       \"is deprecated.\", ScrapyDeprecationWarning)\n-        settings.setdict(pickle.loads(pickled_settings), priority='project')\n+    settings.setdict(pickle.loads(pickled_settings), priority='project')",
      "comment": "```suggestion\r\n        settings.setdict(pickle.loads(pickled_settings), priority='project')\r\n```",
      "comment_id": 377267432,
      "user": "elacuesta",
      "created_at": "2020-02-10T19:25:02Z",
      "url": "https://github.com/scrapy/scrapy/pull/4300#discussion_r377267432"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 4899,
      "file_path": "docs/conf.py",
      "line": 294,
      "side": "RIGHT",
      "diff_hunk": "@@ -291,6 +291,7 @@\n     'tox': ('https://tox.readthedocs.io/en/latest', None),\n     'twisted': ('https://twistedmatrix.com/documents/current', None),\n     'twistedapi': ('https://twistedmatrix.com/documents/current/api', None),\n+    'cryptography' : ('https://cryptography.io/en/latest/', None),",
      "comment": ":lipstick: Let\u2019s keep these entries alphabetical :nerd_face: ",
      "comment_id": 532609259,
      "user": "Gallaecio",
      "created_at": "2020-11-30T13:49:25Z",
      "url": "https://github.com/scrapy/scrapy/pull/4899#discussion_r532609259"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 4900,
      "file_path": "scrapy/utils/spider.py",
      "line": 17,
      "side": "LEFT",
      "diff_hunk": "@@ -4,17 +4,14 @@\n from scrapy.spiders import Spider\n from scrapy.utils.defer import deferred_from_coro\n from scrapy.utils.misc import arg_to_iter\n-try:\n-    from scrapy.utils.py36 import collect_asyncgen\n-except SyntaxError:\n-    collect_asyncgen = None\n+from scrapy.utils.python import collect_asyncgen\n \n \n logger = logging.getLogger(__name__)\n \n \n def iterate_spider_output(result):\n-    if collect_asyncgen and hasattr(inspect, 'isasyncgen') and inspect.isasyncgen(result):",
      "comment": "[`inspect.isasyncgen`](https://docs.python.org/3.6/library/inspect.html#inspect.isasyncgen) was added in Python 3.6",
      "comment_id": 528767349,
      "user": "elacuesta",
      "created_at": "2020-11-23T15:03:17Z",
      "url": "https://github.com/scrapy/scrapy/pull/4900#discussion_r528767349"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 4872,
      "file_path": "tests/CrawlerProcess/asyncio_deferred_signal.py",
      "line": 17,
      "side": "RIGHT",
      "diff_hunk": "@@ -0,0 +1,45 @@\n+import asyncio\n+import sys\n+\n+import scrapy\n+\n+from scrapy.crawler import CrawlerProcess\n+from twisted.internet.defer import Deferred\n+\n+\n+class UppercasePipeline:\n+    async def _open_spider(self, spider):\n+        spider.logger.info(\"async pipeline opened!\")\n+        await asyncio.sleep(0.1)\n+\n+    def open_spider(self, spider):\n+        loop = asyncio.get_event_loop()\n+        return Deferred.fromFuture(loop.create_task(self._open_spider(spider)))",
      "comment": "What do you think about using scrapy.utils.defer.deferred_from_coro or scrapy.utils.defer.deferred_f_from_coro_f here, as @wRAR suggested?",
      "comment_id": 519164294,
      "user": "kmike",
      "created_at": "2020-11-07T10:50:08Z",
      "url": "https://github.com/scrapy/scrapy/pull/4872#discussion_r519164294"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 4872,
      "file_path": "tests/CrawlerProcess/asyncio_deferred_signal.py",
      "line": 16,
      "side": "RIGHT",
      "diff_hunk": "@@ -0,0 +1,45 @@\n+import asyncio\n+import sys\n+\n+from scrapy import Spider\n+from scrapy.crawler import CrawlerProcess\n+from scrapy.utils.defer import deferred_from_coro\n+from twisted.internet.defer import Deferred\n+\n+\n+class UppercasePipeline:\n+    async def _open_spider(self, spider):\n+        spider.logger.info(\"async pipeline opened!\")\n+        await asyncio.sleep(0.1)\n+\n+    def open_spider(self, spider):\n+        loop = asyncio.get_event_loop()",
      "comment": "Good eye, it is not needed. I wonder why the flake8 check didn't fail \ud83e\udd14 ",
      "comment_id": 519968939,
      "user": "elacuesta",
      "created_at": "2020-11-09T16:57:56Z",
      "url": "https://github.com/scrapy/scrapy/pull/4872#discussion_r519968939"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 4831,
      "file_path": "scrapy/downloadermiddlewares/httpcompression.py",
      "line": 2,
      "side": "RIGHT",
      "diff_hunk": "@@ -1,4 +1,5 @@\n import zlib\n+import io",
      "comment": ":lipstick: \r\n\r\n```suggestion\r\nimport io\r\nimport zlib\r\n```",
      "comment_id": 500467744,
      "user": "Gallaecio",
      "created_at": "2020-10-06T17:20:09Z",
      "url": "https://github.com/scrapy/scrapy/pull/4831#discussion_r500467744"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 4831,
      "file_path": "scrapy/downloadermiddlewares/httpcompression.py",
      "line": 80,
      "side": "RIGHT",
      "diff_hunk": "@@ -67,4 +74,9 @@ def _decode(self, body, encoding):\n                 body = zlib.decompress(body, -15)\n         if encoding == b'br' and b'br' in ACCEPTED_ENCODINGS:\n             body = brotli.decompress(body)\n+        if encoding == b'zstd' and b'zstd' in ACCEPTED_ENCODINGS:\n+            # Using its streaming API since its simple API could handle only cases\n+            # where there is content size data embedded in the frame\n+            reader = zstandard.ZstdDecompressor().stream_reader(io.BytesIO(body))",
      "comment": "hey! I wonder if it makes sense to use a context manager, to close the reader after it is used. This is very minor, as it is not doing much (https://github.com/indygreg/python-zstandard/blob/53b71dc3f96961564c9c140bf88b0aa118589247/zstandard/cffi.py#L1937), but it still may clean up some references earlier.",
      "comment_id": 502946508,
      "user": "kmike",
      "created_at": "2020-10-11T17:59:52Z",
      "url": "https://github.com/scrapy/scrapy/pull/4831#discussion_r502946508"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 4778,
      "file_path": "tests/test_downloadermiddleware_httpproxy.py",
      "line": 130,
      "side": "RIGHT",
      "diff_hunk": "@@ -123,7 +123,11 @@ def test_proxy_already_seted(self):\n \n     def test_no_proxy(self):\n         os.environ['http_proxy'] = 'https://proxy.for.http:3128'\n+        os.environ['no_proxy'] = '/var/run/docker.sock'\n         mw = HttpProxyMiddleware()\n+        # '/var/run/docker.sock' may be used by the user for\n+        # no_proxy value but is not parseable and should be skipped\n+        assert 'no' not in mw.proxies",
      "comment": "What would you think about creating a separate method just to test this, instead of modifying an existing test method?",
      "comment_id": 484579338,
      "user": "Gallaecio",
      "created_at": "2020-09-07T22:39:51Z",
      "url": "https://github.com/scrapy/scrapy/pull/4778#discussion_r484579338"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 4778,
      "file_path": "tests/test_downloadermiddleware_httpproxy.py",
      "line": 130,
      "side": "RIGHT",
      "diff_hunk": "@@ -123,7 +123,11 @@ def test_proxy_already_seted(self):\n \n     def test_no_proxy(self):\n         os.environ['http_proxy'] = 'https://proxy.for.http:3128'\n+        os.environ['no_proxy'] = '/var/run/docker.sock'\n         mw = HttpProxyMiddleware()\n+        # '/var/run/docker.sock' may be used by the user for\n+        # no_proxy value but is not parseable and should be skipped\n+        assert 'no' not in mw.proxies",
      "comment": "Yeah that makes sense.\r\nAlso should I do anything about the multi-valued no_proxy env variable like `no_proxy=127.0.0.1,example.com,another.example.com`? `_get_proxy`  does not deal with the multiple values well.",
      "comment_id": 485140663,
      "user": "drs-11",
      "created_at": "2020-09-08T19:15:20Z",
      "url": "https://github.com/scrapy/scrapy/pull/4778#discussion_r485140663"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 4778,
      "file_path": "tests/test_downloadermiddleware_httpproxy.py",
      "line": 130,
      "side": "RIGHT",
      "diff_hunk": "@@ -123,7 +123,11 @@ def test_proxy_already_seted(self):\n \n     def test_no_proxy(self):\n         os.environ['http_proxy'] = 'https://proxy.for.http:3128'\n+        os.environ['no_proxy'] = '/var/run/docker.sock'\n         mw = HttpProxyMiddleware()\n+        # '/var/run/docker.sock' may be used by the user for\n+        # no_proxy value but is not parseable and should be skipped\n+        assert 'no' not in mw.proxies",
      "comment": "> Also should I do anything about the multi-valued no_proxy env variable like no_proxy=127.0.0.1,example.com,another.example.com? _get_proxy does not deal with the multiple values well.\r\n\r\nSince it is not necessary to fix the source issue, and it may complicate the review, I would just go ahead with the current change.\r\n\r\nI suggest that you instead simply open an issue about it, so that we do not loose track about it. And, only if you feel motivated, feel free to work on it yourself.",
      "comment_id": 486212488,
      "user": "Gallaecio",
      "created_at": "2020-09-10T09:53:24Z",
      "url": "https://github.com/scrapy/scrapy/pull/4778#discussion_r486212488"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 4817,
      "file_path": "tests/test_spidermiddleware_output_chain.py",
      "line": 61,
      "side": "LEFT",
      "diff_hunk": "@@ -56,9 +58,9 @@ class ProcessSpiderInputSpiderWithoutErrback(Spider):\n     custom_settings = {\n         'SPIDER_MIDDLEWARES': {\n             # spider\n-            __name__ + '.LogExceptionMiddleware': 10,\n-            __name__ + '.FailProcessSpiderInputMiddleware': 8,\n-            __name__ + '.LogExceptionMiddleware': 6,",
      "comment": "So it looks like it currently uses only one of these entries? :)",
      "comment_id": 498081654,
      "user": "wRAR",
      "created_at": "2020-10-01T08:45:17Z",
      "url": "https://github.com/scrapy/scrapy/pull/4817#discussion_r498081654"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 4817,
      "file_path": "tests/test_spidermiddleware_output_chain.py",
      "line": 61,
      "side": "LEFT",
      "diff_hunk": "@@ -56,9 +58,9 @@ class ProcessSpiderInputSpiderWithoutErrback(Spider):\n     custom_settings = {\n         'SPIDER_MIDDLEWARES': {\n             # spider\n-            __name__ + '.LogExceptionMiddleware': 10,\n-            __name__ + '.FailProcessSpiderInputMiddleware': 8,\n-            __name__ + '.LogExceptionMiddleware': 6,",
      "comment": "Indeed, the behaviour makes sense. The failing middleware fails in `process_spider_input` and does not define a `process_spider_exception` method, so `LogExceptionMiddleware.process_spider_exception` (the method that logs the exception) is placed at the beginning of the chain as expected. In fact, we only need one of the occurrences for the test case, I'm removing the duplicate one.\r\nNice catch, thanks for noticing!",
      "comment_id": 498286857,
      "user": "elacuesta",
      "created_at": "2020-10-01T14:26:19Z",
      "url": "https://github.com/scrapy/scrapy/pull/4817#discussion_r498286857"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 4817,
      "file_path": "tests/test_spidermiddleware_output_chain.py",
      "line": 61,
      "side": "LEFT",
      "diff_hunk": "@@ -56,9 +58,9 @@ class ProcessSpiderInputSpiderWithoutErrback(Spider):\n     custom_settings = {\n         'SPIDER_MIDDLEWARES': {\n             # spider\n-            __name__ + '.LogExceptionMiddleware': 10,\n-            __name__ + '.FailProcessSpiderInputMiddleware': 8,\n-            __name__ + '.LogExceptionMiddleware': 6,",
      "comment": "(For reference)\r\ncurrent `master` (5a386393):\r\n```\r\n  Enabled spider middlewares:\r\n['tests.test_spidermiddleware_output_chain.LogExceptionMiddleware',\r\n 'tests.test_spidermiddleware_output_chain.FailProcessSpiderInputMiddleware',\r\n 'scrapy.spidermiddlewares.httperror.HttpErrorMiddleware',\r\n 'scrapy.spidermiddlewares.offsite.OffsiteMiddleware',\r\n 'scrapy.spidermiddlewares.referer.RefererMiddleware',\r\n 'scrapy.spidermiddlewares.urllength.UrlLengthMiddleware',\r\n 'scrapy.spidermiddlewares.depth.DepthMiddleware']\r\n ```\r\n\r\ncurrent `test-classes-settings` (62394c2b):\r\n```\r\n   Enabled spider middlewares:\r\n[<class 'tests.test_spidermiddleware_output_chain.LogExceptionMiddleware'>,\r\n <class 'tests.test_spidermiddleware_output_chain.FailProcessSpiderInputMiddleware'>,\r\n 'scrapy.spidermiddlewares.httperror.HttpErrorMiddleware',\r\n 'scrapy.spidermiddlewares.offsite.OffsiteMiddleware',\r\n 'scrapy.spidermiddlewares.referer.RefererMiddleware',\r\n 'scrapy.spidermiddlewares.urllength.UrlLengthMiddleware',\r\n 'scrapy.spidermiddlewares.depth.DepthMiddleware']",
      "comment_id": 498292993,
      "user": "elacuesta",
      "created_at": "2020-10-01T14:34:21Z",
      "url": "https://github.com/scrapy/scrapy/pull/4817#discussion_r498292993"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 4775,
      "file_path": "scrapy/link.py",
      "line": 16,
      "side": "RIGHT",
      "diff_hunk": "@@ -7,7 +7,21 @@\n \n \n class Link:\n-    \"\"\"Link objects represent an extracted link by the LinkExtractor.\"\"\"\n+    \"\"\"Link objects represent an extracted link by the LinkExtractor.\n+\n+    Using the anchor tag sample below to illustrate the parameters::\n+\n+            <a href=\"/nofollow.html#foo\" rel=\"nofollow\">Dont follow this one</a>\n+\n+    :param url: the address being linked to in the anchor tag. From the sample, this is ``base_url/nofollow.html``.",
      "comment": "If `url` is meant to be an absolute URL, as it seems, I would make that explicit here (\u201caddress\u201d \u2192 \u201cabsolute URL\u201d).\r\n\r\nAs for `base_url`, I would turn it into `<base_url>` to make it a bit more obvious that it is a place holder. Alternatively, you may even consider going further, and suggest that, assuming the HTML document containing the anchor was https:/example.com/index.html, the URL would be ``https://example.com/nofollow.html``.",
      "comment_id": 487896533,
      "user": "Gallaecio",
      "created_at": "2020-09-14T13:06:23Z",
      "url": "https://github.com/scrapy/scrapy/pull/4775#discussion_r487896533"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 4775,
      "file_path": "scrapy/link.py",
      "line": 14,
      "side": "RIGHT",
      "diff_hunk": "@@ -11,9 +11,9 @@ class Link:\n \n     Using the anchor tag sample below to illustrate the parameters::\n \n-            <a href=\"/nofollow.html#foo\" rel=\"nofollow\">Dont follow this one</a>\n+            <a href=\"https://example.com/nofollow.html#foo\" rel=\"nofollow\">Dont follow this one</a>",
      "comment": "I actually think that it\u2019s good that the URL was not absolute here. We simply need to indicate, either in the preceding paragraph or in the documentation about the `url` parameter below, that the example `url` value assumes that this code comes from `https://example.com`.\r\n\r\nDirectly making this an absolute URL in the code example hides the fact that the `url` parameter in `Link` must be an absolute URL.\r\n\r\nAlthough it could be argued that saying `absolute URL` instead of `address` below should be enough to clarify that. I guess keeping the absolute URL here but indicating that below would work for me as well.",
      "comment_id": 489411499,
      "user": "Gallaecio",
      "created_at": "2020-09-16T12:51:36Z",
      "url": "https://github.com/scrapy/scrapy/pull/4775#discussion_r489411499"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 4785,
      "file_path": "scrapy/core/downloader/handlers/http2.py",
      "line": 21,
      "side": "RIGHT",
      "diff_hunk": "@@ -1,38 +1,43 @@\n import warnings\n from time import time\n-from typing import Optional\n+from typing import Optional, Type, TypeVar\n from urllib.parse import urldefrag\n \n+from twisted.internet.base import DelayedCall\n from twisted.internet.defer import Deferred\n from twisted.internet.error import TimeoutError\n from twisted.web.client import URI\n \n from scrapy.core.downloader.contextfactory import load_context_factory_from_settings\n from scrapy.core.downloader.webclient import _parse\n from scrapy.core.http2.agent import H2Agent, H2ConnectionPool, ScrapyProxyH2Agent\n+from scrapy.crawler import Crawler\n from scrapy.http import Request, Response\n from scrapy.settings import Settings\n from scrapy.spiders import Spider\n from scrapy.utils.python import to_bytes\n \n \n+H2DownloadHandlerTV = TypeVar(\"H2DownloadHandlerTV\", bound=\"H2DownloadHandler\")",
      "comment": ":lipstick: What about `H2DownloadHandlerTypeVar`, `H2DownloadHandlerOrSubclass`, or something else? It\u2019s longer, but `TV` makes me think of something else entirely :slightly_smiling_face: ",
      "comment_id": 487940573,
      "user": "Gallaecio",
      "created_at": "2020-09-14T13:56:05Z",
      "url": "https://github.com/scrapy/scrapy/pull/4785#discussion_r487940573"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 4785,
      "file_path": "scrapy/core/http2/agent.py",
      "line": 101,
      "side": "RIGHT",
      "diff_hunk": "@@ -95,16 +95,18 @@ def close_connections(self) -> None:\n \n class H2Agent:\n     def __init__(\n-        self, reactor: ReactorBase, pool: H2ConnectionPool,\n-        context_factory=BrowserLikePolicyForHTTPS(),\n-        connect_timeout: Optional[float] = None, bind_address: Optional[bytes] = None\n+        self,\n+        reactor: ReactorBase,\n+        pool: H2ConnectionPool,\n+        context_factory: Type[BrowserLikePolicyForHTTPS] = BrowserLikePolicyForHTTPS(),",
      "comment": "I\u2019m confused. The parameter is an instance, the typing data says it\u2019s the class itself.",
      "comment_id": 487948862,
      "user": "Gallaecio",
      "created_at": "2020-09-14T14:03:50Z",
      "url": "https://github.com/scrapy/scrapy/pull/4785#discussion_r487948862"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 4610,
      "file_path": "scrapy/core/http2/protocol.py",
      "line": 69,
      "side": "RIGHT",
      "diff_hunk": "@@ -66,22 +47,45 @@ def __init__(self):\n         self.is_connection_made = False\n         self._pending_request_stream_pool = []\n \n+    def _stream_close_cb(self, stream_id: int):\n+        \"\"\"Called when stream is closed completely\n+        \"\"\"\n+        try:\n+            del self.streams[stream_id]\n+        except KeyError:\n+            pass\n+\n     def _new_stream(self, request: Request):\n         \"\"\"Instantiates a new Stream object\n         \"\"\"\n-        stream = Stream(self.next_stream_id, request, self)\n+        stream_id = self.next_stream_id\n         self.next_stream_id += 2\n \n+        stream = Stream(\n+            stream_id=stream_id,\n+            request=request,\n+            connection=self.conn,\n+            write_to_transport=self._write_to_transport,\n+            cb_close=lambda: self._stream_close_cb(stream_id)",
      "comment": "This may be problematic, when using lambdas `stream_id` may not be what you expect by the time the lambda is executed. See https://docs.python.org/3/faq/programming.html#why-do-lambdas-defined-in-a-loop-with-different-values-all-return-the-same-result\r\n\r\nSince the caller of `cb_close` will know the stream ID, you may set `cb_close=self._stream_close_cb` instead and have `Stream` call `self.cb_close(self.stream_id)`.",
      "comment_id": 439859339,
      "user": "Gallaecio",
      "created_at": "2020-06-14T19:14:33Z",
      "url": "https://github.com/scrapy/scrapy/pull/4610#discussion_r439859339"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 4610,
      "file_path": "scrapy/core/http2/protocol.py",
      "line": 130,
      "side": "RIGHT",
      "diff_hunk": "@@ -100,31 +104,34 @@ def connectionMade(self):\n         \"\"\"Called by Twisted when the connection is established. We can start\n         sending some data now: we should open with the connection preamble.\n         \"\"\"\n-        LOGGER.info(\"Connection made to {}\".format(self.transport))\n+        self.destination = self.transport.connector.getDestination()\n+        LOGGER.info('Connection made to {}'.format(self.destination))\n+\n         self.conn.initiate_connection()\n         self._write_to_transport()\n-\n         self.is_connection_made = True\n \n-        # Initiate all pending requests\n-        for stream in self._pending_request_stream_pool:\n-            assert isinstance(stream, Stream)\n-            stream.initiate_request()\n-\n-        self._pending_request_stream_pool.clear()\n+        self._send_pending_requests()\n \n     def dataReceived(self, data):\n         events = self.conn.receive_data(data)\n         self._handle_events(events)\n         self._write_to_transport()\n \n     def connectionLost(self, reason=connectionDone):\n-\n         \"\"\"Called by Twisted when the transport connection is lost.\n+        No need to write anything to transport here.\n         \"\"\"\n-        for stream_id in self.streams.keys():\n-            # TODO: Close each Stream instance in a clean manner\n-            self.conn.end_stream(stream_id)\n+        # Pop all streams which were pending and were not yet started\n+        for stream_id in list(self.streams):\n+            try:\n+                self.streams[stream_id].lost_connection()\n+            except KeyError:\n+                pass",
      "comment": "It looks like you could use `self.streams.values()` instead.\r\n\r\nI\u2019m not sure why `KeyError` is needed, unless `list_connection()` may raise it.",
      "comment_id": 439859749,
      "user": "Gallaecio",
      "created_at": "2020-06-14T19:20:41Z",
      "url": "https://github.com/scrapy/scrapy/pull/4610#discussion_r439859749"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 4610,
      "file_path": "scrapy/core/http2/stream.py",
      "line": 133,
      "side": "RIGHT",
      "diff_hunk": "@@ -59,26 +93,124 @@ def initiate_request(self):\n \n             # TODO: Check if scheme can be \"http\" for HTTP/2 ?\n             (\":scheme\", \"https\"),\n-            (\":path\", url.path)\n+            (\":path\", url.path),\n+\n+            # TODO: Make sure 'Content-Type' and 'Content-Encoding' headers\n+            #  are sent for request having body\n         ]\n \n-        self._conn.send_headers(self.stream_id, http2_request_headers)\n+        self._conn.send_headers(self.stream_id, http2_request_headers, end_stream=False)\n+        self._write_to_transport()\n+\n+        self.send_data()\n+\n+    def send_data(self):\n+        \"\"\"Called immediately after the headers are sent. Here we send all the\n+         data as part of the request.\n+\n+         If the content length is 0 initially then we end the stream immediately and\n+         wait for response data.\n+         \"\"\"\n+\n+        # TODO:\n+        #  1. Add test for sending very large data\n+        #  2. Add test for small data\n+        #  3. Both (1) and (2) should be tested for\n+        #    3.1 Large number of request\n+        #    3.2 Small number of requests\n+\n+        # Firstly, check what the flow control window is for current stream.\n+        window_size = self._conn.local_flow_control_window(stream_id=self.stream_id)\n+\n+        # Next, check what the maximum frame size is.\n+        max_frame_size = self._conn.max_outbound_frame_size\n+\n+        # We will send no more than the window size or the remaining file size\n+        # of data in this call, whichever is smaller.\n+        bytes_to_send = min(window_size, self.remaining_content_length)\n+\n+        # We now need to send a number of data frames.\n+        while bytes_to_send > 0:",
      "comment": ":lipstick:  `bytes_to_send_size` would be less ambiguous, more consistent with similar variables in this function, and it would allow you to make this change without making the code more confusing:\r\n\r\n```suggestion\r\n        while bytes_to_send_size:\r\n```",
      "comment_id": 439860331,
      "user": "Gallaecio",
      "created_at": "2020-06-14T19:28:37Z",
      "url": "https://github.com/scrapy/scrapy/pull/4610#discussion_r439860331"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 4610,
      "file_path": "scrapy/core/http2/stream.py",
      "line": 143,
      "side": "RIGHT",
      "diff_hunk": "@@ -59,26 +93,124 @@ def initiate_request(self):\n \n             # TODO: Check if scheme can be \"http\" for HTTP/2 ?\n             (\":scheme\", \"https\"),\n-            (\":path\", url.path)\n+            (\":path\", url.path),\n+\n+            # TODO: Make sure 'Content-Type' and 'Content-Encoding' headers\n+            #  are sent for request having body\n         ]\n \n-        self._conn.send_headers(self.stream_id, http2_request_headers)\n+        self._conn.send_headers(self.stream_id, http2_request_headers, end_stream=False)\n+        self._write_to_transport()\n+\n+        self.send_data()\n+\n+    def send_data(self):\n+        \"\"\"Called immediately after the headers are sent. Here we send all the\n+         data as part of the request.\n+\n+         If the content length is 0 initially then we end the stream immediately and\n+         wait for response data.\n+         \"\"\"\n+\n+        # TODO:\n+        #  1. Add test for sending very large data\n+        #  2. Add test for small data\n+        #  3. Both (1) and (2) should be tested for\n+        #    3.1 Large number of request\n+        #    3.2 Small number of requests\n+\n+        # Firstly, check what the flow control window is for current stream.\n+        window_size = self._conn.local_flow_control_window(stream_id=self.stream_id)\n+\n+        # Next, check what the maximum frame size is.\n+        max_frame_size = self._conn.max_outbound_frame_size\n+\n+        # We will send no more than the window size or the remaining file size\n+        # of data in this call, whichever is smaller.\n+        bytes_to_send = min(window_size, self.remaining_content_length)\n+\n+        # We now need to send a number of data frames.\n+        while bytes_to_send > 0:\n+            chunk_size = min(bytes_to_send, max_frame_size)\n+\n+            data_chunk_start = self.content_length - self.remaining_content_length\n+            data_chunk = self._request_body[data_chunk_start:data_chunk_start + chunk_size]\n \n-    def receive_data(self, data: bytes):\n+            self._conn.send_data(self.stream_id, data_chunk, end_stream=False)\n+            self._write_to_transport()\n+\n+            bytes_to_send = max(0, bytes_to_send - chunk_size)\n+            self.remaining_content_length = max(0, self.remaining_content_length - chunk_size)",
      "comment": "Given the prior lines:\r\n\r\n```\r\nbytes_to_send = min(window_size, self.remaining_content_length)\r\n# \u2026\r\nchunk_size = min(bytes_to_send, max_frame_size)\r\n```\r\n\r\nI _think_ it would be safe to assume that the subtraction value will be \u22650.",
      "comment_id": 439860809,
      "user": "Gallaecio",
      "created_at": "2020-06-14T19:34:20Z",
      "url": "https://github.com/scrapy/scrapy/pull/4610#discussion_r439860809"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 4610,
      "file_path": "scrapy/core/http2/protocol.py",
      "line": 130,
      "side": "RIGHT",
      "diff_hunk": "@@ -100,31 +104,34 @@ def connectionMade(self):\n         \"\"\"Called by Twisted when the connection is established. We can start\n         sending some data now: we should open with the connection preamble.\n         \"\"\"\n-        LOGGER.info(\"Connection made to {}\".format(self.transport))\n+        self.destination = self.transport.connector.getDestination()\n+        LOGGER.info('Connection made to {}'.format(self.destination))\n+\n         self.conn.initiate_connection()\n         self._write_to_transport()\n-\n         self.is_connection_made = True\n \n-        # Initiate all pending requests\n-        for stream in self._pending_request_stream_pool:\n-            assert isinstance(stream, Stream)\n-            stream.initiate_request()\n-\n-        self._pending_request_stream_pool.clear()\n+        self._send_pending_requests()\n \n     def dataReceived(self, data):\n         events = self.conn.receive_data(data)\n         self._handle_events(events)\n         self._write_to_transport()\n \n     def connectionLost(self, reason=connectionDone):\n-\n         \"\"\"Called by Twisted when the transport connection is lost.\n+        No need to write anything to transport here.\n         \"\"\"\n-        for stream_id in self.streams.keys():\n-            # TODO: Close each Stream instance in a clean manner\n-            self.conn.end_stream(stream_id)\n+        # Pop all streams which were pending and were not yet started\n+        for stream_id in list(self.streams):\n+            try:\n+                self.streams[stream_id].lost_connection()\n+            except KeyError:\n+                pass",
      "comment": ">  looks like you could use `self.streams.values()` instead.\r\n\r\nYup I tried using `self.stream.values()` at first but that gave me \"RuntimeError: Dictionary changed size during iteration\" which was because of `lost_connection()` which calls `self._stream_close_cb` which pops the element from the dictionary. I then tried [this solution](https://stackoverflow.com/questions/11941817/how-to-avoid-runtimeerror-dictionary-changed-size-during-iteration-error) which worked. \r\n\r\n> I\u2019m not sure why `KeyError` is needed, unless `list_connection()` may raise it.\r\n\r\nJust removed it and tested -- Works \ud83d\ude43",
      "comment_id": 439879221,
      "user": "adityaa30",
      "created_at": "2020-06-14T23:37:56Z",
      "url": "https://github.com/scrapy/scrapy/pull/4610#discussion_r439879221"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 4610,
      "file_path": "scrapy/core/http2/stream.py",
      "line": 143,
      "side": "RIGHT",
      "diff_hunk": "@@ -59,26 +93,124 @@ def initiate_request(self):\n \n             # TODO: Check if scheme can be \"http\" for HTTP/2 ?\n             (\":scheme\", \"https\"),\n-            (\":path\", url.path)\n+            (\":path\", url.path),\n+\n+            # TODO: Make sure 'Content-Type' and 'Content-Encoding' headers\n+            #  are sent for request having body\n         ]\n \n-        self._conn.send_headers(self.stream_id, http2_request_headers)\n+        self._conn.send_headers(self.stream_id, http2_request_headers, end_stream=False)\n+        self._write_to_transport()\n+\n+        self.send_data()\n+\n+    def send_data(self):\n+        \"\"\"Called immediately after the headers are sent. Here we send all the\n+         data as part of the request.\n+\n+         If the content length is 0 initially then we end the stream immediately and\n+         wait for response data.\n+         \"\"\"\n+\n+        # TODO:\n+        #  1. Add test for sending very large data\n+        #  2. Add test for small data\n+        #  3. Both (1) and (2) should be tested for\n+        #    3.1 Large number of request\n+        #    3.2 Small number of requests\n+\n+        # Firstly, check what the flow control window is for current stream.\n+        window_size = self._conn.local_flow_control_window(stream_id=self.stream_id)\n+\n+        # Next, check what the maximum frame size is.\n+        max_frame_size = self._conn.max_outbound_frame_size\n+\n+        # We will send no more than the window size or the remaining file size\n+        # of data in this call, whichever is smaller.\n+        bytes_to_send = min(window_size, self.remaining_content_length)\n+\n+        # We now need to send a number of data frames.\n+        while bytes_to_send > 0:\n+            chunk_size = min(bytes_to_send, max_frame_size)\n+\n+            data_chunk_start = self.content_length - self.remaining_content_length\n+            data_chunk = self._request_body[data_chunk_start:data_chunk_start + chunk_size]\n \n-    def receive_data(self, data: bytes):\n+            self._conn.send_data(self.stream_id, data_chunk, end_stream=False)\n+            self._write_to_transport()\n+\n+            bytes_to_send = max(0, bytes_to_send - chunk_size)\n+            self.remaining_content_length = max(0, self.remaining_content_length - chunk_size)",
      "comment": "> I think it would be safe to assume that the subtraction value will be \u22650.\r\n\r\nIt's valid only if `chunk_size` is an integer multiple of both `bytes_to_send` and `self.remaining_content_length`. I removed the `min` though and changed to [this](https://github.com/scrapy/scrapy/pull/4610/commits/01ad8b31ab7fe86fd78a70b09a6dd61a497e0ccb#diff-f9b3d5f8359fe602b12d142e3ed2ace6R143-R148) in 01ad8b31ab7fe86fd78a70b09a6dd61a497e0ccb. ",
      "comment_id": 439880051,
      "user": "adityaa30",
      "created_at": "2020-06-14T23:47:43Z",
      "url": "https://github.com/scrapy/scrapy/pull/4610#discussion_r439880051"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 4610,
      "file_path": "scrapy/core/http2/protocol.py",
      "line": 124,
      "side": "RIGHT",
      "diff_hunk": "@@ -0,0 +1,183 @@\n+import logging\n+\n+from h2.config import H2Configuration\n+from h2.connection import H2Connection\n+from h2.events import (\n+    ConnectionTerminated, DataReceived, ResponseReceived,\n+    StreamEnded, StreamReset, WindowUpdated\n+)\n+from twisted.internet.protocol import connectionDone, Protocol\n+\n+from scrapy.core.http2.stream import Stream\n+from scrapy.http import Request\n+\n+LOGGER = logging.getLogger(__name__)\n+\n+\n+class H2ClientProtocol(Protocol):\n+    # TODO:\n+    #  1. Check for user-agent while testing\n+    #  2. Add support for cookies\n+    #  3. Handle priority updates (Not required)\n+    #  4. Handle case when received events have StreamID = 0 (applied to H2Connection)\n+    #  1 & 2:\n+    #   - Automatically handled by the Request middleware\n+    #   - request.headers will have 'Set-Cookie' value\n+\n+    def __init__(self):\n+        config = H2Configuration(client_side=True, header_encoding='utf-8')\n+        self.conn = H2Connection(config=config)\n+\n+        # Address of the server we are connected to\n+        # these are updated when connection is successfully made\n+        self.destination = None\n+\n+        # ID of the next request stream\n+        # Following the convention made by hyper-h2 each client ID\n+        # will be odd.\n+        self.next_stream_id = 1\n+\n+        # Streams are stored in a dictionary keyed off their stream IDs\n+        self.streams = {}\n+\n+        # Boolean to keep track the connection is made\n+        # If requests are received before connection is made\n+        # we keep all requests in a pool and send them as the connection\n+        # is made\n+        self.is_connection_made = False\n+        self._pending_request_stream_pool = []\n+\n+    def _stream_close_cb(self, stream_id: int):\n+        \"\"\"Called when stream is closed completely\n+        \"\"\"\n+        self.streams.pop(stream_id, None)\n+\n+    def _new_stream(self, request: Request):\n+        \"\"\"Instantiates a new Stream object\n+        \"\"\"\n+        stream_id = self.next_stream_id\n+        self.next_stream_id += 2\n+\n+        stream = Stream(\n+            stream_id=stream_id,\n+            request=request,\n+            connection=self.conn,\n+            write_to_transport=self._write_to_transport,\n+            cb_close=self._stream_close_cb\n+        )\n+\n+        self.streams[stream.stream_id] = stream\n+        return stream\n+\n+    def _send_pending_requests(self):\n+        # TODO: handle MAX_CONCURRENT_STREAMS\n+        # Initiate all pending requests\n+        for stream in self._pending_request_stream_pool:\n+            stream.initiate_request()\n+\n+        self._pending_request_stream_pool.clear()\n+\n+    def _write_to_transport(self):\n+        \"\"\" Write data to the underlying transport connection\n+        from the HTTP2 connection instance if any\n+        \"\"\"\n+        data = self.conn.data_to_send()\n+        self.transport.write(data)\n+\n+    def request(self, _request: Request):\n+        stream = self._new_stream(_request)\n+        d = stream.get_response()\n+\n+        # If connection is not yet established then add the\n+        # stream to pool or initiate request\n+        if self.is_connection_made:\n+            stream.initiate_request()\n+        else:\n+            self._pending_request_stream_pool.append(stream)\n+\n+        return d\n+\n+    def connectionMade(self):\n+        \"\"\"Called by Twisted when the connection is established. We can start\n+        sending some data now: we should open with the connection preamble.\n+        \"\"\"\n+        self.destination = self.transport.connector.getDestination()\n+        LOGGER.info('Connection made to {}'.format(self.destination))\n+\n+        self.conn.initiate_connection()\n+        self._write_to_transport()\n+        self.is_connection_made = True\n+\n+        self._send_pending_requests()\n+\n+    def dataReceived(self, data):\n+        events = self.conn.receive_data(data)\n+        self._handle_events(events)\n+        self._write_to_transport()\n+\n+    def connectionLost(self, reason=connectionDone):\n+        \"\"\"Called by Twisted when the transport connection is lost.\n+        No need to write anything to transport here.\n+        \"\"\"\n+        # Pop all streams which were pending and were not yet started\n+        for stream_id in list(self.streams):\n+            self.streams[stream_id].lost_connection()",
      "comment": "I must say things seem a bit overcomplicated. It is weird that `protocol.streams[n].lost_connection()` pops `protocol.streams[n]` (through a callback).\r\n\r\nAny reason not to make it simpler?\r\n\r\n```suggestion\r\n        for stream in self.streams.values():\r\n            stream.stream_closed_server = True\r\n        self.streams = {}\r\n```\r\n\r\nGiven the protocol is the one that calls `reset`, `lost_connection` and `end_stream`, the callback approach seems unnecessary, at least given the current code.",
      "comment_id": 440006977,
      "user": "Gallaecio",
      "created_at": "2020-06-15T08:20:54Z",
      "url": "https://github.com/scrapy/scrapy/pull/4610#discussion_r440006977"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 4610,
      "file_path": "scrapy/core/http2/protocol.py",
      "line": 48,
      "side": "RIGHT",
      "diff_hunk": "@@ -0,0 +1,183 @@\n+import logging\n+\n+from h2.config import H2Configuration\n+from h2.connection import H2Connection\n+from h2.events import (\n+    ConnectionTerminated, DataReceived, ResponseReceived,\n+    StreamEnded, StreamReset, WindowUpdated\n+)\n+from twisted.internet.protocol import connectionDone, Protocol\n+\n+from scrapy.core.http2.stream import Stream\n+from scrapy.http import Request\n+\n+LOGGER = logging.getLogger(__name__)\n+\n+\n+class H2ClientProtocol(Protocol):\n+    # TODO:\n+    #  1. Check for user-agent while testing\n+    #  2. Add support for cookies\n+    #  3. Handle priority updates (Not required)\n+    #  4. Handle case when received events have StreamID = 0 (applied to H2Connection)\n+    #  1 & 2:\n+    #   - Automatically handled by the Request middleware\n+    #   - request.headers will have 'Set-Cookie' value\n+\n+    def __init__(self):\n+        config = H2Configuration(client_side=True, header_encoding='utf-8')\n+        self.conn = H2Connection(config=config)\n+\n+        # Address of the server we are connected to\n+        # these are updated when connection is successfully made\n+        self.destination = None\n+\n+        # ID of the next request stream\n+        # Following the convention made by hyper-h2 each client ID\n+        # will be odd.\n+        self.next_stream_id = 1\n+\n+        # Streams are stored in a dictionary keyed off their stream IDs\n+        self.streams = {}\n+\n+        # Boolean to keep track the connection is made\n+        # If requests are received before connection is made\n+        # we keep all requests in a pool and send them as the connection\n+        # is made\n+        self.is_connection_made = False\n+        self._pending_request_stream_pool = []",
      "comment": "Have you considered using a [deque](https://docs.python.org/3.8/library/collections.html#collections.deque) here?",
      "comment_id": 440010480,
      "user": "Gallaecio",
      "created_at": "2020-06-15T08:26:43Z",
      "url": "https://github.com/scrapy/scrapy/pull/4610#discussion_r440010480"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 4610,
      "file_path": "scrapy/core/http2/protocol.py",
      "line": 38,
      "side": "RIGHT",
      "diff_hunk": "@@ -0,0 +1,183 @@\n+import logging\n+\n+from h2.config import H2Configuration\n+from h2.connection import H2Connection\n+from h2.events import (\n+    ConnectionTerminated, DataReceived, ResponseReceived,\n+    StreamEnded, StreamReset, WindowUpdated\n+)\n+from twisted.internet.protocol import connectionDone, Protocol\n+\n+from scrapy.core.http2.stream import Stream\n+from scrapy.http import Request\n+\n+LOGGER = logging.getLogger(__name__)\n+\n+\n+class H2ClientProtocol(Protocol):\n+    # TODO:\n+    #  1. Check for user-agent while testing\n+    #  2. Add support for cookies\n+    #  3. Handle priority updates (Not required)\n+    #  4. Handle case when received events have StreamID = 0 (applied to H2Connection)\n+    #  1 & 2:\n+    #   - Automatically handled by the Request middleware\n+    #   - request.headers will have 'Set-Cookie' value\n+\n+    def __init__(self):\n+        config = H2Configuration(client_side=True, header_encoding='utf-8')\n+        self.conn = H2Connection(config=config)\n+\n+        # Address of the server we are connected to\n+        # these are updated when connection is successfully made\n+        self.destination = None\n+\n+        # ID of the next request stream\n+        # Following the convention made by hyper-h2 each client ID\n+        # will be odd.\n+        self.next_stream_id = 1",
      "comment": "If you use [itertools.count](https://docs.python.org/3.8/library/itertools.html#itertools.count) as a value here, you can get new stream IDs a bit simpler:\r\n\r\n```\r\nstream_id = next(self.stream_id_count)\r\n```",
      "comment_id": 440012838,
      "user": "Gallaecio",
      "created_at": "2020-06-15T08:30:49Z",
      "url": "https://github.com/scrapy/scrapy/pull/4610#discussion_r440012838"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 4610,
      "file_path": "scrapy/core/http2/protocol.py",
      "line": 65,
      "side": "RIGHT",
      "diff_hunk": "@@ -0,0 +1,183 @@\n+import logging\n+\n+from h2.config import H2Configuration\n+from h2.connection import H2Connection\n+from h2.events import (\n+    ConnectionTerminated, DataReceived, ResponseReceived,\n+    StreamEnded, StreamReset, WindowUpdated\n+)\n+from twisted.internet.protocol import connectionDone, Protocol\n+\n+from scrapy.core.http2.stream import Stream\n+from scrapy.http import Request\n+\n+LOGGER = logging.getLogger(__name__)\n+\n+\n+class H2ClientProtocol(Protocol):\n+    # TODO:\n+    #  1. Check for user-agent while testing\n+    #  2. Add support for cookies\n+    #  3. Handle priority updates (Not required)\n+    #  4. Handle case when received events have StreamID = 0 (applied to H2Connection)\n+    #  1 & 2:\n+    #   - Automatically handled by the Request middleware\n+    #   - request.headers will have 'Set-Cookie' value\n+\n+    def __init__(self):\n+        config = H2Configuration(client_side=True, header_encoding='utf-8')\n+        self.conn = H2Connection(config=config)\n+\n+        # Address of the server we are connected to\n+        # these are updated when connection is successfully made\n+        self.destination = None\n+\n+        # ID of the next request stream\n+        # Following the convention made by hyper-h2 each client ID\n+        # will be odd.\n+        self.next_stream_id = 1\n+\n+        # Streams are stored in a dictionary keyed off their stream IDs\n+        self.streams = {}\n+\n+        # Boolean to keep track the connection is made\n+        # If requests are received before connection is made\n+        # we keep all requests in a pool and send them as the connection\n+        # is made\n+        self.is_connection_made = False\n+        self._pending_request_stream_pool = []\n+\n+    def _stream_close_cb(self, stream_id: int):\n+        \"\"\"Called when stream is closed completely\n+        \"\"\"\n+        self.streams.pop(stream_id, None)\n+\n+    def _new_stream(self, request: Request):\n+        \"\"\"Instantiates a new Stream object\n+        \"\"\"\n+        stream_id = self.next_stream_id\n+        self.next_stream_id += 2\n+\n+        stream = Stream(\n+            stream_id=stream_id,\n+            request=request,\n+            connection=self.conn,\n+            write_to_transport=self._write_to_transport,",
      "comment": "Any reason to use this callback instead of giving the stream direct access to `self.transport`? It looks like `self.conn` and `self.transport` is all the stream needs from the protocol to write into the transport, and you are already passing `self.conn`.",
      "comment_id": 440018404,
      "user": "Gallaecio",
      "created_at": "2020-06-15T08:40:44Z",
      "url": "https://github.com/scrapy/scrapy/pull/4610#discussion_r440018404"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 4610,
      "file_path": "scrapy/core/http2/protocol.py",
      "line": 173,
      "side": "RIGHT",
      "diff_hunk": "@@ -0,0 +1,183 @@\n+import logging\n+\n+from h2.config import H2Configuration\n+from h2.connection import H2Connection\n+from h2.events import (\n+    ConnectionTerminated, DataReceived, ResponseReceived,\n+    StreamEnded, StreamReset, WindowUpdated\n+)\n+from twisted.internet.protocol import connectionDone, Protocol\n+\n+from scrapy.core.http2.stream import Stream\n+from scrapy.http import Request\n+\n+LOGGER = logging.getLogger(__name__)\n+\n+\n+class H2ClientProtocol(Protocol):\n+    # TODO:\n+    #  1. Check for user-agent while testing\n+    #  2. Add support for cookies\n+    #  3. Handle priority updates (Not required)\n+    #  4. Handle case when received events have StreamID = 0 (applied to H2Connection)\n+    #  1 & 2:\n+    #   - Automatically handled by the Request middleware\n+    #   - request.headers will have 'Set-Cookie' value\n+\n+    def __init__(self):\n+        config = H2Configuration(client_side=True, header_encoding='utf-8')\n+        self.conn = H2Connection(config=config)\n+\n+        # Address of the server we are connected to\n+        # these are updated when connection is successfully made\n+        self.destination = None\n+\n+        # ID of the next request stream\n+        # Following the convention made by hyper-h2 each client ID\n+        # will be odd.\n+        self.next_stream_id = 1\n+\n+        # Streams are stored in a dictionary keyed off their stream IDs\n+        self.streams = {}\n+\n+        # Boolean to keep track the connection is made\n+        # If requests are received before connection is made\n+        # we keep all requests in a pool and send them as the connection\n+        # is made\n+        self.is_connection_made = False\n+        self._pending_request_stream_pool = []\n+\n+    def _stream_close_cb(self, stream_id: int):\n+        \"\"\"Called when stream is closed completely\n+        \"\"\"\n+        self.streams.pop(stream_id, None)\n+\n+    def _new_stream(self, request: Request):\n+        \"\"\"Instantiates a new Stream object\n+        \"\"\"\n+        stream_id = self.next_stream_id\n+        self.next_stream_id += 2\n+\n+        stream = Stream(\n+            stream_id=stream_id,\n+            request=request,\n+            connection=self.conn,\n+            write_to_transport=self._write_to_transport,\n+            cb_close=self._stream_close_cb\n+        )\n+\n+        self.streams[stream.stream_id] = stream\n+        return stream\n+\n+    def _send_pending_requests(self):\n+        # TODO: handle MAX_CONCURRENT_STREAMS\n+        # Initiate all pending requests\n+        for stream in self._pending_request_stream_pool:\n+            stream.initiate_request()\n+\n+        self._pending_request_stream_pool.clear()\n+\n+    def _write_to_transport(self):\n+        \"\"\" Write data to the underlying transport connection\n+        from the HTTP2 connection instance if any\n+        \"\"\"\n+        data = self.conn.data_to_send()\n+        self.transport.write(data)\n+\n+    def request(self, _request: Request):\n+        stream = self._new_stream(_request)\n+        d = stream.get_response()\n+\n+        # If connection is not yet established then add the\n+        # stream to pool or initiate request\n+        if self.is_connection_made:\n+            stream.initiate_request()\n+        else:\n+            self._pending_request_stream_pool.append(stream)\n+\n+        return d\n+\n+    def connectionMade(self):\n+        \"\"\"Called by Twisted when the connection is established. We can start\n+        sending some data now: we should open with the connection preamble.\n+        \"\"\"\n+        self.destination = self.transport.connector.getDestination()\n+        LOGGER.info('Connection made to {}'.format(self.destination))\n+\n+        self.conn.initiate_connection()\n+        self._write_to_transport()\n+        self.is_connection_made = True\n+\n+        self._send_pending_requests()\n+\n+    def dataReceived(self, data):\n+        events = self.conn.receive_data(data)\n+        self._handle_events(events)\n+        self._write_to_transport()\n+\n+    def connectionLost(self, reason=connectionDone):\n+        \"\"\"Called by Twisted when the transport connection is lost.\n+        No need to write anything to transport here.\n+        \"\"\"\n+        # Pop all streams which were pending and were not yet started\n+        for stream_id in list(self.streams):\n+            self.streams[stream_id].lost_connection()\n+\n+        self.conn.close_connection()\n+\n+        LOGGER.info(\"Connection lost with reason \" + str(reason))\n+\n+    def _handle_events(self, events):\n+        \"\"\"Private method which acts as a bridge between the events\n+        received from the HTTP/2 data and IH2EventsHandler\n+\n+        Arguments:\n+            events {list} -- A list of events that the remote peer\n+                triggered by sending data\n+        \"\"\"\n+        for event in events:\n+            LOGGER.debug(event)\n+            if isinstance(event, ConnectionTerminated):\n+                self.connection_terminated(event)\n+            elif isinstance(event, DataReceived):\n+                self.data_received(event)\n+            elif isinstance(event, ResponseReceived):\n+                self.response_received(event)\n+            elif isinstance(event, StreamEnded):\n+                self.stream_ended(event)\n+            elif isinstance(event, StreamReset):\n+                self.stream_reset(event)\n+            elif isinstance(event, WindowUpdated):\n+                self.window_updated(event)\n+            else:\n+                LOGGER.info(\"Received unhandled event {}\".format(event))\n+\n+    # Event handler functions starts here\n+    def connection_terminated(self, event: ConnectionTerminated):\n+        pass\n+\n+    def data_received(self, event: DataReceived):\n+        stream_id = event.stream_id\n+        self.streams[stream_id].receive_data(event.data, event.flow_controlled_length)\n+\n+    def response_received(self, event: ResponseReceived):\n+        stream_id = event.stream_id\n+        self.streams[stream_id].receive_headers(event.headers)\n+\n+    def stream_ended(self, event: StreamEnded):\n+        stream_id = event.stream_id\n+        self.streams[stream_id].end_stream()\n+\n+    def stream_reset(self, event: StreamReset):\n+        # TODO: event.stream_id was abruptly closed\n+        #  Q. What should be the response? (Failure/Partial/???)",
      "comment": "In HTTP 1.1 the behavior [depends on the `DOWNLOAD_FAIL_ON_DATALOSS` setting](https://github.com/scrapy/scrapy/blob/master/scrapy/core/downloader/handlers/http11.py#L554).",
      "comment_id": 440023245,
      "user": "Gallaecio",
      "created_at": "2020-06-15T08:48:53Z",
      "url": "https://github.com/scrapy/scrapy/pull/4610#discussion_r440023245"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 4610,
      "file_path": "scrapy/core/http2/protocol.py",
      "line": 124,
      "side": "RIGHT",
      "diff_hunk": "@@ -0,0 +1,183 @@\n+import logging\n+\n+from h2.config import H2Configuration\n+from h2.connection import H2Connection\n+from h2.events import (\n+    ConnectionTerminated, DataReceived, ResponseReceived,\n+    StreamEnded, StreamReset, WindowUpdated\n+)\n+from twisted.internet.protocol import connectionDone, Protocol\n+\n+from scrapy.core.http2.stream import Stream\n+from scrapy.http import Request\n+\n+LOGGER = logging.getLogger(__name__)\n+\n+\n+class H2ClientProtocol(Protocol):\n+    # TODO:\n+    #  1. Check for user-agent while testing\n+    #  2. Add support for cookies\n+    #  3. Handle priority updates (Not required)\n+    #  4. Handle case when received events have StreamID = 0 (applied to H2Connection)\n+    #  1 & 2:\n+    #   - Automatically handled by the Request middleware\n+    #   - request.headers will have 'Set-Cookie' value\n+\n+    def __init__(self):\n+        config = H2Configuration(client_side=True, header_encoding='utf-8')\n+        self.conn = H2Connection(config=config)\n+\n+        # Address of the server we are connected to\n+        # these are updated when connection is successfully made\n+        self.destination = None\n+\n+        # ID of the next request stream\n+        # Following the convention made by hyper-h2 each client ID\n+        # will be odd.\n+        self.next_stream_id = 1\n+\n+        # Streams are stored in a dictionary keyed off their stream IDs\n+        self.streams = {}\n+\n+        # Boolean to keep track the connection is made\n+        # If requests are received before connection is made\n+        # we keep all requests in a pool and send them as the connection\n+        # is made\n+        self.is_connection_made = False\n+        self._pending_request_stream_pool = []\n+\n+    def _stream_close_cb(self, stream_id: int):\n+        \"\"\"Called when stream is closed completely\n+        \"\"\"\n+        self.streams.pop(stream_id, None)\n+\n+    def _new_stream(self, request: Request):\n+        \"\"\"Instantiates a new Stream object\n+        \"\"\"\n+        stream_id = self.next_stream_id\n+        self.next_stream_id += 2\n+\n+        stream = Stream(\n+            stream_id=stream_id,\n+            request=request,\n+            connection=self.conn,\n+            write_to_transport=self._write_to_transport,\n+            cb_close=self._stream_close_cb\n+        )\n+\n+        self.streams[stream.stream_id] = stream\n+        return stream\n+\n+    def _send_pending_requests(self):\n+        # TODO: handle MAX_CONCURRENT_STREAMS\n+        # Initiate all pending requests\n+        for stream in self._pending_request_stream_pool:\n+            stream.initiate_request()\n+\n+        self._pending_request_stream_pool.clear()\n+\n+    def _write_to_transport(self):\n+        \"\"\" Write data to the underlying transport connection\n+        from the HTTP2 connection instance if any\n+        \"\"\"\n+        data = self.conn.data_to_send()\n+        self.transport.write(data)\n+\n+    def request(self, _request: Request):\n+        stream = self._new_stream(_request)\n+        d = stream.get_response()\n+\n+        # If connection is not yet established then add the\n+        # stream to pool or initiate request\n+        if self.is_connection_made:\n+            stream.initiate_request()\n+        else:\n+            self._pending_request_stream_pool.append(stream)\n+\n+        return d\n+\n+    def connectionMade(self):\n+        \"\"\"Called by Twisted when the connection is established. We can start\n+        sending some data now: we should open with the connection preamble.\n+        \"\"\"\n+        self.destination = self.transport.connector.getDestination()\n+        LOGGER.info('Connection made to {}'.format(self.destination))\n+\n+        self.conn.initiate_connection()\n+        self._write_to_transport()\n+        self.is_connection_made = True\n+\n+        self._send_pending_requests()\n+\n+    def dataReceived(self, data):\n+        events = self.conn.receive_data(data)\n+        self._handle_events(events)\n+        self._write_to_transport()\n+\n+    def connectionLost(self, reason=connectionDone):\n+        \"\"\"Called by Twisted when the transport connection is lost.\n+        No need to write anything to transport here.\n+        \"\"\"\n+        # Pop all streams which were pending and were not yet started\n+        for stream_id in list(self.streams):\n+            self.streams[stream_id].lost_connection()",
      "comment": "> Any reason not to make it simpler?\r\n\r\nOne of the reasons was I wanted to make code more readable and was planning to handle cases where in functins `lost_connection` and `reset` we have to fire the reponse deferred errback. Similarly for `end_stream` we have to fire response deferred callback with the response instance",
      "comment_id": 441659614,
      "user": "adityaa30",
      "created_at": "2020-06-17T16:05:29Z",
      "url": "https://github.com/scrapy/scrapy/pull/4610#discussion_r441659614"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 4610,
      "file_path": "scrapy/core/http2/protocol.py",
      "line": 65,
      "side": "RIGHT",
      "diff_hunk": "@@ -0,0 +1,183 @@\n+import logging\n+\n+from h2.config import H2Configuration\n+from h2.connection import H2Connection\n+from h2.events import (\n+    ConnectionTerminated, DataReceived, ResponseReceived,\n+    StreamEnded, StreamReset, WindowUpdated\n+)\n+from twisted.internet.protocol import connectionDone, Protocol\n+\n+from scrapy.core.http2.stream import Stream\n+from scrapy.http import Request\n+\n+LOGGER = logging.getLogger(__name__)\n+\n+\n+class H2ClientProtocol(Protocol):\n+    # TODO:\n+    #  1. Check for user-agent while testing\n+    #  2. Add support for cookies\n+    #  3. Handle priority updates (Not required)\n+    #  4. Handle case when received events have StreamID = 0 (applied to H2Connection)\n+    #  1 & 2:\n+    #   - Automatically handled by the Request middleware\n+    #   - request.headers will have 'Set-Cookie' value\n+\n+    def __init__(self):\n+        config = H2Configuration(client_side=True, header_encoding='utf-8')\n+        self.conn = H2Connection(config=config)\n+\n+        # Address of the server we are connected to\n+        # these are updated when connection is successfully made\n+        self.destination = None\n+\n+        # ID of the next request stream\n+        # Following the convention made by hyper-h2 each client ID\n+        # will be odd.\n+        self.next_stream_id = 1\n+\n+        # Streams are stored in a dictionary keyed off their stream IDs\n+        self.streams = {}\n+\n+        # Boolean to keep track the connection is made\n+        # If requests are received before connection is made\n+        # we keep all requests in a pool and send them as the connection\n+        # is made\n+        self.is_connection_made = False\n+        self._pending_request_stream_pool = []\n+\n+    def _stream_close_cb(self, stream_id: int):\n+        \"\"\"Called when stream is closed completely\n+        \"\"\"\n+        self.streams.pop(stream_id, None)\n+\n+    def _new_stream(self, request: Request):\n+        \"\"\"Instantiates a new Stream object\n+        \"\"\"\n+        stream_id = self.next_stream_id\n+        self.next_stream_id += 2\n+\n+        stream = Stream(\n+            stream_id=stream_id,\n+            request=request,\n+            connection=self.conn,\n+            write_to_transport=self._write_to_transport,",
      "comment": "Yeah so the only use of `self.transport` in `Stream` instance would be to write data into transport. So, instead of creating the same function I thought maybe passing the the `HTTP2ClientProtocol` would be better. Also, in case there are some edge cases we can directly change `HTTP2ClientProtocol._write_to_transport` to reflect changes everywhere",
      "comment_id": 441661066,
      "user": "adityaa30",
      "created_at": "2020-06-17T16:07:50Z",
      "url": "https://github.com/scrapy/scrapy/pull/4610#discussion_r441661066"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 4610,
      "file_path": "scrapy/core/http2/protocol.py",
      "line": 76,
      "side": "RIGHT",
      "diff_hunk": "@@ -72,11 +73,10 @@ def _new_stream(self, request: Request):\n     def _send_pending_requests(self):\n         # TODO: handle MAX_CONCURRENT_STREAMS\n         # Initiate all pending requests\n-        for stream in self._pending_request_stream_pool:\n+        while len(self._pending_request_stream_pool):",
      "comment": ":lipstick: \r\n\r\n```suggestion\r\n        while self._pending_request_stream_pool:\r\n```",
      "comment_id": 441680698,
      "user": "Gallaecio",
      "created_at": "2020-06-17T16:40:15Z",
      "url": "https://github.com/scrapy/scrapy/pull/4610#discussion_r441680698"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 4610,
      "file_path": "scrapy/core/http2/stream.py",
      "line": 166,
      "side": "RIGHT",
      "diff_hunk": "@@ -163,7 +163,7 @@ def receive_window_update(self, delta):\n         Arguments:\n             delta -- Window change delta\n         \"\"\"\n-        if self.remaining_content_length > 0 and not self.stream_closed_local:\n+        if self.stream_closed_local is False:",
      "comment": ":lipstick: \r\n\r\n```suggestion\r\n        if not self.stream_closed_local:\r\n```\r\n\r\nUnless it can be something else (`None`), which would be a bit confusing.",
      "comment_id": 441681999,
      "user": "Gallaecio",
      "created_at": "2020-06-17T16:42:12Z",
      "url": "https://github.com/scrapy/scrapy/pull/4610#discussion_r441681999"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 4610,
      "file_path": "scrapy/core/http2/stream.py",
      "line": 91,
      "side": "RIGHT",
      "diff_hunk": "@@ -58,20 +68,30 @@ def __init__(\n         # Flag to keep track whether the server has closed the stream\n         self.stream_closed_server = False\n \n-        # Data received frame by frame from the server is appended\n-        # and passed to the response Deferred when completely received.\n-        self._response_data = b\"\"\n-\n         # The amount of data received that counts against the flow control\n         # window\n         self._response_flow_controlled_size = 0\n \n-        # Headers received after sending the request\n-        self._response_headers = Headers({})\n+        # Private variable used to build the response\n+        # this response is then converted to appropriate Response class\n+        # passed to the response deferred callback\n+        self._response = {\n+            # Data received frame by frame from the server is appended\n+            # and passed to the response Deferred when completely received.\n+            'body': b'',\n+\n+            # Headers received after sending the request\n+            'headers': Headers({})\n+        }\n \n         # TODO: Add canceller for the Deferred below\n         self._deferred_response = Deferred()\n \n+    def __str__(self):\n+        return \"Stream(id={})\".format(self.stream_id)",
      "comment": ":lipstick: \r\n\r\n```suggestion\r\n        return \"Stream(id={})\".format(repr(self.stream_id))\r\n```",
      "comment_id": 443720102,
      "user": "Gallaecio",
      "created_at": "2020-06-22T17:34:51Z",
      "url": "https://github.com/scrapy/scrapy/pull/4610#discussion_r443720102"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 4610,
      "file_path": "scrapy/core/http2/stream.py",
      "line": 242,
      "side": "RIGHT",
      "diff_hunk": "@@ -178,47 +220,69 @@ def receive_data(self, data: bytes, flow_controlled_length: int):\n \n     def receive_headers(self, headers):\n         for name, value in headers:\n-            self._response_headers[name] = value\n-\n-    def reset(self):\n-        \"\"\"Received a RST_STREAM -- forcefully reset\"\"\"\n-        # TODO:\n-        #  Q1. Do we need to send the request again?\n-        #  Q2. What response should we send now?\n-        self.stream_closed_server = True\n-        self._cb_close(self.stream_id)\n+            self._response['headers'][name] = value\n \n-    def lost_connection(self):\n-        # TODO: Same as self.reset\n-        self.stream_closed_server = True\n-        self._cb_close(self.stream_id)\n+    def close(self, event=None):\n+        \"\"\"Based on the event sent we will handle each case.\n \n-    def end_stream(self):\n-        \"\"\"Stream is ended by the server hence no further\n+        event: StreamEnded\n+        Stream is ended by the server hence no further\n         data or headers should be expected on this stream.\n-\n         We will call the response deferred callback passing\n         the response object\n+\n+        event: StreamReset\n+        Stream reset via RST_FRAME by the upstream hence forcefully close\n+        this stream and send TODO: ?\n+\n+        event: None\n+        No event is launched -- Hence we will simply close this stream\n         \"\"\"\n+        # TODO: In case of abruptly stream close\n+        #  Q1. Do we need to send the request again?",
      "comment": "Sending requests again is something we want to be able to control from Scrapy, so that should definitely not be done here.",
      "comment_id": 443721909,
      "user": "Gallaecio",
      "created_at": "2020-06-22T17:38:17Z",
      "url": "https://github.com/scrapy/scrapy/pull/4610#discussion_r443721909"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 4610,
      "file_path": "scrapy/core/http2/stream.py",
      "line": 243,
      "side": "RIGHT",
      "diff_hunk": "@@ -178,47 +220,69 @@ def receive_data(self, data: bytes, flow_controlled_length: int):\n \n     def receive_headers(self, headers):\n         for name, value in headers:\n-            self._response_headers[name] = value\n-\n-    def reset(self):\n-        \"\"\"Received a RST_STREAM -- forcefully reset\"\"\"\n-        # TODO:\n-        #  Q1. Do we need to send the request again?\n-        #  Q2. What response should we send now?\n-        self.stream_closed_server = True\n-        self._cb_close(self.stream_id)\n+            self._response['headers'][name] = value\n \n-    def lost_connection(self):\n-        # TODO: Same as self.reset\n-        self.stream_closed_server = True\n-        self._cb_close(self.stream_id)\n+    def close(self, event=None):\n+        \"\"\"Based on the event sent we will handle each case.\n \n-    def end_stream(self):\n-        \"\"\"Stream is ended by the server hence no further\n+        event: StreamEnded\n+        Stream is ended by the server hence no further\n         data or headers should be expected on this stream.\n-\n         We will call the response deferred callback passing\n         the response object\n+\n+        event: StreamReset\n+        Stream reset via RST_FRAME by the upstream hence forcefully close\n+        this stream and send TODO: ?\n+\n+        event: None\n+        No event is launched -- Hence we will simply close this stream\n         \"\"\"\n+        # TODO: In case of abruptly stream close\n+        #  Q1. Do we need to send the request again?\n+        #  Q2. What response should we send now?",
      "comment": "None, I think. It probably makes sense to call the request errback at this point. See https://github.com/scrapy/scrapy/blob/master/scrapy/core/downloader/handlers/http11.py#L542",
      "comment_id": 443723586,
      "user": "Gallaecio",
      "created_at": "2020-06-22T17:41:21Z",
      "url": "https://github.com/scrapy/scrapy/pull/4610#discussion_r443723586"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 4610,
      "file_path": "setup.py",
      "line": 71,
      "side": "RIGHT",
      "diff_hunk": "@@ -69,6 +68,7 @@ def has_environment_marker_platform_impl_support():\n     python_requires='>=3.5.2',\n     install_requires=[\n         'Twisted>=17.9.0',\n+        'Twisted[http2]>=17.9.0'",
      "comment": "Shouldn\u2019t you replace the existing entry instead of just adding a new one?",
      "comment_id": 445700928,
      "user": "Gallaecio",
      "created_at": "2020-06-25T16:52:48Z",
      "url": "https://github.com/scrapy/scrapy/pull/4610#discussion_r445700928"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 4610,
      "file_path": "scrapy/core/http2/stream.py",
      "line": 251,
      "side": "RIGHT",
      "diff_hunk": "@@ -0,0 +1,384 @@\n+import logging\n+from enum import IntFlag, auto\n+from io import BytesIO\n+from typing import Dict\n+from urllib.parse import urlparse\n+\n+from h2.connection import H2Connection\n+from h2.errors import ErrorCodes\n+from h2.exceptions import StreamClosedError\n+from twisted.internet.defer import Deferred, CancelledError\n+from twisted.python.failure import Failure\n+from twisted.web.client import ResponseFailed\n+# for python < 3.8 -- typing.TypedDict is undefined\n+from typing_extensions import TypedDict\n+\n+from scrapy.http import Request\n+from scrapy.http.headers import Headers\n+from scrapy.responsetypes import responsetypes\n+\n+\n+class _ResponseTypedDict(TypedDict):\n+    # Data received frame by frame from the server is appended\n+    # and passed to the response Deferred when completely received.\n+    body: BytesIO\n+\n+    # The amount of data received that counts against the flow control\n+    # window\n+    flow_controlled_size: int\n+\n+    # Headers received after sending the request\n+    headers: Headers\n+\n+\n+LOGGER = logging.getLogger(__name__)\n+\n+\n+class StreamCloseReason(IntFlag):\n+    # Received a StreamEnded event\n+    ENDED = auto()\n+\n+    # Received a StreamReset event -- ended abruptly\n+    RESET = auto()\n+\n+    # Transport connection was lost\n+    CONNECTION_LOST = auto()\n+\n+    # Expected response body size is more than allowed limit\n+    MAXSIZE_EXCEEDED = auto()\n+\n+    # When the response deferred is cancelled\n+    CANCELLED = auto()\n+\n+\n+class Stream:\n+    \"\"\"Represents a single HTTP/2 Stream.\n+\n+    Stream is a bidirectional flow of bytes within an established connection,\n+    which may carry one or more messages. Handles the transfer of HTTP Headers\n+    and Data frames.\n+\n+    Role of this class is to\n+    1. Combine all the data frames\n+    \"\"\"\n+\n+    def __init__(\n+            self,\n+            stream_id: int,\n+            request: Request,\n+            connection: H2Connection,\n+            conn_metadata: Dict,\n+            write_to_transport,\n+            cb_close,\n+            download_maxsize=0,\n+            download_warnsize=0,\n+            fail_on_data_loss=True\n+    ):\n+        \"\"\"\n+        Arguments:\n+            stream_id {int} -- For one HTTP/2 connection each stream is\n+                uniquely identified by a single integer\n+            request {Request} -- HTTP request\n+            connection {H2Connection} -- HTTP/2 connection this stream belongs to.\n+            conn_metadata {Dict} -- Reference to dictionary having metadata of HTTP/2 connection\n+            write_to_transport {callable} -- Method used to write & send data to the server\n+                This method should be used whenever some frame is to be sent to the server.\n+            cb_close {callable} -- Method called when this stream is closed\n+                to notify the TCP connection instance.\n+        \"\"\"\n+        self.stream_id = stream_id\n+        self._request = request\n+        self._conn = connection\n+        self._conn_metadata = conn_metadata\n+        self._write_to_transport = write_to_transport\n+        self._cb_close = cb_close\n+\n+        self._download_maxsize = self._request.meta.get('download_maxsize', download_maxsize)\n+        self._download_warnsize = self._request.meta.get('download_warnsize', download_warnsize)\n+        self._fail_on_dataloss = self._request.meta.get('download_fail_on_dataloss', fail_on_data_loss)\n+\n+        self.request_start_time = None\n+\n+        self.content_length = 0 if self._request.body is None else len(self._request.body)\n+\n+        # Flag to keep track whether this stream has initiated the request\n+        self.request_sent = False\n+\n+        # Flag to track whether we have logged about exceeding download warnsize\n+        self._reached_warnsize = False\n+\n+        # Each time we send a data frame, we will decrease value by the amount send.\n+        self.remaining_content_length = self.content_length\n+\n+        # Flag to keep track whether we have closed this stream\n+        self.stream_closed_local = False\n+\n+        # Flag to keep track whether the server has closed the stream\n+        self.stream_closed_server = False\n+\n+        # Private variable used to build the response\n+        # this response is then converted to appropriate Response class\n+        # passed to the response deferred callback\n+        self._response: _ResponseTypedDict = {\n+            'body': BytesIO(),\n+            'flow_controlled_size': 0,\n+            'headers': Headers({})\n+        }\n+\n+        def _cancel(_):\n+            # Close this stream as gracefully as possible :)\n+            self.reset_stream(StreamCloseReason.CANCELLED)\n+\n+        self._deferred_response = Deferred(_cancel)\n+\n+    def __str__(self):\n+        return \"Stream(id={})\".format(repr(self.stream_id))\n+\n+    __repr__ = __str__\n+\n+    def get_response(self):\n+        \"\"\"Simply return a Deferred which fires when response\n+        from the asynchronous request is available\n+\n+        Returns:\n+            Deferred -- Calls the callback passing the response\n+        \"\"\"\n+        return self._deferred_response\n+\n+    def _get_request_headers(self):\n+        url = urlparse(self._request.url)\n+\n+        # Make sure pseudo-headers comes before all the other headers\n+        headers = [\n+            (':method', self._request.method),\n+            (':authority', url.netloc),\n+\n+            # TODO: Check if scheme can be 'http' for HTTP/2 ?\n+            (':scheme', 'https'),\n+            (':path', url.path),\n+        ]\n+\n+        for name, value in self._request.headers.items():\n+            headers.append((name, value[0]))\n+\n+        return headers\n+\n+    def initiate_request(self):\n+        headers = self._get_request_headers()\n+        self._conn.send_headers(self.stream_id, headers, end_stream=False)\n+        self._write_to_transport()\n+\n+        self.request_sent = True\n+\n+        self.send_data()\n+\n+    def send_data(self):\n+        \"\"\"Called immediately after the headers are sent. Here we send all the\n+         data as part of the request.\n+\n+         If the content length is 0 initially then we end the stream immediately and\n+         wait for response data.\n+\n+         Warning: Only call this method when stream not closed from client side\n+            and has initiated request already by sending HEADER frame. If not then\n+            stream will raise ProtocolError (raise by h2 state machine).\n+         \"\"\"\n+        if self.stream_closed_local:\n+            raise StreamClosedError(self.stream_id)\n+\n+        # Firstly, check what the flow control window is for current stream.\n+        window_size = self._conn.local_flow_control_window(stream_id=self.stream_id)\n+\n+        # Next, check what the maximum frame size is.\n+        max_frame_size = self._conn.max_outbound_frame_size\n+\n+        # We will send no more than the window size or the remaining file size\n+        # of data in this call, whichever is smaller.\n+        bytes_to_send_size = min(window_size, self.remaining_content_length)\n+\n+        # We now need to send a number of data frames.\n+        data_frames_sent = 0\n+        while bytes_to_send_size > 0:\n+            chunk_size = min(bytes_to_send_size, max_frame_size)\n+\n+            data_chunk_start_id = self.content_length - self.remaining_content_length\n+            data_chunk = self._request.body[data_chunk_start_id:data_chunk_start_id + chunk_size]\n+\n+            self._conn.send_data(self.stream_id, data_chunk, end_stream=False)\n+\n+            data_frames_sent += 1\n+            bytes_to_send_size = bytes_to_send_size - chunk_size\n+            self.remaining_content_length = self.remaining_content_length - chunk_size\n+\n+        self.remaining_content_length = max(0, self.remaining_content_length)\n+        LOGGER.debug(\"{} sending {}/{} data bytes ({} frames) to {}\".format(\n+            self,\n+            self.content_length - self.remaining_content_length, self.content_length,\n+            data_frames_sent,\n+            self._conn_metadata['ip_address'])\n+        )\n+\n+        # End the stream if no more data needs to be send\n+        if self.remaining_content_length == 0:\n+            self._conn.end_stream(self.stream_id)\n+\n+        # Write data to transport -- Empty the outstanding data\n+        self._write_to_transport()\n+\n+        # Q. What about the rest of the data?\n+        # Ans: Remaining Data frames will be sent when we get a WindowUpdate frame\n+\n+    def receive_window_update(self):\n+        \"\"\"Flow control window size was changed.\n+        Send data that earlier could not be sent as we were\n+        blocked behind the flow control.\n+        \"\"\"\n+        if self.remaining_content_length and not self.stream_closed_server and self.request_sent:\n+            self.send_data()\n+\n+    def receive_data(self, data: bytes, flow_controlled_length: int):\n+        self._response['body'].write(data)\n+        self._response['flow_controlled_size'] += flow_controlled_length\n+\n+        if self._download_maxsize and self._response['flow_controlled_size'] > self._download_maxsize:\n+            # Clear buffer earlier to avoid keeping data in memory for a long time\n+            self._response['body'].truncate(0)\n+            self.reset_stream(StreamCloseReason.MAXSIZE_EXCEEDED)\n+            return\n+\n+        if self._download_warnsize \\\n+                and self._response['flow_controlled_size'] > self._download_warnsize \\\n+                and not self._reached_warnsize:",
      "comment": ":lipstick: \r\n```suggestion\r\n        if (\r\n            self._download_warnsize\r\n            and self._response['flow_controlled_size'] > self._download_warnsize\r\n            and not self._reached_warnsize\r\n        ):\r\n```",
      "comment_id": 446672951,
      "user": "elacuesta",
      "created_at": "2020-06-28T16:53:30Z",
      "url": "https://github.com/scrapy/scrapy/pull/4610#discussion_r446672951"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 4610,
      "file_path": "scrapy/core/http2/stream.py",
      "line": 75,
      "side": "RIGHT",
      "diff_hunk": "@@ -0,0 +1,384 @@\n+import logging\n+from enum import IntFlag, auto\n+from io import BytesIO\n+from typing import Dict\n+from urllib.parse import urlparse\n+\n+from h2.connection import H2Connection\n+from h2.errors import ErrorCodes\n+from h2.exceptions import StreamClosedError\n+from twisted.internet.defer import Deferred, CancelledError\n+from twisted.python.failure import Failure\n+from twisted.web.client import ResponseFailed\n+# for python < 3.8 -- typing.TypedDict is undefined\n+from typing_extensions import TypedDict\n+\n+from scrapy.http import Request\n+from scrapy.http.headers import Headers\n+from scrapy.responsetypes import responsetypes\n+\n+\n+class _ResponseTypedDict(TypedDict):\n+    # Data received frame by frame from the server is appended\n+    # and passed to the response Deferred when completely received.\n+    body: BytesIO\n+\n+    # The amount of data received that counts against the flow control\n+    # window\n+    flow_controlled_size: int\n+\n+    # Headers received after sending the request\n+    headers: Headers\n+\n+\n+LOGGER = logging.getLogger(__name__)\n+\n+\n+class StreamCloseReason(IntFlag):\n+    # Received a StreamEnded event\n+    ENDED = auto()\n+\n+    # Received a StreamReset event -- ended abruptly\n+    RESET = auto()\n+\n+    # Transport connection was lost\n+    CONNECTION_LOST = auto()\n+\n+    # Expected response body size is more than allowed limit\n+    MAXSIZE_EXCEEDED = auto()\n+\n+    # When the response deferred is cancelled\n+    CANCELLED = auto()\n+\n+\n+class Stream:\n+    \"\"\"Represents a single HTTP/2 Stream.\n+\n+    Stream is a bidirectional flow of bytes within an established connection,\n+    which may carry one or more messages. Handles the transfer of HTTP Headers\n+    and Data frames.\n+\n+    Role of this class is to\n+    1. Combine all the data frames\n+    \"\"\"\n+\n+    def __init__(\n+            self,\n+            stream_id: int,\n+            request: Request,\n+            connection: H2Connection,\n+            conn_metadata: Dict,\n+            write_to_transport,\n+            cb_close,\n+            download_maxsize=0,\n+            download_warnsize=0,\n+            fail_on_data_loss=True",
      "comment": ":lipstick: \r\n```suggestion\r\n        self,\r\n        stream_id: int,\r\n        request: Request,\r\n        connection: H2Connection,\r\n        conn_metadata: Dict,\r\n        write_to_transport,\r\n        cb_close,\r\n        download_maxsize=0,\r\n        download_warnsize=0,\r\n        fail_on_data_loss=True\r\n```\r\n\r\nAlso, it would be good to add type annotations to the remaining parameters, and remove the types in the docstring.",
      "comment_id": 446673174,
      "user": "elacuesta",
      "created_at": "2020-06-28T16:55:53Z",
      "url": "https://github.com/scrapy/scrapy/pull/4610#discussion_r446673174"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 4610,
      "file_path": "scrapy/core/http2/protocol.py",
      "line": 18,
      "side": "RIGHT",
      "diff_hunk": "@@ -0,0 +1,191 @@\n+import ipaddress\n+import itertools\n+import logging\n+from collections import deque\n+\n+from h2.config import H2Configuration\n+from h2.connection import H2Connection\n+from h2.events import (\n+    DataReceived, ResponseReceived, SettingsAcknowledged,\n+    StreamEnded, StreamReset, WindowUpdated\n+)\n+from twisted.internet.protocol import connectionDone, Protocol\n+from twisted.internet.ssl import Certificate\n+\n+from scrapy.core.http2.stream import Stream, StreamCloseReason\n+from scrapy.http import Request\n+\n+LOGGER = logging.getLogger(__name__)",
      "comment": ":lipstick: \r\n```suggestion\r\n\r\nlogger = logging.getLogger(__name__)\r\n```\r\n\r\nOther occurrences of the logger would need be updated too.",
      "comment_id": 446673908,
      "user": "elacuesta",
      "created_at": "2020-06-28T17:04:00Z",
      "url": "https://github.com/scrapy/scrapy/pull/4610#discussion_r446673908"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 4610,
      "file_path": "scrapy/core/http2/protocol.py",
      "line": 95,
      "side": "RIGHT",
      "diff_hunk": "@@ -0,0 +1,191 @@\n+import ipaddress\n+import itertools\n+import logging\n+from collections import deque\n+\n+from h2.config import H2Configuration\n+from h2.connection import H2Connection\n+from h2.events import (\n+    DataReceived, ResponseReceived, SettingsAcknowledged,\n+    StreamEnded, StreamReset, WindowUpdated\n+)\n+from twisted.internet.protocol import connectionDone, Protocol\n+from twisted.internet.ssl import Certificate\n+\n+from scrapy.core.http2.stream import Stream, StreamCloseReason\n+from scrapy.http import Request\n+\n+LOGGER = logging.getLogger(__name__)\n+\n+\n+class H2ClientProtocol(Protocol):\n+    # TODO:\n+    #  1. Check for user-agent while testing\n+    #  2. Handle case when received events have StreamID = 0 (applied to H2Connection)\n+\n+    def __init__(self):\n+        config = H2Configuration(client_side=True, header_encoding='utf-8')\n+        self.conn = H2Connection(config=config)\n+\n+        # Address of the server we are connected to\n+        # these are updated when connection is successfully made\n+        self.destination = None\n+\n+        # ID of the next request stream\n+        # Following the convention made by hyper-h2 each client ID\n+        # will be odd.\n+        self.stream_id_count = itertools.count(start=1, step=2)\n+\n+        # Streams are stored in a dictionary keyed off their stream IDs\n+        self.streams = {}\n+\n+        # Boolean to keep track the connection is made\n+        # If requests are received before connection is made\n+        # we keep all requests in a pool and send them as the connection\n+        # is made\n+        self.is_connection_made = False\n+        self._pending_request_stream_pool = deque()\n+\n+        # Some meta data of this connection\n+        # initialized when connection is successfully made\n+        self._metadata = {\n+            'certificate': None,\n+            'ip_address': None\n+        }\n+\n+    def _stream_close_cb(self, stream_id: int):\n+        \"\"\"Called when stream is closed completely\n+        \"\"\"\n+        self.streams.pop(stream_id, None)\n+\n+    def _new_stream(self, request: Request):\n+        \"\"\"Instantiates a new Stream object\n+        \"\"\"\n+        stream_id = next(self.stream_id_count)\n+\n+        stream = Stream(\n+            stream_id=stream_id,\n+            request=request,\n+            connection=self.conn,\n+            conn_metadata=self._metadata,\n+            write_to_transport=self._write_to_transport,\n+            cb_close=self._stream_close_cb\n+        )\n+\n+        self.streams[stream.stream_id] = stream\n+        return stream\n+\n+    def _send_pending_requests(self):\n+        # TODO: handle MAX_CONCURRENT_STREAMS\n+        # Initiate all pending requests\n+        while self._pending_request_stream_pool:\n+            stream = self._pending_request_stream_pool.popleft()\n+            stream.initiate_request()\n+\n+    def _write_to_transport(self):\n+        \"\"\" Write data to the underlying transport connection\n+        from the HTTP2 connection instance if any\n+        \"\"\"\n+        data = self.conn.data_to_send()\n+        self.transport.write(data)\n+\n+        LOGGER.debug(\"Sent {} bytes to {} via transport\".format(len(data), self._metadata['ip_address']))\n+\n+    def request(self, _request: Request):\n+        stream = self._new_stream(_request)",
      "comment": "```suggestion\r\n    def request(self, request: Request):\r\n        stream = self._new_stream(request)\r\n```",
      "comment_id": 446674306,
      "user": "elacuesta",
      "created_at": "2020-06-28T17:07:50Z",
      "url": "https://github.com/scrapy/scrapy/pull/4610#discussion_r446674306"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 4610,
      "file_path": "scrapy/core/http2/protocol.py",
      "line": 132,
      "side": "RIGHT",
      "diff_hunk": "@@ -0,0 +1,191 @@\n+import ipaddress\n+import itertools\n+import logging\n+from collections import deque\n+\n+from h2.config import H2Configuration\n+from h2.connection import H2Connection\n+from h2.events import (\n+    DataReceived, ResponseReceived, SettingsAcknowledged,\n+    StreamEnded, StreamReset, WindowUpdated\n+)\n+from twisted.internet.protocol import connectionDone, Protocol\n+from twisted.internet.ssl import Certificate\n+\n+from scrapy.core.http2.stream import Stream, StreamCloseReason\n+from scrapy.http import Request\n+\n+LOGGER = logging.getLogger(__name__)\n+\n+\n+class H2ClientProtocol(Protocol):\n+    # TODO:\n+    #  1. Check for user-agent while testing\n+    #  2. Handle case when received events have StreamID = 0 (applied to H2Connection)\n+\n+    def __init__(self):\n+        config = H2Configuration(client_side=True, header_encoding='utf-8')\n+        self.conn = H2Connection(config=config)\n+\n+        # Address of the server we are connected to\n+        # these are updated when connection is successfully made\n+        self.destination = None\n+\n+        # ID of the next request stream\n+        # Following the convention made by hyper-h2 each client ID\n+        # will be odd.\n+        self.stream_id_count = itertools.count(start=1, step=2)\n+\n+        # Streams are stored in a dictionary keyed off their stream IDs\n+        self.streams = {}\n+\n+        # Boolean to keep track the connection is made\n+        # If requests are received before connection is made\n+        # we keep all requests in a pool and send them as the connection\n+        # is made\n+        self.is_connection_made = False\n+        self._pending_request_stream_pool = deque()\n+\n+        # Some meta data of this connection\n+        # initialized when connection is successfully made\n+        self._metadata = {\n+            'certificate': None,\n+            'ip_address': None\n+        }\n+\n+    def _stream_close_cb(self, stream_id: int):\n+        \"\"\"Called when stream is closed completely\n+        \"\"\"\n+        self.streams.pop(stream_id, None)\n+\n+    def _new_stream(self, request: Request):\n+        \"\"\"Instantiates a new Stream object\n+        \"\"\"\n+        stream_id = next(self.stream_id_count)\n+\n+        stream = Stream(\n+            stream_id=stream_id,\n+            request=request,\n+            connection=self.conn,\n+            conn_metadata=self._metadata,\n+            write_to_transport=self._write_to_transport,\n+            cb_close=self._stream_close_cb\n+        )\n+\n+        self.streams[stream.stream_id] = stream\n+        return stream\n+\n+    def _send_pending_requests(self):\n+        # TODO: handle MAX_CONCURRENT_STREAMS\n+        # Initiate all pending requests\n+        while self._pending_request_stream_pool:\n+            stream = self._pending_request_stream_pool.popleft()\n+            stream.initiate_request()\n+\n+    def _write_to_transport(self):\n+        \"\"\" Write data to the underlying transport connection\n+        from the HTTP2 connection instance if any\n+        \"\"\"\n+        data = self.conn.data_to_send()\n+        self.transport.write(data)\n+\n+        LOGGER.debug(\"Sent {} bytes to {} via transport\".format(len(data), self._metadata['ip_address']))\n+\n+    def request(self, _request: Request):\n+        stream = self._new_stream(_request)\n+        d = stream.get_response()\n+\n+        # If connection is not yet established then add the\n+        # stream to pool or initiate request\n+        if self.is_connection_made:\n+            stream.initiate_request()\n+        else:\n+            self._pending_request_stream_pool.append(stream)\n+\n+        return d\n+\n+    def connectionMade(self):\n+        \"\"\"Called by Twisted when the connection is established. We can start\n+        sending some data now: we should open with the connection preamble.\n+        \"\"\"\n+        self.destination = self.transport.getPeer()\n+        LOGGER.info('Connection made to {}'.format(self.destination))\n+\n+        self._metadata['certificate'] = Certificate(self.transport.getPeerCertificate())\n+        self._metadata['ip_address'] = ipaddress.ip_address(self.destination.host)\n+\n+        self.conn.initiate_connection()\n+        self._write_to_transport()\n+        self.is_connection_made = True\n+\n+    def dataReceived(self, data):\n+        events = self.conn.receive_data(data)\n+        self._handle_events(events)\n+        self._write_to_transport()\n+\n+    def connectionLost(self, reason=connectionDone):\n+        \"\"\"Called by Twisted when the transport connection is lost.\n+        No need to write anything to transport here.\n+        \"\"\"\n+        # Pop all streams which were pending and were not yet started\n+        for stream_id in list(self.streams):\n+            self.streams[stream_id].close(StreamCloseReason.CONNECTION_LOST, reason)",
      "comment": "```suggestion\r\n        for stream in self.streams.values():\r\n            stream.close(StreamCloseReason.CONNECTION_LOST, reason)\r\n```\r\nWould \"close\" be more accurate than \"pop\" in the above comment?",
      "comment_id": 446675347,
      "user": "elacuesta",
      "created_at": "2020-06-28T17:18:25Z",
      "url": "https://github.com/scrapy/scrapy/pull/4610#discussion_r446675347"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 4610,
      "file_path": "scrapy/core/http2/protocol.py",
      "line": 132,
      "side": "RIGHT",
      "diff_hunk": "@@ -0,0 +1,191 @@\n+import ipaddress\n+import itertools\n+import logging\n+from collections import deque\n+\n+from h2.config import H2Configuration\n+from h2.connection import H2Connection\n+from h2.events import (\n+    DataReceived, ResponseReceived, SettingsAcknowledged,\n+    StreamEnded, StreamReset, WindowUpdated\n+)\n+from twisted.internet.protocol import connectionDone, Protocol\n+from twisted.internet.ssl import Certificate\n+\n+from scrapy.core.http2.stream import Stream, StreamCloseReason\n+from scrapy.http import Request\n+\n+LOGGER = logging.getLogger(__name__)\n+\n+\n+class H2ClientProtocol(Protocol):\n+    # TODO:\n+    #  1. Check for user-agent while testing\n+    #  2. Handle case when received events have StreamID = 0 (applied to H2Connection)\n+\n+    def __init__(self):\n+        config = H2Configuration(client_side=True, header_encoding='utf-8')\n+        self.conn = H2Connection(config=config)\n+\n+        # Address of the server we are connected to\n+        # these are updated when connection is successfully made\n+        self.destination = None\n+\n+        # ID of the next request stream\n+        # Following the convention made by hyper-h2 each client ID\n+        # will be odd.\n+        self.stream_id_count = itertools.count(start=1, step=2)\n+\n+        # Streams are stored in a dictionary keyed off their stream IDs\n+        self.streams = {}\n+\n+        # Boolean to keep track the connection is made\n+        # If requests are received before connection is made\n+        # we keep all requests in a pool and send them as the connection\n+        # is made\n+        self.is_connection_made = False\n+        self._pending_request_stream_pool = deque()\n+\n+        # Some meta data of this connection\n+        # initialized when connection is successfully made\n+        self._metadata = {\n+            'certificate': None,\n+            'ip_address': None\n+        }\n+\n+    def _stream_close_cb(self, stream_id: int):\n+        \"\"\"Called when stream is closed completely\n+        \"\"\"\n+        self.streams.pop(stream_id, None)\n+\n+    def _new_stream(self, request: Request):\n+        \"\"\"Instantiates a new Stream object\n+        \"\"\"\n+        stream_id = next(self.stream_id_count)\n+\n+        stream = Stream(\n+            stream_id=stream_id,\n+            request=request,\n+            connection=self.conn,\n+            conn_metadata=self._metadata,\n+            write_to_transport=self._write_to_transport,\n+            cb_close=self._stream_close_cb\n+        )\n+\n+        self.streams[stream.stream_id] = stream\n+        return stream\n+\n+    def _send_pending_requests(self):\n+        # TODO: handle MAX_CONCURRENT_STREAMS\n+        # Initiate all pending requests\n+        while self._pending_request_stream_pool:\n+            stream = self._pending_request_stream_pool.popleft()\n+            stream.initiate_request()\n+\n+    def _write_to_transport(self):\n+        \"\"\" Write data to the underlying transport connection\n+        from the HTTP2 connection instance if any\n+        \"\"\"\n+        data = self.conn.data_to_send()\n+        self.transport.write(data)\n+\n+        LOGGER.debug(\"Sent {} bytes to {} via transport\".format(len(data), self._metadata['ip_address']))\n+\n+    def request(self, _request: Request):\n+        stream = self._new_stream(_request)\n+        d = stream.get_response()\n+\n+        # If connection is not yet established then add the\n+        # stream to pool or initiate request\n+        if self.is_connection_made:\n+            stream.initiate_request()\n+        else:\n+            self._pending_request_stream_pool.append(stream)\n+\n+        return d\n+\n+    def connectionMade(self):\n+        \"\"\"Called by Twisted when the connection is established. We can start\n+        sending some data now: we should open with the connection preamble.\n+        \"\"\"\n+        self.destination = self.transport.getPeer()\n+        LOGGER.info('Connection made to {}'.format(self.destination))\n+\n+        self._metadata['certificate'] = Certificate(self.transport.getPeerCertificate())\n+        self._metadata['ip_address'] = ipaddress.ip_address(self.destination.host)\n+\n+        self.conn.initiate_connection()\n+        self._write_to_transport()\n+        self.is_connection_made = True\n+\n+    def dataReceived(self, data):\n+        events = self.conn.receive_data(data)\n+        self._handle_events(events)\n+        self._write_to_transport()\n+\n+    def connectionLost(self, reason=connectionDone):\n+        \"\"\"Called by Twisted when the transport connection is lost.\n+        No need to write anything to transport here.\n+        \"\"\"\n+        # Pop all streams which were pending and were not yet started\n+        for stream_id in list(self.streams):\n+            self.streams[stream_id].close(StreamCloseReason.CONNECTION_LOST, reason)",
      "comment": "The names or the arguments seem a little bit confusing to me, in the sense that `close`'s first parameter is `reason`, but here a variable called \"reason\" is passed as `failure`. Not a big deal, but perhaps it can be improved somehow.",
      "comment_id": 446676621,
      "user": "elacuesta",
      "created_at": "2020-06-28T17:30:26Z",
      "url": "https://github.com/scrapy/scrapy/pull/4610#discussion_r446676621"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 4610,
      "file_path": "scrapy/core/http2/stream.py",
      "line": 337,
      "side": "RIGHT",
      "diff_hunk": "@@ -0,0 +1,384 @@\n+import logging\n+from enum import IntFlag, auto\n+from io import BytesIO\n+from typing import Dict\n+from urllib.parse import urlparse\n+\n+from h2.connection import H2Connection\n+from h2.errors import ErrorCodes\n+from h2.exceptions import StreamClosedError\n+from twisted.internet.defer import Deferred, CancelledError\n+from twisted.python.failure import Failure\n+from twisted.web.client import ResponseFailed\n+# for python < 3.8 -- typing.TypedDict is undefined\n+from typing_extensions import TypedDict\n+\n+from scrapy.http import Request\n+from scrapy.http.headers import Headers\n+from scrapy.responsetypes import responsetypes\n+\n+\n+class _ResponseTypedDict(TypedDict):\n+    # Data received frame by frame from the server is appended\n+    # and passed to the response Deferred when completely received.\n+    body: BytesIO\n+\n+    # The amount of data received that counts against the flow control\n+    # window\n+    flow_controlled_size: int\n+\n+    # Headers received after sending the request\n+    headers: Headers\n+\n+\n+LOGGER = logging.getLogger(__name__)\n+\n+\n+class StreamCloseReason(IntFlag):\n+    # Received a StreamEnded event\n+    ENDED = auto()\n+\n+    # Received a StreamReset event -- ended abruptly\n+    RESET = auto()\n+\n+    # Transport connection was lost\n+    CONNECTION_LOST = auto()\n+\n+    # Expected response body size is more than allowed limit\n+    MAXSIZE_EXCEEDED = auto()\n+\n+    # When the response deferred is cancelled\n+    CANCELLED = auto()\n+\n+\n+class Stream:\n+    \"\"\"Represents a single HTTP/2 Stream.\n+\n+    Stream is a bidirectional flow of bytes within an established connection,\n+    which may carry one or more messages. Handles the transfer of HTTP Headers\n+    and Data frames.\n+\n+    Role of this class is to\n+    1. Combine all the data frames\n+    \"\"\"\n+\n+    def __init__(\n+            self,\n+            stream_id: int,\n+            request: Request,\n+            connection: H2Connection,\n+            conn_metadata: Dict,\n+            write_to_transport,\n+            cb_close,\n+            download_maxsize=0,\n+            download_warnsize=0,\n+            fail_on_data_loss=True\n+    ):\n+        \"\"\"\n+        Arguments:\n+            stream_id {int} -- For one HTTP/2 connection each stream is\n+                uniquely identified by a single integer\n+            request {Request} -- HTTP request\n+            connection {H2Connection} -- HTTP/2 connection this stream belongs to.\n+            conn_metadata {Dict} -- Reference to dictionary having metadata of HTTP/2 connection\n+            write_to_transport {callable} -- Method used to write & send data to the server\n+                This method should be used whenever some frame is to be sent to the server.\n+            cb_close {callable} -- Method called when this stream is closed\n+                to notify the TCP connection instance.\n+        \"\"\"\n+        self.stream_id = stream_id\n+        self._request = request\n+        self._conn = connection\n+        self._conn_metadata = conn_metadata\n+        self._write_to_transport = write_to_transport\n+        self._cb_close = cb_close\n+\n+        self._download_maxsize = self._request.meta.get('download_maxsize', download_maxsize)\n+        self._download_warnsize = self._request.meta.get('download_warnsize', download_warnsize)\n+        self._fail_on_dataloss = self._request.meta.get('download_fail_on_dataloss', fail_on_data_loss)\n+\n+        self.request_start_time = None\n+\n+        self.content_length = 0 if self._request.body is None else len(self._request.body)\n+\n+        # Flag to keep track whether this stream has initiated the request\n+        self.request_sent = False\n+\n+        # Flag to track whether we have logged about exceeding download warnsize\n+        self._reached_warnsize = False\n+\n+        # Each time we send a data frame, we will decrease value by the amount send.\n+        self.remaining_content_length = self.content_length\n+\n+        # Flag to keep track whether we have closed this stream\n+        self.stream_closed_local = False\n+\n+        # Flag to keep track whether the server has closed the stream\n+        self.stream_closed_server = False\n+\n+        # Private variable used to build the response\n+        # this response is then converted to appropriate Response class\n+        # passed to the response deferred callback\n+        self._response: _ResponseTypedDict = {\n+            'body': BytesIO(),\n+            'flow_controlled_size': 0,\n+            'headers': Headers({})\n+        }\n+\n+        def _cancel(_):\n+            # Close this stream as gracefully as possible :)\n+            self.reset_stream(StreamCloseReason.CANCELLED)\n+\n+        self._deferred_response = Deferred(_cancel)\n+\n+    def __str__(self):\n+        return \"Stream(id={})\".format(repr(self.stream_id))\n+\n+    __repr__ = __str__\n+\n+    def get_response(self):\n+        \"\"\"Simply return a Deferred which fires when response\n+        from the asynchronous request is available\n+\n+        Returns:\n+            Deferred -- Calls the callback passing the response\n+        \"\"\"\n+        return self._deferred_response\n+\n+    def _get_request_headers(self):\n+        url = urlparse(self._request.url)\n+\n+        # Make sure pseudo-headers comes before all the other headers\n+        headers = [\n+            (':method', self._request.method),\n+            (':authority', url.netloc),\n+\n+            # TODO: Check if scheme can be 'http' for HTTP/2 ?\n+            (':scheme', 'https'),\n+            (':path', url.path),\n+        ]\n+\n+        for name, value in self._request.headers.items():\n+            headers.append((name, value[0]))\n+\n+        return headers\n+\n+    def initiate_request(self):\n+        headers = self._get_request_headers()\n+        self._conn.send_headers(self.stream_id, headers, end_stream=False)\n+        self._write_to_transport()\n+\n+        self.request_sent = True\n+\n+        self.send_data()\n+\n+    def send_data(self):\n+        \"\"\"Called immediately after the headers are sent. Here we send all the\n+         data as part of the request.\n+\n+         If the content length is 0 initially then we end the stream immediately and\n+         wait for response data.\n+\n+         Warning: Only call this method when stream not closed from client side\n+            and has initiated request already by sending HEADER frame. If not then\n+            stream will raise ProtocolError (raise by h2 state machine).\n+         \"\"\"\n+        if self.stream_closed_local:\n+            raise StreamClosedError(self.stream_id)\n+\n+        # Firstly, check what the flow control window is for current stream.\n+        window_size = self._conn.local_flow_control_window(stream_id=self.stream_id)\n+\n+        # Next, check what the maximum frame size is.\n+        max_frame_size = self._conn.max_outbound_frame_size\n+\n+        # We will send no more than the window size or the remaining file size\n+        # of data in this call, whichever is smaller.\n+        bytes_to_send_size = min(window_size, self.remaining_content_length)\n+\n+        # We now need to send a number of data frames.\n+        data_frames_sent = 0\n+        while bytes_to_send_size > 0:\n+            chunk_size = min(bytes_to_send_size, max_frame_size)\n+\n+            data_chunk_start_id = self.content_length - self.remaining_content_length\n+            data_chunk = self._request.body[data_chunk_start_id:data_chunk_start_id + chunk_size]\n+\n+            self._conn.send_data(self.stream_id, data_chunk, end_stream=False)\n+\n+            data_frames_sent += 1\n+            bytes_to_send_size = bytes_to_send_size - chunk_size\n+            self.remaining_content_length = self.remaining_content_length - chunk_size\n+\n+        self.remaining_content_length = max(0, self.remaining_content_length)\n+        LOGGER.debug(\"{} sending {}/{} data bytes ({} frames) to {}\".format(\n+            self,\n+            self.content_length - self.remaining_content_length, self.content_length,\n+            data_frames_sent,\n+            self._conn_metadata['ip_address'])\n+        )\n+\n+        # End the stream if no more data needs to be send\n+        if self.remaining_content_length == 0:\n+            self._conn.end_stream(self.stream_id)\n+\n+        # Write data to transport -- Empty the outstanding data\n+        self._write_to_transport()\n+\n+        # Q. What about the rest of the data?\n+        # Ans: Remaining Data frames will be sent when we get a WindowUpdate frame\n+\n+    def receive_window_update(self):\n+        \"\"\"Flow control window size was changed.\n+        Send data that earlier could not be sent as we were\n+        blocked behind the flow control.\n+        \"\"\"\n+        if self.remaining_content_length and not self.stream_closed_server and self.request_sent:\n+            self.send_data()\n+\n+    def receive_data(self, data: bytes, flow_controlled_length: int):\n+        self._response['body'].write(data)\n+        self._response['flow_controlled_size'] += flow_controlled_length\n+\n+        if self._download_maxsize and self._response['flow_controlled_size'] > self._download_maxsize:\n+            # Clear buffer earlier to avoid keeping data in memory for a long time\n+            self._response['body'].truncate(0)\n+            self.reset_stream(StreamCloseReason.MAXSIZE_EXCEEDED)\n+            return\n+\n+        if self._download_warnsize \\\n+                and self._response['flow_controlled_size'] > self._download_warnsize \\\n+                and not self._reached_warnsize:\n+            self._reached_warnsize = True\n+            warning_msg = ('Received more ({bytes}) bytes than download ',\n+                           'warn size ({warnsize}) in request {request}')\n+            warning_args = {\n+                'bytes': self._response['flow_controlled_size'],\n+                'warnsize': self._download_warnsize,\n+                'request': self._request\n+            }\n+            LOGGER.warning(warning_msg, warning_args)\n+\n+        # Acknowledge the data received\n+        self._conn.acknowledge_received_data(\n+            self._response['flow_controlled_size'],\n+            self.stream_id\n+        )\n+\n+    def receive_headers(self, headers):\n+        for name, value in headers:\n+            self._response['headers'][name] = value\n+\n+        # Check if we exceed the allowed max data size which can be received\n+        expected_size = int(self._response['headers'].get(b'Content-Length', -1))\n+        if self._download_maxsize and expected_size > self._download_maxsize:\n+            self.reset_stream(StreamCloseReason.MAXSIZE_EXCEEDED)\n+            return\n+\n+        if self._download_warnsize and expected_size > self._download_warnsize:\n+            warning_msg = (\"Expected response size ({size}) larger than \",\n+                           \"download warn size ({warnsize}) in request {request}.\")\n+            warning_args = {\n+                'size': expected_size, 'warnsize': self._download_warnsize,\n+                'request': self._request\n+            }\n+            LOGGER.warning(warning_msg, warning_args)\n+\n+    def reset_stream(self, reason=StreamCloseReason.RESET):\n+        \"\"\"Close this stream by sending a RST_FRAME to the remote peer\"\"\"\n+        if self.stream_closed_local:\n+            raise StreamClosedError(self.stream_id)\n+\n+        self.stream_closed_local = True\n+        self._conn.reset_stream(self.stream_id, ErrorCodes.REFUSED_STREAM)\n+        self._write_to_transport()\n+        self.close(reason)\n+\n+    def _is_data_lost(self) -> bool:\n+        assert self.stream_closed_server\n+\n+        expected_size = self._response['flow_controlled_size']\n+        received_body_size = int(self._response['headers'][b'Content-Length'])\n+\n+        return expected_size != received_body_size\n+\n+    def close(self, reason: StreamCloseReason, failure=None):\n+        \"\"\"Based on the reason sent we will handle each case.\n+        \"\"\"\n+        if self.stream_closed_server:\n+            raise StreamClosedError(self.stream_id)\n+\n+        self._cb_close(self.stream_id)\n+        self.stream_closed_server = True\n+\n+        # Do nothing if the response deferred was cancelled\n+        flags = None\n+        if b'Content-Length' not in self._response['headers']:\n+            # Missing Content-Length - PotentialDataLoss\n+            flags = ['partial']\n+        elif self._is_data_lost():\n+            if self._fail_on_dataloss:\n+                self._deferred_response.errback(ResponseFailed([Failure()]))\n+                return\n+            else:\n+                flags = ['dataloss']\n+\n+        if reason is StreamCloseReason.ENDED:\n+            self._fire_response_deferred(flags)\n+\n+        # Stream was abruptly ended here\n+        elif reason is StreamCloseReason.CANCELLED:\n+            # Client has cancelled the request. Remove all the data\n+            # received and fire the response deferred with no flags set\n+            self._response['body'].truncate(0)\n+            self._response['headers'].clear()\n+            self._fire_response_deferred()\n+\n+        elif reason in (StreamCloseReason.RESET | StreamCloseReason.CONNECTION_LOST):",
      "comment": "```suggestion\r\n        elif reason in (StreamCloseReason.RESET, StreamCloseReason.CONNECTION_LOST):\r\n```\r\nIs there a reason to be using a bitwise or? I found it a bit confusing, I had to look into the docs to understand the subtle fact that [`enum.IntFlag`](https://docs.python.org/3/library/enum.html#enum.IntFlag) handles this (`1 in (1 | 2)` explodes as expected). I believe doing a \"regular\" tuple check is simpler and more intuitive. It would also allow to define `StreamCloseReason` as a subclass of `enum.Enum` instead.\r\nLet me know if I'm missing something.",
      "comment_id": 446678686,
      "user": "elacuesta",
      "created_at": "2020-06-28T17:49:34Z",
      "url": "https://github.com/scrapy/scrapy/pull/4610#discussion_r446678686"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 4610,
      "file_path": "scrapy/core/http2/protocol.py",
      "line": 166,
      "side": "RIGHT",
      "diff_hunk": "@@ -0,0 +1,191 @@\n+import ipaddress\n+import itertools\n+import logging\n+from collections import deque\n+\n+from h2.config import H2Configuration\n+from h2.connection import H2Connection\n+from h2.events import (\n+    DataReceived, ResponseReceived, SettingsAcknowledged,\n+    StreamEnded, StreamReset, WindowUpdated\n+)\n+from twisted.internet.protocol import connectionDone, Protocol\n+from twisted.internet.ssl import Certificate\n+\n+from scrapy.core.http2.stream import Stream, StreamCloseReason\n+from scrapy.http import Request\n+\n+LOGGER = logging.getLogger(__name__)\n+\n+\n+class H2ClientProtocol(Protocol):\n+    # TODO:\n+    #  1. Check for user-agent while testing\n+    #  2. Handle case when received events have StreamID = 0 (applied to H2Connection)\n+\n+    def __init__(self):\n+        config = H2Configuration(client_side=True, header_encoding='utf-8')\n+        self.conn = H2Connection(config=config)\n+\n+        # Address of the server we are connected to\n+        # these are updated when connection is successfully made\n+        self.destination = None\n+\n+        # ID of the next request stream\n+        # Following the convention made by hyper-h2 each client ID\n+        # will be odd.\n+        self.stream_id_count = itertools.count(start=1, step=2)\n+\n+        # Streams are stored in a dictionary keyed off their stream IDs\n+        self.streams = {}\n+\n+        # Boolean to keep track the connection is made\n+        # If requests are received before connection is made\n+        # we keep all requests in a pool and send them as the connection\n+        # is made\n+        self.is_connection_made = False\n+        self._pending_request_stream_pool = deque()\n+\n+        # Some meta data of this connection\n+        # initialized when connection is successfully made\n+        self._metadata = {\n+            'certificate': None,\n+            'ip_address': None\n+        }\n+\n+    def _stream_close_cb(self, stream_id: int):\n+        \"\"\"Called when stream is closed completely\n+        \"\"\"\n+        self.streams.pop(stream_id, None)\n+\n+    def _new_stream(self, request: Request):\n+        \"\"\"Instantiates a new Stream object\n+        \"\"\"\n+        stream_id = next(self.stream_id_count)\n+\n+        stream = Stream(\n+            stream_id=stream_id,\n+            request=request,\n+            connection=self.conn,\n+            conn_metadata=self._metadata,\n+            write_to_transport=self._write_to_transport,\n+            cb_close=self._stream_close_cb\n+        )\n+\n+        self.streams[stream.stream_id] = stream\n+        return stream\n+\n+    def _send_pending_requests(self):\n+        # TODO: handle MAX_CONCURRENT_STREAMS\n+        # Initiate all pending requests\n+        while self._pending_request_stream_pool:\n+            stream = self._pending_request_stream_pool.popleft()\n+            stream.initiate_request()\n+\n+    def _write_to_transport(self):\n+        \"\"\" Write data to the underlying transport connection\n+        from the HTTP2 connection instance if any\n+        \"\"\"\n+        data = self.conn.data_to_send()\n+        self.transport.write(data)\n+\n+        LOGGER.debug(\"Sent {} bytes to {} via transport\".format(len(data), self._metadata['ip_address']))\n+\n+    def request(self, _request: Request):\n+        stream = self._new_stream(_request)\n+        d = stream.get_response()\n+\n+        # If connection is not yet established then add the\n+        # stream to pool or initiate request\n+        if self.is_connection_made:\n+            stream.initiate_request()\n+        else:\n+            self._pending_request_stream_pool.append(stream)\n+\n+        return d\n+\n+    def connectionMade(self):\n+        \"\"\"Called by Twisted when the connection is established. We can start\n+        sending some data now: we should open with the connection preamble.\n+        \"\"\"\n+        self.destination = self.transport.getPeer()\n+        LOGGER.info('Connection made to {}'.format(self.destination))\n+\n+        self._metadata['certificate'] = Certificate(self.transport.getPeerCertificate())\n+        self._metadata['ip_address'] = ipaddress.ip_address(self.destination.host)\n+\n+        self.conn.initiate_connection()\n+        self._write_to_transport()\n+        self.is_connection_made = True\n+\n+    def dataReceived(self, data):\n+        events = self.conn.receive_data(data)\n+        self._handle_events(events)\n+        self._write_to_transport()\n+\n+    def connectionLost(self, reason=connectionDone):\n+        \"\"\"Called by Twisted when the transport connection is lost.\n+        No need to write anything to transport here.\n+        \"\"\"\n+        # Pop all streams which were pending and were not yet started\n+        for stream_id in list(self.streams):\n+            self.streams[stream_id].close(StreamCloseReason.CONNECTION_LOST, reason)\n+\n+        self.conn.close_connection()\n+\n+        LOGGER.warning(\"Connection lost with reason \" + str(reason))\n+\n+    def _handle_events(self, events):\n+        \"\"\"Private method which acts as a bridge between the events\n+        received from the HTTP/2 data and IH2EventsHandler\n+\n+        Arguments:\n+            events {list} -- A list of events that the remote peer\n+                triggered by sending data\n+        \"\"\"\n+        for event in events:\n+            LOGGER.debug(event)\n+            if isinstance(event, DataReceived):\n+                self.data_received(event)\n+            elif isinstance(event, ResponseReceived):\n+                self.response_received(event)\n+            elif isinstance(event, StreamEnded):\n+                self.stream_ended(event)\n+            elif isinstance(event, StreamReset):\n+                self.stream_reset(event)\n+            elif isinstance(event, WindowUpdated):\n+                self.window_updated(event)\n+            elif isinstance(event, SettingsAcknowledged):\n+                self.settings_acknowledged(event)\n+            else:\n+                LOGGER.info(\"Received unhandled event {}\".format(event))\n+\n+    # Event handler functions starts here\n+    def data_received(self, event: DataReceived):\n+        stream_id = event.stream_id\n+        self.streams[stream_id].receive_data(event.data, event.flow_controlled_length)",
      "comment": "I think it'd be simpler to do what you're doing in `stream_reset`, i.e. `self.streams[event.stream_id]`. The same in other methods for this class.",
      "comment_id": 446678956,
      "user": "elacuesta",
      "created_at": "2020-06-28T17:51:57Z",
      "url": "https://github.com/scrapy/scrapy/pull/4610#discussion_r446678956"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 4610,
      "file_path": "scrapy/core/http2/stream.py",
      "line": 337,
      "side": "RIGHT",
      "diff_hunk": "@@ -0,0 +1,384 @@\n+import logging\n+from enum import IntFlag, auto\n+from io import BytesIO\n+from typing import Dict\n+from urllib.parse import urlparse\n+\n+from h2.connection import H2Connection\n+from h2.errors import ErrorCodes\n+from h2.exceptions import StreamClosedError\n+from twisted.internet.defer import Deferred, CancelledError\n+from twisted.python.failure import Failure\n+from twisted.web.client import ResponseFailed\n+# for python < 3.8 -- typing.TypedDict is undefined\n+from typing_extensions import TypedDict\n+\n+from scrapy.http import Request\n+from scrapy.http.headers import Headers\n+from scrapy.responsetypes import responsetypes\n+\n+\n+class _ResponseTypedDict(TypedDict):\n+    # Data received frame by frame from the server is appended\n+    # and passed to the response Deferred when completely received.\n+    body: BytesIO\n+\n+    # The amount of data received that counts against the flow control\n+    # window\n+    flow_controlled_size: int\n+\n+    # Headers received after sending the request\n+    headers: Headers\n+\n+\n+LOGGER = logging.getLogger(__name__)\n+\n+\n+class StreamCloseReason(IntFlag):\n+    # Received a StreamEnded event\n+    ENDED = auto()\n+\n+    # Received a StreamReset event -- ended abruptly\n+    RESET = auto()\n+\n+    # Transport connection was lost\n+    CONNECTION_LOST = auto()\n+\n+    # Expected response body size is more than allowed limit\n+    MAXSIZE_EXCEEDED = auto()\n+\n+    # When the response deferred is cancelled\n+    CANCELLED = auto()\n+\n+\n+class Stream:\n+    \"\"\"Represents a single HTTP/2 Stream.\n+\n+    Stream is a bidirectional flow of bytes within an established connection,\n+    which may carry one or more messages. Handles the transfer of HTTP Headers\n+    and Data frames.\n+\n+    Role of this class is to\n+    1. Combine all the data frames\n+    \"\"\"\n+\n+    def __init__(\n+            self,\n+            stream_id: int,\n+            request: Request,\n+            connection: H2Connection,\n+            conn_metadata: Dict,\n+            write_to_transport,\n+            cb_close,\n+            download_maxsize=0,\n+            download_warnsize=0,\n+            fail_on_data_loss=True\n+    ):\n+        \"\"\"\n+        Arguments:\n+            stream_id {int} -- For one HTTP/2 connection each stream is\n+                uniquely identified by a single integer\n+            request {Request} -- HTTP request\n+            connection {H2Connection} -- HTTP/2 connection this stream belongs to.\n+            conn_metadata {Dict} -- Reference to dictionary having metadata of HTTP/2 connection\n+            write_to_transport {callable} -- Method used to write & send data to the server\n+                This method should be used whenever some frame is to be sent to the server.\n+            cb_close {callable} -- Method called when this stream is closed\n+                to notify the TCP connection instance.\n+        \"\"\"\n+        self.stream_id = stream_id\n+        self._request = request\n+        self._conn = connection\n+        self._conn_metadata = conn_metadata\n+        self._write_to_transport = write_to_transport\n+        self._cb_close = cb_close\n+\n+        self._download_maxsize = self._request.meta.get('download_maxsize', download_maxsize)\n+        self._download_warnsize = self._request.meta.get('download_warnsize', download_warnsize)\n+        self._fail_on_dataloss = self._request.meta.get('download_fail_on_dataloss', fail_on_data_loss)\n+\n+        self.request_start_time = None\n+\n+        self.content_length = 0 if self._request.body is None else len(self._request.body)\n+\n+        # Flag to keep track whether this stream has initiated the request\n+        self.request_sent = False\n+\n+        # Flag to track whether we have logged about exceeding download warnsize\n+        self._reached_warnsize = False\n+\n+        # Each time we send a data frame, we will decrease value by the amount send.\n+        self.remaining_content_length = self.content_length\n+\n+        # Flag to keep track whether we have closed this stream\n+        self.stream_closed_local = False\n+\n+        # Flag to keep track whether the server has closed the stream\n+        self.stream_closed_server = False\n+\n+        # Private variable used to build the response\n+        # this response is then converted to appropriate Response class\n+        # passed to the response deferred callback\n+        self._response: _ResponseTypedDict = {\n+            'body': BytesIO(),\n+            'flow_controlled_size': 0,\n+            'headers': Headers({})\n+        }\n+\n+        def _cancel(_):\n+            # Close this stream as gracefully as possible :)\n+            self.reset_stream(StreamCloseReason.CANCELLED)\n+\n+        self._deferred_response = Deferred(_cancel)\n+\n+    def __str__(self):\n+        return \"Stream(id={})\".format(repr(self.stream_id))\n+\n+    __repr__ = __str__\n+\n+    def get_response(self):\n+        \"\"\"Simply return a Deferred which fires when response\n+        from the asynchronous request is available\n+\n+        Returns:\n+            Deferred -- Calls the callback passing the response\n+        \"\"\"\n+        return self._deferred_response\n+\n+    def _get_request_headers(self):\n+        url = urlparse(self._request.url)\n+\n+        # Make sure pseudo-headers comes before all the other headers\n+        headers = [\n+            (':method', self._request.method),\n+            (':authority', url.netloc),\n+\n+            # TODO: Check if scheme can be 'http' for HTTP/2 ?\n+            (':scheme', 'https'),\n+            (':path', url.path),\n+        ]\n+\n+        for name, value in self._request.headers.items():\n+            headers.append((name, value[0]))\n+\n+        return headers\n+\n+    def initiate_request(self):\n+        headers = self._get_request_headers()\n+        self._conn.send_headers(self.stream_id, headers, end_stream=False)\n+        self._write_to_transport()\n+\n+        self.request_sent = True\n+\n+        self.send_data()\n+\n+    def send_data(self):\n+        \"\"\"Called immediately after the headers are sent. Here we send all the\n+         data as part of the request.\n+\n+         If the content length is 0 initially then we end the stream immediately and\n+         wait for response data.\n+\n+         Warning: Only call this method when stream not closed from client side\n+            and has initiated request already by sending HEADER frame. If not then\n+            stream will raise ProtocolError (raise by h2 state machine).\n+         \"\"\"\n+        if self.stream_closed_local:\n+            raise StreamClosedError(self.stream_id)\n+\n+        # Firstly, check what the flow control window is for current stream.\n+        window_size = self._conn.local_flow_control_window(stream_id=self.stream_id)\n+\n+        # Next, check what the maximum frame size is.\n+        max_frame_size = self._conn.max_outbound_frame_size\n+\n+        # We will send no more than the window size or the remaining file size\n+        # of data in this call, whichever is smaller.\n+        bytes_to_send_size = min(window_size, self.remaining_content_length)\n+\n+        # We now need to send a number of data frames.\n+        data_frames_sent = 0\n+        while bytes_to_send_size > 0:\n+            chunk_size = min(bytes_to_send_size, max_frame_size)\n+\n+            data_chunk_start_id = self.content_length - self.remaining_content_length\n+            data_chunk = self._request.body[data_chunk_start_id:data_chunk_start_id + chunk_size]\n+\n+            self._conn.send_data(self.stream_id, data_chunk, end_stream=False)\n+\n+            data_frames_sent += 1\n+            bytes_to_send_size = bytes_to_send_size - chunk_size\n+            self.remaining_content_length = self.remaining_content_length - chunk_size\n+\n+        self.remaining_content_length = max(0, self.remaining_content_length)\n+        LOGGER.debug(\"{} sending {}/{} data bytes ({} frames) to {}\".format(\n+            self,\n+            self.content_length - self.remaining_content_length, self.content_length,\n+            data_frames_sent,\n+            self._conn_metadata['ip_address'])\n+        )\n+\n+        # End the stream if no more data needs to be send\n+        if self.remaining_content_length == 0:\n+            self._conn.end_stream(self.stream_id)\n+\n+        # Write data to transport -- Empty the outstanding data\n+        self._write_to_transport()\n+\n+        # Q. What about the rest of the data?\n+        # Ans: Remaining Data frames will be sent when we get a WindowUpdate frame\n+\n+    def receive_window_update(self):\n+        \"\"\"Flow control window size was changed.\n+        Send data that earlier could not be sent as we were\n+        blocked behind the flow control.\n+        \"\"\"\n+        if self.remaining_content_length and not self.stream_closed_server and self.request_sent:\n+            self.send_data()\n+\n+    def receive_data(self, data: bytes, flow_controlled_length: int):\n+        self._response['body'].write(data)\n+        self._response['flow_controlled_size'] += flow_controlled_length\n+\n+        if self._download_maxsize and self._response['flow_controlled_size'] > self._download_maxsize:\n+            # Clear buffer earlier to avoid keeping data in memory for a long time\n+            self._response['body'].truncate(0)\n+            self.reset_stream(StreamCloseReason.MAXSIZE_EXCEEDED)\n+            return\n+\n+        if self._download_warnsize \\\n+                and self._response['flow_controlled_size'] > self._download_warnsize \\\n+                and not self._reached_warnsize:\n+            self._reached_warnsize = True\n+            warning_msg = ('Received more ({bytes}) bytes than download ',\n+                           'warn size ({warnsize}) in request {request}')\n+            warning_args = {\n+                'bytes': self._response['flow_controlled_size'],\n+                'warnsize': self._download_warnsize,\n+                'request': self._request\n+            }\n+            LOGGER.warning(warning_msg, warning_args)\n+\n+        # Acknowledge the data received\n+        self._conn.acknowledge_received_data(\n+            self._response['flow_controlled_size'],\n+            self.stream_id\n+        )\n+\n+    def receive_headers(self, headers):\n+        for name, value in headers:\n+            self._response['headers'][name] = value\n+\n+        # Check if we exceed the allowed max data size which can be received\n+        expected_size = int(self._response['headers'].get(b'Content-Length', -1))\n+        if self._download_maxsize and expected_size > self._download_maxsize:\n+            self.reset_stream(StreamCloseReason.MAXSIZE_EXCEEDED)\n+            return\n+\n+        if self._download_warnsize and expected_size > self._download_warnsize:\n+            warning_msg = (\"Expected response size ({size}) larger than \",\n+                           \"download warn size ({warnsize}) in request {request}.\")\n+            warning_args = {\n+                'size': expected_size, 'warnsize': self._download_warnsize,\n+                'request': self._request\n+            }\n+            LOGGER.warning(warning_msg, warning_args)\n+\n+    def reset_stream(self, reason=StreamCloseReason.RESET):\n+        \"\"\"Close this stream by sending a RST_FRAME to the remote peer\"\"\"\n+        if self.stream_closed_local:\n+            raise StreamClosedError(self.stream_id)\n+\n+        self.stream_closed_local = True\n+        self._conn.reset_stream(self.stream_id, ErrorCodes.REFUSED_STREAM)\n+        self._write_to_transport()\n+        self.close(reason)\n+\n+    def _is_data_lost(self) -> bool:\n+        assert self.stream_closed_server\n+\n+        expected_size = self._response['flow_controlled_size']\n+        received_body_size = int(self._response['headers'][b'Content-Length'])\n+\n+        return expected_size != received_body_size\n+\n+    def close(self, reason: StreamCloseReason, failure=None):\n+        \"\"\"Based on the reason sent we will handle each case.\n+        \"\"\"\n+        if self.stream_closed_server:\n+            raise StreamClosedError(self.stream_id)\n+\n+        self._cb_close(self.stream_id)\n+        self.stream_closed_server = True\n+\n+        # Do nothing if the response deferred was cancelled\n+        flags = None\n+        if b'Content-Length' not in self._response['headers']:\n+            # Missing Content-Length - PotentialDataLoss\n+            flags = ['partial']\n+        elif self._is_data_lost():\n+            if self._fail_on_dataloss:\n+                self._deferred_response.errback(ResponseFailed([Failure()]))\n+                return\n+            else:\n+                flags = ['dataloss']\n+\n+        if reason is StreamCloseReason.ENDED:\n+            self._fire_response_deferred(flags)\n+\n+        # Stream was abruptly ended here\n+        elif reason is StreamCloseReason.CANCELLED:\n+            # Client has cancelled the request. Remove all the data\n+            # received and fire the response deferred with no flags set\n+            self._response['body'].truncate(0)\n+            self._response['headers'].clear()\n+            self._fire_response_deferred()\n+\n+        elif reason in (StreamCloseReason.RESET | StreamCloseReason.CONNECTION_LOST):",
      "comment": "You're right. I didn't get the idea of using a `in` tuple check earlier so went with `IntFlag`. Changed definition to\r\n```python\r\nclass StreamCloseReason(Enum):\r\n```",
      "comment_id": 446760971,
      "user": "adityaa30",
      "created_at": "2020-06-29T04:07:59Z",
      "url": "https://github.com/scrapy/scrapy/pull/4610#discussion_r446760971"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 4610,
      "file_path": "scrapy/core/http2/protocol.py",
      "line": 132,
      "side": "RIGHT",
      "diff_hunk": "@@ -0,0 +1,191 @@\n+import ipaddress\n+import itertools\n+import logging\n+from collections import deque\n+\n+from h2.config import H2Configuration\n+from h2.connection import H2Connection\n+from h2.events import (\n+    DataReceived, ResponseReceived, SettingsAcknowledged,\n+    StreamEnded, StreamReset, WindowUpdated\n+)\n+from twisted.internet.protocol import connectionDone, Protocol\n+from twisted.internet.ssl import Certificate\n+\n+from scrapy.core.http2.stream import Stream, StreamCloseReason\n+from scrapy.http import Request\n+\n+LOGGER = logging.getLogger(__name__)\n+\n+\n+class H2ClientProtocol(Protocol):\n+    # TODO:\n+    #  1. Check for user-agent while testing\n+    #  2. Handle case when received events have StreamID = 0 (applied to H2Connection)\n+\n+    def __init__(self):\n+        config = H2Configuration(client_side=True, header_encoding='utf-8')\n+        self.conn = H2Connection(config=config)\n+\n+        # Address of the server we are connected to\n+        # these are updated when connection is successfully made\n+        self.destination = None\n+\n+        # ID of the next request stream\n+        # Following the convention made by hyper-h2 each client ID\n+        # will be odd.\n+        self.stream_id_count = itertools.count(start=1, step=2)\n+\n+        # Streams are stored in a dictionary keyed off their stream IDs\n+        self.streams = {}\n+\n+        # Boolean to keep track the connection is made\n+        # If requests are received before connection is made\n+        # we keep all requests in a pool and send them as the connection\n+        # is made\n+        self.is_connection_made = False\n+        self._pending_request_stream_pool = deque()\n+\n+        # Some meta data of this connection\n+        # initialized when connection is successfully made\n+        self._metadata = {\n+            'certificate': None,\n+            'ip_address': None\n+        }\n+\n+    def _stream_close_cb(self, stream_id: int):\n+        \"\"\"Called when stream is closed completely\n+        \"\"\"\n+        self.streams.pop(stream_id, None)\n+\n+    def _new_stream(self, request: Request):\n+        \"\"\"Instantiates a new Stream object\n+        \"\"\"\n+        stream_id = next(self.stream_id_count)\n+\n+        stream = Stream(\n+            stream_id=stream_id,\n+            request=request,\n+            connection=self.conn,\n+            conn_metadata=self._metadata,\n+            write_to_transport=self._write_to_transport,\n+            cb_close=self._stream_close_cb\n+        )\n+\n+        self.streams[stream.stream_id] = stream\n+        return stream\n+\n+    def _send_pending_requests(self):\n+        # TODO: handle MAX_CONCURRENT_STREAMS\n+        # Initiate all pending requests\n+        while self._pending_request_stream_pool:\n+            stream = self._pending_request_stream_pool.popleft()\n+            stream.initiate_request()\n+\n+    def _write_to_transport(self):\n+        \"\"\" Write data to the underlying transport connection\n+        from the HTTP2 connection instance if any\n+        \"\"\"\n+        data = self.conn.data_to_send()\n+        self.transport.write(data)\n+\n+        LOGGER.debug(\"Sent {} bytes to {} via transport\".format(len(data), self._metadata['ip_address']))\n+\n+    def request(self, _request: Request):\n+        stream = self._new_stream(_request)\n+        d = stream.get_response()\n+\n+        # If connection is not yet established then add the\n+        # stream to pool or initiate request\n+        if self.is_connection_made:\n+            stream.initiate_request()\n+        else:\n+            self._pending_request_stream_pool.append(stream)\n+\n+        return d\n+\n+    def connectionMade(self):\n+        \"\"\"Called by Twisted when the connection is established. We can start\n+        sending some data now: we should open with the connection preamble.\n+        \"\"\"\n+        self.destination = self.transport.getPeer()\n+        LOGGER.info('Connection made to {}'.format(self.destination))\n+\n+        self._metadata['certificate'] = Certificate(self.transport.getPeerCertificate())\n+        self._metadata['ip_address'] = ipaddress.ip_address(self.destination.host)\n+\n+        self.conn.initiate_connection()\n+        self._write_to_transport()\n+        self.is_connection_made = True\n+\n+    def dataReceived(self, data):\n+        events = self.conn.receive_data(data)\n+        self._handle_events(events)\n+        self._write_to_transport()\n+\n+    def connectionLost(self, reason=connectionDone):\n+        \"\"\"Called by Twisted when the transport connection is lost.\n+        No need to write anything to transport here.\n+        \"\"\"\n+        # Pop all streams which were pending and were not yet started\n+        for stream_id in list(self.streams):\n+            self.streams[stream_id].close(StreamCloseReason.CONNECTION_LOST, reason)",
      "comment": "Earlier I was going through what `reason` actually can be used for. I realized that `reason` represents the whole connection which works in HTTP/1.x as it has one request per connection. For HTTP/2 I used it just in case when `connectionLost` is called and we have some streams left then we can pass the `reason: Failure` instance to the errback. Any suggestions on this? \r\n\r\n>  but perhaps it can be improved somehow\r\n\r\nSince `reason` is instance of `twisted.python.failure.Failure` I made the argument name of `Stream.close()` as `failure` \ud83d\ude01. Changing the argument name of `reason` in `connectionLost` won't be appropriate here ig? ",
      "comment_id": 446763369,
      "user": "adityaa30",
      "created_at": "2020-06-29T04:18:46Z",
      "url": "https://github.com/scrapy/scrapy/pull/4610#discussion_r446763369"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 4610,
      "file_path": "scrapy/core/http2/protocol.py",
      "line": 132,
      "side": "RIGHT",
      "diff_hunk": "@@ -0,0 +1,191 @@\n+import ipaddress\n+import itertools\n+import logging\n+from collections import deque\n+\n+from h2.config import H2Configuration\n+from h2.connection import H2Connection\n+from h2.events import (\n+    DataReceived, ResponseReceived, SettingsAcknowledged,\n+    StreamEnded, StreamReset, WindowUpdated\n+)\n+from twisted.internet.protocol import connectionDone, Protocol\n+from twisted.internet.ssl import Certificate\n+\n+from scrapy.core.http2.stream import Stream, StreamCloseReason\n+from scrapy.http import Request\n+\n+LOGGER = logging.getLogger(__name__)\n+\n+\n+class H2ClientProtocol(Protocol):\n+    # TODO:\n+    #  1. Check for user-agent while testing\n+    #  2. Handle case when received events have StreamID = 0 (applied to H2Connection)\n+\n+    def __init__(self):\n+        config = H2Configuration(client_side=True, header_encoding='utf-8')\n+        self.conn = H2Connection(config=config)\n+\n+        # Address of the server we are connected to\n+        # these are updated when connection is successfully made\n+        self.destination = None\n+\n+        # ID of the next request stream\n+        # Following the convention made by hyper-h2 each client ID\n+        # will be odd.\n+        self.stream_id_count = itertools.count(start=1, step=2)\n+\n+        # Streams are stored in a dictionary keyed off their stream IDs\n+        self.streams = {}\n+\n+        # Boolean to keep track the connection is made\n+        # If requests are received before connection is made\n+        # we keep all requests in a pool and send them as the connection\n+        # is made\n+        self.is_connection_made = False\n+        self._pending_request_stream_pool = deque()\n+\n+        # Some meta data of this connection\n+        # initialized when connection is successfully made\n+        self._metadata = {\n+            'certificate': None,\n+            'ip_address': None\n+        }\n+\n+    def _stream_close_cb(self, stream_id: int):\n+        \"\"\"Called when stream is closed completely\n+        \"\"\"\n+        self.streams.pop(stream_id, None)\n+\n+    def _new_stream(self, request: Request):\n+        \"\"\"Instantiates a new Stream object\n+        \"\"\"\n+        stream_id = next(self.stream_id_count)\n+\n+        stream = Stream(\n+            stream_id=stream_id,\n+            request=request,\n+            connection=self.conn,\n+            conn_metadata=self._metadata,\n+            write_to_transport=self._write_to_transport,\n+            cb_close=self._stream_close_cb\n+        )\n+\n+        self.streams[stream.stream_id] = stream\n+        return stream\n+\n+    def _send_pending_requests(self):\n+        # TODO: handle MAX_CONCURRENT_STREAMS\n+        # Initiate all pending requests\n+        while self._pending_request_stream_pool:\n+            stream = self._pending_request_stream_pool.popleft()\n+            stream.initiate_request()\n+\n+    def _write_to_transport(self):\n+        \"\"\" Write data to the underlying transport connection\n+        from the HTTP2 connection instance if any\n+        \"\"\"\n+        data = self.conn.data_to_send()\n+        self.transport.write(data)\n+\n+        LOGGER.debug(\"Sent {} bytes to {} via transport\".format(len(data), self._metadata['ip_address']))\n+\n+    def request(self, _request: Request):\n+        stream = self._new_stream(_request)\n+        d = stream.get_response()\n+\n+        # If connection is not yet established then add the\n+        # stream to pool or initiate request\n+        if self.is_connection_made:\n+            stream.initiate_request()\n+        else:\n+            self._pending_request_stream_pool.append(stream)\n+\n+        return d\n+\n+    def connectionMade(self):\n+        \"\"\"Called by Twisted when the connection is established. We can start\n+        sending some data now: we should open with the connection preamble.\n+        \"\"\"\n+        self.destination = self.transport.getPeer()\n+        LOGGER.info('Connection made to {}'.format(self.destination))\n+\n+        self._metadata['certificate'] = Certificate(self.transport.getPeerCertificate())\n+        self._metadata['ip_address'] = ipaddress.ip_address(self.destination.host)\n+\n+        self.conn.initiate_connection()\n+        self._write_to_transport()\n+        self.is_connection_made = True\n+\n+    def dataReceived(self, data):\n+        events = self.conn.receive_data(data)\n+        self._handle_events(events)\n+        self._write_to_transport()\n+\n+    def connectionLost(self, reason=connectionDone):\n+        \"\"\"Called by Twisted when the transport connection is lost.\n+        No need to write anything to transport here.\n+        \"\"\"\n+        # Pop all streams which were pending and were not yet started\n+        for stream_id in list(self.streams):\n+            self.streams[stream_id].close(StreamCloseReason.CONNECTION_LOST, reason)",
      "comment": "> Would \"close\" be more accurate than \"pop\" in the above comment?\r\n\r\nI did not get you?",
      "comment_id": 446778226,
      "user": "adityaa30",
      "created_at": "2020-06-29T05:22:02Z",
      "url": "https://github.com/scrapy/scrapy/pull/4610#discussion_r446778226"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 4610,
      "file_path": "setup.py",
      "line": 70,
      "side": "RIGHT",
      "diff_hunk": "@@ -68,7 +67,7 @@ def has_environment_marker_platform_impl_support():\n     ],\n     python_requires='>=3.5.2',\n     install_requires=[\n-        'Twisted>=17.9.0',\n+        'Twisted[http2]>=17.9.0'",
      "comment": "```suggestion\r\n        'Twisted[http2]>=17.9.0',\r\n```",
      "comment_id": 446906778,
      "user": "Gallaecio",
      "created_at": "2020-06-29T11:44:31Z",
      "url": "https://github.com/scrapy/scrapy/pull/4610#discussion_r446906778"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 4610,
      "file_path": "scrapy/core/http2/protocol.py",
      "line": 132,
      "side": "RIGHT",
      "diff_hunk": "@@ -0,0 +1,191 @@\n+import ipaddress\n+import itertools\n+import logging\n+from collections import deque\n+\n+from h2.config import H2Configuration\n+from h2.connection import H2Connection\n+from h2.events import (\n+    DataReceived, ResponseReceived, SettingsAcknowledged,\n+    StreamEnded, StreamReset, WindowUpdated\n+)\n+from twisted.internet.protocol import connectionDone, Protocol\n+from twisted.internet.ssl import Certificate\n+\n+from scrapy.core.http2.stream import Stream, StreamCloseReason\n+from scrapy.http import Request\n+\n+LOGGER = logging.getLogger(__name__)\n+\n+\n+class H2ClientProtocol(Protocol):\n+    # TODO:\n+    #  1. Check for user-agent while testing\n+    #  2. Handle case when received events have StreamID = 0 (applied to H2Connection)\n+\n+    def __init__(self):\n+        config = H2Configuration(client_side=True, header_encoding='utf-8')\n+        self.conn = H2Connection(config=config)\n+\n+        # Address of the server we are connected to\n+        # these are updated when connection is successfully made\n+        self.destination = None\n+\n+        # ID of the next request stream\n+        # Following the convention made by hyper-h2 each client ID\n+        # will be odd.\n+        self.stream_id_count = itertools.count(start=1, step=2)\n+\n+        # Streams are stored in a dictionary keyed off their stream IDs\n+        self.streams = {}\n+\n+        # Boolean to keep track the connection is made\n+        # If requests are received before connection is made\n+        # we keep all requests in a pool and send them as the connection\n+        # is made\n+        self.is_connection_made = False\n+        self._pending_request_stream_pool = deque()\n+\n+        # Some meta data of this connection\n+        # initialized when connection is successfully made\n+        self._metadata = {\n+            'certificate': None,\n+            'ip_address': None\n+        }\n+\n+    def _stream_close_cb(self, stream_id: int):\n+        \"\"\"Called when stream is closed completely\n+        \"\"\"\n+        self.streams.pop(stream_id, None)\n+\n+    def _new_stream(self, request: Request):\n+        \"\"\"Instantiates a new Stream object\n+        \"\"\"\n+        stream_id = next(self.stream_id_count)\n+\n+        stream = Stream(\n+            stream_id=stream_id,\n+            request=request,\n+            connection=self.conn,\n+            conn_metadata=self._metadata,\n+            write_to_transport=self._write_to_transport,\n+            cb_close=self._stream_close_cb\n+        )\n+\n+        self.streams[stream.stream_id] = stream\n+        return stream\n+\n+    def _send_pending_requests(self):\n+        # TODO: handle MAX_CONCURRENT_STREAMS\n+        # Initiate all pending requests\n+        while self._pending_request_stream_pool:\n+            stream = self._pending_request_stream_pool.popleft()\n+            stream.initiate_request()\n+\n+    def _write_to_transport(self):\n+        \"\"\" Write data to the underlying transport connection\n+        from the HTTP2 connection instance if any\n+        \"\"\"\n+        data = self.conn.data_to_send()\n+        self.transport.write(data)\n+\n+        LOGGER.debug(\"Sent {} bytes to {} via transport\".format(len(data), self._metadata['ip_address']))\n+\n+    def request(self, _request: Request):\n+        stream = self._new_stream(_request)\n+        d = stream.get_response()\n+\n+        # If connection is not yet established then add the\n+        # stream to pool or initiate request\n+        if self.is_connection_made:\n+            stream.initiate_request()\n+        else:\n+            self._pending_request_stream_pool.append(stream)\n+\n+        return d\n+\n+    def connectionMade(self):\n+        \"\"\"Called by Twisted when the connection is established. We can start\n+        sending some data now: we should open with the connection preamble.\n+        \"\"\"\n+        self.destination = self.transport.getPeer()\n+        LOGGER.info('Connection made to {}'.format(self.destination))\n+\n+        self._metadata['certificate'] = Certificate(self.transport.getPeerCertificate())\n+        self._metadata['ip_address'] = ipaddress.ip_address(self.destination.host)\n+\n+        self.conn.initiate_connection()\n+        self._write_to_transport()\n+        self.is_connection_made = True\n+\n+    def dataReceived(self, data):\n+        events = self.conn.receive_data(data)\n+        self._handle_events(events)\n+        self._write_to_transport()\n+\n+    def connectionLost(self, reason=connectionDone):\n+        \"\"\"Called by Twisted when the transport connection is lost.\n+        No need to write anything to transport here.\n+        \"\"\"\n+        # Pop all streams which were pending and were not yet started\n+        for stream_id in list(self.streams):\n+            self.streams[stream_id].close(StreamCloseReason.CONNECTION_LOST, reason)",
      "comment": "@elacuesta Some background: https://github.com/scrapy/scrapy/pull/4610#discussion_r440006977",
      "comment_id": 446976695,
      "user": "Gallaecio",
      "created_at": "2020-06-29T13:36:41Z",
      "url": "https://github.com/scrapy/scrapy/pull/4610#discussion_r446976695"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 4610,
      "file_path": "scrapy/core/http2/protocol.py",
      "line": 132,
      "side": "RIGHT",
      "diff_hunk": "@@ -0,0 +1,191 @@\n+import ipaddress\n+import itertools\n+import logging\n+from collections import deque\n+\n+from h2.config import H2Configuration\n+from h2.connection import H2Connection\n+from h2.events import (\n+    DataReceived, ResponseReceived, SettingsAcknowledged,\n+    StreamEnded, StreamReset, WindowUpdated\n+)\n+from twisted.internet.protocol import connectionDone, Protocol\n+from twisted.internet.ssl import Certificate\n+\n+from scrapy.core.http2.stream import Stream, StreamCloseReason\n+from scrapy.http import Request\n+\n+LOGGER = logging.getLogger(__name__)\n+\n+\n+class H2ClientProtocol(Protocol):\n+    # TODO:\n+    #  1. Check for user-agent while testing\n+    #  2. Handle case when received events have StreamID = 0 (applied to H2Connection)\n+\n+    def __init__(self):\n+        config = H2Configuration(client_side=True, header_encoding='utf-8')\n+        self.conn = H2Connection(config=config)\n+\n+        # Address of the server we are connected to\n+        # these are updated when connection is successfully made\n+        self.destination = None\n+\n+        # ID of the next request stream\n+        # Following the convention made by hyper-h2 each client ID\n+        # will be odd.\n+        self.stream_id_count = itertools.count(start=1, step=2)\n+\n+        # Streams are stored in a dictionary keyed off their stream IDs\n+        self.streams = {}\n+\n+        # Boolean to keep track the connection is made\n+        # If requests are received before connection is made\n+        # we keep all requests in a pool and send them as the connection\n+        # is made\n+        self.is_connection_made = False\n+        self._pending_request_stream_pool = deque()\n+\n+        # Some meta data of this connection\n+        # initialized when connection is successfully made\n+        self._metadata = {\n+            'certificate': None,\n+            'ip_address': None\n+        }\n+\n+    def _stream_close_cb(self, stream_id: int):\n+        \"\"\"Called when stream is closed completely\n+        \"\"\"\n+        self.streams.pop(stream_id, None)\n+\n+    def _new_stream(self, request: Request):\n+        \"\"\"Instantiates a new Stream object\n+        \"\"\"\n+        stream_id = next(self.stream_id_count)\n+\n+        stream = Stream(\n+            stream_id=stream_id,\n+            request=request,\n+            connection=self.conn,\n+            conn_metadata=self._metadata,\n+            write_to_transport=self._write_to_transport,\n+            cb_close=self._stream_close_cb\n+        )\n+\n+        self.streams[stream.stream_id] = stream\n+        return stream\n+\n+    def _send_pending_requests(self):\n+        # TODO: handle MAX_CONCURRENT_STREAMS\n+        # Initiate all pending requests\n+        while self._pending_request_stream_pool:\n+            stream = self._pending_request_stream_pool.popleft()\n+            stream.initiate_request()\n+\n+    def _write_to_transport(self):\n+        \"\"\" Write data to the underlying transport connection\n+        from the HTTP2 connection instance if any\n+        \"\"\"\n+        data = self.conn.data_to_send()\n+        self.transport.write(data)\n+\n+        LOGGER.debug(\"Sent {} bytes to {} via transport\".format(len(data), self._metadata['ip_address']))\n+\n+    def request(self, _request: Request):\n+        stream = self._new_stream(_request)\n+        d = stream.get_response()\n+\n+        # If connection is not yet established then add the\n+        # stream to pool or initiate request\n+        if self.is_connection_made:\n+            stream.initiate_request()\n+        else:\n+            self._pending_request_stream_pool.append(stream)\n+\n+        return d\n+\n+    def connectionMade(self):\n+        \"\"\"Called by Twisted when the connection is established. We can start\n+        sending some data now: we should open with the connection preamble.\n+        \"\"\"\n+        self.destination = self.transport.getPeer()\n+        LOGGER.info('Connection made to {}'.format(self.destination))\n+\n+        self._metadata['certificate'] = Certificate(self.transport.getPeerCertificate())\n+        self._metadata['ip_address'] = ipaddress.ip_address(self.destination.host)\n+\n+        self.conn.initiate_connection()\n+        self._write_to_transport()\n+        self.is_connection_made = True\n+\n+    def dataReceived(self, data):\n+        events = self.conn.receive_data(data)\n+        self._handle_events(events)\n+        self._write_to_transport()\n+\n+    def connectionLost(self, reason=connectionDone):\n+        \"\"\"Called by Twisted when the transport connection is lost.\n+        No need to write anything to transport here.\n+        \"\"\"\n+        # Pop all streams which were pending and were not yet started\n+        for stream_id in list(self.streams):\n+            self.streams[stream_id].close(StreamCloseReason.CONNECTION_LOST, reason)",
      "comment": "Oh right, I remember that. Makes sense, and the comment in https://github.com/scrapy/scrapy/commit/23906b6bee953d9bc5dd8042e785711b11840797#diff-a9927075d70e58a912f1e78ff3251186R143-R145 helps, but I'm not sure I like it. I will suggest a change in that thread.",
      "comment_id": 446989464,
      "user": "elacuesta",
      "created_at": "2020-06-29T13:54:17Z",
      "url": "https://github.com/scrapy/scrapy/pull/4610#discussion_r446989464"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 4610,
      "file_path": "scrapy/core/http2/protocol.py",
      "line": 200,
      "side": "RIGHT",
      "diff_hunk": "@@ -0,0 +1,204 @@\n+import ipaddress\n+import itertools\n+import logging\n+from collections import deque\n+from typing import Union, Dict\n+\n+from h2.config import H2Configuration\n+from h2.connection import H2Connection\n+from h2.events import (\n+    DataReceived, ResponseReceived, SettingsAcknowledged,\n+    StreamEnded, StreamReset, WindowUpdated\n+)\n+from h2.exceptions import ProtocolError\n+from twisted.internet.protocol import connectionDone, Protocol\n+from twisted.internet.ssl import Certificate\n+\n+from scrapy.core.http2.stream import Stream, StreamCloseReason\n+from scrapy.core.http2.types import H2ConnectionMetadataDict\n+from scrapy.http import Request\n+\n+logger = logging.getLogger(__name__)\n+\n+\n+class H2ClientProtocol(Protocol):\n+    def __init__(self):\n+        config = H2Configuration(client_side=True, header_encoding='utf-8')\n+        self.conn = H2Connection(config=config)\n+\n+        # Address of the server we are connected to\n+        # these are updated when connection is successfully made\n+        self.destination = None\n+\n+        # ID of the next request stream\n+        # Following the convention made by hyper-h2 each client ID\n+        # will be odd.\n+        self.stream_id_count = itertools.count(start=1, step=2)\n+\n+        # Streams are stored in a dictionary keyed off their stream IDs\n+        self.streams: Dict[int, Stream] = {}\n+\n+        # Boolean to keep track the connection is made\n+        # If requests are received before connection is made\n+        # we keep all requests in a pool and send them as the connection\n+        # is made\n+        self.is_connection_made = False\n+        self._pending_request_stream_pool = deque()\n+\n+        # Save an instance of ProtocolError raised by hyper-h2\n+        # We pass this instance to the streams ResponseFailed() failure\n+        self._protocol_error: Union[None, ProtocolError] = None\n+\n+        self._metadata: H2ConnectionMetadataDict = {\n+            'certificate': None,\n+            'ip_address': None\n+        }\n+\n+    def _stream_close_cb(self, stream_id: int):\n+        \"\"\"Called when stream is closed completely\n+        \"\"\"\n+        self.streams.pop(stream_id, None)\n+\n+    def _new_stream(self, request: Request):\n+        \"\"\"Instantiates a new Stream object\n+        \"\"\"\n+        stream_id = next(self.stream_id_count)\n+\n+        stream = Stream(\n+            stream_id=stream_id,\n+            request=request,\n+            connection=self.conn,\n+            conn_metadata=self._metadata,\n+            cb_close=self._stream_close_cb\n+        )\n+\n+        self.streams[stream.stream_id] = stream\n+        return stream\n+\n+    def _send_pending_requests(self):\n+        # TODO: handle MAX_CONCURRENT_STREAMS\n+        # Initiate all pending requests\n+        while self._pending_request_stream_pool:\n+            stream = self._pending_request_stream_pool.popleft()\n+            stream.initiate_request()\n+\n+    def _write_to_transport(self):\n+        \"\"\" Write data to the underlying transport connection\n+        from the HTTP2 connection instance if any\n+        \"\"\"\n+        data = self.conn.data_to_send()\n+        self.transport.write(data)\n+\n+        logger.debug(\"Sent {} bytes to {} via transport\".format(len(data), self._metadata['ip_address']))\n+\n+    def request(self, request: Request):\n+        stream = self._new_stream(request)\n+        d = stream.get_response()\n+\n+        # If connection is not yet established then add the\n+        # stream to pool or initiate request\n+        if self.is_connection_made:\n+            stream.initiate_request()\n+        else:\n+            self._pending_request_stream_pool.append(stream)\n+\n+        return d\n+\n+    def connectionMade(self):\n+        \"\"\"Called by Twisted when the connection is established. We can start\n+        sending some data now: we should open with the connection preamble.\n+        \"\"\"\n+        self.destination = self.transport.getPeer()\n+        logger.info('Connection made to {}'.format(self.destination))\n+\n+        self._metadata['certificate'] = Certificate(self.transport.getPeerCertificate())\n+        self._metadata['ip_address'] = ipaddress.ip_address(self.destination.host)\n+\n+        self.conn.initiate_connection()\n+        self._write_to_transport()\n+        self.is_connection_made = True\n+\n+    def dataReceived(self, data):\n+        try:\n+            events = self.conn.receive_data(data)\n+            self._handle_events(events)\n+        except ProtocolError as e:\n+            # TODO: In case of InvalidBodyLengthError -- terminate only one stream\n+\n+            # Save this error as ultimately the connection will be dropped\n+            # internally by hyper-h2. Saved error will be passed to all the streams\n+            # closed with the connection.\n+            self._protocol_error = e\n+\n+            # We lose the transport connection here\n+            self.transport.loseConnection()\n+        finally:\n+            self._write_to_transport()\n+\n+    def connectionLost(self, reason=connectionDone):\n+        \"\"\"Called by Twisted when the transport connection is lost.\n+        No need to write anything to transport here.\n+        \"\"\"\n+        # Pop all streams which were pending and were not yet started\n+        # NOTE: Stream.close() pops the element from the streams dictionary\n+        # which raises `RuntimeError: dictionary changed size during iteration`\n+        # Hence, we copy the streams into a list.\n+        for stream in list(self.streams.values()):\n+            stream.close(StreamCloseReason.CONNECTION_LOST, self._protocol_error)\n+\n+        self.conn.close_connection()\n+\n+        if not reason.check(connectionDone):\n+            logger.warning(\"Connection lost with reason \" + str(reason))\n+\n+    def _handle_events(self, events):\n+        \"\"\"Private method which acts as a bridge between the events\n+        received from the HTTP/2 data and IH2EventsHandler\n+\n+        Arguments:\n+            events {list} -- A list of events that the remote peer\n+                triggered by sending data\n+        \"\"\"\n+        for event in events:\n+            logger.debug(event)\n+            if isinstance(event, DataReceived):\n+                self.data_received(event)\n+            elif isinstance(event, ResponseReceived):\n+                self.response_received(event)\n+            elif isinstance(event, StreamEnded):\n+                self.stream_ended(event)\n+            elif isinstance(event, StreamReset):\n+                self.stream_reset(event)\n+            elif isinstance(event, WindowUpdated):\n+                self.window_updated(event)\n+            elif isinstance(event, SettingsAcknowledged):\n+                self.settings_acknowledged(event)\n+            else:\n+                logger.info(\"Received unhandled event {}\".format(event))\n+\n+    # Event handler functions starts here\n+    def data_received(self, event: DataReceived):\n+        self.streams[event.stream_id].receive_data(event.data, event.flow_controlled_length)\n+\n+    def response_received(self, event: ResponseReceived):\n+        self.streams[event.stream_id].receive_headers(event.headers)\n+\n+    def settings_acknowledged(self, event: SettingsAcknowledged):\n+        # Send off all the pending requests\n+        # as now we have established a proper HTTP/2 connection\n+        self._send_pending_requests()\n+\n+    def stream_ended(self, event: StreamEnded):\n+        self.streams[event.stream_id].close(StreamCloseReason.ENDED)\n+\n+    def stream_reset(self, event: StreamReset):\n+        self.streams[event.stream_id].close(StreamCloseReason.RESET)\n+\n+    def window_updated(self, event: WindowUpdated):\n+        stream_id = event.stream_id\n+        if stream_id != 0:\n+            self.streams[stream_id].receive_window_update()",
      "comment": "```suggestion\r\n        if event.stream_id != 0:\r\n            self.streams[event.stream_id].receive_window_update()\r\n```\r\n\r\nA small simplification.",
      "comment_id": 446994643,
      "user": "elacuesta",
      "created_at": "2020-06-29T14:01:18Z",
      "url": "https://github.com/scrapy/scrapy/pull/4610#discussion_r446994643"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 4610,
      "file_path": "scrapy/core/http2/protocol.py",
      "line": 147,
      "side": "RIGHT",
      "diff_hunk": "@@ -0,0 +1,204 @@\n+import ipaddress\n+import itertools\n+import logging\n+from collections import deque\n+from typing import Union, Dict\n+\n+from h2.config import H2Configuration\n+from h2.connection import H2Connection\n+from h2.events import (\n+    DataReceived, ResponseReceived, SettingsAcknowledged,\n+    StreamEnded, StreamReset, WindowUpdated\n+)\n+from h2.exceptions import ProtocolError\n+from twisted.internet.protocol import connectionDone, Protocol\n+from twisted.internet.ssl import Certificate\n+\n+from scrapy.core.http2.stream import Stream, StreamCloseReason\n+from scrapy.core.http2.types import H2ConnectionMetadataDict\n+from scrapy.http import Request\n+\n+logger = logging.getLogger(__name__)\n+\n+\n+class H2ClientProtocol(Protocol):\n+    def __init__(self):\n+        config = H2Configuration(client_side=True, header_encoding='utf-8')\n+        self.conn = H2Connection(config=config)\n+\n+        # Address of the server we are connected to\n+        # these are updated when connection is successfully made\n+        self.destination = None\n+\n+        # ID of the next request stream\n+        # Following the convention made by hyper-h2 each client ID\n+        # will be odd.\n+        self.stream_id_count = itertools.count(start=1, step=2)\n+\n+        # Streams are stored in a dictionary keyed off their stream IDs\n+        self.streams: Dict[int, Stream] = {}\n+\n+        # Boolean to keep track the connection is made\n+        # If requests are received before connection is made\n+        # we keep all requests in a pool and send them as the connection\n+        # is made\n+        self.is_connection_made = False\n+        self._pending_request_stream_pool = deque()\n+\n+        # Save an instance of ProtocolError raised by hyper-h2\n+        # We pass this instance to the streams ResponseFailed() failure\n+        self._protocol_error: Union[None, ProtocolError] = None\n+\n+        self._metadata: H2ConnectionMetadataDict = {\n+            'certificate': None,\n+            'ip_address': None\n+        }\n+\n+    def _stream_close_cb(self, stream_id: int):\n+        \"\"\"Called when stream is closed completely\n+        \"\"\"\n+        self.streams.pop(stream_id, None)\n+\n+    def _new_stream(self, request: Request):\n+        \"\"\"Instantiates a new Stream object\n+        \"\"\"\n+        stream_id = next(self.stream_id_count)\n+\n+        stream = Stream(\n+            stream_id=stream_id,\n+            request=request,\n+            connection=self.conn,\n+            conn_metadata=self._metadata,\n+            cb_close=self._stream_close_cb\n+        )\n+\n+        self.streams[stream.stream_id] = stream\n+        return stream\n+\n+    def _send_pending_requests(self):\n+        # TODO: handle MAX_CONCURRENT_STREAMS\n+        # Initiate all pending requests\n+        while self._pending_request_stream_pool:\n+            stream = self._pending_request_stream_pool.popleft()\n+            stream.initiate_request()\n+\n+    def _write_to_transport(self):\n+        \"\"\" Write data to the underlying transport connection\n+        from the HTTP2 connection instance if any\n+        \"\"\"\n+        data = self.conn.data_to_send()\n+        self.transport.write(data)\n+\n+        logger.debug(\"Sent {} bytes to {} via transport\".format(len(data), self._metadata['ip_address']))\n+\n+    def request(self, request: Request):\n+        stream = self._new_stream(request)\n+        d = stream.get_response()\n+\n+        # If connection is not yet established then add the\n+        # stream to pool or initiate request\n+        if self.is_connection_made:\n+            stream.initiate_request()\n+        else:\n+            self._pending_request_stream_pool.append(stream)\n+\n+        return d\n+\n+    def connectionMade(self):\n+        \"\"\"Called by Twisted when the connection is established. We can start\n+        sending some data now: we should open with the connection preamble.\n+        \"\"\"\n+        self.destination = self.transport.getPeer()\n+        logger.info('Connection made to {}'.format(self.destination))\n+\n+        self._metadata['certificate'] = Certificate(self.transport.getPeerCertificate())\n+        self._metadata['ip_address'] = ipaddress.ip_address(self.destination.host)\n+\n+        self.conn.initiate_connection()\n+        self._write_to_transport()\n+        self.is_connection_made = True\n+\n+    def dataReceived(self, data):\n+        try:\n+            events = self.conn.receive_data(data)\n+            self._handle_events(events)\n+        except ProtocolError as e:\n+            # TODO: In case of InvalidBodyLengthError -- terminate only one stream\n+\n+            # Save this error as ultimately the connection will be dropped\n+            # internally by hyper-h2. Saved error will be passed to all the streams\n+            # closed with the connection.\n+            self._protocol_error = e\n+\n+            # We lose the transport connection here\n+            self.transport.loseConnection()\n+        finally:\n+            self._write_to_transport()\n+\n+    def connectionLost(self, reason=connectionDone):\n+        \"\"\"Called by Twisted when the transport connection is lost.\n+        No need to write anything to transport here.\n+        \"\"\"\n+        # Pop all streams which were pending and were not yet started\n+        # NOTE: Stream.close() pops the element from the streams dictionary\n+        # which raises `RuntimeError: dictionary changed size during iteration`\n+        # Hence, we copy the streams into a list.\n+        for stream in list(self.streams.values()):\n+            stream.close(StreamCloseReason.CONNECTION_LOST, self._protocol_error)",
      "comment": "@adityaa30 @Gallaecio I still don't like the fact that a Stream ends up being responsible from removing itself from the streams dict, and that this implementation detail demands the need to create a new structure here. What about this?\r\n```suggestion\r\n        for stream in self.streams.values():\r\n            stream.close(StreamCloseReason.CONNECTION_LOST, self._protocol_error)\r\n        self.streams.clear()\r\n```\r\nSince all streams will be popped anyway.\r\n",
      "comment_id": 447240521,
      "user": "elacuesta",
      "created_at": "2020-06-29T20:40:36Z",
      "url": "https://github.com/scrapy/scrapy/pull/4610#discussion_r447240521"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 4610,
      "file_path": "scrapy/core/http2/protocol.py",
      "line": 147,
      "side": "RIGHT",
      "diff_hunk": "@@ -0,0 +1,204 @@\n+import ipaddress\n+import itertools\n+import logging\n+from collections import deque\n+from typing import Union, Dict\n+\n+from h2.config import H2Configuration\n+from h2.connection import H2Connection\n+from h2.events import (\n+    DataReceived, ResponseReceived, SettingsAcknowledged,\n+    StreamEnded, StreamReset, WindowUpdated\n+)\n+from h2.exceptions import ProtocolError\n+from twisted.internet.protocol import connectionDone, Protocol\n+from twisted.internet.ssl import Certificate\n+\n+from scrapy.core.http2.stream import Stream, StreamCloseReason\n+from scrapy.core.http2.types import H2ConnectionMetadataDict\n+from scrapy.http import Request\n+\n+logger = logging.getLogger(__name__)\n+\n+\n+class H2ClientProtocol(Protocol):\n+    def __init__(self):\n+        config = H2Configuration(client_side=True, header_encoding='utf-8')\n+        self.conn = H2Connection(config=config)\n+\n+        # Address of the server we are connected to\n+        # these are updated when connection is successfully made\n+        self.destination = None\n+\n+        # ID of the next request stream\n+        # Following the convention made by hyper-h2 each client ID\n+        # will be odd.\n+        self.stream_id_count = itertools.count(start=1, step=2)\n+\n+        # Streams are stored in a dictionary keyed off their stream IDs\n+        self.streams: Dict[int, Stream] = {}\n+\n+        # Boolean to keep track the connection is made\n+        # If requests are received before connection is made\n+        # we keep all requests in a pool and send them as the connection\n+        # is made\n+        self.is_connection_made = False\n+        self._pending_request_stream_pool = deque()\n+\n+        # Save an instance of ProtocolError raised by hyper-h2\n+        # We pass this instance to the streams ResponseFailed() failure\n+        self._protocol_error: Union[None, ProtocolError] = None\n+\n+        self._metadata: H2ConnectionMetadataDict = {\n+            'certificate': None,\n+            'ip_address': None\n+        }\n+\n+    def _stream_close_cb(self, stream_id: int):\n+        \"\"\"Called when stream is closed completely\n+        \"\"\"\n+        self.streams.pop(stream_id, None)\n+\n+    def _new_stream(self, request: Request):\n+        \"\"\"Instantiates a new Stream object\n+        \"\"\"\n+        stream_id = next(self.stream_id_count)\n+\n+        stream = Stream(\n+            stream_id=stream_id,\n+            request=request,\n+            connection=self.conn,\n+            conn_metadata=self._metadata,\n+            cb_close=self._stream_close_cb\n+        )\n+\n+        self.streams[stream.stream_id] = stream\n+        return stream\n+\n+    def _send_pending_requests(self):\n+        # TODO: handle MAX_CONCURRENT_STREAMS\n+        # Initiate all pending requests\n+        while self._pending_request_stream_pool:\n+            stream = self._pending_request_stream_pool.popleft()\n+            stream.initiate_request()\n+\n+    def _write_to_transport(self):\n+        \"\"\" Write data to the underlying transport connection\n+        from the HTTP2 connection instance if any\n+        \"\"\"\n+        data = self.conn.data_to_send()\n+        self.transport.write(data)\n+\n+        logger.debug(\"Sent {} bytes to {} via transport\".format(len(data), self._metadata['ip_address']))\n+\n+    def request(self, request: Request):\n+        stream = self._new_stream(request)\n+        d = stream.get_response()\n+\n+        # If connection is not yet established then add the\n+        # stream to pool or initiate request\n+        if self.is_connection_made:\n+            stream.initiate_request()\n+        else:\n+            self._pending_request_stream_pool.append(stream)\n+\n+        return d\n+\n+    def connectionMade(self):\n+        \"\"\"Called by Twisted when the connection is established. We can start\n+        sending some data now: we should open with the connection preamble.\n+        \"\"\"\n+        self.destination = self.transport.getPeer()\n+        logger.info('Connection made to {}'.format(self.destination))\n+\n+        self._metadata['certificate'] = Certificate(self.transport.getPeerCertificate())\n+        self._metadata['ip_address'] = ipaddress.ip_address(self.destination.host)\n+\n+        self.conn.initiate_connection()\n+        self._write_to_transport()\n+        self.is_connection_made = True\n+\n+    def dataReceived(self, data):\n+        try:\n+            events = self.conn.receive_data(data)\n+            self._handle_events(events)\n+        except ProtocolError as e:\n+            # TODO: In case of InvalidBodyLengthError -- terminate only one stream\n+\n+            # Save this error as ultimately the connection will be dropped\n+            # internally by hyper-h2. Saved error will be passed to all the streams\n+            # closed with the connection.\n+            self._protocol_error = e\n+\n+            # We lose the transport connection here\n+            self.transport.loseConnection()\n+        finally:\n+            self._write_to_transport()\n+\n+    def connectionLost(self, reason=connectionDone):\n+        \"\"\"Called by Twisted when the transport connection is lost.\n+        No need to write anything to transport here.\n+        \"\"\"\n+        # Pop all streams which were pending and were not yet started\n+        # NOTE: Stream.close() pops the element from the streams dictionary\n+        # which raises `RuntimeError: dictionary changed size during iteration`\n+        # Hence, we copy the streams into a list.\n+        for stream in list(self.streams.values()):\n+            stream.close(StreamCloseReason.CONNECTION_LOST, self._protocol_error)",
      "comment": "This looks good. I have one doubt -- the `Stream` class under differnet conditions closes itself. Eg. the client cancels the request by calling `response_defer.cancel()`. For such cases what should we do? :thinking: ",
      "comment_id": 447350941,
      "user": "adityaa30",
      "created_at": "2020-06-30T01:18:56Z",
      "url": "https://github.com/scrapy/scrapy/pull/4610#discussion_r447350941"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 4610,
      "file_path": "scrapy/core/http2/types.py",
      "line": 17,
      "side": "RIGHT",
      "diff_hunk": "@@ -0,0 +1,30 @@\n+from io import BytesIO\n+from ipaddress import IPv4Address, IPv6Address\n+from typing import Union\n+\n+from twisted.internet.ssl import Certificate\n+# for python < 3.8 -- typing.TypedDict is undefined\n+from typing_extensions import TypedDict\n+\n+from scrapy.http.headers import Headers\n+\n+\n+class H2ConnectionMetadataDict(TypedDict):\n+    \"\"\"Some meta data of this connection\n+    initialized when connection is successfully made\n+    \"\"\"\n+    certificate: Union[None, Certificate]\n+    ip_address: Union[None, IPv4Address, IPv6Address]",
      "comment": "```suggestion\r\n    certificate: Optional[Certificate]\r\n    ip_address: Optional[Union[IPv4Address, IPv6Address]]\r\n```",
      "comment_id": 447677562,
      "user": "elacuesta",
      "created_at": "2020-06-30T13:22:51Z",
      "url": "https://github.com/scrapy/scrapy/pull/4610#discussion_r447677562"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 4610,
      "file_path": "setup.py",
      "line": 1,
      "side": "RIGHT",
      "diff_hunk": "@@ -1,8 +1,8 @@\n from os.path import dirname, join",
      "comment": "Nitpick: the white lines in this file should be left unmodified",
      "comment_id": 447679200,
      "user": "elacuesta",
      "created_at": "2020-06-30T13:25:05Z",
      "url": "https://github.com/scrapy/scrapy/pull/4610#discussion_r447679200"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 4610,
      "file_path": "scrapy/core/http2/protocol.py",
      "line": 147,
      "side": "RIGHT",
      "diff_hunk": "@@ -0,0 +1,204 @@\n+import ipaddress\n+import itertools\n+import logging\n+from collections import deque\n+from typing import Union, Dict\n+\n+from h2.config import H2Configuration\n+from h2.connection import H2Connection\n+from h2.events import (\n+    DataReceived, ResponseReceived, SettingsAcknowledged,\n+    StreamEnded, StreamReset, WindowUpdated\n+)\n+from h2.exceptions import ProtocolError\n+from twisted.internet.protocol import connectionDone, Protocol\n+from twisted.internet.ssl import Certificate\n+\n+from scrapy.core.http2.stream import Stream, StreamCloseReason\n+from scrapy.core.http2.types import H2ConnectionMetadataDict\n+from scrapy.http import Request\n+\n+logger = logging.getLogger(__name__)\n+\n+\n+class H2ClientProtocol(Protocol):\n+    def __init__(self):\n+        config = H2Configuration(client_side=True, header_encoding='utf-8')\n+        self.conn = H2Connection(config=config)\n+\n+        # Address of the server we are connected to\n+        # these are updated when connection is successfully made\n+        self.destination = None\n+\n+        # ID of the next request stream\n+        # Following the convention made by hyper-h2 each client ID\n+        # will be odd.\n+        self.stream_id_count = itertools.count(start=1, step=2)\n+\n+        # Streams are stored in a dictionary keyed off their stream IDs\n+        self.streams: Dict[int, Stream] = {}\n+\n+        # Boolean to keep track the connection is made\n+        # If requests are received before connection is made\n+        # we keep all requests in a pool and send them as the connection\n+        # is made\n+        self.is_connection_made = False\n+        self._pending_request_stream_pool = deque()\n+\n+        # Save an instance of ProtocolError raised by hyper-h2\n+        # We pass this instance to the streams ResponseFailed() failure\n+        self._protocol_error: Union[None, ProtocolError] = None\n+\n+        self._metadata: H2ConnectionMetadataDict = {\n+            'certificate': None,\n+            'ip_address': None\n+        }\n+\n+    def _stream_close_cb(self, stream_id: int):\n+        \"\"\"Called when stream is closed completely\n+        \"\"\"\n+        self.streams.pop(stream_id, None)\n+\n+    def _new_stream(self, request: Request):\n+        \"\"\"Instantiates a new Stream object\n+        \"\"\"\n+        stream_id = next(self.stream_id_count)\n+\n+        stream = Stream(\n+            stream_id=stream_id,\n+            request=request,\n+            connection=self.conn,\n+            conn_metadata=self._metadata,\n+            cb_close=self._stream_close_cb\n+        )\n+\n+        self.streams[stream.stream_id] = stream\n+        return stream\n+\n+    def _send_pending_requests(self):\n+        # TODO: handle MAX_CONCURRENT_STREAMS\n+        # Initiate all pending requests\n+        while self._pending_request_stream_pool:\n+            stream = self._pending_request_stream_pool.popleft()\n+            stream.initiate_request()\n+\n+    def _write_to_transport(self):\n+        \"\"\" Write data to the underlying transport connection\n+        from the HTTP2 connection instance if any\n+        \"\"\"\n+        data = self.conn.data_to_send()\n+        self.transport.write(data)\n+\n+        logger.debug(\"Sent {} bytes to {} via transport\".format(len(data), self._metadata['ip_address']))\n+\n+    def request(self, request: Request):\n+        stream = self._new_stream(request)\n+        d = stream.get_response()\n+\n+        # If connection is not yet established then add the\n+        # stream to pool or initiate request\n+        if self.is_connection_made:\n+            stream.initiate_request()\n+        else:\n+            self._pending_request_stream_pool.append(stream)\n+\n+        return d\n+\n+    def connectionMade(self):\n+        \"\"\"Called by Twisted when the connection is established. We can start\n+        sending some data now: we should open with the connection preamble.\n+        \"\"\"\n+        self.destination = self.transport.getPeer()\n+        logger.info('Connection made to {}'.format(self.destination))\n+\n+        self._metadata['certificate'] = Certificate(self.transport.getPeerCertificate())\n+        self._metadata['ip_address'] = ipaddress.ip_address(self.destination.host)\n+\n+        self.conn.initiate_connection()\n+        self._write_to_transport()\n+        self.is_connection_made = True\n+\n+    def dataReceived(self, data):\n+        try:\n+            events = self.conn.receive_data(data)\n+            self._handle_events(events)\n+        except ProtocolError as e:\n+            # TODO: In case of InvalidBodyLengthError -- terminate only one stream\n+\n+            # Save this error as ultimately the connection will be dropped\n+            # internally by hyper-h2. Saved error will be passed to all the streams\n+            # closed with the connection.\n+            self._protocol_error = e\n+\n+            # We lose the transport connection here\n+            self.transport.loseConnection()\n+        finally:\n+            self._write_to_transport()\n+\n+    def connectionLost(self, reason=connectionDone):\n+        \"\"\"Called by Twisted when the transport connection is lost.\n+        No need to write anything to transport here.\n+        \"\"\"\n+        # Pop all streams which were pending and were not yet started\n+        # NOTE: Stream.close() pops the element from the streams dictionary\n+        # which raises `RuntimeError: dictionary changed size during iteration`\n+        # Hence, we copy the streams into a list.\n+        for stream in list(self.streams.values()):\n+            stream.close(StreamCloseReason.CONNECTION_LOST, self._protocol_error)",
      "comment": "Interesting. In that case, perhaps the stream could hold a reference to its parent protocol. It already stores a `H2ConnectionMetadataDict` with metadata, it could store the protocol itself instead of it.",
      "comment_id": 447680964,
      "user": "elacuesta",
      "created_at": "2020-06-30T13:27:30Z",
      "url": "https://github.com/scrapy/scrapy/pull/4610#discussion_r447680964"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 4610,
      "file_path": "scrapy/core/http2/stream.py",
      "line": 134,
      "side": "RIGHT",
      "diff_hunk": "@@ -131,7 +131,7 @@ def _cancel(_):\n         self._deferred_response = Deferred(_cancel)\n \n     def __str__(self):\n-        return \"Stream(id={})\".format(repr(self.stream_id))\n+        return f'Stream(id={self.stream_id})'",
      "comment": "```suggestion\r\n        return f'Stream(id={self.stream_id!r})'\r\n```",
      "comment_id": 448252470,
      "user": "Gallaecio",
      "created_at": "2020-07-01T09:55:24Z",
      "url": "https://github.com/scrapy/scrapy/pull/4610#discussion_r448252470"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 4610,
      "file_path": "scrapy/core/http2/stream.py",
      "line": 169,
      "side": "RIGHT",
      "diff_hunk": "@@ -167,13 +167,15 @@ def _get_request_headers(self):\n         url = urlparse(self._request.url)\n \n         # Make sure pseudo-headers comes before all the other headers",
      "comment": "This comment should probably be below, specially since you introduced an empty line to separate `path` changes from `headers` definition.",
      "comment_id": 448253961,
      "user": "Gallaecio",
      "created_at": "2020-07-01T09:58:03Z",
      "url": "https://github.com/scrapy/scrapy/pull/4610#discussion_r448253961"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 4610,
      "file_path": "scrapy/core/http2/stream.py",
      "line": 258,
      "side": "RIGHT",
      "diff_hunk": "@@ -253,14 +255,9 @@ def receive_data(self, data: bytes, flow_controlled_length: int):\n \n         if self._log_warnsize:\n             self._reached_warnsize = True\n-            warning_msg = 'Received more ({bytes}) bytes than download ' \\\n-                          + 'warn size ({warnsize}) in request {request}'\n-            warning_args = {\n-                'bytes': self._response['flow_controlled_size'],\n-                'warnsize': self._download_warnsize,\n-                'request': self._request\n-            }\n-            logger.warning(warning_msg.format(**warning_args))\n+            warning_msg = f\"Received more ({self._response['flow_controlled_size']}) bytes than download \" \\",
      "comment": "In Scrapy, we tend to prefer\r\n\r\n```python\r\nvariable = (\"string over \"\r\n            \"multiple lines\")\r\n```\r\n\r\nor, specially with longer strings,\r\n\r\n```python\r\nvariable = (\r\n    \"string over \"\r\n    \"multiple lines\"\r\n)\r\n```\r\n\r\nover\r\n\r\n```python\r\nvariable = \"string over \" \\\r\n           + \"multiple lines\"\r\n```",
      "comment_id": 448256050,
      "user": "Gallaecio",
      "created_at": "2020-07-01T10:01:42Z",
      "url": "https://github.com/scrapy/scrapy/pull/4610#discussion_r448256050"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 4610,
      "file_path": "scrapy/utils/log.py",
      "line": 55,
      "side": "RIGHT",
      "diff_hunk": "@@ -52,6 +52,9 @@ def filter(self, record):\n         'twisted': {\n             'level': 'ERROR',\n         },\n+        'hpack': {",
      "comment": ":lipstick:  What about keeping this alphabetical? hpack, scrapy, twisted.",
      "comment_id": 450104266,
      "user": "Gallaecio",
      "created_at": "2020-07-06T09:39:41Z",
      "url": "https://github.com/scrapy/scrapy/pull/4610#discussion_r450104266"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 4610,
      "file_path": "scrapy/core/http2/stream.py",
      "line": 386,
      "side": "RIGHT",
      "diff_hunk": "@@ -0,0 +1,422 @@\n+import logging\n+from enum import Enum\n+from io import BytesIO\n+from typing import Callable, List\n+from urllib.parse import urlparse\n+\n+from h2.connection import H2Connection\n+from h2.errors import ErrorCodes\n+from h2.exceptions import StreamClosedError\n+from twisted.internet.defer import Deferred, CancelledError\n+from twisted.internet.error import ConnectionClosed\n+from twisted.python.failure import Failure\n+from twisted.web.client import ResponseFailed\n+\n+from scrapy.core.http2.types import H2ConnectionMetadataDict, H2ResponseDict\n+from scrapy.http import Request\n+from scrapy.http.headers import Headers\n+from scrapy.responsetypes import responsetypes\n+\n+logger = logging.getLogger(__name__)\n+\n+\n+class InactiveStreamClosed(ConnectionClosed):\n+    \"\"\"Connection was closed without sending request headers\n+    of the stream. This happens when a stream is waiting for other\n+    streams to close and connection is lost.\"\"\"\n+\n+    def __init__(self, request: Request):\n+        self.request = request\n+\n+\n+class InvalidHostname(Exception):\n+\n+    def __init__(self, request: Request, expected_hostname, expected_netloc):\n+        self.request = request\n+        self.expected_hostname = expected_hostname\n+        self.expected_netloc = expected_netloc\n+\n+    def __str__(self):\n+        return f'InvalidHostname: Expected {self.expected_hostname} or {self.expected_netloc} in {self.request}'\n+\n+\n+class StreamCloseReason(Enum):\n+    # Received a StreamEnded event\n+    ENDED = 1\n+\n+    # Received a StreamReset event -- ended abruptly\n+    RESET = 2\n+\n+    # Transport connection was lost\n+    CONNECTION_LOST = 3\n+\n+    # Expected response body size is more than allowed limit\n+    MAXSIZE_EXCEEDED = 4\n+\n+    # Response deferred is cancelled by the client\n+    # (happens when client called response_deferred.cancel())\n+    CANCELLED = 5\n+\n+    # Connection lost and the stream was not initiated\n+    INACTIVE = 6\n+\n+    # The hostname of the request is not same as of connected peer hostname\n+    # As a result sending this request will the end the connection\n+    INVALID_HOSTNAME = 7\n+\n+\n+class Stream:\n+    \"\"\"Represents a single HTTP/2 Stream.\n+\n+    Stream is a bidirectional flow of bytes within an established connection,\n+    which may carry one or more messages. Handles the transfer of HTTP Headers\n+    and Data frames.\n+\n+    Role of this class is to\n+    1. Combine all the data frames\n+    \"\"\"\n+\n+    def __init__(\n+        self,\n+        stream_id: int,\n+        request: Request,\n+        connection: H2Connection,\n+        conn_metadata: H2ConnectionMetadataDict,\n+        cb_close: Callable[[int], None],\n+        download_maxsize: int = 0,\n+        download_warnsize: int = 0,\n+        fail_on_data_loss: bool = True\n+    ):\n+        \"\"\"\n+        Arguments:\n+            stream_id -- For one HTTP/2 connection each stream is\n+                uniquely identified by a single integer\n+            request -- HTTP request\n+            connection -- HTTP/2 connection this stream belongs to.\n+            conn_metadata -- Reference to dictionary having metadata of HTTP/2 connection\n+            cb_close -- Method called when this stream is closed\n+                to notify the TCP connection instance.\n+        \"\"\"\n+        self.stream_id = stream_id\n+        self._request = request\n+        self._conn = connection\n+        self._conn_metadata = conn_metadata\n+        self._cb_close = cb_close\n+\n+        self._download_maxsize = self._request.meta.get('download_maxsize', download_maxsize)\n+        self._download_warnsize = self._request.meta.get('download_warnsize', download_warnsize)\n+        self._fail_on_dataloss = self._request.meta.get('download_fail_on_dataloss', fail_on_data_loss)\n+\n+        self.request_start_time = None\n+\n+        self.content_length = 0 if self._request.body is None else len(self._request.body)\n+\n+        # Flag to keep track whether this stream has initiated the request\n+        self.request_sent = False\n+\n+        # Flag to track whether we have logged about exceeding download warnsize\n+        self._reached_warnsize = False\n+\n+        # Each time we send a data frame, we will decrease value by the amount send.\n+        self.remaining_content_length = self.content_length\n+\n+        # Flag to keep track whether we have closed this stream\n+        self.stream_closed_local = False\n+\n+        # Flag to keep track whether the server has closed the stream\n+        self.stream_closed_server = False\n+\n+        # Private variable used to build the response\n+        # this response is then converted to appropriate Response class\n+        # passed to the response deferred callback\n+        self._response: H2ResponseDict = {\n+            'body': BytesIO(),\n+            'flow_controlled_size': 0,\n+            'headers': Headers({})\n+        }\n+\n+        def _cancel(_):\n+            # Close this stream as gracefully as possible\n+            # Check if the stream has started\n+            if self.request_sent:\n+                self.reset_stream(StreamCloseReason.CANCELLED)\n+            else:\n+                self.close(StreamCloseReason.CANCELLED)\n+\n+        self._deferred_response = Deferred(_cancel)\n+\n+    def __str__(self):\n+        return f'Stream(id={self.stream_id!r})'\n+\n+    __repr__ = __str__\n+\n+    @property\n+    def _log_warnsize(self) -> bool:\n+        \"\"\"Checks if we have received data which exceeds the download warnsize\n+        and whether we have not already logged about it.\n+\n+        Returns:\n+            True if both the above conditions hold true\n+            False if any of the conditions is false\n+        \"\"\"\n+        content_length_header = int(self._response['headers'].get(b'Content-Length', -1))\n+        return (\n+            self._download_warnsize\n+            and (\n+                self._response['flow_controlled_size'] > self._download_warnsize\n+                or content_length_header > self._download_warnsize\n+            )\n+            and not self._reached_warnsize\n+        )\n+\n+    def get_response(self):\n+        \"\"\"Simply return a Deferred which fires when response\n+        from the asynchronous request is available\n+\n+        Returns:\n+            Deferred -- Calls the callback passing the response\n+        \"\"\"\n+        return self._deferred_response\n+\n+    def check_request_url(self) -> bool:\n+        # Make sure that we are sending the request to the correct URL\n+        url = urlparse(self._request.url)\n+        return (\n+            url.netloc == self._conn_metadata['hostname']\n+            or url.netloc == f'{self._conn_metadata[\"hostname\"]}:{self._conn_metadata[\"port\"]}'\n+            or url.netloc == f'{self._conn_metadata[\"ip_address\"]}:{self._conn_metadata[\"port\"]}'\n+        )\n+\n+    def _get_request_headers(self):\n+        url = urlparse(self._request.url)\n+\n+        path = url.path\n+        if url.query:\n+            path += '?' + url.query\n+\n+        # Make sure pseudo-headers comes before all the other headers\n+        headers = [\n+            (':method', self._request.method),\n+            (':authority', url.netloc),\n+            (':scheme', 'https'),\n+            (':path', path),\n+        ]\n+\n+        for name, value in self._request.headers.items():\n+            headers.append((name, value[0]))\n+\n+        return headers\n+\n+    def initiate_request(self):\n+        if self.check_request_url():\n+            headers = self._get_request_headers()\n+            self._conn.send_headers(self.stream_id, headers, end_stream=False)\n+            self.request_sent = True\n+            self.send_data()\n+        else:\n+            # Close this stream calling the response errback\n+            # Note that we have not sent any headers\n+            self.close(StreamCloseReason.INVALID_HOSTNAME)\n+\n+    def send_data(self):\n+        \"\"\"Called immediately after the headers are sent. Here we send all the\n+         data as part of the request.\n+\n+         If the content length is 0 initially then we end the stream immediately and\n+         wait for response data.\n+\n+         Warning: Only call this method when stream not closed from client side\n+            and has initiated request already by sending HEADER frame. If not then\n+            stream will raise ProtocolError (raise by h2 state machine).\n+         \"\"\"\n+        if self.stream_closed_local:\n+            raise StreamClosedError(self.stream_id)\n+\n+        # Firstly, check what the flow control window is for current stream.\n+        window_size = self._conn.local_flow_control_window(stream_id=self.stream_id)\n+\n+        # Next, check what the maximum frame size is.\n+        max_frame_size = self._conn.max_outbound_frame_size\n+\n+        # We will send no more than the window size or the remaining file size\n+        # of data in this call, whichever is smaller.\n+        bytes_to_send_size = min(window_size, self.remaining_content_length)\n+\n+        # We now need to send a number of data frames.\n+        while bytes_to_send_size > 0:\n+            chunk_size = min(bytes_to_send_size, max_frame_size)\n+\n+            data_chunk_start_id = self.content_length - self.remaining_content_length\n+            data_chunk = self._request.body[data_chunk_start_id:data_chunk_start_id + chunk_size]\n+\n+            self._conn.send_data(self.stream_id, data_chunk, end_stream=False)\n+\n+            bytes_to_send_size = bytes_to_send_size - chunk_size\n+            self.remaining_content_length = self.remaining_content_length - chunk_size\n+\n+        self.remaining_content_length = max(0, self.remaining_content_length)\n+\n+        # End the stream if no more data needs to be send\n+        if self.remaining_content_length == 0:\n+            self._conn.end_stream(self.stream_id)\n+\n+        # Q. What about the rest of the data?\n+        # Ans: Remaining Data frames will be sent when we get a WindowUpdate frame\n+\n+    def receive_window_update(self):\n+        \"\"\"Flow control window size was changed.\n+        Send data that earlier could not be sent as we were\n+        blocked behind the flow control.\n+        \"\"\"\n+        if self.remaining_content_length and not self.stream_closed_server and self.request_sent:\n+            self.send_data()\n+\n+    def receive_data(self, data: bytes, flow_controlled_length: int):\n+        self._response['body'].write(data)\n+        self._response['flow_controlled_size'] += flow_controlled_length\n+\n+        # We check maxsize here in case the Content-Length header was not received\n+        if self._download_maxsize and self._response['flow_controlled_size'] > self._download_maxsize:\n+            self.reset_stream(StreamCloseReason.MAXSIZE_EXCEEDED)\n+            return\n+\n+        if self._log_warnsize:\n+            self._reached_warnsize = True\n+            warning_msg = (\n+                f'Received more ({self._response[\"flow_controlled_size\"]}) bytes than download '\n+                f'warn size ({self._download_warnsize}) in request {self._request}'\n+            )\n+            logger.warning(warning_msg)\n+\n+        # Acknowledge the data received\n+        self._conn.acknowledge_received_data(\n+            self._response['flow_controlled_size'],\n+            self.stream_id\n+        )\n+\n+    def receive_headers(self, headers):\n+        for name, value in headers:\n+            self._response['headers'][name] = value\n+\n+        # Check if we exceed the allowed max data size which can be received\n+        expected_size = int(self._response['headers'].get(b'Content-Length', -1))\n+        if self._download_maxsize and expected_size > self._download_maxsize:\n+            self.reset_stream(StreamCloseReason.MAXSIZE_EXCEEDED)\n+            return\n+\n+        if self._log_warnsize:\n+            self._reached_warnsize = True\n+            warning_msg = (\n+                f'Expected response size ({expected_size}) larger than '\n+                f'download warn size ({self._download_warnsize}) in request {self._request}'\n+            )\n+            logger.warning(warning_msg)\n+\n+    def reset_stream(self, reason=StreamCloseReason.RESET):\n+        \"\"\"Close this stream by sending a RST_FRAME to the remote peer\"\"\"\n+        if self.stream_closed_local:\n+            raise StreamClosedError(self.stream_id)\n+\n+        # Clear buffer earlier to avoid keeping data in memory for a long time\n+        self._response['body'].truncate(0)\n+\n+        self.stream_closed_local = True\n+        self._conn.reset_stream(self.stream_id, ErrorCodes.REFUSED_STREAM)\n+        self.close(reason)\n+\n+    def _is_data_lost(self) -> bool:\n+        assert self.stream_closed_server\n+\n+        expected_size = self._response['flow_controlled_size']\n+        received_body_size = int(self._response['headers'][b'Content-Length'])\n+\n+        return expected_size != received_body_size\n+\n+    def close(self, reason: StreamCloseReason, error: Exception = None):\n+        \"\"\"Based on the reason sent we will handle each case.\n+\n+        Arguments:\n+            reason -- One if StreamCloseReason\n+        \"\"\"\n+        if self.stream_closed_server:\n+            raise StreamClosedError(self.stream_id)\n+\n+        if not isinstance(reason, StreamCloseReason):\n+            raise TypeError(f'Expected StreamCloseReason, received {reason.__class__.__qualname__}')\n+\n+        self._cb_close(self.stream_id)\n+        self.stream_closed_server = True\n+\n+        flags = None\n+        if b'Content-Length' not in self._response['headers']:\n+            # Missing Content-Length - {twisted.web.http.PotentialDataLoss}\n+            flags = ['partial']\n+\n+        # NOTE: Order of handling the events is important here\n+        # As we immediately cancel the request when maxsize is exceeded while\n+        # receiving DATA_FRAME's when we have received the headers (not\n+        # having Content-Length)\n+        if reason is StreamCloseReason.MAXSIZE_EXCEEDED:\n+            expected_size = int(self._response['headers'].get(b'Content-Length', -1))\n+            error_msg = (\n+                f'Cancelling download of {self._request.url}: expected response '\n+                f'size ({expected_size}) larger than download max size ({self._download_maxsize}).'\n+            )\n+            logger.error(error_msg)\n+            self._deferred_response.errback(CancelledError(error_msg))\n+\n+        elif reason is StreamCloseReason.ENDED:\n+            self._fire_response_deferred(flags)\n+\n+        # Stream was abruptly ended here\n+        elif reason is StreamCloseReason.CANCELLED:\n+            # Client has cancelled the request. Remove all the data\n+            # received and fire the response deferred with no flags set\n+\n+            # NOTE: The data is already flushed in Stream.reset_stream() called\n+            # immediately when the stream needs to be cancelled\n+\n+            # There maybe no :status in headers, we make\n+            # HTTP Status Code: 499 - Client Closed Request\n+            self._response['headers'][':status'] = '499'\n+            self._fire_response_deferred()\n+\n+        elif reason in (StreamCloseReason.RESET, StreamCloseReason.CONNECTION_LOST):\n+            self._deferred_response.errback(ResponseFailed([\n+                error if error else Failure()",
      "comment": "Is this correct? `error` is annotated as `Exception` in the function definition.",
      "comment_id": 450331715,
      "user": "elacuesta",
      "created_at": "2020-07-06T16:14:55Z",
      "url": "https://github.com/scrapy/scrapy/pull/4610#discussion_r450331715"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 4610,
      "file_path": "scrapy/core/http2/stream.py",
      "line": 413,
      "side": "RIGHT",
      "diff_hunk": "@@ -0,0 +1,422 @@\n+import logging\n+from enum import Enum\n+from io import BytesIO\n+from typing import Callable, List\n+from urllib.parse import urlparse\n+\n+from h2.connection import H2Connection\n+from h2.errors import ErrorCodes\n+from h2.exceptions import StreamClosedError\n+from twisted.internet.defer import Deferred, CancelledError\n+from twisted.internet.error import ConnectionClosed\n+from twisted.python.failure import Failure\n+from twisted.web.client import ResponseFailed\n+\n+from scrapy.core.http2.types import H2ConnectionMetadataDict, H2ResponseDict\n+from scrapy.http import Request\n+from scrapy.http.headers import Headers\n+from scrapy.responsetypes import responsetypes\n+\n+logger = logging.getLogger(__name__)\n+\n+\n+class InactiveStreamClosed(ConnectionClosed):\n+    \"\"\"Connection was closed without sending request headers\n+    of the stream. This happens when a stream is waiting for other\n+    streams to close and connection is lost.\"\"\"\n+\n+    def __init__(self, request: Request):\n+        self.request = request\n+\n+\n+class InvalidHostname(Exception):\n+\n+    def __init__(self, request: Request, expected_hostname, expected_netloc):\n+        self.request = request\n+        self.expected_hostname = expected_hostname\n+        self.expected_netloc = expected_netloc\n+\n+    def __str__(self):\n+        return f'InvalidHostname: Expected {self.expected_hostname} or {self.expected_netloc} in {self.request}'\n+\n+\n+class StreamCloseReason(Enum):\n+    # Received a StreamEnded event\n+    ENDED = 1\n+\n+    # Received a StreamReset event -- ended abruptly\n+    RESET = 2\n+\n+    # Transport connection was lost\n+    CONNECTION_LOST = 3\n+\n+    # Expected response body size is more than allowed limit\n+    MAXSIZE_EXCEEDED = 4\n+\n+    # Response deferred is cancelled by the client\n+    # (happens when client called response_deferred.cancel())\n+    CANCELLED = 5\n+\n+    # Connection lost and the stream was not initiated\n+    INACTIVE = 6\n+\n+    # The hostname of the request is not same as of connected peer hostname\n+    # As a result sending this request will the end the connection\n+    INVALID_HOSTNAME = 7\n+\n+\n+class Stream:\n+    \"\"\"Represents a single HTTP/2 Stream.\n+\n+    Stream is a bidirectional flow of bytes within an established connection,\n+    which may carry one or more messages. Handles the transfer of HTTP Headers\n+    and Data frames.\n+\n+    Role of this class is to\n+    1. Combine all the data frames\n+    \"\"\"\n+\n+    def __init__(\n+        self,\n+        stream_id: int,\n+        request: Request,\n+        connection: H2Connection,\n+        conn_metadata: H2ConnectionMetadataDict,\n+        cb_close: Callable[[int], None],\n+        download_maxsize: int = 0,\n+        download_warnsize: int = 0,\n+        fail_on_data_loss: bool = True\n+    ):\n+        \"\"\"\n+        Arguments:\n+            stream_id -- For one HTTP/2 connection each stream is\n+                uniquely identified by a single integer\n+            request -- HTTP request\n+            connection -- HTTP/2 connection this stream belongs to.\n+            conn_metadata -- Reference to dictionary having metadata of HTTP/2 connection\n+            cb_close -- Method called when this stream is closed\n+                to notify the TCP connection instance.\n+        \"\"\"\n+        self.stream_id = stream_id\n+        self._request = request\n+        self._conn = connection\n+        self._conn_metadata = conn_metadata\n+        self._cb_close = cb_close\n+\n+        self._download_maxsize = self._request.meta.get('download_maxsize', download_maxsize)\n+        self._download_warnsize = self._request.meta.get('download_warnsize', download_warnsize)\n+        self._fail_on_dataloss = self._request.meta.get('download_fail_on_dataloss', fail_on_data_loss)\n+\n+        self.request_start_time = None\n+\n+        self.content_length = 0 if self._request.body is None else len(self._request.body)\n+\n+        # Flag to keep track whether this stream has initiated the request\n+        self.request_sent = False\n+\n+        # Flag to track whether we have logged about exceeding download warnsize\n+        self._reached_warnsize = False\n+\n+        # Each time we send a data frame, we will decrease value by the amount send.\n+        self.remaining_content_length = self.content_length\n+\n+        # Flag to keep track whether we have closed this stream\n+        self.stream_closed_local = False\n+\n+        # Flag to keep track whether the server has closed the stream\n+        self.stream_closed_server = False\n+\n+        # Private variable used to build the response\n+        # this response is then converted to appropriate Response class\n+        # passed to the response deferred callback\n+        self._response: H2ResponseDict = {\n+            'body': BytesIO(),\n+            'flow_controlled_size': 0,\n+            'headers': Headers({})\n+        }\n+\n+        def _cancel(_):\n+            # Close this stream as gracefully as possible\n+            # Check if the stream has started\n+            if self.request_sent:\n+                self.reset_stream(StreamCloseReason.CANCELLED)\n+            else:\n+                self.close(StreamCloseReason.CANCELLED)\n+\n+        self._deferred_response = Deferred(_cancel)\n+\n+    def __str__(self):\n+        return f'Stream(id={self.stream_id!r})'\n+\n+    __repr__ = __str__\n+\n+    @property\n+    def _log_warnsize(self) -> bool:\n+        \"\"\"Checks if we have received data which exceeds the download warnsize\n+        and whether we have not already logged about it.\n+\n+        Returns:\n+            True if both the above conditions hold true\n+            False if any of the conditions is false\n+        \"\"\"\n+        content_length_header = int(self._response['headers'].get(b'Content-Length', -1))\n+        return (\n+            self._download_warnsize\n+            and (\n+                self._response['flow_controlled_size'] > self._download_warnsize\n+                or content_length_header > self._download_warnsize\n+            )\n+            and not self._reached_warnsize\n+        )\n+\n+    def get_response(self):\n+        \"\"\"Simply return a Deferred which fires when response\n+        from the asynchronous request is available\n+\n+        Returns:\n+            Deferred -- Calls the callback passing the response\n+        \"\"\"\n+        return self._deferred_response\n+\n+    def check_request_url(self) -> bool:\n+        # Make sure that we are sending the request to the correct URL\n+        url = urlparse(self._request.url)\n+        return (\n+            url.netloc == self._conn_metadata['hostname']\n+            or url.netloc == f'{self._conn_metadata[\"hostname\"]}:{self._conn_metadata[\"port\"]}'\n+            or url.netloc == f'{self._conn_metadata[\"ip_address\"]}:{self._conn_metadata[\"port\"]}'\n+        )\n+\n+    def _get_request_headers(self):\n+        url = urlparse(self._request.url)\n+\n+        path = url.path\n+        if url.query:\n+            path += '?' + url.query\n+\n+        # Make sure pseudo-headers comes before all the other headers\n+        headers = [\n+            (':method', self._request.method),\n+            (':authority', url.netloc),\n+            (':scheme', 'https'),\n+            (':path', path),\n+        ]\n+\n+        for name, value in self._request.headers.items():\n+            headers.append((name, value[0]))\n+\n+        return headers\n+\n+    def initiate_request(self):\n+        if self.check_request_url():\n+            headers = self._get_request_headers()\n+            self._conn.send_headers(self.stream_id, headers, end_stream=False)\n+            self.request_sent = True\n+            self.send_data()\n+        else:\n+            # Close this stream calling the response errback\n+            # Note that we have not sent any headers\n+            self.close(StreamCloseReason.INVALID_HOSTNAME)\n+\n+    def send_data(self):\n+        \"\"\"Called immediately after the headers are sent. Here we send all the\n+         data as part of the request.\n+\n+         If the content length is 0 initially then we end the stream immediately and\n+         wait for response data.\n+\n+         Warning: Only call this method when stream not closed from client side\n+            and has initiated request already by sending HEADER frame. If not then\n+            stream will raise ProtocolError (raise by h2 state machine).\n+         \"\"\"\n+        if self.stream_closed_local:\n+            raise StreamClosedError(self.stream_id)\n+\n+        # Firstly, check what the flow control window is for current stream.\n+        window_size = self._conn.local_flow_control_window(stream_id=self.stream_id)\n+\n+        # Next, check what the maximum frame size is.\n+        max_frame_size = self._conn.max_outbound_frame_size\n+\n+        # We will send no more than the window size or the remaining file size\n+        # of data in this call, whichever is smaller.\n+        bytes_to_send_size = min(window_size, self.remaining_content_length)\n+\n+        # We now need to send a number of data frames.\n+        while bytes_to_send_size > 0:\n+            chunk_size = min(bytes_to_send_size, max_frame_size)\n+\n+            data_chunk_start_id = self.content_length - self.remaining_content_length\n+            data_chunk = self._request.body[data_chunk_start_id:data_chunk_start_id + chunk_size]\n+\n+            self._conn.send_data(self.stream_id, data_chunk, end_stream=False)\n+\n+            bytes_to_send_size = bytes_to_send_size - chunk_size\n+            self.remaining_content_length = self.remaining_content_length - chunk_size\n+\n+        self.remaining_content_length = max(0, self.remaining_content_length)\n+\n+        # End the stream if no more data needs to be send\n+        if self.remaining_content_length == 0:\n+            self._conn.end_stream(self.stream_id)\n+\n+        # Q. What about the rest of the data?\n+        # Ans: Remaining Data frames will be sent when we get a WindowUpdate frame\n+\n+    def receive_window_update(self):\n+        \"\"\"Flow control window size was changed.\n+        Send data that earlier could not be sent as we were\n+        blocked behind the flow control.\n+        \"\"\"\n+        if self.remaining_content_length and not self.stream_closed_server and self.request_sent:\n+            self.send_data()\n+\n+    def receive_data(self, data: bytes, flow_controlled_length: int):\n+        self._response['body'].write(data)\n+        self._response['flow_controlled_size'] += flow_controlled_length\n+\n+        # We check maxsize here in case the Content-Length header was not received\n+        if self._download_maxsize and self._response['flow_controlled_size'] > self._download_maxsize:\n+            self.reset_stream(StreamCloseReason.MAXSIZE_EXCEEDED)\n+            return\n+\n+        if self._log_warnsize:\n+            self._reached_warnsize = True\n+            warning_msg = (\n+                f'Received more ({self._response[\"flow_controlled_size\"]}) bytes than download '\n+                f'warn size ({self._download_warnsize}) in request {self._request}'\n+            )\n+            logger.warning(warning_msg)\n+\n+        # Acknowledge the data received\n+        self._conn.acknowledge_received_data(\n+            self._response['flow_controlled_size'],\n+            self.stream_id\n+        )\n+\n+    def receive_headers(self, headers):\n+        for name, value in headers:\n+            self._response['headers'][name] = value\n+\n+        # Check if we exceed the allowed max data size which can be received\n+        expected_size = int(self._response['headers'].get(b'Content-Length', -1))\n+        if self._download_maxsize and expected_size > self._download_maxsize:\n+            self.reset_stream(StreamCloseReason.MAXSIZE_EXCEEDED)\n+            return\n+\n+        if self._log_warnsize:\n+            self._reached_warnsize = True\n+            warning_msg = (\n+                f'Expected response size ({expected_size}) larger than '\n+                f'download warn size ({self._download_warnsize}) in request {self._request}'\n+            )\n+            logger.warning(warning_msg)\n+\n+    def reset_stream(self, reason=StreamCloseReason.RESET):\n+        \"\"\"Close this stream by sending a RST_FRAME to the remote peer\"\"\"\n+        if self.stream_closed_local:\n+            raise StreamClosedError(self.stream_id)\n+\n+        # Clear buffer earlier to avoid keeping data in memory for a long time\n+        self._response['body'].truncate(0)\n+\n+        self.stream_closed_local = True\n+        self._conn.reset_stream(self.stream_id, ErrorCodes.REFUSED_STREAM)\n+        self.close(reason)\n+\n+    def _is_data_lost(self) -> bool:\n+        assert self.stream_closed_server\n+\n+        expected_size = self._response['flow_controlled_size']\n+        received_body_size = int(self._response['headers'][b'Content-Length'])\n+\n+        return expected_size != received_body_size\n+\n+    def close(self, reason: StreamCloseReason, error: Exception = None):\n+        \"\"\"Based on the reason sent we will handle each case.\n+\n+        Arguments:\n+            reason -- One if StreamCloseReason\n+        \"\"\"\n+        if self.stream_closed_server:\n+            raise StreamClosedError(self.stream_id)\n+\n+        if not isinstance(reason, StreamCloseReason):\n+            raise TypeError(f'Expected StreamCloseReason, received {reason.__class__.__qualname__}')\n+\n+        self._cb_close(self.stream_id)\n+        self.stream_closed_server = True\n+\n+        flags = None\n+        if b'Content-Length' not in self._response['headers']:\n+            # Missing Content-Length - {twisted.web.http.PotentialDataLoss}\n+            flags = ['partial']\n+\n+        # NOTE: Order of handling the events is important here\n+        # As we immediately cancel the request when maxsize is exceeded while\n+        # receiving DATA_FRAME's when we have received the headers (not\n+        # having Content-Length)\n+        if reason is StreamCloseReason.MAXSIZE_EXCEEDED:\n+            expected_size = int(self._response['headers'].get(b'Content-Length', -1))\n+            error_msg = (\n+                f'Cancelling download of {self._request.url}: expected response '\n+                f'size ({expected_size}) larger than download max size ({self._download_maxsize}).'\n+            )\n+            logger.error(error_msg)\n+            self._deferred_response.errback(CancelledError(error_msg))\n+\n+        elif reason is StreamCloseReason.ENDED:\n+            self._fire_response_deferred(flags)\n+\n+        # Stream was abruptly ended here\n+        elif reason is StreamCloseReason.CANCELLED:\n+            # Client has cancelled the request. Remove all the data\n+            # received and fire the response deferred with no flags set\n+\n+            # NOTE: The data is already flushed in Stream.reset_stream() called\n+            # immediately when the stream needs to be cancelled\n+\n+            # There maybe no :status in headers, we make\n+            # HTTP Status Code: 499 - Client Closed Request\n+            self._response['headers'][':status'] = '499'\n+            self._fire_response_deferred()\n+\n+        elif reason in (StreamCloseReason.RESET, StreamCloseReason.CONNECTION_LOST):\n+            self._deferred_response.errback(ResponseFailed([\n+                error if error else Failure()\n+            ]))\n+\n+        elif reason is StreamCloseReason.INACTIVE:\n+            self._deferred_response.errback(InactiveStreamClosed(self._request))\n+\n+        elif reason is StreamCloseReason.INVALID_HOSTNAME:\n+            self._deferred_response.errback(InvalidHostname(\n+                self._request,\n+                self._conn_metadata['hostname'],\n+                f'{self._conn_metadata[\"ip_address\"]}:{self._conn_metadata[\"port\"]}'\n+            ))\n+\n+    def _fire_response_deferred(self, flags: List[str] = None):\n+        \"\"\"Builds response from the self._response dict\n+        and fires the response deferred callback with the\n+        generated response instance\"\"\"\n+\n+        body = self._response['body'].getvalue()\n+        response_cls = responsetypes.from_args(\n+            headers=self._response['headers'],\n+            url=self._request.url,\n+            body=body\n+        )\n+\n+        response = response_cls(\n+            url=self._request.url,\n+            status=self._response['headers'][':status'],",
      "comment": "Should this be cast to `int`? IIRC all headers are strings, and above there is a line that does `self._response['headers'][':status'] = '499'`",
      "comment_id": 450333891,
      "user": "elacuesta",
      "created_at": "2020-07-06T16:18:18Z",
      "url": "https://github.com/scrapy/scrapy/pull/4610#discussion_r450333891"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 4610,
      "file_path": "scrapy/core/http2/stream.py",
      "line": 413,
      "side": "RIGHT",
      "diff_hunk": "@@ -0,0 +1,422 @@\n+import logging\n+from enum import Enum\n+from io import BytesIO\n+from typing import Callable, List\n+from urllib.parse import urlparse\n+\n+from h2.connection import H2Connection\n+from h2.errors import ErrorCodes\n+from h2.exceptions import StreamClosedError\n+from twisted.internet.defer import Deferred, CancelledError\n+from twisted.internet.error import ConnectionClosed\n+from twisted.python.failure import Failure\n+from twisted.web.client import ResponseFailed\n+\n+from scrapy.core.http2.types import H2ConnectionMetadataDict, H2ResponseDict\n+from scrapy.http import Request\n+from scrapy.http.headers import Headers\n+from scrapy.responsetypes import responsetypes\n+\n+logger = logging.getLogger(__name__)\n+\n+\n+class InactiveStreamClosed(ConnectionClosed):\n+    \"\"\"Connection was closed without sending request headers\n+    of the stream. This happens when a stream is waiting for other\n+    streams to close and connection is lost.\"\"\"\n+\n+    def __init__(self, request: Request):\n+        self.request = request\n+\n+\n+class InvalidHostname(Exception):\n+\n+    def __init__(self, request: Request, expected_hostname, expected_netloc):\n+        self.request = request\n+        self.expected_hostname = expected_hostname\n+        self.expected_netloc = expected_netloc\n+\n+    def __str__(self):\n+        return f'InvalidHostname: Expected {self.expected_hostname} or {self.expected_netloc} in {self.request}'\n+\n+\n+class StreamCloseReason(Enum):\n+    # Received a StreamEnded event\n+    ENDED = 1\n+\n+    # Received a StreamReset event -- ended abruptly\n+    RESET = 2\n+\n+    # Transport connection was lost\n+    CONNECTION_LOST = 3\n+\n+    # Expected response body size is more than allowed limit\n+    MAXSIZE_EXCEEDED = 4\n+\n+    # Response deferred is cancelled by the client\n+    # (happens when client called response_deferred.cancel())\n+    CANCELLED = 5\n+\n+    # Connection lost and the stream was not initiated\n+    INACTIVE = 6\n+\n+    # The hostname of the request is not same as of connected peer hostname\n+    # As a result sending this request will the end the connection\n+    INVALID_HOSTNAME = 7\n+\n+\n+class Stream:\n+    \"\"\"Represents a single HTTP/2 Stream.\n+\n+    Stream is a bidirectional flow of bytes within an established connection,\n+    which may carry one or more messages. Handles the transfer of HTTP Headers\n+    and Data frames.\n+\n+    Role of this class is to\n+    1. Combine all the data frames\n+    \"\"\"\n+\n+    def __init__(\n+        self,\n+        stream_id: int,\n+        request: Request,\n+        connection: H2Connection,\n+        conn_metadata: H2ConnectionMetadataDict,\n+        cb_close: Callable[[int], None],\n+        download_maxsize: int = 0,\n+        download_warnsize: int = 0,\n+        fail_on_data_loss: bool = True\n+    ):\n+        \"\"\"\n+        Arguments:\n+            stream_id -- For one HTTP/2 connection each stream is\n+                uniquely identified by a single integer\n+            request -- HTTP request\n+            connection -- HTTP/2 connection this stream belongs to.\n+            conn_metadata -- Reference to dictionary having metadata of HTTP/2 connection\n+            cb_close -- Method called when this stream is closed\n+                to notify the TCP connection instance.\n+        \"\"\"\n+        self.stream_id = stream_id\n+        self._request = request\n+        self._conn = connection\n+        self._conn_metadata = conn_metadata\n+        self._cb_close = cb_close\n+\n+        self._download_maxsize = self._request.meta.get('download_maxsize', download_maxsize)\n+        self._download_warnsize = self._request.meta.get('download_warnsize', download_warnsize)\n+        self._fail_on_dataloss = self._request.meta.get('download_fail_on_dataloss', fail_on_data_loss)\n+\n+        self.request_start_time = None\n+\n+        self.content_length = 0 if self._request.body is None else len(self._request.body)\n+\n+        # Flag to keep track whether this stream has initiated the request\n+        self.request_sent = False\n+\n+        # Flag to track whether we have logged about exceeding download warnsize\n+        self._reached_warnsize = False\n+\n+        # Each time we send a data frame, we will decrease value by the amount send.\n+        self.remaining_content_length = self.content_length\n+\n+        # Flag to keep track whether we have closed this stream\n+        self.stream_closed_local = False\n+\n+        # Flag to keep track whether the server has closed the stream\n+        self.stream_closed_server = False\n+\n+        # Private variable used to build the response\n+        # this response is then converted to appropriate Response class\n+        # passed to the response deferred callback\n+        self._response: H2ResponseDict = {\n+            'body': BytesIO(),\n+            'flow_controlled_size': 0,\n+            'headers': Headers({})\n+        }\n+\n+        def _cancel(_):\n+            # Close this stream as gracefully as possible\n+            # Check if the stream has started\n+            if self.request_sent:\n+                self.reset_stream(StreamCloseReason.CANCELLED)\n+            else:\n+                self.close(StreamCloseReason.CANCELLED)\n+\n+        self._deferred_response = Deferred(_cancel)\n+\n+    def __str__(self):\n+        return f'Stream(id={self.stream_id!r})'\n+\n+    __repr__ = __str__\n+\n+    @property\n+    def _log_warnsize(self) -> bool:\n+        \"\"\"Checks if we have received data which exceeds the download warnsize\n+        and whether we have not already logged about it.\n+\n+        Returns:\n+            True if both the above conditions hold true\n+            False if any of the conditions is false\n+        \"\"\"\n+        content_length_header = int(self._response['headers'].get(b'Content-Length', -1))\n+        return (\n+            self._download_warnsize\n+            and (\n+                self._response['flow_controlled_size'] > self._download_warnsize\n+                or content_length_header > self._download_warnsize\n+            )\n+            and not self._reached_warnsize\n+        )\n+\n+    def get_response(self):\n+        \"\"\"Simply return a Deferred which fires when response\n+        from the asynchronous request is available\n+\n+        Returns:\n+            Deferred -- Calls the callback passing the response\n+        \"\"\"\n+        return self._deferred_response\n+\n+    def check_request_url(self) -> bool:\n+        # Make sure that we are sending the request to the correct URL\n+        url = urlparse(self._request.url)\n+        return (\n+            url.netloc == self._conn_metadata['hostname']\n+            or url.netloc == f'{self._conn_metadata[\"hostname\"]}:{self._conn_metadata[\"port\"]}'\n+            or url.netloc == f'{self._conn_metadata[\"ip_address\"]}:{self._conn_metadata[\"port\"]}'\n+        )\n+\n+    def _get_request_headers(self):\n+        url = urlparse(self._request.url)\n+\n+        path = url.path\n+        if url.query:\n+            path += '?' + url.query\n+\n+        # Make sure pseudo-headers comes before all the other headers\n+        headers = [\n+            (':method', self._request.method),\n+            (':authority', url.netloc),\n+            (':scheme', 'https'),\n+            (':path', path),\n+        ]\n+\n+        for name, value in self._request.headers.items():\n+            headers.append((name, value[0]))\n+\n+        return headers\n+\n+    def initiate_request(self):\n+        if self.check_request_url():\n+            headers = self._get_request_headers()\n+            self._conn.send_headers(self.stream_id, headers, end_stream=False)\n+            self.request_sent = True\n+            self.send_data()\n+        else:\n+            # Close this stream calling the response errback\n+            # Note that we have not sent any headers\n+            self.close(StreamCloseReason.INVALID_HOSTNAME)\n+\n+    def send_data(self):\n+        \"\"\"Called immediately after the headers are sent. Here we send all the\n+         data as part of the request.\n+\n+         If the content length is 0 initially then we end the stream immediately and\n+         wait for response data.\n+\n+         Warning: Only call this method when stream not closed from client side\n+            and has initiated request already by sending HEADER frame. If not then\n+            stream will raise ProtocolError (raise by h2 state machine).\n+         \"\"\"\n+        if self.stream_closed_local:\n+            raise StreamClosedError(self.stream_id)\n+\n+        # Firstly, check what the flow control window is for current stream.\n+        window_size = self._conn.local_flow_control_window(stream_id=self.stream_id)\n+\n+        # Next, check what the maximum frame size is.\n+        max_frame_size = self._conn.max_outbound_frame_size\n+\n+        # We will send no more than the window size or the remaining file size\n+        # of data in this call, whichever is smaller.\n+        bytes_to_send_size = min(window_size, self.remaining_content_length)\n+\n+        # We now need to send a number of data frames.\n+        while bytes_to_send_size > 0:\n+            chunk_size = min(bytes_to_send_size, max_frame_size)\n+\n+            data_chunk_start_id = self.content_length - self.remaining_content_length\n+            data_chunk = self._request.body[data_chunk_start_id:data_chunk_start_id + chunk_size]\n+\n+            self._conn.send_data(self.stream_id, data_chunk, end_stream=False)\n+\n+            bytes_to_send_size = bytes_to_send_size - chunk_size\n+            self.remaining_content_length = self.remaining_content_length - chunk_size\n+\n+        self.remaining_content_length = max(0, self.remaining_content_length)\n+\n+        # End the stream if no more data needs to be send\n+        if self.remaining_content_length == 0:\n+            self._conn.end_stream(self.stream_id)\n+\n+        # Q. What about the rest of the data?\n+        # Ans: Remaining Data frames will be sent when we get a WindowUpdate frame\n+\n+    def receive_window_update(self):\n+        \"\"\"Flow control window size was changed.\n+        Send data that earlier could not be sent as we were\n+        blocked behind the flow control.\n+        \"\"\"\n+        if self.remaining_content_length and not self.stream_closed_server and self.request_sent:\n+            self.send_data()\n+\n+    def receive_data(self, data: bytes, flow_controlled_length: int):\n+        self._response['body'].write(data)\n+        self._response['flow_controlled_size'] += flow_controlled_length\n+\n+        # We check maxsize here in case the Content-Length header was not received\n+        if self._download_maxsize and self._response['flow_controlled_size'] > self._download_maxsize:\n+            self.reset_stream(StreamCloseReason.MAXSIZE_EXCEEDED)\n+            return\n+\n+        if self._log_warnsize:\n+            self._reached_warnsize = True\n+            warning_msg = (\n+                f'Received more ({self._response[\"flow_controlled_size\"]}) bytes than download '\n+                f'warn size ({self._download_warnsize}) in request {self._request}'\n+            )\n+            logger.warning(warning_msg)\n+\n+        # Acknowledge the data received\n+        self._conn.acknowledge_received_data(\n+            self._response['flow_controlled_size'],\n+            self.stream_id\n+        )\n+\n+    def receive_headers(self, headers):\n+        for name, value in headers:\n+            self._response['headers'][name] = value\n+\n+        # Check if we exceed the allowed max data size which can be received\n+        expected_size = int(self._response['headers'].get(b'Content-Length', -1))\n+        if self._download_maxsize and expected_size > self._download_maxsize:\n+            self.reset_stream(StreamCloseReason.MAXSIZE_EXCEEDED)\n+            return\n+\n+        if self._log_warnsize:\n+            self._reached_warnsize = True\n+            warning_msg = (\n+                f'Expected response size ({expected_size}) larger than '\n+                f'download warn size ({self._download_warnsize}) in request {self._request}'\n+            )\n+            logger.warning(warning_msg)\n+\n+    def reset_stream(self, reason=StreamCloseReason.RESET):\n+        \"\"\"Close this stream by sending a RST_FRAME to the remote peer\"\"\"\n+        if self.stream_closed_local:\n+            raise StreamClosedError(self.stream_id)\n+\n+        # Clear buffer earlier to avoid keeping data in memory for a long time\n+        self._response['body'].truncate(0)\n+\n+        self.stream_closed_local = True\n+        self._conn.reset_stream(self.stream_id, ErrorCodes.REFUSED_STREAM)\n+        self.close(reason)\n+\n+    def _is_data_lost(self) -> bool:\n+        assert self.stream_closed_server\n+\n+        expected_size = self._response['flow_controlled_size']\n+        received_body_size = int(self._response['headers'][b'Content-Length'])\n+\n+        return expected_size != received_body_size\n+\n+    def close(self, reason: StreamCloseReason, error: Exception = None):\n+        \"\"\"Based on the reason sent we will handle each case.\n+\n+        Arguments:\n+            reason -- One if StreamCloseReason\n+        \"\"\"\n+        if self.stream_closed_server:\n+            raise StreamClosedError(self.stream_id)\n+\n+        if not isinstance(reason, StreamCloseReason):\n+            raise TypeError(f'Expected StreamCloseReason, received {reason.__class__.__qualname__}')\n+\n+        self._cb_close(self.stream_id)\n+        self.stream_closed_server = True\n+\n+        flags = None\n+        if b'Content-Length' not in self._response['headers']:\n+            # Missing Content-Length - {twisted.web.http.PotentialDataLoss}\n+            flags = ['partial']\n+\n+        # NOTE: Order of handling the events is important here\n+        # As we immediately cancel the request when maxsize is exceeded while\n+        # receiving DATA_FRAME's when we have received the headers (not\n+        # having Content-Length)\n+        if reason is StreamCloseReason.MAXSIZE_EXCEEDED:\n+            expected_size = int(self._response['headers'].get(b'Content-Length', -1))\n+            error_msg = (\n+                f'Cancelling download of {self._request.url}: expected response '\n+                f'size ({expected_size}) larger than download max size ({self._download_maxsize}).'\n+            )\n+            logger.error(error_msg)\n+            self._deferred_response.errback(CancelledError(error_msg))\n+\n+        elif reason is StreamCloseReason.ENDED:\n+            self._fire_response_deferred(flags)\n+\n+        # Stream was abruptly ended here\n+        elif reason is StreamCloseReason.CANCELLED:\n+            # Client has cancelled the request. Remove all the data\n+            # received and fire the response deferred with no flags set\n+\n+            # NOTE: The data is already flushed in Stream.reset_stream() called\n+            # immediately when the stream needs to be cancelled\n+\n+            # There maybe no :status in headers, we make\n+            # HTTP Status Code: 499 - Client Closed Request\n+            self._response['headers'][':status'] = '499'\n+            self._fire_response_deferred()\n+\n+        elif reason in (StreamCloseReason.RESET, StreamCloseReason.CONNECTION_LOST):\n+            self._deferred_response.errback(ResponseFailed([\n+                error if error else Failure()\n+            ]))\n+\n+        elif reason is StreamCloseReason.INACTIVE:\n+            self._deferred_response.errback(InactiveStreamClosed(self._request))\n+\n+        elif reason is StreamCloseReason.INVALID_HOSTNAME:\n+            self._deferred_response.errback(InvalidHostname(\n+                self._request,\n+                self._conn_metadata['hostname'],\n+                f'{self._conn_metadata[\"ip_address\"]}:{self._conn_metadata[\"port\"]}'\n+            ))\n+\n+    def _fire_response_deferred(self, flags: List[str] = None):\n+        \"\"\"Builds response from the self._response dict\n+        and fires the response deferred callback with the\n+        generated response instance\"\"\"\n+\n+        body = self._response['body'].getvalue()\n+        response_cls = responsetypes.from_args(\n+            headers=self._response['headers'],\n+            url=self._request.url,\n+            body=body\n+        )\n+\n+        response = response_cls(\n+            url=self._request.url,\n+            status=self._response['headers'][':status'],",
      "comment": "Right. I'll add a typecast to `int` explicitly here. I did not do that initially because the `Response` already typecast's `status` to `int`.\r\n\r\nhttps://github.com/scrapy/scrapy/blob/56a6d22352071208637abd86bd7b6d81a50d5bdb/scrapy/http/response/__init__.py#L23",
      "comment_id": 450370691,
      "user": "adityaa30",
      "created_at": "2020-07-06T17:22:00Z",
      "url": "https://github.com/scrapy/scrapy/pull/4610#discussion_r450370691"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 4610,
      "file_path": "scrapy/core/http2/stream.py",
      "line": 19,
      "side": "RIGHT",
      "diff_hunk": "@@ -16,6 +16,7 @@\n from scrapy.http import Request\n from scrapy.http.headers import Headers\n from scrapy.responsetypes import responsetypes\n+from scrapy.utils.python import to_unicode",
      "comment": "`str` should work, see https://github.com/scrapy/scrapy/issues/4547",
      "comment_id": 452723246,
      "user": "Gallaecio",
      "created_at": "2020-07-10T09:11:16Z",
      "url": "https://github.com/scrapy/scrapy/pull/4610#discussion_r452723246"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 4610,
      "file_path": "scrapy/core/http2/stream.py",
      "line": 19,
      "side": "RIGHT",
      "diff_hunk": "@@ -16,6 +16,7 @@\n from scrapy.http import Request\n from scrapy.http.headers import Headers\n from scrapy.responsetypes import responsetypes\n+from scrapy.utils.python import to_unicode",
      "comment": "Makes sense to stop using `to_unicode`, but please be [mindful of the encoding](https://github.com/scrapy/scrapy/pull/4661#issuecomment-654901531). It might not be an issue in these cases, but it's something to think about IMHO.",
      "comment_id": 452882021,
      "user": "elacuesta",
      "created_at": "2020-07-10T14:33:04Z",
      "url": "https://github.com/scrapy/scrapy/pull/4610#discussion_r452882021"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 4610,
      "file_path": "scrapy/core/http2/stream.py",
      "line": 88,
      "side": "RIGHT",
      "diff_hunk": "@@ -83,7 +83,9 @@ def __init__(\n         self,\n         stream_id: int,\n         request: Request,\n-        protocol: \"H2ClientProtocol\"\n+        protocol: \"H2ClientProtocol\",\n+        download_maxsize: int = 0,\n+        download_warnsize: int = 0",
      "comment": ":lipstick:\r\n\r\n```suggestion\r\n        download_warnsize: int = 0,\r\n```",
      "comment_id": 461440213,
      "user": "Gallaecio",
      "created_at": "2020-07-28T09:17:52Z",
      "url": "https://github.com/scrapy/scrapy/pull/4610#discussion_r461440213"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 4610,
      "file_path": "scrapy/core/downloader/contextfactory.py",
      "line": 11,
      "side": "RIGHT",
      "diff_hunk": "@@ -1,8 +1,12 @@\n from OpenSSL import SSL\n+import warnings\n+\n from twisted.internet.ssl import optionsForClientTLS, CertificateOptions, platformTrust, AcceptableCiphers\n from twisted.web.client import BrowserLikePolicyForHTTPS\n from twisted.web.iweb import IPolicyForHTTPS\n from zope.interface.declarations import implementer\n+from scrapy.core.downloader.tls import openssl_methods\n+from scrapy.utils.misc import create_instance, load_object\n \n from scrapy.core.downloader.tls import ScrapyClientTLSOptions, DEFAULT_CIPHERS",
      "comment": "```suggestion\r\nimport warnings\r\n\r\nfrom OpenSSL import SSL\r\nfrom twisted.internet.ssl import optionsForClientTLS, CertificateOptions, platformTrust, AcceptableCiphers\r\nfrom twisted.web.client import BrowserLikePolicyForHTTPS\r\nfrom twisted.web.iweb import IPolicyForHTTPS\r\nfrom zope.interface.declarations import implementer\r\n\r\nfrom scrapy.core.downloader.tls import DEFAULT_CIPHERS, openssl_methods, ScrapyClientTLSOptions\r\nfrom scrapy.utils.misc import create_instance, load_object\r\n```",
      "comment_id": 463950898,
      "user": "Gallaecio",
      "created_at": "2020-08-01T11:00:29Z",
      "url": "https://github.com/scrapy/scrapy/pull/4610#discussion_r463950898"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 4610,
      "file_path": "scrapy/core/downloader/handlers/http2.py",
      "line": 86,
      "side": "RIGHT",
      "diff_hunk": "@@ -0,0 +1,142 @@\n+import warnings\n+from time import time\n+from typing import Optional, Tuple\n+from urllib.parse import urldefrag\n+\n+from twisted.internet.base import ReactorBase\n+from twisted.internet.defer import Deferred\n+from twisted.internet.error import TimeoutError\n+from twisted.web.client import URI\n+\n+from scrapy.core.downloader.contextfactory import load_context_factory_from_settings\n+from scrapy.core.downloader.webclient import _parse\n+from scrapy.core.http2.agent import H2Agent, H2ConnectionPool\n+from scrapy.exceptions import ScrapyDeprecationWarning\n+from scrapy.http import Request, Response\n+from scrapy.settings import Settings\n+from scrapy.spiders import Spider\n+\n+\n+class H2DownloadHandler:\n+    def __init__(self, settings: Settings, crawler=None):\n+        self._crawler = crawler\n+\n+        from twisted.internet import reactor\n+        self._pool = H2ConnectionPool(reactor, settings)\n+        self._context_factory = load_context_factory_from_settings(settings, crawler)\n+\n+    @classmethod\n+    def from_crawler(cls, crawler):\n+        return cls(crawler.settings, crawler)\n+\n+    def download_request(self, request: Request, spider: Spider):\n+        agent = ScrapyH2Agent(\n+            context_factory=self._context_factory,\n+            pool=self._pool,\n+            crawler=self._crawler\n+        )\n+        return agent.download_request(request, spider)\n+\n+    def close(self) -> None:\n+        self._pool.close_connections()\n+\n+\n+class ScrapyProxyH2Agent(H2Agent):\n+    def __init__(\n+        self, reactor: ReactorBase,\n+        proxy_uri: URI, pool: H2ConnectionPool,\n+        connect_timeout: Optional[float] = None, bind_address: Optional[bytes] = None\n+    ) -> None:\n+        super(ScrapyProxyH2Agent, self).__init__(\n+            reactor=reactor,\n+            pool=pool,\n+            connect_timeout=connect_timeout,\n+            bind_address=bind_address\n+        )\n+        self._proxy_uri = proxy_uri\n+\n+    @staticmethod\n+    def get_key(uri: URI) -> Tuple:\n+        return \"http-proxy\", uri.host, uri.port\n+\n+\n+class ScrapyH2Agent:\n+    _Agent = H2Agent\n+    _ProxyAgent = ScrapyProxyH2Agent\n+\n+    def __init__(\n+        self, context_factory,\n+        connect_timeout=10,\n+        bind_address: Optional[bytes] = None, pool: H2ConnectionPool = None,\n+        crawler=None\n+    ) -> None:\n+        self._context_factory = context_factory\n+        self._connect_timeout = connect_timeout\n+        self._bind_address = bind_address\n+        self._pool = pool\n+        self._crawler = crawler\n+\n+    def _get_agent(self, request: Request, timeout: Optional[float]) -> H2Agent:\n+        from twisted.internet import reactor\n+        bind_address = request.meta.get('bindaddress') or self._bind_address\n+        proxy = request.meta.get('proxy')\n+        if proxy:\n+            _, _, proxy_host, proxy_port, proxy_params = _parse(proxy)\n+            scheme = _parse(request.url)[0]\n+            proxy_host = str(proxy_host, 'utf-8')",
      "comment": ":lipstick: \r\n\r\n```suggestion\r\n            proxy_host = proxy_host.decode()\r\n```",
      "comment_id": 463952145,
      "user": "Gallaecio",
      "created_at": "2020-08-01T11:16:31Z",
      "url": "https://github.com/scrapy/scrapy/pull/4610#discussion_r463952145"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 4610,
      "file_path": "scrapy/core/downloader/handlers/http2.py",
      "line": 99,
      "side": "RIGHT",
      "diff_hunk": "@@ -0,0 +1,142 @@\n+import warnings\n+from time import time\n+from typing import Optional, Tuple\n+from urllib.parse import urldefrag\n+\n+from twisted.internet.base import ReactorBase\n+from twisted.internet.defer import Deferred\n+from twisted.internet.error import TimeoutError\n+from twisted.web.client import URI\n+\n+from scrapy.core.downloader.contextfactory import load_context_factory_from_settings\n+from scrapy.core.downloader.webclient import _parse\n+from scrapy.core.http2.agent import H2Agent, H2ConnectionPool\n+from scrapy.exceptions import ScrapyDeprecationWarning\n+from scrapy.http import Request, Response\n+from scrapy.settings import Settings\n+from scrapy.spiders import Spider\n+\n+\n+class H2DownloadHandler:\n+    def __init__(self, settings: Settings, crawler=None):\n+        self._crawler = crawler\n+\n+        from twisted.internet import reactor\n+        self._pool = H2ConnectionPool(reactor, settings)\n+        self._context_factory = load_context_factory_from_settings(settings, crawler)\n+\n+    @classmethod\n+    def from_crawler(cls, crawler):\n+        return cls(crawler.settings, crawler)\n+\n+    def download_request(self, request: Request, spider: Spider):\n+        agent = ScrapyH2Agent(\n+            context_factory=self._context_factory,\n+            pool=self._pool,\n+            crawler=self._crawler\n+        )\n+        return agent.download_request(request, spider)\n+\n+    def close(self) -> None:\n+        self._pool.close_connections()\n+\n+\n+class ScrapyProxyH2Agent(H2Agent):\n+    def __init__(\n+        self, reactor: ReactorBase,\n+        proxy_uri: URI, pool: H2ConnectionPool,\n+        connect_timeout: Optional[float] = None, bind_address: Optional[bytes] = None\n+    ) -> None:\n+        super(ScrapyProxyH2Agent, self).__init__(\n+            reactor=reactor,\n+            pool=pool,\n+            connect_timeout=connect_timeout,\n+            bind_address=bind_address\n+        )\n+        self._proxy_uri = proxy_uri\n+\n+    @staticmethod\n+    def get_key(uri: URI) -> Tuple:\n+        return \"http-proxy\", uri.host, uri.port\n+\n+\n+class ScrapyH2Agent:\n+    _Agent = H2Agent\n+    _ProxyAgent = ScrapyProxyH2Agent\n+\n+    def __init__(\n+        self, context_factory,\n+        connect_timeout=10,\n+        bind_address: Optional[bytes] = None, pool: H2ConnectionPool = None,\n+        crawler=None\n+    ) -> None:\n+        self._context_factory = context_factory\n+        self._connect_timeout = connect_timeout\n+        self._bind_address = bind_address\n+        self._pool = pool\n+        self._crawler = crawler\n+\n+    def _get_agent(self, request: Request, timeout: Optional[float]) -> H2Agent:\n+        from twisted.internet import reactor\n+        bind_address = request.meta.get('bindaddress') or self._bind_address\n+        proxy = request.meta.get('proxy')\n+        if proxy:\n+            _, _, proxy_host, proxy_port, proxy_params = _parse(proxy)\n+            scheme = _parse(request.url)[0]\n+            proxy_host = str(proxy_host, 'utf-8')\n+            omit_connect_timeout = b'noconnect' in proxy_params\n+            if omit_connect_timeout:\n+                warnings.warn(\"Using HTTPS proxies in the noconnect mode is deprecated. \"\n+                              \"If you use Crawlera, it doesn't require this mode anymore, \"\n+                              \"so you should update scrapy-crawlera to 1.3.0+ \"\n+                              \"and remove '?noconnect' from the Crawlera URL.\",\n+                              ScrapyDeprecationWarning)\n+\n+            if scheme == b'https' and not omit_connect_timeout:\n+                proxy_auth = request.headers.get(b'Proxy-Authorization', None)\n+                proxy_conf = (proxy_host, proxy_port, proxy_auth)\n+\n+                # TODO: Return TunnelingAgent instance",
      "comment": "I think we should raise `NotImplementedError`, and cover this in the relevant parts of the documentation, explaining that the new downloader handler does not support this at the moment.\r\n\r\nIt should also make the `else:` below unnecessary, and allow for dedenting its `return` statement.",
      "comment_id": 463952334,
      "user": "Gallaecio",
      "created_at": "2020-08-01T11:18:55Z",
      "url": "https://github.com/scrapy/scrapy/pull/4610#discussion_r463952334"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 4610,
      "file_path": "scrapy/core/downloader/handlers/http2.py",
      "line": 87,
      "side": "RIGHT",
      "diff_hunk": "@@ -0,0 +1,142 @@\n+import warnings\n+from time import time\n+from typing import Optional, Tuple\n+from urllib.parse import urldefrag\n+\n+from twisted.internet.base import ReactorBase\n+from twisted.internet.defer import Deferred\n+from twisted.internet.error import TimeoutError\n+from twisted.web.client import URI\n+\n+from scrapy.core.downloader.contextfactory import load_context_factory_from_settings\n+from scrapy.core.downloader.webclient import _parse\n+from scrapy.core.http2.agent import H2Agent, H2ConnectionPool\n+from scrapy.exceptions import ScrapyDeprecationWarning\n+from scrapy.http import Request, Response\n+from scrapy.settings import Settings\n+from scrapy.spiders import Spider\n+\n+\n+class H2DownloadHandler:\n+    def __init__(self, settings: Settings, crawler=None):\n+        self._crawler = crawler\n+\n+        from twisted.internet import reactor\n+        self._pool = H2ConnectionPool(reactor, settings)\n+        self._context_factory = load_context_factory_from_settings(settings, crawler)\n+\n+    @classmethod\n+    def from_crawler(cls, crawler):\n+        return cls(crawler.settings, crawler)\n+\n+    def download_request(self, request: Request, spider: Spider):\n+        agent = ScrapyH2Agent(\n+            context_factory=self._context_factory,\n+            pool=self._pool,\n+            crawler=self._crawler\n+        )\n+        return agent.download_request(request, spider)\n+\n+    def close(self) -> None:\n+        self._pool.close_connections()\n+\n+\n+class ScrapyProxyH2Agent(H2Agent):\n+    def __init__(\n+        self, reactor: ReactorBase,\n+        proxy_uri: URI, pool: H2ConnectionPool,\n+        connect_timeout: Optional[float] = None, bind_address: Optional[bytes] = None\n+    ) -> None:\n+        super(ScrapyProxyH2Agent, self).__init__(\n+            reactor=reactor,\n+            pool=pool,\n+            connect_timeout=connect_timeout,\n+            bind_address=bind_address\n+        )\n+        self._proxy_uri = proxy_uri\n+\n+    @staticmethod\n+    def get_key(uri: URI) -> Tuple:\n+        return \"http-proxy\", uri.host, uri.port\n+\n+\n+class ScrapyH2Agent:\n+    _Agent = H2Agent\n+    _ProxyAgent = ScrapyProxyH2Agent\n+\n+    def __init__(\n+        self, context_factory,\n+        connect_timeout=10,\n+        bind_address: Optional[bytes] = None, pool: H2ConnectionPool = None,\n+        crawler=None\n+    ) -> None:\n+        self._context_factory = context_factory\n+        self._connect_timeout = connect_timeout\n+        self._bind_address = bind_address\n+        self._pool = pool\n+        self._crawler = crawler\n+\n+    def _get_agent(self, request: Request, timeout: Optional[float]) -> H2Agent:\n+        from twisted.internet import reactor\n+        bind_address = request.meta.get('bindaddress') or self._bind_address\n+        proxy = request.meta.get('proxy')\n+        if proxy:\n+            _, _, proxy_host, proxy_port, proxy_params = _parse(proxy)\n+            scheme = _parse(request.url)[0]\n+            proxy_host = str(proxy_host, 'utf-8')\n+            omit_connect_timeout = b'noconnect' in proxy_params",
      "comment": "I was a bit confused by the code below. Looking at its 1.1 counterpart, I see there is a typo here: `omit_connect_timeout` \u2192 `omit_connect_tunnel`.",
      "comment_id": 463952691,
      "user": "Gallaecio",
      "created_at": "2020-08-01T11:23:22Z",
      "url": "https://github.com/scrapy/scrapy/pull/4610#discussion_r463952691"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 4610,
      "file_path": "scrapy/core/downloader/handlers/http2.py",
      "line": 93,
      "side": "RIGHT",
      "diff_hunk": "@@ -0,0 +1,142 @@\n+import warnings\n+from time import time\n+from typing import Optional, Tuple\n+from urllib.parse import urldefrag\n+\n+from twisted.internet.base import ReactorBase\n+from twisted.internet.defer import Deferred\n+from twisted.internet.error import TimeoutError\n+from twisted.web.client import URI\n+\n+from scrapy.core.downloader.contextfactory import load_context_factory_from_settings\n+from scrapy.core.downloader.webclient import _parse\n+from scrapy.core.http2.agent import H2Agent, H2ConnectionPool\n+from scrapy.exceptions import ScrapyDeprecationWarning\n+from scrapy.http import Request, Response\n+from scrapy.settings import Settings\n+from scrapy.spiders import Spider\n+\n+\n+class H2DownloadHandler:\n+    def __init__(self, settings: Settings, crawler=None):\n+        self._crawler = crawler\n+\n+        from twisted.internet import reactor\n+        self._pool = H2ConnectionPool(reactor, settings)\n+        self._context_factory = load_context_factory_from_settings(settings, crawler)\n+\n+    @classmethod\n+    def from_crawler(cls, crawler):\n+        return cls(crawler.settings, crawler)\n+\n+    def download_request(self, request: Request, spider: Spider):\n+        agent = ScrapyH2Agent(\n+            context_factory=self._context_factory,\n+            pool=self._pool,\n+            crawler=self._crawler\n+        )\n+        return agent.download_request(request, spider)\n+\n+    def close(self) -> None:\n+        self._pool.close_connections()\n+\n+\n+class ScrapyProxyH2Agent(H2Agent):\n+    def __init__(\n+        self, reactor: ReactorBase,\n+        proxy_uri: URI, pool: H2ConnectionPool,\n+        connect_timeout: Optional[float] = None, bind_address: Optional[bytes] = None\n+    ) -> None:\n+        super(ScrapyProxyH2Agent, self).__init__(\n+            reactor=reactor,\n+            pool=pool,\n+            connect_timeout=connect_timeout,\n+            bind_address=bind_address\n+        )\n+        self._proxy_uri = proxy_uri\n+\n+    @staticmethod\n+    def get_key(uri: URI) -> Tuple:\n+        return \"http-proxy\", uri.host, uri.port\n+\n+\n+class ScrapyH2Agent:\n+    _Agent = H2Agent\n+    _ProxyAgent = ScrapyProxyH2Agent\n+\n+    def __init__(\n+        self, context_factory,\n+        connect_timeout=10,\n+        bind_address: Optional[bytes] = None, pool: H2ConnectionPool = None,\n+        crawler=None\n+    ) -> None:\n+        self._context_factory = context_factory\n+        self._connect_timeout = connect_timeout\n+        self._bind_address = bind_address\n+        self._pool = pool\n+        self._crawler = crawler\n+\n+    def _get_agent(self, request: Request, timeout: Optional[float]) -> H2Agent:\n+        from twisted.internet import reactor\n+        bind_address = request.meta.get('bindaddress') or self._bind_address\n+        proxy = request.meta.get('proxy')\n+        if proxy:\n+            _, _, proxy_host, proxy_port, proxy_params = _parse(proxy)\n+            scheme = _parse(request.url)[0]\n+            proxy_host = str(proxy_host, 'utf-8')\n+            omit_connect_timeout = b'noconnect' in proxy_params\n+            if omit_connect_timeout:\n+                warnings.warn(\"Using HTTPS proxies in the noconnect mode is deprecated. \"\n+                              \"If you use Crawlera, it doesn't require this mode anymore, \"\n+                              \"so you should update scrapy-crawlera to 1.3.0+ \"\n+                              \"and remove '?noconnect' from the Crawlera URL.\",\n+                              ScrapyDeprecationWarning)",
      "comment": "@kmike @elacuesta @wRAR Given this is a new downloader handler, I wonder if we should just ignore this proxy param.\r\n\r\nAnd, if so, I wonder if we should still log a warning. If we do, it should probably not be a deprecation warning, but a regular warning, maybe with the same message but replacing \u201cdeprecated\u201d with \u201cnot supported by the <class> downloader handler\u201d.",
      "comment_id": 463953179,
      "user": "Gallaecio",
      "created_at": "2020-08-01T11:29:08Z",
      "url": "https://github.com/scrapy/scrapy/pull/4610#discussion_r463953179"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 4610,
      "file_path": "scrapy/core/downloader/handlers/http2.py",
      "line": 103,
      "side": "RIGHT",
      "diff_hunk": "@@ -0,0 +1,142 @@\n+import warnings\n+from time import time\n+from typing import Optional, Tuple\n+from urllib.parse import urldefrag\n+\n+from twisted.internet.base import ReactorBase\n+from twisted.internet.defer import Deferred\n+from twisted.internet.error import TimeoutError\n+from twisted.web.client import URI\n+\n+from scrapy.core.downloader.contextfactory import load_context_factory_from_settings\n+from scrapy.core.downloader.webclient import _parse\n+from scrapy.core.http2.agent import H2Agent, H2ConnectionPool\n+from scrapy.exceptions import ScrapyDeprecationWarning\n+from scrapy.http import Request, Response\n+from scrapy.settings import Settings\n+from scrapy.spiders import Spider\n+\n+\n+class H2DownloadHandler:\n+    def __init__(self, settings: Settings, crawler=None):\n+        self._crawler = crawler\n+\n+        from twisted.internet import reactor\n+        self._pool = H2ConnectionPool(reactor, settings)\n+        self._context_factory = load_context_factory_from_settings(settings, crawler)\n+\n+    @classmethod\n+    def from_crawler(cls, crawler):\n+        return cls(crawler.settings, crawler)\n+\n+    def download_request(self, request: Request, spider: Spider):\n+        agent = ScrapyH2Agent(\n+            context_factory=self._context_factory,\n+            pool=self._pool,\n+            crawler=self._crawler\n+        )\n+        return agent.download_request(request, spider)\n+\n+    def close(self) -> None:\n+        self._pool.close_connections()\n+\n+\n+class ScrapyProxyH2Agent(H2Agent):\n+    def __init__(\n+        self, reactor: ReactorBase,\n+        proxy_uri: URI, pool: H2ConnectionPool,\n+        connect_timeout: Optional[float] = None, bind_address: Optional[bytes] = None\n+    ) -> None:\n+        super(ScrapyProxyH2Agent, self).__init__(\n+            reactor=reactor,\n+            pool=pool,\n+            connect_timeout=connect_timeout,\n+            bind_address=bind_address\n+        )\n+        self._proxy_uri = proxy_uri\n+\n+    @staticmethod\n+    def get_key(uri: URI) -> Tuple:\n+        return \"http-proxy\", uri.host, uri.port\n+\n+\n+class ScrapyH2Agent:\n+    _Agent = H2Agent\n+    _ProxyAgent = ScrapyProxyH2Agent\n+\n+    def __init__(\n+        self, context_factory,\n+        connect_timeout=10,\n+        bind_address: Optional[bytes] = None, pool: H2ConnectionPool = None,\n+        crawler=None\n+    ) -> None:\n+        self._context_factory = context_factory\n+        self._connect_timeout = connect_timeout\n+        self._bind_address = bind_address\n+        self._pool = pool\n+        self._crawler = crawler\n+\n+    def _get_agent(self, request: Request, timeout: Optional[float]) -> H2Agent:\n+        from twisted.internet import reactor\n+        bind_address = request.meta.get('bindaddress') or self._bind_address\n+        proxy = request.meta.get('proxy')\n+        if proxy:\n+            _, _, proxy_host, proxy_port, proxy_params = _parse(proxy)\n+            scheme = _parse(request.url)[0]\n+            proxy_host = str(proxy_host, 'utf-8')\n+            omit_connect_timeout = b'noconnect' in proxy_params\n+            if omit_connect_timeout:\n+                warnings.warn(\"Using HTTPS proxies in the noconnect mode is deprecated. \"\n+                              \"If you use Crawlera, it doesn't require this mode anymore, \"\n+                              \"so you should update scrapy-crawlera to 1.3.0+ \"\n+                              \"and remove '?noconnect' from the Crawlera URL.\",\n+                              ScrapyDeprecationWarning)\n+\n+            if scheme == b'https' and not omit_connect_timeout:\n+                proxy_auth = request.headers.get(b'Proxy-Authorization', None)\n+                proxy_conf = (proxy_host, proxy_port, proxy_auth)\n+\n+                # TODO: Return TunnelingAgent instance\n+            else:\n+                return self._ProxyAgent(\n+                    reactor=reactor,\n+                    proxy_uri=URI.fromBytes(bytes(proxy, encoding='ascii')),",
      "comment": "Better use `to_bytes` instead, which also supports `bytes` as input.\r\n\r\nI might have been the one asking you to use `bytes` in the first place, as [I only recently found out how `to_bytes` works differently](https://github.com/scrapy/scrapy/pull/4661#issuecomment-658133232), so sorry about that :sweat_smile: ",
      "comment_id": 463953798,
      "user": "Gallaecio",
      "created_at": "2020-08-01T11:36:56Z",
      "url": "https://github.com/scrapy/scrapy/pull/4610#discussion_r463953798"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 4610,
      "file_path": "scrapy/core/http2/stream.py",
      "line": 198,
      "side": "RIGHT",
      "diff_hunk": "@@ -185,14 +185,32 @@ def _get_request_headers(self) -> List[Tuple[str, str]]:\n         if url.query:\n             path += '?' + url.query\n \n+        # This pseudo-header field MUST NOT be empty for \"http\" or \"https\"\n+        # URIs; \"http\" or \"https\" URIs that do not contain a path component\n+        # MUST include a value of '/'. The exception to this rule is an\n+        # OPTIONS request for an \"http\" or \"https\" URI that does not include\n+        # a path component; these MUST include a \":path\" pseudo-header field\n+        # with a value of '*' (refer RFC 7540 - Section 8.1.2.3)\n+        if not path:\n+            if self._request.method == 'OPTIONS':\n+                path = path or '*'\n+            else:\n+                path = path or '/'",
      "comment": ":lipstick: (`if not path` allows simplifying inner code)\r\n\r\n```suggestion\r\n        if not path:\r\n            path = '*' if self._request.method == 'OPTIONS' else '/'\r\n```",
      "comment_id": 467841579,
      "user": "Gallaecio",
      "created_at": "2020-08-10T11:29:13Z",
      "url": "https://github.com/scrapy/scrapy/pull/4610#discussion_r467841579"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 4610,
      "file_path": "scrapy/core/downloader/handlers/http2.py",
      "line": 9,
      "side": "RIGHT",
      "diff_hunk": "@@ -6,7 +6,7 @@\n from twisted.internet.base import ReactorBase\n from twisted.internet.defer import Deferred\n from twisted.internet.error import TimeoutError\n-from twisted.web.client import URI\n+from twisted.web.client import URI, BrowserLikePolicyForHTTPS",
      "comment": ":lipstick: \r\n\r\n```suggestion\r\nfrom twisted.web.client import BrowserLikePolicyForHTTPS, URI\r\n```",
      "comment_id": 467841686,
      "user": "Gallaecio",
      "created_at": "2020-08-10T11:29:28Z",
      "url": "https://github.com/scrapy/scrapy/pull/4610#discussion_r467841686"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 4610,
      "file_path": "tests/test_downloader_handlers.py",
      "line": 792,
      "side": "RIGHT",
      "diff_hunk": "@@ -786,7 +786,10 @@ def test_download_with_proxy(self):\n         def _test(response):\n             self.assertEqual(response.status, 200)\n             self.assertEqual(response.url, request.url)\n-            self.assertEqual(response.body, b'http://example.com')\n+            self.assertTrue(\n+                response.body == b'http://example.com'  # HTTP/1.x\n+                or response.body == b'/'  # HTTP/2\n+            )",
      "comment": "What about keeping the old check, but turning `b'http://example.com'` into a class-level variable to be overridden in HTTP/2 tests? That way the check is more strict, and will fail if the protocol-version-specific expectations are not met (e.g. we suddenly start returning `/` for HTTP/1.x).",
      "comment_id": 467843413,
      "user": "Gallaecio",
      "created_at": "2020-08-10T11:33:14Z",
      "url": "https://github.com/scrapy/scrapy/pull/4610#discussion_r467843413"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 4610,
      "file_path": "tests/test_downloader_handlers.py",
      "line": 808,
      "side": "RIGHT",
      "diff_hunk": "@@ -796,10 +799,13 @@ def test_download_with_proxy_https_noconnect(self):\n         def _test(response):\n             self.assertEqual(response.status, 200)\n             self.assertEqual(response.url, request.url)\n-            self.assertEqual(response.body, b'https://example.com')\n+            self.assertTrue(\n+                response.body == b'http://example.com'  # HTTP/1.x\n+                or response.body == b'/'  # HTTP/2\n+            )\n \n         http_proxy = '%s?noconnect' % self.getURL('')\n-        request = Request('https://example.com', meta={'proxy': http_proxy})\n+        request = Request('http://example.com', meta={'proxy': http_proxy})",
      "comment": "Could you elaborate on the reason behind this change?",
      "comment_id": 467844070,
      "user": "Gallaecio",
      "created_at": "2020-08-10T11:34:44Z",
      "url": "https://github.com/scrapy/scrapy/pull/4610#discussion_r467844070"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 4610,
      "file_path": "tests/test_downloader_handlers.py",
      "line": 808,
      "side": "RIGHT",
      "diff_hunk": "@@ -796,10 +799,13 @@ def test_download_with_proxy_https_noconnect(self):\n         def _test(response):\n             self.assertEqual(response.status, 200)\n             self.assertEqual(response.url, request.url)\n-            self.assertEqual(response.body, b'https://example.com')\n+            self.assertTrue(\n+                response.body == b'http://example.com'  # HTTP/1.x\n+                or response.body == b'/'  # HTTP/2\n+            )\n \n         http_proxy = '%s?noconnect' % self.getURL('')\n-        request = Request('https://example.com', meta={'proxy': http_proxy})\n+        request = Request('http://example.com', meta={'proxy': http_proxy})",
      "comment": "Earlier while setting up tests with HTTP/2 I was having trouble with the *https://example.com* url. I did revert the change back to `https` in c67d6dea318d6f0915ae86d46ce367b6c1e8ee51 as it works now.",
      "comment_id": 468235367,
      "user": "adityaa30",
      "created_at": "2020-08-10T23:12:20Z",
      "url": "https://github.com/scrapy/scrapy/pull/4610#discussion_r468235367"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 4610,
      "file_path": "tests/test_downloader_handlers.py",
      "line": 319,
      "side": "RIGHT",
      "diff_hunk": "@@ -315,8 +315,8 @@ def test_host_header_seted_in_request_headers(self):\n         host = self.host + ':' + str(self.portno)\n \n         def _test(response):\n-            self.assertEqual(response.body, bytes(host, 'utf-8'))\n-            self.assertEqual(request.headers.get('Host'), bytes(host, 'utf-8'))\n+            self.assertEqual(response.body, to_bytes(host))\n+            self.assertEqual(request.headers.get('Host'), to_bytes(host))",
      "comment": "`to_bytes` is meant for scenarios where the input may be either `bytes` or `str`.\r\n\r\nBecause here we control the input type, `str`, `host.encode()` would make more sense, being more explicit.",
      "comment_id": 468402310,
      "user": "Gallaecio",
      "created_at": "2020-08-11T08:10:16Z",
      "url": "https://github.com/scrapy/scrapy/pull/4610#discussion_r468402310"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 4610,
      "file_path": "scrapy/core/http2/stream.py",
      "line": 8,
      "side": "RIGHT",
      "diff_hunk": "@@ -5,14 +5,14 @@\n from urllib.parse import urlparse\n \n from h2.errors import ErrorCodes\n-from h2.exceptions import H2Error, StreamClosedError\n+from h2.exceptions import H2Error, StreamClosedError, ProtocolError",
      "comment": ":lipstick: \r\n\r\n```suggestion\r\nfrom h2.exceptions import H2Error, ProtocolError, StreamClosedError\r\n```",
      "comment_id": 471947329,
      "user": "Gallaecio",
      "created_at": "2020-08-18T06:39:48Z",
      "url": "https://github.com/scrapy/scrapy/pull/4610#discussion_r471947329"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 4610,
      "file_path": "setup.py",
      "line": 36,
      "side": "RIGHT",
      "diff_hunk": "@@ -32,6 +32,8 @@ def has_environment_marker_platform_impl_support():\n     'zope.interface>=4.1.3',\n     'protego>=0.1.15',\n     'itemadapter>=0.1.0',\n+    'h2>=3.2.0',\n+    'typing-extensions>=3.7.4',",
      "comment": "I think we already talked about this, but I don't remember exactly. Is it still necessary now that we dropped support for Python 3.5?",
      "comment_id": 477237746,
      "user": "elacuesta",
      "created_at": "2020-08-26T11:45:42Z",
      "url": "https://github.com/scrapy/scrapy/pull/4610#discussion_r477237746"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 4610,
      "file_path": "setup.py",
      "line": 36,
      "side": "RIGHT",
      "diff_hunk": "@@ -32,6 +32,8 @@ def has_environment_marker_platform_impl_support():\n     'zope.interface>=4.1.3',\n     'protego>=0.1.15',\n     'itemadapter>=0.1.0',\n+    'h2>=3.2.0',\n+    'typing-extensions>=3.7.4',",
      "comment": "I have removed the `typing-extensions` dependency in 5e36f539e28631625862b84d8ca1c7c0134584b0.",
      "comment_id": 478293897,
      "user": "adityaa30",
      "created_at": "2020-08-27T09:47:07Z",
      "url": "https://github.com/scrapy/scrapy/pull/4610#discussion_r478293897"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 4610,
      "file_path": "scrapy/core/http2/protocol.py",
      "line": 24,
      "side": "RIGHT",
      "diff_hunk": "@@ -22,10 +21,10 @@\n from twisted.protocols.policies import TimeoutMixin\n from twisted.python.failure import Failure\n from twisted.web.client import URI\n+from typing import Dict, List, Optional, Union",
      "comment": "I think this was in the right line before (https://docs.python.org/3/library/typing.html).",
      "comment_id": 478349489,
      "user": "Gallaecio",
      "created_at": "2020-08-27T11:35:13Z",
      "url": "https://github.com/scrapy/scrapy/pull/4610#discussion_r478349489"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 4610,
      "file_path": "scrapy/core/http2/stream.py",
      "line": 14,
      "side": "RIGHT",
      "diff_hunk": "@@ -11,8 +10,9 @@\n from twisted.internet.error import ConnectionClosed\n from twisted.python.failure import Failure\n from twisted.web.client import ResponseFailed\n+from typing import Dict\n+from typing import List, Optional, Tuple, TYPE_CHECKING",
      "comment": "And it should definitely not be split into 2 lines :slightly_smiling_face: ",
      "comment_id": 478350996,
      "user": "Gallaecio",
      "created_at": "2020-08-27T11:38:09Z",
      "url": "https://github.com/scrapy/scrapy/pull/4610#discussion_r478350996"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 4243,
      "file_path": "scrapy/downloadermiddlewares/httpcache.py",
      "line": 16,
      "side": "RIGHT",
      "diff_hunk": "@@ -11,41 +13,54 @@\n     TimeoutError,\n )\n from twisted.web.client import ResponseFailed\n+from typing import Optional, Tuple, Type, Union",
      "comment": "`typing` is a standard module so it should be in the first import block :)",
      "comment_id": 359341812,
      "user": "wRAR",
      "created_at": "2019-12-18T13:28:02Z",
      "url": "https://github.com/scrapy/scrapy/pull/4243#discussion_r359341812"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 4243,
      "file_path": "scrapy/downloadermiddlewares/httpcache.py",
      "line": 46,
      "side": "RIGHT",
      "diff_hunk": "@@ -11,41 +13,54 @@\n     TimeoutError,\n )\n from twisted.web.client import ResponseFailed\n+from typing import Optional, Tuple, Type, Union\n \n from scrapy import signals\n+from scrapy.crawler import Crawler\n from scrapy.exceptions import IgnoreRequest, NotConfigured\n+from scrapy.extensions.httpcache import (\n+    DbmCacheStorage,\n+    DummyPolicy,\n+    FilesystemCacheStorage,\n+    RFC2616Policy,\n+)\n+from scrapy.http.request import Request\n+from scrapy.http.response import Response\n+from scrapy.settings import Settings\n+from scrapy.spiders import Spider\n+from scrapy.statscollectors import StatsCollector\n from scrapy.utils.misc import load_object\n \n \n class HttpCacheMiddleware(object):\n \n-    DOWNLOAD_EXCEPTIONS = (defer.TimeoutError, TimeoutError, DNSLookupError,\n+    DOWNLOAD_EXCEPTIONS: Tuple = (defer.TimeoutError, TimeoutError, DNSLookupError,\n                            ConnectionRefusedError, ConnectionDone, ConnectError,\n                            ConnectionLost, TCPTimedOutError, ResponseFailed,\n                            IOError)\n \n-    def __init__(self, settings, stats):\n+    def __init__(self, settings: Settings, stats: Type[StatsCollector]) -> None:\n         if not settings.getbool('HTTPCACHE_ENABLED'):\n             raise NotConfigured\n-        self.policy = load_object(settings['HTTPCACHE_POLICY'])(settings)\n-        self.storage = load_object(settings['HTTPCACHE_STORAGE'])(settings)\n-        self.ignore_missing = settings.getbool('HTTPCACHE_IGNORE_MISSING')\n+        self.policy: Union[DummyPolicy, RFC2616Policy] = load_object(settings['HTTPCACHE_POLICY'])(settings)\n+        self.storage: Union[DbmCacheStorage, FilesystemCacheStorage] = load_object(settings['HTTPCACHE_STORAGE'])(settings)",
      "comment": "These can be any other (user-defined) classes, right?",
      "comment_id": 359342931,
      "user": "wRAR",
      "created_at": "2019-12-18T13:30:30Z",
      "url": "https://github.com/scrapy/scrapy/pull/4243#discussion_r359342931"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 4243,
      "file_path": "scrapy/downloadermiddlewares/httpcache.py",
      "line": 91,
      "side": "RIGHT",
      "diff_hunk": "@@ -73,7 +88,7 @@ def process_request(self, request, spider):\n         # process_response hook\n         request.meta['cached_response'] = cachedresponse\n \n-    def process_response(self, request, response, spider):\n+    def process_response(self, request: Type[Request], response: Type[Response], spider: Type[Spider]) -> Type[Response]:",
      "comment": "Type is not needed here, and in other places as well. Type means that a class instance is received, not an object of this type, which is not the case.",
      "comment_id": 359346510,
      "user": "kmike",
      "created_at": "2019-12-18T13:38:25Z",
      "url": "https://github.com/scrapy/scrapy/pull/4243#discussion_r359346510"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 4243,
      "file_path": "scrapy/downloadermiddlewares/httpcache.py",
      "line": 46,
      "side": "RIGHT",
      "diff_hunk": "@@ -11,41 +13,54 @@\n     TimeoutError,\n )\n from twisted.web.client import ResponseFailed\n+from typing import Optional, Tuple, Type, Union\n \n from scrapy import signals\n+from scrapy.crawler import Crawler\n from scrapy.exceptions import IgnoreRequest, NotConfigured\n+from scrapy.extensions.httpcache import (\n+    DbmCacheStorage,\n+    DummyPolicy,\n+    FilesystemCacheStorage,\n+    RFC2616Policy,\n+)\n+from scrapy.http.request import Request\n+from scrapy.http.response import Response\n+from scrapy.settings import Settings\n+from scrapy.spiders import Spider\n+from scrapy.statscollectors import StatsCollector\n from scrapy.utils.misc import load_object\n \n \n class HttpCacheMiddleware(object):\n \n-    DOWNLOAD_EXCEPTIONS = (defer.TimeoutError, TimeoutError, DNSLookupError,\n+    DOWNLOAD_EXCEPTIONS: Tuple = (defer.TimeoutError, TimeoutError, DNSLookupError,\n                            ConnectionRefusedError, ConnectionDone, ConnectError,\n                            ConnectionLost, TCPTimedOutError, ResponseFailed,\n                            IOError)\n \n-    def __init__(self, settings, stats):\n+    def __init__(self, settings: Settings, stats: Type[StatsCollector]) -> None:\n         if not settings.getbool('HTTPCACHE_ENABLED'):\n             raise NotConfigured\n-        self.policy = load_object(settings['HTTPCACHE_POLICY'])(settings)\n-        self.storage = load_object(settings['HTTPCACHE_STORAGE'])(settings)\n-        self.ignore_missing = settings.getbool('HTTPCACHE_IGNORE_MISSING')\n+        self.policy: Union[DummyPolicy, RFC2616Policy] = load_object(settings['HTTPCACHE_POLICY'])(settings)\n+        self.storage: Union[DbmCacheStorage, FilesystemCacheStorage] = load_object(settings['HTTPCACHE_STORAGE'])(settings)",
      "comment": "Yes, and now we have only these classes (`DummpyPolicy`, `RFC2616Policy`, `DbmCacheStorage`, `FilesystemCacheStorage`) in this project.",
      "comment_id": 359596532,
      "user": "grammy-jiang",
      "created_at": "2019-12-18T22:15:48Z",
      "url": "https://github.com/scrapy/scrapy/pull/4243#discussion_r359596532"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 4243,
      "file_path": "scrapy/downloadermiddlewares/httpcache.py",
      "line": 91,
      "side": "RIGHT",
      "diff_hunk": "@@ -73,7 +88,7 @@ def process_request(self, request, spider):\n         # process_response hook\n         request.meta['cached_response'] = cachedresponse\n \n-    def process_response(self, request, response, spider):\n+    def process_response(self, request: Type[Request], response: Type[Response], spider: Type[Spider]) -> Type[Response]:",
      "comment": "Right, I find the right way is to use [`TypeVar`](https://docs.python.org/3/library/typing.html#typing.TypeVar) for subclass typing hint.\r\n",
      "comment_id": 359606652,
      "user": "grammy-jiang",
      "created_at": "2019-12-18T22:44:09Z",
      "url": "https://github.com/scrapy/scrapy/pull/4243#discussion_r359606652"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 4243,
      "file_path": "scrapy/downloadermiddlewares/httpcache.py",
      "line": 40,
      "side": "RIGHT",
      "diff_hunk": "@@ -13,39 +16,58 @@\n from twisted.web.client import ResponseFailed\n \n from scrapy import signals\n+from scrapy.crawler import Crawler\n from scrapy.exceptions import IgnoreRequest, NotConfigured\n+from scrapy.extensions.httpcache import (\n+    DbmCacheStorage,\n+    DummyPolicy,\n+    FilesystemCacheStorage,\n+    RFC2616Policy,\n+)\n+from scrapy.http.request import Request\n+from scrapy.http.response import Response\n+from scrapy.settings import Settings\n+from scrapy.spiders import Spider\n+from scrapy.statscollectors import StatsCollector\n from scrapy.utils.misc import load_object\n \n+TCrawler = TypeVar(\"TCrawler\", bound=Crawler)\n+TException = TypeVar(\"TException\", bound=Exception)\n+TRequest = TypeVar(\"TRequest\", bound=Request)\n+TResponse = TypeVar(\"TResponse\", bound=Response)\n+TSpider = TypeVar(\"TSpider\", bound=Spider)\n+TStatsCollector = TypeVar(\"TStatsCollector\", bound=StatsCollector)\n+",
      "comment": "Defining the types used in every current module is quite boring. There should be a better way to do this.",
      "comment_id": 359608899,
      "user": "grammy-jiang",
      "created_at": "2019-12-18T22:51:15Z",
      "url": "https://github.com/scrapy/scrapy/pull/4243#discussion_r359608899"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 4243,
      "file_path": "scrapy/downloadermiddlewares/httpcache.py",
      "line": 40,
      "side": "RIGHT",
      "diff_hunk": "@@ -13,39 +16,58 @@\n from twisted.web.client import ResponseFailed\n \n from scrapy import signals\n+from scrapy.crawler import Crawler\n from scrapy.exceptions import IgnoreRequest, NotConfigured\n+from scrapy.extensions.httpcache import (\n+    DbmCacheStorage,\n+    DummyPolicy,\n+    FilesystemCacheStorage,\n+    RFC2616Policy,\n+)\n+from scrapy.http.request import Request\n+from scrapy.http.response import Response\n+from scrapy.settings import Settings\n+from scrapy.spiders import Spider\n+from scrapy.statscollectors import StatsCollector\n from scrapy.utils.misc import load_object\n \n+TCrawler = TypeVar(\"TCrawler\", bound=Crawler)\n+TException = TypeVar(\"TException\", bound=Exception)\n+TRequest = TypeVar(\"TRequest\", bound=Request)\n+TResponse = TypeVar(\"TResponse\", bound=Response)\n+TSpider = TypeVar(\"TSpider\", bound=Spider)\n+TStatsCollector = TypeVar(\"TStatsCollector\", bound=StatsCollector)\n+",
      "comment": "I'm by no means a typing expert, but can't you just use the classes themselves? Like you are doing with the `settings` argument in `__init__`.",
      "comment_id": 360369442,
      "user": "elacuesta",
      "created_at": "2019-12-20T13:21:41Z",
      "url": "https://github.com/scrapy/scrapy/pull/4243#discussion_r360369442"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 4243,
      "file_path": "scrapy/downloadermiddlewares/httpcache.py",
      "line": 91,
      "side": "RIGHT",
      "diff_hunk": "@@ -73,7 +88,7 @@ def process_request(self, request, spider):\n         # process_response hook\n         request.meta['cached_response'] = cachedresponse\n \n-    def process_response(self, request, response, spider):\n+    def process_response(self, request: Type[Request], response: Type[Response], spider: Type[Spider]) -> Type[Response]:",
      "comment": "TypeVar is removed. Now the native class is adopted for typing hint.",
      "comment_id": 362734173,
      "user": "grammy-jiang",
      "created_at": "2020-01-03T08:37:36Z",
      "url": "https://github.com/scrapy/scrapy/pull/4243#discussion_r362734173"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 4243,
      "file_path": "scrapy/downloadermiddlewares/httpcache.py",
      "line": 40,
      "side": "RIGHT",
      "diff_hunk": "@@ -13,39 +16,58 @@\n from twisted.web.client import ResponseFailed\n \n from scrapy import signals\n+from scrapy.crawler import Crawler\n from scrapy.exceptions import IgnoreRequest, NotConfigured\n+from scrapy.extensions.httpcache import (\n+    DbmCacheStorage,\n+    DummyPolicy,\n+    FilesystemCacheStorage,\n+    RFC2616Policy,\n+)\n+from scrapy.http.request import Request\n+from scrapy.http.response import Response\n+from scrapy.settings import Settings\n+from scrapy.spiders import Spider\n+from scrapy.statscollectors import StatsCollector\n from scrapy.utils.misc import load_object\n \n+TCrawler = TypeVar(\"TCrawler\", bound=Crawler)\n+TException = TypeVar(\"TException\", bound=Exception)\n+TRequest = TypeVar(\"TRequest\", bound=Request)\n+TResponse = TypeVar(\"TResponse\", bound=Response)\n+TSpider = TypeVar(\"TSpider\", bound=Spider)\n+TStatsCollector = TypeVar(\"TStatsCollector\", bound=StatsCollector)\n+",
      "comment": "The comment is adopted. Now the native class is used for typing hint.",
      "comment_id": 362734321,
      "user": "grammy-jiang",
      "created_at": "2020-01-03T08:38:17Z",
      "url": "https://github.com/scrapy/scrapy/pull/4243#discussion_r362734321"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 4243,
      "file_path": "scrapy/downloadermiddlewares/httpcache.py",
      "line": 43,
      "side": "RIGHT",
      "diff_hunk": "@@ -33,19 +40,19 @@ def __init__(self, settings, stats):\n         self.stats = stats\n \n     @classmethod\n-    def from_crawler(cls, crawler):\n+    def from_crawler(cls, crawler: Crawler) -> \"HttpCacheMiddleware\":",
      "comment": "this method doesn't return HttpCacheMiddleware in a subclass, see https://stackoverflow.com/questions/44640479/mypy-annotation-for-classmethod-returning-instance for a discussion",
      "comment_id": 364441716,
      "user": "kmike",
      "created_at": "2020-01-08T21:02:55Z",
      "url": "https://github.com/scrapy/scrapy/pull/4243#discussion_r364441716"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 4243,
      "file_path": "scrapy/downloadermiddlewares/httpcache.py",
      "line": 43,
      "side": "RIGHT",
      "diff_hunk": "@@ -33,19 +40,19 @@ def __init__(self, settings, stats):\n         self.stats = stats\n \n     @classmethod\n-    def from_crawler(cls, crawler):\n+    def from_crawler(cls, crawler: Crawler) -> \"HttpCacheMiddleware\":",
      "comment": "Em, I can see this will be a hot topic in this typing hint topic.\r\n\r\nFirst, should all kinds of possible typing hint be covered? Using `typing.Type` to cover all subclasses is not a problem. The problem is should we use `typing.Type` for all classes in Scrapy, just like the previous `Request` and `Response` typing hint in this pull request?\r\n\r\nSecond, annotating the class itself is supported until python 3.7 with the help of `__future__.annotations`. Since Scrapy is still compatible with python 3.5, what should we do for `classmethod` return at this moment? A string typing hint is not a good solution in my opinion.",
      "comment_id": 365183796,
      "user": "grammy-jiang",
      "created_at": "2020-01-10T11:07:05Z",
      "url": "https://github.com/scrapy/scrapy/pull/4243#discussion_r365183796"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 4243,
      "file_path": "scrapy/__init__.py",
      "line": 10,
      "side": "RIGHT",
      "diff_hunk": "@@ -7,7 +7,7 @@\n \n # Scrapy version\n import pkgutil\n-__version__ = pkgutil.get_data(__package__, 'VERSION').decode('ascii').strip()\n+__version__ = (pkgutil.get_data(__package__, 'VERSION') or b'').decode('ascii').strip()",
      "comment": "why is this change needed? Is it related to typing?",
      "comment_id": 429403282,
      "user": "kmike",
      "created_at": "2020-05-22T18:48:11Z",
      "url": "https://github.com/scrapy/scrapy/pull/4243#discussion_r429403282"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 4243,
      "file_path": "scrapy/__init__.py",
      "line": 10,
      "side": "RIGHT",
      "diff_hunk": "@@ -7,7 +7,7 @@\n \n # Scrapy version\n import pkgutil\n-__version__ = pkgutil.get_data(__package__, 'VERSION').decode('ascii').strip()\n+__version__ = (pkgutil.get_data(__package__, 'VERSION') or b'').decode('ascii').strip()",
      "comment": "Indeed:\r\n```\r\nscrapy/__init__.py:10: error: Item \"None\" of \"Optional[bytes]\" has no attribute \"decode\"\r\n```\r\n\r\nI just reverted it and added the file to the ignore list\r\n",
      "comment_id": 429410841,
      "user": "elacuesta",
      "created_at": "2020-05-22T19:04:02Z",
      "url": "https://github.com/scrapy/scrapy/pull/4243#discussion_r429410841"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 4324,
      "file_path": "scrapy/commands/version.py",
      "line": 28,
      "side": "RIGHT",
      "diff_hunk": "@@ -23,8 +23,8 @@ def run(self, args, opts):\n         if opts.verbose:\n             versions = scrapy_components_versions()\n             width = max(len(n) for (n, _) in versions)\n-            patt = \"%-{}s : %s\".format(width)\n+            patt = f\"%-{width}s : %s\"\n             for name, version in versions:\n                 print(patt % (name, version))",
      "comment": "Looks like it can be done as:\r\n\r\n```suggestion\r\n            for name, version in versions:\r\n                print(f\"{name:<{width}} : {version}\")\r\n```",
      "comment_id": 477114053,
      "user": "Gallaecio",
      "created_at": "2020-08-26T08:08:47Z",
      "url": "https://github.com/scrapy/scrapy/pull/4324#discussion_r477114053"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 4324,
      "file_path": "scrapy/core/downloader/__init__.py",
      "line": 46,
      "side": "RIGHT",
      "diff_hunk": "@@ -41,17 +41,17 @@ def close(self):\n \n     def __repr__(self):\n         cls_name = self.__class__.__name__\n-        return \"%s(concurrency=%r, delay=%0.2f, randomize_delay=%r)\" % (\n-            cls_name, self.concurrency, self.delay, self.randomize_delay)\n+        return (f\"{cls_name}(concurrency={self.concurrency!r}, \"\n+                f\"delay={self.delay:.2f}, \"\n+                f\"randomize_delay={self.randomize_delay!r}\")",
      "comment": "```suggestion\r\n                f\"randomize_delay={self.randomize_delay!r})\")\r\n```\r\n\r\nDo you think you can add a test that would have caught this?",
      "comment_id": 477116062,
      "user": "Gallaecio",
      "created_at": "2020-08-26T08:12:00Z",
      "url": "https://github.com/scrapy/scrapy/pull/4324#discussion_r477116062"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 4324,
      "file_path": "scrapy/extensions/statsmailer.py",
      "line": 33,
      "side": "RIGHT",
      "diff_hunk": "@@ -24,11 +24,11 @@ def from_crawler(cls, crawler):\n         o = cls(crawler.stats, recipients, mail)\n         crawler.signals.connect(o.spider_closed, signal=signals.spider_closed)\n         return o\n-        \n+\n     def spider_closed(self, spider):\n         spider_stats = self.stats.get_stats(spider)\n         body = \"Global stats\\n\\n\"\n-        body += \"\\n\".join(\"%-50s : %s\" % i for i in self.stats.get_stats().items())\n-        body += \"\\n\\n%s stats\\n\\n\" % spider.name\n-        body += \"\\n\".join(\"%-50s : %s\" % i for i in spider_stats.items())\n-        return self.mail.send(self.recipients, \"Scrapy stats for: %s\" % spider.name, body)\n+        body += \"\\n\".join(f\"{i:<50} : {self.stats.get_stats()[i]}\" for i in self.stats.get_stats())\n+        body += f\"\\n\\n{spider.name} stats\\n\\n\"\n+        body += \"\\n\".join(f\"{i:<50} : {spider_stats[i]}\" for i in spider_stats)",
      "comment": "```suggestion\r\n        body += \"\\n\".join(f\"{k:<50} : {v}\" for k, v in self.stats.get_stats().items())\r\n        body += f\"\\n\\n{spider.name} stats\\n\\n\"\r\n        body += \"\\n\".join(f\"{k:<50} : {v}\" for k, v in spider_stats.items())\r\n```",
      "comment_id": 477144150,
      "user": "Gallaecio",
      "created_at": "2020-08-26T08:56:34Z",
      "url": "https://github.com/scrapy/scrapy/pull/4324#discussion_r477144150"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 4324,
      "file_path": "scrapy/http/request/form.py",
      "line": 207,
      "side": "RIGHT",
      "diff_hunk": "@@ -205,12 +204,12 @@ def _get_clickable(clickdata, form):\n \n     # We didn't find it, so now we build an XPath expression out of the other\n     # arguments, because they can be used as such\n-    xpath = './/*' + ''.join('[@%s=\"%s\"]' % c for c in clickdata.items())\n+    xpath = './/*' + ''.join(f'[@{key}=\"{clickdata[key]}\"]' for key in clickdata)",
      "comment": "```suggestion\r\n    xpath = './/*' + ''.join(f'[@{k}=\"{v}\"]' for k, v in clickdata.items())\r\n```",
      "comment_id": 477144542,
      "user": "Gallaecio",
      "created_at": "2020-08-26T08:57:12Z",
      "url": "https://github.com/scrapy/scrapy/pull/4324#discussion_r477144542"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 4324,
      "file_path": "scrapy/http/response/__init__.py",
      "line": 59,
      "side": "RIGHT",
      "diff_hunk": "@@ -55,8 +55,8 @@ def _set_url(self, url):\n         if isinstance(url, str):\n             self._url = url\n         else:\n-            raise TypeError('%s url must be str, got %s:' %\n-                            (type(self).__name__, type(url).__name__))\n+            raise TypeError(f'{type(self).__name__} url must be str, '\n+                            f'got {type(url).__name__}')",
      "comment": "Looks like that colon at the end shouldn\u2019t have been there in the first place, so :heavy_check_mark: ",
      "comment_id": 477149547,
      "user": "Gallaecio",
      "created_at": "2020-08-26T09:05:29Z",
      "url": "https://github.com/scrapy/scrapy/pull/4324#discussion_r477149547"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 4324,
      "file_path": "scrapy/utils/conf.py",
      "line": 21,
      "side": "RIGHT",
      "diff_hunk": "@@ -17,18 +17,19 @@ def build_component_list(compdict, custom=None, convert=update_classpath):\n \n     def _check_components(complist):\n         if len({convert(c) for c in complist}) != len(complist):\n-            raise ValueError('Some paths in {!r} convert to the same object, '\n-                             'please update your settings'.format(complist))\n+            raise ValueError('Some paths in {complist!r} convert to the same object, '\n+                             'please update your settings')",
      "comment": "```suggestion\r\n            raise ValueError(f'Some paths in {complist!r} convert to the same object, '\r\n                             'please update your settings')\r\n```\r\n\r\nA test that would have caught this would be great.",
      "comment_id": 477164582,
      "user": "Gallaecio",
      "created_at": "2020-08-26T09:27:03Z",
      "url": "https://github.com/scrapy/scrapy/pull/4324#discussion_r477164582"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 4324,
      "file_path": "scrapy/utils/conf.py",
      "line": 46,
      "side": "RIGHT",
      "diff_hunk": "@@ -40,8 +41,9 @@ def _validate_values(compdict):\n         \"\"\"Fail if a value in the components dict is not a real number or None.\"\"\"\n         for name, value in compdict.items():\n             if value is not None and not isinstance(value, numbers.Real):\n-                raise ValueError('Invalid value {} for component {}, please provide '\n-                                 'a real number or None instead'.format(value, name))\n+                raise ValueError(f'Invalid value {value} for component {name}, '\n+                                 'please provide a real number or None instead'\n+                                 )",
      "comment": ":lipstick: \r\n\r\n```suggestion\r\n                raise ValueError(f'Invalid value {value} for component {name}, '\r\n                                 'please provide a real number or None instead')\r\n```",
      "comment_id": 477165383,
      "user": "Gallaecio",
      "created_at": "2020-08-26T09:28:28Z",
      "url": "https://github.com/scrapy/scrapy/pull/4324#discussion_r477165383"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 4324,
      "file_path": "scrapy/core/downloader/__init__.py",
      "line": 46,
      "side": "RIGHT",
      "diff_hunk": "@@ -41,17 +41,17 @@ def close(self):\n \n     def __repr__(self):\n         cls_name = self.__class__.__name__\n-        return \"%s(concurrency=%r, delay=%0.2f, randomize_delay=%r)\" % (\n-            cls_name, self.concurrency, self.delay, self.randomize_delay)\n+        return (f\"{cls_name}(concurrency={self.concurrency!r}, \"\n+                f\"delay={self.delay:.2f}, \"\n+                f\"randomize_delay={self.randomize_delay!r}\")",
      "comment": "@Gallaecio , I did not find where this class is tested. Would you please give me some directions to where/how would `__repr__` be tested?",
      "comment_id": 478661358,
      "user": "ammarnajjar",
      "created_at": "2020-08-27T19:57:40Z",
      "url": "https://github.com/scrapy/scrapy/pull/4324#discussion_r478661358"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 4324,
      "file_path": "scrapy/core/downloader/__init__.py",
      "line": 46,
      "side": "RIGHT",
      "diff_hunk": "@@ -41,17 +41,17 @@ def close(self):\n \n     def __repr__(self):\n         cls_name = self.__class__.__name__\n-        return \"%s(concurrency=%r, delay=%0.2f, randomize_delay=%r)\" % (\n-            cls_name, self.concurrency, self.delay, self.randomize_delay)\n+        return (f\"{cls_name}(concurrency={self.concurrency!r}, \"\n+                f\"delay={self.delay:.2f}, \"\n+                f\"randomize_delay={self.randomize_delay!r}\")",
      "comment": "I don\u2019t think we have any. I would suggest creating a new file, e.g. `tests/test_core_downloader.py`, import `Slot` there, and add a simple test case class with a method that tests this.",
      "comment_id": 478916296,
      "user": "Gallaecio",
      "created_at": "2020-08-28T08:05:20Z",
      "url": "https://github.com/scrapy/scrapy/pull/4324#discussion_r478916296"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 4324,
      "file_path": "scrapy/core/downloader/__init__.py",
      "line": 46,
      "side": "RIGHT",
      "diff_hunk": "@@ -41,17 +41,17 @@ def close(self):\n \n     def __repr__(self):\n         cls_name = self.__class__.__name__\n-        return \"%s(concurrency=%r, delay=%0.2f, randomize_delay=%r)\" % (\n-            cls_name, self.concurrency, self.delay, self.randomize_delay)\n+        return (f\"{cls_name}(concurrency={self.concurrency!r}, \"\n+                f\"delay={self.delay:.2f}, \"\n+                f\"randomize_delay={self.randomize_delay!r}\")",
      "comment": "In 0e579182 I covered only the `__repr__` method, covering the whole file with tests would be great, but I think this would be outside the scope of this PR, won't you agree?",
      "comment_id": 479202713,
      "user": "ammarnajjar",
      "created_at": "2020-08-28T12:03:31Z",
      "url": "https://github.com/scrapy/scrapy/pull/4324#discussion_r479202713"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 4324,
      "file_path": "scrapy/commands/check.py",
      "line": 20,
      "side": "RIGHT",
      "diff_hunk": "@@ -17,22 +17,22 @@ def printSummary(self, start, stop):\n         plural = \"s\" if run != 1 else \"\"\n \n         writeln(self.separator2)\n-        writeln(\"Ran %d contract%s in %.3fs\" % (run, plural, stop - start))\n+        writeln(f\"Ran {run} contract{plural} in {stop - start:.3f}\")",
      "comment": "```suggestion\r\n        writeln(f\"Ran {run} contract{plural} in {stop - start:.3f}s\")\r\n```",
      "comment_id": 479621844,
      "user": "kmike",
      "created_at": "2020-08-29T07:41:25Z",
      "url": "https://github.com/scrapy/scrapy/pull/4324#discussion_r479621844"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 4742,
      "file_path": "scrapy/utils/spider.py",
      "line": 12,
      "side": "RIGHT",
      "diff_hunk": "@@ -4,15 +4,18 @@\n from scrapy.spiders import Spider\n from scrapy.utils.defer import deferred_from_coro\n from scrapy.utils.misc import arg_to_iter\n-try:\n-    from scrapy.utils.py36 import collect_asyncgen\n-except SyntaxError:\n-    collect_asyncgen = None\n \n \n logger = logging.getLogger(__name__)\n \n \n+async def collect_asyncgen(result):",
      "comment": "I'm using this function in a test in the async start_requests PR, I've moved it to utils.asyncgen there.",
      "comment_id": 474479835,
      "user": "wRAR",
      "created_at": "2020-08-21T07:41:54Z",
      "url": "https://github.com/scrapy/scrapy/pull/4742#discussion_r474479835"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 4742,
      "file_path": "scrapy/utils/py36.py",
      "line": 1,
      "side": "LEFT",
      "diff_hunk": "@@ -1,10 +0,0 @@\n-\"\"\"",
      "comment": "Don't we want to deprecate this first? https://github.com/scrapy/scrapy/pull/4467/files#diff-0ec586c8bb4f8b18d1add1d954eb5448",
      "comment_id": 474480575,
      "user": "wRAR",
      "created_at": "2020-08-21T07:42:48Z",
      "url": "https://github.com/scrapy/scrapy/pull/4742#discussion_r474480575"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 4742,
      "file_path": "scrapy/utils/spider.py",
      "line": 12,
      "side": "RIGHT",
      "diff_hunk": "@@ -4,15 +4,18 @@\n from scrapy.spiders import Spider\n from scrapy.utils.defer import deferred_from_coro\n from scrapy.utils.misc import arg_to_iter\n-try:\n-    from scrapy.utils.py36 import collect_asyncgen\n-except SyntaxError:\n-    collect_asyncgen = None\n \n \n logger = logging.getLogger(__name__)\n \n \n+async def collect_asyncgen(result):",
      "comment": "I\u2019ll undo this change and leave it to be handled by https://github.com/scrapy/scrapy/pull/4467",
      "comment_id": 474642370,
      "user": "Gallaecio",
      "created_at": "2020-08-21T11:37:05Z",
      "url": "https://github.com/scrapy/scrapy/pull/4742#discussion_r474642370"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 4742,
      "file_path": "tests/test_unsupported_python_version.py",
      "line": 11,
      "side": "RIGHT",
      "diff_hunk": "@@ -0,0 +1,19 @@\n+import sys\n+from io import StringIO\n+from unittest import TestCase\n+\n+from pytest import mark\n+\n+\n+class UnsupportedPythonVersionTestCase(TestCase):\n+\n+    @mark.skipif(sys.version_info >= (3, 6), reason='only meant for unsupported Python versions')\n+    def test_unsupported_python_version(self):",
      "comment": "It can seem pointless, but it will allow our test coverage to eventually reach 100%, and as long as we keep the Travis CI job in Python 3.5 even after dropping 3.6 and later versions, it will prevent us from breaking this message, e.g. by switching it to an f-string.",
      "comment_id": 477046516,
      "user": "Gallaecio",
      "created_at": "2020-08-26T05:41:41Z",
      "url": "https://github.com/scrapy/scrapy/pull/4742#discussion_r477046516"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 4742,
      "file_path": "scrapy/__init__.py",
      "line": 26,
      "side": "RIGHT",
      "diff_hunk": "@@ -28,11 +22,18 @@\n \n \n # Check minimum required Python version\n-if sys.version_info < (3, 5, 2):\n-    print(\"Scrapy %s requires Python 3.5.2\" % __version__)\n+if sys.version_info < (3, 6):\n+    print((\"Scrapy %s requires Python 3.6+\" % __version__).encode())",
      "comment": "I needed to do this to get the new test to pass in Python 2.7. It has to do with the fact that we are replacing `sys.stdout` to capture. I figure, being ASCII text, that this should not be a problem. But if we can test the output without having to do this, that would definitely be better.\r\n\r\nI got issues when using StringIO, so I switched to BytesIO. I\u2019ll try cStringIO as mentioned in https://stackoverflow.com/a/1218951/939364, maybe that will work.",
      "comment_id": 477223743,
      "user": "Gallaecio",
      "created_at": "2020-08-26T11:18:09Z",
      "url": "https://github.com/scrapy/scrapy/pull/4742#discussion_r477223743"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 4742,
      "file_path": "scrapy/__init__.py",
      "line": 26,
      "side": "RIGHT",
      "diff_hunk": "@@ -28,11 +22,18 @@\n \n \n # Check minimum required Python version\n-if sys.version_info < (3, 5, 2):\n-    print(\"Scrapy %s requires Python 3.5.2\" % __version__)\n+if sys.version_info < (3, 6):\n+    print((\"Scrapy %s requires Python 3.6+\" % __version__).encode())",
      "comment": "I was concerned about this thing mostly:\r\n\r\n```py\r\n>>> print(\"foo\")\r\nfoo\r\n>>> print(\"foo\".encode())\r\nb'foo'\r\n```",
      "comment_id": 477518927,
      "user": "kmike",
      "created_at": "2020-08-26T18:58:06Z",
      "url": "https://github.com/scrapy/scrapy/pull/4742#discussion_r477518927"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 4742,
      "file_path": "tests/test_unsupported_python_version.py",
      "line": 11,
      "side": "RIGHT",
      "diff_hunk": "@@ -0,0 +1,19 @@\n+import sys\n+from io import StringIO\n+from unittest import TestCase\n+\n+from pytest import mark\n+\n+\n+class UnsupportedPythonVersionTestCase(TestCase):\n+\n+    @mark.skipif(sys.version_info >= (3, 6), reason='only meant for unsupported Python versions')\n+    def test_unsupported_python_version(self):",
      "comment": "That's a very comprehensive approach, I'm impressed -  I've never seen a project testing against Python versions it doesn't support :) \r\n\r\nMy main worries were about the CI time and maintenance time. \r\n\r\nCI time doesn't seem to be large, but that's still a minute per job. \r\n\r\nRegarding maintenance: installing of old Pythons may stop working, pip may stop working in older Pythons, having 2 more envs increases chances for random failure of a build (e.g. because of a network issue in one of the jobs). Also, we now use https://packaging.python.org/guides/distributing-packages-using-setuptools/#python-requires in setup.py, so that the error message which we could break may become less and less relevant over time. \r\n\r\nBecause of that, +0.5 from me for **not** testing against Python 2.7 and 3.5.",
      "comment_id": 477576939,
      "user": "kmike",
      "created_at": "2020-08-26T20:42:05Z",
      "url": "https://github.com/scrapy/scrapy/pull/4742#discussion_r477576939"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 3873,
      "file_path": "scrapy/utils/misc.py",
      "line": 47,
      "side": "RIGHT",
      "diff_hunk": "@@ -33,10 +33,19 @@ def arg_to_iter(arg):\n def load_object(path):\n     \"\"\"Load an object given its absolute object path, and return it.\n \n-    object can be a class, function, variable or an instance.\n+    If ``path`` is not a string, but an object, then return it as is.\n+\n+    The object can be a class, function, variable or an instance.\n     path ie: 'scrapy.downloadermiddlewares.redirect.RedirectMiddleware'\n     \"\"\"\n \n+    if not isinstance(path, six.string_types):\n+        if callable(path):",
      "comment": "Sorry this has languished so.\r\n\r\nBut I'm unsure how to treat the logic then.\r\n`callable()` will return True even for some objects that aren't (like an empty class).\r\nBut for variables, it's not as simple, if they're strings they could be meant as a classpath to load, or a variable to pass as-is. The distinction would be hard to make.\r\n\r\nSo should the logic for `load_object` just return anything that doesn't happen to be a string which has a dot (the check for valid classpath), or fails to import?",
      "comment_id": 386528461,
      "user": "nyov",
      "created_at": "2020-03-02T17:11:24Z",
      "url": "https://github.com/scrapy/scrapy/pull/3873#discussion_r386528461"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 3873,
      "file_path": "scrapy/utils/misc.py",
      "line": 47,
      "side": "RIGHT",
      "diff_hunk": "@@ -33,10 +33,19 @@ def arg_to_iter(arg):\n def load_object(path):\n     \"\"\"Load an object given its absolute object path, and return it.\n \n-    object can be a class, function, variable or an instance.\n+    If ``path`` is not a string, but an object, then return it as is.\n+\n+    The object can be a class, function, variable or an instance.\n     path ie: 'scrapy.downloadermiddlewares.redirect.RedirectMiddleware'\n     \"\"\"\n \n+    if not isinstance(path, six.string_types):\n+        if callable(path):",
      "comment": "I\u2019m OK with checking that is it not a string and returning it otherwise; I assume a setting that is loaded using `load_object` will not allow a string as value, and we really not want to silence import errors due to typos.",
      "comment_id": 393676783,
      "user": "Gallaecio",
      "created_at": "2020-03-17T13:26:16Z",
      "url": "https://github.com/scrapy/scrapy/pull/3873#discussion_r393676783"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 3873,
      "file_path": "scrapy/utils/misc.py",
      "line": 47,
      "side": "RIGHT",
      "diff_hunk": "@@ -33,10 +33,19 @@ def arg_to_iter(arg):\n def load_object(path):\n     \"\"\"Load an object given its absolute object path, and return it.\n \n-    object can be a class, function, variable or an instance.\n+    If ``path`` is not a string, but an object, then return it as is.\n+\n+    The object can be a class, function, variable or an instance.\n     path ie: 'scrapy.downloadermiddlewares.redirect.RedirectMiddleware'\n     \"\"\"\n \n+    if not isinstance(path, six.string_types):\n+        if callable(path):",
      "comment": "https://github.com/scrapy/scrapy/pull/3873#pullrequestreview-471665059",
      "comment_id": 474022731,
      "user": "Gallaecio",
      "created_at": "2020-08-20T14:24:00Z",
      "url": "https://github.com/scrapy/scrapy/pull/3873#discussion_r474022731"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 3873,
      "file_path": "tests/test_utils_misc/__init__.py",
      "line": 17,
      "side": "RIGHT",
      "diff_hunk": "@@ -13,10 +13,13 @@\n class UtilsMiscTestCase(unittest.TestCase):\n \n     def test_load_object(self):\n+        obj = load_object(load_object)\n+        self.assertIs(obj, load_object)",
      "comment": "I think it'd be nice to add a test for a class explicitly.",
      "comment_id": 474936354,
      "user": "kmike",
      "created_at": "2020-08-21T20:22:48Z",
      "url": "https://github.com/scrapy/scrapy/pull/3873#discussion_r474936354"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 3873,
      "file_path": "tests/test_settings/__init__.py",
      "line": 416,
      "side": "RIGHT",
      "diff_hunk": "@@ -385,6 +385,38 @@ def test_getdict_autodegrade_basesettings(self):\n         self.assertIn('key', mydict)\n         self.assertEqual(mydict['key'], 'val')\n \n+    def test_passing_objects_as_values(self):\n+        from scrapy.core.downloader.handlers.file import FileDownloadHandler\n+        from scrapy.utils.misc import create_instance\n+        from scrapy.utils.test import get_crawler\n+\n+        class TestPipeline():\n+            def process_item(self, i, s):\n+                return i\n+\n+        settings = Settings({\n+            'ITEM_PIPELINES': {\n+                TestPipeline: 800,\n+            },\n+            'DOWNLOAD_HANDLERS': {\n+                'ftp': FileDownloadHandler,\n+            },\n+        })\n+\n+        self.assertIn('ITEM_PIPELINES', settings.attributes)\n+\n+        mypipeline, priority = settings.getdict('ITEM_PIPELINES').popitem()\n+        self.assertEqual(priority, 800)\n+        self.assertEqual(mypipeline, TestPipeline)\n+        self.assertIsInstance(mypipeline(), TestPipeline)\n+        self.assertEqual(mypipeline().process_item('item', None), 'item')\n+\n+        myhandler = settings.getdict('DOWNLOAD_HANDLERS').pop('ftp')\n+        self.assertEqual(myhandler, FileDownloadHandler)\n+        myhandler_instance = create_instance(myhandler, None, get_crawler())",
      "comment": "What do you think about adding a more integration-style test, to ensure such settings are working when used with Crawler, given that it'd be the use case visible to the users?",
      "comment_id": 474939113,
      "user": "kmike",
      "created_at": "2020-08-21T20:26:16Z",
      "url": "https://github.com/scrapy/scrapy/pull/3873#discussion_r474939113"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 3873,
      "file_path": "tests/test_settings/__init__.py",
      "line": 416,
      "side": "RIGHT",
      "diff_hunk": "@@ -385,6 +385,38 @@ def test_getdict_autodegrade_basesettings(self):\n         self.assertIn('key', mydict)\n         self.assertEqual(mydict['key'], 'val')\n \n+    def test_passing_objects_as_values(self):\n+        from scrapy.core.downloader.handlers.file import FileDownloadHandler\n+        from scrapy.utils.misc import create_instance\n+        from scrapy.utils.test import get_crawler\n+\n+        class TestPipeline():\n+            def process_item(self, i, s):\n+                return i\n+\n+        settings = Settings({\n+            'ITEM_PIPELINES': {\n+                TestPipeline: 800,\n+            },\n+            'DOWNLOAD_HANDLERS': {\n+                'ftp': FileDownloadHandler,\n+            },\n+        })\n+\n+        self.assertIn('ITEM_PIPELINES', settings.attributes)\n+\n+        mypipeline, priority = settings.getdict('ITEM_PIPELINES').popitem()\n+        self.assertEqual(priority, 800)\n+        self.assertEqual(mypipeline, TestPipeline)\n+        self.assertIsInstance(mypipeline(), TestPipeline)\n+        self.assertEqual(mypipeline().process_item('item', None), 'item')\n+\n+        myhandler = settings.getdict('DOWNLOAD_HANDLERS').pop('ftp')\n+        self.assertEqual(myhandler, FileDownloadHandler)\n+        myhandler_instance = create_instance(myhandler, None, get_crawler())",
      "comment": "This test gets a class from Settings (similar to taking an value from a dict), and then calls create_instance on it, so it really checks that passthrough works for Settings and for create_instance. That's not 100% obvious from these checks that Crawler would work with such settings as well.",
      "comment_id": 474942259,
      "user": "kmike",
      "created_at": "2020-08-21T20:30:07Z",
      "url": "https://github.com/scrapy/scrapy/pull/3873#discussion_r474942259"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 3873,
      "file_path": "tests/test_settings/__init__.py",
      "line": 416,
      "side": "RIGHT",
      "diff_hunk": "@@ -385,6 +385,38 @@ def test_getdict_autodegrade_basesettings(self):\n         self.assertIn('key', mydict)\n         self.assertEqual(mydict['key'], 'val')\n \n+    def test_passing_objects_as_values(self):\n+        from scrapy.core.downloader.handlers.file import FileDownloadHandler\n+        from scrapy.utils.misc import create_instance\n+        from scrapy.utils.test import get_crawler\n+\n+        class TestPipeline():\n+            def process_item(self, i, s):\n+                return i\n+\n+        settings = Settings({\n+            'ITEM_PIPELINES': {\n+                TestPipeline: 800,\n+            },\n+            'DOWNLOAD_HANDLERS': {\n+                'ftp': FileDownloadHandler,\n+            },\n+        })\n+\n+        self.assertIn('ITEM_PIPELINES', settings.attributes)\n+\n+        mypipeline, priority = settings.getdict('ITEM_PIPELINES').popitem()\n+        self.assertEqual(priority, 800)\n+        self.assertEqual(mypipeline, TestPipeline)\n+        self.assertIsInstance(mypipeline(), TestPipeline)\n+        self.assertEqual(mypipeline().process_item('item', None), 'item')\n+\n+        myhandler = settings.getdict('DOWNLOAD_HANDLERS').pop('ftp')\n+        self.assertEqual(myhandler, FileDownloadHandler)\n+        myhandler_instance = create_instance(myhandler, None, get_crawler())",
      "comment": "I looked for existing tests that used import paths in settings for objects that were defined in the test files themselves, and switched them to use regular object references.\r\n\r\nShould we consider this covered with that, or should we write a specific test for this as well?",
      "comment_id": 476441284,
      "user": "Gallaecio",
      "created_at": "2020-08-25T13:18:53Z",
      "url": "https://github.com/scrapy/scrapy/pull/3873#discussion_r476441284"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 3873,
      "file_path": "tests/test_settings/__init__.py",
      "line": 416,
      "side": "RIGHT",
      "diff_hunk": "@@ -385,6 +385,38 @@ def test_getdict_autodegrade_basesettings(self):\n         self.assertIn('key', mydict)\n         self.assertEqual(mydict['key'], 'val')\n \n+    def test_passing_objects_as_values(self):\n+        from scrapy.core.downloader.handlers.file import FileDownloadHandler\n+        from scrapy.utils.misc import create_instance\n+        from scrapy.utils.test import get_crawler\n+\n+        class TestPipeline():\n+            def process_item(self, i, s):\n+                return i\n+\n+        settings = Settings({\n+            'ITEM_PIPELINES': {\n+                TestPipeline: 800,\n+            },\n+            'DOWNLOAD_HANDLERS': {\n+                'ftp': FileDownloadHandler,\n+            },\n+        })\n+\n+        self.assertIn('ITEM_PIPELINES', settings.attributes)\n+\n+        mypipeline, priority = settings.getdict('ITEM_PIPELINES').popitem()\n+        self.assertEqual(priority, 800)\n+        self.assertEqual(mypipeline, TestPipeline)\n+        self.assertIsInstance(mypipeline(), TestPipeline)\n+        self.assertEqual(mypipeline().process_item('item', None), 'item')\n+\n+        myhandler = settings.getdict('DOWNLOAD_HANDLERS').pop('ftp')\n+        self.assertEqual(myhandler, FileDownloadHandler)\n+        myhandler_instance = create_instance(myhandler, None, get_crawler())",
      "comment": "Nice idea to repurpose existing tests for that \ud83d\udc4d I'd consider this covered.",
      "comment_id": 477132549,
      "user": "kmike",
      "created_at": "2020-08-26T08:37:52Z",
      "url": "https://github.com/scrapy/scrapy/pull/3873#discussion_r477132549"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 3873,
      "file_path": "scrapy/utils/misc.py",
      "line": 45,
      "side": "RIGHT",
      "diff_hunk": "@@ -39,10 +39,19 @@ def arg_to_iter(arg):\n def load_object(path):\n     \"\"\"Load an object given its absolute object path, and return it.\n \n-    object can be the import path of a class, function, variable or an\n-    instance, e.g. 'scrapy.downloadermiddlewares.redirect.RedirectMiddleware'\n+    The object can be the import path of a class, function, variable or an\n+    instance, e.g. 'scrapy.downloadermiddlewares.redirect.RedirectMiddleware'.\n+\n+    If ``path`` is not a string, but a callable() object, then return it as is.",
      "comment": "What do you think about mentioning that classes are callable? I think this is a rather arcane knowledge, but it is the main use case here.",
      "comment_id": 477133602,
      "user": "kmike",
      "created_at": "2020-08-26T08:39:34Z",
      "url": "https://github.com/scrapy/scrapy/pull/3873#discussion_r477133602"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 4756,
      "file_path": "scrapy/utils/reqser.py",
      "line": 73,
      "side": "RIGHT",
      "diff_hunk": "@@ -73,23 +73,22 @@ def request_from_dict(d, spider=None):\n def _find_method(obj, func):",
      "comment": "Maybe you could simplify this statement to something like this:\r\n\r\n```python\r\ndef _find_method(obj, func):\r\n    if obj and hasattr(func, '__func__'):\r\n            members = inspect.getmembers(obj, predicate=inspect.ismethod)\r\n            for name, obj_func in members:\r\n                # We need to use __func__ to access the original\r\n                # function object because instance method objects\r\n                # are generated each time attribute is retrieved from\r\n                # instance.\r\n                #\r\n                # Reference: The standard type hierarchy\r\n                # https://docs.python.org/3/reference/datamodel.html\r\n                if obj_func.__func__ is func.__func__:\r\n                    return name\r\n    raise ValueError(\"Function %s is not an instance method in: %s\" % (func, obj))\r\n```",
      "comment_id": 476434834,
      "user": "victor-torres",
      "created_at": "2020-08-25T13:09:14Z",
      "url": "https://github.com/scrapy/scrapy/pull/4756#discussion_r476434834"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 4756,
      "file_path": "scrapy/utils/reqser.py",
      "line": 73,
      "side": "RIGHT",
      "diff_hunk": "@@ -73,23 +73,22 @@ def request_from_dict(d, spider=None):\n def _find_method(obj, func):",
      "comment": "Good idea! Done here: https://github.com/scrapy/scrapy/pull/4756/commits/0524df866936506ae9438a5565fc4733fa5ba5b0",
      "comment_id": 476454811,
      "user": "ivanprado",
      "created_at": "2020-08-25T13:38:06Z",
      "url": "https://github.com/scrapy/scrapy/pull/4756#discussion_r476454811"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 4721,
      "file_path": "scrapy/utils/misc.py",
      "line": 194,
      "side": "RIGHT",
      "diff_hunk": "@@ -184,6 +184,33 @@ def set_environ(**kwargs):\n                 os.environ[k] = v\n \n \n+class GeneratorNodeVisitor(ast.NodeVisitor):\n+    \"\"\"Visits all AST nodes of a generator, but ignores functions defined inside the generator.\n+    If the generator code includes a return statement then sets includes_return_statement to True.\n+    \"\"\"\n+    def __init__(self):\n+        self.read_func_header = False\n+        self.includes_return_statement = False\n+        self.return_statement_lineno = None",
      "comment": "Forgot to remove it, sorry. I was gonna add the line number to the error message, but then decided to limit the change.\r\nI remove it now.",
      "comment_id": 470357638,
      "user": "soid",
      "created_at": "2020-08-14T01:11:33Z",
      "url": "https://github.com/scrapy/scrapy/pull/4721#discussion_r470357638"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 4721,
      "file_path": "scrapy/utils/misc.py",
      "line": 200,
      "side": "RIGHT",
      "diff_hunk": "@@ -184,6 +184,25 @@ def set_environ(**kwargs):\n                 os.environ[k] = v\n \n \n+def walk_callable(node):\n+    \"\"\"Similar to ``ast.walk``, but walks only function body and skips nested\n+    functions defined within the node.\n+    \"\"\"\n+    from collections import deque\n+    todo = deque([node])\n+    walked_func_def = False\n+    while todo:\n+        node = todo.popleft()\n+        if isinstance(node, ast.FunctionDef):\n+            if walked_func_def:\n+                # don't traverse nested functions\n+                continue\n+            # first function def is ok",
      "comment": "```suggestion\r\n                continue\r\n```\r\nThese comments are unnecessary, I think their purpose is already explained the docstring.",
      "comment_id": 473298449,
      "user": "elacuesta",
      "created_at": "2020-08-19T20:26:40Z",
      "url": "https://github.com/scrapy/scrapy/pull/4721#discussion_r473298449"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 4721,
      "file_path": "scrapy/utils/misc.py",
      "line": 191,
      "side": "RIGHT",
      "diff_hunk": "@@ -184,6 +184,25 @@ def set_environ(**kwargs):\n                 os.environ[k] = v\n \n \n+def walk_callable(node):\n+    \"\"\"Similar to ``ast.walk``, but walks only function body and skips nested\n+    functions defined within the node.\n+    \"\"\"\n+    from collections import deque",
      "comment": "Could this import be moved to the top of the file?",
      "comment_id": 473298684,
      "user": "elacuesta",
      "created_at": "2020-08-19T20:27:06Z",
      "url": "https://github.com/scrapy/scrapy/pull/4721#discussion_r473298684"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 4632,
      "file_path": "scrapy/core/scraper.py",
      "line": 150,
      "side": "RIGHT",
      "diff_hunk": "@@ -146,7 +146,8 @@ def _scrape2(self, request_result, request, spider):\n                 self._log_download_errors, request_result, request, spider)\n \n     def call_spider(self, result, request, spider):\n-        result.request = request\n+        if getattr(result, \"request\", None) is None:\n+            result.request = request",
      "comment": "I reviewed the surrounding code, and it looks like we can assume that `result` here is a `Response` object. So maybe a simpler change, like the one in `engine.py`, would work the same.\r\n\r\nI would also suggest renaming `result` to `response` if it were not a backward-incompatible change :expressionless: ",
      "comment_id": 440957047,
      "user": "Gallaecio",
      "created_at": "2020-06-16T15:48:19Z",
      "url": "https://github.com/scrapy/scrapy/pull/4632#discussion_r440957047"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 4632,
      "file_path": "scrapy/core/scraper.py",
      "line": 150,
      "side": "RIGHT",
      "diff_hunk": "@@ -146,7 +146,8 @@ def _scrape2(self, request_result, request, spider):\n                 self._log_download_errors, request_result, request, spider)\n \n     def call_spider(self, result, request, spider):\n-        result.request = request\n+        if getattr(result, \"request\", None) is None:\n+            result.request = request",
      "comment": "Actually, `result` can be a `Failure` object, that's what the attribute check is needed: https://github.com/scrapy/scrapy/pull/4618/commits/3992338573ba64f8c7ebaf5cee919068fcdd2ea9#diff-d12d4e527e55eef105fcf232ef856619R80-R83",
      "comment_id": 440976725,
      "user": "elacuesta",
      "created_at": "2020-06-16T16:16:56Z",
      "url": "https://github.com/scrapy/scrapy/pull/4632#discussion_r440976725"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 4414,
      "file_path": "scrapy/utils/log.py",
      "line": 155,
      "side": "RIGHT",
      "diff_hunk": "@@ -150,6 +150,9 @@ def log_scrapy_info(settings):\n                     if name != \"Scrapy\")})\n     from twisted.internet import reactor\n     logger.debug(\"Using reactor: %s.%s\", reactor.__module__, reactor.__class__.__name__)\n+    if reactor.__module__ == \"twisted.internet.asyncioreactor\" and reactor.__class__.__name__ == \"AsyncioSelectorReactor\":\n+        import asyncio\n+        logger.debug(\"Using loop: %s\", asyncio.get_event_loop().__module__)",
      "comment": "I think we should post the whole import path:\r\n\r\n```python\r\nloop = asyncio.get_event_loop()\r\nlogger.debug(\"Using loop: %s.%s\", loop.__module__, loop.__class__.__name__)\r\n```",
      "comment_id": 392573378,
      "user": "Gallaecio",
      "created_at": "2020-03-14T10:04:54Z",
      "url": "https://github.com/scrapy/scrapy/pull/4414#discussion_r392573378"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 4414,
      "file_path": "scrapy/utils/reactor.py",
      "line": 54,
      "side": "RIGHT",
      "diff_hunk": "@@ -49,13 +49,21 @@ def __call__(self):\n         return self._func(*self._a, **self._kw)\n \n \n-def install_reactor(reactor_path):\n+def install_reactor(reactor_path, event_loop_path):\n     \"\"\"Installs the :mod:`~twisted.internet.reactor` with the specified\n-    import path.\"\"\"\n+    import path.Also installs asyncio event loop as specified in the import",
      "comment": "```suggestion\r\n    import path. Also installs the asyncio event loop with the specified import\r\n```",
      "comment_id": 392573452,
      "user": "Gallaecio",
      "created_at": "2020-03-14T10:05:48Z",
      "url": "https://github.com/scrapy/scrapy/pull/4414#discussion_r392573452"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 4414,
      "file_path": "scrapy/utils/reactor.py",
      "line": 55,
      "side": "RIGHT",
      "diff_hunk": "@@ -49,13 +49,21 @@ def __call__(self):\n         return self._func(*self._a, **self._kw)\n \n \n-def install_reactor(reactor_path):\n+def install_reactor(reactor_path, event_loop_path):\n     \"\"\"Installs the :mod:`~twisted.internet.reactor` with the specified\n-    import path.\"\"\"\n+    import path.Also installs asyncio event loop as specified in the import\n+    path if asyncio reactor is enabled\"\"\"",
      "comment": "```suggestion\r\n    path if the asyncio reactor is enabled\"\"\"\r\n```\r\n\r\nI think the function documentation should clarify that `event_loop_path` must be the import path of an asyncio event loop module that provides a `new_event_loop` function.",
      "comment_id": 392573536,
      "user": "Gallaecio",
      "created_at": "2020-03-14T10:06:52Z",
      "url": "https://github.com/scrapy/scrapy/pull/4414#discussion_r392573536"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 4414,
      "file_path": "scrapy/utils/reactor.py",
      "line": 52,
      "side": "RIGHT",
      "diff_hunk": "@@ -49,13 +49,21 @@ def __call__(self):\n         return self._func(*self._a, **self._kw)\n \n \n-def install_reactor(reactor_path):\n+def install_reactor(reactor_path, event_loop_path):",
      "comment": "```suggestion\r\ndef install_reactor(reactor_path, event_loop_path=None):\r\n```\r\n\r\nSo that function calls can be cleaner for non-asyncio reactors.",
      "comment_id": 392573560,
      "user": "Gallaecio",
      "created_at": "2020-03-14T10:07:47Z",
      "url": "https://github.com/scrapy/scrapy/pull/4414#discussion_r392573560"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 4414,
      "file_path": "scrapy/utils/reactor.py",
      "line": 60,
      "side": "RIGHT",
      "diff_hunk": "@@ -49,13 +49,21 @@ def __call__(self):\n         return self._func(*self._a, **self._kw)\n \n \n-def install_reactor(reactor_path):\n+def install_reactor(reactor_path, event_loop_path):\n     \"\"\"Installs the :mod:`~twisted.internet.reactor` with the specified\n-    import path.\"\"\"\n+    import path.Also installs asyncio event loop as specified in the import\n+    path if asyncio reactor is enabled\"\"\"\n     reactor_class = load_object(reactor_path)\n     if reactor_class is asyncioreactor.AsyncioSelectorReactor:\n         with suppress(error.ReactorAlreadyInstalledError):\n-            asyncioreactor.install(asyncio.get_event_loop())\n+            if event_loop_path is not None:\n+                x = __import__(event_loop_path)",
      "comment": "I think you should use `import_module`. And I think you should not check if it is `None`, you should use whatever is loaded, and let it fail if the value is wrong.\r\n\r\nAnd maybe `x` should be renamed to `event_loop_module` or something in that line. And `loop` to `event_loop` for consistency.",
      "comment_id": 392573657,
      "user": "Gallaecio",
      "created_at": "2020-03-14T10:09:55Z",
      "url": "https://github.com/scrapy/scrapy/pull/4414#discussion_r392573657"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 4414,
      "file_path": "tests/CrawlerProcess/asyncio_custom_loop.py",
      "line": 4,
      "side": "RIGHT",
      "diff_hunk": "@@ -0,0 +1,22 @@\n+import asyncio\n+\n+from twisted.internet import asyncioreactor\n+asyncioreactor.install(asyncio.get_event_loop())",
      "comment": "Why are these imports here? Shouldn\u2019t the settings handle this part?",
      "comment_id": 392574244,
      "user": "Gallaecio",
      "created_at": "2020-03-14T10:20:00Z",
      "url": "https://github.com/scrapy/scrapy/pull/4414#discussion_r392574244"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 4414,
      "file_path": "tests/test_crawler.py",
      "line": 355,
      "side": "RIGHT",
      "diff_hunk": "@@ -347,3 +347,9 @@ def test_reactor_asyncio(self):\n         log = self.run_script(\"twisted_reactor_asyncio.py\")\n         self.assertIn(\"Spider closed (finished)\", log)\n         self.assertIn(\"Using reactor: twisted.internet.asyncioreactor.AsyncioSelectorReactor\", log)\n+\n+    def test_custom_loop_asyncio(self):\n+        log = self.run_script(\"asyncio_custom_loop.py\")\n+        self.assertIn(\"Spider closed (finished)\", log)\n+        self.assertIn(\"Using reactor: twisted.internet.asyncioreactor.AsyncioSelectorReactor\", log)\n+        self.assertIn(\"Using loop: uvloop\", log)",
      "comment": "```suggestion\r\n        self.assertIn(\"Using loop: uvloop.Loop\", log)\r\n```",
      "comment_id": 392704519,
      "user": "elacuesta",
      "created_at": "2020-03-15T19:30:01Z",
      "url": "https://github.com/scrapy/scrapy/pull/4414#discussion_r392704519"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 4414,
      "file_path": "scrapy/utils/log.py",
      "line": 157,
      "side": "RIGHT",
      "diff_hunk": "@@ -150,6 +150,11 @@ def log_scrapy_info(settings):\n                     if name != \"Scrapy\")})\n     from twisted.internet import reactor\n     logger.debug(\"Using reactor: %s.%s\", reactor.__module__, reactor.__class__.__name__)\n+    from twisted.internet import asyncioreactor\n+    if isinstance(reactor, asyncioreactor.AsyncioSelectorReactor):\n+        import asyncio\n+        loop = asyncio.get_event_loop()\n+        logger.debug(\"Using loop: %s.%s\", loop.__module__, loop.__class__.__name__)",
      "comment": "```suggestion\r\n        logger.debug(\"Using asyncio event loop: %s.%s\", loop.__module__, loop.__class__.__name__)\r\n```",
      "comment_id": 392704741,
      "user": "elacuesta",
      "created_at": "2020-03-15T19:32:15Z",
      "url": "https://github.com/scrapy/scrapy/pull/4414#discussion_r392704741"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 4414,
      "file_path": "scrapy/utils/reactor.py",
      "line": 64,
      "side": "RIGHT",
      "diff_hunk": "@@ -49,13 +49,20 @@ def __call__(self):\n         return self._func(*self._a, **self._kw)\n \n \n-def install_reactor(reactor_path):\n+def install_reactor(reactor_path, event_loop_path=None):\n     \"\"\"Installs the :mod:`~twisted.internet.reactor` with the specified\n-    import path.\"\"\"\n+    import path. Also installs the asyncio event loop with the specified import\n+    path if the asyncio reactor is enabled\"\"\"\n     reactor_class = load_object(reactor_path)\n     if reactor_class is asyncioreactor.AsyncioSelectorReactor:\n         with suppress(error.ReactorAlreadyInstalledError):\n-            asyncioreactor.install(asyncio.get_event_loop())\n+            if event_loop_path is not None:\n+                event_loop_class = load_object(event_loop_path)\n+                event_loop = event_loop_class()\n+                asyncio.set_event_loop(event_loop)\n+            else:\n+                event_loop = asyncio.get_event_loop()",
      "comment": "Is this necessary? Can\u2019t we just skip `asyncioreactor.install` in this scenario altogether?",
      "comment_id": 396590102,
      "user": "Gallaecio",
      "created_at": "2020-03-23T16:36:19Z",
      "url": "https://github.com/scrapy/scrapy/pull/4414#discussion_r396590102"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 4414,
      "file_path": "scrapy/utils/reactor.py",
      "line": 64,
      "side": "RIGHT",
      "diff_hunk": "@@ -49,13 +49,20 @@ def __call__(self):\n         return self._func(*self._a, **self._kw)\n \n \n-def install_reactor(reactor_path):\n+def install_reactor(reactor_path, event_loop_path=None):\n     \"\"\"Installs the :mod:`~twisted.internet.reactor` with the specified\n-    import path.\"\"\"\n+    import path. Also installs the asyncio event loop with the specified import\n+    path if the asyncio reactor is enabled\"\"\"\n     reactor_class = load_object(reactor_path)\n     if reactor_class is asyncioreactor.AsyncioSelectorReactor:\n         with suppress(error.ReactorAlreadyInstalledError):\n-            asyncioreactor.install(asyncio.get_event_loop())\n+            if event_loop_path is not None:\n+                event_loop_class = load_object(event_loop_path)\n+                event_loop = event_loop_class()\n+                asyncio.set_event_loop(event_loop)\n+            else:\n+                event_loop = asyncio.get_event_loop()",
      "comment": "But if we remove this part and `asyncioreactor.install` then how would we deal with the case when no event loop path is specified and the user wants to install the asyncio reactor with the default event loop ? ",
      "comment_id": 396641403,
      "user": "sakshamb2113",
      "created_at": "2020-03-23T17:49:47Z",
      "url": "https://github.com/scrapy/scrapy/pull/4414#discussion_r396641403"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 4414,
      "file_path": "tests/test_commands.py",
      "line": 318,
      "side": "RIGHT",
      "diff_hunk": "@@ -305,6 +305,18 @@ def test_asyncio_enabled_false(self):\n         log = self.get_log(self.debug_log_spider, args=[])\n         self.assertNotIn(\"Using reactor: twisted.internet.asyncioreactor.AsyncioSelectorReactor\", log)\n \n+    def test_custom_asyncio_loop_enabled_true(self):\n+        log = self.get_log(self.debug_log_spider, args=[\n+            '-s', 'TWISTED_REACTOR=twisted.internet.asyncioreactor.AsyncioSelectorReactor', '-s', 'ASYNCIO_EVENT_LOOP=uvloop.Loop'\n+        ])\n+        self.assertIn(\"Using asyncio event loop: uvloop.Loop\", log)\n+\n+    def test_custom_asyncio_loop_enabled_false(self):\n+        log = self.get_log(self.debug_log_spider, args=[\n+            '-s', 'TWISTED_REACTOR=twisted.internet.asyncioreactor.AsyncioSelectorReactor'\n+        ])\n+        self.assertIn(\"Using asyncio event loop: asyncio.unix_events._UnixSelectorEventLoop\", log)",
      "comment": "I found that asyncio uses different loops for unix and windows. Maybe its better to change the function and check for the absence of uvloop (which is not provided in the settings in this function) in the logs instead.  ",
      "comment_id": 396653008,
      "user": "sakshamb2113",
      "created_at": "2020-03-23T18:06:53Z",
      "url": "https://github.com/scrapy/scrapy/pull/4414#discussion_r396653008"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 4414,
      "file_path": "scrapy/utils/reactor.py",
      "line": 64,
      "side": "RIGHT",
      "diff_hunk": "@@ -49,13 +49,20 @@ def __call__(self):\n         return self._func(*self._a, **self._kw)\n \n \n-def install_reactor(reactor_path):\n+def install_reactor(reactor_path, event_loop_path=None):\n     \"\"\"Installs the :mod:`~twisted.internet.reactor` with the specified\n-    import path.\"\"\"\n+    import path. Also installs the asyncio event loop with the specified import\n+    path if the asyncio reactor is enabled\"\"\"\n     reactor_class = load_object(reactor_path)\n     if reactor_class is asyncioreactor.AsyncioSelectorReactor:\n         with suppress(error.ReactorAlreadyInstalledError):\n-            asyncioreactor.install(asyncio.get_event_loop())\n+            if event_loop_path is not None:\n+                event_loop_class = load_object(event_loop_path)\n+                event_loop = event_loop_class()\n+                asyncio.set_event_loop(event_loop)\n+            else:\n+                event_loop = asyncio.get_event_loop()",
      "comment": "I assume the default event loop is already used by default, if no event loop is installed.",
      "comment_id": 396665864,
      "user": "Gallaecio",
      "created_at": "2020-03-23T18:25:24Z",
      "url": "https://github.com/scrapy/scrapy/pull/4414#discussion_r396665864"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 4414,
      "file_path": "tests/test_commands.py",
      "line": 318,
      "side": "RIGHT",
      "diff_hunk": "@@ -305,6 +305,18 @@ def test_asyncio_enabled_false(self):\n         log = self.get_log(self.debug_log_spider, args=[])\n         self.assertNotIn(\"Using reactor: twisted.internet.asyncioreactor.AsyncioSelectorReactor\", log)\n \n+    def test_custom_asyncio_loop_enabled_true(self):\n+        log = self.get_log(self.debug_log_spider, args=[\n+            '-s', 'TWISTED_REACTOR=twisted.internet.asyncioreactor.AsyncioSelectorReactor', '-s', 'ASYNCIO_EVENT_LOOP=uvloop.Loop'\n+        ])\n+        self.assertIn(\"Using asyncio event loop: uvloop.Loop\", log)\n+\n+    def test_custom_asyncio_loop_enabled_false(self):\n+        log = self.get_log(self.debug_log_spider, args=[\n+            '-s', 'TWISTED_REACTOR=twisted.internet.asyncioreactor.AsyncioSelectorReactor'\n+        ])\n+        self.assertIn(\"Using asyncio event loop: asyncio.unix_events._UnixSelectorEventLoop\", log)",
      "comment": "I think a better approach would be to get the default loop class from asyncio programmatically, and check that the one reported one matches that one.",
      "comment_id": 396666625,
      "user": "Gallaecio",
      "created_at": "2020-03-23T18:26:19Z",
      "url": "https://github.com/scrapy/scrapy/pull/4414#discussion_r396666625"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 4414,
      "file_path": "scrapy/utils/reactor.py",
      "line": 64,
      "side": "RIGHT",
      "diff_hunk": "@@ -49,13 +49,20 @@ def __call__(self):\n         return self._func(*self._a, **self._kw)\n \n \n-def install_reactor(reactor_path):\n+def install_reactor(reactor_path, event_loop_path=None):\n     \"\"\"Installs the :mod:`~twisted.internet.reactor` with the specified\n-    import path.\"\"\"\n+    import path. Also installs the asyncio event loop with the specified import\n+    path if the asyncio reactor is enabled\"\"\"\n     reactor_class = load_object(reactor_path)\n     if reactor_class is asyncioreactor.AsyncioSelectorReactor:\n         with suppress(error.ReactorAlreadyInstalledError):\n-            asyncioreactor.install(asyncio.get_event_loop())\n+            if event_loop_path is not None:\n+                event_loop_class = load_object(event_loop_path)\n+                event_loop = event_loop_class()\n+                asyncio.set_event_loop(event_loop)\n+            else:\n+                event_loop = asyncio.get_event_loop()",
      "comment": "I have removed the two lines but have left `asyncioreactor.install` as without it the reactor will not be installed.",
      "comment_id": 396717290,
      "user": "sakshamb2113",
      "created_at": "2020-03-23T19:51:33Z",
      "url": "https://github.com/scrapy/scrapy/pull/4414#discussion_r396717290"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 4414,
      "file_path": "scrapy/utils/reactor.py",
      "line": 63,
      "side": "RIGHT",
      "diff_hunk": "@@ -49,13 +49,18 @@ def __call__(self):\n         return self._func(*self._a, **self._kw)\n \n \n-def install_reactor(reactor_path):\n+def install_reactor(reactor_path, event_loop_path=None):\n     \"\"\"Installs the :mod:`~twisted.internet.reactor` with the specified\n-    import path.\"\"\"\n+    import path. Also installs the asyncio event loop with the specified import\n+    path if the asyncio reactor is enabled\"\"\"\n     reactor_class = load_object(reactor_path)\n     if reactor_class is asyncioreactor.AsyncioSelectorReactor:\n         with suppress(error.ReactorAlreadyInstalledError):\n-            asyncioreactor.install(asyncio.get_event_loop())\n+            if event_loop_path is not None:\n+                event_loop_class = load_object(event_loop_path)\n+                event_loop = event_loop_class()\n+                asyncio.set_event_loop(event_loop)\n+            asyncioreactor.install()",
      "comment": "Wait, my bad. It looks like calling `asyncioreactor.install()` is necessary in all cases. Please, feel free to go to your previous implementation. Sorry :disappointed: ",
      "comment_id": 396932370,
      "user": "Gallaecio",
      "created_at": "2020-03-24T06:49:34Z",
      "url": "https://github.com/scrapy/scrapy/pull/4414#discussion_r396932370"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 4414,
      "file_path": "tests/test_commands.py",
      "line": 321,
      "side": "RIGHT",
      "diff_hunk": "@@ -305,6 +305,21 @@ def test_asyncio_enabled_false(self):\n         log = self.get_log(self.debug_log_spider, args=[])\n         self.assertNotIn(\"Using reactor: twisted.internet.asyncioreactor.AsyncioSelectorReactor\", log)\n \n+    def test_custom_asyncio_loop_enabled_true(self):\n+        log = self.get_log(self.debug_log_spider, args=[\n+            '-s', 'TWISTED_REACTOR=twisted.internet.asyncioreactor.AsyncioSelectorReactor', '-s', 'ASYNCIO_EVENT_LOOP=uvloop.Loop'\n+        ])\n+        self.assertIn(\"Using asyncio event loop: uvloop.Loop\", log)\n+\n+    def test_custom_asyncio_loop_enabled_false(self):\n+        log = self.get_log(self.debug_log_spider, args=[\n+            '-s', 'TWISTED_REACTOR=twisted.internet.asyncioreactor.AsyncioSelectorReactor'\n+        ])\n+        if sys.platform == 'win32':\n+            self.assertIn(\"Using asyncio event loop: asyncio.windows_events._WindowsSelectorEventLoop\", log)\n+        else:\n+            self.assertIn(\"Using asyncio event loop: asyncio.unix_events._UnixSelectorEventLoop\", log)",
      "comment": "This may still be a problem, e.g. given https://github.com/tornadoweb/tornado/issues/2751\r\n\r\nWhat I had in mind was using something like `new_event_loop()`, assuming that it returns an instance of the default loop class regardless of the loop installed in the Twisted reactor, and making sure that the reported asyncio event loop is of the same class.",
      "comment_id": 396935315,
      "user": "Gallaecio",
      "created_at": "2020-03-24T06:58:22Z",
      "url": "https://github.com/scrapy/scrapy/pull/4414#discussion_r396935315"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 4414,
      "file_path": "scrapy/utils/reactor.py",
      "line": 63,
      "side": "RIGHT",
      "diff_hunk": "@@ -49,13 +49,18 @@ def __call__(self):\n         return self._func(*self._a, **self._kw)\n \n \n-def install_reactor(reactor_path):\n+def install_reactor(reactor_path, event_loop_path=None):\n     \"\"\"Installs the :mod:`~twisted.internet.reactor` with the specified\n-    import path.\"\"\"\n+    import path. Also installs the asyncio event loop with the specified import\n+    path if the asyncio reactor is enabled\"\"\"\n     reactor_class = load_object(reactor_path)\n     if reactor_class is asyncioreactor.AsyncioSelectorReactor:\n         with suppress(error.ReactorAlreadyInstalledError):\n-            asyncioreactor.install(asyncio.get_event_loop())\n+            if event_loop_path is not None:\n+                event_loop_class = load_object(event_loop_path)\n+                event_loop = event_loop_class()\n+                asyncio.set_event_loop(event_loop)\n+            asyncioreactor.install()",
      "comment": "I think that the current implementation works fine. Once we set the custom event loop in asyncio , it automatically becomes the default loop and `asyncioreactor` installs it. We don't really need to supply any parameter to `asyncioreactor.install()`. ",
      "comment_id": 397109556,
      "user": "sakshamb2113",
      "created_at": "2020-03-24T12:19:44Z",
      "url": "https://github.com/scrapy/scrapy/pull/4414#discussion_r397109556"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 4414,
      "file_path": "tests/test_commands.py",
      "line": 321,
      "side": "RIGHT",
      "diff_hunk": "@@ -305,6 +305,21 @@ def test_asyncio_enabled_false(self):\n         log = self.get_log(self.debug_log_spider, args=[])\n         self.assertNotIn(\"Using reactor: twisted.internet.asyncioreactor.AsyncioSelectorReactor\", log)\n \n+    def test_custom_asyncio_loop_enabled_true(self):\n+        log = self.get_log(self.debug_log_spider, args=[\n+            '-s', 'TWISTED_REACTOR=twisted.internet.asyncioreactor.AsyncioSelectorReactor', '-s', 'ASYNCIO_EVENT_LOOP=uvloop.Loop'\n+        ])\n+        self.assertIn(\"Using asyncio event loop: uvloop.Loop\", log)\n+\n+    def test_custom_asyncio_loop_enabled_false(self):\n+        log = self.get_log(self.debug_log_spider, args=[\n+            '-s', 'TWISTED_REACTOR=twisted.internet.asyncioreactor.AsyncioSelectorReactor'\n+        ])\n+        if sys.platform == 'win32':\n+            self.assertIn(\"Using asyncio event loop: asyncio.windows_events._WindowsSelectorEventLoop\", log)\n+        else:\n+            self.assertIn(\"Using asyncio event loop: asyncio.unix_events._UnixSelectorEventLoop\", log)",
      "comment": "I have used `new_event_loop()` to find the default asyncio loop according to the platform. I think it  should work now.",
      "comment_id": 397109990,
      "user": "sakshamb2113",
      "created_at": "2020-03-24T12:20:32Z",
      "url": "https://github.com/scrapy/scrapy/pull/4414#discussion_r397109990"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 4414,
      "file_path": "scrapy/utils/reactor.py",
      "line": 63,
      "side": "RIGHT",
      "diff_hunk": "@@ -49,13 +49,18 @@ def __call__(self):\n         return self._func(*self._a, **self._kw)\n \n \n-def install_reactor(reactor_path):\n+def install_reactor(reactor_path, event_loop_path=None):\n     \"\"\"Installs the :mod:`~twisted.internet.reactor` with the specified\n-    import path.\"\"\"\n+    import path. Also installs the asyncio event loop with the specified import\n+    path if the asyncio reactor is enabled\"\"\"\n     reactor_class = load_object(reactor_path)\n     if reactor_class is asyncioreactor.AsyncioSelectorReactor:\n         with suppress(error.ReactorAlreadyInstalledError):\n-            asyncioreactor.install(asyncio.get_event_loop())\n+            if event_loop_path is not None:\n+                event_loop_class = load_object(event_loop_path)\n+                event_loop = event_loop_class()\n+                asyncio.set_event_loop(event_loop)\n+            asyncioreactor.install()",
      "comment": "Interesting. However, maybe we should avoid calling `asyncio.set_event_loop()`. Changing the default loop globally may cause unexpected issues in projects that execute another asyncio loop after the Scrapy-based crawling finishes.",
      "comment_id": 398017430,
      "user": "Gallaecio",
      "created_at": "2020-03-25T17:00:22Z",
      "url": "https://github.com/scrapy/scrapy/pull/4414#discussion_r398017430"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 4414,
      "file_path": "scrapy/utils/reactor.py",
      "line": 63,
      "side": "RIGHT",
      "diff_hunk": "@@ -49,13 +49,18 @@ def __call__(self):\n         return self._func(*self._a, **self._kw)\n \n \n-def install_reactor(reactor_path):\n+def install_reactor(reactor_path, event_loop_path=None):\n     \"\"\"Installs the :mod:`~twisted.internet.reactor` with the specified\n-    import path.\"\"\"\n+    import path. Also installs the asyncio event loop with the specified import\n+    path if the asyncio reactor is enabled\"\"\"\n     reactor_class = load_object(reactor_path)\n     if reactor_class is asyncioreactor.AsyncioSelectorReactor:\n         with suppress(error.ReactorAlreadyInstalledError):\n-            asyncioreactor.install(asyncio.get_event_loop())\n+            if event_loop_path is not None:\n+                event_loop_class = load_object(event_loop_path)\n+                event_loop = event_loop_class()\n+                asyncio.set_event_loop(event_loop)\n+            asyncioreactor.install()",
      "comment": "I have changed reactor.py and log.py. Now the event loop is only set in the `asyncioreactor`. The global asyncio event loop is no longer changed.",
      "comment_id": 399411256,
      "user": "sakshamb2113",
      "created_at": "2020-03-27T17:01:49Z",
      "url": "https://github.com/scrapy/scrapy/pull/4414#discussion_r399411256"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 4414,
      "file_path": "scrapy/utils/reactor.py",
      "line": 64,
      "side": "RIGHT",
      "diff_hunk": "@@ -50,13 +50,19 @@ def __call__(self):\n         return self._func(*self._a, **self._kw)\n \n \n-def install_reactor(reactor_path):\n+def install_reactor(reactor_path, event_loop_path=None):\n     \"\"\"Installs the :mod:`~twisted.internet.reactor` with the specified\n-    import path.\"\"\"\n+    import path. Also installs the asyncio event loop with the specified import\n+    path if the asyncio reactor is enabled\"\"\"\n     reactor_class = load_object(reactor_path)\n     if reactor_class is asyncioreactor.AsyncioSelectorReactor:\n         with suppress(error.ReactorAlreadyInstalledError):\n-            asyncioreactor.install(asyncio.get_event_loop())\n+            if event_loop_path is not None:\n+                event_loop_class = load_object(event_loop_path)\n+                event_loop = event_loop_class()\n+            else:\n+                event_loop = asyncio.new_event_loop()",
      "comment": "Is there any reason to use `new_event_loop` here as opposed to `get_event_loop` as before?",
      "comment_id": 418698925,
      "user": "elacuesta",
      "created_at": "2020-05-01T19:26:40Z",
      "url": "https://github.com/scrapy/scrapy/pull/4414#discussion_r418698925"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 4414,
      "file_path": "scrapy/utils/reactor.py",
      "line": 64,
      "side": "RIGHT",
      "diff_hunk": "@@ -50,13 +50,19 @@ def __call__(self):\n         return self._func(*self._a, **self._kw)\n \n \n-def install_reactor(reactor_path):\n+def install_reactor(reactor_path, event_loop_path=None):\n     \"\"\"Installs the :mod:`~twisted.internet.reactor` with the specified\n-    import path.\"\"\"\n+    import path. Also installs the asyncio event loop with the specified import\n+    path if the asyncio reactor is enabled\"\"\"\n     reactor_class = load_object(reactor_path)\n     if reactor_class is asyncioreactor.AsyncioSelectorReactor:\n         with suppress(error.ReactorAlreadyInstalledError):\n-            asyncioreactor.install(asyncio.get_event_loop())\n+            if event_loop_path is not None:\n+                event_loop_class = load_object(event_loop_path)\n+                event_loop = event_loop_class()\n+            else:\n+                event_loop = asyncio.new_event_loop()",
      "comment": "Calling `get_event_loop` may set the asyncio event loop globally since it calls  `set_event_loop`(which sets the loop as the default event loop)  along with `new_event_loop`(which creates a new event loop object). If someone plans to use some different asyncio event loop for work other than web crawling using scrapy in the same project, it may lead to issues.",
      "comment_id": 418728945,
      "user": "sakshamb2113",
      "created_at": "2020-05-01T20:42:11Z",
      "url": "https://github.com/scrapy/scrapy/pull/4414#discussion_r418728945"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 4414,
      "file_path": "scrapy/utils/reactor.py",
      "line": 64,
      "side": "RIGHT",
      "diff_hunk": "@@ -50,13 +50,19 @@ def __call__(self):\n         return self._func(*self._a, **self._kw)\n \n \n-def install_reactor(reactor_path):\n+def install_reactor(reactor_path, event_loop_path=None):\n     \"\"\"Installs the :mod:`~twisted.internet.reactor` with the specified\n-    import path.\"\"\"\n+    import path. Also installs the asyncio event loop with the specified import\n+    path if the asyncio reactor is enabled\"\"\"\n     reactor_class = load_object(reactor_path)\n     if reactor_class is asyncioreactor.AsyncioSelectorReactor:\n         with suppress(error.ReactorAlreadyInstalledError):\n-            asyncioreactor.install(asyncio.get_event_loop())\n+            if event_loop_path is not None:\n+                event_loop_class = load_object(event_loop_path)\n+                event_loop = event_loop_class()\n+            else:\n+                event_loop = asyncio.new_event_loop()",
      "comment": "This was discussed earlier so I tried to avoid using `set_event_loop`. https://github.com/scrapy/scrapy/pull/4414#discussion_r398017430",
      "comment_id": 418729588,
      "user": "sakshamb2113",
      "created_at": "2020-05-01T20:43:52Z",
      "url": "https://github.com/scrapy/scrapy/pull/4414#discussion_r418729588"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 4504,
      "file_path": "setup.py",
      "line": 33,
      "side": "RIGHT",
      "diff_hunk": "@@ -21,7 +21,16 @@ def has_environment_marker_platform_impl_support():\n extras_require = {}\n \n if has_environment_marker_platform_impl_support():\n+    extras_require[':platform_python_implementation == \"CPython\"'] = [\n+        'lxml>=3.5.0',\n+    ]\n     extras_require[':platform_python_implementation == \"PyPy\"'] = [\n+        # Earlier lxml versions are affected by\n+        # https://bitbucket.org/pypy/pypy/issues/2498/cython-on-pypy-3-dict-object-has-no,\n+        # which was fixed in Cython 0.26, released on 2017-06-19, and used to\n+        # generate the C headers of lxml release tarballs published since then, the\n+        # first of which was:\n+        'lxml>=4.0.0',",
      "comment": "It is technically possible for someone to install an older version if they re-generate the C headers with Cython 0.26+. If they are willing to do that, however, they can also change this number here locally for a Scrapy version supporting that.",
      "comment_id": 448536871,
      "user": "Gallaecio",
      "created_at": "2020-07-01T18:15:10Z",
      "url": "https://github.com/scrapy/scrapy/pull/4504#discussion_r448536871"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 4512,
      "file_path": "scrapy/commands/crawl.py",
      "line": 23,
      "side": "RIGHT",
      "diff_hunk": "@@ -19,6 +19,8 @@ def add_options(self, parser):\n                           help=\"set spider argument (may be repeated)\")\n         parser.add_option(\"-o\", \"--output\", metavar=\"FILE\", action=\"append\",\n                           help=\"dump scraped items into FILE (use - for stdout)\")\n+        parser.add_option(\"-O\", \"--overwrite-output\", metavar=\"FILE\", action=\"append\",\n+                          help=\"overwrite scraped items into FILE\")",
      "comment": "I wonder if it'd be more clear if help text for -o and -O is similar. E.g. (not sure about wording):\r\n\r\n```suggestion\r\n        parser.add_option(\"-o\", \"--output\", metavar=\"FILE\", action=\"append\",\r\n                          help=\"dump scraped items into FILE, appending them in the end (use - for stdout)\")\r\n        parser.add_option(\"-O\", \"--overwrite-output\", metavar=\"FILE\", action=\"append\",\r\n                          help=\"dump scraped items into FILE, overwrite the file\")\r\n```",
      "comment_id": 421059179,
      "user": "kmike",
      "created_at": "2020-05-06T20:05:22Z",
      "url": "https://github.com/scrapy/scrapy/pull/4512#discussion_r421059179"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 4512,
      "file_path": "scrapy/utils/conf.py",
      "line": 142,
      "side": "RIGHT",
      "diff_hunk": "@@ -141,6 +142,13 @@ def check_valid_format(output_format):\n                              \" or as a file extension, from the supported list %s\" %",
      "comment": "should -O be mentioned in the error above as well?",
      "comment_id": 421061582,
      "user": "kmike",
      "created_at": "2020-05-06T20:09:42Z",
      "url": "https://github.com/scrapy/scrapy/pull/4512#discussion_r421061582"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 4512,
      "file_path": "scrapy/utils/conf.py",
      "line": 148,
      "side": "RIGHT",
      "diff_hunk": "@@ -141,6 +142,13 @@ def check_valid_format(output_format):\n                              \" or as a file extension, from the supported list %s\" %\n                              (output_format, tuple(valid_output_formats)))\n \n+    overwrite = False\n+    if overwrite_output:\n+        if output:\n+            raise UsageError(\"Please use only one of --output and --overwrite-output\")",
      "comment": "```suggestion\r\n            raise UsageError(\"Please use only one of -o/--output and -O/--overwrite-output\")\r\n```\r\nOr something similar. I wonder if that would be more informative, perhaps not everybody knows exactly what `-o/-O` means.",
      "comment_id": 421082215,
      "user": "elacuesta",
      "created_at": "2020-05-06T20:48:10Z",
      "url": "https://github.com/scrapy/scrapy/pull/4512#discussion_r421082215"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 4512,
      "file_path": "scrapy/extensions/feedexport.py",
      "line": 35,
      "side": "RIGHT",
      "diff_hunk": "@@ -32,8 +32,9 @@\n class IFeedStorage(Interface):\n     \"\"\"Interface that all Feed Storages must implement\"\"\"\n \n-    def __init__(uri):\n-        \"\"\"Initialize the storage with the parameters given in the URI\"\"\"\n+    def __init__(uri, feed):",
      "comment": "What do you think about calling it feed_options?\r\n\r\n* for feed argument I'd expect some instance of Feed, whatever is it\r\n* feed_settings is not good, because this dict is not a Settings instance",
      "comment_id": 421726672,
      "user": "kmike",
      "created_at": "2020-05-07T19:01:10Z",
      "url": "https://github.com/scrapy/scrapy/pull/4512#discussion_r421726672"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 4512,
      "file_path": "scrapy/extensions/feedexport.py",
      "line": 384,
      "side": "RIGHT",
      "diff_hunk": "@@ -328,8 +363,40 @@ def _get_instance(self, objcls, *args, **kwargs):\n     def _get_exporter(self, file, format, *args, **kwargs):\n         return self._get_instance(self.exporters[format], file, *args, **kwargs)\n \n-    def _get_storage(self, uri):\n-        return self._get_instance(self.storages[urlparse(uri).scheme], uri)\n+    def _get_storage(self, uri, feed_options):\n+        \"\"\"Fork of create_instance specific to feed storage classes\n+\n+        It supports not passing the *feed_options* parameters to classes that\n+        do not support it, and issuing a deprecation warning instead.\n+        \"\"\"\n+        feedcls = self.storages[urlparse(uri).scheme]\n+        crawler = getattr(self, 'crawler', None)\n+\n+        def build_instance(builder, *args):\n+            argument_names = get_func_args(builder)\n+            if 'feed_options' in argument_names:\n+                _kwargs = {'feed_options': feed_options}\n+            else:\n+                warnings.warn(\n+                    \"{} does not support the 'feed_options' keyword argument\"\n+                    .format(builder.__qualname__),\n+                    category=ScrapyDeprecationWarning\n+                )",
      "comment": "This deprecation logic is repeated a few times, would it be possible to extract a helper?",
      "comment_id": 426073687,
      "user": "kmike",
      "created_at": "2020-05-15T22:29:33Z",
      "url": "https://github.com/scrapy/scrapy/pull/4512#discussion_r426073687"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 4512,
      "file_path": "tests/test_feedexport.py",
      "line": 1217,
      "side": "RIGHT",
      "diff_hunk": "@@ -969,3 +1056,232 @@ def test_pathlib_uri(self):\n         }\n         data = yield self.exported_no_data(settings)\n         self.assertEqual(data['csv'], b'')\n+\n+\n+class FeedExportInitTest(unittest.TestCase):\n+\n+    def test_unsupported_storage(self):\n+        settings = {\n+            'FEEDS': {\n+                'unsupported://uri': {},\n+            },\n+        }\n+        crawler = get_crawler(settings_dict=settings)\n+        with self.assertRaises(NotConfigured):\n+            FeedExporter.from_crawler(crawler)\n+\n+    def test_unsupported_format(self):\n+        settings = {\n+            'FEEDS': {\n+                'file://path': {\n+                    'format': 'unsupported_format',\n+                },\n+            },\n+        }\n+        crawler = get_crawler(settings_dict=settings)\n+        with self.assertRaises(NotConfigured):\n+            FeedExporter.from_crawler(crawler)\n+\n+\n+class StdoutFeedStorageWithoutFeedOptions(StdoutFeedStorage):\n+\n+    def __init__(self, uri):\n+        super().__init__(uri)\n+\n+\n+class StdoutFeedStoragePreFeedOptionsTest(unittest.TestCase):\n+    \"\"\"Make sure that any feed exporter created by users before the\n+    introduction of the ``feed_options`` parameter continues to work as\n+    expected, and simply issues a warning.\"\"\"\n+\n+    def test_init(self):\n+        settings_dict = {\n+            'FEED_URI': 'file:///tmp/foobar',\n+            'FEED_STORAGES': {\n+                'file': 'tests.test_feedexport.StdoutFeedStorageWithoutFeedOptions'\n+            },\n+        }\n+        crawler = get_crawler(settings_dict=settings_dict)\n+        feed_exporter = FeedExporter.from_crawler(crawler)\n+        spider = scrapy.Spider(\"default\")\n+        with warnings.catch_warnings(record=True) as w:\n+            feed_exporter.open_spider(spider)\n+            messages = tuple(str(item.message) for item in w)\n+            self.assertEqual(\n+                messages,\n+                (\n+                    (\n+                        \"StdoutFeedStorageWithoutFeedOptions does not support \"\n+                        \"the 'feed_options' keyword argument\"\n+                    ),\n+                )\n+            )\n+\n+\n+class FileFeedStorageWithoutFeedOptions(FileFeedStorage):\n+\n+    def __init__(self, uri):\n+        super().__init__(uri)\n+\n+\n+class FileFeedStoragePreFeedOptionsTest(unittest.TestCase):\n+    \"\"\"Make sure that any feed exporter created by users before the\n+    introduction of the ``feed_options`` parameter continues to work as\n+    expected, and simply issues a warning.\"\"\"\n+\n+    def test_init(self):\n+        settings_dict = {\n+            'FEED_URI': 'file:///tmp/foobar',\n+            'FEED_STORAGES': {\n+                'file': 'tests.test_feedexport.FileFeedStorageWithoutFeedOptions'\n+            },\n+        }\n+        crawler = get_crawler(settings_dict=settings_dict)\n+        feed_exporter = FeedExporter.from_crawler(crawler)\n+        spider = scrapy.Spider(\"default\")\n+        with warnings.catch_warnings(record=True) as w:\n+            feed_exporter.open_spider(spider)\n+            messages = tuple(str(item.message) for item in w)\n+            self.assertEqual(\n+                messages,\n+                (\n+                    (\n+                        \"FileFeedStorageWithoutFeedOptions does not support \"\n+                        \"the 'feed_options' keyword argument\"\n+                    ),\n+                )\n+            )\n+\n+\n+class S3FeedStorageWithoutFeedOptions(S3FeedStorage):\n+\n+    def __init__(self, uri, access_key, secret_key, acl):\n+        super().__init__(uri, access_key, secret_key, acl)\n+\n+\n+class S3FeedStorageWithoutFeedOptionsWithFromCrawler(S3FeedStorage):\n+\n+    @classmethod\n+    def from_crawler(cls, crawler, uri):\n+        return super().from_crawler(crawler, uri)\n+\n+\n+class S3FeedStoragePreFeedOptionsTest(unittest.TestCase):\n+    \"\"\"Make sure that any feed exporter created by users before the\n+    introduction of the ``feed_options`` parameter continues to work as\n+    expected, and simply issues a warning.\"\"\"\n+\n+    def test_init(self):\n+        settings_dict = {\n+            'FEED_URI': 'file:///tmp/foobar',\n+            'FEED_STORAGES': {\n+                'file': 'tests.test_feedexport.S3FeedStorageWithoutFeedOptions'\n+            },\n+        }\n+        crawler = get_crawler(settings_dict=settings_dict)\n+        feed_exporter = FeedExporter.from_crawler(crawler)\n+        spider = scrapy.Spider(\"default\")\n+        spider.crawler = crawler\n+        with warnings.catch_warnings(record=True) as w:\n+            feed_exporter.open_spider(spider)\n+            messages = tuple(str(item.message) for item in w)\n+            self.assertEqual(\n+                messages,\n+                (\n+                    (\n+                        \"S3FeedStorageWithoutFeedOptions does not support \"\n+                        \"the 'feed_options' keyword argument\"\n+                    ),\n+                )\n+            )\n+\n+    def test_from_crawler(self):\n+        settings_dict = {\n+            'FEED_URI': 'file:///tmp/foobar',\n+            'FEED_STORAGES': {\n+                'file': 'tests.test_feedexport.S3FeedStorageWithoutFeedOptionsWithFromCrawler'\n+            },\n+        }\n+        crawler = get_crawler(settings_dict=settings_dict)\n+        feed_exporter = FeedExporter.from_crawler(crawler)\n+        spider = scrapy.Spider(\"default\")\n+        spider.crawler = crawler\n+        with warnings.catch_warnings(record=True) as w:\n+            feed_exporter.open_spider(spider)\n+            messages = tuple(str(item.message) for item in w)\n+            self.assertEqual(\n+                messages,\n+                (\n+                    (\n+                        \"S3FeedStorageWithoutFeedOptionsWithFromCrawler.from_crawler \"\n+                        \"does not support the 'feed_options' keyword argument\"",
      "comment": "What do you think about telling people how to update their code in these messages, to make them disappear? We may also say explicitly that such custom storages are deprecated, and we'll stop supporting them in future releases. It can be easier to update all messages if they're issued in a single helper function.",
      "comment_id": 426074515,
      "user": "kmike",
      "created_at": "2020-05-15T22:32:39Z",
      "url": "https://github.com/scrapy/scrapy/pull/4512#discussion_r426074515"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 4512,
      "file_path": "scrapy/utils/python.py",
      "line": 198,
      "side": "RIGHT",
      "diff_hunk": "@@ -194,7 +194,8 @@ def _getargspec_py23(func):\n def get_func_args(func, stripself=False):\n     \"\"\"Return the argument name list of a callable\"\"\"\n     if inspect.isfunction(func):\n-        func_args, _, _, _ = _getargspec_py23(func)\n+        spec = inspect.getfullargspec(func)\n+        func_args = spec.args + spec.kwonlyargs",
      "comment": "Is it a cleanup or an issue fix? If that's an issue fix, could you please add a test case for get_func_args, even if without the fix a different part of scrapy fails?",
      "comment_id": 426074995,
      "user": "kmike",
      "created_at": "2020-05-15T22:34:43Z",
      "url": "https://github.com/scrapy/scrapy/pull/4512#discussion_r426074995"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 4623,
      "file_path": "scrapy/commands/genspider.py",
      "line": 70,
      "side": "RIGHT",
      "diff_hunk": "@@ -66,6 +66,10 @@ def run(self, args, opts):\n             print(\"Cannot create a spider with the same name as your project\")\n             return\n \n+        if exists(name + \".py\"):\n+            print(\"Spider %r already exists in module\" % name)",
      "comment": "This message is not entirely accurate, as any file with the same name would trigger it (not necessarily a spider).",
      "comment_id": 438790212,
      "user": "elacuesta",
      "created_at": "2020-06-11T13:40:02Z",
      "url": "https://github.com/scrapy/scrapy/pull/4623#discussion_r438790212"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 4623,
      "file_path": "tests/test_commands.py",
      "line": 193,
      "side": "RIGHT",
      "diff_hunk": "@@ -188,6 +188,10 @@ def test_same_name_as_project(self):\n         self.assertEqual(2, self.call('genspider', self.project_name))\n         assert not exists(join(self.proj_mod_path, 'spiders', '%s.py' % self.project_name))\n \n+    def test_same_name_as_existing_spider(self):\n+        self.call('genspider', 'example', 'example.com')\n+        self.assertEqual(0, self.call('genspider', 'example', 'example.com'))",
      "comment": "This only checks that the command finishes correctly with an exit code 0. Is there a way we could also test that the file is not overridden? Checking that the printed message appears in the command's output should be enough I think.",
      "comment_id": 438793602,
      "user": "elacuesta",
      "created_at": "2020-06-11T13:43:27Z",
      "url": "https://github.com/scrapy/scrapy/pull/4623#discussion_r438793602"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 4623,
      "file_path": "tests/test_commands.py",
      "line": 193,
      "side": "RIGHT",
      "diff_hunk": "@@ -188,6 +188,10 @@ def test_same_name_as_project(self):\n         self.assertEqual(2, self.call('genspider', self.project_name))\n         assert not exists(join(self.proj_mod_path, 'spiders', '%s.py' % self.project_name))\n \n+    def test_same_name_as_existing_spider(self):\n+        self.call('genspider', 'example', 'example.com')\n+        self.assertEqual(0, self.call('genspider', 'example', 'example.com'))",
      "comment": "I think we could maybe compare the md5 checksum of the file before and after if it's really necessary. Do you think we need that or should I just stick to checking the printed message?",
      "comment_id": 438947016,
      "user": "ajaymittur",
      "created_at": "2020-06-11T17:21:41Z",
      "url": "https://github.com/scrapy/scrapy/pull/4623#discussion_r438947016"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 4623,
      "file_path": "scrapy/commands/genspider.py",
      "line": 70,
      "side": "RIGHT",
      "diff_hunk": "@@ -66,6 +66,10 @@ def run(self, args, opts):\n             print(\"Cannot create a spider with the same name as your project\")\n             return\n \n+        if exists(name + \".py\"):\n+            print(\"Spider %r already exists in module\" % name)",
      "comment": "Do you think a message like \"File %r.py already exists in the current directory\" would be more accurate? and I think allowing it to overwrite the existing file if the --force option is used would be suitable as described in the original issue, what do you think?",
      "comment_id": 438952256,
      "user": "ajaymittur",
      "created_at": "2020-06-11T17:31:01Z",
      "url": "https://github.com/scrapy/scrapy/pull/4623#discussion_r438952256"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 4623,
      "file_path": "scrapy/commands/genspider.py",
      "line": 70,
      "side": "RIGHT",
      "diff_hunk": "@@ -66,6 +66,10 @@ def run(self, args, opts):\n             print(\"Cannot create a spider with the same name as your project\")\n             return\n \n+        if exists(name + \".py\"):\n+            print(\"Spider %r already exists in module\" % name)",
      "comment": "I think talking about the file is indeed better, thanks for making the change. I don't think adding a `--force` option is necessary, in my opinion it'd just make the code more complex for something that could be solved easily outside of Scrapy (renaming the existing file or choosing a different name for the new file).",
      "comment_id": 439445481,
      "user": "elacuesta",
      "created_at": "2020-06-12T14:15:36Z",
      "url": "https://github.com/scrapy/scrapy/pull/4623#discussion_r439445481"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 4623,
      "file_path": "tests/test_commands.py",
      "line": 193,
      "side": "RIGHT",
      "diff_hunk": "@@ -188,6 +188,10 @@ def test_same_name_as_project(self):\n         self.assertEqual(2, self.call('genspider', self.project_name))\n         assert not exists(join(self.proj_mod_path, 'spiders', '%s.py' % self.project_name))\n \n+    def test_same_name_as_existing_spider(self):\n+        self.call('genspider', 'example', 'example.com')\n+        self.assertEqual(0, self.call('genspider', 'example', 'example.com'))",
      "comment": "Just checking the message would be enough IMHO. I see you already made the change, thanks for that. Could you also check that the message does not appear the first time?",
      "comment_id": 439446989,
      "user": "elacuesta",
      "created_at": "2020-06-12T14:18:00Z",
      "url": "https://github.com/scrapy/scrapy/pull/4623#discussion_r439446989"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 4623,
      "file_path": "scrapy/commands/genspider.py",
      "line": 82,
      "side": "RIGHT",
      "diff_hunk": "@@ -69,7 +69,18 @@ def run(self, args, opts):\n         try:\n             spidercls = self.crawler_process.spider_loader.load(name)\n         except KeyError:\n-            pass\n+            if not self.settings.get('NEWSPIDER_MODULE'):\n+                if exists(name + \".py\"):\n+                    print(\"File %r already exists in the current directory\" % (name + \".py\"))\n+                    return\n+            else:\n+                spiders_module = import_module(self.settings['NEWSPIDER_MODULE'])\n+                spiders_dir = dirname(spiders_module.__file__)\n+                spiders_dir_abs = abspath(spiders_dir)\n+                if exists(join(spiders_dir_abs, name + \".py\")):\n+                    print(\"Spider with filename %r already exists in directory:\" % (name + \".py\"))\n+                    print(\"  %s\" % spiders_dir)",
      "comment": ":lipstick:  I would simplify both messages to \"%r already exists\", where %r is the absolute path of the destination file.",
      "comment_id": 439863160,
      "user": "Gallaecio",
      "created_at": "2020-06-14T20:06:14Z",
      "url": "https://github.com/scrapy/scrapy/pull/4623#discussion_r439863160"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 4623,
      "file_path": "scrapy/commands/genspider.py",
      "line": 76,
      "side": "RIGHT",
      "diff_hunk": "@@ -69,7 +69,18 @@ def run(self, args, opts):\n         try:\n             spidercls = self.crawler_process.spider_loader.load(name)\n         except KeyError:\n-            pass\n+            if not self.settings.get('NEWSPIDER_MODULE'):\n+                if exists(name + \".py\"):\n+                    print(\"File %r already exists in the current directory\" % (name + \".py\"))\n+                    return\n+            else:",
      "comment": "Could you add a test to cover the case where `NEWSPIDER_MODULE` is defined?",
      "comment_id": 439863387,
      "user": "Gallaecio",
      "created_at": "2020-06-14T20:09:48Z",
      "url": "https://github.com/scrapy/scrapy/pull/4623#discussion_r439863387"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 4623,
      "file_path": "scrapy/commands/genspider.py",
      "line": 76,
      "side": "RIGHT",
      "diff_hunk": "@@ -69,7 +69,18 @@ def run(self, args, opts):\n         try:\n             spidercls = self.crawler_process.spider_loader.load(name)\n         except KeyError:\n-            pass\n+            if not self.settings.get('NEWSPIDER_MODULE'):\n+                if exists(name + \".py\"):\n+                    print(\"File %r already exists in the current directory\" % (name + \".py\"))\n+                    return\n+            else:",
      "comment": "I've added a test to the case @elacuesta mentioned, `test_same_filename_as_existing_spider` under `GenspiderCommandTest` where `NEWSPIDER_MODULE` will be defined when the test is run. Could you please elaborate? don't quite understand what you mean.",
      "comment_id": 439914785,
      "user": "ajaymittur",
      "created_at": "2020-06-15T03:35:59Z",
      "url": "https://github.com/scrapy/scrapy/pull/4623#discussion_r439914785"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 4623,
      "file_path": "scrapy/commands/genspider.py",
      "line": 76,
      "side": "RIGHT",
      "diff_hunk": "@@ -69,7 +69,18 @@ def run(self, args, opts):\n         try:\n             spidercls = self.crawler_process.spider_loader.load(name)\n         except KeyError:\n-            pass\n+            if not self.settings.get('NEWSPIDER_MODULE'):\n+                if exists(name + \".py\"):\n+                    print(\"File %r already exists in the current directory\" % (name + \".py\"))\n+                    return\n+            else:",
      "comment": "> where NEWSPIDER_MODULE will be defined when the test is run\r\n\r\nWhere is it defined? Or do you mean that people running the tests must define it manually somewhere before running the test?",
      "comment_id": 440029483,
      "user": "Gallaecio",
      "created_at": "2020-06-15T08:59:03Z",
      "url": "https://github.com/scrapy/scrapy/pull/4623#discussion_r440029483"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 4623,
      "file_path": "scrapy/commands/genspider.py",
      "line": 76,
      "side": "RIGHT",
      "diff_hunk": "@@ -69,7 +69,18 @@ def run(self, args, opts):\n         try:\n             spidercls = self.crawler_process.spider_loader.load(name)\n         except KeyError:\n-            pass\n+            if not self.settings.get('NEWSPIDER_MODULE'):\n+                if exists(name + \".py\"):\n+                    print(\"File %r already exists in the current directory\" % (name + \".py\"))\n+                    return\n+            else:",
      "comment": "Sorry, should have phrased it better. From what I understand of the code base, when the `scrapy` command is run in the command line, the `settings` object is set in line 112 of the [cmdline](https://github.com/scrapy/scrapy/blob/master/scrapy/cmdline.py#L112) module, digging further into `get_project_settings()`, I found that the value of `NEWSPIDER_MODULE` **is set here to either an empty string or the module where the spiders are located** in case of a project. This `settings` object is then passed on to [cmd](https://github.com/scrapy/scrapy/blob/master/scrapy/cmdline.py#L137) in line 137.\r\n\r\nAt this point `cmd` **is already set to** `genspider` and the line 137 `cmd.settings = settings` assigns the previously mentioned `settings` object to `genspider.settings`. This settings dictionary is what I'm accessing through `self.settings`. So essentially the `NEWSPIDER_MODULE` property will always be defined (either to `''` or the spiders module) ",
      "comment_id": 440105195,
      "user": "ajaymittur",
      "created_at": "2020-06-15T11:19:19Z",
      "url": "https://github.com/scrapy/scrapy/pull/4623#discussion_r440105195"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 4623,
      "file_path": "scrapy/commands/genspider.py",
      "line": 76,
      "side": "RIGHT",
      "diff_hunk": "@@ -69,7 +69,18 @@ def run(self, args, opts):\n         try:\n             spidercls = self.crawler_process.spider_loader.load(name)\n         except KeyError:\n-            pass\n+            if not self.settings.get('NEWSPIDER_MODULE'):\n+                if exists(name + \".py\"):\n+                    print(\"File %r already exists in the current directory\" % (name + \".py\"))\n+                    return\n+            else:",
      "comment": "Makes sense.\r\n\r\nSo, given your code also handles the scenario where the `NEWSPIDER_MODULE` setting is defined with a non-empty string as value, I think we need a test for that scenario.",
      "comment_id": 440107798,
      "user": "Gallaecio",
      "created_at": "2020-06-15T11:24:59Z",
      "url": "https://github.com/scrapy/scrapy/pull/4623#discussion_r440107798"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 4623,
      "file_path": "scrapy/commands/genspider.py",
      "line": 76,
      "side": "RIGHT",
      "diff_hunk": "@@ -69,7 +69,18 @@ def run(self, args, opts):\n         try:\n             spidercls = self.crawler_process.spider_loader.load(name)\n         except KeyError:\n-            pass\n+            if not self.settings.get('NEWSPIDER_MODULE'):\n+                if exists(name + \".py\"):\n+                    print(\"File %r already exists in the current directory\" % (name + \".py\"))\n+                    return\n+            else:",
      "comment": "The value of `NEWSPIDER_MODULE` is set implicitly when the `scrapy` command is run, I think the only way we can test it for both the scenarios is if we test run `genspider` as a standalone command and then within a project scope, which I think I have handled in the tests file.",
      "comment_id": 440113677,
      "user": "ajaymittur",
      "created_at": "2020-06-15T11:37:08Z",
      "url": "https://github.com/scrapy/scrapy/pull/4623#discussion_r440113677"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 4623,
      "file_path": "scrapy/commands/genspider.py",
      "line": 76,
      "side": "RIGHT",
      "diff_hunk": "@@ -69,7 +69,18 @@ def run(self, args, opts):\n         try:\n             spidercls = self.crawler_process.spider_loader.load(name)\n         except KeyError:\n-            pass\n+            if not self.settings.get('NEWSPIDER_MODULE'):\n+                if exists(name + \".py\"):\n+                    print(\"File %r already exists in the current directory\" % (name + \".py\"))\n+                    return\n+            else:",
      "comment": "`test_same_filename_as_existing_spider` for when the command is run within a project and `test_same_name_as_existing_file` for when the command is run as a standalone",
      "comment_id": 440114966,
      "user": "ajaymittur",
      "created_at": "2020-06-15T11:40:02Z",
      "url": "https://github.com/scrapy/scrapy/pull/4623#discussion_r440114966"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 4623,
      "file_path": "scrapy/commands/genspider.py",
      "line": 76,
      "side": "RIGHT",
      "diff_hunk": "@@ -69,7 +69,18 @@ def run(self, args, opts):\n         try:\n             spidercls = self.crawler_process.spider_loader.load(name)\n         except KeyError:\n-            pass\n+            if not self.settings.get('NEWSPIDER_MODULE'):\n+                if exists(name + \".py\"):\n+                    print(\"File %r already exists in the current directory\" % (name + \".py\"))\n+                    return\n+            else:",
      "comment": "OK, I finally understand [why the tests cover `NEWSPIDER_MODULE` usage](https://github.com/scrapy/scrapy/blob/master/scrapy/templates/project/module/settings.py.tmpl#L13). Sorry! :flushed: ",
      "comment_id": 440176495,
      "user": "Gallaecio",
      "created_at": "2020-06-15T13:30:48Z",
      "url": "https://github.com/scrapy/scrapy/pull/4623#discussion_r440176495"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 4623,
      "file_path": "scrapy/commands/genspider.py",
      "line": 82,
      "side": "RIGHT",
      "diff_hunk": "@@ -69,7 +69,17 @@ def run(self, args, opts):\n         try:\n             spidercls = self.crawler_process.spider_loader.load(name)\n         except KeyError:\n-            pass\n+            if not self.settings.get('NEWSPIDER_MODULE'):\n+                if exists(name + \".py\"):\n+                    print(\"%r already exists\" % (abspath(name + \".py\")))\n+                    return\n+            else:\n+                spiders_module = import_module(self.settings['NEWSPIDER_MODULE'])\n+                spiders_dir = dirname(spiders_module.__file__)\n+                spiders_dir_abs = abspath(spiders_dir)\n+                if exists(join(spiders_dir_abs, name + \".py\")):\n+                    print(\"%r already exists\" % (join(spiders_dir_abs, (name + \".py\"))))\n+                    return",
      "comment": "Looking at lines 84-88, I suspect this implementation will fail even if `--force` is used, which is probably undesired.",
      "comment_id": 440178468,
      "user": "Gallaecio",
      "created_at": "2020-06-15T13:33:50Z",
      "url": "https://github.com/scrapy/scrapy/pull/4623#discussion_r440178468"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 4623,
      "file_path": "scrapy/commands/genspider.py",
      "line": 76,
      "side": "RIGHT",
      "diff_hunk": "@@ -69,7 +69,18 @@ def run(self, args, opts):\n         try:\n             spidercls = self.crawler_process.spider_loader.load(name)\n         except KeyError:\n-            pass\n+            if not self.settings.get('NEWSPIDER_MODULE'):\n+                if exists(name + \".py\"):\n+                    print(\"File %r already exists in the current directory\" % (name + \".py\"))\n+                    return\n+            else:",
      "comment": "No problem at all, always down for a discussion :)",
      "comment_id": 440181034,
      "user": "ajaymittur",
      "created_at": "2020-06-15T13:37:44Z",
      "url": "https://github.com/scrapy/scrapy/pull/4623#discussion_r440181034"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 4623,
      "file_path": "scrapy/commands/genspider.py",
      "line": 82,
      "side": "RIGHT",
      "diff_hunk": "@@ -69,7 +69,17 @@ def run(self, args, opts):\n         try:\n             spidercls = self.crawler_process.spider_loader.load(name)\n         except KeyError:\n-            pass\n+            if not self.settings.get('NEWSPIDER_MODULE'):\n+                if exists(name + \".py\"):\n+                    print(\"%r already exists\" % (abspath(name + \".py\")))\n+                    return\n+            else:\n+                spiders_module = import_module(self.settings['NEWSPIDER_MODULE'])\n+                spiders_dir = dirname(spiders_module.__file__)\n+                spiders_dir_abs = abspath(spiders_dir)\n+                if exists(join(spiders_dir_abs, name + \".py\")):\n+                    print(\"%r already exists\" % (join(spiders_dir_abs, (name + \".py\"))))\n+                    return",
      "comment": "Hmm...I had discussed the same with @elacuesta https://github.com/scrapy/scrapy/pull/4623#discussion_r439445481 and he said since it was just a matter of renaming the file which the user could do easily it wasn't required. However, I could add it if its needed.",
      "comment_id": 440184743,
      "user": "ajaymittur",
      "created_at": "2020-06-15T13:43:18Z",
      "url": "https://github.com/scrapy/scrapy/pull/4623#discussion_r440184743"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 4623,
      "file_path": "scrapy/commands/genspider.py",
      "line": 82,
      "side": "RIGHT",
      "diff_hunk": "@@ -69,7 +69,17 @@ def run(self, args, opts):\n         try:\n             spidercls = self.crawler_process.spider_loader.load(name)\n         except KeyError:\n-            pass\n+            if not self.settings.get('NEWSPIDER_MODULE'):\n+                if exists(name + \".py\"):\n+                    print(\"%r already exists\" % (abspath(name + \".py\")))\n+                    return\n+            else:\n+                spiders_module = import_module(self.settings['NEWSPIDER_MODULE'])\n+                spiders_dir = dirname(spiders_module.__file__)\n+                spiders_dir_abs = abspath(spiders_dir)\n+                if exists(join(spiders_dir_abs, name + \".py\")):\n+                    print(\"%r already exists\" % (join(spiders_dir_abs, (name + \".py\"))))\n+                    return",
      "comment": "Right, sorry about that. I missed the fact that the `--force` option already exists for this command. Given that, it probably makes sense to take the flag into account.",
      "comment_id": 440220050,
      "user": "elacuesta",
      "created_at": "2020-06-15T14:33:09Z",
      "url": "https://github.com/scrapy/scrapy/pull/4623#discussion_r440220050"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 4623,
      "file_path": "scrapy/commands/genspider.py",
      "line": 69,
      "side": "RIGHT",
      "diff_hunk": "@@ -69,7 +69,23 @@ def run(self, args, opts):\n         try:",
      "comment": "I\u2019m thinking you could extract the `opts.force` check out of the whole `try`-`except`, since the whole `try`-`except` is only there to check if the spider or file already exist:\r\n\r\n```python\r\nif not opts.force:\r\n    try:\r\n    #\u2026\r\n```\r\n\r\nAlso, since this part of the code is getting long, maybe it would make sense to take the check into its own method:\r\n\r\n```python\r\n\r\nif not opts.force and self._spider_exists(name):\r\n    return\r\n\r\n# \u2026\r\n\r\ndef _spider_exists(self, name):\r\n    # \u2026\r\n```\r\n\r\nWith this later approach, you could leave `pass` within `except KeyError`, and move the additional checks _after_ the `else` of the `try`-`except`, using early returns to minimize indentation.",
      "comment_id": 440939295,
      "user": "Gallaecio",
      "created_at": "2020-06-16T15:24:15Z",
      "url": "https://github.com/scrapy/scrapy/pull/4623#discussion_r440939295"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 4623,
      "file_path": "scrapy/commands/genspider.py",
      "line": 69,
      "side": "RIGHT",
      "diff_hunk": "@@ -69,7 +69,23 @@ def run(self, args, opts):\n         try:",
      "comment": "@Gallaecio  Did you mean something like this?\r\n```py\r\ndef _spider_exists(self, name):\r\n        if not self.settings.get('NEWSPIDER_MODULE'):\r\n            # if run as a standalone command and file with same filename already exists\r\n            if exists(name + \".py\"):\r\n                print(\"%s already exists\" % (abspath(name + \".py\")))\r\n                return True\r\n        else:\r\n            try:\r\n                spidercls = self.crawler_process.spider_loader.load(name)\r\n            except KeyError:\r\n                pass\r\n            else:\r\n                # if spider with same name exists\r\n                print(\"Spider %r already exists in module:\" % name)\r\n                print(\"  %s\" % spidercls.__module__)\r\n                return False\r\n            # if spider same filename exists\r\n            spiders_module = import_module(self.settings['NEWSPIDER_MODULE'])\r\n            spiders_dir = dirname(spiders_module.__file__)\r\n            spiders_dir_abs = abspath(spiders_dir)\r\n            if exists(join(spiders_dir_abs, name + \".py\")):\r\n                print(\"%s already exists\" % (join(spiders_dir_abs, (name + \".py\"))))\r\n                return True\r\n\r\n        return False\r\n```\r\nThen the entire block (L69-94) can be reduced to \r\n```py\r\nif not opts.force and self._spider_exists(name): \r\n    return\r\n```",
      "comment_id": 441033491,
      "user": "ajaymittur",
      "created_at": "2020-06-16T17:49:08Z",
      "url": "https://github.com/scrapy/scrapy/pull/4623#discussion_r441033491"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 4623,
      "file_path": "scrapy/commands/genspider.py",
      "line": 130,
      "side": "RIGHT",
      "diff_hunk": "@@ -135,6 +112,32 @@ def _list_templates(self):\n             if filename.endswith('.tmpl'):\n                 print(\"  %s\" % splitext(filename)[0])\n \n+    def _spider_exists(self, name):\n+        if not self.settings.get('NEWSPIDER_MODULE'):\n+            # if run as a standalone command and file with same filename already exists\n+            if exists(name + \".py\"):\n+                print(\"%s already exists\" % (abspath(name + \".py\")))\n+                return True\n+        else:\n+            try:\n+                spidercls = self.crawler_process.spider_loader.load(name)\n+            except KeyError:\n+                pass\n+            else:\n+                # if spider with same name exists\n+                print(\"Spider %r already exists in module:\" % name)\n+                print(\"  %s\" % spidercls.__module__)\n+                return False",
      "comment": "```suggestion\r\n                return True\r\n```\r\n\r\nI don\u2019t understand why the tests are not breaking, though. Maybe I am missing something.\r\n\r\nIf the tests should be breaking with the current code, please first make sure they do, and _then_ change the return value.",
      "comment_id": 442099328,
      "user": "Gallaecio",
      "created_at": "2020-06-18T09:37:25Z",
      "url": "https://github.com/scrapy/scrapy/pull/4623#discussion_r442099328"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 4623,
      "file_path": "scrapy/commands/genspider.py",
      "line": 120,
      "side": "RIGHT",
      "diff_hunk": "@@ -135,6 +112,32 @@ def _list_templates(self):\n             if filename.endswith('.tmpl'):\n                 print(\"  %s\" % splitext(filename)[0])\n \n+    def _spider_exists(self, name):\n+        if not self.settings.get('NEWSPIDER_MODULE'):\n+            # if run as a standalone command and file with same filename already exists\n+            if exists(name + \".py\"):\n+                print(\"%s already exists\" % (abspath(name + \".py\")))\n+                return True",
      "comment": ":lipstick: If you add a `return False` statement after this `if`, at the same indentation level as the `if`, then the `else` below of the upper `if` is not needed anymore, allowing you to remove 1 level of indentation from all the code below.",
      "comment_id": 442101331,
      "user": "Gallaecio",
      "created_at": "2020-06-18T09:40:52Z",
      "url": "https://github.com/scrapy/scrapy/pull/4623#discussion_r442101331"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 4623,
      "file_path": "scrapy/commands/genspider.py",
      "line": 130,
      "side": "RIGHT",
      "diff_hunk": "@@ -135,6 +112,32 @@ def _list_templates(self):\n             if filename.endswith('.tmpl'):\n                 print(\"  %s\" % splitext(filename)[0])\n \n+    def _spider_exists(self, name):\n+        if not self.settings.get('NEWSPIDER_MODULE'):\n+            # if run as a standalone command and file with same filename already exists\n+            if exists(name + \".py\"):\n+                print(\"%s already exists\" % (abspath(name + \".py\")))\n+                return True\n+        else:\n+            try:\n+                spidercls = self.crawler_process.spider_loader.load(name)\n+            except KeyError:\n+                pass\n+            else:\n+                # if spider with same name exists\n+                print(\"Spider %r already exists in module:\" % name)\n+                print(\"  %s\" % spidercls.__module__)\n+                return False",
      "comment": "It looks like the [test](https://github.com/scrapy/scrapy/blob/041d1302a2f706121554dd8bd02139bffc6f3b5e/tests/test_commands.py#L168-L169) for this case only asserts the output, and because both \"Spider %r already exists in module\" and \"Created spider %r using template %r \" were being displayed it passed the test. On changing it to `return True` only the former will be displayed.\r\nApologies, can't believe I missed it.",
      "comment_id": 442146709,
      "user": "ajaymittur",
      "created_at": "2020-06-18T11:06:07Z",
      "url": "https://github.com/scrapy/scrapy/pull/4623#discussion_r442146709"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 4623,
      "file_path": "scrapy/commands/genspider.py",
      "line": 130,
      "side": "RIGHT",
      "diff_hunk": "@@ -135,6 +112,32 @@ def _list_templates(self):\n             if filename.endswith('.tmpl'):\n                 print(\"  %s\" % splitext(filename)[0])\n \n+    def _spider_exists(self, name):\n+        if not self.settings.get('NEWSPIDER_MODULE'):\n+            # if run as a standalone command and file with same filename already exists\n+            if exists(name + \".py\"):\n+                print(\"%s already exists\" % (abspath(name + \".py\")))\n+                return True\n+        else:\n+            try:\n+                spidercls = self.crawler_process.spider_loader.load(name)\n+            except KeyError:\n+                pass\n+            else:\n+                # if spider with same name exists\n+                print(\"Spider %r already exists in module:\" % name)\n+                print(\"  %s\" % spidercls.__module__)\n+                return False",
      "comment": "If you had not made a mistake with the return value here, we would probably have not detected the issue in the test coverage. Now you can improve the test :slightly_smiling_face: ",
      "comment_id": 442162518,
      "user": "Gallaecio",
      "created_at": "2020-06-18T11:39:07Z",
      "url": "https://github.com/scrapy/scrapy/pull/4623#discussion_r442162518"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 4623,
      "file_path": "scrapy/commands/genspider.py",
      "line": 130,
      "side": "RIGHT",
      "diff_hunk": "@@ -135,6 +112,32 @@ def _list_templates(self):\n             if filename.endswith('.tmpl'):\n                 print(\"  %s\" % splitext(filename)[0])\n \n+    def _spider_exists(self, name):\n+        if not self.settings.get('NEWSPIDER_MODULE'):\n+            # if run as a standalone command and file with same filename already exists\n+            if exists(name + \".py\"):\n+                print(\"%s already exists\" % (abspath(name + \".py\")))\n+                return True\n+        else:\n+            try:\n+                spidercls = self.crawler_process.spider_loader.load(name)\n+            except KeyError:\n+                pass\n+            else:\n+                # if spider with same name exists\n+                print(\"Spider %r already exists in module:\" % name)\n+                print(\"  %s\" % spidercls.__module__)\n+                return False",
      "comment": "I think we could check the modification time of the file before and after the command is run to ensure the file wasn't rewritten on top of asserting the output to make the test stronger. What do you think? The `os.path` module in python has a method `os.path.getmtime` to get the modification time, so shouldn't be too overbearing. ",
      "comment_id": 442200022,
      "user": "ajaymittur",
      "created_at": "2020-06-18T12:48:47Z",
      "url": "https://github.com/scrapy/scrapy/pull/4623#discussion_r442200022"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 4623,
      "file_path": "scrapy/commands/genspider.py",
      "line": 130,
      "side": "RIGHT",
      "diff_hunk": "@@ -135,6 +112,32 @@ def _list_templates(self):\n             if filename.endswith('.tmpl'):\n                 print(\"  %s\" % splitext(filename)[0])\n \n+    def _spider_exists(self, name):\n+        if not self.settings.get('NEWSPIDER_MODULE'):\n+            # if run as a standalone command and file with same filename already exists\n+            if exists(name + \".py\"):\n+                print(\"%s already exists\" % (abspath(name + \".py\")))\n+                return True\n+        else:\n+            try:\n+                spidercls = self.crawler_process.spider_loader.load(name)\n+            except KeyError:\n+                pass\n+            else:\n+                # if spider with same name exists\n+                print(\"Spider %r already exists in module:\" % name)\n+                print(\"  %s\" % spidercls.__module__)\n+                return False",
      "comment": "The tests fail as expected now, when the return is changed to `return False` instead of `return True`",
      "comment_id": 442390982,
      "user": "ajaymittur",
      "created_at": "2020-06-18T17:32:14Z",
      "url": "https://github.com/scrapy/scrapy/pull/4623#discussion_r442390982"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 4623,
      "file_path": "scrapy/commands/genspider.py",
      "line": 130,
      "side": "RIGHT",
      "diff_hunk": "@@ -135,6 +112,32 @@ def _list_templates(self):\n             if filename.endswith('.tmpl'):\n                 print(\"  %s\" % splitext(filename)[0])\n \n+    def _spider_exists(self, name):\n+        if not self.settings.get('NEWSPIDER_MODULE'):\n+            # if run as a standalone command and file with same filename already exists\n+            if exists(name + \".py\"):\n+                print(\"%s already exists\" % (abspath(name + \".py\")))\n+                return True\n+        else:\n+            try:\n+                spidercls = self.crawler_process.spider_loader.load(name)\n+            except KeyError:\n+                pass\n+            else:\n+                # if spider with same name exists\n+                print(\"Spider %r already exists in module:\" % name)\n+                print(\"  %s\" % spidercls.__module__)\n+                return False",
      "comment": "@Gallaecio could you please have a look at the code and tell me what you think when possible",
      "comment_id": 442961116,
      "user": "ajaymittur",
      "created_at": "2020-06-19T17:23:05Z",
      "url": "https://github.com/scrapy/scrapy/pull/4623#discussion_r442961116"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 4623,
      "file_path": "scrapy/commands/genspider.py",
      "line": 132,
      "side": "RIGHT",
      "diff_hunk": "@@ -119,6 +112,33 @@ def _list_templates(self):\n             if filename.endswith('.tmpl'):\n                 print(\"  %s\" % splitext(filename)[0])\n \n+    def _spider_exists(self, name):\n+        if not self.settings.get('NEWSPIDER_MODULE'):\n+            # if run as a standalone command and file with same filename already exists\n+            if exists(name + \".py\"):\n+                print(\"%s already exists\" % (abspath(name + \".py\")))\n+                return True\n+            return False\n+\n+        try:\n+            spidercls = self.crawler_process.spider_loader.load(name)\n+        except KeyError:\n+            pass\n+        else:\n+            # if spider with same name exists\n+            print(\"Spider %r already exists in module:\" % name)\n+            print(\"  %s\" % spidercls.__module__)\n+            return True\n+        # if spider same filename exists",
      "comment": "```suggestion\r\n\r\n        # a file with the same name exists in the target directory\r\n```\r\nGrammar police :oncoming_police_car: ",
      "comment_id": 469891506,
      "user": "elacuesta",
      "created_at": "2020-08-13T11:45:42Z",
      "url": "https://github.com/scrapy/scrapy/pull/4623#discussion_r469891506"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 4686,
      "file_path": "scrapy/pipelines/files.py",
      "line": 370,
      "side": "RIGHT",
      "diff_hunk": "@@ -357,6 +360,15 @@ def __init__(self, store_uri, download_func=None, settings=None):\n         if isinstance(settings, dict) or settings is None:\n             settings = Settings(settings)\n \n+        # Check if file_path used by user is deprecated\n+        file_path_sig = signature(self.file_path)\n+        try:\n+            file_path_sig.parameters['item']\n+        except KeyError:\n+            warn('file_path(self, request, response=None, info=None) is deprecated, '\n+                 'please use file_path(self, request, response=None, info=None, item=None)',\n+                 ScrapyDeprecationWarning, stacklevel=2)",
      "comment": ":lipstick: `if 'item' not in file_path_sig.parameters:` would be simpler. ",
      "comment_id": 465258215,
      "user": "Gallaecio",
      "created_at": "2020-08-04T18:49:39Z",
      "url": "https://github.com/scrapy/scrapy/pull/4686#discussion_r465258215"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 4686,
      "file_path": "tests/test_pipeline_files.py",
      "line": 185,
      "side": "RIGHT",
      "diff_hunk": "@@ -174,6 +174,18 @@ def file_path(self, request, response=None, info=None, item=None):\n         request = Request(\"http://example.com\")\n         self.assertEqual(file_path(request, item=item), 'full/path-to-store-file')\n \n+    def test_file_path_backwards_compatibility(self):\n+        \"\"\"\n+        Test file_path method without `item` parameter in its signature\n+        \"\"\"\n+        class CustomFilesPipeline(FilesPipeline):\n+            def file_path(self, request, response=None, info=None):\n+                return 'full/%s' % 'path'\n+\n+        file_path = CustomFilesPipeline.from_settings(Settings({'FILES_STORE': self.tempdir})).file_path",
      "comment": "It would be great to also validate that the warning is issued.",
      "comment_id": 465260528,
      "user": "Gallaecio",
      "created_at": "2020-08-04T18:54:07Z",
      "url": "https://github.com/scrapy/scrapy/pull/4686#discussion_r465260528"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 4686,
      "file_path": "scrapy/pipelines/images.py",
      "line": 65,
      "side": "RIGHT",
      "diff_hunk": "@@ -51,6 +54,15 @@ def __init__(self, store_uri, download_func=None, settings=None):\n         if isinstance(settings, dict) or settings is None:\n             settings = Settings(settings)\n \n+        # Check if file_path used by user is deprecated\n+        file_path_sig = signature(self.file_path)\n+        try:\n+            file_path_sig.parameters['item']\n+        except KeyError:\n+            warn('file_path(self, request, response=None, info=None) is deprecated, '\n+                 'please use file_path(self, request, response=None, info=None, item=None)',\n+                 ScrapyDeprecationWarning, stacklevel=2)\n+",
      "comment": "I would move it to the parent class.\r\n\r\nI\u2019m thinking:\r\n\r\n- It would avoid this duplication.\r\n\r\n- It would allow to set a private class variable (e.g. `_file_path_expects_item = True/False`) which could be used by `_file_path`, to avoid 1 call when `item` is not expected, and to only perform a call without `item` when needed (currently an unrelated `TypeError` in a `file_path` implementation could trigger that call as well).",
      "comment_id": 465263378,
      "user": "Gallaecio",
      "created_at": "2020-08-04T18:59:33Z",
      "url": "https://github.com/scrapy/scrapy/pull/4686#discussion_r465263378"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 4686,
      "file_path": "scrapy/pipelines/images.py",
      "line": 65,
      "side": "RIGHT",
      "diff_hunk": "@@ -51,6 +54,15 @@ def __init__(self, store_uri, download_func=None, settings=None):\n         if isinstance(settings, dict) or settings is None:\n             settings = Settings(settings)\n \n+        # Check if file_path used by user is deprecated\n+        file_path_sig = signature(self.file_path)\n+        try:\n+            file_path_sig.parameters['item']\n+        except KeyError:\n+            warn('file_path(self, request, response=None, info=None) is deprecated, '\n+                 'please use file_path(self, request, response=None, info=None, item=None)',\n+                 ScrapyDeprecationWarning, stacklevel=2)\n+",
      "comment": "I was unsure about doing this in the parent class since it doesn't have any declaration of `file_path` or any usage other than `_file_path`, should I add an empty declaration of `file_path` under \"Overridable Interfaces\" or is it not needed?\r\n\r\nUPD: It looks like I have to add an empty `file_path` interface to the parent class `MediaPipeline` since `test_pipeline_media` will fail the tests otherwise.",
      "comment_id": 465297688,
      "user": "ajaymittur",
      "created_at": "2020-08-04T20:01:42Z",
      "url": "https://github.com/scrapy/scrapy/pull/4686#discussion_r465297688"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 4686,
      "file_path": "scrapy/pipelines/media.py",
      "line": 225,
      "side": "RIGHT",
      "diff_hunk": "@@ -207,3 +219,7 @@ def item_completed(self, results, item, info):\n                         extra={'spider': info.spider}\n                     )\n         return item\n+\n+    def file_path(self, request, response=None, info=None, item=None):\n+        \"\"\"Returns the path where downloaded media should be stored\"\"\"\n+        pass",
      "comment": "Maybe `raise NotImplementedError`, just in case someone tries to use this class directly?",
      "comment_id": 465596777,
      "user": "Gallaecio",
      "created_at": "2020-08-05T09:30:14Z",
      "url": "https://github.com/scrapy/scrapy/pull/4686#discussion_r465596777"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 4686,
      "file_path": "scrapy/pipelines/media.py",
      "line": 225,
      "side": "RIGHT",
      "diff_hunk": "@@ -207,3 +219,7 @@ def item_completed(self, results, item, info):\n                         extra={'spider': info.spider}\n                     )\n         return item\n+\n+    def file_path(self, request, response=None, info=None, item=None):\n+        \"\"\"Returns the path where downloaded media should be stored\"\"\"\n+        pass",
      "comment": "We could do this, but `file_path` or `_file_path` is **not called anywhere** in the `MediaPipeline`, it is only called in its subclasses `ImagesPipeline` and `FilesPipeline` where `file_path` is implemented, so even if a user overrides or uses this class directly `file_path` will not be called. It looks like this class is not meant to be used directly by users according to the [docs](https://docs.scrapy.org/en/latest/topics/media-pipeline.html) and I'm guessing that's why its not implemented here. \r\n\r\nHowever if we raise an exception here, I think we should raise the exception in `media_to_download` and `get_media_requests` as well since they are also not implemented?",
      "comment_id": 465619031,
      "user": "ajaymittur",
      "created_at": "2020-08-05T10:10:17Z",
      "url": "https://github.com/scrapy/scrapy/pull/4686#discussion_r465619031"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 4686,
      "file_path": "scrapy/pipelines/media.py",
      "line": 146,
      "side": "RIGHT",
      "diff_hunk": "@@ -141,9 +140,11 @@ def _compatible(self, func):\n         def wrapper(*args, **kwargs):\n             if self._expects_item[func.__name__]:\n                 return func(*args, **kwargs)\n-            else:\n+            elif 'item' in kwargs:\n                 kwargs.pop('item', None)\n-                return func(*args, **kwargs)\n+            elif is_item(args[-1]):\n+                args = args[:-1]",
      "comment": "I\u2019m not sure about these 2 lines. `is_item` does not return `True` when the input _is_ an item, only when it _may be_ one.\r\n\r\nWhat if we add `item` as a [keyword-only parameter](https://python-3-for-scientists.readthedocs.io/en/latest/python3_advanced.html#keyword-only-arguments) to those methods? Then we only need to worry about `kwargs` again.",
      "comment_id": 467828453,
      "user": "Gallaecio",
      "created_at": "2020-08-10T11:00:10Z",
      "url": "https://github.com/scrapy/scrapy/pull/4686#discussion_r467828453"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 4686,
      "file_path": "scrapy/pipelines/media.py",
      "line": 146,
      "side": "RIGHT",
      "diff_hunk": "@@ -141,9 +140,11 @@ def _compatible(self, func):\n         def wrapper(*args, **kwargs):\n             if self._expects_item[func.__name__]:\n                 return func(*args, **kwargs)\n-            else:\n+            elif 'item' in kwargs:\n                 kwargs.pop('item', None)\n-                return func(*args, **kwargs)\n+            elif is_item(args[-1]):\n+                args = args[:-1]",
      "comment": "Yep we could do that, it would remove the uncertainty around `item` being passed as a positional/keyworded argument and make handling much easier! Thanks for the link. \r\nWill update the docs and warning message as well!",
      "comment_id": 467914699,
      "user": "ajaymittur",
      "created_at": "2020-08-10T13:46:28Z",
      "url": "https://github.com/scrapy/scrapy/pull/4686#discussion_r467914699"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 4686,
      "file_path": "scrapy/pipelines/media.py",
      "line": 134,
      "side": "RIGHT",
      "diff_hunk": "@@ -102,34 +109,74 @@ def _process_request(self, request, info):\n \n         # Download request checking media_to_download hook output first\n         info.downloading.add(fp)\n-        dfd = mustbe_deferred(self.media_to_download, request, info)\n-        dfd.addCallback(self._check_media_to_download, request, info)\n+        dfd = mustbe_deferred(self.media_to_download, request, info, item=item)\n+        dfd.addCallback(self._check_media_to_download, request, info, item=item)\n         dfd.addBoth(self._cache_result_and_execute_waiters, fp, info)\n         dfd.addErrback(lambda f: logger.error(\n             f.value, exc_info=failure_to_exc_info(f), extra={'spider': info.spider})\n         )\n         return dfd.addBoth(lambda _: wad)  # it must return wad at last\n \n+    def _make_compatible(self):\n+        \"\"\"Make overridable methods of MediaPipeline and subclasses backwards compatible\"\"\"\n+        methods = [\n+            \"file_path\", \"media_to_download\", \"media_downloaded\",\n+            \"file_downloaded\", \"image_downloaded\", \"get_images\"\n+        ]\n+\n+        for method_name in methods:\n+            method = getattr(self, method_name, None)\n+            if callable(method):\n+                setattr(self, method_name, self._compatible(method))\n+\n+    def _compatible(self, func):\n+        \"\"\"Wrapper for overridable methods to allow backwards compatibility\"\"\"\n+        if func.__name__ not in self._expects_item:",
      "comment": ":lipstick: Looking at the coverage data, it looks like this `if` statement always evaluates to `True`, which seems right looking at the implementation method above. So maybe you can remove it.",
      "comment_id": 468398539,
      "user": "Gallaecio",
      "created_at": "2020-08-11T08:02:57Z",
      "url": "https://github.com/scrapy/scrapy/pull/4686#discussion_r468398539"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 4686,
      "file_path": "scrapy/pipelines/media.py",
      "line": 7,
      "side": "RIGHT",
      "diff_hunk": "@@ -1,12 +1,15 @@\n import functools\n+from inspect import signature\n import logging\n from collections import defaultdict\n from twisted.internet.defer import Deferred, DeferredList\n from twisted.python.failure import Failure\n+from warnings import warn",
      "comment": "I think this import should be before the Twisted ones? @Gallaecio you are the expert on this :)",
      "comment_id": 468477136,
      "user": "wRAR",
      "created_at": "2020-08-11T10:21:11Z",
      "url": "https://github.com/scrapy/scrapy/pull/4686#discussion_r468477136"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 4686,
      "file_path": "scrapy/pipelines/media.py",
      "line": 134,
      "side": "RIGHT",
      "diff_hunk": "@@ -102,34 +109,74 @@ def _process_request(self, request, info):\n \n         # Download request checking media_to_download hook output first\n         info.downloading.add(fp)\n-        dfd = mustbe_deferred(self.media_to_download, request, info)\n-        dfd.addCallback(self._check_media_to_download, request, info)\n+        dfd = mustbe_deferred(self.media_to_download, request, info, item=item)\n+        dfd.addCallback(self._check_media_to_download, request, info, item=item)\n         dfd.addBoth(self._cache_result_and_execute_waiters, fp, info)\n         dfd.addErrback(lambda f: logger.error(\n             f.value, exc_info=failure_to_exc_info(f), extra={'spider': info.spider})\n         )\n         return dfd.addBoth(lambda _: wad)  # it must return wad at last\n \n+    def _make_compatible(self):\n+        \"\"\"Make overridable methods of MediaPipeline and subclasses backwards compatible\"\"\"\n+        methods = [\n+            \"file_path\", \"media_to_download\", \"media_downloaded\",\n+            \"file_downloaded\", \"image_downloaded\", \"get_images\"\n+        ]\n+\n+        for method_name in methods:\n+            method = getattr(self, method_name, None)\n+            if callable(method):\n+                setattr(self, method_name, self._compatible(method))\n+\n+    def _compatible(self, func):\n+        \"\"\"Wrapper for overridable methods to allow backwards compatibility\"\"\"\n+        if func.__name__ not in self._expects_item:",
      "comment": "Yep you're right, I think I had added it initially as I had expected to call `_compatible` multiple times, but clearly that wasn't needed.",
      "comment_id": 468482697,
      "user": "ajaymittur",
      "created_at": "2020-08-11T10:31:52Z",
      "url": "https://github.com/scrapy/scrapy/pull/4686#discussion_r468482697"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 4686,
      "file_path": "scrapy/pipelines/media.py",
      "line": 7,
      "side": "RIGHT",
      "diff_hunk": "@@ -1,12 +1,15 @@\n import functools\n+from inspect import signature\n import logging\n from collections import defaultdict\n from twisted.internet.defer import Deferred, DeferredList\n from twisted.python.failure import Failure\n+from warnings import warn",
      "comment": "Hmm, I think it does! Maybe I could also add an empty line between standard library imports and Twisted imports as specified in the [PEP8 guidelines](https://www.python.org/dev/peps/pep-0008/#:~:text=You%20should%20put%20a%20blank%20line%20between%20each%20group%20of%20imports.&text=Standard%20library%20code%20should%20avoid,been%20removed%20in%20Python%203.)?. What say @Gallaecio?",
      "comment_id": 468487981,
      "user": "ajaymittur",
      "created_at": "2020-08-11T10:42:22Z",
      "url": "https://github.com/scrapy/scrapy/pull/4686#discussion_r468487981"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 4686,
      "file_path": "scrapy/pipelines/media.py",
      "line": 7,
      "side": "RIGHT",
      "diff_hunk": "@@ -1,12 +1,15 @@\n import functools\n+from inspect import signature\n import logging\n from collections import defaultdict\n from twisted.internet.defer import Deferred, DeferredList\n from twisted.python.failure import Failure\n+from warnings import warn",
      "comment": "And `inspect` should be among other standard library `from` imports (`right after `from collections \u2026`), we group those right after straight imports (without an empty line, though).",
      "comment_id": 468498776,
      "user": "Gallaecio",
      "created_at": "2020-08-11T11:03:57Z",
      "url": "https://github.com/scrapy/scrapy/pull/4686#discussion_r468498776"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 4564,
      "file_path": "scrapy/settings/__init__.py",
      "line": 86,
      "side": "RIGHT",
      "diff_hunk": "@@ -83,7 +83,8 @@ class BaseSettings(MutableMapping):\n     def __init__(self, values=None, priority='project'):\n         self.frozen = False\n         self.attributes = {}\n-        self.update(values, priority)\n+        if values is not None:",
      "comment": "Nice catch.\r\n\r\nSince we are at it, maybe it would make sense to just use `if values:`. I imagine empty settings do not require `self.update` either.",
      "comment_id": 423267568,
      "user": "Gallaecio",
      "created_at": "2020-05-11T19:27:15Z",
      "url": "https://github.com/scrapy/scrapy/pull/4564#discussion_r423267568"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 4564,
      "file_path": "scrapy/settings/__init__.py",
      "line": 86,
      "side": "RIGHT",
      "diff_hunk": "@@ -83,7 +83,8 @@ class BaseSettings(MutableMapping):\n     def __init__(self, values=None, priority='project'):\n         self.frozen = False\n         self.attributes = {}\n-        self.update(values, priority)\n+        if values is not None:",
      "comment": "> Nice catch.\r\n> \r\n> Since we are at it, maybe it would make sense to just use `if values:`. I imagine empty settings do not require `self.update` either.\r\n\r\nAgree. ",
      "comment_id": 423447671,
      "user": "jacty",
      "created_at": "2020-05-12T03:58:21Z",
      "url": "https://github.com/scrapy/scrapy/pull/4564#discussion_r423447671"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 4701,
      "file_path": "scrapy/utils/python.py",
      "line": 278,
      "side": "RIGHT",
      "diff_hunk": "@@ -273,6 +275,7 @@ def equal_attributes(obj1, obj2, attributes):\n     return True\n \n \n+@deprecated",
      "comment": "I don't think it works on classes? Have you tried to instantiate it?",
      "comment_id": 462933537,
      "user": "wRAR",
      "created_at": "2020-07-30T11:33:21Z",
      "url": "https://github.com/scrapy/scrapy/pull/4701#discussion_r462933537"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 4701,
      "file_path": "scrapy/utils/python.py",
      "line": 278,
      "side": "RIGHT",
      "diff_hunk": "@@ -273,6 +275,7 @@ def equal_attributes(obj1, obj2, attributes):\n     return True\n \n \n+@deprecated",
      "comment": "@wRAR  Yep, this is working with classes as inherently we are calling the `__init_`_ function .\r\n\r\nI tested it out and it gave me the following warning : \r\n\r\nUserWarning: Call to deprecated function WeakKeyCache. Use The following API is deprecated Use instead.",
      "comment_id": 462953074,
      "user": "kshitijcode",
      "created_at": "2020-07-30T12:15:07Z",
      "url": "https://github.com/scrapy/scrapy/pull/4701#discussion_r462953074"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 4701,
      "file_path": "scrapy/utils/python.py",
      "line": 278,
      "side": "RIGHT",
      "diff_hunk": "@@ -273,6 +275,7 @@ def equal_attributes(obj1, obj2, attributes):\n     return True\n \n \n+@deprecated",
      "comment": "Well, the message is inaccurate, \u201cdeprecated function WeakKeyCache\u201d. We need to either make `@deprecated` smart enough to say \u2018class\u2019 when needed, or use a different approach. We\u2019ve been using the latter so far, I\u2019m not sure if there are potential unexpected side effects of using `@deprecated` after changing it to say \u201cclass\u201d for classes. ",
      "comment_id": 463949440,
      "user": "Gallaecio",
      "created_at": "2020-08-01T10:41:15Z",
      "url": "https://github.com/scrapy/scrapy/pull/4701#discussion_r463949440"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 4701,
      "file_path": "scrapy/utils/python.py",
      "line": 278,
      "side": "RIGHT",
      "diff_hunk": "@@ -273,6 +275,7 @@ def equal_attributes(obj1, obj2, attributes):\n     return True\n \n \n+@deprecated",
      "comment": "@Gallaecio @wRAR  What is the latter approach which has been used so far?\r\n\r\nAlso which is the existing test function?",
      "comment_id": 463953229,
      "user": "kshitijcode",
      "created_at": "2020-08-01T11:29:47Z",
      "url": "https://github.com/scrapy/scrapy/pull/4701#discussion_r463953229"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 4701,
      "file_path": "scrapy/utils/python.py",
      "line": 278,
      "side": "RIGHT",
      "diff_hunk": "@@ -273,6 +275,7 @@ def equal_attributes(obj1, obj2, attributes):\n     return True\n \n \n+@deprecated",
      "comment": "> @Gallaecio @wRAR What is the latter approach which has been used so far?\r\n\r\nLogging a warning manually in the `__init__` method, with `ScrapyDeprecationWarning` as warning class, and `stacklevel=2` (so that the warning is about the call to `__init__`, and not about the implementation line where we log the warning).\r\n\r\n> Also which is the existing test function?\r\n\r\nI did not get this, sorry. Could you elaborate?",
      "comment_id": 465277067,
      "user": "Gallaecio",
      "created_at": "2020-08-04T19:25:24Z",
      "url": "https://github.com/scrapy/scrapy/pull/4701#discussion_r465277067"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 4701,
      "file_path": "scrapy/utils/python.py",
      "line": 10,
      "side": "RIGHT",
      "diff_hunk": "@@ -7,10 +7,12 @@\n import re\n import sys\n import weakref\n+import warnings",
      "comment": ":lipstick: \r\n\r\n```suggestion\r\nimport warnings\r\nimport weakref\r\n```",
      "comment_id": 465621679,
      "user": "Gallaecio",
      "created_at": "2020-08-05T10:15:33Z",
      "url": "https://github.com/scrapy/scrapy/pull/4701#discussion_r465621679"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 4701,
      "file_path": "scrapy/utils/python.py",
      "line": 15,
      "side": "RIGHT",
      "diff_hunk": "@@ -7,10 +7,12 @@\n import re\n import sys\n import weakref\n+import warnings\n from functools import partial, wraps\n from itertools import chain\n \n from scrapy.utils.decorators import deprecated\n+from scrapy.exceptions import ScrapyDeprecationWarning",
      "comment": ":lipstick: \r\n\r\n```suggestion\r\nfrom scrapy.exceptions import ScrapyDeprecationWarning\r\nfrom scrapy.utils.decorators import deprecated\r\n```",
      "comment_id": 465621812,
      "user": "Gallaecio",
      "created_at": "2020-08-05T10:15:51Z",
      "url": "https://github.com/scrapy/scrapy/pull/4701#discussion_r465621812"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 4701,
      "file_path": "scrapy/utils/python.py",
      "line": 283,
      "side": "RIGHT",
      "diff_hunk": "@@ -276,6 +280,7 @@ def equal_attributes(obj1, obj2, attributes):\n class WeakKeyCache:\n \n     def __init__(self, default_factory):\n+        warnings.warn(\"Call to deprecated Class WeakKeyCache\", category=ScrapyDeprecationWarning, stacklevel=2)",
      "comment": "\u201cCall\u201d feels weird to me when talking about classes, and \u201cclass\u201d should be lowercase.\r\n\r\n:lipstick: What about\u2026\r\n\r\n```suggestion\r\n        warnings.warn(\"The WeakKeyCache class is deprecated\",\r\n                      category=ScrapyDeprecationWarning, stacklevel=2)\r\n```",
      "comment_id": 465623066,
      "user": "Gallaecio",
      "created_at": "2020-08-05T10:18:14Z",
      "url": "https://github.com/scrapy/scrapy/pull/4701#discussion_r465623066"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 4707,
      "file_path": "tests/test_downloadermiddleware_httpcache.py",
      "line": 154,
      "side": "RIGHT",
      "diff_hunk": "@@ -151,7 +151,7 @@ class FilesystemStorageGzipTest(FilesystemStorageTest):\n \n     def _get_settings(self, **new_settings):\n         new_settings.setdefault('HTTPCACHE_GZIP', True)\n-        return super(FilesystemStorageTest, self)._get_settings(**new_settings)\n+        return super()._get_settings(**new_settings)",
      "comment": "As you can see, originally, this `super()` was referring to the `FilesystemStorageTest` superclass instead of `FilesystemStorageGzipTest`, but it's the same (`FilesystemStorageTest` doesn't implement its own `._get_settings()` method) so I decided to keep it as simply `super()`.",
      "comment_id": 463094231,
      "user": "noviluni",
      "created_at": "2020-07-30T15:47:03Z",
      "url": "https://github.com/scrapy/scrapy/pull/4707#discussion_r463094231"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 4403,
      "file_path": "scrapy/utils/display.py",
      "line": 22,
      "side": "RIGHT",
      "diff_hunk": "@@ -3,24 +3,55 @@\n \"\"\"\n \n import sys\n+import platform\n from pprint import pformat as pformat_\n \n \n def _colorize(text, colorize=True):\n     if not colorize or not sys.stdout.isatty():\n         return text\n     try:\n+        import pygments.util\n+        from pygments.formatters import get_formatter_by_name\n         from pygments import highlight\n-        from pygments.formatters import TerminalFormatter\n         from pygments.lexers import PythonLexer\n-        return highlight(text, PythonLexer(), TerminalFormatter())\n     except ImportError:\n         return text\n \n+    if sys.platform == \"win32\" and platform.release() == \"10\":\n+        if platform.version() >= \"10.0.14393\":",
      "comment": "- Shouldn\u2019t this be a single `if` statement?\r\n- Is `platform.release() == \"10\"` needed, given `platform.version() >= \"10.0.14393\"`?\r\n- Isn\u2019t using `>=` for string comparison problematic here?\r\n- I don\u2019t think it is obvious from the code why `10.0.14393` is hardcoded there. Maybe we need a comment explaining it?",
      "comment_id": 398813078,
      "user": "Gallaecio",
      "created_at": "2020-03-26T18:50:35Z",
      "url": "https://github.com/scrapy/scrapy/pull/4403#discussion_r398813078"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 4403,
      "file_path": "scrapy/utils/display.py",
      "line": 22,
      "side": "RIGHT",
      "diff_hunk": "@@ -3,24 +3,55 @@\n \"\"\"\n \n import sys\n+import platform\n from pprint import pformat as pformat_\n \n \n def _colorize(text, colorize=True):\n     if not colorize or not sys.stdout.isatty():\n         return text\n     try:\n+        import pygments.util\n+        from pygments.formatters import get_formatter_by_name\n         from pygments import highlight\n-        from pygments.formatters import TerminalFormatter\n         from pygments.lexers import PythonLexer\n-        return highlight(text, PythonLexer(), TerminalFormatter())\n     except ImportError:\n         return text\n \n+    if sys.platform == \"win32\" and platform.release() == \"10\":\n+        if platform.version() >= \"10.0.14393\":",
      "comment": "> * Shouldn\u2019t this be a single `if` statement?\r\n> \r\n> * Is `platform.release() == \"10\"` needed, given `platform.version() >= \"10.0.14393\"`?\r\n\r\nyes, it should be single `if` statement and there is no need for `platform.release( ) == \"10\"`\r\n\r\n>     * Isn\u2019t using `>=` for string comparison problematic here? \r\nIt is problematic. So, now I have used `packaging.version.parse()` for version comparison.\r\n\r\n\r\n",
      "comment_id": 399152224,
      "user": "akshaysharmajs",
      "created_at": "2020-03-27T09:59:14Z",
      "url": "https://github.com/scrapy/scrapy/pull/4403#discussion_r399152224"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 4403,
      "file_path": "scrapy/utils/display.py",
      "line": 7,
      "side": "RIGHT",
      "diff_hunk": "@@ -3,24 +3,62 @@\n \"\"\"\n \n import sys\n+from platform import version\n+from packaging.version import parse",
      "comment": ":lipstick: A-Z\r\n```suggestion\r\nfrom packaging.version import parse\r\nfrom platform import version\r\n```",
      "comment_id": 399683893,
      "user": "Gallaecio",
      "created_at": "2020-03-28T16:53:29Z",
      "url": "https://github.com/scrapy/scrapy/pull/4403#discussion_r399683893"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 4403,
      "file_path": "scrapy/utils/display.py",
      "line": 28,
      "side": "RIGHT",
      "diff_hunk": "@@ -3,24 +3,62 @@\n \"\"\"\n \n import sys\n+from platform import version\n+from packaging.version import parse\n from pprint import pformat as pformat_\n \n \n def _colorize(text, colorize=True):\n     if not colorize or not sys.stdout.isatty():\n         return text\n     try:\n+        import pygments.util\n+        from pygments.formatters import get_formatter_by_name\n         from pygments import highlight\n-        from pygments.formatters import TerminalFormatter\n         from pygments.lexers import PythonLexer\n-        return highlight(text, PythonLexer(), TerminalFormatter())\n     except ImportError:\n         return text\n \n+    \"\"\"\n+    All Windows versions >= \"10.0.14393\" interpret ANSI escape sequences\n+    using terminal processing.\n+\n+    Enable enivornment variable `ENABLE_VIRTUAL_TERMINAL_PROCESSING`\n+    to activate terminal processing.\n+    \"\"\"",
      "comment": ":lipstick: Docstrings are not meant to be used in the middle of a function implementation.\r\n\r\n```suggestion\r\n    # All Windows versions >= \"10.0.14393\" interpret ANSI escape sequences\r\n    # using terminal processing.\r\n    #\r\n    # Enable enivornment variable `ENABLE_VIRTUAL_TERMINAL_PROCESSING`\r\n    # to activate terminal processing.\r\n```",
      "comment_id": 399684091,
      "user": "Gallaecio",
      "created_at": "2020-03-28T16:55:00Z",
      "url": "https://github.com/scrapy/scrapy/pull/4403#discussion_r399684091"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 4403,
      "file_path": "scrapy/utils/display.py",
      "line": 39,
      "side": "RIGHT",
      "diff_hunk": "@@ -3,24 +3,62 @@\n \"\"\"\n \n import sys\n+from platform import version\n+from packaging.version import parse\n from pprint import pformat as pformat_\n \n \n def _colorize(text, colorize=True):\n     if not colorize or not sys.stdout.isatty():\n         return text\n     try:\n+        import pygments.util\n+        from pygments.formatters import get_formatter_by_name\n         from pygments import highlight\n-        from pygments.formatters import TerminalFormatter\n         from pygments.lexers import PythonLexer\n-        return highlight(text, PythonLexer(), TerminalFormatter())\n     except ImportError:\n         return text\n \n+    \"\"\"\n+    All Windows versions >= \"10.0.14393\" interpret ANSI escape sequences\n+    using terminal processing.\n+\n+    Enable enivornment variable `ENABLE_VIRTUAL_TERMINAL_PROCESSING`\n+    to activate terminal processing.\n+    \"\"\"\n+    if sys.platform == \"win32\" and parse(version()) >= parse(\"10.0.14393\"):\n+        import ctypes\n+        kernel32 = ctypes.windll.kernel32\n+        kernel32.SetConsoleMode(kernel32.GetStdHandle(-11), 7)\n+        # set `ENABLE_VIRTUAL_TERMINAL_PROCESSING` flag\n+    colors = color_support_info()\n+    if colors == 256:\n+        format_options = {'style': 'default'}\n+    else:\n+        format_options = {'bg': 'dark'}\n+    format_alias = 'terminal256' if colors == 256 else 'terminal'",
      "comment": ":lipstick:\r\n```suggestion\r\n    if color_support_info() == 256:\r\n        format_alias = 'terminal256'\r\n        format_options = {'style': 'default'}\r\n    else:\r\n        format_alias = 'terminal'\r\n        format_options = {'bg': 'dark'}\r\n```",
      "comment_id": 399684264,
      "user": "Gallaecio",
      "created_at": "2020-03-28T16:56:39Z",
      "url": "https://github.com/scrapy/scrapy/pull/4403#discussion_r399684264"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 4403,
      "file_path": "scrapy/utils/display.py",
      "line": 57,
      "side": "RIGHT",
      "diff_hunk": "@@ -3,24 +3,62 @@\n \"\"\"\n \n import sys\n+from platform import version\n+from packaging.version import parse\n from pprint import pformat as pformat_\n \n \n def _colorize(text, colorize=True):\n     if not colorize or not sys.stdout.isatty():\n         return text\n     try:\n+        import pygments.util\n+        from pygments.formatters import get_formatter_by_name\n         from pygments import highlight\n-        from pygments.formatters import TerminalFormatter\n         from pygments.lexers import PythonLexer\n-        return highlight(text, PythonLexer(), TerminalFormatter())\n     except ImportError:\n         return text\n \n+    \"\"\"\n+    All Windows versions >= \"10.0.14393\" interpret ANSI escape sequences\n+    using terminal processing.\n+\n+    Enable enivornment variable `ENABLE_VIRTUAL_TERMINAL_PROCESSING`\n+    to activate terminal processing.\n+    \"\"\"\n+    if sys.platform == \"win32\" and parse(version()) >= parse(\"10.0.14393\"):\n+        import ctypes\n+        kernel32 = ctypes.windll.kernel32\n+        kernel32.SetConsoleMode(kernel32.GetStdHandle(-11), 7)\n+        # set `ENABLE_VIRTUAL_TERMINAL_PROCESSING` flag\n+    colors = color_support_info()\n+    if colors == 256:\n+        format_options = {'style': 'default'}\n+    else:\n+        format_options = {'bg': 'dark'}\n+    format_alias = 'terminal256' if colors == 256 else 'terminal'\n+    try:\n+        formatter = get_formatter_by_name(format_alias, **format_options)\n+    except pygments.util.ClassNotFound as err:\n+        sys.stderr.write(str(err) + \"\\n\")\n+        formatter = get_formatter_by_name(format_alias)\n+\n+    return highlight(text, PythonLexer(), formatter)\n+\n \n def pformat(obj, *args, **kwargs):\n     return _colorize(pformat_(obj), kwargs.pop('colorize', True))\n \n \n def pprint(obj, *args, **kwargs):\n     print(pformat(obj, *args, **kwargs))\n+\n+\n+def color_support_info():",
      "comment": "```suggestion\r\ndef _color_support_info():\r\n```\r\n\r\nAnd maybe we should move it right before the function that uses it, above.",
      "comment_id": 399684364,
      "user": "Gallaecio",
      "created_at": "2020-03-28T16:57:41Z",
      "url": "https://github.com/scrapy/scrapy/pull/4403#discussion_r399684364"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 4403,
      "file_path": "scrapy/utils/display.py",
      "line": 6,
      "side": "RIGHT",
      "diff_hunk": "@@ -3,20 +3,56 @@\n \"\"\"\n \n import sys\n+from packaging.version import parse",
      "comment": "no, it is a third party utility used by setuptools.",
      "comment_id": 400330614,
      "user": "akshaysharmajs",
      "created_at": "2020-03-30T16:32:47Z",
      "url": "https://github.com/scrapy/scrapy/pull/4403#discussion_r400330614"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 4403,
      "file_path": "scrapy/utils/display.py",
      "line": 30,
      "side": "RIGHT",
      "diff_hunk": "@@ -3,20 +3,56 @@\n \"\"\"\n \n import sys\n+from packaging.version import parse\n+from platform import version\n from pprint import pformat as pformat_\n \n \n def _colorize(text, colorize=True):\n     if not colorize or not sys.stdout.isatty():\n         return text\n     try:\n+        import pygments.util\n+        from pygments.formatters import get_formatter_by_name\n         from pygments import highlight\n-        from pygments.formatters import TerminalFormatter\n         from pygments.lexers import PythonLexer\n-        return highlight(text, PythonLexer(), TerminalFormatter())\n     except ImportError:\n         return text\n \n+    # All Windows versions >= \"10.0.14393\" interpret ANSI escape sequences\n+    # using terminal processing.\n+    #\n+    # Enable enivornment variable `ENABLE_VIRTUAL_TERMINAL_PROCESSING`\n+    # to activate terminal processing.\n+    if sys.platform == \"win32\" and parse(version()) >= parse(\"10.0.14393\"):\n+        import ctypes\n+        kernel32 = ctypes.windll.kernel32\n+        kernel32.SetConsoleMode(kernel32.GetStdHandle(-11), 7)",
      "comment": "@wRAR @Gallaecio I have added some error handling there. Please check if its correct.",
      "comment_id": 400333503,
      "user": "akshaysharmajs",
      "created_at": "2020-03-30T16:37:08Z",
      "url": "https://github.com/scrapy/scrapy/pull/4403#discussion_r400333503"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 4403,
      "file_path": "scrapy/utils/display.py",
      "line": 6,
      "side": "RIGHT",
      "diff_hunk": "@@ -3,20 +3,56 @@\n \"\"\"\n \n import sys\n+from packaging.version import parse",
      "comment": "I think we can use `distutils.version.LooseVersion()` or `distutils.version.StrictVersion()` for it but most users must have installed setuptools. ",
      "comment_id": 402109397,
      "user": "akshaysharmajs",
      "created_at": "2020-04-02T07:36:54Z",
      "url": "https://github.com/scrapy/scrapy/pull/4403#discussion_r402109397"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 4403,
      "file_path": "scrapy/utils/display.py",
      "line": 38,
      "side": "RIGHT",
      "diff_hunk": "@@ -3,20 +3,63 @@\n \"\"\"\n \n import sys\n+from packaging.version import parse\n+from platform import version\n from pprint import pformat as pformat_\n \n \n def _colorize(text, colorize=True):\n     if not colorize or not sys.stdout.isatty():\n         return text\n     try:\n+        import pygments.util\n+        from pygments.formatters import get_formatter_by_name\n         from pygments import highlight\n-        from pygments.formatters import TerminalFormatter\n         from pygments.lexers import PythonLexer\n-        return highlight(text, PythonLexer(), TerminalFormatter())\n     except ImportError:\n         return text\n \n+    # All Windows versions >= \"10.0.14393\" interpret ANSI escape sequences\n+    # using terminal processing.\n+    #\n+    # Enable enivornment variable `ENABLE_VIRTUAL_TERMINAL_PROCESSING`\n+    # to activate terminal processing.\n+    if sys.platform == \"win32\" and parse(version()) >= parse(\"10.0.14393\"):\n+        try:\n+            import ctypes\n+            from ctypes import FormatError\n+            kernel32 = ctypes.windll.kernel32\n+            handle = kernel32.GetStdHandle(-11)\n+            # set `ENABLE_VIRTUAL_TERMINAL_PROCESSING` flag\n+            if not kernel32.SetConsoleMode(handle, 7):\n+                raise ValueError\n+        except ValueError:\n+            sys.stderr.write(FormatError(kernel32.GetLastError()))\n+            return text",
      "comment": "I am not sure if there is need of error message `sys.stderr.write(FormatError(kernel32.GetLastError()))`, Maybe we can just return the plain text without the error message. \r\n@wRAR please guide me here",
      "comment_id": 402111014,
      "user": "akshaysharmajs",
      "created_at": "2020-04-02T07:40:01Z",
      "url": "https://github.com/scrapy/scrapy/pull/4403#discussion_r402111014"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 4403,
      "file_path": "scrapy/utils/display.py",
      "line": 6,
      "side": "RIGHT",
      "diff_hunk": "@@ -3,20 +3,56 @@\n \"\"\"\n \n import sys\n+from packaging.version import parse",
      "comment": "@Gallaecio Does scrapy install ``setuptools`` package with other reqirements during installation?",
      "comment_id": 409129545,
      "user": "akshaysharmajs",
      "created_at": "2020-04-15T20:57:46Z",
      "url": "https://github.com/scrapy/scrapy/pull/4403#discussion_r409129545"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 4403,
      "file_path": "scrapy/utils/display.py",
      "line": 6,
      "side": "RIGHT",
      "diff_hunk": "@@ -3,20 +3,56 @@\n \"\"\"\n \n import sys\n+from packaging.version import parse",
      "comment": "I don\u2019t think so, you can check in `setup.py`. However, can\u2019t we just [use a built-in alternative](https://stackoverflow.com/a/11887885/939364)?",
      "comment_id": 409704848,
      "user": "Gallaecio",
      "created_at": "2020-04-16T16:51:16Z",
      "url": "https://github.com/scrapy/scrapy/pull/4403#discussion_r409704848"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 4403,
      "file_path": "scrapy/utils/display.py",
      "line": 6,
      "side": "RIGHT",
      "diff_hunk": "@@ -3,20 +3,56 @@\n \"\"\"\n \n import sys\n+from packaging.version import parse",
      "comment": "Thanks for the suggestion. I have changed version comparison with inbuilt function `distutils.version.LooseVersion()`.",
      "comment_id": 409810701,
      "user": "akshaysharmajs",
      "created_at": "2020-04-16T19:53:08Z",
      "url": "https://github.com/scrapy/scrapy/pull/4403#discussion_r409810701"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 4403,
      "file_path": "scrapy/utils/display.py",
      "line": 38,
      "side": "RIGHT",
      "diff_hunk": "@@ -3,20 +3,63 @@\n \"\"\"\n \n import sys\n+from packaging.version import parse\n+from platform import version\n from pprint import pformat as pformat_\n \n \n def _colorize(text, colorize=True):\n     if not colorize or not sys.stdout.isatty():\n         return text\n     try:\n+        import pygments.util\n+        from pygments.formatters import get_formatter_by_name\n         from pygments import highlight\n-        from pygments.formatters import TerminalFormatter\n         from pygments.lexers import PythonLexer\n-        return highlight(text, PythonLexer(), TerminalFormatter())\n     except ImportError:\n         return text\n \n+    # All Windows versions >= \"10.0.14393\" interpret ANSI escape sequences\n+    # using terminal processing.\n+    #\n+    # Enable enivornment variable `ENABLE_VIRTUAL_TERMINAL_PROCESSING`\n+    # to activate terminal processing.\n+    if sys.platform == \"win32\" and parse(version()) >= parse(\"10.0.14393\"):\n+        try:\n+            import ctypes\n+            from ctypes import FormatError\n+            kernel32 = ctypes.windll.kernel32\n+            handle = kernel32.GetStdHandle(-11)\n+            # set `ENABLE_VIRTUAL_TERMINAL_PROCESSING` flag\n+            if not kernel32.SetConsoleMode(handle, 7):\n+                raise ValueError\n+        except ValueError:\n+            sys.stderr.write(FormatError(kernel32.GetLastError()))\n+            return text",
      "comment": "@Gallaecio Can you please tell me if we need error message `sys.stderr.write(FormatError(kernel32.GetLastError()))` as the text \"The handle is invalid\" doesn't look aesthetically good(like in below screenshot)\r\n\r\n![1](https://user-images.githubusercontent.com/42249933/79500709-81b0bc00-804a-11ea-8f47-30c58ade78d0.PNG)\r\n)\r\nI think we should just return the plain text when exception is raised.",
      "comment_id": 409814315,
      "user": "akshaysharmajs",
      "created_at": "2020-04-16T20:00:05Z",
      "url": "https://github.com/scrapy/scrapy/pull/4403#discussion_r409814315"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 4403,
      "file_path": "scrapy/utils/display.py",
      "line": 6,
      "side": "RIGHT",
      "diff_hunk": "@@ -3,20 +3,61 @@\n \"\"\"\n \n import sys\n+from distutils.version import LooseVersion as check",
      "comment": "`check` seems rather ambiguous, maybe `parse_version` or similar?",
      "comment_id": 415846477,
      "user": "Gallaecio",
      "created_at": "2020-04-27T14:11:31Z",
      "url": "https://github.com/scrapy/scrapy/pull/4403#discussion_r415846477"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 4403,
      "file_path": "scrapy/utils/display.py",
      "line": 6,
      "side": "RIGHT",
      "diff_hunk": "@@ -3,20 +3,61 @@\n \"\"\"\n \n import sys\n+from distutils.version import LooseVersion as check",
      "comment": "@Gallaecio \ud83d\ude04You re' right.\r\nbut to use `parse_version`, I have to use two `if` statements(like below) as single `if` statement is failing one flake test of crossing 79 characters limit in a single line.\r\n```\r\n    if sys.platform == \"win32\":\r\n        if parse_version(version()) >= parse_version(\"10.0.14393\"):\r\n```\r\n",
      "comment_id": 416903778,
      "user": "akshaysharmajs",
      "created_at": "2020-04-28T20:32:51Z",
      "url": "https://github.com/scrapy/scrapy/pull/4403#discussion_r416903778"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 4403,
      "file_path": "scrapy/utils/display.py",
      "line": 6,
      "side": "RIGHT",
      "diff_hunk": "@@ -3,20 +3,61 @@\n \"\"\"\n \n import sys\n+from distutils.version import LooseVersion as check",
      "comment": "We are not currently enforcing the 79-chars limit. In fact, we're working towards a higher limit (#4237). For the time being, please add this file to `pytest.ini` with the code `E501`.",
      "comment_id": 417026510,
      "user": "elacuesta",
      "created_at": "2020-04-29T01:58:42Z",
      "url": "https://github.com/scrapy/scrapy/pull/4403#discussion_r417026510"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 4403,
      "file_path": "scrapy/utils/display.py",
      "line": 6,
      "side": "RIGHT",
      "diff_hunk": "@@ -3,20 +3,61 @@\n \"\"\"\n \n import sys\n+from distutils.version import LooseVersion as check",
      "comment": "Alright! single `if` statement will be good then.\r\n@elacuesta thanks for the info : )",
      "comment_id": 417140382,
      "user": "akshaysharmajs",
      "created_at": "2020-04-29T08:12:46Z",
      "url": "https://github.com/scrapy/scrapy/pull/4403#discussion_r417140382"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 4403,
      "file_path": "scrapy/utils/display.py",
      "line": 6,
      "side": "RIGHT",
      "diff_hunk": "@@ -3,20 +3,61 @@\n \"\"\"\n \n import sys\n+from distutils.version import LooseVersion as check",
      "comment": ">  For the time being, please add this file to `pytest.ini` with the code `E501`.\r\n\r\n Done \ud83d\udc4d \r\n",
      "comment_id": 417148229,
      "user": "akshaysharmajs",
      "created_at": "2020-04-29T08:27:34Z",
      "url": "https://github.com/scrapy/scrapy/pull/4403#discussion_r417148229"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 4403,
      "file_path": "scrapy/utils/display.py",
      "line": 35,
      "side": "RIGHT",
      "diff_hunk": "@@ -3,20 +3,60 @@\n \"\"\"\n \n import sys\n+from distutils.version import LooseVersion as parse_version\n+from platform import version\n from pprint import pformat as pformat_\n \n \n def _colorize(text, colorize=True):\n     if not colorize or not sys.stdout.isatty():\n         return text\n     try:\n-        from pygments import highlight\n         from pygments.formatters import TerminalFormatter\n+        from pygments import highlight\n         from pygments.lexers import PythonLexer\n-        return highlight(text, PythonLexer(), TerminalFormatter())\n     except ImportError:\n         return text\n \n+    # All Windows versions >= \"10.0.14393\" interpret ANSI escape sequences\n+    # using terminal processing.\n+    #\n+    # Enable enivornment variable `ENABLE_VIRTUAL_TERMINAL_PROCESSING`\n+    # to activate terminal processing.\n+    if sys.platform == \"win32\" and parse_version(version()) >= parse_version(\"10.0.14393\"):\n+        try:\n+            import ctypes\n+            kernel32 = ctypes.windll.kernel32\n+            handle = kernel32.GetStdHandle(-11)\n+            # set `ENABLE_VIRTUAL_TERMINAL_PROCESSING` flag\n+            if not kernel32.SetConsoleMode(handle, 7):\n+                raise ValueError\n+        except ValueError:\n+            return text",
      "comment": "@Gallaecio  please suggest how should I cover this part. I tried mocking windows platform but I think `parse_version` is still failing.",
      "comment_id": 439325599,
      "user": "akshaysharmajs",
      "created_at": "2020-06-12T09:59:30Z",
      "url": "https://github.com/scrapy/scrapy/pull/4403#discussion_r439325599"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 4403,
      "file_path": "scrapy/utils/display.py",
      "line": 35,
      "side": "RIGHT",
      "diff_hunk": "@@ -3,20 +3,60 @@\n \"\"\"\n \n import sys\n+from distutils.version import LooseVersion as parse_version\n+from platform import version\n from pprint import pformat as pformat_\n \n \n def _colorize(text, colorize=True):\n     if not colorize or not sys.stdout.isatty():\n         return text\n     try:\n-        from pygments import highlight\n         from pygments.formatters import TerminalFormatter\n+        from pygments import highlight\n         from pygments.lexers import PythonLexer\n-        return highlight(text, PythonLexer(), TerminalFormatter())\n     except ImportError:\n         return text\n \n+    # All Windows versions >= \"10.0.14393\" interpret ANSI escape sequences\n+    # using terminal processing.\n+    #\n+    # Enable enivornment variable `ENABLE_VIRTUAL_TERMINAL_PROCESSING`\n+    # to activate terminal processing.\n+    if sys.platform == \"win32\" and parse_version(version()) >= parse_version(\"10.0.14393\"):\n+        try:\n+            import ctypes\n+            kernel32 = ctypes.windll.kernel32\n+            handle = kernel32.GetStdHandle(-11)\n+            # set `ENABLE_VIRTUAL_TERMINAL_PROCESSING` flag\n+            if not kernel32.SetConsoleMode(handle, 7):\n+                raise ValueError\n+        except ValueError:\n+            return text",
      "comment": "Could you please push the test code that fails, so that I can have a look?",
      "comment_id": 439856396,
      "user": "Gallaecio",
      "created_at": "2020-06-14T18:35:37Z",
      "url": "https://github.com/scrapy/scrapy/pull/4403#discussion_r439856396"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 4403,
      "file_path": "scrapy/utils/display.py",
      "line": 35,
      "side": "RIGHT",
      "diff_hunk": "@@ -3,20 +3,60 @@\n \"\"\"\n \n import sys\n+from distutils.version import LooseVersion as parse_version\n+from platform import version\n from pprint import pformat as pformat_\n \n \n def _colorize(text, colorize=True):\n     if not colorize or not sys.stdout.isatty():\n         return text\n     try:\n-        from pygments import highlight\n         from pygments.formatters import TerminalFormatter\n+        from pygments import highlight\n         from pygments.lexers import PythonLexer\n-        return highlight(text, PythonLexer(), TerminalFormatter())\n     except ImportError:\n         return text\n \n+    # All Windows versions >= \"10.0.14393\" interpret ANSI escape sequences\n+    # using terminal processing.\n+    #\n+    # Enable enivornment variable `ENABLE_VIRTUAL_TERMINAL_PROCESSING`\n+    # to activate terminal processing.\n+    if sys.platform == \"win32\" and parse_version(version()) >= parse_version(\"10.0.14393\"):\n+        try:\n+            import ctypes\n+            kernel32 = ctypes.windll.kernel32\n+            handle = kernel32.GetStdHandle(-11)\n+            # set `ENABLE_VIRTUAL_TERMINAL_PROCESSING` flag\n+            if not kernel32.SetConsoleMode(handle, 7):\n+                raise ValueError\n+        except ValueError:\n+            return text",
      "comment": "I have pushed the test code.Please have a look, windows mocking part is failing giving this error `AttributeError: <module 'ctypes' from '/usr/lib/python3.6/ctypes/__init__.py'> does not have the attribute 'windll'\r\n`",
      "comment_id": 440223622,
      "user": "akshaysharmajs",
      "created_at": "2020-06-15T14:38:09Z",
      "url": "https://github.com/scrapy/scrapy/pull/4403#discussion_r440223622"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 4704,
      "file_path": "docs/utils/linkfix.py",
      "line": 26,
      "side": "RIGHT",
      "diff_hunk": "@@ -23,7 +23,7 @@ def main():\n     _contents = None\n \n     # A regex that matches standard linkcheck output lines\n-    line_re = re.compile(u'(.*)\\:\\d+\\:\\s\\[(.*)\\]\\s(?:(.*)\\sto\\s(.*)|(.*))')\n+    line_re = re.compile(r'(.*)\\:\\d+\\:\\s\\[(.*)\\]\\s(?:(.*)\\sto\\s(.*)|(.*))')",
      "comment": "This was the non-obvious change in this PR; checked that it is ok:\r\n```py\r\n>>> r'(.*)\\:\\d+\\:\\s\\[(.*)\\]\\s(?:(.*)\\sto\\s(.*)|(.*))' == '(.*)\\:\\d+\\:\\s\\[(.*)\\]\\s(?:(.*)\\sto\\s(.*)|(.*))'\r\nTrue\r\n```",
      "comment_id": 463249401,
      "user": "kmike",
      "created_at": "2020-07-30T20:22:47Z",
      "url": "https://github.com/scrapy/scrapy/pull/4704#discussion_r463249401"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 4434,
      "file_path": "scrapy/extensions/feedexport.py",
      "line": 244,
      "side": "RIGHT",
      "diff_hunk": "@@ -241,28 +241,19 @@ def __init__(self, crawler):\n \n         self.storages = self._load_components('FEED_STORAGES')\n         self.exporters = self._load_components('FEED_EXPORTERS')\n+        self.storage_batch = self.settings.getint('FEED_STORAGE_BATCH')",
      "comment": "Maybe `FEED_STORAGE_BATCH_SIZE` is a better name.\r\nAlso, we could consider time based deliveries (say every X minutes), this one is just for consideration.",
      "comment_id": 394391136,
      "user": "ejulio",
      "created_at": "2020-03-18T14:32:28Z",
      "url": "https://github.com/scrapy/scrapy/pull/4434#discussion_r394391136"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 4434,
      "file_path": "scrapy/extensions/feedexport.py",
      "line": 301,
      "side": "RIGHT",
      "diff_hunk": "@@ -285,11 +276,49 @@ def close_spider(self, spider):\n             deferred_list.append(d)\n         return defer.DeferredList(deferred_list) if deferred_list else None\n \n+    def _start_new_batch(self, previous_batch_slot, uri, feed, spider):\n+        \"\"\"\n+        Redirect the output data stream to a new file.\n+        Execute multiple times if 'FEED_STORAGE_BATCH' setting is greater than zero.\n+        \"\"\"\n+        if previous_batch_slot is not None:\n+            previous_batch_slot.exporter.finish_exporting()\n+            previous_batch_slot.storage.store(previous_batch_slot.file)\n+        storage = self._get_storage(uri)\n+        file = storage.open(spider)\n+        exporter = self._get_exporter(\n+            file=file,\n+            format=feed['format'],\n+            fields_to_export=feed['fields'],\n+            encoding=feed['encoding'],\n+            indent=feed['indent']\n+        )\n+        slot = _FeedSlot(file, exporter, storage, uri, feed['format'], feed['store_empty'])\n+        if slot.store_empty:\n+            slot.start_exporting()\n+        return slot\n+\n+    def _get_uri_of_partial(self, template_uri, feed, spider):",
      "comment": "I guess you shouldn't force the timestamp in the file name.\r\nJust log a warning if `%(time)s` is not in the URI as it will cause errors.\r\nMaybe, we could add a new parameter, like `%(batch_id)s` also",
      "comment_id": 394392349,
      "user": "ejulio",
      "created_at": "2020-03-18T14:33:58Z",
      "url": "https://github.com/scrapy/scrapy/pull/4434#discussion_r394392349"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 4434,
      "file_path": "scrapy/extensions/feedexport.py",
      "line": 253,
      "side": "RIGHT",
      "diff_hunk": "@@ -241,28 +241,19 @@ def __init__(self, crawler):\n \n         self.storages = self._load_components('FEED_STORAGES')\n         self.exporters = self._load_components('FEED_EXPORTERS')\n+        self.storage_batch = self.settings.getint('FEED_STORAGE_BATCH')\n         for uri, feed in self.feeds.items():\n             if not self._storage_supported(uri):\n                 raise NotConfigured\n             if not self._exporter_supported(feed['format']):\n                 raise NotConfigured\n \n     def open_spider(self, spider):\n+        if self.storage_batch:\n+            self.feeds = {self._get_uri_of_partial(uri, feed, spider): feed for uri, feed in self.feeds.items()}",
      "comment": "One approach is that, whenever we reach the expected count, just close the current file/deliver it and create a new one.",
      "comment_id": 394393041,
      "user": "ejulio",
      "created_at": "2020-03-18T14:34:53Z",
      "url": "https://github.com/scrapy/scrapy/pull/4434#discussion_r394393041"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 4434,
      "file_path": "scrapy/extensions/feedexport.py",
      "line": 301,
      "side": "RIGHT",
      "diff_hunk": "@@ -285,11 +276,49 @@ def close_spider(self, spider):\n             deferred_list.append(d)\n         return defer.DeferredList(deferred_list) if deferred_list else None\n \n+    def _start_new_batch(self, previous_batch_slot, uri, feed, spider):\n+        \"\"\"\n+        Redirect the output data stream to a new file.\n+        Execute multiple times if 'FEED_STORAGE_BATCH' setting is greater than zero.\n+        \"\"\"\n+        if previous_batch_slot is not None:\n+            previous_batch_slot.exporter.finish_exporting()\n+            previous_batch_slot.storage.store(previous_batch_slot.file)\n+        storage = self._get_storage(uri)\n+        file = storage.open(spider)\n+        exporter = self._get_exporter(\n+            file=file,\n+            format=feed['format'],\n+            fields_to_export=feed['fields'],\n+            encoding=feed['encoding'],\n+            indent=feed['indent']\n+        )\n+        slot = _FeedSlot(file, exporter, storage, uri, feed['format'], feed['store_empty'])\n+        if slot.store_empty:\n+            slot.start_exporting()\n+        return slot\n+\n+    def _get_uri_of_partial(self, template_uri, feed, spider):",
      "comment": "If I understand correctly, the user must specify %(time)s and %(batch_id)s in the path and the input should be\r\nscrapy crawl quotes -o res/test%(time)s.json - something like that?\r\nIs %(batch_id)s a serial number of current batch?",
      "comment_id": 395110916,
      "user": "BroodingKangaroo",
      "created_at": "2020-03-19T15:24:27Z",
      "url": "https://github.com/scrapy/scrapy/pull/4434#discussion_r395110916"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 4434,
      "file_path": "scrapy/extensions/feedexport.py",
      "line": 301,
      "side": "RIGHT",
      "diff_hunk": "@@ -285,11 +276,49 @@ def close_spider(self, spider):\n             deferred_list.append(d)\n         return defer.DeferredList(deferred_list) if deferred_list else None\n \n+    def _start_new_batch(self, previous_batch_slot, uri, feed, spider):\n+        \"\"\"\n+        Redirect the output data stream to a new file.\n+        Execute multiple times if 'FEED_STORAGE_BATCH' setting is greater than zero.\n+        \"\"\"\n+        if previous_batch_slot is not None:\n+            previous_batch_slot.exporter.finish_exporting()\n+            previous_batch_slot.storage.store(previous_batch_slot.file)\n+        storage = self._get_storage(uri)\n+        file = storage.open(spider)\n+        exporter = self._get_exporter(\n+            file=file,\n+            format=feed['format'],\n+            fields_to_export=feed['fields'],\n+            encoding=feed['encoding'],\n+            indent=feed['indent']\n+        )\n+        slot = _FeedSlot(file, exporter, storage, uri, feed['format'], feed['store_empty'])\n+        if slot.store_empty:\n+            slot.start_exporting()\n+        return slot\n+\n+    def _get_uri_of_partial(self, template_uri, feed, spider):",
      "comment": "Yup, the users should set the parameter as they wish.\r\nWe should warn them if that parameter is missing.\r\n\r\nThe new `batch_id` parameter can be just a sequential id starting at 1..",
      "comment_id": 395164780,
      "user": "ejulio",
      "created_at": "2020-03-19T16:38:50Z",
      "url": "https://github.com/scrapy/scrapy/pull/4434#discussion_r395164780"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 4434,
      "file_path": "scrapy/extensions/feedexport.py",
      "line": 266,
      "side": "RIGHT",
      "diff_hunk": "@@ -241,28 +243,28 @@ def __init__(self, crawler):\n \n         self.storages = self._load_components('FEED_STORAGES')\n         self.exporters = self._load_components('FEED_EXPORTERS')\n+        self.storage_batch_size = self.settings.getint('FEED_STORAGE_BATCH_SIZE')\n         for uri, feed in self.feeds.items():\n             if not self._storage_supported(uri):\n                 raise NotConfigured\n+            if not self._batch_deliveries_supported(uri):\n+                raise NotConfigured\n             if not self._exporter_supported(feed['format']):\n                 raise NotConfigured\n \n     def open_spider(self, spider):\n         for uri, feed in self.feeds.items():\n-            uri = uri % self._get_uri_params(spider, feed['uri_params'])\n-            storage = self._get_storage(uri)\n-            file = storage.open(spider)\n-            exporter = self._get_exporter(\n-                file=file,\n-                format=feed['format'],\n-                fields_to_export=feed['fields'],\n-                encoding=feed['encoding'],\n-                indent=feed['indent'],\n-            )\n-            slot = _FeedSlot(file, exporter, storage, uri, feed['format'], feed['store_empty'])\n-            self.slots.append(slot)\n-            if slot.store_empty:\n-                slot.start_exporting()\n+            batch_id = 1\n+            uri_params = self._get_uri_params(spider, feed['uri_params'])\n+            uri_params['batch_id'] = batch_id\n+            self.slots.append(self._start_new_batch(\n+                previous_batch_slot=None,\n+                uri=uri % uri_params,\n+                feed=feed,\n+                spider=spider,\n+                batch_id=batch_id,\n+                template_uri=uri",
      "comment": "```suggestion\r\n                template_uri=uri,\r\n```\r\n:lipstick: ",
      "comment_id": 395813690,
      "user": "elacuesta",
      "created_at": "2020-03-20T18:17:05Z",
      "url": "https://github.com/scrapy/scrapy/pull/4434#discussion_r395813690"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 4434,
      "file_path": "scrapy/extensions/feedexport.py",
      "line": 314,
      "side": "RIGHT",
      "diff_hunk": "@@ -285,11 +287,56 @@ def close_spider(self, spider):\n             deferred_list.append(d)\n         return defer.DeferredList(deferred_list) if deferred_list else None\n \n+    def _start_new_batch(self, previous_batch_slot, uri, feed, spider, batch_id, template_uri):\n+        \"\"\"\n+        Redirect the output data stream to a new file.\n+        Execute multiple times if 'FEED_STORAGE_BATCH' setting is greater than zero.\n+        :param previous_batch_slot: slot of previous batch. We need to call slot.storage.store\n+        to get the file properly closed.\n+        :param uri: uri of the new batch to start\n+        :param feed: dict with parameters of feed\n+        :param spider: user spider\n+        :param batch_id: sequential batch id starting at 1\n+        :param template_uri: template uri which contains %(time)s or %(batch_id)s to create new uri\n+        \"\"\"\n+        if previous_batch_slot is not None:\n+            previous_batch_slot.exporter.finish_exporting()\n+            previous_batch_slot.storage.store(previous_batch_slot.file)\n+        storage = self._get_storage(uri)\n+        file = storage.open(spider)\n+        exporter = self._get_exporter(\n+            file=file,\n+            format=feed['format'],\n+            fields_to_export=feed['fields'],\n+            encoding=feed['encoding'],\n+            indent=feed['indent']\n+        )\n+        slot = _FeedSlot(file, exporter, storage, uri, feed['format'], feed['store_empty'], batch_id, template_uri)",
      "comment": "These are a lot of parameters, could you pass them using keywords?",
      "comment_id": 395814193,
      "user": "elacuesta",
      "created_at": "2020-03-20T18:18:01Z",
      "url": "https://github.com/scrapy/scrapy/pull/4434#discussion_r395814193"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 4434,
      "file_path": "scrapy/extensions/feedexport.py",
      "line": 312,
      "side": "RIGHT",
      "diff_hunk": "@@ -285,11 +287,56 @@ def close_spider(self, spider):\n             deferred_list.append(d)\n         return defer.DeferredList(deferred_list) if deferred_list else None\n \n+    def _start_new_batch(self, previous_batch_slot, uri, feed, spider, batch_id, template_uri):\n+        \"\"\"\n+        Redirect the output data stream to a new file.\n+        Execute multiple times if 'FEED_STORAGE_BATCH' setting is greater than zero.\n+        :param previous_batch_slot: slot of previous batch. We need to call slot.storage.store\n+        to get the file properly closed.\n+        :param uri: uri of the new batch to start\n+        :param feed: dict with parameters of feed\n+        :param spider: user spider\n+        :param batch_id: sequential batch id starting at 1\n+        :param template_uri: template uri which contains %(time)s or %(batch_id)s to create new uri\n+        \"\"\"\n+        if previous_batch_slot is not None:\n+            previous_batch_slot.exporter.finish_exporting()\n+            previous_batch_slot.storage.store(previous_batch_slot.file)\n+        storage = self._get_storage(uri)\n+        file = storage.open(spider)\n+        exporter = self._get_exporter(\n+            file=file,\n+            format=feed['format'],\n+            fields_to_export=feed['fields'],\n+            encoding=feed['encoding'],\n+            indent=feed['indent']",
      "comment": "```suggestion\r\n            indent=feed['indent'],\r\n```\r\n:lipstick: ",
      "comment_id": 395814339,
      "user": "elacuesta",
      "created_at": "2020-03-20T18:18:18Z",
      "url": "https://github.com/scrapy/scrapy/pull/4434#discussion_r395814339"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 4434,
      "file_path": "scrapy/settings/default_settings.py",
      "line": 149,
      "side": "RIGHT",
      "diff_hunk": "@@ -146,6 +146,7 @@\n     's3': 'scrapy.extensions.feedexport.S3FeedStorage',\n     'ftp': 'scrapy.extensions.feedexport.FTPFeedStorage',\n }\n+FEED_STORAGE_BATCH_SIZE = 0",
      "comment": "I think a better default value for this setting, meaning no batch splitting, would be `None`.",
      "comment_id": 395814960,
      "user": "elacuesta",
      "created_at": "2020-03-20T18:19:35Z",
      "url": "https://github.com/scrapy/scrapy/pull/4434#discussion_r395814960"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 4434,
      "file_path": "scrapy/extensions/feedexport.py",
      "line": 344,
      "side": "RIGHT",
      "diff_hunk": "@@ -285,11 +287,56 @@ def close_spider(self, spider):\n             deferred_list.append(d)\n         return defer.DeferredList(deferred_list) if deferred_list else None\n \n+    def _start_new_batch(self, previous_batch_slot, uri, feed, spider, batch_id, template_uri):\n+        \"\"\"\n+        Redirect the output data stream to a new file.\n+        Execute multiple times if 'FEED_STORAGE_BATCH' setting is greater than zero.\n+        :param previous_batch_slot: slot of previous batch. We need to call slot.storage.store\n+        to get the file properly closed.\n+        :param uri: uri of the new batch to start\n+        :param feed: dict with parameters of feed\n+        :param spider: user spider\n+        :param batch_id: sequential batch id starting at 1\n+        :param template_uri: template uri which contains %(time)s or %(batch_id)s to create new uri\n+        \"\"\"\n+        if previous_batch_slot is not None:\n+            previous_batch_slot.exporter.finish_exporting()\n+            previous_batch_slot.storage.store(previous_batch_slot.file)\n+        storage = self._get_storage(uri)\n+        file = storage.open(spider)\n+        exporter = self._get_exporter(\n+            file=file,\n+            format=feed['format'],\n+            fields_to_export=feed['fields'],\n+            encoding=feed['encoding'],\n+            indent=feed['indent']\n+        )\n+        slot = _FeedSlot(file, exporter, storage, uri, feed['format'], feed['store_empty'], batch_id, template_uri)\n+        if slot.store_empty:\n+            slot.start_exporting()\n+        return slot\n+\n     def item_scraped(self, item, spider):\n-        for slot in self.slots:\n+        slots = []\n+        for idx, slot in enumerate(self.slots):\n             slot.start_exporting()\n             slot.exporter.export_item(item)\n             slot.itemcount += 1\n+            if self.storage_batch_size and slot.itemcount % self.storage_batch_size == 0:\n+                batch_id = slot.batch_id + 1\n+                uri_params = self._get_uri_params(spider, self.feeds[slot.template_uri]['uri_params'])\n+                uri_params['batch_id'] = batch_id\n+                self.slots.append(self._start_new_batch(\n+                    previous_batch_slot=slot,\n+                    uri=slot.template_uri % uri_params,\n+                    feed=self.feeds[slot.template_uri],\n+                    spider=spider,\n+                    batch_id=batch_id,\n+                    template_uri=slot.template_uri\n+                ))\n+                self.slots[idx] = None\n+        self.slots = [slot for slot in self.slots if slot is not None]\n+        self.slots.extend(slots)",
      "comment": "This does nothing, because `slots` is not modified after being set as `slots = []`",
      "comment_id": 395818981,
      "user": "elacuesta",
      "created_at": "2020-03-20T18:27:25Z",
      "url": "https://github.com/scrapy/scrapy/pull/4434#discussion_r395818981"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 4434,
      "file_path": "scrapy/extensions/feedexport.py",
      "line": 361,
      "side": "RIGHT",
      "diff_hunk": "@@ -306,6 +353,17 @@ def _exporter_supported(self, format):\n             return True\n         logger.error(\"Unknown feed format: %(format)s\", {'format': format})\n \n+    def _batch_deliveries_supported(self, uri):\n+        \"\"\"\n+        If FEED_STORAGE_BATCH_SIZE setting is specified uri has to contain %(time)s or %(batch_id)s\n+        to distinguish different files of partial output\n+        \"\"\"\n+        if not self.storage_batch_size:",
      "comment": "Could you combine these three conditions into one single `\u00ecf` check? Also, please include an explicit `return False`. It's not strictly needed because there is an implicit `None` being returned, which evaluates to `False`, but [_Explicit is better than implicit_](https://www.python.org/dev/peps/pep-0020).\r\n\r\nAlso, should the log level be \"warning\" instead? :thinking: ",
      "comment_id": 395820100,
      "user": "elacuesta",
      "created_at": "2020-03-20T18:29:38Z",
      "url": "https://github.com/scrapy/scrapy/pull/4434#discussion_r395820100"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 4434,
      "file_path": "scrapy/extensions/feedexport.py",
      "line": 344,
      "side": "RIGHT",
      "diff_hunk": "@@ -285,11 +287,56 @@ def close_spider(self, spider):\n             deferred_list.append(d)\n         return defer.DeferredList(deferred_list) if deferred_list else None\n \n+    def _start_new_batch(self, previous_batch_slot, uri, feed, spider, batch_id, template_uri):\n+        \"\"\"\n+        Redirect the output data stream to a new file.\n+        Execute multiple times if 'FEED_STORAGE_BATCH' setting is greater than zero.\n+        :param previous_batch_slot: slot of previous batch. We need to call slot.storage.store\n+        to get the file properly closed.\n+        :param uri: uri of the new batch to start\n+        :param feed: dict with parameters of feed\n+        :param spider: user spider\n+        :param batch_id: sequential batch id starting at 1\n+        :param template_uri: template uri which contains %(time)s or %(batch_id)s to create new uri\n+        \"\"\"\n+        if previous_batch_slot is not None:\n+            previous_batch_slot.exporter.finish_exporting()\n+            previous_batch_slot.storage.store(previous_batch_slot.file)\n+        storage = self._get_storage(uri)\n+        file = storage.open(spider)\n+        exporter = self._get_exporter(\n+            file=file,\n+            format=feed['format'],\n+            fields_to_export=feed['fields'],\n+            encoding=feed['encoding'],\n+            indent=feed['indent']\n+        )\n+        slot = _FeedSlot(file, exporter, storage, uri, feed['format'], feed['store_empty'], batch_id, template_uri)\n+        if slot.store_empty:\n+            slot.start_exporting()\n+        return slot\n+\n     def item_scraped(self, item, spider):\n-        for slot in self.slots:\n+        slots = []\n+        for idx, slot in enumerate(self.slots):\n             slot.start_exporting()\n             slot.exporter.export_item(item)\n             slot.itemcount += 1\n+            if self.storage_batch_size and slot.itemcount % self.storage_batch_size == 0:\n+                batch_id = slot.batch_id + 1\n+                uri_params = self._get_uri_params(spider, self.feeds[slot.template_uri]['uri_params'])\n+                uri_params['batch_id'] = batch_id\n+                self.slots.append(self._start_new_batch(\n+                    previous_batch_slot=slot,\n+                    uri=slot.template_uri % uri_params,\n+                    feed=self.feeds[slot.template_uri],\n+                    spider=spider,\n+                    batch_id=batch_id,\n+                    template_uri=slot.template_uri\n+                ))\n+                self.slots[idx] = None\n+        self.slots = [slot for slot in self.slots if slot is not None]\n+        self.slots.extend(slots)",
      "comment": "Thank you, `slots.append(self._start_new_batch` should be instead of `self.slots.append(self._start_new_batch`",
      "comment_id": 395968505,
      "user": "BroodingKangaroo",
      "created_at": "2020-03-21T06:55:56Z",
      "url": "https://github.com/scrapy/scrapy/pull/4434#discussion_r395968505"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 4434,
      "file_path": "scrapy/extensions/feedexport.py",
      "line": 361,
      "side": "RIGHT",
      "diff_hunk": "@@ -306,6 +353,17 @@ def _exporter_supported(self, format):\n             return True\n         logger.error(\"Unknown feed format: %(format)s\", {'format': format})\n \n+    def _batch_deliveries_supported(self, uri):\n+        \"\"\"\n+        If FEED_STORAGE_BATCH_SIZE setting is specified uri has to contain %(time)s or %(batch_id)s\n+        to distinguish different files of partial output\n+        \"\"\"\n+        if not self.storage_batch_size:",
      "comment": "Done.\r\nI thought it can be more readable if I slit it into 2 `if`.",
      "comment_id": 395968515,
      "user": "BroodingKangaroo",
      "created_at": "2020-03-21T06:56:06Z",
      "url": "https://github.com/scrapy/scrapy/pull/4434#discussion_r395968515"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 4434,
      "file_path": "scrapy/extensions/feedexport.py",
      "line": 333,
      "side": "RIGHT",
      "diff_hunk": "@@ -285,11 +286,65 @@ def close_spider(self, spider):\n             deferred_list.append(d)\n         return defer.DeferredList(deferred_list) if deferred_list else None\n \n+    def _start_new_batch(self, previous_batch_slot, uri, feed, spider, batch_id, template_uri):\n+        \"\"\"\n+        Redirect the output data stream to a new file.\n+        Execute multiple times if 'FEED_STORAGE_BATCH' setting is specified.\n+        :param previous_batch_slot: slot of previous batch. We need to call slot.storage.store\n+        to get the file properly closed.\n+        :param uri: uri of the new batch to start\n+        :param feed: dict with parameters of feed\n+        :param spider: user spider\n+        :param batch_id: sequential batch id starting at 1\n+        :param template_uri: template uri which contains %(time)s or %(batch_id)s to create new uri\n+        \"\"\"\n+        if previous_batch_slot is not None:\n+            previous_batch_slot.exporter.finish_exporting()\n+            previous_batch_slot.storage.store(previous_batch_slot.file)\n+        storage = self._get_storage(uri)\n+        file = storage.open(spider)\n+        exporter = self._get_exporter(\n+            file=file,\n+            format=feed['format'],\n+            fields_to_export=feed['fields'],\n+            encoding=feed['encoding'],\n+            indent=feed['indent'],\n+        )\n+        slot = _FeedSlot(\n+            file=file,\n+            exporter=exporter,\n+            storage=storage,\n+            uri=uri,\n+            format=feed['format'],\n+            store_empty=feed['store_empty'],\n+            batch_id=batch_id,\n+            template_uri=template_uri,\n+        )\n+        if slot.store_empty:\n+            slot.start_exporting()\n+        return slot\n+\n     def item_scraped(self, item, spider):\n-        for slot in self.slots:\n+        slots = []\n+        for idx, slot in enumerate(self.slots):\n             slot.start_exporting()\n             slot.exporter.export_item(item)\n             slot.itemcount += 1\n+            if self.storage_batch_size and slot.itemcount % self.storage_batch_size == 0:",
      "comment": "I guess you should be calling a routine similar to `close_spider` here, right?\r\nOtherwise we're just creating the local files, but never sending the S3 or some other storage that is not local.\r\nAlso, I wrote a piece of this functionality and had issues when exporting to S3.\r\nI had to upload `file.read()` instead of just `file` as it was raising errors.",
      "comment_id": 398489671,
      "user": "ejulio",
      "created_at": "2020-03-26T11:09:45Z",
      "url": "https://github.com/scrapy/scrapy/pull/4434#discussion_r398489671"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 4434,
      "file_path": "scrapy/extensions/feedexport.py",
      "line": 403,
      "side": "RIGHT",
      "diff_hunk": "@@ -335,7 +400,7 @@ def _get_uri_params(self, spider, uri_params):\n         params = {}\n         for k in dir(spider):\n             params[k] = getattr(spider, k)\n-        ts = datetime.utcnow().replace(microsecond=0).isoformat().replace(':', '-')\n+        ts = datetime.utcnow().isoformat().replace(':', '-')",
      "comment": "replace(microsecond=0) - removes microseconds. But if several files were sent within one second they will have the same names.",
      "comment_id": 398497347,
      "user": "BroodingKangaroo",
      "created_at": "2020-03-26T11:23:46Z",
      "url": "https://github.com/scrapy/scrapy/pull/4434#discussion_r398497347"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 4434,
      "file_path": "scrapy/extensions/feedexport.py",
      "line": 258,
      "side": "RIGHT",
      "diff_hunk": "@@ -241,28 +242,28 @@ def __init__(self, crawler):\n \n         self.storages = self._load_components('FEED_STORAGES')\n         self.exporters = self._load_components('FEED_EXPORTERS')\n+        self.storage_batch_size = self.settings.get('FEED_STORAGE_BATCH_SIZE', None)\n         for uri, feed in self.feeds.items():\n             if not self._storage_supported(uri):\n                 raise NotConfigured\n+            if not self._batch_deliveries_supported(uri):\n+                raise NotConfigured\n             if not self._exporter_supported(feed['format']):\n                 raise NotConfigured\n \n     def open_spider(self, spider):\n         for uri, feed in self.feeds.items():\n-            uri = uri % self._get_uri_params(spider, feed['uri_params'])\n-            storage = self._get_storage(uri)\n-            file = storage.open(spider)\n-            exporter = self._get_exporter(\n-                file=file,\n-                format=feed['format'],\n-                fields_to_export=feed['fields'],\n-                encoding=feed['encoding'],\n-                indent=feed['indent'],\n-            )\n-            slot = _FeedSlot(file, exporter, storage, uri, feed['format'], feed['store_empty'])\n-            self.slots.append(slot)\n-            if slot.store_empty:\n-                slot.start_exporting()\n+            batch_id = 1\n+            uri_params = self._get_uri_params(spider, feed['uri_params'])\n+            uri_params['batch_id'] = batch_id",
      "comment": "It\u2019s true, I thought about it, but didn\u2019t figure out how to do it. I'll try again =)",
      "comment_id": 398500074,
      "user": "BroodingKangaroo",
      "created_at": "2020-03-26T11:28:21Z",
      "url": "https://github.com/scrapy/scrapy/pull/4434#discussion_r398500074"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 4434,
      "file_path": "scrapy/extensions/feedexport.py",
      "line": 333,
      "side": "RIGHT",
      "diff_hunk": "@@ -285,11 +286,65 @@ def close_spider(self, spider):\n             deferred_list.append(d)\n         return defer.DeferredList(deferred_list) if deferred_list else None\n \n+    def _start_new_batch(self, previous_batch_slot, uri, feed, spider, batch_id, template_uri):\n+        \"\"\"\n+        Redirect the output data stream to a new file.\n+        Execute multiple times if 'FEED_STORAGE_BATCH' setting is specified.\n+        :param previous_batch_slot: slot of previous batch. We need to call slot.storage.store\n+        to get the file properly closed.\n+        :param uri: uri of the new batch to start\n+        :param feed: dict with parameters of feed\n+        :param spider: user spider\n+        :param batch_id: sequential batch id starting at 1\n+        :param template_uri: template uri which contains %(time)s or %(batch_id)s to create new uri\n+        \"\"\"\n+        if previous_batch_slot is not None:\n+            previous_batch_slot.exporter.finish_exporting()\n+            previous_batch_slot.storage.store(previous_batch_slot.file)\n+        storage = self._get_storage(uri)\n+        file = storage.open(spider)\n+        exporter = self._get_exporter(\n+            file=file,\n+            format=feed['format'],\n+            fields_to_export=feed['fields'],\n+            encoding=feed['encoding'],\n+            indent=feed['indent'],\n+        )\n+        slot = _FeedSlot(\n+            file=file,\n+            exporter=exporter,\n+            storage=storage,\n+            uri=uri,\n+            format=feed['format'],\n+            store_empty=feed['store_empty'],\n+            batch_id=batch_id,\n+            template_uri=template_uri,\n+        )\n+        if slot.store_empty:\n+            slot.start_exporting()\n+        return slot\n+\n     def item_scraped(self, item, spider):\n-        for slot in self.slots:\n+        slots = []\n+        for idx, slot in enumerate(self.slots):\n             slot.start_exporting()\n             slot.exporter.export_item(item)\n             slot.itemcount += 1\n+            if self.storage_batch_size and slot.itemcount % self.storage_batch_size == 0:",
      "comment": "The current implementation of the `_start_new_batch()` function repeats the `close_spider()` function in some aspects.\r\nI tried running it for S3. It seems the program worked correctly.",
      "comment_id": 406728489,
      "user": "BroodingKangaroo",
      "created_at": "2020-04-10T12:05:00Z",
      "url": "https://github.com/scrapy/scrapy/pull/4434#discussion_r406728489"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 4434,
      "file_path": "scrapy/extensions/feedexport.py",
      "line": 333,
      "side": "RIGHT",
      "diff_hunk": "@@ -285,11 +286,65 @@ def close_spider(self, spider):\n             deferred_list.append(d)\n         return defer.DeferredList(deferred_list) if deferred_list else None\n \n+    def _start_new_batch(self, previous_batch_slot, uri, feed, spider, batch_id, template_uri):\n+        \"\"\"\n+        Redirect the output data stream to a new file.\n+        Execute multiple times if 'FEED_STORAGE_BATCH' setting is specified.\n+        :param previous_batch_slot: slot of previous batch. We need to call slot.storage.store\n+        to get the file properly closed.\n+        :param uri: uri of the new batch to start\n+        :param feed: dict with parameters of feed\n+        :param spider: user spider\n+        :param batch_id: sequential batch id starting at 1\n+        :param template_uri: template uri which contains %(time)s or %(batch_id)s to create new uri\n+        \"\"\"\n+        if previous_batch_slot is not None:\n+            previous_batch_slot.exporter.finish_exporting()\n+            previous_batch_slot.storage.store(previous_batch_slot.file)\n+        storage = self._get_storage(uri)\n+        file = storage.open(spider)\n+        exporter = self._get_exporter(\n+            file=file,\n+            format=feed['format'],\n+            fields_to_export=feed['fields'],\n+            encoding=feed['encoding'],\n+            indent=feed['indent'],\n+        )\n+        slot = _FeedSlot(\n+            file=file,\n+            exporter=exporter,\n+            storage=storage,\n+            uri=uri,\n+            format=feed['format'],\n+            store_empty=feed['store_empty'],\n+            batch_id=batch_id,\n+            template_uri=template_uri,\n+        )\n+        if slot.store_empty:\n+            slot.start_exporting()\n+        return slot\n+\n     def item_scraped(self, item, spider):\n-        for slot in self.slots:\n+        slots = []\n+        for idx, slot in enumerate(self.slots):\n             slot.start_exporting()\n             slot.exporter.export_item(item)\n             slot.itemcount += 1\n+            if self.storage_batch_size and slot.itemcount % self.storage_batch_size == 0:",
      "comment": "My advice here is to extract the common behavior to a function.\r\nAs there is no logging here about a file that was created.\r\nAlso, if you look into the behavior of `close_spider`, you'll notice that file storage is called in thread, therefore not blocking the current code.\r\nOtherwise, we'll be blocking the main thread while storing the files and, maybe, causing performance issues",
      "comment_id": 413993291,
      "user": "ejulio",
      "created_at": "2020-04-23T17:38:10Z",
      "url": "https://github.com/scrapy/scrapy/pull/4434#discussion_r413993291"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 4434,
      "file_path": "tests/test_feedexport.py",
      "line": 488,
      "side": "RIGHT",
      "diff_hunk": "@@ -464,6 +445,61 @@ def parse(self, response):\n         data = yield self.run_and_export(TestSpider, settings)\n         return data\n \n+    @defer.inlineCallbacks\n+    def assertExported(self, items, header, rows, settings=None, ordered=True):\n+        yield self.assertExportedCsv(items, header, rows, settings, ordered)\n+        yield self.assertExportedJsonLines(items, rows, settings)\n+        yield self.assertExportedXml(items, rows, settings)\n+        yield self.assertExportedPickle(items, rows, settings)\n+        yield self.assertExportedMarshal(items, rows, settings)\n+        yield self.assertExportedMultiple(items, rows, settings)\n+\n+    @abstractmethod\n+    def run_and_export(self, spider_cls, settings):\n+        pass\n+\n+    def _load_until_eof(self, data, load_func):\n+        result = []\n+        with tempfile.TemporaryFile() as temp:\n+            temp.write(data)\n+            temp.seek(0)\n+            while True:\n+                try:\n+                    result.append(load_func(temp))\n+                except EOFError:\n+                    break\n+        return result\n+\n+\n+class FeedExportTest(FeedExportTestBase):\n+    __test__ = True\n+\n+    @defer.inlineCallbacks\n+    def run_and_export(self, spider_cls, settings):\n+        \"\"\" Run spider with specified settings; return exported data. \"\"\"\n+\n+        FEEDS = settings.get('FEEDS') or {}\n+        settings['FEEDS'] = {\n+            urljoin('file:', pathname2url(str(file_path))): feed\n+            for file_path, feed in FEEDS.items()\n+        }\n+        content = {}\n+        try:\n+            with MockServer() as s:",
      "comment": "Do you mean to use `scrapy.utils.test.get_crawler` instead of `MockServer` or it is about an error which I get trying to use `S3FeedStorageTest::test_store`?",
      "comment_id": 418478025,
      "user": "BroodingKangaroo",
      "created_at": "2020-05-01T09:32:49Z",
      "url": "https://github.com/scrapy/scrapy/pull/4434#discussion_r418478025"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 4434,
      "file_path": "tests/test_feedexport.py",
      "line": 488,
      "side": "RIGHT",
      "diff_hunk": "@@ -464,6 +445,61 @@ def parse(self, response):\n         data = yield self.run_and_export(TestSpider, settings)\n         return data\n \n+    @defer.inlineCallbacks\n+    def assertExported(self, items, header, rows, settings=None, ordered=True):\n+        yield self.assertExportedCsv(items, header, rows, settings, ordered)\n+        yield self.assertExportedJsonLines(items, rows, settings)\n+        yield self.assertExportedXml(items, rows, settings)\n+        yield self.assertExportedPickle(items, rows, settings)\n+        yield self.assertExportedMarshal(items, rows, settings)\n+        yield self.assertExportedMultiple(items, rows, settings)\n+\n+    @abstractmethod\n+    def run_and_export(self, spider_cls, settings):\n+        pass\n+\n+    def _load_until_eof(self, data, load_func):\n+        result = []\n+        with tempfile.TemporaryFile() as temp:\n+            temp.write(data)\n+            temp.seek(0)\n+            while True:\n+                try:\n+                    result.append(load_func(temp))\n+                except EOFError:\n+                    break\n+        return result\n+\n+\n+class FeedExportTest(FeedExportTestBase):\n+    __test__ = True\n+\n+    @defer.inlineCallbacks\n+    def run_and_export(self, spider_cls, settings):\n+        \"\"\" Run spider with specified settings; return exported data. \"\"\"\n+\n+        FEEDS = settings.get('FEEDS') or {}\n+        settings['FEEDS'] = {\n+            urljoin('file:', pathname2url(str(file_path))): feed\n+            for file_path, feed in FEEDS.items()\n+        }\n+        content = {}\n+        try:\n+            with MockServer() as s:",
      "comment": "Yeah, I don't know if you really need `MockServer`.\r\nIf it's required, then go for it.\r\nWas just suggesting `get_crawler` as an alternative, in case you weren't aware of it :smile: ",
      "comment_id": 418532506,
      "user": "ejulio",
      "created_at": "2020-05-01T13:05:34Z",
      "url": "https://github.com/scrapy/scrapy/pull/4434#discussion_r418532506"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 4434,
      "file_path": "tests/test_feedexport.py",
      "line": 488,
      "side": "RIGHT",
      "diff_hunk": "@@ -464,6 +445,61 @@ def parse(self, response):\n         data = yield self.run_and_export(TestSpider, settings)\n         return data\n \n+    @defer.inlineCallbacks\n+    def assertExported(self, items, header, rows, settings=None, ordered=True):\n+        yield self.assertExportedCsv(items, header, rows, settings, ordered)\n+        yield self.assertExportedJsonLines(items, rows, settings)\n+        yield self.assertExportedXml(items, rows, settings)\n+        yield self.assertExportedPickle(items, rows, settings)\n+        yield self.assertExportedMarshal(items, rows, settings)\n+        yield self.assertExportedMultiple(items, rows, settings)\n+\n+    @abstractmethod\n+    def run_and_export(self, spider_cls, settings):\n+        pass\n+\n+    def _load_until_eof(self, data, load_func):\n+        result = []\n+        with tempfile.TemporaryFile() as temp:\n+            temp.write(data)\n+            temp.seek(0)\n+            while True:\n+                try:\n+                    result.append(load_func(temp))\n+                except EOFError:\n+                    break\n+        return result\n+\n+\n+class FeedExportTest(FeedExportTestBase):\n+    __test__ = True\n+\n+    @defer.inlineCallbacks\n+    def run_and_export(self, spider_cls, settings):\n+        \"\"\" Run spider with specified settings; return exported data. \"\"\"\n+\n+        FEEDS = settings.get('FEEDS') or {}\n+        settings['FEEDS'] = {\n+            urljoin('file:', pathname2url(str(file_path))): feed\n+            for file_path, feed in FEEDS.items()\n+        }\n+        content = {}\n+        try:\n+            with MockServer() as s:",
      "comment": "Okay, finally got it.\r\nMockServer was in FeedExportTest before, so believe there was any reason to do this such way. I will also remember that get_crawler is an alternative. =))",
      "comment_id": 418761707,
      "user": "BroodingKangaroo",
      "created_at": "2020-05-01T22:20:01Z",
      "url": "https://github.com/scrapy/scrapy/pull/4434#discussion_r418761707"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 4434,
      "file_path": "scrapy/extensions/feedexport.py",
      "line": 293,
      "side": "RIGHT",
      "diff_hunk": "@@ -241,55 +242,104 @@ def __init__(self, crawler):\n \n         self.storages = self._load_components('FEED_STORAGES')\n         self.exporters = self._load_components('FEED_EXPORTERS')\n+        self.storage_batch_size = self.settings.get('FEED_STORAGE_BATCH_SIZE', None)\n         for uri, feed in self.feeds.items():\n             if not self._storage_supported(uri):\n                 raise NotConfigured\n+            if not self._batch_deliveries_supported(uri):\n+                raise NotConfigured\n             if not self._exporter_supported(feed['format']):\n                 raise NotConfigured\n \n     def open_spider(self, spider):\n         for uri, feed in self.feeds.items():\n-            uri = uri % self._get_uri_params(spider, feed['uri_params'])\n-            storage = self._get_storage(uri)\n-            file = storage.open(spider)\n-            exporter = self._get_exporter(\n-                file=file,\n-                format=feed['format'],\n-                fields_to_export=feed['fields'],\n-                encoding=feed['encoding'],\n-                indent=feed['indent'],\n-            )\n-            slot = _FeedSlot(file, exporter, storage, uri, feed['format'], feed['store_empty'])\n-            self.slots.append(slot)\n-            if slot.store_empty:\n-                slot.start_exporting()\n+            uri_params = self._get_uri_params(spider, feed['uri_params'], None)\n+            self.slots.append(self._start_new_batch(\n+                batch_id=1,\n+                uri=uri % uri_params,\n+                feed=feed,\n+                spider=spider,\n+                template_uri=uri,\n+            ))\n \n     def close_spider(self, spider):\n         deferred_list = []\n         for slot in self.slots:\n-            if not slot.itemcount and not slot.store_empty:\n-                # We need to call slot.storage.store nonetheless to get the file\n-                # properly closed.\n-                return defer.maybeDeferred(slot.storage.store, slot.file)\n-            slot.finish_exporting()\n-            logfmt = \"%s %%(format)s feed (%%(itemcount)d items) in: %%(uri)s\"\n-            log_args = {'format': slot.format,\n-                        'itemcount': slot.itemcount,\n-                        'uri': slot.uri}\n-            d = defer.maybeDeferred(slot.storage.store, slot.file)\n-            d.addCallback(lambda _: logger.info(logfmt % \"Stored\", log_args,\n-                                                extra={'spider': spider}))\n-            d.addErrback(lambda f: logger.error(logfmt % \"Error storing\", log_args,\n-                                                exc_info=failure_to_exc_info(f),\n-                                                extra={'spider': spider}))\n+            d = self._close_slot(slot, spider)\n             deferred_list.append(d)\n         return defer.DeferredList(deferred_list) if deferred_list else None\n \n+    def _close_slot(self, slot, spider):\n+        if not slot.itemcount and not slot.store_empty:\n+            # We need to call slot.storage.store nonetheless to get the file\n+            # properly closed.\n+            return defer.maybeDeferred(slot.storage.store, slot.file)\n+        slot.finish_exporting()\n+        logfmt = \"%s %%(format)s feed (%%(itemcount)d items) in: %%(uri)s\"\n+        log_args = {'format': slot.format,\n+                    'itemcount': slot.itemcount,\n+                    'uri': slot.uri}\n+        d = defer.maybeDeferred(slot.storage.store, slot.file)\n+        d.addCallback(lambda _: logger.info(logfmt % \"Stored\", log_args,\n+                                            extra={'spider': spider}))\n+        d.addErrback(lambda f: logger.error(logfmt % \"Error storing\", log_args,\n+                                            exc_info=failure_to_exc_info(f),\n+                                            extra={'spider': spider}))\n+        return d\n+\n+    def _start_new_batch(self, batch_id, uri, feed, spider, template_uri):\n+        \"\"\"\n+        Redirect the output data stream to a new file.\n+        Execute multiple times if 'FEED_STORAGE_BATCH' setting is specified.",
      "comment": "I guess this comes from a previous name of the setting.",
      "comment_id": 423999813,
      "user": "Gallaecio",
      "created_at": "2020-05-12T20:03:28Z",
      "url": "https://github.com/scrapy/scrapy/pull/4434#discussion_r423999813"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 4434,
      "file_path": "scrapy/extensions/feedexport.py",
      "line": 342,
      "side": "RIGHT",
      "diff_hunk": "@@ -241,55 +242,104 @@ def __init__(self, crawler):\n \n         self.storages = self._load_components('FEED_STORAGES')\n         self.exporters = self._load_components('FEED_EXPORTERS')\n+        self.storage_batch_size = self.settings.get('FEED_STORAGE_BATCH_SIZE', None)\n         for uri, feed in self.feeds.items():\n             if not self._storage_supported(uri):\n                 raise NotConfigured\n+            if not self._batch_deliveries_supported(uri):\n+                raise NotConfigured\n             if not self._exporter_supported(feed['format']):\n                 raise NotConfigured\n \n     def open_spider(self, spider):\n         for uri, feed in self.feeds.items():\n-            uri = uri % self._get_uri_params(spider, feed['uri_params'])\n-            storage = self._get_storage(uri)\n-            file = storage.open(spider)\n-            exporter = self._get_exporter(\n-                file=file,\n-                format=feed['format'],\n-                fields_to_export=feed['fields'],\n-                encoding=feed['encoding'],\n-                indent=feed['indent'],\n-            )\n-            slot = _FeedSlot(file, exporter, storage, uri, feed['format'], feed['store_empty'])\n-            self.slots.append(slot)\n-            if slot.store_empty:\n-                slot.start_exporting()\n+            uri_params = self._get_uri_params(spider, feed['uri_params'], None)\n+            self.slots.append(self._start_new_batch(\n+                batch_id=1,\n+                uri=uri % uri_params,\n+                feed=feed,\n+                spider=spider,\n+                template_uri=uri,\n+            ))\n \n     def close_spider(self, spider):\n         deferred_list = []\n         for slot in self.slots:\n-            if not slot.itemcount and not slot.store_empty:\n-                # We need to call slot.storage.store nonetheless to get the file\n-                # properly closed.\n-                return defer.maybeDeferred(slot.storage.store, slot.file)\n-            slot.finish_exporting()\n-            logfmt = \"%s %%(format)s feed (%%(itemcount)d items) in: %%(uri)s\"\n-            log_args = {'format': slot.format,\n-                        'itemcount': slot.itemcount,\n-                        'uri': slot.uri}\n-            d = defer.maybeDeferred(slot.storage.store, slot.file)\n-            d.addCallback(lambda _: logger.info(logfmt % \"Stored\", log_args,\n-                                                extra={'spider': spider}))\n-            d.addErrback(lambda f: logger.error(logfmt % \"Error storing\", log_args,\n-                                                exc_info=failure_to_exc_info(f),\n-                                                extra={'spider': spider}))\n+            d = self._close_slot(slot, spider)\n             deferred_list.append(d)\n         return defer.DeferredList(deferred_list) if deferred_list else None\n \n+    def _close_slot(self, slot, spider):\n+        if not slot.itemcount and not slot.store_empty:\n+            # We need to call slot.storage.store nonetheless to get the file\n+            # properly closed.\n+            return defer.maybeDeferred(slot.storage.store, slot.file)\n+        slot.finish_exporting()\n+        logfmt = \"%s %%(format)s feed (%%(itemcount)d items) in: %%(uri)s\"\n+        log_args = {'format': slot.format,\n+                    'itemcount': slot.itemcount,\n+                    'uri': slot.uri}\n+        d = defer.maybeDeferred(slot.storage.store, slot.file)\n+        d.addCallback(lambda _: logger.info(logfmt % \"Stored\", log_args,\n+                                            extra={'spider': spider}))\n+        d.addErrback(lambda f: logger.error(logfmt % \"Error storing\", log_args,\n+                                            exc_info=failure_to_exc_info(f),\n+                                            extra={'spider': spider}))\n+        return d\n+\n+    def _start_new_batch(self, batch_id, uri, feed, spider, template_uri):\n+        \"\"\"\n+        Redirect the output data stream to a new file.\n+        Execute multiple times if 'FEED_STORAGE_BATCH' setting is specified.\n+        :param batch_id: sequence number of current batch\n+        :param uri: uri of the new batch to start\n+        :param feed: dict with parameters of feed\n+        :param spider: user spider\n+        :param template_uri: template uri which contains %(batch_time)s or %(batch_id)s to create new uri\n+        \"\"\"\n+        storage = self._get_storage(uri)\n+        file = storage.open(spider)\n+        exporter = self._get_exporter(\n+            file=file,\n+            format=feed['format'],\n+            fields_to_export=feed['fields'],\n+            encoding=feed['encoding'],\n+            indent=feed['indent'],\n+        )\n+        slot = _FeedSlot(\n+            file=file,\n+            exporter=exporter,\n+            storage=storage,\n+            uri=uri,\n+            format=feed['format'],\n+            store_empty=feed['store_empty'],\n+            batch_id=batch_id,\n+            template_uri=template_uri,\n+        )\n+        if slot.store_empty:\n+            slot.start_exporting()\n+        return slot\n+\n     def item_scraped(self, item, spider):\n-        for slot in self.slots:\n+        slots = []\n+        for idx, slot in enumerate(self.slots):\n             slot.start_exporting()\n             slot.exporter.export_item(item)\n             slot.itemcount += 1\n+            # create new slot for each slot with itemcount == FEED_STORAGE_BATCH_SIZE and close the old one\n+            if self.storage_batch_size and slot.itemcount == self.storage_batch_size:\n+                uri_params = self._get_uri_params(spider, self.feeds[slot.template_uri]['uri_params'], slot)\n+                self._close_slot(slot, spider)\n+                slots.append(self._start_new_batch(\n+                    batch_id=slot.batch_id + 1,\n+                    uri=slot.template_uri % uri_params,\n+                    feed=self.feeds[slot.template_uri],\n+                    spider=spider,\n+                    template_uri=slot.template_uri,\n+                ))\n+                self.slots[idx] = None\n+        self.slots = [slot for slot in self.slots if slot is not None]\n+        self.slots.extend(slots)",
      "comment": "I think this can be simplified a bit:\r\n\r\n```suggestion\r\n                slot = self._start_new_batch(\r\n                    batch_id=slot.batch_id + 1,\r\n                    uri=slot.template_uri % uri_params,\r\n                    feed=self.feeds[slot.template_uri],\r\n                    spider=spider,\r\n                    template_uri=slot.template_uri,\r\n                )\r\n            slots.append(slot)\r\n        self.slots = slots\r\n```",
      "comment_id": 424004574,
      "user": "Gallaecio",
      "created_at": "2020-05-12T20:12:03Z",
      "url": "https://github.com/scrapy/scrapy/pull/4434#discussion_r424004574"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 4434,
      "file_path": "scrapy/extensions/feedexport.py",
      "line": 183,
      "side": "RIGHT",
      "diff_hunk": "@@ -180,14 +180,16 @@ def _store_in_thread(self, file):\n \n \n class _FeedSlot:\n-    def __init__(self, file, exporter, storage, uri, format, store_empty):\n+    def __init__(self, file, exporter, storage, uri, format, store_empty, batch_id, template_uri):",
      "comment": "I think `uri_template` would be more accurate, it\u2019s the template of a URI, not the URI of a template.",
      "comment_id": 425795251,
      "user": "Gallaecio",
      "created_at": "2020-05-15T13:18:28Z",
      "url": "https://github.com/scrapy/scrapy/pull/4434#discussion_r425795251"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 4434,
      "file_path": "scrapy/extensions/feedexport.py",
      "line": 246,
      "side": "RIGHT",
      "diff_hunk": "@@ -241,55 +243,104 @@ def __init__(self, crawler):\n \n         self.storages = self._load_components('FEED_STORAGES')\n         self.exporters = self._load_components('FEED_EXPORTERS')\n+        self.storage_batch_size = self.settings.get('FEED_STORAGE_BATCH_ITEM_COUNT', None)",
      "comment": "For consistency:\r\n```suggestion\r\n        self.storage_batch_item_count = self.settings.get('FEED_STORAGE_BATCH_ITEM_COUNT', None)\r\n```",
      "comment_id": 425945523,
      "user": "Gallaecio",
      "created_at": "2020-05-15T17:27:17Z",
      "url": "https://github.com/scrapy/scrapy/pull/4434#discussion_r425945523"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 4434,
      "file_path": "scrapy/extensions/feedexport.py",
      "line": 250,
      "side": "RIGHT",
      "diff_hunk": "@@ -241,55 +243,104 @@ def __init__(self, crawler):\n \n         self.storages = self._load_components('FEED_STORAGES')\n         self.exporters = self._load_components('FEED_EXPORTERS')\n+        self.storage_batch_size = self.settings.get('FEED_STORAGE_BATCH_ITEM_COUNT', None)\n         for uri, feed in self.feeds.items():\n             if not self._storage_supported(uri):\n                 raise NotConfigured\n+            if not self._batch_deliveries_supported(uri):",
      "comment": "We are not checking if batch deliveries are supported. We are checking if the setting values affecting batch deliveries are consistent. So you can change the method name to something more in that line.\r\n\r\nYou may not even have to make it specific to batch deliveries, you could give the method a generic name in the line of `_settings_are_valid` or `_options_are_valid`. In the future we can also pass the `feed` variable to that method and use it to check the validity of several options and settings.",
      "comment_id": 425950268,
      "user": "Gallaecio",
      "created_at": "2020-05-15T17:36:40Z",
      "url": "https://github.com/scrapy/scrapy/pull/4434#discussion_r425950268"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 4434,
      "file_path": "scrapy/extensions/feedexport.py",
      "line": 365,
      "side": "RIGHT",
      "diff_hunk": "@@ -306,6 +357,16 @@ def _exporter_supported(self, format):\n             return True\n         logger.error(\"Unknown feed format: %(format)s\", {'format': format})\n \n+    def _batch_deliveries_supported(self, uri):\n+        \"\"\"\n+        If FEED_STORAGE_BATCH_ITEM_COUNT setting is specified uri has to contain %(batch_time)s or %(batch_id)s\n+        to distinguish different files of partial output\n+        \"\"\"\n+        if self.storage_batch_size is None or '%(batch_time)s' in uri or '%(batch_id)s' in uri:",
      "comment": "To support `0` as well:\r\n\r\n```suggestion\r\n        if not self.storage_batch_size or '%(batch_time)s' in uri or '%(batch_id)s' in uri:\r\n```",
      "comment_id": 425952136,
      "user": "Gallaecio",
      "created_at": "2020-05-15T17:40:19Z",
      "url": "https://github.com/scrapy/scrapy/pull/4434#discussion_r425952136"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 4434,
      "file_path": "tests/test_feedexport.py",
      "line": 619,
      "side": "RIGHT",
      "diff_hunk": "@@ -601,7 +616,7 @@ def test_export_no_items_not_store_empty(self):\n                 },\n             }\n             data = yield self.exported_no_data(settings)\n-            self.assertEqual(data[fmt], b'')\n+            self.assertEqual(b'', data[fmt])",
      "comment": "Was there a reason for this change? :slightly_smiling_face: ",
      "comment_id": 425955825,
      "user": "Gallaecio",
      "created_at": "2020-05-15T17:47:30Z",
      "url": "https://github.com/scrapy/scrapy/pull/4434#discussion_r425955825"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 4434,
      "file_path": "tests/test_feedexport.py",
      "line": 989,
      "side": "RIGHT",
      "diff_hunk": "@@ -969,3 +984,341 @@ def test_pathlib_uri(self):\n         }\n         data = yield self.exported_no_data(settings)\n         self.assertEqual(data['csv'], b'')\n+\n+\n+class PartialDeliveriesTest(FeedExportTestBase):",
      "comment": "Here and in a few other parts of the code it says \u201cpartial\u201d; \u201dbatch\u201d is more consistent with the rest of the code, and more unambiguous (\u201cpartial\u201d may be interpreted as not delivering all data).\r\n\r\n```suggestion\r\nclass BatchDeliveriesTest(FeedExportTestBase):\r\n```",
      "comment_id": 425956446,
      "user": "Gallaecio",
      "created_at": "2020-05-15T17:48:36Z",
      "url": "https://github.com/scrapy/scrapy/pull/4434#discussion_r425956446"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 4434,
      "file_path": "tests/test_feedexport.py",
      "line": 619,
      "side": "RIGHT",
      "diff_hunk": "@@ -601,7 +616,7 @@ def test_export_no_items_not_store_empty(self):\n                 },\n             }\n             data = yield self.exported_no_data(settings)\n-            self.assertEqual(data[fmt], b'')\n+            self.assertEqual(b'', data[fmt])",
      "comment": "I saw such tox error output: \"expected != got\" or something like this, so I supposed that first value was considered as expected, second - got. For some reason, I can't reproduce such output now.",
      "comment_id": 426006112,
      "user": "BroodingKangaroo",
      "created_at": "2020-05-15T19:30:11Z",
      "url": "https://github.com/scrapy/scrapy/pull/4434#discussion_r426006112"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 4434,
      "file_path": "scrapy/extensions/feedexport.py",
      "line": 367,
      "side": "RIGHT",
      "diff_hunk": "@@ -306,6 +357,16 @@ def _exporter_supported(self, format):\n             return True\n         logger.error(\"Unknown feed format: %(format)s\", {'format': format})\n \n+    def _settings_are_valid(self, uri):\n+        \"\"\"\n+        If FEED_STORAGE_BATCH_ITEM_COUNT setting is specified uri has to contain %(batch_time)s or %(batch_id)s\n+        to distinguish different files of partial output\n+        \"\"\"\n+        if not self.storage_batch_item_count or '%(batch_time)s' in uri or '%(batch_id)s' in uri:\n+            return True\n+        logger.warning('%(batch_time)s or %(batch_id)s must be in uri if FEED_STORAGE_BATCH_ITEM_COUNT setting is specified')",
      "comment": "```suggestion\r\n        logger.error('%(batch_time)s or %(batch_id)s must be in uri if FEED_STORAGE_BATCH_ITEM_COUNT setting is specified')\r\n```\r\n\r\n`_exporter_supported` and `_storage_supported` both log it as an error, and since the result if the feed export being disabled, I guess it makes sense.",
      "comment_id": 426762216,
      "user": "Gallaecio",
      "created_at": "2020-05-18T16:47:14Z",
      "url": "https://github.com/scrapy/scrapy/pull/4434#discussion_r426762216"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 4434,
      "file_path": "scrapy/extensions/feedexport.py",
      "line": 402,
      "side": "RIGHT",
      "diff_hunk": "@@ -331,12 +394,13 @@ def _get_exporter(self, file, format, *args, **kwargs):\n     def _get_storage(self, uri):\n         return self._get_instance(self.storages[urlparse(uri).scheme], uri)\n \n-    def _get_uri_params(self, spider, uri_params):\n+    def _get_uri_params(self, spider, uri_params, slot):\n         params = {}\n         for k in dir(spider):\n             params[k] = getattr(spider, k)\n-        ts = datetime.utcnow().replace(microsecond=0).isoformat().replace(':', '-')\n-        params['time'] = ts\n+        params['time'] = datetime.utcnow().replace(microsecond=0).isoformat().replace(':', '-')\n+        params['batch_time'] = datetime.utcnow().isoformat().replace(':', '-')",
      "comment": "What do you think about calling  datetime.utcnow() once? Otherwise the results may be different.",
      "comment_id": 429412156,
      "user": "kmike",
      "created_at": "2020-05-22T19:06:37Z",
      "url": "https://github.com/scrapy/scrapy/pull/4434#discussion_r429412156"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 4434,
      "file_path": "scrapy/extensions/feedexport.py",
      "line": 246,
      "side": "RIGHT",
      "diff_hunk": "@@ -241,55 +243,104 @@ def __init__(self, crawler):\n \n         self.storages = self._load_components('FEED_STORAGES')\n         self.exporters = self._load_components('FEED_EXPORTERS')\n+        self.storage_batch_item_count = self.settings.get('FEED_STORAGE_BATCH_ITEM_COUNT', None)",
      "comment": "Would it be possible to have batch_item_count support in FEEDS setting?",
      "comment_id": 429413882,
      "user": "kmike",
      "created_at": "2020-05-22T19:11:18Z",
      "url": "https://github.com/scrapy/scrapy/pull/4434#discussion_r429413882"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 4434,
      "file_path": "scrapy/extensions/feedexport.py",
      "line": 402,
      "side": "RIGHT",
      "diff_hunk": "@@ -331,12 +394,13 @@ def _get_exporter(self, file, format, *args, **kwargs):\n     def _get_storage(self, uri):\n         return self._get_instance(self.storages[urlparse(uri).scheme], uri)\n \n-    def _get_uri_params(self, spider, uri_params):\n+    def _get_uri_params(self, spider, uri_params, slot):\n         params = {}\n         for k in dir(spider):\n             params[k] = getattr(spider, k)\n-        ts = datetime.utcnow().replace(microsecond=0).isoformat().replace(':', '-')\n-        params['time'] = ts\n+        params['time'] = datetime.utcnow().replace(microsecond=0).isoformat().replace(':', '-')\n+        params['batch_time'] = datetime.utcnow().isoformat().replace(':', '-')",
      "comment": "I guess it is very unlikely but there is no need to test our fortune =).\r\nThank you.",
      "comment_id": 429417743,
      "user": "BroodingKangaroo",
      "created_at": "2020-05-22T19:20:19Z",
      "url": "https://github.com/scrapy/scrapy/pull/4434#discussion_r429417743"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 4434,
      "file_path": "scrapy/extensions/feedexport.py",
      "line": 246,
      "side": "RIGHT",
      "diff_hunk": "@@ -241,55 +243,104 @@ def __init__(self, crawler):\n \n         self.storages = self._load_components('FEED_STORAGES')\n         self.exporters = self._load_components('FEED_EXPORTERS')\n+        self.storage_batch_item_count = self.settings.get('FEED_STORAGE_BATCH_ITEM_COUNT', None)",
      "comment": "I guess so. Should I do it in this PR or it is already overwhelmed?",
      "comment_id": 429428453,
      "user": "BroodingKangaroo",
      "created_at": "2020-05-22T19:50:54Z",
      "url": "https://github.com/scrapy/scrapy/pull/4434#discussion_r429428453"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 4434,
      "file_path": "scrapy/extensions/feedexport.py",
      "line": 246,
      "side": "RIGHT",
      "diff_hunk": "@@ -241,55 +243,104 @@ def __init__(self, crawler):\n \n         self.storages = self._load_components('FEED_STORAGES')\n         self.exporters = self._load_components('FEED_EXPORTERS')\n+        self.storage_batch_item_count = self.settings.get('FEED_STORAGE_BATCH_ITEM_COUNT', None)",
      "comment": "It would be great if we could have it as part of this pull request.",
      "comment_id": 433039589,
      "user": "Gallaecio",
      "created_at": "2020-06-01T04:48:03Z",
      "url": "https://github.com/scrapy/scrapy/pull/4434#discussion_r433039589"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 4434,
      "file_path": "scrapy/extensions/feedexport.py",
      "line": 246,
      "side": "RIGHT",
      "diff_hunk": "@@ -241,55 +243,104 @@ def __init__(self, crawler):\n \n         self.storages = self._load_components('FEED_STORAGES')\n         self.exporters = self._load_components('FEED_EXPORTERS')\n+        self.storage_batch_item_count = self.settings.get('FEED_STORAGE_BATCH_ITEM_COUNT', None)",
      "comment": "```suggestion\r\n        self.storage_batch_item_count = self.settings.getint('FEED_STORAGE_BATCH_ITEM_COUNT')\r\n```",
      "comment_id": 442278645,
      "user": "victor-torres",
      "created_at": "2020-06-18T14:39:49Z",
      "url": "https://github.com/scrapy/scrapy/pull/4434#discussion_r442278645"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 4434,
      "file_path": "scrapy/settings/default_settings.py",
      "line": 149,
      "side": "RIGHT",
      "diff_hunk": "@@ -146,6 +146,7 @@\n     's3': 'scrapy.extensions.feedexport.S3FeedStorage',\n     'ftp': 'scrapy.extensions.feedexport.FTPFeedStorage',\n }\n+FEED_STORAGE_BATCH_ITEM_COUNT = None",
      "comment": "```suggestion\r\nFEED_STORAGE_BATCH_ITEM_COUNT = 0\r\n```",
      "comment_id": 442284464,
      "user": "victor-torres",
      "created_at": "2020-06-18T14:47:36Z",
      "url": "https://github.com/scrapy/scrapy/pull/4434#discussion_r442284464"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 4434,
      "file_path": "tests/test_feedexport.py",
      "line": 1036,
      "side": "RIGHT",
      "diff_hunk": "@@ -978,3 +993,349 @@ def test_pathlib_uri(self):\n         }\n         data = yield self.exported_no_data(settings)\n         self.assertEqual(data['csv'], b'')\n+\n+\n+class BatchDeliveriesTest(FeedExportTestBase):\n+    __test__ = True\n+    _file_mark = '_%(batch_time)s_#%(batch_id)s_'\n+\n+    @defer.inlineCallbacks\n+    def run_and_export(self, spider_cls, settings):\n+        \"\"\" Run spider with specified settings; return exported data. \"\"\"\n+\n+        FEEDS = settings.get('FEEDS') or {}\n+        settings['FEEDS'] = {\n+            urljoin('file:', file_path): feed\n+            for file_path, feed in FEEDS.items()\n+        }\n+        content = defaultdict(list)\n+        try:\n+            with MockServer() as s:\n+                runner = CrawlerRunner(Settings(settings))\n+                spider_cls.start_urls = [s.url('/')]\n+                yield runner.crawl(spider_cls)\n+\n+            for path, feed in FEEDS.items():\n+                dir_name = os.path.dirname(path)\n+                for file in sorted(os.listdir(dir_name)):\n+                    with open(os.path.join(dir_name, file), 'rb') as f:\n+                        data = f.read()\n+                        content[feed['format']].append(data)\n+        finally:\n+            self.tearDown()\n+        defer.returnValue(content)\n+\n+    @defer.inlineCallbacks\n+    def assertExportedJsonLines(self, items, rows, settings=None):\n+        settings = settings or {}\n+        settings.update({\n+            'FEEDS': {\n+                os.path.join(self._random_temp_filename(), 'jl', self._file_mark): {'format': 'jl'},\n+            },\n+        })\n+        batch_size = settings['FEED_STORAGE_BATCH_ITEM_COUNT']",
      "comment": "Should we use `BaseSettings.getint` here (and in other occurrences in this test file)? Or does it make sense to stick to the current approach?\r\n\r\n```suggestion\r\n        batch_size = settings.getint('FEED_STORAGE_BATCH_ITEM_COUNT')\r\n```",
      "comment_id": 442285927,
      "user": "victor-torres",
      "created_at": "2020-06-18T14:49:27Z",
      "url": "https://github.com/scrapy/scrapy/pull/4434#discussion_r442285927"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 4434,
      "file_path": "scrapy/extensions/feedexport.py",
      "line": 28,
      "side": "RIGHT",
      "diff_hunk": "@@ -25,7 +25,6 @@\n from scrapy.utils.misc import create_instance, load_object\n from scrapy.utils.python import without_none_values\n \n-\n logger = logging.getLogger(__name__)",
      "comment": "Hi, could you bring the empty line that was above the logger back? it should be 2 empty lines between imports and the code itself, It has now only one, thanks.",
      "comment_id": 446676616,
      "user": "rafaelcapucho",
      "created_at": "2020-06-28T17:30:22Z",
      "url": "https://github.com/scrapy/scrapy/pull/4434#discussion_r446676616"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 4434,
      "file_path": "scrapy/extensions/feedexport.py",
      "line": 28,
      "side": "RIGHT",
      "diff_hunk": "@@ -25,7 +25,6 @@\n from scrapy.utils.misc import create_instance, load_object\n from scrapy.utils.python import without_none_values\n \n-\n logger = logging.getLogger(__name__)",
      "comment": "Hi. Of course. I don't know why but any time I am trying to reformat code using PyCharm it deletes that line. This time I forgot to bring it back.",
      "comment_id": 446685533,
      "user": "BroodingKangaroo",
      "created_at": "2020-06-28T18:58:42Z",
      "url": "https://github.com/scrapy/scrapy/pull/4434#discussion_r446685533"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 4434,
      "file_path": "scrapy/extensions/feedexport.py",
      "line": 245,
      "side": "RIGHT",
      "diff_hunk": "@@ -241,66 +242,115 @@ def __init__(self, crawler):\n \n         self.storages = self._load_components('FEED_STORAGES')\n         self.exporters = self._load_components('FEED_EXPORTERS')\n+        self.storage_batch_item_count = self.settings.getint('FEED_STORAGE_BATCH_ITEM_COUNT')",
      "comment": "Instead of doing this here, please update [`scrapy.utils.conf.feed_complete_default_values_from_settings`](https://github.com/scrapy/scrapy/blob/2.2.0/scrapy/utils/conf.py#L114). That would simplify the `if` at line 339.",
      "comment_id": 446725481,
      "user": "elacuesta",
      "created_at": "2020-06-29T01:14:32Z",
      "url": "https://github.com/scrapy/scrapy/pull/4434#discussion_r446725481"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 4434,
      "file_path": "scrapy/extensions/feedexport.py",
      "line": 341,
      "side": "RIGHT",
      "diff_hunk": "@@ -241,66 +242,115 @@ def __init__(self, crawler):\n \n         self.storages = self._load_components('FEED_STORAGES')\n         self.exporters = self._load_components('FEED_EXPORTERS')\n+        self.storage_batch_item_count = self.settings.getint('FEED_STORAGE_BATCH_ITEM_COUNT')\n         for uri, feed in self.feeds.items():\n             if not self._storage_supported(uri):\n                 raise NotConfigured\n+            if not self._settings_are_valid(uri):\n+                raise NotConfigured\n             if not self._exporter_supported(feed['format']):\n                 raise NotConfigured\n \n     def open_spider(self, spider):\n         for uri, feed in self.feeds.items():\n-            uri = uri % self._get_uri_params(spider, feed['uri_params'])\n-            storage = self._get_storage(uri)\n-            file = storage.open(spider)\n-            exporter = self._get_exporter(\n-                file=file,\n-                format=feed['format'],\n-                fields_to_export=feed['fields'],\n-                encoding=feed['encoding'],\n-                indent=feed['indent'],\n-            )\n-            slot = _FeedSlot(file, exporter, storage, uri, feed['format'], feed['store_empty'])\n-            self.slots.append(slot)\n-            if slot.store_empty:\n-                slot.start_exporting()\n+            uri_params = self._get_uri_params(spider, feed['uri_params'], None)\n+            self.slots.append(self._start_new_batch(\n+                batch_id=1,\n+                uri=uri % uri_params,\n+                feed=feed,\n+                spider=spider,\n+                uri_template=uri,\n+            ))\n \n     def close_spider(self, spider):\n         deferred_list = []\n         for slot in self.slots:\n-            if not slot.itemcount and not slot.store_empty:\n-                # We need to call slot.storage.store nonetheless to get the file\n-                # properly closed.\n-                d = defer.maybeDeferred(slot.storage.store, slot.file)\n-                deferred_list.append(d)\n-                continue\n-            slot.finish_exporting()\n-            logfmt = \"%s %%(format)s feed (%%(itemcount)d items) in: %%(uri)s\"\n-            log_args = {'format': slot.format,\n-                        'itemcount': slot.itemcount,\n-                        'uri': slot.uri}\n-            d = defer.maybeDeferred(slot.storage.store, slot.file)\n-\n-            # Use `largs=log_args` to copy log_args into function's scope\n-            # instead of using `log_args` from the outer scope\n-            d.addCallback(\n-                lambda _, largs=log_args: logger.info(\n-                    logfmt % \"Stored\", largs, extra={'spider': spider}\n-                )\n-            )\n-            d.addErrback(\n-                lambda f, largs=log_args: logger.error(\n-                    logfmt % \"Error storing\", largs,\n-                    exc_info=failure_to_exc_info(f), extra={'spider': spider}\n-                )\n-            )\n+            d = self._close_slot(slot, spider)\n             deferred_list.append(d)\n         return defer.DeferredList(deferred_list) if deferred_list else None\n \n+    def _close_slot(self, slot, spider):\n+        if not slot.itemcount and not slot.store_empty:\n+            # We need to call slot.storage.store nonetheless to get the file\n+            # properly closed.\n+            return defer.maybeDeferred(slot.storage.store, slot.file)\n+        slot.finish_exporting()\n+        logfmt = \"%s %%(format)s feed (%%(itemcount)d items) in: %%(uri)s\"\n+        log_args = {'format': slot.format,\n+                    'itemcount': slot.itemcount,\n+                    'uri': slot.uri}\n+        d = defer.maybeDeferred(slot.storage.store, slot.file)\n+\n+        # Use `largs=log_args` to copy log_args into function's scope\n+        # instead of using `log_args` from the outer scope\n+        d.addCallback(\n+            lambda _, largs=log_args: logger.info(\n+                logfmt % \"Stored\", largs, extra={'spider': spider}\n+            )\n+        )\n+        d.addErrback(\n+            lambda f, largs=log_args: logger.error(\n+                logfmt % \"Error storing\", largs,\n+                exc_info=failure_to_exc_info(f), extra={'spider': spider}\n+            )\n+        )\n+        return d\n+\n+    def _start_new_batch(self, batch_id, uri, feed, spider, uri_template):\n+        \"\"\"\n+        Redirect the output data stream to a new file.\n+        Execute multiple times if 'FEED_STORAGE_BATCH_ITEM_COUNT' setting is specified.\n+        :param batch_id: sequence number of current batch\n+        :param uri: uri of the new batch to start\n+        :param feed: dict with parameters of feed\n+        :param spider: user spider\n+        :param uri_template: template of uri which contains %(batch_time)s or %(batch_id)s to create new uri\n+        \"\"\"\n+        storage = self._get_storage(uri)\n+        file = storage.open(spider)\n+        exporter = self._get_exporter(\n+            file=file,\n+            format=feed['format'],\n+            fields_to_export=feed['fields'],\n+            encoding=feed['encoding'],\n+            indent=feed['indent'],\n+        )\n+        slot = _FeedSlot(\n+            file=file,\n+            exporter=exporter,\n+            storage=storage,\n+            uri=uri,\n+            format=feed['format'],\n+            store_empty=feed['store_empty'],\n+            batch_id=batch_id,\n+            uri_template=uri_template,\n+        )\n+        if slot.store_empty:\n+            slot.start_exporting()\n+        return slot\n+\n     def item_scraped(self, item, spider):\n-        for slot in self.slots:\n+        slots = []\n+        for idx, slot in enumerate(self.slots):\n             slot.start_exporting()\n             slot.exporter.export_item(item)\n             slot.itemcount += 1\n+            # create new slot for each slot with itemcount == FEED_STORAGE_BATCH_ITEM_COUNT and close the old one\n+            if self.feeds[slot.uri_template].get('batch_item_count', self.storage_batch_item_count) \\\n+                    and slot.itemcount == self.feeds[slot.uri_template].get('batch_item_count',\n+                                                                            self.storage_batch_item_count):",
      "comment": "```suggestion\r\n            if (\r\n                self.feeds[slot.uri_template]['batch_item_count']\r\n                and slot.itemcount >= self.feeds[slot.uri_template]['batch_item_count']\r\n            ):\r\n```\r\n\r\nThis simplification works after applying the above suggestion about updating `scrapy.utils.conf.feed_complete_default_values_from_settings`.\r\n\r\nAlso, notice the change from `==` to `>=`: if something goes wrong during the closing of the current batch, it could happen that the slot item count keeps being incremented and never reaches the batch size. I'm not sure I'm being clear, I'm also not sure that could happen in this case but I think it's safer anyway. I was bitten by an error caused by this recently and it's still fresh in my memory.",
      "comment_id": 446728805,
      "user": "elacuesta",
      "created_at": "2020-06-29T01:33:17Z",
      "url": "https://github.com/scrapy/scrapy/pull/4434#discussion_r446728805"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 4434,
      "file_path": "scrapy/extensions/feedexport.py",
      "line": 334,
      "side": "RIGHT",
      "diff_hunk": "@@ -241,66 +242,115 @@ def __init__(self, crawler):\n \n         self.storages = self._load_components('FEED_STORAGES')\n         self.exporters = self._load_components('FEED_EXPORTERS')\n+        self.storage_batch_item_count = self.settings.getint('FEED_STORAGE_BATCH_ITEM_COUNT')\n         for uri, feed in self.feeds.items():\n             if not self._storage_supported(uri):\n                 raise NotConfigured\n+            if not self._settings_are_valid(uri):\n+                raise NotConfigured\n             if not self._exporter_supported(feed['format']):\n                 raise NotConfigured\n \n     def open_spider(self, spider):\n         for uri, feed in self.feeds.items():\n-            uri = uri % self._get_uri_params(spider, feed['uri_params'])\n-            storage = self._get_storage(uri)\n-            file = storage.open(spider)\n-            exporter = self._get_exporter(\n-                file=file,\n-                format=feed['format'],\n-                fields_to_export=feed['fields'],\n-                encoding=feed['encoding'],\n-                indent=feed['indent'],\n-            )\n-            slot = _FeedSlot(file, exporter, storage, uri, feed['format'], feed['store_empty'])\n-            self.slots.append(slot)\n-            if slot.store_empty:\n-                slot.start_exporting()\n+            uri_params = self._get_uri_params(spider, feed['uri_params'], None)\n+            self.slots.append(self._start_new_batch(\n+                batch_id=1,\n+                uri=uri % uri_params,\n+                feed=feed,\n+                spider=spider,\n+                uri_template=uri,\n+            ))\n \n     def close_spider(self, spider):\n         deferred_list = []\n         for slot in self.slots:\n-            if not slot.itemcount and not slot.store_empty:\n-                # We need to call slot.storage.store nonetheless to get the file\n-                # properly closed.\n-                d = defer.maybeDeferred(slot.storage.store, slot.file)\n-                deferred_list.append(d)\n-                continue\n-            slot.finish_exporting()\n-            logfmt = \"%s %%(format)s feed (%%(itemcount)d items) in: %%(uri)s\"\n-            log_args = {'format': slot.format,\n-                        'itemcount': slot.itemcount,\n-                        'uri': slot.uri}\n-            d = defer.maybeDeferred(slot.storage.store, slot.file)\n-\n-            # Use `largs=log_args` to copy log_args into function's scope\n-            # instead of using `log_args` from the outer scope\n-            d.addCallback(\n-                lambda _, largs=log_args: logger.info(\n-                    logfmt % \"Stored\", largs, extra={'spider': spider}\n-                )\n-            )\n-            d.addErrback(\n-                lambda f, largs=log_args: logger.error(\n-                    logfmt % \"Error storing\", largs,\n-                    exc_info=failure_to_exc_info(f), extra={'spider': spider}\n-                )\n-            )\n+            d = self._close_slot(slot, spider)\n             deferred_list.append(d)\n         return defer.DeferredList(deferred_list) if deferred_list else None\n \n+    def _close_slot(self, slot, spider):\n+        if not slot.itemcount and not slot.store_empty:\n+            # We need to call slot.storage.store nonetheless to get the file\n+            # properly closed.\n+            return defer.maybeDeferred(slot.storage.store, slot.file)\n+        slot.finish_exporting()\n+        logfmt = \"%s %%(format)s feed (%%(itemcount)d items) in: %%(uri)s\"\n+        log_args = {'format': slot.format,\n+                    'itemcount': slot.itemcount,\n+                    'uri': slot.uri}\n+        d = defer.maybeDeferred(slot.storage.store, slot.file)\n+\n+        # Use `largs=log_args` to copy log_args into function's scope\n+        # instead of using `log_args` from the outer scope\n+        d.addCallback(\n+            lambda _, largs=log_args: logger.info(\n+                logfmt % \"Stored\", largs, extra={'spider': spider}\n+            )\n+        )\n+        d.addErrback(\n+            lambda f, largs=log_args: logger.error(\n+                logfmt % \"Error storing\", largs,\n+                exc_info=failure_to_exc_info(f), extra={'spider': spider}\n+            )\n+        )\n+        return d\n+\n+    def _start_new_batch(self, batch_id, uri, feed, spider, uri_template):\n+        \"\"\"\n+        Redirect the output data stream to a new file.\n+        Execute multiple times if 'FEED_STORAGE_BATCH_ITEM_COUNT' setting is specified.\n+        :param batch_id: sequence number of current batch\n+        :param uri: uri of the new batch to start\n+        :param feed: dict with parameters of feed\n+        :param spider: user spider\n+        :param uri_template: template of uri which contains %(batch_time)s or %(batch_id)s to create new uri\n+        \"\"\"\n+        storage = self._get_storage(uri)\n+        file = storage.open(spider)\n+        exporter = self._get_exporter(\n+            file=file,\n+            format=feed['format'],\n+            fields_to_export=feed['fields'],\n+            encoding=feed['encoding'],\n+            indent=feed['indent'],\n+        )\n+        slot = _FeedSlot(\n+            file=file,\n+            exporter=exporter,\n+            storage=storage,\n+            uri=uri,\n+            format=feed['format'],\n+            store_empty=feed['store_empty'],\n+            batch_id=batch_id,\n+            uri_template=uri_template,\n+        )\n+        if slot.store_empty:\n+            slot.start_exporting()\n+        return slot\n+\n     def item_scraped(self, item, spider):\n-        for slot in self.slots:\n+        slots = []\n+        for idx, slot in enumerate(self.slots):",
      "comment": "Seems like the `enumerate` call is a remnant from a previous implementation, could you revert it?",
      "comment_id": 446728962,
      "user": "elacuesta",
      "created_at": "2020-06-29T01:34:16Z",
      "url": "https://github.com/scrapy/scrapy/pull/4434#discussion_r446728962"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 4434,
      "file_path": "scrapy/extensions/feedexport.py",
      "line": 378,
      "side": "RIGHT",
      "diff_hunk": "@@ -317,6 +367,18 @@ def _exporter_supported(self, format):\n             return True\n         logger.error(\"Unknown feed format: %(format)s\", {'format': format})\n \n+    def _settings_are_valid(self, uri):\n+        \"\"\"\n+        If FEED_STORAGE_BATCH_ITEM_COUNT setting is specified uri has to contain %(batch_time)s or %(batch_id)s\n+        to distinguish different files of partial output\n+        \"\"\"\n+        if not self.storage_batch_item_count or '%(batch_time)s' in uri or '%(batch_id)s' in uri:\n+            return True\n+        logger.error(\n+            '%(batch_time)s or %(batch_id)s must be in uri if FEED_STORAGE_BATCH_ITEM_COUNT setting is specified'",
      "comment": "This message might need an update to reflect that fact that the batch size could come from `FEEDS.batch_item_count`.",
      "comment_id": 446729355,
      "user": "elacuesta",
      "created_at": "2020-06-29T01:36:05Z",
      "url": "https://github.com/scrapy/scrapy/pull/4434#discussion_r446729355"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 4434,
      "file_path": "scrapy/extensions/feedexport.py",
      "line": 256,
      "side": "RIGHT",
      "diff_hunk": "@@ -241,66 +242,115 @@ def __init__(self, crawler):\n \n         self.storages = self._load_components('FEED_STORAGES')\n         self.exporters = self._load_components('FEED_EXPORTERS')\n+        self.storage_batch_item_count = self.settings.getint('FEED_STORAGE_BATCH_ITEM_COUNT')\n         for uri, feed in self.feeds.items():\n             if not self._storage_supported(uri):\n                 raise NotConfigured\n+            if not self._settings_are_valid(uri):\n+                raise NotConfigured\n             if not self._exporter_supported(feed['format']):\n                 raise NotConfigured\n \n     def open_spider(self, spider):\n         for uri, feed in self.feeds.items():\n-            uri = uri % self._get_uri_params(spider, feed['uri_params'])\n-            storage = self._get_storage(uri)\n-            file = storage.open(spider)\n-            exporter = self._get_exporter(\n-                file=file,\n-                format=feed['format'],\n-                fields_to_export=feed['fields'],\n-                encoding=feed['encoding'],\n-                indent=feed['indent'],\n-            )\n-            slot = _FeedSlot(file, exporter, storage, uri, feed['format'], feed['store_empty'])\n-            self.slots.append(slot)\n-            if slot.store_empty:\n-                slot.start_exporting()\n+            uri_params = self._get_uri_params(spider, feed['uri_params'], None)",
      "comment": "I think it would be better to set `None` as default value for `slot` in `_get_uri_params` .",
      "comment_id": 446733210,
      "user": "elacuesta",
      "created_at": "2020-06-29T01:56:21Z",
      "url": "https://github.com/scrapy/scrapy/pull/4434#discussion_r446733210"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 4434,
      "file_path": "scrapy/extensions/feedexport.py",
      "line": 28,
      "side": "RIGHT",
      "diff_hunk": "@@ -25,7 +25,6 @@\n from scrapy.utils.misc import create_instance, load_object\n from scrapy.utils.python import without_none_values\n \n-\n logger = logging.getLogger(__name__)",
      "comment": "Hey, @rafaelcapucho, I've just come across this comment and figured out PyCharm is doing the same thing to my code. I've decided to check the PEP 8 and this is what it says regarding [Blank Lines](https://www.python.org/dev/peps/pep-0008/#blank-lines):\r\n\r\n> Surround top-level function and class definitions with two blank lines.\r\n>\r\n> Method definitions inside a class are surrounded by a single blank line.\r\n>\r\n> Extra blank lines may be used (sparingly) to separate groups of related functions. Blank lines may be omitted between a bunch of related one-liners (e.g. a set of dummy implementations).\r\n> \r\n> Use blank lines in functions, sparingly, to indicate logical sections.\r\n>\r\n> Python accepts the control-L (i.e. ^L) form feed character as whitespace; Many tools treat these characters as page separators, so you may use them to separate pages of related sections of your file. Note, some editors and web-based code viewers may not recognize control-L as a form feed and will show another glyph in its place.\r\n\r\nSince this is not a top-level function or class definition, I don't think it's mandatory to surround it with two blank lines. \r\n\r\nDo you have another source or is it something related to Scrapy development guidelines itself?",
      "comment_id": 447356604,
      "user": "victor-torres",
      "created_at": "2020-06-30T01:38:27Z",
      "url": "https://github.com/scrapy/scrapy/pull/4434#discussion_r447356604"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 4434,
      "file_path": "scrapy/extensions/feedexport.py",
      "line": 28,
      "side": "RIGHT",
      "diff_hunk": "@@ -25,7 +25,6 @@\n from scrapy.utils.misc import create_instance, load_object\n from scrapy.utils.python import without_none_values\n \n-\n logger = logging.getLogger(__name__)",
      "comment": "The [convention](https://stackoverflow.com/a/2953268/939364) is to keep two blank lines between imports and the rest of the code. I think it makes sense, as you already use a single blank line to separate different groups of imports.",
      "comment_id": 448271286,
      "user": "Gallaecio",
      "created_at": "2020-07-01T10:31:30Z",
      "url": "https://github.com/scrapy/scrapy/pull/4434#discussion_r448271286"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 4434,
      "file_path": "scrapy/utils/conf.py",
      "line": 121,
      "side": "RIGHT",
      "diff_hunk": "@@ -115,6 +115,10 @@ def feed_complete_default_values_from_settings(feed, settings):\n     out = feed.copy()\n     out.setdefault(\"encoding\", settings[\"FEED_EXPORT_ENCODING\"])\n     out.setdefault(\"fields\", settings.getlist(\"FEED_EXPORT_FIELDS\") or None)\n+    out.setdefault(\n+        \"batch_item_count\",\n+        out.get('batch_item_count', settings.getint('FEED_STORAGE_BATCH_ITEM_COUNT'))\n+    )",
      "comment": "```suggestion\r\n    out.setdefault(\"batch_item_count\", settings.getint('FEED_STORAGE_BATCH_ITEM_COUNT'))\r\n```\r\n\r\nNo need to check for the presence of a current value, `setdefault` will act only if it's missing.",
      "comment_id": 448316216,
      "user": "elacuesta",
      "created_at": "2020-07-01T12:04:36Z",
      "url": "https://github.com/scrapy/scrapy/pull/4434#discussion_r448316216"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 4434,
      "file_path": "scrapy/extensions/feedexport.py",
      "line": 28,
      "side": "RIGHT",
      "diff_hunk": "@@ -25,7 +25,6 @@\n from scrapy.utils.misc import create_instance, load_object\n from scrapy.utils.python import without_none_values\n \n-\n logger = logging.getLogger(__name__)",
      "comment": "> it's surrounded by two blank lines in scrapy/downloadermiddlewares/cookies.py and in scrapy/utils/signal.py\r\n\r\nI personally like two lines after imports, those two examples are on me \ud83d\ude04 \r\n\r\nI believe there are a few unwritten conventions which are not taken directly from PEP 8. For instance, @Gallaecio has been promoting alphabetically sorted imports, putting `import` lines before `from ... import` ones. I'm a big fan of [parenthesized multi-line conditions with leading logical operators](https://github.com/scrapy/scrapy/pull/4525/files#diff-115565e38381736e9e87227cb69ac0f2L64-R70).\r\n\r\nPerhaps the time has come to write all of these conventions down.",
      "comment_id": 448403969,
      "user": "elacuesta",
      "created_at": "2020-07-01T14:29:50Z",
      "url": "https://github.com/scrapy/scrapy/pull/4434#discussion_r448403969"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 4434,
      "file_path": "scrapy/extensions/feedexport.py",
      "line": 28,
      "side": "RIGHT",
      "diff_hunk": "@@ -25,7 +25,6 @@\n from scrapy.utils.misc import create_instance, load_object\n from scrapy.utils.python import without_none_values\n \n-\n logger = logging.getLogger(__name__)",
      "comment": "Sure, @elacuesta.\r\n\r\nI've created a [ticket](https://github.com/scrapy/scrapy/issues/4654) on Scrapy to continue this discussion outside this pull request.\r\n\r\n@rafaelcapucho, I'm sorry if I sounded like I was nitpicking stuff. I'm just trying to turn this into an objective style guideline, ideally automatically enforced by a code linter or at least well documented, independently of the number of blank lines we end up deciding to use.\r\n\r\nCheers!",
      "comment_id": 448645043,
      "user": "victor-torres",
      "created_at": "2020-07-01T22:18:55Z",
      "url": "https://github.com/scrapy/scrapy/pull/4434#discussion_r448645043"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 4434,
      "file_path": "scrapy/extensions/feedexport.py",
      "line": 340,
      "side": "RIGHT",
      "diff_hunk": "@@ -244,63 +245,112 @@ def __init__(self, crawler):\n         for uri, feed in self.feeds.items():\n             if not self._storage_supported(uri):\n                 raise NotConfigured\n+            if not self._settings_are_valid(uri):\n+                raise NotConfigured\n             if not self._exporter_supported(feed['format']):\n                 raise NotConfigured\n \n     def open_spider(self, spider):\n         for uri, feed in self.feeds.items():\n-            uri = uri % self._get_uri_params(spider, feed['uri_params'])\n-            storage = self._get_storage(uri)\n-            file = storage.open(spider)\n-            exporter = self._get_exporter(\n-                file=file,\n-                format=feed['format'],\n-                fields_to_export=feed['fields'],\n-                encoding=feed['encoding'],\n-                indent=feed['indent'],\n-            )\n-            slot = _FeedSlot(file, exporter, storage, uri, feed['format'], feed['store_empty'])\n-            self.slots.append(slot)\n-            if slot.store_empty:\n-                slot.start_exporting()\n+            uri_params = self._get_uri_params(spider, feed['uri_params'])\n+            self.slots.append(self._start_new_batch(\n+                batch_id=1,\n+                uri=uri % uri_params,\n+                feed=feed,\n+                spider=spider,\n+                uri_template=uri,\n+            ))\n \n     def close_spider(self, spider):\n         deferred_list = []\n         for slot in self.slots:\n-            if not slot.itemcount and not slot.store_empty:\n-                # We need to call slot.storage.store nonetheless to get the file\n-                # properly closed.\n-                d = defer.maybeDeferred(slot.storage.store, slot.file)\n-                deferred_list.append(d)\n-                continue\n-            slot.finish_exporting()\n-            logfmt = \"%s %%(format)s feed (%%(itemcount)d items) in: %%(uri)s\"\n-            log_args = {'format': slot.format,\n-                        'itemcount': slot.itemcount,\n-                        'uri': slot.uri}\n-            d = defer.maybeDeferred(slot.storage.store, slot.file)\n-\n-            # Use `largs=log_args` to copy log_args into function's scope\n-            # instead of using `log_args` from the outer scope\n-            d.addCallback(\n-                lambda _, largs=log_args: logger.info(\n-                    logfmt % \"Stored\", largs, extra={'spider': spider}\n-                )\n-            )\n-            d.addErrback(\n-                lambda f, largs=log_args: logger.error(\n-                    logfmt % \"Error storing\", largs,\n-                    exc_info=failure_to_exc_info(f), extra={'spider': spider}\n-                )\n-            )\n+            d = self._close_slot(slot, spider)\n             deferred_list.append(d)\n         return defer.DeferredList(deferred_list) if deferred_list else None\n \n+    def _close_slot(self, slot, spider):\n+        if not slot.itemcount and not slot.store_empty:\n+            # We need to call slot.storage.store nonetheless to get the file\n+            # properly closed.\n+            return defer.maybeDeferred(slot.storage.store, slot.file)\n+        slot.finish_exporting()\n+        logfmt = \"%s %%(format)s feed (%%(itemcount)d items) in: %%(uri)s\"\n+        log_args = {'format': slot.format,\n+                    'itemcount': slot.itemcount,\n+                    'uri': slot.uri}\n+        d = defer.maybeDeferred(slot.storage.store, slot.file)\n+\n+        # Use `largs=log_args` to copy log_args into function's scope\n+        # instead of using `log_args` from the outer scope\n+        d.addCallback(\n+            lambda _, largs=log_args: logger.info(\n+                logfmt % \"Stored\", largs, extra={'spider': spider}\n+            )\n+        )\n+        d.addErrback(\n+            lambda f, largs=log_args: logger.error(\n+                logfmt % \"Error storing\", largs,\n+                exc_info=failure_to_exc_info(f), extra={'spider': spider}\n+            )\n+        )\n+        return d\n+\n+    def _start_new_batch(self, batch_id, uri, feed, spider, uri_template):\n+        \"\"\"\n+        Redirect the output data stream to a new file.\n+        Execute multiple times if FEED_STORAGE_BATCH_ITEM_COUNT setting or FEEDS.batch_item_count is specified\n+        :param batch_id: sequence number of current batch\n+        :param uri: uri of the new batch to start\n+        :param feed: dict with parameters of feed\n+        :param spider: user spider\n+        :param uri_template: template of uri which contains %(batch_time)s or %(batch_id)s to create new uri\n+        \"\"\"\n+        storage = self._get_storage(uri)\n+        file = storage.open(spider)\n+        exporter = self._get_exporter(\n+            file=file,\n+            format=feed['format'],\n+            fields_to_export=feed['fields'],\n+            encoding=feed['encoding'],\n+            indent=feed['indent'],\n+        )\n+        slot = _FeedSlot(\n+            file=file,\n+            exporter=exporter,\n+            storage=storage,\n+            uri=uri,\n+            format=feed['format'],\n+            store_empty=feed['store_empty'],\n+            batch_id=batch_id,\n+            uri_template=uri_template,\n+        )\n+        if slot.store_empty:\n+            slot.start_exporting()\n+        return slot\n+\n     def item_scraped(self, item, spider):\n+        slots = []\n         for slot in self.slots:\n             slot.start_exporting()\n             slot.exporter.export_item(item)\n             slot.itemcount += 1\n+            # create new slot for each slot with itemcount == FEED_STORAGE_BATCH_ITEM_COUNT and close the old one\n+            if (\n+                    self.feeds[slot.uri_template]['batch_item_count']\n+                    and slot.itemcount >= self.feeds[slot.uri_template]['batch_item_count']",
      "comment": "```suggestion\r\n                self.feeds[slot.uri_template]['batch_item_count']\r\n                and slot.itemcount >= self.feeds[slot.uri_template]['batch_item_count']\r\n```",
      "comment_id": 448724712,
      "user": "elacuesta",
      "created_at": "2020-07-02T03:14:56Z",
      "url": "https://github.com/scrapy/scrapy/pull/4434#discussion_r448724712"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 4434,
      "file_path": "scrapy/extensions/feedexport.py",
      "line": 378,
      "side": "RIGHT",
      "diff_hunk": "@@ -367,16 +369,18 @@ def _exporter_supported(self, format):\n             return True\n         logger.error(\"Unknown feed format: %(format)s\", {'format': format})\n \n-    def _settings_are_valid(self, uri):\n+    def _settings_are_valid(self):\n         \"\"\"\n-        If FEED_STORAGE_BATCH_ITEM_COUNT setting or FEEDS.batch_item_count is specified uri has to contain\n+        If FEED_EXPORT_BATCH_ITEM_COUNT setting or FEEDS.batch_item_count is specified uri has to contain\n         %(batch_time)s or %(batch_id)s to distinguish different files of partial output\n         \"\"\"\n         for uri_template, values in self.feeds.items():\n-            if values['batch_item_count'] and not any(s in uri_template for s in ['%(batch_time)s', '%(batch_id)s']):\n+            if values['batch_item_count'] and not re.findall(r'(%\\(batch_time\\)s|(%\\(batch_id\\)0\\d*d))', uri_template):",
      "comment": "What about just looking for `%(asdf)`, and hope that the user did not break the formatting syntax? Either we do that, or we implement something that finds all [syntax variants](https://docs.python.org/3/library/stdtypes.html#old-string-formatting).\r\n\r\nAlso, `findall` probably does not make sense here, given the preceding `not`; finding a single match should suffice in this scenario.",
      "comment_id": 448916047,
      "user": "Gallaecio",
      "created_at": "2020-07-02T10:49:49Z",
      "url": "https://github.com/scrapy/scrapy/pull/4434#discussion_r448916047"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 4434,
      "file_path": "scrapy/extensions/feedexport.py",
      "line": 378,
      "side": "RIGHT",
      "diff_hunk": "@@ -367,16 +369,18 @@ def _exporter_supported(self, format):\n             return True\n         logger.error(\"Unknown feed format: %(format)s\", {'format': format})\n \n-    def _settings_are_valid(self, uri):\n+    def _settings_are_valid(self):\n         \"\"\"\n-        If FEED_STORAGE_BATCH_ITEM_COUNT setting or FEEDS.batch_item_count is specified uri has to contain\n+        If FEED_EXPORT_BATCH_ITEM_COUNT setting or FEEDS.batch_item_count is specified uri has to contain\n         %(batch_time)s or %(batch_id)s to distinguish different files of partial output\n         \"\"\"\n         for uri_template, values in self.feeds.items():\n-            if values['batch_item_count'] and not any(s in uri_template for s in ['%(batch_time)s', '%(batch_id)s']):\n+            if values['batch_item_count'] and not re.findall(r'(%\\(batch_time\\)s|(%\\(batch_id\\)0\\d*d))', uri_template):",
      "comment": "> What about just looking for %(asdf), and hope that the user did not break the formatting syntax? Either we do that, or we implement something that finds all syntax variants.\r\n\r\n@Gallaecio, could you please explain it a little bit more because I can't clearly understand why should we allow users to break the formatting syntax if batch_id is always an integer and we only want to add leading zeros?",
      "comment_id": 449029897,
      "user": "BroodingKangaroo",
      "created_at": "2020-07-02T14:09:59Z",
      "url": "https://github.com/scrapy/scrapy/pull/4434#discussion_r449029897"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 4434,
      "file_path": "scrapy/extensions/feedexport.py",
      "line": 378,
      "side": "RIGHT",
      "diff_hunk": "@@ -367,16 +369,18 @@ def _exporter_supported(self, format):\n             return True\n         logger.error(\"Unknown feed format: %(format)s\", {'format': format})\n \n-    def _settings_are_valid(self, uri):\n+    def _settings_are_valid(self):\n         \"\"\"\n-        If FEED_STORAGE_BATCH_ITEM_COUNT setting or FEEDS.batch_item_count is specified uri has to contain\n+        If FEED_EXPORT_BATCH_ITEM_COUNT setting or FEEDS.batch_item_count is specified uri has to contain\n         %(batch_time)s or %(batch_id)s to distinguish different files of partial output\n         \"\"\"\n         for uri_template, values in self.feeds.items():\n-            if values['batch_item_count'] and not any(s in uri_template for s in ['%(batch_time)s', '%(batch_id)s']):\n+            if values['batch_item_count'] and not re.findall(r'(%\\(batch_time\\)s|(%\\(batch_id\\)0\\d*d))', uri_template):",
      "comment": "My thinking was that we should allow as much flexibility as possible if it\u2019s trivial to do. For example, if someone wants to use spaces instead of zeroes for padding, we would be allowing that (`%(batch_id)4d`).\r\n\r\nNot a strong opinion about it, though.",
      "comment_id": 449051865,
      "user": "Gallaecio",
      "created_at": "2020-07-02T14:41:03Z",
      "url": "https://github.com/scrapy/scrapy/pull/4434#discussion_r449051865"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 4434,
      "file_path": "scrapy/extensions/feedexport.py",
      "line": 380,
      "side": "RIGHT",
      "diff_hunk": "@@ -375,9 +375,9 @@ def _settings_are_valid(self):\n         %(batch_time)s or %(batch_id)s to distinguish different files of partial output\n         \"\"\"\n         for uri_template, values in self.feeds.items():\n-            if values['batch_item_count'] and not re.findall(r'(%\\(batch_time\\)s|(%\\(batch_id\\)0\\d*d))', uri_template):\n+            if values['batch_item_count'] and not re.search(r'%\\(batch_time\\)s|%\\(batch_id\\)', uri_template):\n                 logger.error(\n-                    '%(batch_time)s or %(batch_id)0xd must be in uri({}) if FEED_EXPORT_BATCH_ITEM_COUNT setting '\n+                    '%(batch_time)s or %(batch_id) must be in uri({}) if FEED_EXPORT_BATCH_ITEM_COUNT setting '",
      "comment": ":lipstick: I would still describe it as `%(batch_id)d` in the message.\r\n\r\n```suggestion\r\n                    '%(batch_time)s or %(batch_id)d must be in the feed URI ({}) if FEED_EXPORT_BATCH_ITEM_COUNT setting '\r\n```",
      "comment_id": 450076372,
      "user": "Gallaecio",
      "created_at": "2020-07-06T08:50:35Z",
      "url": "https://github.com/scrapy/scrapy/pull/4434#discussion_r450076372"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 4434,
      "file_path": "tests/test_feedexport.py",
      "line": 1207,
      "side": "RIGHT",
      "diff_hunk": "@@ -1163,3 +1180,371 @@ def test_multiple_feeds_failing_logs_blocking_feed_storage(self):\n         print(log)\n         for fmt in ['json', 'xml', 'csv']:\n             self.assertIn('Error storing %s feed (2 items)' % fmt, str(log))\n+\n+\n+class BatchDeliveriesTest(FeedExportTestBase):\n+    __test__ = True\n+    _file_mark = '_%(batch_time)s_#%(batch_id)02d_'\n+\n+    @defer.inlineCallbacks\n+    def run_and_export(self, spider_cls, settings):\n+        \"\"\" Run spider with specified settings; return exported data. \"\"\"\n+\n+        FEEDS = settings.get('FEEDS') or {}\n+        settings['FEEDS'] = {\n+            urljoin('file:', file_path): feed\n+            for file_path, feed in FEEDS.items()\n+        }\n+        content = defaultdict(list)\n+        try:\n+            with MockServer() as s:\n+                runner = CrawlerRunner(Settings(settings))\n+                spider_cls.start_urls = [s.url('/')]\n+                yield runner.crawl(spider_cls)\n+\n+            for path, feed in FEEDS.items():\n+                dir_name = os.path.dirname(path)\n+                for file in sorted(os.listdir(dir_name)):",
      "comment": "It looks like tests fail here on Windows: https://scrapinghub.visualstudio.com/scrapy/_build/results?buildId=98&view=logs&j=76ed1102-9071-5354-720f-6f09bbc9f0c0&t=dc276db5-d83b-509a-4a8d-770723557532&l=2129",
      "comment_id": 456299238,
      "user": "kmike",
      "created_at": "2020-07-17T08:30:28Z",
      "url": "https://github.com/scrapy/scrapy/pull/4434#discussion_r456299238"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 4458,
      "file_path": "tests/CrawlerRunner/ip_address.py",
      "line": 19,
      "side": "RIGHT",
      "diff_hunk": "@@ -10,6 +12,17 @@\n from tests.mockserver import MockServer, MockDNSServer\n \n \n+# https://stackoverflow.com/a/32784190\n+def createResolver(servers=None, resolvconf=None, hosts=None):\n+    if hosts is None:\n+        hosts = (b'/etc/hosts' if platform.getType() == 'posix'\n+                 else r'c:\\windows\\hosts')",
      "comment": "```suggestion\r\n        hosts = b'/etc/hosts' if platform.getType() == 'posix' else r'c:\\windows\\hosts'\r\n```\r\nNitpick 1",
      "comment_id": 449611058,
      "user": "elacuesta",
      "created_at": "2020-07-03T14:29:36Z",
      "url": "https://github.com/scrapy/scrapy/pull/4458#discussion_r449611058"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 4458,
      "file_path": "tests/CrawlerRunner/ip_address.py",
      "line": 23,
      "side": "RIGHT",
      "diff_hunk": "@@ -10,6 +12,17 @@\n from tests.mockserver import MockServer, MockDNSServer\n \n \n+# https://stackoverflow.com/a/32784190\n+def createResolver(servers=None, resolvconf=None, hosts=None):\n+    if hosts is None:\n+        hosts = (b'/etc/hosts' if platform.getType() == 'posix'\n+                 else r'c:\\windows\\hosts')\n+    theResolver = Resolver(resolvconf, servers)\n+    hostResolver = hostsModule.Resolver(hosts)\n+    L = [hostResolver, cache.CacheResolver(), theResolver]\n+    return resolve.ResolverChain(L)",
      "comment": "```suggestion\r\n    chain = [hostResolver, cache.CacheResolver(), theResolver]\r\n    return resolve.ResolverChain(chain)\r\n```\r\nNitpick 2",
      "comment_id": 449611237,
      "user": "elacuesta",
      "created_at": "2020-07-03T14:30:01Z",
      "url": "https://github.com/scrapy/scrapy/pull/4458#discussion_r449611237"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 4458,
      "file_path": "scrapy/utils/url.py",
      "line": 102,
      "side": "RIGHT",
      "diff_hunk": "@@ -98,7 +96,10 @@ def guess_scheme(url):\n                     )?      # optional match of \".\", \"..\" or \".blabla\"\n                     /       # at least one \"/\" for a file path,\n                     .       # and something after the \"/\"\n-                    ''', parts.path, flags=re.VERBOSE):\n+                    ''', url, flags=re.VERBOSE):\n+        return any_to_uri(url)\n+    # Windows drive-letter path\n+    elif re.match(r'''^[a-z]:\\\\''', url, flags=re.IGNORECASE):",
      "comment": "could you please add tests for these changes? I also wonder if these two conditions can be moved to helper functions, looks_like_posix_path and looks_like_windows_path; it may allow easier testing.",
      "comment_id": 450810246,
      "user": "kmike",
      "created_at": "2020-07-07T11:59:21Z",
      "url": "https://github.com/scrapy/scrapy/pull/4458#discussion_r450810246"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 4458,
      "file_path": "tests/CrawlerRunner/ip_address.py",
      "line": 18,
      "side": "RIGHT",
      "diff_hunk": "@@ -10,6 +12,16 @@\n from tests.mockserver import MockServer, MockDNSServer\n \n \n+# https://stackoverflow.com/a/32784190\n+def createResolver(servers=None, resolvconf=None, hosts=None):\n+    if hosts is None:\n+        hosts = b'/etc/hosts' if platform.getType() == 'posix' else r'c:\\windows\\hosts'",
      "comment": "*Ideally* this should detect the Windows dir path at run time",
      "comment_id": 454865797,
      "user": "wRAR",
      "created_at": "2020-07-15T08:01:13Z",
      "url": "https://github.com/scrapy/scrapy/pull/4458#discussion_r454865797"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 4458,
      "file_path": "tests/CrawlerRunner/ip_address.py",
      "line": 18,
      "side": "RIGHT",
      "diff_hunk": "@@ -10,6 +12,16 @@\n from tests.mockserver import MockServer, MockDNSServer\n \n \n+# https://stackoverflow.com/a/32784190\n+def createResolver(servers=None, resolvconf=None, hosts=None):\n+    if hosts is None:\n+        hosts = b'/etc/hosts' if platform.getType() == 'posix' else r'c:\\windows\\hosts'",
      "comment": "Indeed. However, what we really care for here is `servers` getting picked up. The code for `hosts` is just so that we have a hosts value to pass to `hostsModule.Resolver`.",
      "comment_id": 454953140,
      "user": "Gallaecio",
      "created_at": "2020-07-15T10:31:13Z",
      "url": "https://github.com/scrapy/scrapy/pull/4458#discussion_r454953140"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 3608,
      "file_path": "scrapy/extensions/feedexport.py",
      "line": 158,
      "side": "RIGHT",
      "diff_hunk": "@@ -146,6 +146,32 @@ def _store_in_thread(self, file):\n             key.close()\n \n \n+\n+class GCSFeedStorage(BlockingFeedStorage):\n+\n+    project_id = None\n+    bucket_name = None\n+    blob_name = None\n+\n+    def __init__(self, uri, project_id):\n+        self.project_id = project_id\n+        u = urlparse(uri)",
      "comment": "Note that these three lines are similar to `S3FeedStorage`.\r\nI thought about extracting them in a method, but it doesn't seem to hurt (letting it duplicate) right now",
      "comment_id": 253004429,
      "user": "ejulio",
      "created_at": "2019-02-01T10:38:18Z",
      "url": "https://github.com/scrapy/scrapy/pull/3608#discussion_r253004429"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 3608,
      "file_path": "scrapy/extensions/feedexport.py",
      "line": 152,
      "side": "RIGHT",
      "diff_hunk": "@@ -146,6 +146,32 @@ def _store_in_thread(self, file):\n             key.close()\n \n \n+\n+class GCSFeedStorage(BlockingFeedStorage):\n+\n+    project_id = None",
      "comment": "It doesn't seem right to store this information as class attributes. \r\nYou should be defining those values in the init method, don't you?",
      "comment_id": 253437719,
      "user": "victor-torres",
      "created_at": "2019-02-04T11:42:45Z",
      "url": "https://github.com/scrapy/scrapy/pull/3608#discussion_r253437719"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 3608,
      "file_path": "scrapy/extensions/feedexport.py",
      "line": 172,
      "side": "RIGHT",
      "diff_hunk": "@@ -146,6 +146,32 @@ def _store_in_thread(self, file):\n             key.close()\n \n \n+\n+class GCSFeedStorage(BlockingFeedStorage):\n+\n+    project_id = None\n+    bucket_name = None\n+    blob_name = None\n+\n+    def __init__(self, uri, project_id):\n+        self.project_id = project_id\n+        u = urlparse(uri)\n+        self.bucket_name = u.hostname\n+        self.blob_name = u.path[1:]  # remove first \"/\"\n+\n+    @classmethod\n+    def from_crawler(cls, crawler, uri):\n+        return cls(uri, crawler.settings['GCS_PROJECT_ID'])\n+\n+    def _store_in_thread(self, file):\n+        file.seek(0)\n+        from google.cloud.storage import Client\n+        client = Client(project=self.project_id)\n+        bucket = client.get_bucket(self.bucket_name)\n+        blob = bucket.blob(self.blob_name)\n+        blob.upload_from_file(file)",
      "comment": "Could you check for optional Policy options for the bucket? I believe we have something similar on Media Pipelines.",
      "comment_id": 253438146,
      "user": "victor-torres",
      "created_at": "2019-02-04T11:44:26Z",
      "url": "https://github.com/scrapy/scrapy/pull/3608#discussion_r253438146"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 3608,
      "file_path": "scrapy/extensions/feedexport.py",
      "line": 152,
      "side": "RIGHT",
      "diff_hunk": "@@ -146,6 +146,32 @@ def _store_in_thread(self, file):\n             key.close()\n \n \n+\n+class GCSFeedStorage(BlockingFeedStorage):\n+\n+    project_id = None",
      "comment": "You mean to make it private?\r\nI don't see any difference in:\r\n```\r\nclass A:\r\n   attribute = None\r\n   def __init__(self, a):\r\n        self.attribute = a\r\n\r\nclass A:\r\n   def __init__(self, a):\r\n        self.attribute = a\r\n```\r\n\r\nActually, I prefer the first one because it makes things explicit (there is an attribute called `attribute`).",
      "comment_id": 253452173,
      "user": "ejulio",
      "created_at": "2019-02-04T12:35:26Z",
      "url": "https://github.com/scrapy/scrapy/pull/3608#discussion_r253452173"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 3608,
      "file_path": "scrapy/extensions/feedexport.py",
      "line": 152,
      "side": "RIGHT",
      "diff_hunk": "@@ -146,6 +146,32 @@ def _store_in_thread(self, file):\n             key.close()\n \n \n+\n+class GCSFeedStorage(BlockingFeedStorage):\n+\n+    project_id = None",
      "comment": "No, I mean to declare them as instance attributes instead of class attributes.\r\nThis is how we are doing in `S3FeedStorage`, for example.\r\n\r\nClass attributes are really useful when storing constants or helper values, things that are shared across multiple instances of the same class.\r\n\r\nIn this case, I don't think you should reuse the storage settings.\r\n\r\nIn worst case scenarios, it could also lead to indesirable mutability when trying to change an instance attribute value causes the class attribute value and therefore all other instance attribute values to be changed too.\r\n\r\nIn a nutshell, you **need** those values in order to initialize the instance, so there's no reason to keep an unused default value as a class attribute.",
      "comment_id": 253478285,
      "user": "victor-torres",
      "created_at": "2019-02-04T13:58:12Z",
      "url": "https://github.com/scrapy/scrapy/pull/3608#discussion_r253478285"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 3608,
      "file_path": "scrapy/extensions/feedexport.py",
      "line": 158,
      "side": "RIGHT",
      "diff_hunk": "@@ -146,6 +146,32 @@ def _store_in_thread(self, file):\n             key.close()\n \n \n+\n+class GCSFeedStorage(BlockingFeedStorage):\n+\n+    project_id = None\n+    bucket_name = None\n+    blob_name = None\n+\n+    def __init__(self, uri, project_id):\n+        self.project_id = project_id\n+        u = urlparse(uri)",
      "comment": "> but it does seem to hurt right now\r\n\r\nIt DOES hurt? as in... performance?",
      "comment_id": 253494518,
      "user": "stav",
      "created_at": "2019-02-04T14:40:16Z",
      "url": "https://github.com/scrapy/scrapy/pull/3608#discussion_r253494518"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 3608,
      "file_path": "tests/test_feedexport.py",
      "line": 210,
      "side": "RIGHT",
      "diff_hunk": "@@ -187,6 +188,48 @@ def test_store(self):\n         self.assertEqual(content, expected_content)\n \n \n+class GCSFeedStorageTest(unittest.TestCase):\n+\n+    @mock.patch('scrapy.conf.settings',\n+                new={'GCS_PROJECT_ID': 'conf_id', 'FEED_STORAGE_GCS_ACL': None }, create=True)\n+    def test_parse_settings(self):\n+        try:\n+            from google.cloud.storage import Client\n+        except ImportError:\n+            raise unittest.SkipTest(\"GCSFeedStorage requires google-cloud-storage\")\n+\n+        settings = {'GCS_PROJECT_ID': '123', 'FEED_STORAGE_GCS_ACL': 'publicRead' }\n+        crawler = get_crawler(settings_dict=settings)\n+        storage = GCSFeedStorage.from_crawler(crawler, 'gcs://mybucket/export.csv')\n+        assert storage.project_id == '123'\n+        assert storage.acl == 'publicRead'\n+        assert storage.bucket_name == 'mybucket'\n+        assert storage.blob_name == 'export.csv'\n+\n+    @defer.inlineCallbacks\n+    def test_store(self):",
      "comment": "Would you like to add tests to cover the upload without an ACL/Policy defined (`None`)? ",
      "comment_id": 255520717,
      "user": "victor-torres",
      "created_at": "2019-02-11T14:07:54Z",
      "url": "https://github.com/scrapy/scrapy/pull/3608#discussion_r255520717"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 3608,
      "file_path": "tests/test_feedexport.py",
      "line": 210,
      "side": "RIGHT",
      "diff_hunk": "@@ -187,6 +188,48 @@ def test_store(self):\n         self.assertEqual(content, expected_content)\n \n \n+class GCSFeedStorageTest(unittest.TestCase):\n+\n+    @mock.patch('scrapy.conf.settings',\n+                new={'GCS_PROJECT_ID': 'conf_id', 'FEED_STORAGE_GCS_ACL': None }, create=True)\n+    def test_parse_settings(self):\n+        try:\n+            from google.cloud.storage import Client\n+        except ImportError:\n+            raise unittest.SkipTest(\"GCSFeedStorage requires google-cloud-storage\")\n+\n+        settings = {'GCS_PROJECT_ID': '123', 'FEED_STORAGE_GCS_ACL': 'publicRead' }\n+        crawler = get_crawler(settings_dict=settings)\n+        storage = GCSFeedStorage.from_crawler(crawler, 'gcs://mybucket/export.csv')\n+        assert storage.project_id == '123'\n+        assert storage.acl == 'publicRead'\n+        assert storage.bucket_name == 'mybucket'\n+        assert storage.blob_name == 'export.csv'\n+\n+    @defer.inlineCallbacks\n+    def test_store(self):",
      "comment": "Not sure.\r\nThe test will be a _copy + paste_ from `test_store` with the only difference in the assignment `acl = None`.\r\nProbably, an option could be parameterized tests.",
      "comment_id": 255565670,
      "user": "ejulio",
      "created_at": "2019-02-11T15:48:16Z",
      "url": "https://github.com/scrapy/scrapy/pull/3608#discussion_r255565670"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 3608,
      "file_path": "tests/test_feedexport.py",
      "line": 210,
      "side": "RIGHT",
      "diff_hunk": "@@ -187,6 +188,48 @@ def test_store(self):\n         self.assertEqual(content, expected_content)\n \n \n+class GCSFeedStorageTest(unittest.TestCase):\n+\n+    @mock.patch('scrapy.conf.settings',\n+                new={'GCS_PROJECT_ID': 'conf_id', 'FEED_STORAGE_GCS_ACL': None }, create=True)\n+    def test_parse_settings(self):\n+        try:\n+            from google.cloud.storage import Client\n+        except ImportError:\n+            raise unittest.SkipTest(\"GCSFeedStorage requires google-cloud-storage\")\n+\n+        settings = {'GCS_PROJECT_ID': '123', 'FEED_STORAGE_GCS_ACL': 'publicRead' }\n+        crawler = get_crawler(settings_dict=settings)\n+        storage = GCSFeedStorage.from_crawler(crawler, 'gcs://mybucket/export.csv')\n+        assert storage.project_id == '123'\n+        assert storage.acl == 'publicRead'\n+        assert storage.bucket_name == 'mybucket'\n+        assert storage.blob_name == 'export.csv'\n+\n+    @defer.inlineCallbacks\n+    def test_store(self):",
      "comment": "In this case, you would be testing the default value for the ACL setting.",
      "comment_id": 255623539,
      "user": "victor-torres",
      "created_at": "2019-02-11T17:55:53Z",
      "url": "https://github.com/scrapy/scrapy/pull/3608#discussion_r255623539"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 3608,
      "file_path": "scrapy/extensions/feedexport.py",
      "line": 169,
      "side": "RIGHT",
      "diff_hunk": "@@ -146,6 +146,32 @@ def _store_in_thread(self, file):\n             key.close()\n \n \n+class GCSFeedStorage(BlockingFeedStorage):\n+\n+    def __init__(self, uri, project_id, acl):\n+        self.project_id = project_id\n+        self.acl = acl\n+        u = urlparse(uri)\n+        self.bucket_name = u.hostname\n+        self.blob_name = u.path[1:]  # remove first \"/\"\n+\n+    @classmethod\n+    def from_crawler(cls, crawler, uri):\n+        return cls(\n+            uri,\n+            crawler.settings['GCS_PROJECT_ID'],\n+            crawler.settings['FEED_STORAGE_GCS_ACL']\n+        )\n+\n+    def _store_in_thread(self, file):\n+        file.seek(0)\n+        from google.cloud.storage import Client\n+        client = Client(project=self.project_id)",
      "comment": "You can also create the client using:\r\n\r\n```python\r\njson_path = os.path.join(os.path.dirname(os.path.abspath(__file__)), '../google-cloud-service-account.json')\r\nclient = Client.from_service_account_json(json_path)\r\n```",
      "comment_id": 260495371,
      "user": "victor-torres",
      "created_at": "2019-02-26T21:28:54Z",
      "url": "https://github.com/scrapy/scrapy/pull/3608#discussion_r260495371"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 3608,
      "file_path": "scrapy/extensions/feedexport.py",
      "line": 169,
      "side": "RIGHT",
      "diff_hunk": "@@ -146,6 +146,32 @@ def _store_in_thread(self, file):\n             key.close()\n \n \n+class GCSFeedStorage(BlockingFeedStorage):\n+\n+    def __init__(self, uri, project_id, acl):\n+        self.project_id = project_id\n+        self.acl = acl\n+        u = urlparse(uri)\n+        self.bucket_name = u.hostname\n+        self.blob_name = u.path[1:]  # remove first \"/\"\n+\n+    @classmethod\n+    def from_crawler(cls, crawler, uri):\n+        return cls(\n+            uri,\n+            crawler.settings['GCS_PROJECT_ID'],\n+            crawler.settings['FEED_STORAGE_GCS_ACL']\n+        )\n+\n+    def _store_in_thread(self, file):\n+        file.seek(0)\n+        from google.cloud.storage import Client\n+        client = Client(project=self.project_id)",
      "comment": "Yup, this was in my original approach.\r\nBut, I kept compatibility with IMAGES_STORE for now.",
      "comment_id": 260748905,
      "user": "ejulio",
      "created_at": "2019-02-27T13:32:42Z",
      "url": "https://github.com/scrapy/scrapy/pull/3608#discussion_r260748905"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 3608,
      "file_path": "scrapy/settings/default_settings.py",
      "line": 162,
      "side": "RIGHT",
      "diff_hunk": "@@ -158,6 +159,7 @@\n }\n FEED_EXPORT_INDENT = 0\n \n+FEED_STORAGE_GCS_ACL = None",
      "comment": "I still wonder if that's ok to use None values as defaults, instead of empty strings, because there is no way to set an option to None using `-s` from command line (or am I wrong here?). So, once overridden, you can't get it back to the default value, when starting a spider from command line. That's the reason most other default values are empty strings instead of None - we should probably treat empty string as None in most cases. By having it `''` in default_settings, and checking that it works, we make sure that `-s FEED_STORAGE_GCS_ACL=` from command line also works.",
      "comment_id": 315333129,
      "user": "kmike",
      "created_at": "2019-08-19T17:47:17Z",
      "url": "https://github.com/scrapy/scrapy/pull/3608#discussion_r315333129"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 3608,
      "file_path": "scrapy/settings/default_settings.py",
      "line": 162,
      "side": "RIGHT",
      "diff_hunk": "@@ -158,6 +159,7 @@\n }\n FEED_EXPORT_INDENT = 0\n \n+FEED_STORAGE_GCS_ACL = None",
      "comment": "Indeed @kmike .\r\nI updated it to be `\"\"` by default, as it is also the default value of `FILES_STORE_GCS_ACL`",
      "comment_id": 319093324,
      "user": "ejulio",
      "created_at": "2019-08-29T14:12:45Z",
      "url": "https://github.com/scrapy/scrapy/pull/3608#discussion_r319093324"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 4516,
      "file_path": "scrapy/loader/__init__.py",
      "line": 16,
      "side": "RIGHT",
      "diff_hunk": "@@ -3,219 +3,35 @@\n \n See documentation in docs/topics/loaders.rst\n \"\"\"\n-from collections import defaultdict\n-from contextlib import suppress\n+import itemloaders\n \n from scrapy.item import Item\n-from scrapy.loader.common import wrap_loader_context\n-from scrapy.loader.processors import Identity\n from scrapy.selector import Selector\n-from scrapy.utils.misc import arg_to_iter, extract_regex\n-from scrapy.utils.python import flatten\n \n-\n-def unbound_method(method):\n-    \"\"\"\n-    Allow to use single-argument functions as input or output processors\n-    (no need to define an unused first 'self' argument)\n-    \"\"\"\n-    with suppress(AttributeError):\n-        if '.' not in method.__qualname__:\n-            return method.__func__\n-    return method\n-\n-\n-class ItemLoader:\n+class ItemLoader(itemloaders.ItemLoader):\n \n     default_item_class = Item\n-    default_input_processor = Identity()\n-    default_output_processor = Identity()\n     default_selector_class = Selector\n \n-    def __init__(self, item=None, selector=None, response=None, parent=None, **context):\n+    def __init__(self, response=None, item=None, selector=None, parent=None, **context):",
      "comment": "Can we keep the previous parameter order, for backward compatibility?",
      "comment_id": 416078429,
      "user": "Gallaecio",
      "created_at": "2020-04-27T19:11:32Z",
      "url": "https://github.com/scrapy/scrapy/pull/4516#discussion_r416078429"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 4516,
      "file_path": "scrapy/loader/common.py",
      "line": 14,
      "side": "LEFT",
      "diff_hunk": "@@ -1,14 +0,0 @@\n-\"\"\"Common functions used in Item Loaders code\"\"\"\n-\n-from functools import partial\n-from scrapy.utils.python import get_func_args\n-\n-\n-def wrap_loader_context(function, context):\n-    \"\"\"Wrap functions that receive loader_context to contain the context\n-    \"pre-loaded\" and expose a interface that receives only one argument\n-    \"\"\"\n-    if 'loader_context' in get_func_args(function):\n-        return partial(function, loader_context=context)\n-    else:\n-        return function",
      "comment": "To maximize backward compatibility, we might want to deprecate this module instead of removing it. Maybe we can import the function from the new library, though.",
      "comment_id": 416084750,
      "user": "Gallaecio",
      "created_at": "2020-04-27T19:21:43Z",
      "url": "https://github.com/scrapy/scrapy/pull/4516#discussion_r416084750"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 4516,
      "file_path": "scrapy/loader/processors.py",
      "line": 1,
      "side": "RIGHT",
      "diff_hunk": "@@ -1,104 +1 @@\n-\"\"\"\n-This module provides some commonly used processors for Item Loaders.\n-\n-See documentation in docs/topics/loaders.rst\n-\"\"\"\n-from collections import ChainMap\n-\n-from scrapy.utils.misc import arg_to_iter\n-from scrapy.loader.common import wrap_loader_context\n-\n-\n-class MapCompose:\n-\n-    def __init__(self, *functions, **default_loader_context):\n-        self.functions = functions\n-        self.default_loader_context = default_loader_context\n-\n-    def __call__(self, value, loader_context=None):\n-        values = arg_to_iter(value)\n-        if loader_context:\n-            context = ChainMap(loader_context, self.default_loader_context)\n-        else:\n-            context = self.default_loader_context\n-        wrapped_funcs = [wrap_loader_context(f, context) for f in self.functions]\n-        for func in wrapped_funcs:\n-            next_values = []\n-            for v in values:\n-                try:\n-                    next_values += arg_to_iter(func(v))\n-                except Exception as e:\n-                    raise ValueError(\"Error in MapCompose with \"\n-                                     \"%s value=%r error='%s: %s'\" %\n-                                     (str(func), value, type(e).__name__,\n-                                      str(e)))\n-            values = next_values\n-        return values\n-\n-\n-class Compose:\n-\n-    def __init__(self, *functions, **default_loader_context):\n-        self.functions = functions\n-        self.stop_on_none = default_loader_context.get('stop_on_none', True)\n-        self.default_loader_context = default_loader_context\n-\n-    def __call__(self, value, loader_context=None):\n-        if loader_context:\n-            context = ChainMap(loader_context, self.default_loader_context)\n-        else:\n-            context = self.default_loader_context\n-        wrapped_funcs = [wrap_loader_context(f, context) for f in self.functions]\n-        for func in wrapped_funcs:\n-            if value is None and self.stop_on_none:\n-                break\n-            try:\n-                value = func(value)\n-            except Exception as e:\n-                raise ValueError(\"Error in Compose with \"\n-                                 \"%s value=%r error='%s: %s'\" %\n-                                 (str(func), value, type(e).__name__, str(e)))\n-        return value\n-\n-\n-class TakeFirst:\n-\n-    def __call__(self, values):\n-        for value in values:\n-            if value is not None and value != '':\n-                return value\n-\n-\n-class Identity:\n-\n-    def __call__(self, values):\n-        return values\n-\n-\n-class SelectJmes:\n-    \"\"\"\n-        Query the input string for the jmespath (given at instantiation),\n-        and return the answer\n-        Requires : jmespath(https://github.com/jmespath/jmespath)\n-        Note: SelectJmes accepts only one input element at a time.\n-    \"\"\"\n-    def __init__(self, json_path):\n-        self.json_path = json_path\n-        import jmespath\n-        self.compiled_path = jmespath.compile(self.json_path)\n-\n-    def __call__(self, value):\n-        \"\"\"Query value for the jmespath query and return answer\n-        :param value: a data structure (dict, list) to extract from\n-        :return: Element extracted according to jmespath query\n-        \"\"\"\n-        return self.compiled_path.search(value)\n-\n-\n-class Join:\n-\n-    def __init__(self, separator=u' '):\n-        self.separator = separator\n-\n-    def __call__(self, values):\n-        return self.separator.join(values)\n+from itemloaders.processors import *",
      "comment": "We need to issue a deprecation warning, to try and get people importing from `itemloaders` directly in the long term.",
      "comment_id": 416085354,
      "user": "Gallaecio",
      "created_at": "2020-04-27T19:22:49Z",
      "url": "https://github.com/scrapy/scrapy/pull/4516#discussion_r416085354"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 4516,
      "file_path": "scrapy/loader/processors.py",
      "line": 1,
      "side": "RIGHT",
      "diff_hunk": "@@ -1,104 +1 @@\n-\"\"\"\n-This module provides some commonly used processors for Item Loaders.\n-\n-See documentation in docs/topics/loaders.rst\n-\"\"\"\n-from collections import ChainMap\n-\n-from scrapy.utils.misc import arg_to_iter\n-from scrapy.loader.common import wrap_loader_context\n-\n-\n-class MapCompose:\n-\n-    def __init__(self, *functions, **default_loader_context):\n-        self.functions = functions\n-        self.default_loader_context = default_loader_context\n-\n-    def __call__(self, value, loader_context=None):\n-        values = arg_to_iter(value)\n-        if loader_context:\n-            context = ChainMap(loader_context, self.default_loader_context)\n-        else:\n-            context = self.default_loader_context\n-        wrapped_funcs = [wrap_loader_context(f, context) for f in self.functions]\n-        for func in wrapped_funcs:\n-            next_values = []\n-            for v in values:\n-                try:\n-                    next_values += arg_to_iter(func(v))\n-                except Exception as e:\n-                    raise ValueError(\"Error in MapCompose with \"\n-                                     \"%s value=%r error='%s: %s'\" %\n-                                     (str(func), value, type(e).__name__,\n-                                      str(e)))\n-            values = next_values\n-        return values\n-\n-\n-class Compose:\n-\n-    def __init__(self, *functions, **default_loader_context):\n-        self.functions = functions\n-        self.stop_on_none = default_loader_context.get('stop_on_none', True)\n-        self.default_loader_context = default_loader_context\n-\n-    def __call__(self, value, loader_context=None):\n-        if loader_context:\n-            context = ChainMap(loader_context, self.default_loader_context)\n-        else:\n-            context = self.default_loader_context\n-        wrapped_funcs = [wrap_loader_context(f, context) for f in self.functions]\n-        for func in wrapped_funcs:\n-            if value is None and self.stop_on_none:\n-                break\n-            try:\n-                value = func(value)\n-            except Exception as e:\n-                raise ValueError(\"Error in Compose with \"\n-                                 \"%s value=%r error='%s: %s'\" %\n-                                 (str(func), value, type(e).__name__, str(e)))\n-        return value\n-\n-\n-class TakeFirst:\n-\n-    def __call__(self, values):\n-        for value in values:\n-            if value is not None and value != '':\n-                return value\n-\n-\n-class Identity:\n-\n-    def __call__(self, values):\n-        return values\n-\n-\n-class SelectJmes:\n-    \"\"\"\n-        Query the input string for the jmespath (given at instantiation),\n-        and return the answer\n-        Requires : jmespath(https://github.com/jmespath/jmespath)\n-        Note: SelectJmes accepts only one input element at a time.\n-    \"\"\"\n-    def __init__(self, json_path):\n-        self.json_path = json_path\n-        import jmespath\n-        self.compiled_path = jmespath.compile(self.json_path)\n-\n-    def __call__(self, value):\n-        \"\"\"Query value for the jmespath query and return answer\n-        :param value: a data structure (dict, list) to extract from\n-        :return: Element extracted according to jmespath query\n-        \"\"\"\n-        return self.compiled_path.search(value)\n-\n-\n-class Join:\n-\n-    def __init__(self, separator=u' '):\n-        self.separator = separator\n-\n-    def __call__(self, values):\n-        return self.separator.join(values)\n+from itemloaders.processors import *",
      "comment": "Maybe it's better to import each processor individually. This way we keep a text reference to them instead of a dynamic \"import all\".",
      "comment_id": 416085570,
      "user": "victor-torres",
      "created_at": "2020-04-27T19:23:09Z",
      "url": "https://github.com/scrapy/scrapy/pull/4516#discussion_r416085570"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 4516,
      "file_path": "scrapy/loader/__init__.py",
      "line": 16,
      "side": "RIGHT",
      "diff_hunk": "@@ -3,219 +3,35 @@\n \n See documentation in docs/topics/loaders.rst\n \"\"\"\n-from collections import defaultdict\n-from contextlib import suppress\n+import itemloaders\n \n from scrapy.item import Item\n-from scrapy.loader.common import wrap_loader_context\n-from scrapy.loader.processors import Identity\n from scrapy.selector import Selector\n-from scrapy.utils.misc import arg_to_iter, extract_regex\n-from scrapy.utils.python import flatten\n \n-\n-def unbound_method(method):\n-    \"\"\"\n-    Allow to use single-argument functions as input or output processors\n-    (no need to define an unused first 'self' argument)\n-    \"\"\"\n-    with suppress(AttributeError):\n-        if '.' not in method.__qualname__:\n-            return method.__func__\n-    return method\n-\n-\n-class ItemLoader:\n+class ItemLoader(itemloaders.ItemLoader):\n \n     default_item_class = Item\n-    default_input_processor = Identity()\n-    default_output_processor = Identity()\n     default_selector_class = Selector\n \n-    def __init__(self, item=None, selector=None, response=None, parent=None, **context):\n+    def __init__(self, response=None, item=None, selector=None, parent=None, **context):",
      "comment": "Any reason for changing arguments order here? It might break code that doesn't make use of named args.",
      "comment_id": 416086594,
      "user": "victor-torres",
      "created_at": "2020-04-27T19:24:48Z",
      "url": "https://github.com/scrapy/scrapy/pull/4516#discussion_r416086594"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 4516,
      "file_path": "tests/test_loader.py",
      "line": 789,
      "side": "LEFT",
      "diff_hunk": "@@ -630,367 +227,6 @@ def test_avoid_reprocessing_without_initial_values_list(self):\n         self.assertEqual(NoInputReprocessingItemLoader(item=il_loaded).load_item(), {'title': 'FOO'})\n \n \n-class TestOutputProcessorDict(unittest.TestCase):\n-    def test_output_processor(self):\n-\n-        class TempDict(dict):\n-            def __init__(self, *args, **kwargs):\n-                super(TempDict, self).__init__(self, *args, **kwargs)\n-                self.setdefault('temp', 0.3)\n-\n-        class TempLoader(ItemLoader):\n-            default_item_class = TempDict\n-            default_input_processor = Identity()\n-            default_output_processor = Compose(TakeFirst())\n-\n-        loader = TempLoader()\n-        item = loader.load_item()\n-        self.assertIsInstance(item, TempDict)\n-        self.assertEqual(dict(item), {'temp': 0.3})\n-\n-\n-class TestOutputProcessorItem(unittest.TestCase):\n-    def test_output_processor(self):\n-\n-        class TempItem(Item):\n-            temp = Field()\n-\n-            def __init__(self, *args, **kwargs):\n-                super(TempItem, self).__init__(self, *args, **kwargs)\n-                self.setdefault('temp', 0.3)\n-\n-        class TempLoader(ItemLoader):\n-            default_item_class = TempItem\n-            default_input_processor = Identity()\n-            default_output_processor = Compose(TakeFirst())\n-\n-        loader = TempLoader()\n-        item = loader.load_item()\n-        self.assertIsInstance(item, TempItem)\n-        self.assertEqual(dict(item), {'temp': 0.3})\n-\n-\n-class ProcessorsTest(unittest.TestCase):\n-\n-    def test_take_first(self):\n-        proc = TakeFirst()\n-        self.assertEqual(proc([None, '', 'hello', 'world']), 'hello')\n-        self.assertEqual(proc([None, '', 0, 'hello', 'world']), 0)\n-\n-    def test_identity(self):\n-        proc = Identity()\n-        self.assertEqual(proc([None, '', 'hello', 'world']),\n-                         [None, '', 'hello', 'world'])\n-\n-    def test_join(self):\n-        proc = Join()\n-        self.assertRaises(TypeError, proc, [None, '', 'hello', 'world'])\n-        self.assertEqual(proc(['', 'hello', 'world']), u' hello world')\n-        self.assertEqual(proc(['hello', 'world']), u'hello world')\n-        self.assertIsInstance(proc(['hello', 'world']), str)\n-\n-    def test_compose(self):\n-        proc = Compose(lambda v: v[0], str.upper)\n-        self.assertEqual(proc(['hello', 'world']), 'HELLO')\n-        proc = Compose(str.upper)\n-        self.assertEqual(proc(None), None)\n-        proc = Compose(str.upper, stop_on_none=False)\n-        self.assertRaises(ValueError, proc, None)\n-        proc = Compose(str.upper, lambda x: x + 1)\n-        self.assertRaises(ValueError, proc, 'hello')\n-\n-    def test_mapcompose(self):\n-        def filter_world(x):\n-            return None if x == 'world' else x\n-        proc = MapCompose(filter_world, str.upper)\n-        self.assertEqual(proc([u'hello', u'world', u'this', u'is', u'scrapy']),\n-                         [u'HELLO', u'THIS', u'IS', u'SCRAPY'])\n-        proc = MapCompose(filter_world, str.upper)\n-        self.assertEqual(proc(None), [])\n-        proc = MapCompose(filter_world, str.upper)\n-        self.assertRaises(ValueError, proc, [1])\n-        proc = MapCompose(filter_world, lambda x: x + 1)\n-        self.assertRaises(ValueError, proc, 'hello')\n-\n-\n-class SelectortemLoaderTest(unittest.TestCase):\n-    response = HtmlResponse(url=\"\", encoding='utf-8', body=b\"\"\"\n-    <html>\n-    <body>\n-    <div id=\"id\">marta</div>\n-    <p>paragraph</p>\n-    <a href=\"http://www.scrapy.org\">homepage</a>\n-    <img src=\"/images/logo.png\" width=\"244\" height=\"65\" alt=\"Scrapy\">\n-    </body>\n-    </html>\n-    \"\"\")\n-\n-    def test_init_method(self):\n-        l = TestItemLoader()\n-        self.assertEqual(l.selector, None)\n-\n-    def test_init_method_errors(self):\n-        l = TestItemLoader()\n-        self.assertRaises(RuntimeError, l.add_xpath, 'url', '//a/@href')\n-        self.assertRaises(RuntimeError, l.replace_xpath, 'url', '//a/@href')\n-        self.assertRaises(RuntimeError, l.get_xpath, '//a/@href')\n-        self.assertRaises(RuntimeError, l.add_css, 'name', '#name::text')\n-        self.assertRaises(RuntimeError, l.replace_css, 'name', '#name::text')\n-        self.assertRaises(RuntimeError, l.get_css, '#name::text')\n-\n-    def test_init_method_with_selector(self):\n-        sel = Selector(text=u\"<html><body><div>marta</div></body></html>\")\n-        l = TestItemLoader(selector=sel)\n-        self.assertIs(l.selector, sel)\n-\n-        l.add_xpath('name', '//div/text()')\n-        self.assertEqual(l.get_output_value('name'), [u'Marta'])\n-\n-    def test_init_method_with_selector_css(self):\n-        sel = Selector(text=u\"<html><body><div>marta</div></body></html>\")\n-        l = TestItemLoader(selector=sel)\n-        self.assertIs(l.selector, sel)\n-\n-        l.add_css('name', 'div::text')\n-        self.assertEqual(l.get_output_value('name'), [u'Marta'])\n-\n-    def test_init_method_with_response(self):\n-        l = TestItemLoader(response=self.response)",
      "comment": "I think we should be keeping tests like that. This removal probably needs a more detailed review: everything which is related to response, or e.g. scrapy.Item, should be tested, because these are features which Scrapy's wrapper provides, not features which itemloaders library provides.\r\n\r\nI also wonder if many (most) other tests needs to be preserved: e.g. I can see how we could have implemented a scrapy ItemLoader subclass in a way which breaks itemloaders.ItemLoader's `selector` argument. Though we haven't done this for scrapy.Selector, so no strong opinion here.",
      "comment_id": 416102236,
      "user": "kmike",
      "created_at": "2020-04-27T19:50:30Z",
      "url": "https://github.com/scrapy/scrapy/pull/4516#discussion_r416102236"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 4516,
      "file_path": "scrapy/loader/processors.py",
      "line": 78,
      "side": "LEFT",
      "diff_hunk": "@@ -1,104 +1 @@\n-\"\"\"\n-This module provides some commonly used processors for Item Loaders.\n-\n-See documentation in docs/topics/loaders.rst\n-\"\"\"\n-from collections import ChainMap\n-\n-from scrapy.utils.misc import arg_to_iter\n-from scrapy.loader.common import wrap_loader_context\n-\n-\n-class MapCompose:\n-\n-    def __init__(self, *functions, **default_loader_context):\n-        self.functions = functions\n-        self.default_loader_context = default_loader_context\n-\n-    def __call__(self, value, loader_context=None):\n-        values = arg_to_iter(value)\n-        if loader_context:\n-            context = ChainMap(loader_context, self.default_loader_context)\n-        else:\n-            context = self.default_loader_context\n-        wrapped_funcs = [wrap_loader_context(f, context) for f in self.functions]\n-        for func in wrapped_funcs:\n-            next_values = []\n-            for v in values:\n-                try:\n-                    next_values += arg_to_iter(func(v))\n-                except Exception as e:\n-                    raise ValueError(\"Error in MapCompose with \"\n-                                     \"%s value=%r error='%s: %s'\" %\n-                                     (str(func), value, type(e).__name__,\n-                                      str(e)))\n-            values = next_values\n-        return values\n-\n-\n-class Compose:\n-\n-    def __init__(self, *functions, **default_loader_context):\n-        self.functions = functions\n-        self.stop_on_none = default_loader_context.get('stop_on_none', True)\n-        self.default_loader_context = default_loader_context\n-\n-    def __call__(self, value, loader_context=None):\n-        if loader_context:\n-            context = ChainMap(loader_context, self.default_loader_context)\n-        else:\n-            context = self.default_loader_context\n-        wrapped_funcs = [wrap_loader_context(f, context) for f in self.functions]\n-        for func in wrapped_funcs:\n-            if value is None and self.stop_on_none:\n-                break\n-            try:\n-                value = func(value)\n-            except Exception as e:\n-                raise ValueError(\"Error in Compose with \"\n-                                 \"%s value=%r error='%s: %s'\" %\n-                                 (str(func), value, type(e).__name__, str(e)))\n-        return value\n-\n-\n-class TakeFirst:\n-\n-    def __call__(self, values):\n-        for value in values:\n-            if value is not None and value != '':\n-                return value\n-\n-\n-class Identity:\n-\n-    def __call__(self, values):\n-        return values\n-\n-\n-class SelectJmes:",
      "comment": "If I'm not mistaken, this is the only place where jmespath is used in Scrapy; I wonder if its mentions should be removed (from docs, from CI?).",
      "comment_id": 416104805,
      "user": "kmike",
      "created_at": "2020-04-27T19:54:58Z",
      "url": "https://github.com/scrapy/scrapy/pull/4516#discussion_r416104805"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 4516,
      "file_path": "scrapy/loader/processors.py",
      "line": 1,
      "side": "RIGHT",
      "diff_hunk": "@@ -1,104 +1 @@\n-\"\"\"\n-This module provides some commonly used processors for Item Loaders.\n-\n-See documentation in docs/topics/loaders.rst\n-\"\"\"\n-from collections import ChainMap\n-\n-from scrapy.utils.misc import arg_to_iter\n-from scrapy.loader.common import wrap_loader_context\n-\n-\n-class MapCompose:\n-\n-    def __init__(self, *functions, **default_loader_context):\n-        self.functions = functions\n-        self.default_loader_context = default_loader_context\n-\n-    def __call__(self, value, loader_context=None):\n-        values = arg_to_iter(value)\n-        if loader_context:\n-            context = ChainMap(loader_context, self.default_loader_context)\n-        else:\n-            context = self.default_loader_context\n-        wrapped_funcs = [wrap_loader_context(f, context) for f in self.functions]\n-        for func in wrapped_funcs:\n-            next_values = []\n-            for v in values:\n-                try:\n-                    next_values += arg_to_iter(func(v))\n-                except Exception as e:\n-                    raise ValueError(\"Error in MapCompose with \"\n-                                     \"%s value=%r error='%s: %s'\" %\n-                                     (str(func), value, type(e).__name__,\n-                                      str(e)))\n-            values = next_values\n-        return values\n-\n-\n-class Compose:\n-\n-    def __init__(self, *functions, **default_loader_context):\n-        self.functions = functions\n-        self.stop_on_none = default_loader_context.get('stop_on_none', True)\n-        self.default_loader_context = default_loader_context\n-\n-    def __call__(self, value, loader_context=None):\n-        if loader_context:\n-            context = ChainMap(loader_context, self.default_loader_context)\n-        else:\n-            context = self.default_loader_context\n-        wrapped_funcs = [wrap_loader_context(f, context) for f in self.functions]\n-        for func in wrapped_funcs:\n-            if value is None and self.stop_on_none:\n-                break\n-            try:\n-                value = func(value)\n-            except Exception as e:\n-                raise ValueError(\"Error in Compose with \"\n-                                 \"%s value=%r error='%s: %s'\" %\n-                                 (str(func), value, type(e).__name__, str(e)))\n-        return value\n-\n-\n-class TakeFirst:\n-\n-    def __call__(self, values):\n-        for value in values:\n-            if value is not None and value != '':\n-                return value\n-\n-\n-class Identity:\n-\n-    def __call__(self, values):\n-        return values\n-\n-\n-class SelectJmes:\n-    \"\"\"\n-        Query the input string for the jmespath (given at instantiation),\n-        and return the answer\n-        Requires : jmespath(https://github.com/jmespath/jmespath)\n-        Note: SelectJmes accepts only one input element at a time.\n-    \"\"\"\n-    def __init__(self, json_path):\n-        self.json_path = json_path\n-        import jmespath\n-        self.compiled_path = jmespath.compile(self.json_path)\n-\n-    def __call__(self, value):\n-        \"\"\"Query value for the jmespath query and return answer\n-        :param value: a data structure (dict, list) to extract from\n-        :return: Element extracted according to jmespath query\n-        \"\"\"\n-        return self.compiled_path.search(value)\n-\n-\n-class Join:\n-\n-    def __init__(self, separator=u' '):\n-        self.separator = separator\n-\n-    def __call__(self, values):\n-        return self.separator.join(values)\n+from itemloaders.processors import *",
      "comment": "Because we have custom `Selector` subclasses in that case.",
      "comment_id": 416411838,
      "user": "Gallaecio",
      "created_at": "2020-04-28T08:02:47Z",
      "url": "https://github.com/scrapy/scrapy/pull/4516#discussion_r416411838"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 4516,
      "file_path": "scrapy/loader/processors.py",
      "line": 1,
      "side": "RIGHT",
      "diff_hunk": "@@ -1,104 +1 @@\n-\"\"\"\n-This module provides some commonly used processors for Item Loaders.\n-\n-See documentation in docs/topics/loaders.rst\n-\"\"\"\n-from collections import ChainMap\n-\n-from scrapy.utils.misc import arg_to_iter\n-from scrapy.loader.common import wrap_loader_context\n-\n-\n-class MapCompose:\n-\n-    def __init__(self, *functions, **default_loader_context):\n-        self.functions = functions\n-        self.default_loader_context = default_loader_context\n-\n-    def __call__(self, value, loader_context=None):\n-        values = arg_to_iter(value)\n-        if loader_context:\n-            context = ChainMap(loader_context, self.default_loader_context)\n-        else:\n-            context = self.default_loader_context\n-        wrapped_funcs = [wrap_loader_context(f, context) for f in self.functions]\n-        for func in wrapped_funcs:\n-            next_values = []\n-            for v in values:\n-                try:\n-                    next_values += arg_to_iter(func(v))\n-                except Exception as e:\n-                    raise ValueError(\"Error in MapCompose with \"\n-                                     \"%s value=%r error='%s: %s'\" %\n-                                     (str(func), value, type(e).__name__,\n-                                      str(e)))\n-            values = next_values\n-        return values\n-\n-\n-class Compose:\n-\n-    def __init__(self, *functions, **default_loader_context):\n-        self.functions = functions\n-        self.stop_on_none = default_loader_context.get('stop_on_none', True)\n-        self.default_loader_context = default_loader_context\n-\n-    def __call__(self, value, loader_context=None):\n-        if loader_context:\n-            context = ChainMap(loader_context, self.default_loader_context)\n-        else:\n-            context = self.default_loader_context\n-        wrapped_funcs = [wrap_loader_context(f, context) for f in self.functions]\n-        for func in wrapped_funcs:\n-            if value is None and self.stop_on_none:\n-                break\n-            try:\n-                value = func(value)\n-            except Exception as e:\n-                raise ValueError(\"Error in Compose with \"\n-                                 \"%s value=%r error='%s: %s'\" %\n-                                 (str(func), value, type(e).__name__, str(e)))\n-        return value\n-\n-\n-class TakeFirst:\n-\n-    def __call__(self, values):\n-        for value in values:\n-            if value is not None and value != '':\n-                return value\n-\n-\n-class Identity:\n-\n-    def __call__(self, values):\n-        return values\n-\n-\n-class SelectJmes:\n-    \"\"\"\n-        Query the input string for the jmespath (given at instantiation),\n-        and return the answer\n-        Requires : jmespath(https://github.com/jmespath/jmespath)\n-        Note: SelectJmes accepts only one input element at a time.\n-    \"\"\"\n-    def __init__(self, json_path):\n-        self.json_path = json_path\n-        import jmespath\n-        self.compiled_path = jmespath.compile(self.json_path)\n-\n-    def __call__(self, value):\n-        \"\"\"Query value for the jmespath query and return answer\n-        :param value: a data structure (dict, list) to extract from\n-        :return: Element extracted according to jmespath query\n-        \"\"\"\n-        return self.compiled_path.search(value)\n-\n-\n-class Join:\n-\n-    def __init__(self, separator=u' '):\n-        self.separator = separator\n-\n-    def __call__(self, values):\n-        return self.separator.join(values)\n+from itemloaders.processors import *",
      "comment": "we do it for w3lib imports, e.g. https://github.com/scrapy/scrapy/blob/master/scrapy/utils/http.py (some other cases like that have been removed)",
      "comment_id": 416442404,
      "user": "kmike",
      "created_at": "2020-04-28T08:50:03Z",
      "url": "https://github.com/scrapy/scrapy/pull/4516#discussion_r416442404"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 4516,
      "file_path": "scrapy/loader/processors.py",
      "line": 1,
      "side": "RIGHT",
      "diff_hunk": "@@ -1,104 +1 @@\n-\"\"\"\n-This module provides some commonly used processors for Item Loaders.\n-\n-See documentation in docs/topics/loaders.rst\n-\"\"\"\n-from collections import ChainMap\n-\n-from scrapy.utils.misc import arg_to_iter\n-from scrapy.loader.common import wrap_loader_context\n-\n-\n-class MapCompose:\n-\n-    def __init__(self, *functions, **default_loader_context):\n-        self.functions = functions\n-        self.default_loader_context = default_loader_context\n-\n-    def __call__(self, value, loader_context=None):\n-        values = arg_to_iter(value)\n-        if loader_context:\n-            context = ChainMap(loader_context, self.default_loader_context)\n-        else:\n-            context = self.default_loader_context\n-        wrapped_funcs = [wrap_loader_context(f, context) for f in self.functions]\n-        for func in wrapped_funcs:\n-            next_values = []\n-            for v in values:\n-                try:\n-                    next_values += arg_to_iter(func(v))\n-                except Exception as e:\n-                    raise ValueError(\"Error in MapCompose with \"\n-                                     \"%s value=%r error='%s: %s'\" %\n-                                     (str(func), value, type(e).__name__,\n-                                      str(e)))\n-            values = next_values\n-        return values\n-\n-\n-class Compose:\n-\n-    def __init__(self, *functions, **default_loader_context):\n-        self.functions = functions\n-        self.stop_on_none = default_loader_context.get('stop_on_none', True)\n-        self.default_loader_context = default_loader_context\n-\n-    def __call__(self, value, loader_context=None):\n-        if loader_context:\n-            context = ChainMap(loader_context, self.default_loader_context)\n-        else:\n-            context = self.default_loader_context\n-        wrapped_funcs = [wrap_loader_context(f, context) for f in self.functions]\n-        for func in wrapped_funcs:\n-            if value is None and self.stop_on_none:\n-                break\n-            try:\n-                value = func(value)\n-            except Exception as e:\n-                raise ValueError(\"Error in Compose with \"\n-                                 \"%s value=%r error='%s: %s'\" %\n-                                 (str(func), value, type(e).__name__, str(e)))\n-        return value\n-\n-\n-class TakeFirst:\n-\n-    def __call__(self, values):\n-        for value in values:\n-            if value is not None and value != '':\n-                return value\n-\n-\n-class Identity:\n-\n-    def __call__(self, values):\n-        return values\n-\n-\n-class SelectJmes:\n-    \"\"\"\n-        Query the input string for the jmespath (given at instantiation),\n-        and return the answer\n-        Requires : jmespath(https://github.com/jmespath/jmespath)\n-        Note: SelectJmes accepts only one input element at a time.\n-    \"\"\"\n-    def __init__(self, json_path):\n-        self.json_path = json_path\n-        import jmespath\n-        self.compiled_path = jmespath.compile(self.json_path)\n-\n-    def __call__(self, value):\n-        \"\"\"Query value for the jmespath query and return answer\n-        :param value: a data structure (dict, list) to extract from\n-        :return: Element extracted according to jmespath query\n-        \"\"\"\n-        return self.compiled_path.search(value)\n-\n-\n-class Join:\n-\n-    def __init__(self, separator=u' '):\n-        self.separator = separator\n-\n-    def __call__(self, values):\n-        return self.separator.join(values)\n+from itemloaders.processors import *",
      "comment": "or https://github.com/scrapy/scrapy/blob/master/scrapy/utils/markup.py",
      "comment_id": 416442599,
      "user": "kmike",
      "created_at": "2020-04-28T08:50:23Z",
      "url": "https://github.com/scrapy/scrapy/pull/4516#discussion_r416442599"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 4516,
      "file_path": "scrapy/loader/common.py",
      "line": 14,
      "side": "LEFT",
      "diff_hunk": "@@ -1,14 +0,0 @@\n-\"\"\"Common functions used in Item Loaders code\"\"\"\n-\n-from functools import partial\n-from scrapy.utils.python import get_func_args\n-\n-\n-def wrap_loader_context(function, context):\n-    \"\"\"Wrap functions that receive loader_context to contain the context\n-    \"pre-loaded\" and expose a interface that receives only one argument\n-    \"\"\"\n-    if 'loader_context' in get_func_args(function):\n-        return partial(function, loader_context=context)\n-    else:\n-        return function",
      "comment": "I guess keeping the import is better than adding a deprecation, thoughts?\r\nAlso, I removed it as it doesn't appear in the docs https://docs.scrapy.org/en/latest/topics/loaders.html, so it shouldn't be used outside `ItemLoader`, or am I missing something here?",
      "comment_id": 417211736,
      "user": "ejulio",
      "created_at": "2020-04-29T10:22:26Z",
      "url": "https://github.com/scrapy/scrapy/pull/4516#discussion_r417211736"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 4516,
      "file_path": "scrapy/loader/processors.py",
      "line": 1,
      "side": "RIGHT",
      "diff_hunk": "@@ -1,104 +1 @@\n-\"\"\"\n-This module provides some commonly used processors for Item Loaders.\n-\n-See documentation in docs/topics/loaders.rst\n-\"\"\"\n-from collections import ChainMap\n-\n-from scrapy.utils.misc import arg_to_iter\n-from scrapy.loader.common import wrap_loader_context\n-\n-\n-class MapCompose:\n-\n-    def __init__(self, *functions, **default_loader_context):\n-        self.functions = functions\n-        self.default_loader_context = default_loader_context\n-\n-    def __call__(self, value, loader_context=None):\n-        values = arg_to_iter(value)\n-        if loader_context:\n-            context = ChainMap(loader_context, self.default_loader_context)\n-        else:\n-            context = self.default_loader_context\n-        wrapped_funcs = [wrap_loader_context(f, context) for f in self.functions]\n-        for func in wrapped_funcs:\n-            next_values = []\n-            for v in values:\n-                try:\n-                    next_values += arg_to_iter(func(v))\n-                except Exception as e:\n-                    raise ValueError(\"Error in MapCompose with \"\n-                                     \"%s value=%r error='%s: %s'\" %\n-                                     (str(func), value, type(e).__name__,\n-                                      str(e)))\n-            values = next_values\n-        return values\n-\n-\n-class Compose:\n-\n-    def __init__(self, *functions, **default_loader_context):\n-        self.functions = functions\n-        self.stop_on_none = default_loader_context.get('stop_on_none', True)\n-        self.default_loader_context = default_loader_context\n-\n-    def __call__(self, value, loader_context=None):\n-        if loader_context:\n-            context = ChainMap(loader_context, self.default_loader_context)\n-        else:\n-            context = self.default_loader_context\n-        wrapped_funcs = [wrap_loader_context(f, context) for f in self.functions]\n-        for func in wrapped_funcs:\n-            if value is None and self.stop_on_none:\n-                break\n-            try:\n-                value = func(value)\n-            except Exception as e:\n-                raise ValueError(\"Error in Compose with \"\n-                                 \"%s value=%r error='%s: %s'\" %\n-                                 (str(func), value, type(e).__name__, str(e)))\n-        return value\n-\n-\n-class TakeFirst:\n-\n-    def __call__(self, values):\n-        for value in values:\n-            if value is not None and value != '':\n-                return value\n-\n-\n-class Identity:\n-\n-    def __call__(self, values):\n-        return values\n-\n-\n-class SelectJmes:\n-    \"\"\"\n-        Query the input string for the jmespath (given at instantiation),\n-        and return the answer\n-        Requires : jmespath(https://github.com/jmespath/jmespath)\n-        Note: SelectJmes accepts only one input element at a time.\n-    \"\"\"\n-    def __init__(self, json_path):\n-        self.json_path = json_path\n-        import jmespath\n-        self.compiled_path = jmespath.compile(self.json_path)\n-\n-    def __call__(self, value):\n-        \"\"\"Query value for the jmespath query and return answer\n-        :param value: a data structure (dict, list) to extract from\n-        :return: Element extracted according to jmespath query\n-        \"\"\"\n-        return self.compiled_path.search(value)\n-\n-\n-class Join:\n-\n-    def __init__(self, separator=u' '):\n-        self.separator = separator\n-\n-    def __call__(self, values):\n-        return self.separator.join(values)\n+from itemloaders.processors import *",
      "comment": "I guess this is fine, though, for any new processor, we'll need to update this piece of code.\r\nUnless, we import them with some deprecation warning as mentioned above.",
      "comment_id": 417212448,
      "user": "ejulio",
      "created_at": "2020-04-29T10:23:50Z",
      "url": "https://github.com/scrapy/scrapy/pull/4516#discussion_r417212448"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 4516,
      "file_path": "scrapy/loader/processors.py",
      "line": 1,
      "side": "RIGHT",
      "diff_hunk": "@@ -1,104 +1 @@\n-\"\"\"\n-This module provides some commonly used processors for Item Loaders.\n-\n-See documentation in docs/topics/loaders.rst\n-\"\"\"\n-from collections import ChainMap\n-\n-from scrapy.utils.misc import arg_to_iter\n-from scrapy.loader.common import wrap_loader_context\n-\n-\n-class MapCompose:\n-\n-    def __init__(self, *functions, **default_loader_context):\n-        self.functions = functions\n-        self.default_loader_context = default_loader_context\n-\n-    def __call__(self, value, loader_context=None):\n-        values = arg_to_iter(value)\n-        if loader_context:\n-            context = ChainMap(loader_context, self.default_loader_context)\n-        else:\n-            context = self.default_loader_context\n-        wrapped_funcs = [wrap_loader_context(f, context) for f in self.functions]\n-        for func in wrapped_funcs:\n-            next_values = []\n-            for v in values:\n-                try:\n-                    next_values += arg_to_iter(func(v))\n-                except Exception as e:\n-                    raise ValueError(\"Error in MapCompose with \"\n-                                     \"%s value=%r error='%s: %s'\" %\n-                                     (str(func), value, type(e).__name__,\n-                                      str(e)))\n-            values = next_values\n-        return values\n-\n-\n-class Compose:\n-\n-    def __init__(self, *functions, **default_loader_context):\n-        self.functions = functions\n-        self.stop_on_none = default_loader_context.get('stop_on_none', True)\n-        self.default_loader_context = default_loader_context\n-\n-    def __call__(self, value, loader_context=None):\n-        if loader_context:\n-            context = ChainMap(loader_context, self.default_loader_context)\n-        else:\n-            context = self.default_loader_context\n-        wrapped_funcs = [wrap_loader_context(f, context) for f in self.functions]\n-        for func in wrapped_funcs:\n-            if value is None and self.stop_on_none:\n-                break\n-            try:\n-                value = func(value)\n-            except Exception as e:\n-                raise ValueError(\"Error in Compose with \"\n-                                 \"%s value=%r error='%s: %s'\" %\n-                                 (str(func), value, type(e).__name__, str(e)))\n-        return value\n-\n-\n-class TakeFirst:\n-\n-    def __call__(self, values):\n-        for value in values:\n-            if value is not None and value != '':\n-                return value\n-\n-\n-class Identity:\n-\n-    def __call__(self, values):\n-        return values\n-\n-\n-class SelectJmes:\n-    \"\"\"\n-        Query the input string for the jmespath (given at instantiation),\n-        and return the answer\n-        Requires : jmespath(https://github.com/jmespath/jmespath)\n-        Note: SelectJmes accepts only one input element at a time.\n-    \"\"\"\n-    def __init__(self, json_path):\n-        self.json_path = json_path\n-        import jmespath\n-        self.compiled_path = jmespath.compile(self.json_path)\n-\n-    def __call__(self, value):\n-        \"\"\"Query value for the jmespath query and return answer\n-        :param value: a data structure (dict, list) to extract from\n-        :return: Element extracted according to jmespath query\n-        \"\"\"\n-        return self.compiled_path.search(value)\n-\n-\n-class Join:\n-\n-    def __init__(self, separator=u' '):\n-        self.separator = separator\n-\n-    def __call__(self, values):\n-        return self.separator.join(values)\n+from itemloaders.processors import *",
      "comment": "Here we have both options.\r\nConsider a deprecation and help people move to `itemloaders`, or just import it as part of `scrapy`.\r\nWhich one is preferred?",
      "comment_id": 417213063,
      "user": "ejulio",
      "created_at": "2020-04-29T10:25:03Z",
      "url": "https://github.com/scrapy/scrapy/pull/4516#discussion_r417213063"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 4516,
      "file_path": "tests/test_loader.py",
      "line": 789,
      "side": "LEFT",
      "diff_hunk": "@@ -630,367 +227,6 @@ def test_avoid_reprocessing_without_initial_values_list(self):\n         self.assertEqual(NoInputReprocessingItemLoader(item=il_loaded).load_item(), {'title': 'FOO'})\n \n \n-class TestOutputProcessorDict(unittest.TestCase):\n-    def test_output_processor(self):\n-\n-        class TempDict(dict):\n-            def __init__(self, *args, **kwargs):\n-                super(TempDict, self).__init__(self, *args, **kwargs)\n-                self.setdefault('temp', 0.3)\n-\n-        class TempLoader(ItemLoader):\n-            default_item_class = TempDict\n-            default_input_processor = Identity()\n-            default_output_processor = Compose(TakeFirst())\n-\n-        loader = TempLoader()\n-        item = loader.load_item()\n-        self.assertIsInstance(item, TempDict)\n-        self.assertEqual(dict(item), {'temp': 0.3})\n-\n-\n-class TestOutputProcessorItem(unittest.TestCase):\n-    def test_output_processor(self):\n-\n-        class TempItem(Item):\n-            temp = Field()\n-\n-            def __init__(self, *args, **kwargs):\n-                super(TempItem, self).__init__(self, *args, **kwargs)\n-                self.setdefault('temp', 0.3)\n-\n-        class TempLoader(ItemLoader):\n-            default_item_class = TempItem\n-            default_input_processor = Identity()\n-            default_output_processor = Compose(TakeFirst())\n-\n-        loader = TempLoader()\n-        item = loader.load_item()\n-        self.assertIsInstance(item, TempItem)\n-        self.assertEqual(dict(item), {'temp': 0.3})\n-\n-\n-class ProcessorsTest(unittest.TestCase):\n-\n-    def test_take_first(self):\n-        proc = TakeFirst()\n-        self.assertEqual(proc([None, '', 'hello', 'world']), 'hello')\n-        self.assertEqual(proc([None, '', 0, 'hello', 'world']), 0)\n-\n-    def test_identity(self):\n-        proc = Identity()\n-        self.assertEqual(proc([None, '', 'hello', 'world']),\n-                         [None, '', 'hello', 'world'])\n-\n-    def test_join(self):\n-        proc = Join()\n-        self.assertRaises(TypeError, proc, [None, '', 'hello', 'world'])\n-        self.assertEqual(proc(['', 'hello', 'world']), u' hello world')\n-        self.assertEqual(proc(['hello', 'world']), u'hello world')\n-        self.assertIsInstance(proc(['hello', 'world']), str)\n-\n-    def test_compose(self):\n-        proc = Compose(lambda v: v[0], str.upper)\n-        self.assertEqual(proc(['hello', 'world']), 'HELLO')\n-        proc = Compose(str.upper)\n-        self.assertEqual(proc(None), None)\n-        proc = Compose(str.upper, stop_on_none=False)\n-        self.assertRaises(ValueError, proc, None)\n-        proc = Compose(str.upper, lambda x: x + 1)\n-        self.assertRaises(ValueError, proc, 'hello')\n-\n-    def test_mapcompose(self):\n-        def filter_world(x):\n-            return None if x == 'world' else x\n-        proc = MapCompose(filter_world, str.upper)\n-        self.assertEqual(proc([u'hello', u'world', u'this', u'is', u'scrapy']),\n-                         [u'HELLO', u'THIS', u'IS', u'SCRAPY'])\n-        proc = MapCompose(filter_world, str.upper)\n-        self.assertEqual(proc(None), [])\n-        proc = MapCompose(filter_world, str.upper)\n-        self.assertRaises(ValueError, proc, [1])\n-        proc = MapCompose(filter_world, lambda x: x + 1)\n-        self.assertRaises(ValueError, proc, 'hello')\n-\n-\n-class SelectortemLoaderTest(unittest.TestCase):\n-    response = HtmlResponse(url=\"\", encoding='utf-8', body=b\"\"\"\n-    <html>\n-    <body>\n-    <div id=\"id\">marta</div>\n-    <p>paragraph</p>\n-    <a href=\"http://www.scrapy.org\">homepage</a>\n-    <img src=\"/images/logo.png\" width=\"244\" height=\"65\" alt=\"Scrapy\">\n-    </body>\n-    </html>\n-    \"\"\")\n-\n-    def test_init_method(self):\n-        l = TestItemLoader()\n-        self.assertEqual(l.selector, None)\n-\n-    def test_init_method_errors(self):\n-        l = TestItemLoader()\n-        self.assertRaises(RuntimeError, l.add_xpath, 'url', '//a/@href')\n-        self.assertRaises(RuntimeError, l.replace_xpath, 'url', '//a/@href')\n-        self.assertRaises(RuntimeError, l.get_xpath, '//a/@href')\n-        self.assertRaises(RuntimeError, l.add_css, 'name', '#name::text')\n-        self.assertRaises(RuntimeError, l.replace_css, 'name', '#name::text')\n-        self.assertRaises(RuntimeError, l.get_css, '#name::text')\n-\n-    def test_init_method_with_selector(self):\n-        sel = Selector(text=u\"<html><body><div>marta</div></body></html>\")\n-        l = TestItemLoader(selector=sel)\n-        self.assertIs(l.selector, sel)\n-\n-        l.add_xpath('name', '//div/text()')\n-        self.assertEqual(l.get_output_value('name'), [u'Marta'])\n-\n-    def test_init_method_with_selector_css(self):\n-        sel = Selector(text=u\"<html><body><div>marta</div></body></html>\")\n-        l = TestItemLoader(selector=sel)\n-        self.assertIs(l.selector, sel)\n-\n-        l.add_css('name', 'div::text')\n-        self.assertEqual(l.get_output_value('name'), [u'Marta'])\n-\n-    def test_init_method_with_response(self):\n-        l = TestItemLoader(response=self.response)",
      "comment": "Makes sense to me.\r\nThe ones I removed were related to a usage of `response` in which I transformed to `selector` in `itemloaders`.\r\nBut I'm in favor of keeping the ones referencing `response`..",
      "comment_id": 417214686,
      "user": "ejulio",
      "created_at": "2020-04-29T10:28:15Z",
      "url": "https://github.com/scrapy/scrapy/pull/4516#discussion_r417214686"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 4516,
      "file_path": "scrapy/loader/processors.py",
      "line": 78,
      "side": "LEFT",
      "diff_hunk": "@@ -1,104 +1 @@\n-\"\"\"\n-This module provides some commonly used processors for Item Loaders.\n-\n-See documentation in docs/topics/loaders.rst\n-\"\"\"\n-from collections import ChainMap\n-\n-from scrapy.utils.misc import arg_to_iter\n-from scrapy.loader.common import wrap_loader_context\n-\n-\n-class MapCompose:\n-\n-    def __init__(self, *functions, **default_loader_context):\n-        self.functions = functions\n-        self.default_loader_context = default_loader_context\n-\n-    def __call__(self, value, loader_context=None):\n-        values = arg_to_iter(value)\n-        if loader_context:\n-            context = ChainMap(loader_context, self.default_loader_context)\n-        else:\n-            context = self.default_loader_context\n-        wrapped_funcs = [wrap_loader_context(f, context) for f in self.functions]\n-        for func in wrapped_funcs:\n-            next_values = []\n-            for v in values:\n-                try:\n-                    next_values += arg_to_iter(func(v))\n-                except Exception as e:\n-                    raise ValueError(\"Error in MapCompose with \"\n-                                     \"%s value=%r error='%s: %s'\" %\n-                                     (str(func), value, type(e).__name__,\n-                                      str(e)))\n-            values = next_values\n-        return values\n-\n-\n-class Compose:\n-\n-    def __init__(self, *functions, **default_loader_context):\n-        self.functions = functions\n-        self.stop_on_none = default_loader_context.get('stop_on_none', True)\n-        self.default_loader_context = default_loader_context\n-\n-    def __call__(self, value, loader_context=None):\n-        if loader_context:\n-            context = ChainMap(loader_context, self.default_loader_context)\n-        else:\n-            context = self.default_loader_context\n-        wrapped_funcs = [wrap_loader_context(f, context) for f in self.functions]\n-        for func in wrapped_funcs:\n-            if value is None and self.stop_on_none:\n-                break\n-            try:\n-                value = func(value)\n-            except Exception as e:\n-                raise ValueError(\"Error in Compose with \"\n-                                 \"%s value=%r error='%s: %s'\" %\n-                                 (str(func), value, type(e).__name__, str(e)))\n-        return value\n-\n-\n-class TakeFirst:\n-\n-    def __call__(self, values):\n-        for value in values:\n-            if value is not None and value != '':\n-                return value\n-\n-\n-class Identity:\n-\n-    def __call__(self, values):\n-        return values\n-\n-\n-class SelectJmes:",
      "comment": "Removed the dependency.\r\nI'll remove from the docs once I update it referencing the library",
      "comment_id": 417217498,
      "user": "ejulio",
      "created_at": "2020-04-29T10:33:26Z",
      "url": "https://github.com/scrapy/scrapy/pull/4516#discussion_r417217498"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 4516,
      "file_path": "scrapy/loader/processors.py",
      "line": 1,
      "side": "RIGHT",
      "diff_hunk": "@@ -1,104 +1 @@\n-\"\"\"\n-This module provides some commonly used processors for Item Loaders.\n-\n-See documentation in docs/topics/loaders.rst\n-\"\"\"\n-from collections import ChainMap\n-\n-from scrapy.utils.misc import arg_to_iter\n-from scrapy.loader.common import wrap_loader_context\n-\n-\n-class MapCompose:\n-\n-    def __init__(self, *functions, **default_loader_context):\n-        self.functions = functions\n-        self.default_loader_context = default_loader_context\n-\n-    def __call__(self, value, loader_context=None):\n-        values = arg_to_iter(value)\n-        if loader_context:\n-            context = ChainMap(loader_context, self.default_loader_context)\n-        else:\n-            context = self.default_loader_context\n-        wrapped_funcs = [wrap_loader_context(f, context) for f in self.functions]\n-        for func in wrapped_funcs:\n-            next_values = []\n-            for v in values:\n-                try:\n-                    next_values += arg_to_iter(func(v))\n-                except Exception as e:\n-                    raise ValueError(\"Error in MapCompose with \"\n-                                     \"%s value=%r error='%s: %s'\" %\n-                                     (str(func), value, type(e).__name__,\n-                                      str(e)))\n-            values = next_values\n-        return values\n-\n-\n-class Compose:\n-\n-    def __init__(self, *functions, **default_loader_context):\n-        self.functions = functions\n-        self.stop_on_none = default_loader_context.get('stop_on_none', True)\n-        self.default_loader_context = default_loader_context\n-\n-    def __call__(self, value, loader_context=None):\n-        if loader_context:\n-            context = ChainMap(loader_context, self.default_loader_context)\n-        else:\n-            context = self.default_loader_context\n-        wrapped_funcs = [wrap_loader_context(f, context) for f in self.functions]\n-        for func in wrapped_funcs:\n-            if value is None and self.stop_on_none:\n-                break\n-            try:\n-                value = func(value)\n-            except Exception as e:\n-                raise ValueError(\"Error in Compose with \"\n-                                 \"%s value=%r error='%s: %s'\" %\n-                                 (str(func), value, type(e).__name__, str(e)))\n-        return value\n-\n-\n-class TakeFirst:\n-\n-    def __call__(self, values):\n-        for value in values:\n-            if value is not None and value != '':\n-                return value\n-\n-\n-class Identity:\n-\n-    def __call__(self, values):\n-        return values\n-\n-\n-class SelectJmes:\n-    \"\"\"\n-        Query the input string for the jmespath (given at instantiation),\n-        and return the answer\n-        Requires : jmespath(https://github.com/jmespath/jmespath)\n-        Note: SelectJmes accepts only one input element at a time.\n-    \"\"\"\n-    def __init__(self, json_path):\n-        self.json_path = json_path\n-        import jmespath\n-        self.compiled_path = jmespath.compile(self.json_path)\n-\n-    def __call__(self, value):\n-        \"\"\"Query value for the jmespath query and return answer\n-        :param value: a data structure (dict, list) to extract from\n-        :return: Element extracted according to jmespath query\n-        \"\"\"\n-        return self.compiled_path.search(value)\n-\n-\n-class Join:\n-\n-    def __init__(self, separator=u' '):\n-        self.separator = separator\n-\n-    def __call__(self, values):\n-        return self.separator.join(values)\n+from itemloaders.processors import *",
      "comment": "I think we should issue a deprcation warning and ask people to use itemloaders.",
      "comment_id": 417235598,
      "user": "kmike",
      "created_at": "2020-04-29T11:09:45Z",
      "url": "https://github.com/scrapy/scrapy/pull/4516#discussion_r417235598"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 4516,
      "file_path": "scrapy/loader/common.py",
      "line": 14,
      "side": "LEFT",
      "diff_hunk": "@@ -1,14 +0,0 @@\n-\"\"\"Common functions used in Item Loaders code\"\"\"\n-\n-from functools import partial\n-from scrapy.utils.python import get_func_args\n-\n-\n-def wrap_loader_context(function, context):\n-    \"\"\"Wrap functions that receive loader_context to contain the context\n-    \"pre-loaded\" and expose a interface that receives only one argument\n-    \"\"\"\n-    if 'loader_context' in get_func_args(function):\n-        return partial(function, loader_context=context)\n-    else:\n-        return function",
      "comment": "Yes, an import + deprecation warning. \r\n\r\nWe're usually trying to be quite careful about deprecations, and even parts which were not publicly documented are going through deprecation process. \r\n\r\nHere you can also make an argument that the module is not private (not _common), and the function  is not private (not _wrap_loader_context).",
      "comment_id": 417237008,
      "user": "kmike",
      "created_at": "2020-04-29T11:12:44Z",
      "url": "https://github.com/scrapy/scrapy/pull/4516#discussion_r417237008"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 4516,
      "file_path": "scrapy/loader/processors.py",
      "line": 1,
      "side": "RIGHT",
      "diff_hunk": "@@ -1,104 +1 @@\n-\"\"\"\n-This module provides some commonly used processors for Item Loaders.\n-\n-See documentation in docs/topics/loaders.rst\n-\"\"\"\n-from collections import ChainMap\n-\n-from scrapy.utils.misc import arg_to_iter\n-from scrapy.loader.common import wrap_loader_context\n-\n-\n-class MapCompose:\n-\n-    def __init__(self, *functions, **default_loader_context):\n-        self.functions = functions\n-        self.default_loader_context = default_loader_context\n-\n-    def __call__(self, value, loader_context=None):\n-        values = arg_to_iter(value)\n-        if loader_context:\n-            context = ChainMap(loader_context, self.default_loader_context)\n-        else:\n-            context = self.default_loader_context\n-        wrapped_funcs = [wrap_loader_context(f, context) for f in self.functions]\n-        for func in wrapped_funcs:\n-            next_values = []\n-            for v in values:\n-                try:\n-                    next_values += arg_to_iter(func(v))\n-                except Exception as e:\n-                    raise ValueError(\"Error in MapCompose with \"\n-                                     \"%s value=%r error='%s: %s'\" %\n-                                     (str(func), value, type(e).__name__,\n-                                      str(e)))\n-            values = next_values\n-        return values\n-\n-\n-class Compose:\n-\n-    def __init__(self, *functions, **default_loader_context):\n-        self.functions = functions\n-        self.stop_on_none = default_loader_context.get('stop_on_none', True)\n-        self.default_loader_context = default_loader_context\n-\n-    def __call__(self, value, loader_context=None):\n-        if loader_context:\n-            context = ChainMap(loader_context, self.default_loader_context)\n-        else:\n-            context = self.default_loader_context\n-        wrapped_funcs = [wrap_loader_context(f, context) for f in self.functions]\n-        for func in wrapped_funcs:\n-            if value is None and self.stop_on_none:\n-                break\n-            try:\n-                value = func(value)\n-            except Exception as e:\n-                raise ValueError(\"Error in Compose with \"\n-                                 \"%s value=%r error='%s: %s'\" %\n-                                 (str(func), value, type(e).__name__, str(e)))\n-        return value\n-\n-\n-class TakeFirst:\n-\n-    def __call__(self, values):\n-        for value in values:\n-            if value is not None and value != '':\n-                return value\n-\n-\n-class Identity:\n-\n-    def __call__(self, values):\n-        return values\n-\n-\n-class SelectJmes:\n-    \"\"\"\n-        Query the input string for the jmespath (given at instantiation),\n-        and return the answer\n-        Requires : jmespath(https://github.com/jmespath/jmespath)\n-        Note: SelectJmes accepts only one input element at a time.\n-    \"\"\"\n-    def __init__(self, json_path):\n-        self.json_path = json_path\n-        import jmespath\n-        self.compiled_path = jmespath.compile(self.json_path)\n-\n-    def __call__(self, value):\n-        \"\"\"Query value for the jmespath query and return answer\n-        :param value: a data structure (dict, list) to extract from\n-        :return: Element extracted according to jmespath query\n-        \"\"\"\n-        return self.compiled_path.search(value)\n-\n-\n-class Join:\n-\n-    def __init__(self, separator=u' '):\n-        self.separator = separator\n-\n-    def __call__(self, values):\n-        return self.separator.join(values)\n+from itemloaders.processors import *",
      "comment": "Actually, since the goal is for people to import directly from `itemloaders` (which is why this module should yield a warning when imported), even if `itemloaders` adds new processors we would not want them imported here.",
      "comment_id": 418588261,
      "user": "Gallaecio",
      "created_at": "2020-05-01T15:20:00Z",
      "url": "https://github.com/scrapy/scrapy/pull/4516#discussion_r418588261"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 4516,
      "file_path": "scrapy/loader/processors.py",
      "line": 25,
      "side": "RIGHT",
      "diff_hunk": "@@ -4,101 +4,61 @@\n See documentation in docs/topics/loaders.rst\n \"\"\"\n from collections import ChainMap\n+import warnings\n+\n+from itemloaders import processors\n \n-from scrapy.utils.misc import arg_to_iter\n from scrapy.loader.common import wrap_loader_context\n+from scrapy.utils.deprecate import ScrapyDeprecationWarning\n+from scrapy.utils.misc import arg_to_iter\n+\n+\n+def deprecation_warning(cls):\n+    \"\"\" ATTENTION: When removing these references, also remove tests/test_loader_deprecated.py\"\"\"\n+    warnings.warn(\n+        f\"{cls.__module__}.{cls.__name__} has moved to a new library.\"\n+        f\"Please update your reference to itemloaders.processors.{cls.__name__}\",\n+        ScrapyDeprecationWarning\n+    )\n \n \n-class MapCompose:\n+class MapCompose(processors.MapCompose):",
      "comment": "I wonder if you can use scrapy.utils.deprecate.create_deprecated_class here",
      "comment_id": 418982566,
      "user": "kmike",
      "created_at": "2020-05-02T17:07:06Z",
      "url": "https://github.com/scrapy/scrapy/pull/4516#discussion_r418982566"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 4516,
      "file_path": "docs/conf.py",
      "line": 291,
      "side": "RIGHT",
      "diff_hunk": "@@ -288,6 +288,7 @@\n     'tox': ('https://tox.readthedocs.io/en/latest', None),\n     'twisted': ('https://twistedmatrix.com/documents/current', None),\n     'twistedapi': ('https://twistedmatrix.com/documents/current/api', None),\n+    'itemloaders': ('https://itemloaders.readthedocs.io/en/latest/', None),",
      "comment": ":lipstick: Let\u2019s keep it alphabetical :nerd_face: ",
      "comment_id": 422493624,
      "user": "Gallaecio",
      "created_at": "2020-05-09T13:05:04Z",
      "url": "https://github.com/scrapy/scrapy/pull/4516#discussion_r422493624"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 4516,
      "file_path": "scrapy/loader/common.py",
      "line": 4,
      "side": "RIGHT",
      "diff_hunk": "@@ -1,14 +1,19 @@\n \"\"\"Common functions used in Item Loaders code\"\"\"\n \n from functools import partial\n+import warnings",
      "comment": ":lipstick: \r\n\r\n```suggestion\r\nimport warnings\r\nfrom functools import partial\r\n```",
      "comment_id": 423748634,
      "user": "Gallaecio",
      "created_at": "2020-05-12T13:49:48Z",
      "url": "https://github.com/scrapy/scrapy/pull/4516#discussion_r423748634"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 4516,
      "file_path": "scrapy/loader/common.py",
      "line": 9,
      "side": "RIGHT",
      "diff_hunk": "@@ -1,14 +1,19 @@\n \"\"\"Common functions used in Item Loaders code\"\"\"\n \n from functools import partial\n+import warnings\n+\n+from itemloaders import common\n+\n from scrapy.utils.python import get_func_args\n+from scrapy.utils.deprecate import ScrapyDeprecationWarning",
      "comment": ":lipstick: \r\n\r\n```suggestion\r\nfrom scrapy.utils.deprecate import ScrapyDeprecationWarning\r\nfrom scrapy.utils.python import get_func_args\r\n```",
      "comment_id": 423749069,
      "user": "Gallaecio",
      "created_at": "2020-05-12T13:50:18Z",
      "url": "https://github.com/scrapy/scrapy/pull/4516#discussion_r423749069"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 4516,
      "file_path": "scrapy/loader/common.py",
      "line": 10,
      "side": "LEFT",
      "diff_hunk": "@@ -1,14 +1,19 @@\n \"\"\"Common functions used in Item Loaders code\"\"\"\n \n from functools import partial\n+import warnings\n+\n+from itemloaders import common\n+\n from scrapy.utils.python import get_func_args\n+from scrapy.utils.deprecate import ScrapyDeprecationWarning\n \n \n def wrap_loader_context(function, context):\n-    \"\"\"Wrap functions that receive loader_context to contain the context\n-    \"pre-loaded\" and expose a interface that receives only one argument\n-    \"\"\"",
      "comment": "It should be OK to leave the docstring until we remove the function.",
      "comment_id": 423750453,
      "user": "Gallaecio",
      "created_at": "2020-05-12T13:52:01Z",
      "url": "https://github.com/scrapy/scrapy/pull/4516#discussion_r423750453"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 4516,
      "file_path": "tests/test_loader_deprecated.py",
      "line": 1,
      "side": "RIGHT",
      "diff_hunk": "@@ -0,0 +1,695 @@\n+\"\"\"",
      "comment": "Given `ItemLoader` is no longer deprecated, it may make sense to restore the original file name.",
      "comment_id": 423752904,
      "user": "Gallaecio",
      "created_at": "2020-05-12T13:55:06Z",
      "url": "https://github.com/scrapy/scrapy/pull/4516#discussion_r423752904"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 4516,
      "file_path": "tests/test_loader_deprecated.py",
      "line": 1,
      "side": "RIGHT",
      "diff_hunk": "@@ -0,0 +1,695 @@\n+\"\"\"",
      "comment": "Maybe a better name, these are the tests that were moved to the new library.\r\nThe idea is to remove them once the deprecated stuff (processors, ...) is removed.\r\n`test_loader_moved_itemloaders.py`?",
      "comment_id": 423949850,
      "user": "ejulio",
      "created_at": "2020-05-12T18:35:55Z",
      "url": "https://github.com/scrapy/scrapy/pull/4516#discussion_r423949850"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 4516,
      "file_path": "tests/test_loader_deprecated.py",
      "line": 1,
      "side": "RIGHT",
      "diff_hunk": "@@ -0,0 +1,695 @@\n+\"\"\"",
      "comment": "Or maybe we can leave the `test_loader_deprecated` name but add a `test_loader` with the tests covering Scrapy-specific features that will remain after those deprecations.",
      "comment_id": 423958036,
      "user": "Gallaecio",
      "created_at": "2020-05-12T18:49:54Z",
      "url": "https://github.com/scrapy/scrapy/pull/4516#discussion_r423958036"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 4516,
      "file_path": "tests/test_loader_deprecated.py",
      "line": 1,
      "side": "RIGHT",
      "diff_hunk": "@@ -0,0 +1,695 @@\n+\"\"\"",
      "comment": "@Gallaecio , but there's already a file named `test_loader.py`, which is the past one, but I removed the tests that were covered by `itemloaders` (moved them to `test_loader_deprecated`)",
      "comment_id": 425081420,
      "user": "ejulio",
      "created_at": "2020-05-14T11:59:36Z",
      "url": "https://github.com/scrapy/scrapy/pull/4516#discussion_r425081420"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 4516,
      "file_path": "tests/test_loader_deprecated.py",
      "line": 1,
      "side": "RIGHT",
      "diff_hunk": "@@ -0,0 +1,695 @@\n+\"\"\"",
      "comment": ":facepalm: \r\n\r\nMy bad, it did not load by default in the patch viewer and because it only had deleted lines in the count of added and deleted lines I though the whole file had been deleted.",
      "comment_id": 425451206,
      "user": "Gallaecio",
      "created_at": "2020-05-14T21:50:27Z",
      "url": "https://github.com/scrapy/scrapy/pull/4516#discussion_r425451206"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 4516,
      "file_path": "scrapy/loader/__init__.py",
      "line": 82,
      "side": "RIGHT",
      "diff_hunk": "@@ -3,219 +3,104 @@\n \n See documentation in docs/topics/loaders.rst\n \"\"\"\n-from collections import defaultdict\n-from contextlib import suppress\n+import itemloaders\n \n from scrapy.item import Item\n-from scrapy.loader.common import wrap_loader_context\n-from scrapy.loader.processors import Identity\n from scrapy.selector import Selector\n-from scrapy.utils.misc import arg_to_iter, extract_regex\n-from scrapy.utils.python import flatten\n \n \n-def unbound_method(method):\n+class ItemLoader(itemloaders.ItemLoader):\n     \"\"\"\n-    Allow to use single-argument functions as input or output processors\n-    (no need to define an unused first 'self' argument)\n-    \"\"\"\n-    with suppress(AttributeError):\n-        if '.' not in method.__qualname__:\n-            return method.__func__\n-    return method\n+    Return a new Item Loader for populating the given Item. If no item is\n+    given, one is instantiated automatically using the class in\n+    :attr:`default_item_class`.\n+\n+    When instantiated with a ``selector`` or a ``response`` parameters\n+    the :class:`ItemLoader` class provides convenient mechanisms for extracting\n+    data from web pages using :ref:`selectors <topics-selectors>`.\n+\n+    :param item: The item instance to populate using subsequent calls to\n+        :meth:`~ItemLoader.add_xpath`, :meth:`~ItemLoader.add_css`,\n+        or :meth:`~ItemLoader.add_value`.\n+    :type item: :class:`~scrapy.item.Item` object\n+\n+    :param selector: The selector to extract data from, when using the\n+        :meth:`add_xpath` (resp. :meth:`add_css`) or :meth:`replace_xpath`\n+        (resp. :meth:`replace_css`) method.\n+    :type selector: :class:`~scrapy.selector.Selector` object\n+\n+    :param response: The response used to construct the selector using the\n+        :attr:`default_selector_class`, unless the selector argument is given,\n+        in which case this argument is ignored.\n+    :type response: :class:`~scrapy.http.Response` object\n+\n+    The item, selector, response and the remaining keyword arguments are\n+    assigned to the Loader context (accessible through the :attr:`context` attribute).\n+\n+    .. attribute:: item\n+\n+        The item object being parsed by this Item Loader.\n+        This is mostly used as a property so when attempting to override this\n+        value, you may want to check out :attr:`default_item_class` first.\n+\n+    .. attribute:: context\n+\n+        The currently active :ref:`Context <loaders-context>` of this Item Loader.\n+        Refer to <loaders-context> for more information about the Loader Context.\n+\n+    .. attribute:: default_item_class\n \n+        An Item class (or factory), used to instantiate items when not given in\n+        the ``__init__`` method.\n \n-class ItemLoader:\n+    .. attribute:: default_input_processor\n+\n+        The default input processor to use for those fields which don't specify\n+        one.\n+\n+    .. attribute:: default_output_processor\n+\n+        The default output processor to use for those fields which don't specify\n+        one.\n+\n+    .. attribute:: default_selector_class\n+\n+        The class used to construct the :attr:`selector` of this\n+        :class:`ItemLoader`, if only a response is given in the ``__init__`` method.\n+        If a selector is given in the ``__init__`` method this attribute is ignored.\n+        This attribute is sometimes overridden in subclasses.\n+\n+    .. attribute:: selector\n+\n+        The :class:`~scrapy.selector.Selector` object to extract data from.\n+        It's either the selector given in the ``__init__`` method or one created from\n+        the response given in the ``__init__`` method using the\n+        :attr:`default_selector_class`. This attribute is meant to be\n+        read-only.\n+    \"\"\"\n \n     default_item_class = Item",
      "comment": "Is this useful? I ask because I imagine that, given `Item` has no fields defined, this always needs to be overriden with a different value.",
      "comment_id": 426735786,
      "user": "Gallaecio",
      "created_at": "2020-05-18T16:04:17Z",
      "url": "https://github.com/scrapy/scrapy/pull/4516#discussion_r426735786"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 4516,
      "file_path": "scrapy/loader/__init__.py",
      "line": 105,
      "side": "RIGHT",
      "diff_hunk": "@@ -3,219 +3,104 @@\n \n See documentation in docs/topics/loaders.rst\n \"\"\"\n-from collections import defaultdict\n-from contextlib import suppress\n+import itemloaders\n \n from scrapy.item import Item\n-from scrapy.loader.common import wrap_loader_context\n-from scrapy.loader.processors import Identity\n from scrapy.selector import Selector\n-from scrapy.utils.misc import arg_to_iter, extract_regex\n-from scrapy.utils.python import flatten\n \n \n-def unbound_method(method):\n+class ItemLoader(itemloaders.ItemLoader):\n     \"\"\"\n-    Allow to use single-argument functions as input or output processors\n-    (no need to define an unused first 'self' argument)\n-    \"\"\"\n-    with suppress(AttributeError):\n-        if '.' not in method.__qualname__:\n-            return method.__func__\n-    return method\n+    Return a new Item Loader for populating the given Item. If no item is\n+    given, one is instantiated automatically using the class in\n+    :attr:`default_item_class`.\n+\n+    When instantiated with a ``selector`` or a ``response`` parameters\n+    the :class:`ItemLoader` class provides convenient mechanisms for extracting\n+    data from web pages using :ref:`selectors <topics-selectors>`.\n+\n+    :param item: The item instance to populate using subsequent calls to\n+        :meth:`~ItemLoader.add_xpath`, :meth:`~ItemLoader.add_css`,\n+        or :meth:`~ItemLoader.add_value`.\n+    :type item: :class:`~scrapy.item.Item` object\n+\n+    :param selector: The selector to extract data from, when using the\n+        :meth:`add_xpath` (resp. :meth:`add_css`) or :meth:`replace_xpath`\n+        (resp. :meth:`replace_css`) method.\n+    :type selector: :class:`~scrapy.selector.Selector` object\n+\n+    :param response: The response used to construct the selector using the\n+        :attr:`default_selector_class`, unless the selector argument is given,\n+        in which case this argument is ignored.\n+    :type response: :class:`~scrapy.http.Response` object\n+\n+    The item, selector, response and the remaining keyword arguments are\n+    assigned to the Loader context (accessible through the :attr:`context` attribute).\n+\n+    .. attribute:: item\n+\n+        The item object being parsed by this Item Loader.\n+        This is mostly used as a property so when attempting to override this\n+        value, you may want to check out :attr:`default_item_class` first.\n+\n+    .. attribute:: context\n+\n+        The currently active :ref:`Context <loaders-context>` of this Item Loader.\n+        Refer to <loaders-context> for more information about the Loader Context.\n+\n+    .. attribute:: default_item_class\n \n+        An Item class (or factory), used to instantiate items when not given in\n+        the ``__init__`` method.\n \n-class ItemLoader:\n+    .. attribute:: default_input_processor\n+\n+        The default input processor to use for those fields which don't specify\n+        one.\n+\n+    .. attribute:: default_output_processor\n+\n+        The default output processor to use for those fields which don't specify\n+        one.\n+\n+    .. attribute:: default_selector_class\n+\n+        The class used to construct the :attr:`selector` of this\n+        :class:`ItemLoader`, if only a response is given in the ``__init__`` method.\n+        If a selector is given in the ``__init__`` method this attribute is ignored.\n+        This attribute is sometimes overridden in subclasses.\n+\n+    .. attribute:: selector\n+\n+        The :class:`~scrapy.selector.Selector` object to extract data from.\n+        It's either the selector given in the ``__init__`` method or one created from\n+        the response given in the ``__init__`` method using the\n+        :attr:`default_selector_class`. This attribute is meant to be\n+        read-only.\n+    \"\"\"\n \n     default_item_class = Item\n-    default_input_processor = Identity()\n-    default_output_processor = Identity()\n     default_selector_class = Selector\n \n     def __init__(self, item=None, selector=None, response=None, parent=None, **context):\n         if selector is None and response is not None:\n             selector = self.default_selector_class(response)\n-        self.selector = selector\n-        context.update(selector=selector, response=response)\n-        if item is None:\n-            item = self.default_item_class()\n-        self.context = context\n-        self.parent = parent\n-        self._local_item = context['item'] = item\n-        self._local_values = defaultdict(list)\n-        # values from initial item\n-        for field_name, value in item.items():\n-            self._values[field_name] += arg_to_iter(value)\n-\n-    @property\n-    def _values(self):\n-        if self.parent is not None:\n-            return self.parent._values\n-        else:\n-            return self._local_values\n-\n-    @property\n-    def item(self):\n-        if self.parent is not None:\n-            return self.parent.item\n-        else:\n-            return self._local_item\n-\n-    def nested_xpath(self, xpath, **context):\n-        selector = self.selector.xpath(xpath)\n-        context.update(selector=selector)\n-        subloader = self.__class__(\n-            item=self.item, parent=self, **context\n-        )\n-        return subloader\n-\n-    def nested_css(self, css, **context):\n-        selector = self.selector.css(css)\n-        context.update(selector=selector)\n-        subloader = self.__class__(\n-            item=self.item, parent=self, **context\n-        )\n-        return subloader\n-\n-    def add_value(self, field_name, value, *processors, **kw):\n-        value = self.get_value(value, *processors, **kw)\n-        if value is None:\n-            return\n-        if not field_name:\n-            for k, v in value.items():\n-                self._add_value(k, v)\n-        else:\n-            self._add_value(field_name, value)\n-\n-    def replace_value(self, field_name, value, *processors, **kw):\n-        value = self.get_value(value, *processors, **kw)\n-        if value is None:\n-            return\n-        if not field_name:\n-            for k, v in value.items():\n-                self._replace_value(k, v)\n-        else:\n-            self._replace_value(field_name, value)\n-\n-    def _add_value(self, field_name, value):\n-        value = arg_to_iter(value)\n-        processed_value = self._process_input_value(field_name, value)\n-        if processed_value:\n-            self._values[field_name] += arg_to_iter(processed_value)\n-\n-    def _replace_value(self, field_name, value):\n-        self._values.pop(field_name, None)\n-        self._add_value(field_name, value)\n-\n-    def get_value(self, value, *processors, **kw):\n-        regex = kw.get('re', None)\n-        if regex:\n-            value = arg_to_iter(value)\n-            value = flatten(extract_regex(regex, x) for x in value)\n-\n-        for proc in processors:\n-            if value is None:\n-                break\n-            _proc = proc\n-            proc = wrap_loader_context(proc, self.context)\n-            try:\n-                value = proc(value)\n-            except Exception as e:\n-                raise ValueError(\"Error with processor %s value=%r error='%s: %s'\" %\n-                                 (_proc.__class__.__name__, value,\n-                                  type(e).__name__, str(e)))\n-        return value\n-\n-    def load_item(self):\n-        item = self.item\n-        for field_name in tuple(self._values):\n-            value = self.get_output_value(field_name)\n-            if value is not None:\n-                item[field_name] = value\n-\n-        return item\n-\n-    def get_output_value(self, field_name):\n-        proc = self.get_output_processor(field_name)\n-        proc = wrap_loader_context(proc, self.context)\n-        try:\n-            return proc(self._values[field_name])\n-        except Exception as e:\n-            raise ValueError(\"Error with output processor: field=%r value=%r error='%s: %s'\" %\n-                             (field_name, self._values[field_name], type(e).__name__, str(e)))\n-\n-    def get_collected_values(self, field_name):\n-        return self._values[field_name]\n-\n-    def get_input_processor(self, field_name):\n-        proc = getattr(self, '%s_in' % field_name, None)\n+        context.update(response=response)\n+        super().__init__(item=item, selector=selector, parent=parent, **context)\n+\n+    def get_default_input_processor_for_field(self, field_name):\n+        proc = self._get_item_field_attr(field_name, 'input_processor')\n         if not proc:\n-            proc = self._get_item_field_attr(field_name, 'input_processor',\n-                                             self.default_input_processor)\n-        return unbound_method(proc)\n+            proc = super().get_default_input_processor_for_field(field_name)\n+        return proc\n \n-    def get_output_processor(self, field_name):\n-        proc = getattr(self, '%s_out' % field_name, None)\n+    def get_default_output_processor_for_field(self, field_name):\n+        proc = self._get_item_field_attr(field_name, 'output_processor')\n         if not proc:\n-            proc = self._get_item_field_attr(field_name, 'output_processor',\n-                                             self.default_output_processor)\n-        return unbound_method(proc)\n-\n-    def _process_input_value(self, field_name, value):\n-        proc = self.get_input_processor(field_name)\n-        _proc = proc\n-        proc = wrap_loader_context(proc, self.context)\n-        try:\n-            return proc(value)\n-        except Exception as e:\n-            raise ValueError(\n-                \"Error with input processor %s: field=%r value=%r \"\n-                \"error='%s: %s'\" % (_proc.__class__.__name__, field_name,\n-                                    value, type(e).__name__, str(e)))\n-\n-    def _get_item_field_attr(self, field_name, key, default=None):\n+            proc = super().get_default_output_processor_for_field(field_name)\n+        return proc\n+\n+    def _get_item_field_attr(self, field_name, key):\n         if isinstance(self.item, Item):\n-            value = self.item.fields[field_name].get(key, default)\n-        else:\n-            value = default\n-        return value\n-\n-    def _check_selector_method(self):\n-        if self.selector is None:\n-            raise RuntimeError(\"To use XPath or CSS selectors, \"\n-                               \"%s must be instantiated with a selector \"\n-                               \"or a response\" % self.__class__.__name__)\n-\n-    def add_xpath(self, field_name, xpath, *processors, **kw):\n-        values = self._get_xpathvalues(xpath, **kw)\n-        self.add_value(field_name, values, *processors, **kw)\n-\n-    def replace_xpath(self, field_name, xpath, *processors, **kw):\n-        values = self._get_xpathvalues(xpath, **kw)\n-        self.replace_value(field_name, values, *processors, **kw)\n-\n-    def get_xpath(self, xpath, *processors, **kw):\n-        values = self._get_xpathvalues(xpath, **kw)\n-        return self.get_value(values, *processors, **kw)\n-\n-    def _get_xpathvalues(self, xpaths, **kw):\n-        self._check_selector_method()\n-        xpaths = arg_to_iter(xpaths)\n-        return flatten(self.selector.xpath(xpath).getall() for xpath in xpaths)\n-\n-    def add_css(self, field_name, css, *processors, **kw):\n-        values = self._get_cssvalues(css, **kw)\n-        self.add_value(field_name, values, *processors, **kw)\n-\n-    def replace_css(self, field_name, css, *processors, **kw):\n-        values = self._get_cssvalues(css, **kw)\n-        self.replace_value(field_name, values, *processors, **kw)\n-\n-    def get_css(self, css, *processors, **kw):\n-        values = self._get_cssvalues(css, **kw)\n-        return self.get_value(values, *processors, **kw)\n-\n-    def _get_cssvalues(self, csss, **kw):\n-        self._check_selector_method()\n-        csss = arg_to_iter(csss)\n-        return flatten(self.selector.css(css).getall() for css in csss)\n+            return self.item.fields[field_name].get(key)",
      "comment": "I guess we need to wait for #3881 and use `ItemAdapter` here. Maybe also in the `itemloaders` library itself?",
      "comment_id": 426741144,
      "user": "Gallaecio",
      "created_at": "2020-05-18T16:12:34Z",
      "url": "https://github.com/scrapy/scrapy/pull/4516#discussion_r426741144"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 4516,
      "file_path": "scrapy/loader/__init__.py",
      "line": 105,
      "side": "RIGHT",
      "diff_hunk": "@@ -3,219 +3,104 @@\n \n See documentation in docs/topics/loaders.rst\n \"\"\"\n-from collections import defaultdict\n-from contextlib import suppress\n+import itemloaders\n \n from scrapy.item import Item\n-from scrapy.loader.common import wrap_loader_context\n-from scrapy.loader.processors import Identity\n from scrapy.selector import Selector\n-from scrapy.utils.misc import arg_to_iter, extract_regex\n-from scrapy.utils.python import flatten\n \n \n-def unbound_method(method):\n+class ItemLoader(itemloaders.ItemLoader):\n     \"\"\"\n-    Allow to use single-argument functions as input or output processors\n-    (no need to define an unused first 'self' argument)\n-    \"\"\"\n-    with suppress(AttributeError):\n-        if '.' not in method.__qualname__:\n-            return method.__func__\n-    return method\n+    Return a new Item Loader for populating the given Item. If no item is\n+    given, one is instantiated automatically using the class in\n+    :attr:`default_item_class`.\n+\n+    When instantiated with a ``selector`` or a ``response`` parameters\n+    the :class:`ItemLoader` class provides convenient mechanisms for extracting\n+    data from web pages using :ref:`selectors <topics-selectors>`.\n+\n+    :param item: The item instance to populate using subsequent calls to\n+        :meth:`~ItemLoader.add_xpath`, :meth:`~ItemLoader.add_css`,\n+        or :meth:`~ItemLoader.add_value`.\n+    :type item: :class:`~scrapy.item.Item` object\n+\n+    :param selector: The selector to extract data from, when using the\n+        :meth:`add_xpath` (resp. :meth:`add_css`) or :meth:`replace_xpath`\n+        (resp. :meth:`replace_css`) method.\n+    :type selector: :class:`~scrapy.selector.Selector` object\n+\n+    :param response: The response used to construct the selector using the\n+        :attr:`default_selector_class`, unless the selector argument is given,\n+        in which case this argument is ignored.\n+    :type response: :class:`~scrapy.http.Response` object\n+\n+    The item, selector, response and the remaining keyword arguments are\n+    assigned to the Loader context (accessible through the :attr:`context` attribute).\n+\n+    .. attribute:: item\n+\n+        The item object being parsed by this Item Loader.\n+        This is mostly used as a property so when attempting to override this\n+        value, you may want to check out :attr:`default_item_class` first.\n+\n+    .. attribute:: context\n+\n+        The currently active :ref:`Context <loaders-context>` of this Item Loader.\n+        Refer to <loaders-context> for more information about the Loader Context.\n+\n+    .. attribute:: default_item_class\n \n+        An Item class (or factory), used to instantiate items when not given in\n+        the ``__init__`` method.\n \n-class ItemLoader:\n+    .. attribute:: default_input_processor\n+\n+        The default input processor to use for those fields which don't specify\n+        one.\n+\n+    .. attribute:: default_output_processor\n+\n+        The default output processor to use for those fields which don't specify\n+        one.\n+\n+    .. attribute:: default_selector_class\n+\n+        The class used to construct the :attr:`selector` of this\n+        :class:`ItemLoader`, if only a response is given in the ``__init__`` method.\n+        If a selector is given in the ``__init__`` method this attribute is ignored.\n+        This attribute is sometimes overridden in subclasses.\n+\n+    .. attribute:: selector\n+\n+        The :class:`~scrapy.selector.Selector` object to extract data from.\n+        It's either the selector given in the ``__init__`` method or one created from\n+        the response given in the ``__init__`` method using the\n+        :attr:`default_selector_class`. This attribute is meant to be\n+        read-only.\n+    \"\"\"\n \n     default_item_class = Item\n-    default_input_processor = Identity()\n-    default_output_processor = Identity()\n     default_selector_class = Selector\n \n     def __init__(self, item=None, selector=None, response=None, parent=None, **context):\n         if selector is None and response is not None:\n             selector = self.default_selector_class(response)\n-        self.selector = selector\n-        context.update(selector=selector, response=response)\n-        if item is None:\n-            item = self.default_item_class()\n-        self.context = context\n-        self.parent = parent\n-        self._local_item = context['item'] = item\n-        self._local_values = defaultdict(list)\n-        # values from initial item\n-        for field_name, value in item.items():\n-            self._values[field_name] += arg_to_iter(value)\n-\n-    @property\n-    def _values(self):\n-        if self.parent is not None:\n-            return self.parent._values\n-        else:\n-            return self._local_values\n-\n-    @property\n-    def item(self):\n-        if self.parent is not None:\n-            return self.parent.item\n-        else:\n-            return self._local_item\n-\n-    def nested_xpath(self, xpath, **context):\n-        selector = self.selector.xpath(xpath)\n-        context.update(selector=selector)\n-        subloader = self.__class__(\n-            item=self.item, parent=self, **context\n-        )\n-        return subloader\n-\n-    def nested_css(self, css, **context):\n-        selector = self.selector.css(css)\n-        context.update(selector=selector)\n-        subloader = self.__class__(\n-            item=self.item, parent=self, **context\n-        )\n-        return subloader\n-\n-    def add_value(self, field_name, value, *processors, **kw):\n-        value = self.get_value(value, *processors, **kw)\n-        if value is None:\n-            return\n-        if not field_name:\n-            for k, v in value.items():\n-                self._add_value(k, v)\n-        else:\n-            self._add_value(field_name, value)\n-\n-    def replace_value(self, field_name, value, *processors, **kw):\n-        value = self.get_value(value, *processors, **kw)\n-        if value is None:\n-            return\n-        if not field_name:\n-            for k, v in value.items():\n-                self._replace_value(k, v)\n-        else:\n-            self._replace_value(field_name, value)\n-\n-    def _add_value(self, field_name, value):\n-        value = arg_to_iter(value)\n-        processed_value = self._process_input_value(field_name, value)\n-        if processed_value:\n-            self._values[field_name] += arg_to_iter(processed_value)\n-\n-    def _replace_value(self, field_name, value):\n-        self._values.pop(field_name, None)\n-        self._add_value(field_name, value)\n-\n-    def get_value(self, value, *processors, **kw):\n-        regex = kw.get('re', None)\n-        if regex:\n-            value = arg_to_iter(value)\n-            value = flatten(extract_regex(regex, x) for x in value)\n-\n-        for proc in processors:\n-            if value is None:\n-                break\n-            _proc = proc\n-            proc = wrap_loader_context(proc, self.context)\n-            try:\n-                value = proc(value)\n-            except Exception as e:\n-                raise ValueError(\"Error with processor %s value=%r error='%s: %s'\" %\n-                                 (_proc.__class__.__name__, value,\n-                                  type(e).__name__, str(e)))\n-        return value\n-\n-    def load_item(self):\n-        item = self.item\n-        for field_name in tuple(self._values):\n-            value = self.get_output_value(field_name)\n-            if value is not None:\n-                item[field_name] = value\n-\n-        return item\n-\n-    def get_output_value(self, field_name):\n-        proc = self.get_output_processor(field_name)\n-        proc = wrap_loader_context(proc, self.context)\n-        try:\n-            return proc(self._values[field_name])\n-        except Exception as e:\n-            raise ValueError(\"Error with output processor: field=%r value=%r error='%s: %s'\" %\n-                             (field_name, self._values[field_name], type(e).__name__, str(e)))\n-\n-    def get_collected_values(self, field_name):\n-        return self._values[field_name]\n-\n-    def get_input_processor(self, field_name):\n-        proc = getattr(self, '%s_in' % field_name, None)\n+        context.update(response=response)\n+        super().__init__(item=item, selector=selector, parent=parent, **context)\n+\n+    def get_default_input_processor_for_field(self, field_name):\n+        proc = self._get_item_field_attr(field_name, 'input_processor')\n         if not proc:\n-            proc = self._get_item_field_attr(field_name, 'input_processor',\n-                                             self.default_input_processor)\n-        return unbound_method(proc)\n+            proc = super().get_default_input_processor_for_field(field_name)\n+        return proc\n \n-    def get_output_processor(self, field_name):\n-        proc = getattr(self, '%s_out' % field_name, None)\n+    def get_default_output_processor_for_field(self, field_name):\n+        proc = self._get_item_field_attr(field_name, 'output_processor')\n         if not proc:\n-            proc = self._get_item_field_attr(field_name, 'output_processor',\n-                                             self.default_output_processor)\n-        return unbound_method(proc)\n-\n-    def _process_input_value(self, field_name, value):\n-        proc = self.get_input_processor(field_name)\n-        _proc = proc\n-        proc = wrap_loader_context(proc, self.context)\n-        try:\n-            return proc(value)\n-        except Exception as e:\n-            raise ValueError(\n-                \"Error with input processor %s: field=%r value=%r \"\n-                \"error='%s: %s'\" % (_proc.__class__.__name__, field_name,\n-                                    value, type(e).__name__, str(e)))\n-\n-    def _get_item_field_attr(self, field_name, key, default=None):\n+            proc = super().get_default_output_processor_for_field(field_name)\n+        return proc\n+\n+    def _get_item_field_attr(self, field_name, key):\n         if isinstance(self.item, Item):\n-            value = self.item.fields[field_name].get(key, default)\n-        else:\n-            value = default\n-        return value\n-\n-    def _check_selector_method(self):\n-        if self.selector is None:\n-            raise RuntimeError(\"To use XPath or CSS selectors, \"\n-                               \"%s must be instantiated with a selector \"\n-                               \"or a response\" % self.__class__.__name__)\n-\n-    def add_xpath(self, field_name, xpath, *processors, **kw):\n-        values = self._get_xpathvalues(xpath, **kw)\n-        self.add_value(field_name, values, *processors, **kw)\n-\n-    def replace_xpath(self, field_name, xpath, *processors, **kw):\n-        values = self._get_xpathvalues(xpath, **kw)\n-        self.replace_value(field_name, values, *processors, **kw)\n-\n-    def get_xpath(self, xpath, *processors, **kw):\n-        values = self._get_xpathvalues(xpath, **kw)\n-        return self.get_value(values, *processors, **kw)\n-\n-    def _get_xpathvalues(self, xpaths, **kw):\n-        self._check_selector_method()\n-        xpaths = arg_to_iter(xpaths)\n-        return flatten(self.selector.xpath(xpath).getall() for xpath in xpaths)\n-\n-    def add_css(self, field_name, css, *processors, **kw):\n-        values = self._get_cssvalues(css, **kw)\n-        self.add_value(field_name, values, *processors, **kw)\n-\n-    def replace_css(self, field_name, css, *processors, **kw):\n-        values = self._get_cssvalues(css, **kw)\n-        self.replace_value(field_name, values, *processors, **kw)\n-\n-    def get_css(self, css, *processors, **kw):\n-        values = self._get_cssvalues(css, **kw)\n-        return self.get_value(values, *processors, **kw)\n-\n-    def _get_cssvalues(self, csss, **kw):\n-        self._check_selector_method()\n-        csss = arg_to_iter(csss)\n-        return flatten(self.selector.css(css).getall() for css in csss)\n+            return self.item.fields[field_name].get(key)",
      "comment": "That's the question, what should we merge first :)",
      "comment_id": 426743130,
      "user": "kmike",
      "created_at": "2020-05-18T16:15:32Z",
      "url": "https://github.com/scrapy/scrapy/pull/4516#discussion_r426743130"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 4516,
      "file_path": "scrapy/loader/__init__.py",
      "line": 82,
      "side": "RIGHT",
      "diff_hunk": "@@ -3,219 +3,104 @@\n \n See documentation in docs/topics/loaders.rst\n \"\"\"\n-from collections import defaultdict\n-from contextlib import suppress\n+import itemloaders\n \n from scrapy.item import Item\n-from scrapy.loader.common import wrap_loader_context\n-from scrapy.loader.processors import Identity\n from scrapy.selector import Selector\n-from scrapy.utils.misc import arg_to_iter, extract_regex\n-from scrapy.utils.python import flatten\n \n \n-def unbound_method(method):\n+class ItemLoader(itemloaders.ItemLoader):\n     \"\"\"\n-    Allow to use single-argument functions as input or output processors\n-    (no need to define an unused first 'self' argument)\n-    \"\"\"\n-    with suppress(AttributeError):\n-        if '.' not in method.__qualname__:\n-            return method.__func__\n-    return method\n+    Return a new Item Loader for populating the given Item. If no item is\n+    given, one is instantiated automatically using the class in\n+    :attr:`default_item_class`.\n+\n+    When instantiated with a ``selector`` or a ``response`` parameters\n+    the :class:`ItemLoader` class provides convenient mechanisms for extracting\n+    data from web pages using :ref:`selectors <topics-selectors>`.\n+\n+    :param item: The item instance to populate using subsequent calls to\n+        :meth:`~ItemLoader.add_xpath`, :meth:`~ItemLoader.add_css`,\n+        or :meth:`~ItemLoader.add_value`.\n+    :type item: :class:`~scrapy.item.Item` object\n+\n+    :param selector: The selector to extract data from, when using the\n+        :meth:`add_xpath` (resp. :meth:`add_css`) or :meth:`replace_xpath`\n+        (resp. :meth:`replace_css`) method.\n+    :type selector: :class:`~scrapy.selector.Selector` object\n+\n+    :param response: The response used to construct the selector using the\n+        :attr:`default_selector_class`, unless the selector argument is given,\n+        in which case this argument is ignored.\n+    :type response: :class:`~scrapy.http.Response` object\n+\n+    The item, selector, response and the remaining keyword arguments are\n+    assigned to the Loader context (accessible through the :attr:`context` attribute).\n+\n+    .. attribute:: item\n+\n+        The item object being parsed by this Item Loader.\n+        This is mostly used as a property so when attempting to override this\n+        value, you may want to check out :attr:`default_item_class` first.\n+\n+    .. attribute:: context\n+\n+        The currently active :ref:`Context <loaders-context>` of this Item Loader.\n+        Refer to <loaders-context> for more information about the Loader Context.\n+\n+    .. attribute:: default_item_class\n \n+        An Item class (or factory), used to instantiate items when not given in\n+        the ``__init__`` method.\n \n-class ItemLoader:\n+    .. attribute:: default_input_processor\n+\n+        The default input processor to use for those fields which don't specify\n+        one.\n+\n+    .. attribute:: default_output_processor\n+\n+        The default output processor to use for those fields which don't specify\n+        one.\n+\n+    .. attribute:: default_selector_class\n+\n+        The class used to construct the :attr:`selector` of this\n+        :class:`ItemLoader`, if only a response is given in the ``__init__`` method.\n+        If a selector is given in the ``__init__`` method this attribute is ignored.\n+        This attribute is sometimes overridden in subclasses.\n+\n+    .. attribute:: selector\n+\n+        The :class:`~scrapy.selector.Selector` object to extract data from.\n+        It's either the selector given in the ``__init__`` method or one created from\n+        the response given in the ``__init__`` method using the\n+        :attr:`default_selector_class`. This attribute is meant to be\n+        read-only.\n+    \"\"\"\n \n     default_item_class = Item",
      "comment": "This is here only for backwards compatibility, as this is how it was before.\r\nI guess there should be no harm in removing it",
      "comment_id": 426749199,
      "user": "ejulio",
      "created_at": "2020-05-18T16:25:12Z",
      "url": "https://github.com/scrapy/scrapy/pull/4516#discussion_r426749199"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 4516,
      "file_path": "scrapy/loader/__init__.py",
      "line": 82,
      "side": "RIGHT",
      "diff_hunk": "@@ -3,219 +3,104 @@\n \n See documentation in docs/topics/loaders.rst\n \"\"\"\n-from collections import defaultdict\n-from contextlib import suppress\n+import itemloaders\n \n from scrapy.item import Item\n-from scrapy.loader.common import wrap_loader_context\n-from scrapy.loader.processors import Identity\n from scrapy.selector import Selector\n-from scrapy.utils.misc import arg_to_iter, extract_regex\n-from scrapy.utils.python import flatten\n \n \n-def unbound_method(method):\n+class ItemLoader(itemloaders.ItemLoader):\n     \"\"\"\n-    Allow to use single-argument functions as input or output processors\n-    (no need to define an unused first 'self' argument)\n-    \"\"\"\n-    with suppress(AttributeError):\n-        if '.' not in method.__qualname__:\n-            return method.__func__\n-    return method\n+    Return a new Item Loader for populating the given Item. If no item is\n+    given, one is instantiated automatically using the class in\n+    :attr:`default_item_class`.\n+\n+    When instantiated with a ``selector`` or a ``response`` parameters\n+    the :class:`ItemLoader` class provides convenient mechanisms for extracting\n+    data from web pages using :ref:`selectors <topics-selectors>`.\n+\n+    :param item: The item instance to populate using subsequent calls to\n+        :meth:`~ItemLoader.add_xpath`, :meth:`~ItemLoader.add_css`,\n+        or :meth:`~ItemLoader.add_value`.\n+    :type item: :class:`~scrapy.item.Item` object\n+\n+    :param selector: The selector to extract data from, when using the\n+        :meth:`add_xpath` (resp. :meth:`add_css`) or :meth:`replace_xpath`\n+        (resp. :meth:`replace_css`) method.\n+    :type selector: :class:`~scrapy.selector.Selector` object\n+\n+    :param response: The response used to construct the selector using the\n+        :attr:`default_selector_class`, unless the selector argument is given,\n+        in which case this argument is ignored.\n+    :type response: :class:`~scrapy.http.Response` object\n+\n+    The item, selector, response and the remaining keyword arguments are\n+    assigned to the Loader context (accessible through the :attr:`context` attribute).\n+\n+    .. attribute:: item\n+\n+        The item object being parsed by this Item Loader.\n+        This is mostly used as a property so when attempting to override this\n+        value, you may want to check out :attr:`default_item_class` first.\n+\n+    .. attribute:: context\n+\n+        The currently active :ref:`Context <loaders-context>` of this Item Loader.\n+        Refer to <loaders-context> for more information about the Loader Context.\n+\n+    .. attribute:: default_item_class\n \n+        An Item class (or factory), used to instantiate items when not given in\n+        the ``__init__`` method.\n \n-class ItemLoader:\n+    .. attribute:: default_input_processor\n+\n+        The default input processor to use for those fields which don't specify\n+        one.\n+\n+    .. attribute:: default_output_processor\n+\n+        The default output processor to use for those fields which don't specify\n+        one.\n+\n+    .. attribute:: default_selector_class\n+\n+        The class used to construct the :attr:`selector` of this\n+        :class:`ItemLoader`, if only a response is given in the ``__init__`` method.\n+        If a selector is given in the ``__init__`` method this attribute is ignored.\n+        This attribute is sometimes overridden in subclasses.\n+\n+    .. attribute:: selector\n+\n+        The :class:`~scrapy.selector.Selector` object to extract data from.\n+        It's either the selector given in the ``__init__`` method or one created from\n+        the response given in the ``__init__`` method using the\n+        :attr:`default_selector_class`. This attribute is meant to be\n+        read-only.\n+    \"\"\"\n \n     default_item_class = Item",
      "comment": "Right, backward compatibility. Keeping it makes sense.",
      "comment_id": 426812868,
      "user": "Gallaecio",
      "created_at": "2020-05-18T18:20:48Z",
      "url": "https://github.com/scrapy/scrapy/pull/4516#discussion_r426812868"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 4516,
      "file_path": "scrapy/loader/__init__.py",
      "line": 105,
      "side": "RIGHT",
      "diff_hunk": "@@ -3,219 +3,104 @@\n \n See documentation in docs/topics/loaders.rst\n \"\"\"\n-from collections import defaultdict\n-from contextlib import suppress\n+import itemloaders\n \n from scrapy.item import Item\n-from scrapy.loader.common import wrap_loader_context\n-from scrapy.loader.processors import Identity\n from scrapy.selector import Selector\n-from scrapy.utils.misc import arg_to_iter, extract_regex\n-from scrapy.utils.python import flatten\n \n \n-def unbound_method(method):\n+class ItemLoader(itemloaders.ItemLoader):\n     \"\"\"\n-    Allow to use single-argument functions as input or output processors\n-    (no need to define an unused first 'self' argument)\n-    \"\"\"\n-    with suppress(AttributeError):\n-        if '.' not in method.__qualname__:\n-            return method.__func__\n-    return method\n+    Return a new Item Loader for populating the given Item. If no item is\n+    given, one is instantiated automatically using the class in\n+    :attr:`default_item_class`.\n+\n+    When instantiated with a ``selector`` or a ``response`` parameters\n+    the :class:`ItemLoader` class provides convenient mechanisms for extracting\n+    data from web pages using :ref:`selectors <topics-selectors>`.\n+\n+    :param item: The item instance to populate using subsequent calls to\n+        :meth:`~ItemLoader.add_xpath`, :meth:`~ItemLoader.add_css`,\n+        or :meth:`~ItemLoader.add_value`.\n+    :type item: :class:`~scrapy.item.Item` object\n+\n+    :param selector: The selector to extract data from, when using the\n+        :meth:`add_xpath` (resp. :meth:`add_css`) or :meth:`replace_xpath`\n+        (resp. :meth:`replace_css`) method.\n+    :type selector: :class:`~scrapy.selector.Selector` object\n+\n+    :param response: The response used to construct the selector using the\n+        :attr:`default_selector_class`, unless the selector argument is given,\n+        in which case this argument is ignored.\n+    :type response: :class:`~scrapy.http.Response` object\n+\n+    The item, selector, response and the remaining keyword arguments are\n+    assigned to the Loader context (accessible through the :attr:`context` attribute).\n+\n+    .. attribute:: item\n+\n+        The item object being parsed by this Item Loader.\n+        This is mostly used as a property so when attempting to override this\n+        value, you may want to check out :attr:`default_item_class` first.\n+\n+    .. attribute:: context\n+\n+        The currently active :ref:`Context <loaders-context>` of this Item Loader.\n+        Refer to <loaders-context> for more information about the Loader Context.\n+\n+    .. attribute:: default_item_class\n \n+        An Item class (or factory), used to instantiate items when not given in\n+        the ``__init__`` method.\n \n-class ItemLoader:\n+    .. attribute:: default_input_processor\n+\n+        The default input processor to use for those fields which don't specify\n+        one.\n+\n+    .. attribute:: default_output_processor\n+\n+        The default output processor to use for those fields which don't specify\n+        one.\n+\n+    .. attribute:: default_selector_class\n+\n+        The class used to construct the :attr:`selector` of this\n+        :class:`ItemLoader`, if only a response is given in the ``__init__`` method.\n+        If a selector is given in the ``__init__`` method this attribute is ignored.\n+        This attribute is sometimes overridden in subclasses.\n+\n+    .. attribute:: selector\n+\n+        The :class:`~scrapy.selector.Selector` object to extract data from.\n+        It's either the selector given in the ``__init__`` method or one created from\n+        the response given in the ``__init__`` method using the\n+        :attr:`default_selector_class`. This attribute is meant to be\n+        read-only.\n+    \"\"\"\n \n     default_item_class = Item\n-    default_input_processor = Identity()\n-    default_output_processor = Identity()\n     default_selector_class = Selector\n \n     def __init__(self, item=None, selector=None, response=None, parent=None, **context):\n         if selector is None and response is not None:\n             selector = self.default_selector_class(response)\n-        self.selector = selector\n-        context.update(selector=selector, response=response)\n-        if item is None:\n-            item = self.default_item_class()\n-        self.context = context\n-        self.parent = parent\n-        self._local_item = context['item'] = item\n-        self._local_values = defaultdict(list)\n-        # values from initial item\n-        for field_name, value in item.items():\n-            self._values[field_name] += arg_to_iter(value)\n-\n-    @property\n-    def _values(self):\n-        if self.parent is not None:\n-            return self.parent._values\n-        else:\n-            return self._local_values\n-\n-    @property\n-    def item(self):\n-        if self.parent is not None:\n-            return self.parent.item\n-        else:\n-            return self._local_item\n-\n-    def nested_xpath(self, xpath, **context):\n-        selector = self.selector.xpath(xpath)\n-        context.update(selector=selector)\n-        subloader = self.__class__(\n-            item=self.item, parent=self, **context\n-        )\n-        return subloader\n-\n-    def nested_css(self, css, **context):\n-        selector = self.selector.css(css)\n-        context.update(selector=selector)\n-        subloader = self.__class__(\n-            item=self.item, parent=self, **context\n-        )\n-        return subloader\n-\n-    def add_value(self, field_name, value, *processors, **kw):\n-        value = self.get_value(value, *processors, **kw)\n-        if value is None:\n-            return\n-        if not field_name:\n-            for k, v in value.items():\n-                self._add_value(k, v)\n-        else:\n-            self._add_value(field_name, value)\n-\n-    def replace_value(self, field_name, value, *processors, **kw):\n-        value = self.get_value(value, *processors, **kw)\n-        if value is None:\n-            return\n-        if not field_name:\n-            for k, v in value.items():\n-                self._replace_value(k, v)\n-        else:\n-            self._replace_value(field_name, value)\n-\n-    def _add_value(self, field_name, value):\n-        value = arg_to_iter(value)\n-        processed_value = self._process_input_value(field_name, value)\n-        if processed_value:\n-            self._values[field_name] += arg_to_iter(processed_value)\n-\n-    def _replace_value(self, field_name, value):\n-        self._values.pop(field_name, None)\n-        self._add_value(field_name, value)\n-\n-    def get_value(self, value, *processors, **kw):\n-        regex = kw.get('re', None)\n-        if regex:\n-            value = arg_to_iter(value)\n-            value = flatten(extract_regex(regex, x) for x in value)\n-\n-        for proc in processors:\n-            if value is None:\n-                break\n-            _proc = proc\n-            proc = wrap_loader_context(proc, self.context)\n-            try:\n-                value = proc(value)\n-            except Exception as e:\n-                raise ValueError(\"Error with processor %s value=%r error='%s: %s'\" %\n-                                 (_proc.__class__.__name__, value,\n-                                  type(e).__name__, str(e)))\n-        return value\n-\n-    def load_item(self):\n-        item = self.item\n-        for field_name in tuple(self._values):\n-            value = self.get_output_value(field_name)\n-            if value is not None:\n-                item[field_name] = value\n-\n-        return item\n-\n-    def get_output_value(self, field_name):\n-        proc = self.get_output_processor(field_name)\n-        proc = wrap_loader_context(proc, self.context)\n-        try:\n-            return proc(self._values[field_name])\n-        except Exception as e:\n-            raise ValueError(\"Error with output processor: field=%r value=%r error='%s: %s'\" %\n-                             (field_name, self._values[field_name], type(e).__name__, str(e)))\n-\n-    def get_collected_values(self, field_name):\n-        return self._values[field_name]\n-\n-    def get_input_processor(self, field_name):\n-        proc = getattr(self, '%s_in' % field_name, None)\n+        context.update(response=response)\n+        super().__init__(item=item, selector=selector, parent=parent, **context)\n+\n+    def get_default_input_processor_for_field(self, field_name):\n+        proc = self._get_item_field_attr(field_name, 'input_processor')\n         if not proc:\n-            proc = self._get_item_field_attr(field_name, 'input_processor',\n-                                             self.default_input_processor)\n-        return unbound_method(proc)\n+            proc = super().get_default_input_processor_for_field(field_name)\n+        return proc\n \n-    def get_output_processor(self, field_name):\n-        proc = getattr(self, '%s_out' % field_name, None)\n+    def get_default_output_processor_for_field(self, field_name):\n+        proc = self._get_item_field_attr(field_name, 'output_processor')\n         if not proc:\n-            proc = self._get_item_field_attr(field_name, 'output_processor',\n-                                             self.default_output_processor)\n-        return unbound_method(proc)\n-\n-    def _process_input_value(self, field_name, value):\n-        proc = self.get_input_processor(field_name)\n-        _proc = proc\n-        proc = wrap_loader_context(proc, self.context)\n-        try:\n-            return proc(value)\n-        except Exception as e:\n-            raise ValueError(\n-                \"Error with input processor %s: field=%r value=%r \"\n-                \"error='%s: %s'\" % (_proc.__class__.__name__, field_name,\n-                                    value, type(e).__name__, str(e)))\n-\n-    def _get_item_field_attr(self, field_name, key, default=None):\n+            proc = super().get_default_output_processor_for_field(field_name)\n+        return proc\n+\n+    def _get_item_field_attr(self, field_name, key):\n         if isinstance(self.item, Item):\n-            value = self.item.fields[field_name].get(key, default)\n-        else:\n-            value = default\n-        return value\n-\n-    def _check_selector_method(self):\n-        if self.selector is None:\n-            raise RuntimeError(\"To use XPath or CSS selectors, \"\n-                               \"%s must be instantiated with a selector \"\n-                               \"or a response\" % self.__class__.__name__)\n-\n-    def add_xpath(self, field_name, xpath, *processors, **kw):\n-        values = self._get_xpathvalues(xpath, **kw)\n-        self.add_value(field_name, values, *processors, **kw)\n-\n-    def replace_xpath(self, field_name, xpath, *processors, **kw):\n-        values = self._get_xpathvalues(xpath, **kw)\n-        self.replace_value(field_name, values, *processors, **kw)\n-\n-    def get_xpath(self, xpath, *processors, **kw):\n-        values = self._get_xpathvalues(xpath, **kw)\n-        return self.get_value(values, *processors, **kw)\n-\n-    def _get_xpathvalues(self, xpaths, **kw):\n-        self._check_selector_method()\n-        xpaths = arg_to_iter(xpaths)\n-        return flatten(self.selector.xpath(xpath).getall() for xpath in xpaths)\n-\n-    def add_css(self, field_name, css, *processors, **kw):\n-        values = self._get_cssvalues(css, **kw)\n-        self.add_value(field_name, values, *processors, **kw)\n-\n-    def replace_css(self, field_name, css, *processors, **kw):\n-        values = self._get_cssvalues(css, **kw)\n-        self.replace_value(field_name, values, *processors, **kw)\n-\n-    def get_css(self, css, *processors, **kw):\n-        values = self._get_cssvalues(css, **kw)\n-        return self.get_value(values, *processors, **kw)\n-\n-    def _get_cssvalues(self, csss, **kw):\n-        self._check_selector_method()\n-        csss = arg_to_iter(csss)\n-        return flatten(self.selector.css(css).getall() for css in csss)\n+            return self.item.fields[field_name].get(key)",
      "comment": "Both work for me.\r\nJust need to keep in mind that, as we wait, new changes may come to the files that were moved, requiring to patch/merge changes in the new repo..\r\nThis can get a bit complicated, as we merged the changes there (so we may need to go back in history to merge and then apply the changes back again)",
      "comment_id": 427202439,
      "user": "ejulio",
      "created_at": "2020-05-19T10:39:03Z",
      "url": "https://github.com/scrapy/scrapy/pull/4516#discussion_r427202439"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 4516,
      "file_path": "setup.py",
      "line": 74,
      "side": "RIGHT",
      "diff_hunk": "@@ -71,6 +71,7 @@ def has_environment_marker_platform_impl_support():\n         'Twisted>=17.9.0',\n         'cryptography>=2.0',\n         'cssselect>=0.9.1',\n+        'itemloaders>=1.0.0',",
      "comment": "Could you please check that itemloader's setup.py uses the same minimal package requirements as Scrapy?",
      "comment_id": 427489081,
      "user": "kmike",
      "created_at": "2020-05-19T17:50:12Z",
      "url": "https://github.com/scrapy/scrapy/pull/4516#discussion_r427489081"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 4516,
      "file_path": "scrapy/loader/__init__.py",
      "line": 14,
      "side": "RIGHT",
      "diff_hunk": "@@ -3,219 +3,104 @@\n \n See documentation in docs/topics/loaders.rst\n \"\"\"\n-from collections import defaultdict\n-from contextlib import suppress\n+import itemloaders\n \n from scrapy.item import Item\n-from scrapy.loader.common import wrap_loader_context\n-from scrapy.loader.processors import Identity\n from scrapy.selector import Selector\n-from scrapy.utils.misc import arg_to_iter, extract_regex\n-from scrapy.utils.python import flatten\n \n \n-def unbound_method(method):\n+class ItemLoader(itemloaders.ItemLoader):\n     \"\"\"\n-    Allow to use single-argument functions as input or output processors\n-    (no need to define an unused first 'self' argument)\n-    \"\"\"\n-    with suppress(AttributeError):\n-        if '.' not in method.__qualname__:\n-            return method.__func__\n-    return method\n+    Return a new Item Loader for populating the given Item. If no item is",
      "comment": "It seems this docstring explains how `ItemLoader.__init__` works, not what is ItemLoader class about. Could it be moved to `__init__` method (is autodocs output reasonable?)?\r\n\r\nAlternatively, it can be rewritten as a class docstring. It would probably require only minor changes. This makes more sense to me, because e.g. attribute docs don't really belong to `__init__` docstring.",
      "comment_id": 427552219,
      "user": "kmike",
      "created_at": "2020-05-19T19:37:15Z",
      "url": "https://github.com/scrapy/scrapy/pull/4516#discussion_r427552219"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 4516,
      "file_path": "setup.py",
      "line": 74,
      "side": "RIGHT",
      "diff_hunk": "@@ -71,6 +71,7 @@ def has_environment_marker_platform_impl_support():\n         'Twisted>=17.9.0',\n         'cryptography>=2.0',\n         'cssselect>=0.9.1',\n+        'itemloaders>=1.0.0',",
      "comment": "What do you mean by \"the same minimal package requirements as Scrapy\"?",
      "comment_id": 427717978,
      "user": "victor-torres",
      "created_at": "2020-05-20T03:14:58Z",
      "url": "https://github.com/scrapy/scrapy/pull/4516#discussion_r427717978"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 4516,
      "file_path": "setup.py",
      "line": 74,
      "side": "RIGHT",
      "diff_hunk": "@@ -71,6 +71,7 @@ def has_environment_marker_platform_impl_support():\n         'Twisted>=17.9.0',\n         'cryptography>=2.0',\n         'cssselect>=0.9.1',\n+        'itemloaders>=1.0.0',",
      "comment": "If itemloaders require e.g. parsel 1.6, and scrapy requires 1.5, and now scrapy requires itemloaders, than we're implicitly bumping minimal supported parsel version in scrapy. \r\n\r\nThese versions should either agree, or itemloaders version should be lower.",
      "comment_id": 427831096,
      "user": "kmike",
      "created_at": "2020-05-20T08:28:08Z",
      "url": "https://github.com/scrapy/scrapy/pull/4516#discussion_r427831096"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 4516,
      "file_path": "setup.py",
      "line": 74,
      "side": "RIGHT",
      "diff_hunk": "@@ -71,6 +71,7 @@ def has_environment_marker_platform_impl_support():\n         'Twisted>=17.9.0',\n         'cryptography>=2.0',\n         'cssselect>=0.9.1',\n+        'itemloaders>=1.0.0',",
      "comment": "I'll update the requirements there..\r\nThough, `jmespath` was optional in scrapy, but is a requirement in `itemloaders`\r\nIt shouldn't be a problem, but it changed.",
      "comment_id": 427932661,
      "user": "ejulio",
      "created_at": "2020-05-20T11:21:52Z",
      "url": "https://github.com/scrapy/scrapy/pull/4516#discussion_r427932661"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 4516,
      "file_path": "scrapy/loader/__init__.py",
      "line": 90,
      "side": "RIGHT",
      "diff_hunk": "@@ -3,219 +3,103 @@\n \n See documentation in docs/topics/loaders.rst\n \"\"\"\n-from collections import defaultdict\n-from contextlib import suppress\n+import itemloaders\n \n from scrapy.item import Item\n-from scrapy.loader.common import wrap_loader_context\n-from scrapy.loader.processors import Identity\n from scrapy.selector import Selector\n-from scrapy.utils.misc import arg_to_iter, extract_regex\n-from scrapy.utils.python import flatten\n \n \n-def unbound_method(method):\n+class ItemLoader(itemloaders.ItemLoader):\n     \"\"\"\n-    Allow to use single-argument functions as input or output processors\n-    (no need to define an unused first 'self' argument)\n-    \"\"\"\n-    with suppress(AttributeError):\n-        if '.' not in method.__qualname__:\n-            return method.__func__\n-    return method\n+    A user-fiendly abstraction to populate data to an :ref:`Item <topics-items>`\n+    by applying :ref:`field processors <topics-loaders-processors>` to scraped data.\n+    When instantiated with a ``selector`` or a ``response`` it supports\n+    data extraction from web pages using :ref:`selectors <topics-selectors>`.\n+\n+    :param item: The item instance to populate using subsequent calls to\n+        :meth:`~ItemLoader.add_xpath`, :meth:`~ItemLoader.add_css`,\n+        or :meth:`~ItemLoader.add_value`.\n+    :type item: :class:`~scrapy.item.Item` object\n+\n+    :param selector: The selector to extract data from, when using the\n+        :meth:`add_xpath` (resp. :meth:`add_css`) or :meth:`replace_xpath`\n+        (resp. :meth:`replace_css`) method.\n+    :type selector: :class:`~scrapy.selector.Selector` object\n+\n+    :param response: The response used to construct the selector using the\n+        :attr:`default_selector_class`, unless the selector argument is given,\n+        in which case this argument is ignored.\n+    :type response: :class:`~scrapy.http.Response` object\n+\n+    If no item is given, one is instantiated automatically using the class in\n+    :attr:`default_item_class`.\n+    The item, selector, response and the remaining keyword arguments are\n+    assigned to the Loader context (accessible through the :attr:`context` attribute).\n+\n+    .. attribute:: item\n+\n+        The item object being parsed by this Item Loader.\n+        This is mostly used as a property so when attempting to override this\n+        value, you may want to check out :attr:`default_item_class` first.\n+\n+    .. attribute:: context\n+\n+        The currently active :ref:`Context <loaders-context>` of this Item Loader.\n+        Refer to <loaders-context> for more information about the Loader Context.\n+\n+    .. attribute:: default_item_class\n \n+        An Item class (or factory), used to instantiate items when not given in\n+        the ``__init__`` method.\n \n-class ItemLoader:\n+    .. attribute:: default_input_processor\n+\n+        The default input processor to use for those fields which don't specify\n+        one.\n+\n+    .. attribute:: default_output_processor\n+\n+        The default output processor to use for those fields which don't specify\n+        one.\n+\n+    .. attribute:: default_selector_class\n+\n+        The class used to construct the :attr:`selector` of this\n+        :class:`ItemLoader`, if only a response is given in the ``__init__`` method.\n+        If a selector is given in the ``__init__`` method this attribute is ignored.\n+        This attribute is sometimes overridden in subclasses.\n+\n+    .. attribute:: selector\n+\n+        The :class:`~scrapy.selector.Selector` object to extract data from.\n+        It's either the selector given in the ``__init__`` method or one created from\n+        the response given in the ``__init__`` method using the\n+        :attr:`default_selector_class`. This attribute is meant to be\n+        read-only.\n+    \"\"\"\n \n     default_item_class = Item\n-    default_input_processor = Identity()\n-    default_output_processor = Identity()\n     default_selector_class = Selector\n \n     def __init__(self, item=None, selector=None, response=None, parent=None, **context):\n         if selector is None and response is not None:\n             selector = self.default_selector_class(response)\n-        self.selector = selector\n-        context.update(selector=selector, response=response)\n-        if item is None:\n-            item = self.default_item_class()\n-        self.context = context\n-        self.parent = parent\n-        self._local_item = context['item'] = item\n-        self._local_values = defaultdict(list)\n-        # values from initial item\n-        for field_name, value in item.items():\n-            self._values[field_name] += arg_to_iter(value)\n-\n-    @property\n-    def _values(self):\n-        if self.parent is not None:\n-            return self.parent._values\n-        else:\n-            return self._local_values\n-\n-    @property\n-    def item(self):\n-        if self.parent is not None:\n-            return self.parent.item\n-        else:\n-            return self._local_item\n-\n-    def nested_xpath(self, xpath, **context):\n-        selector = self.selector.xpath(xpath)\n-        context.update(selector=selector)\n-        subloader = self.__class__(\n-            item=self.item, parent=self, **context\n-        )\n-        return subloader\n-\n-    def nested_css(self, css, **context):\n-        selector = self.selector.css(css)\n-        context.update(selector=selector)\n-        subloader = self.__class__(\n-            item=self.item, parent=self, **context\n-        )\n-        return subloader\n-\n-    def add_value(self, field_name, value, *processors, **kw):\n-        value = self.get_value(value, *processors, **kw)\n-        if value is None:\n-            return\n-        if not field_name:\n-            for k, v in value.items():\n-                self._add_value(k, v)\n-        else:\n-            self._add_value(field_name, value)\n-\n-    def replace_value(self, field_name, value, *processors, **kw):\n-        value = self.get_value(value, *processors, **kw)\n-        if value is None:\n-            return\n-        if not field_name:\n-            for k, v in value.items():\n-                self._replace_value(k, v)\n-        else:\n-            self._replace_value(field_name, value)\n-\n-    def _add_value(self, field_name, value):\n-        value = arg_to_iter(value)\n-        processed_value = self._process_input_value(field_name, value)\n-        if processed_value:\n-            self._values[field_name] += arg_to_iter(processed_value)\n-\n-    def _replace_value(self, field_name, value):\n-        self._values.pop(field_name, None)\n-        self._add_value(field_name, value)\n-\n-    def get_value(self, value, *processors, **kw):\n-        regex = kw.get('re', None)\n-        if regex:\n-            value = arg_to_iter(value)\n-            value = flatten(extract_regex(regex, x) for x in value)\n-\n-        for proc in processors:\n-            if value is None:\n-                break\n-            _proc = proc\n-            proc = wrap_loader_context(proc, self.context)\n-            try:\n-                value = proc(value)\n-            except Exception as e:\n-                raise ValueError(\"Error with processor %s value=%r error='%s: %s'\" %\n-                                 (_proc.__class__.__name__, value,\n-                                  type(e).__name__, str(e)))\n-        return value\n-\n-    def load_item(self):\n-        item = self.item\n-        for field_name in tuple(self._values):\n-            value = self.get_output_value(field_name)\n-            if value is not None:\n-                item[field_name] = value\n-\n-        return item\n-\n-    def get_output_value(self, field_name):\n-        proc = self.get_output_processor(field_name)\n-        proc = wrap_loader_context(proc, self.context)\n-        try:\n-            return proc(self._values[field_name])\n-        except Exception as e:\n-            raise ValueError(\"Error with output processor: field=%r value=%r error='%s: %s'\" %\n-                             (field_name, self._values[field_name], type(e).__name__, str(e)))\n-\n-    def get_collected_values(self, field_name):\n-        return self._values[field_name]\n-\n-    def get_input_processor(self, field_name):\n-        proc = getattr(self, '%s_in' % field_name, None)\n+        context.update(response=response)\n+        super().__init__(item=item, selector=selector, parent=parent, **context)\n+\n+    def get_default_input_processor_for_field(self, field_name):",
      "comment": "hm, I suspect these extension points won't be necessary once itemloader gets itemadapter support.",
      "comment_id": 428892663,
      "user": "kmike",
      "created_at": "2020-05-21T20:22:10Z",
      "url": "https://github.com/scrapy/scrapy/pull/4516#discussion_r428892663"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 4516,
      "file_path": "scrapy/loader/__init__.py",
      "line": 14,
      "side": "RIGHT",
      "diff_hunk": "@@ -3,217 +3,86 @@\n \n See documentation in docs/topics/loaders.rst\n \"\"\"\n-from collections import defaultdict\n-from contextlib import suppress\n-\n-from itemadapter import ItemAdapter\n+import itemloaders\n \n from scrapy.item import Item\n-from scrapy.loader.common import wrap_loader_context\n-from scrapy.loader.processors import Identity\n from scrapy.selector import Selector\n-from scrapy.utils.misc import arg_to_iter, extract_regex\n-from scrapy.utils.python import flatten\n \n \n-def unbound_method(method):\n-    \"\"\"\n-    Allow to use single-argument functions as input or output processors\n-    (no need to define an unused first 'self' argument)\n+class ItemLoader(itemloaders.ItemLoader):\n     \"\"\"\n-    with suppress(AttributeError):\n-        if '.' not in method.__qualname__:\n-            return method.__func__\n-    return method\n+    A user-fiendly abstraction to populate data to an :ref:`Item <topics-items>`",
      "comment": "```suggestion\r\n    A user-friendly abstraction to populate an :ref:`item <topics-items>` with data\r\n```",
      "comment_id": 450086518,
      "user": "Gallaecio",
      "created_at": "2020-07-06T09:07:45Z",
      "url": "https://github.com/scrapy/scrapy/pull/4516#discussion_r450086518"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 4516,
      "file_path": "scrapy/loader/__init__.py",
      "line": 22,
      "side": "RIGHT",
      "diff_hunk": "@@ -3,217 +3,86 @@\n \n See documentation in docs/topics/loaders.rst\n \"\"\"\n-from collections import defaultdict\n-from contextlib import suppress\n-\n-from itemadapter import ItemAdapter\n+import itemloaders\n \n from scrapy.item import Item\n-from scrapy.loader.common import wrap_loader_context\n-from scrapy.loader.processors import Identity\n from scrapy.selector import Selector\n-from scrapy.utils.misc import arg_to_iter, extract_regex\n-from scrapy.utils.python import flatten\n \n \n-def unbound_method(method):\n-    \"\"\"\n-    Allow to use single-argument functions as input or output processors\n-    (no need to define an unused first 'self' argument)\n+class ItemLoader(itemloaders.ItemLoader):\n     \"\"\"\n-    with suppress(AttributeError):\n-        if '.' not in method.__qualname__:\n-            return method.__func__\n-    return method\n+    A user-fiendly abstraction to populate data to an :ref:`Item <topics-items>`\n+    by applying :ref:`field processors <topics-loaders-processors>` to scraped data.\n+    When instantiated with a ``selector`` or a ``response`` it supports\n+    data extraction from web pages using :ref:`selectors <topics-selectors>`.\n+\n+    :param item: The item instance to populate using subsequent calls to\n+        :meth:`~ItemLoader.add_xpath`, :meth:`~ItemLoader.add_css`,\n+        or :meth:`~ItemLoader.add_value`.\n+    :type item: :class:`~scrapy.item.Item` object",
      "comment": "I believe this syntax works as well:\r\n\r\n```suggestion\r\n    :type item: scrapy.item.Item\r\n```\r\n\r\nNo strong opinion, though.",
      "comment_id": 450087807,
      "user": "Gallaecio",
      "created_at": "2020-07-06T09:10:00Z",
      "url": "https://github.com/scrapy/scrapy/pull/4516#discussion_r450087807"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 4516,
      "file_path": "scrapy/loader/__init__.py",
      "line": 25,
      "side": "RIGHT",
      "diff_hunk": "@@ -3,217 +3,86 @@\n \n See documentation in docs/topics/loaders.rst\n \"\"\"\n-from collections import defaultdict\n-from contextlib import suppress\n-\n-from itemadapter import ItemAdapter\n+import itemloaders\n \n from scrapy.item import Item\n-from scrapy.loader.common import wrap_loader_context\n-from scrapy.loader.processors import Identity\n from scrapy.selector import Selector\n-from scrapy.utils.misc import arg_to_iter, extract_regex\n-from scrapy.utils.python import flatten\n \n \n-def unbound_method(method):\n-    \"\"\"\n-    Allow to use single-argument functions as input or output processors\n-    (no need to define an unused first 'self' argument)\n+class ItemLoader(itemloaders.ItemLoader):\n     \"\"\"\n-    with suppress(AttributeError):\n-        if '.' not in method.__qualname__:\n-            return method.__func__\n-    return method\n+    A user-fiendly abstraction to populate data to an :ref:`Item <topics-items>`\n+    by applying :ref:`field processors <topics-loaders-processors>` to scraped data.\n+    When instantiated with a ``selector`` or a ``response`` it supports\n+    data extraction from web pages using :ref:`selectors <topics-selectors>`.\n+\n+    :param item: The item instance to populate using subsequent calls to\n+        :meth:`~ItemLoader.add_xpath`, :meth:`~ItemLoader.add_css`,\n+        or :meth:`~ItemLoader.add_value`.\n+    :type item: :class:`~scrapy.item.Item` object\n+\n+    :param selector: The selector to extract data from, when using the\n+        :meth:`add_xpath` (resp. :meth:`add_css`) or :meth:`replace_xpath`",
      "comment": "What does \u201cresp.\u201d mean here?\r\n\r\n:lipstick: Maybe we could just list the 4 methods, as a plain list.",
      "comment_id": 450088752,
      "user": "Gallaecio",
      "created_at": "2020-07-06T09:11:44Z",
      "url": "https://github.com/scrapy/scrapy/pull/4516#discussion_r450088752"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 4516,
      "file_path": "scrapy/loader/__init__.py",
      "line": 36,
      "side": "RIGHT",
      "diff_hunk": "@@ -3,217 +3,86 @@\n \n See documentation in docs/topics/loaders.rst\n \"\"\"\n-from collections import defaultdict\n-from contextlib import suppress\n-\n-from itemadapter import ItemAdapter\n+import itemloaders\n \n from scrapy.item import Item\n-from scrapy.loader.common import wrap_loader_context\n-from scrapy.loader.processors import Identity\n from scrapy.selector import Selector\n-from scrapy.utils.misc import arg_to_iter, extract_regex\n-from scrapy.utils.python import flatten\n \n \n-def unbound_method(method):\n-    \"\"\"\n-    Allow to use single-argument functions as input or output processors\n-    (no need to define an unused first 'self' argument)\n+class ItemLoader(itemloaders.ItemLoader):\n     \"\"\"\n-    with suppress(AttributeError):\n-        if '.' not in method.__qualname__:\n-            return method.__func__\n-    return method\n+    A user-fiendly abstraction to populate data to an :ref:`Item <topics-items>`\n+    by applying :ref:`field processors <topics-loaders-processors>` to scraped data.\n+    When instantiated with a ``selector`` or a ``response`` it supports\n+    data extraction from web pages using :ref:`selectors <topics-selectors>`.\n+\n+    :param item: The item instance to populate using subsequent calls to\n+        :meth:`~ItemLoader.add_xpath`, :meth:`~ItemLoader.add_css`,\n+        or :meth:`~ItemLoader.add_value`.\n+    :type item: :class:`~scrapy.item.Item` object\n+\n+    :param selector: The selector to extract data from, when using the\n+        :meth:`add_xpath` (resp. :meth:`add_css`) or :meth:`replace_xpath`\n+        (resp. :meth:`replace_css`) method.\n+    :type selector: :class:`~scrapy.selector.Selector` object\n+\n+    :param response: The response used to construct the selector using the\n+        :attr:`default_selector_class`, unless the selector argument is given,\n+        in which case this argument is ignored.\n+    :type response: :class:`~scrapy.http.Response` object\n+\n+    If no item is given, one is instantiated automatically using the class in\n+    :attr:`default_item_class`.\n+    The item, selector, response and the remaining keyword arguments are",
      "comment": "```suggestion\r\n    :attr:`default_item_class`.\r\n\r\n    The item, selector, response and remaining keyword arguments are\r\n```",
      "comment_id": 450089293,
      "user": "Gallaecio",
      "created_at": "2020-07-06T09:12:46Z",
      "url": "https://github.com/scrapy/scrapy/pull/4516#discussion_r450089293"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 4516,
      "file_path": "scrapy/loader/__init__.py",
      "line": 42,
      "side": "RIGHT",
      "diff_hunk": "@@ -3,217 +3,86 @@\n \n See documentation in docs/topics/loaders.rst\n \"\"\"\n-from collections import defaultdict\n-from contextlib import suppress\n-\n-from itemadapter import ItemAdapter\n+import itemloaders\n \n from scrapy.item import Item\n-from scrapy.loader.common import wrap_loader_context\n-from scrapy.loader.processors import Identity\n from scrapy.selector import Selector\n-from scrapy.utils.misc import arg_to_iter, extract_regex\n-from scrapy.utils.python import flatten\n \n \n-def unbound_method(method):\n-    \"\"\"\n-    Allow to use single-argument functions as input or output processors\n-    (no need to define an unused first 'self' argument)\n+class ItemLoader(itemloaders.ItemLoader):\n     \"\"\"\n-    with suppress(AttributeError):\n-        if '.' not in method.__qualname__:\n-            return method.__func__\n-    return method\n+    A user-fiendly abstraction to populate data to an :ref:`Item <topics-items>`\n+    by applying :ref:`field processors <topics-loaders-processors>` to scraped data.\n+    When instantiated with a ``selector`` or a ``response`` it supports\n+    data extraction from web pages using :ref:`selectors <topics-selectors>`.\n+\n+    :param item: The item instance to populate using subsequent calls to\n+        :meth:`~ItemLoader.add_xpath`, :meth:`~ItemLoader.add_css`,\n+        or :meth:`~ItemLoader.add_value`.\n+    :type item: :class:`~scrapy.item.Item` object\n+\n+    :param selector: The selector to extract data from, when using the\n+        :meth:`add_xpath` (resp. :meth:`add_css`) or :meth:`replace_xpath`\n+        (resp. :meth:`replace_css`) method.\n+    :type selector: :class:`~scrapy.selector.Selector` object\n+\n+    :param response: The response used to construct the selector using the\n+        :attr:`default_selector_class`, unless the selector argument is given,\n+        in which case this argument is ignored.\n+    :type response: :class:`~scrapy.http.Response` object\n+\n+    If no item is given, one is instantiated automatically using the class in\n+    :attr:`default_item_class`.\n+    The item, selector, response and the remaining keyword arguments are\n+    assigned to the Loader context (accessible through the :attr:`context` attribute).\n+\n+    .. attribute:: item\n+\n+        The item object being parsed by this Item Loader.\n+        This is mostly used as a property so when attempting to override this",
      "comment": "```suggestion\r\n        This is mostly used as a property so, when attempting to override this\r\n```",
      "comment_id": 450090500,
      "user": "Gallaecio",
      "created_at": "2020-07-06T09:14:47Z",
      "url": "https://github.com/scrapy/scrapy/pull/4516#discussion_r450090500"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 4516,
      "file_path": "scrapy/loader/__init__.py",
      "line": 52,
      "side": "RIGHT",
      "diff_hunk": "@@ -3,217 +3,86 @@\n \n See documentation in docs/topics/loaders.rst\n \"\"\"\n-from collections import defaultdict\n-from contextlib import suppress\n-\n-from itemadapter import ItemAdapter\n+import itemloaders\n \n from scrapy.item import Item\n-from scrapy.loader.common import wrap_loader_context\n-from scrapy.loader.processors import Identity\n from scrapy.selector import Selector\n-from scrapy.utils.misc import arg_to_iter, extract_regex\n-from scrapy.utils.python import flatten\n \n \n-def unbound_method(method):\n-    \"\"\"\n-    Allow to use single-argument functions as input or output processors\n-    (no need to define an unused first 'self' argument)\n+class ItemLoader(itemloaders.ItemLoader):\n     \"\"\"\n-    with suppress(AttributeError):\n-        if '.' not in method.__qualname__:\n-            return method.__func__\n-    return method\n+    A user-fiendly abstraction to populate data to an :ref:`Item <topics-items>`\n+    by applying :ref:`field processors <topics-loaders-processors>` to scraped data.\n+    When instantiated with a ``selector`` or a ``response`` it supports\n+    data extraction from web pages using :ref:`selectors <topics-selectors>`.\n+\n+    :param item: The item instance to populate using subsequent calls to\n+        :meth:`~ItemLoader.add_xpath`, :meth:`~ItemLoader.add_css`,\n+        or :meth:`~ItemLoader.add_value`.\n+    :type item: :class:`~scrapy.item.Item` object\n+\n+    :param selector: The selector to extract data from, when using the\n+        :meth:`add_xpath` (resp. :meth:`add_css`) or :meth:`replace_xpath`\n+        (resp. :meth:`replace_css`) method.\n+    :type selector: :class:`~scrapy.selector.Selector` object\n+\n+    :param response: The response used to construct the selector using the\n+        :attr:`default_selector_class`, unless the selector argument is given,\n+        in which case this argument is ignored.\n+    :type response: :class:`~scrapy.http.Response` object\n+\n+    If no item is given, one is instantiated automatically using the class in\n+    :attr:`default_item_class`.\n+    The item, selector, response and the remaining keyword arguments are\n+    assigned to the Loader context (accessible through the :attr:`context` attribute).\n+\n+    .. attribute:: item\n+\n+        The item object being parsed by this Item Loader.\n+        This is mostly used as a property so when attempting to override this\n+        value, you may want to check out :attr:`default_item_class` first.\n+\n+    .. attribute:: context\n+\n+        The currently active :ref:`Context <loaders-context>` of this Item Loader.\n+        Refer to <loaders-context> for more information about the Loader Context.\n \n+    .. attribute:: default_item_class\n \n-class ItemLoader:\n+        An Item class (or factory), used to instantiate items when not given in",
      "comment": "If `dict` is a supported value, even if `attr.s` and `dataclass` are experimental, maybe we should say lowercase \u2018item\u2019 with a link to the topic on items.",
      "comment_id": 450091331,
      "user": "Gallaecio",
      "created_at": "2020-07-06T09:16:16Z",
      "url": "https://github.com/scrapy/scrapy/pull/4516#discussion_r450091331"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 4516,
      "file_path": "scrapy/loader/__init__.py",
      "line": 49,
      "side": "RIGHT",
      "diff_hunk": "@@ -3,217 +3,87 @@\n \n See documentation in docs/topics/loaders.rst\n \"\"\"\n-from collections import defaultdict\n-from contextlib import suppress\n-\n-from itemadapter import ItemAdapter\n+import itemloaders\n \n from scrapy.item import Item\n-from scrapy.loader.common import wrap_loader_context\n-from scrapy.loader.processors import Identity\n from scrapy.selector import Selector\n-from scrapy.utils.misc import arg_to_iter, extract_regex\n-from scrapy.utils.python import flatten\n \n \n-def unbound_method(method):\n-    \"\"\"\n-    Allow to use single-argument functions as input or output processors\n-    (no need to define an unused first 'self' argument)\n+class ItemLoader(itemloaders.ItemLoader):\n     \"\"\"\n-    with suppress(AttributeError):\n-        if '.' not in method.__qualname__:\n-            return method.__func__\n-    return method\n+    A user-friendly abstraction to populate an :ref:`item <topics-items>` with data\n+    by applying :ref:`field processors <topics-loaders-processors>` to scraped data.\n+    When instantiated with a ``selector`` or a ``response`` it supports\n+    data extraction from web pages using :ref:`selectors <topics-selectors>`.\n+\n+    :param item: The item instance to populate using subsequent calls to\n+        :meth:`~ItemLoader.add_xpath`, :meth:`~ItemLoader.add_css`,\n+        or :meth:`~ItemLoader.add_value`.\n+    :type item: scrapy.item.Item\n+\n+    :param selector: The selector to extract data from, when using the\n+        :meth:`add_xpath`, :meth:`add_css`, :meth:`replace_xpath`, or\n+        :meth:`replace_css` method.\n+    :type selector: :class:`~scrapy.selector.Selector` object\n+\n+    :param response: The response used to construct the selector using the\n+        :attr:`default_selector_class`, unless the selector argument is given,\n+        in which case this argument is ignored.\n+    :type response: :class:`~scrapy.http.Response` object\n+\n+    If no item is given, one is instantiated automatically using the class in\n+    :attr:`default_item_class`.\n+\n+    The item, selector, response and remaining keyword arguments are\n+    assigned to the Loader context (accessible through the :attr:`context` attribute).\n+\n+    .. attribute:: item\n+\n+        The item object being parsed by this Item Loader.\n+        This is mostly used as a property so, when attempting to override this\n+        value, you may want to check out :attr:`default_item_class` first.\n+\n+    .. attribute:: context\n \n+        The currently active :ref:`Context <loaders-context>` of this Item Loader.\n+        Refer to <loaders-context> for more information about the Loader Context.",
      "comment": "The reference here is broken, missing the surrounding `` :ref:`\u2026` ``. But I think the whole line could go, the line above should be enough.",
      "comment_id": 452734156,
      "user": "Gallaecio",
      "created_at": "2020-07-10T09:32:53Z",
      "url": "https://github.com/scrapy/scrapy/pull/4516#discussion_r452734156"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 4516,
      "file_path": "tests/test_loader.py",
      "line": 9,
      "side": "RIGHT",
      "diff_hunk": "@@ -7,8 +6,7 @@\n from scrapy.http import HtmlResponse\n from scrapy.item import Item, Field\n from scrapy.loader import ItemLoader\n-from scrapy.loader.processors import (Compose, Identity, Join,\n-                                      MapCompose, SelectJmes, TakeFirst)\n+from scrapy.loader.processors import Compose, Identity, MapCompose, TakeFirst",
      "comment": "In this and any other file were we import processors, we should start importing them from the new library.",
      "comment_id": 453162268,
      "user": "Gallaecio",
      "created_at": "2020-07-11T06:19:24Z",
      "url": "https://github.com/scrapy/scrapy/pull/4516#discussion_r453162268"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 4516,
      "file_path": "tests/test_loader_deprecated.py",
      "line": 7,
      "side": "RIGHT",
      "diff_hunk": "@@ -0,0 +1,695 @@\n+\"\"\"\n+These tests are kept as references from the ones that were ported to a itemloaders library.\n+Once we remove the references from scrapy, we can remove these tests.\n+\"\"\"\n+\n+from functools import partial\n+import unittest",
      "comment": ":lipstick: \r\n\r\n```suggestion\r\nimport unittest\r\nfrom functools import partial\r\n```",
      "comment_id": 453162436,
      "user": "Gallaecio",
      "created_at": "2020-07-11T06:21:32Z",
      "url": "https://github.com/scrapy/scrapy/pull/4516#discussion_r453162436"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 4377,
      "file_path": "scrapy/commands/parse.py",
      "line": 239,
      "side": "RIGHT",
      "diff_hunk": "@@ -233,6 +238,22 @@ def process_spider_arguments(self, opts):\n             opts.spargs = arglist_to_dict(opts.spargs)\n         except ValueError:\n             raise UsageError(\"Invalid -a value, use -a NAME=VALUE\", print_help=False)\n+        if opts.output:",
      "comment": "Please use [`scrapy.utils.conf.feed_process_params_from_cli`](https://github.com/scrapy/scrapy/blob/8845773d44329194ee73fa4985a94e768bf664e7/scrapy/utils/conf.py#L127-L172) to handle this. `FEED_URI`, `FEED_FORMAT` and the `-t` CLI option are deprecated in #3858 (to be released in 2.1)",
      "comment_id": 401114153,
      "user": "elacuesta",
      "created_at": "2020-03-31T18:10:24Z",
      "url": "https://github.com/scrapy/scrapy/pull/4377#discussion_r401114153"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 4377,
      "file_path": "scrapy/commands/parse.py",
      "line": 214,
      "side": "RIGHT",
      "diff_hunk": "@@ -206,7 +209,9 @@ def callback(response, **cb_kwargs):\n                     req.meta['_depth'] = depth + 1\n                     req.meta['_callback'] = req.callback\n                     req.callback = callback\n-                return requests\n+                return items + requests\n+            else:\n+                return items  # dumps the remaining output to a FILE",
      "comment": "Maybe we should only do this when the new option is used, to minimize behavior changes?",
      "comment_id": 402806354,
      "user": "Gallaecio",
      "created_at": "2020-04-03T08:00:47Z",
      "url": "https://github.com/scrapy/scrapy/pull/4377#discussion_r402806354"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 4612,
      "file_path": "scrapy/utils/curl.py",
      "line": 98,
      "side": "RIGHT",
      "diff_hunk": "@@ -90,5 +90,9 @@ def curl_to_request_kwargs(curl_command, ignore_unknown_options=True):\n         result['cookies'] = cookies\n     if parsed_args.data:\n         result['body'] = parsed_args.data\n+        if result.get('method') == 'GET':\n+            # if the \"data\" is specified but the \"method\" is not specified,\n+            # the default method is 'POST'\n+            result['method'] = 'POST'",
      "comment": "While it should not be a problem in most real-life scenarios, `curl <URL> -X GET --data asdf` works. We need to distinguish when `-X` is passed with `GET` and when it is omitted.",
      "comment_id": 436238694,
      "user": "Gallaecio",
      "created_at": "2020-06-06T05:05:12Z",
      "url": "https://github.com/scrapy/scrapy/pull/4612#discussion_r436238694"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 4612,
      "file_path": "scrapy/utils/curl.py",
      "line": 98,
      "side": "RIGHT",
      "diff_hunk": "@@ -90,5 +90,9 @@ def curl_to_request_kwargs(curl_command, ignore_unknown_options=True):\n         result['cookies'] = cookies\n     if parsed_args.data:\n         result['body'] = parsed_args.data\n+        if result.get('method') == 'GET':\n+            # if the \"data\" is specified but the \"method\" is not specified,\n+            # the default method is 'POST'\n+            result['method'] = 'POST'",
      "comment": "Hi @Gallaecio, \r\n\r\nI'm not sure which approach to take. From my perspective, this command tries to do the best from the cURL command, and I think that it doesn't have any sense to add the body when the method is GET.\r\n\r\nBefore deciding this I checked other tools as https://curl.trillworks.com/ , and when entering:\r\n```bash\r\ncurl URL -X GET --data asdf\r\n```\r\n\r\nI got:\r\n```python\r\nimport requests\r\n\r\ndata = 'asdf'\r\n\r\nresponse = requests.post('http://URL', data=data)\r\n```\r\n\r\nOf course, I can change it to respect the provided GET, but I'm not sure about the best option. Any other idea / thoughts?",
      "comment_id": 436797139,
      "user": "noviluni",
      "created_at": "2020-06-08T15:30:23Z",
      "url": "https://github.com/scrapy/scrapy/pull/4612#discussion_r436797139"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 4612,
      "file_path": "scrapy/utils/curl.py",
      "line": 98,
      "side": "RIGHT",
      "diff_hunk": "@@ -90,5 +90,9 @@ def curl_to_request_kwargs(curl_command, ignore_unknown_options=True):\n         result['cookies'] = cookies\n     if parsed_args.data:\n         result['body'] = parsed_args.data\n+        if result.get('method') == 'GET':\n+            # if the \"data\" is specified but the \"method\" is not specified,\n+            # the default method is 'POST'\n+            result['method'] = 'POST'",
      "comment": "I\u2019m not against merging the code as is.\r\n\r\nBut a server may support a GET with a form even if it is not standard:\r\n\r\n```\r\n[adrian@afonsox ~]$ curl httpbin.org/anything -X GET --data asdf\r\n{\r\n  \"args\": {}, \r\n  \"data\": \"\", \r\n  \"files\": {}, \r\n  \"form\": {\r\n    \"asdf\": \"\"\r\n  }, \r\n  \"headers\": {\r\n    \"Accept\": \"*/*\", \r\n    \"Content-Length\": \"4\", \r\n    \"Content-Type\": \"application/x-www-form-urlencoded\", \r\n    \"Host\": \"httpbin.org\", \r\n    \"User-Agent\": \"curl/7.70.0\", \r\n    \"X-Amzn-Trace-Id\": \"Root=\u2026\"\r\n  }, \r\n  \"json\": null, \r\n  \"method\": \"GET\", \r\n  \"origin\": \"\u2026\", \r\n  \"url\": \"http://httpbin.org/anything\"\r\n}\r\n```\r\n\r\nSo I would either implement `GET` support here or create a separate issue to eventually add it.",
      "comment_id": 439845006,
      "user": "Gallaecio",
      "created_at": "2020-06-14T16:13:53Z",
      "url": "https://github.com/scrapy/scrapy/pull/4612#discussion_r439845006"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 4612,
      "file_path": "scrapy/utils/curl.py",
      "line": 98,
      "side": "RIGHT",
      "diff_hunk": "@@ -90,5 +90,9 @@ def curl_to_request_kwargs(curl_command, ignore_unknown_options=True):\n         result['cookies'] = cookies\n     if parsed_args.data:\n         result['body'] = parsed_args.data\n+        if result.get('method') == 'GET':\n+            # if the \"data\" is specified but the \"method\" is not specified,\n+            # the default method is 'POST'\n+            result['method'] = 'POST'",
      "comment": "Ok, I fixed the code to respect this behavior. :+1: ",
      "comment_id": 445388142,
      "user": "noviluni",
      "created_at": "2020-06-25T08:19:42Z",
      "url": "https://github.com/scrapy/scrapy/pull/4612#discussion_r445388142"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 4558,
      "file_path": "scrapy/shell.py",
      "line": 155,
      "side": "RIGHT",
      "diff_hunk": "@@ -146,14 +146,13 @@ def get_help(self):\n         b.append(\"Useful shortcuts:\")\n         if self.inthread:\n             b.append(\"  fetch(url[, redirect=True]) \"\n-                     \"Fetch URL and update local objects \"\n-                     \"(by default, redirects are followed)\")\n+                     \"Fetch URL and update local objects (by default, redirects are followed)\")\n             b.append(\"  fetch(req)                  \"\n                      \"Fetch a scrapy.Request and update local objects \")\n         b.append(\"  shelp()           Shell help (print this help)\")\n         b.append(\"  view(response)    View response in a browser\")\n \n-        return \"\\n\".join(\"[s] %s\" % l for l in b)\n+        return \"\\n\".join(\"[s] %s\" % line for line in b)",
      "comment": "Hi @elacuesta \r\n\r\nMaybe it's not necessary to do it as part of this PR, but as we are giving more meaning to a lot of variable names, it could be a good idea to rename this `b` variable to something like `banner` (I assume this is the real meaning by looking at this: `self.vars['banner'] = self.get_help()`) or `help_lines`.",
      "comment_id": 424390063,
      "user": "noviluni",
      "created_at": "2020-05-13T12:16:49Z",
      "url": "https://github.com/scrapy/scrapy/pull/4558#discussion_r424390063"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 4558,
      "file_path": "scrapy/shell.py",
      "line": 155,
      "side": "RIGHT",
      "diff_hunk": "@@ -146,14 +146,13 @@ def get_help(self):\n         b.append(\"Useful shortcuts:\")\n         if self.inthread:\n             b.append(\"  fetch(url[, redirect=True]) \"\n-                     \"Fetch URL and update local objects \"\n-                     \"(by default, redirects are followed)\")\n+                     \"Fetch URL and update local objects (by default, redirects are followed)\")\n             b.append(\"  fetch(req)                  \"\n                      \"Fetch a scrapy.Request and update local objects \")\n         b.append(\"  shelp()           Shell help (print this help)\")\n         b.append(\"  view(response)    View response in a browser\")\n \n-        return \"\\n\".join(\"[s] %s\" % l for l in b)\n+        return \"\\n\".join(\"[s] %s\" % line for line in b)",
      "comment": "Indeed, I almost did that, but I decided not to in order to keep the diff simpler. Perhaps we can do it in a later PR :+1: ",
      "comment_id": 424398138,
      "user": "elacuesta",
      "created_at": "2020-05-13T12:30:05Z",
      "url": "https://github.com/scrapy/scrapy/pull/4558#discussion_r424398138"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 4629,
      "file_path": "scrapy/extensions/feedexport.py",
      "line": 286,
      "side": "LEFT",
      "diff_hunk": "@@ -277,11 +277,25 @@ def close_spider(self, spider):\n                         'itemcount': slot.itemcount,\n                         'uri': slot.uri}\n             d = defer.maybeDeferred(slot.storage.store, slot.file)\n-            d.addCallback(lambda _: logger.info(logfmt % \"Stored\", log_args,\n-                                                extra={'spider': spider}))\n-            d.addErrback(lambda f: logger.error(logfmt % \"Error storing\", log_args,\n-                                                exc_info=failure_to_exc_info(f),\n-                                                extra={'spider': spider}))",
      "comment": "I wonder if [this](https://stackoverflow.com/a/2295372/939364) would work. It would be much cleaner.",
      "comment_id": 439858641,
      "user": "Gallaecio",
      "created_at": "2020-06-14T19:05:03Z",
      "url": "https://github.com/scrapy/scrapy/pull/4629#discussion_r439858641"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 4626,
      "file_path": "tests/test_feedexport.py",
      "line": 19,
      "side": "RIGHT",
      "diff_hunk": "@@ -16,7 +16,8 @@\n import lxml.etree\n from twisted.internet import defer\n from twisted.trial import unittest\n-from w3lib.url import path_to_file_uri\n+from w3lib.url import path_to_file_uri, file_uri_to_path",
      "comment": ":lipstick: \r\n\r\n```suggestion\r\nfrom w3lib.url import file_uri_to_path, path_to_file_uri\r\n```",
      "comment_id": 439861070,
      "user": "Gallaecio",
      "created_at": "2020-06-14T19:38:09Z",
      "url": "https://github.com/scrapy/scrapy/pull/4626#discussion_r439861070"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 4626,
      "file_path": "tests/test_feedexport.py",
      "line": 671,
      "side": "RIGHT",
      "diff_hunk": "@@ -623,6 +653,23 @@ def test_export_no_items_store_empty(self):\n             data = yield self.exported_no_data(settings)\n             self.assertEqual(data[fmt], expctd)\n \n+    @defer.inlineCallbacks\n+    def test_export_no_items_multiple_feeds(self):\n+        settings = {\n+            'FEEDS': {\n+                self._random_temp_filename(): {'format': 'json'},\n+                self._random_temp_filename(): {'format': 'xml'},\n+                self._random_temp_filename(): {'format': 'csv'},\n+            },\n+            'FEED_STORAGES': {'file': 'tests.test_feedexport.WriteOnStoreFileStorage'},\n+            'FEED_STORE_EMPTY': False\n+        }\n+        data = yield self.exported_no_data(settings)\n+\n+        self.assertIn('json', data)\n+        self.assertIn('xml', data)\n+        self.assertIn('csv', data)",
      "comment": "I think this test could use a docstring. I think it is checking that `FEED_STORE_EMPTY=False` does not prevent `store()` from being called by using `WriteOnStoreFileStorage`, which acts as if `FEED_STORE_EMPTY=True`.\r\n\r\nAlso, based on your issue report, I wonder if it would not be easier to check the log content instead. I don\u2019t see any log-based test in this test file, though, so maybe it would actually be harder.",
      "comment_id": 439862157,
      "user": "Gallaecio",
      "created_at": "2020-06-14T19:52:22Z",
      "url": "https://github.com/scrapy/scrapy/pull/4626#discussion_r439862157"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 4626,
      "file_path": "tests/test_feedexport.py",
      "line": 671,
      "side": "RIGHT",
      "diff_hunk": "@@ -623,6 +653,23 @@ def test_export_no_items_store_empty(self):\n             data = yield self.exported_no_data(settings)\n             self.assertEqual(data[fmt], expctd)\n \n+    @defer.inlineCallbacks\n+    def test_export_no_items_multiple_feeds(self):\n+        settings = {\n+            'FEEDS': {\n+                self._random_temp_filename(): {'format': 'json'},\n+                self._random_temp_filename(): {'format': 'xml'},\n+                self._random_temp_filename(): {'format': 'csv'},\n+            },\n+            'FEED_STORAGES': {'file': 'tests.test_feedexport.WriteOnStoreFileStorage'},\n+            'FEED_STORE_EMPTY': False\n+        }\n+        data = yield self.exported_no_data(settings)\n+\n+        self.assertIn('json', data)\n+        self.assertIn('xml', data)\n+        self.assertIn('csv', data)",
      "comment": "Actually, `storage.store` needs to be called every time by design.\r\n`FEED_STORE_EMPTY` is a little bit strange setting. It does not prevent a file from being created, but rather it prevents creation of an object inside the file. \r\nIn other words, this setting defines whether an output file will contain `[]` (in case of json) or will be empty.\r\nThis is a little confusing, in my opinion, but out of scope of this PR.\r\n\r\nHere I fix the missing calls of `storage.store` that are expected even in cases when there are no data and `FEED_STORE_EMPTY=False`. ",
      "comment_id": 440302731,
      "user": "StasDeep",
      "created_at": "2020-06-15T16:34:07Z",
      "url": "https://github.com/scrapy/scrapy/pull/4626#discussion_r440302731"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 3881,
      "file_path": "scrapy/core/scraper.py",
      "line": 187,
      "side": "RIGHT",
      "diff_hunk": "@@ -182,7 +184,7 @@ def _process_spidermw_output(self, output, request, response, spider):\n         \"\"\"\n         if isinstance(output, Request):\n             self.crawler.engine.crawl(request=output, spider=spider)\n-        elif isinstance(output, (BaseItem, dict)):\n+        elif isinstance(output, (BaseItem, dict)) or is_dataclass_instance(output):",
      "comment": "Maybe we should implement a high-level helper function for use cases like this?\r\n```suggestion\r\n        elif is_item(output):\r\n```\r\n\r\nThis would make our current FAQ entry about splitting an item into multiple items much more readable.",
      "comment_id": 308311708,
      "user": "Gallaecio",
      "created_at": "2019-07-29T16:04:52Z",
      "url": "https://github.com/scrapy/scrapy/pull/3881#discussion_r308311708"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 3881,
      "file_path": "scrapy/shell.py",
      "line": 157,
      "side": "RIGHT",
      "diff_hunk": "@@ -159,7 +156,7 @@ def get_help(self):\n         return \"\\n\".join(\"[s] %s\" % l for l in b)\n \n     def _is_relevant(self, value):\n-        return isinstance(value, self.relevant_classes)\n+        return isinstance(value, self.relevant_classes) or is_item_like(value)",
      "comment": "Looking at line 122 (old 125), I think this file does not need any change, given that `_is_relevant` is only used with the contents of `self.vars`.",
      "comment_id": 351661982,
      "user": "Gallaecio",
      "created_at": "2019-11-28T09:12:30Z",
      "url": "https://github.com/scrapy/scrapy/pull/3881#discussion_r351661982"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 3881,
      "file_path": "scrapy/spiders/feed.py",
      "line": 34,
      "side": "RIGHT",
      "diff_hunk": "@@ -31,7 +31,7 @@ def process_results(self, response, results):\n         processing required before returning the results to the framework core,\n         for example setting the item GUIDs. It receives a list of results and\n         the response which originated that results. It must return a list of\n-        results (Items or Requests).\n+        results (Requests, Items, dicts, dataclasses).",
      "comment": ":lipstick:  We could alternatively modify the string not to refer to classes, but concepts.\r\n```suggestion\r\n        results (items or requests).\r\n```",
      "comment_id": 351662795,
      "user": "Gallaecio",
      "created_at": "2019-11-28T09:14:15Z",
      "url": "https://github.com/scrapy/scrapy/pull/3881#discussion_r351662795"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 3881,
      "file_path": "scrapy/shell.py",
      "line": 157,
      "side": "RIGHT",
      "diff_hunk": "@@ -159,7 +156,7 @@ def get_help(self):\n         return \"\\n\".join(\"[s] %s\" % l for l in b)\n \n     def _is_relevant(self, value):\n-        return isinstance(value, self.relevant_classes)\n+        return isinstance(value, self.relevant_classes) or is_item_like(value)",
      "comment": "Actually it seems to be necessary for the item to be displayed in the \"Available Scrapy objects\" list. It's just an aesthetic thing, since the variable is populated nonetheless, just not displayed in the list of variables.\r\n\r\n```python\r\n# inventory.py\r\nfrom dataclasses import dataclass, field\r\n\r\n@dataclass\r\nclass InventoryItem:\r\n    name: list = field(default_factory=list)\r\n    price: list = field(default_factory=list)\r\n    stock: list = field(default_factory=list)\r\n```\r\n\r\n```\r\n$ scrapy shell https://example.org -s DEFAULT_ITEM_CLASS=inventory.InventoryItem\r\n2019-11-29 13:37:40 [scrapy.utils.log] INFO: Scrapy 1.8.0 started (bot: scrapybot)\r\n(...)\r\n[s] Available Scrapy objects:\r\n[s]   scrapy     scrapy module (contains scrapy.Request, scrapy.Selector, etc)\r\n[s]   crawler    <scrapy.crawler.Crawler object at 0x7fcd90b1cbe0>\r\n[s]   item       InventoryItem(name=[], price=[], stock=[])\r\n[s]   request    <GET https://example.org>\r\n[s]   response   <200 https://example.org>\r\n[s]   settings   <scrapy.settings.Settings object at 0x7fcd8c94d7f0>\r\n[s]   spider     <DefaultSpider 'default' at 0x7fcd8b668f60>\r\n[s] Useful shortcuts:\r\n[s]   fetch(url[, redirect=True]) Fetch URL and update local objects (by default, redirects are followed)\r\n[s]   fetch(req)                  Fetch a scrapy.Request and update local objects \r\n[s]   shelp()           Shell help (print this help)\r\n[s]   view(response)    View response in a browser\r\nIn [1]: item\r\nOut[1]: InventoryItem(name=[], price=[], stock=[])\r\n```\r\n\r\nFor reference, here is where the `item` variable gets populated: https://github.com/scrapy/scrapy/blob/1.8.0/scrapy/shell.py#L125",
      "comment_id": 352201799,
      "user": "elacuesta",
      "created_at": "2019-11-29T16:42:56Z",
      "url": "https://github.com/scrapy/scrapy/pull/3881#discussion_r352201799"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 3881,
      "file_path": "scrapy/utils/datatypes.py",
      "line": 314,
      "side": "RIGHT",
      "diff_hunk": "@@ -291,3 +292,29 @@ def __init__(self, seq):\n \n     def __contains__(self, item):\n         return item not in self.seq\n+\n+\n+def get_item_field(item, field_name, default=None):\n+    \"\"\"\n+    Access item fields on both \"regular\" and dataclass-based items\n+    \"\"\"\n+    if is_dataclass_instance(item):\n+        return getattr(item, field_name, default)\n+    else:\n+        return item.get(field_name, default)\n+\n+\n+def set_item_field(item, field_name, value):\n+    \"\"\"\n+    Set item fields on both \"regular\" and dataclass-based items\n+    \"\"\"\n+    if is_dataclass_instance(item):\n+        if not hasattr(item, \"_field_names\"):\n+            from dataclasses import fields\n+            item._field_names = [f.name for f in fields(item)]",
      "comment": "Is it a performance optimization, to cache available field names? I'm not sure that's good to add attributes to user's objects. It can be fine to just use fields.",
      "comment_id": 370307961,
      "user": "kmike",
      "created_at": "2020-01-23T19:21:18Z",
      "url": "https://github.com/scrapy/scrapy/pull/3881#discussion_r370307961"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 3881,
      "file_path": "scrapy/utils/misc.py",
      "line": 37,
      "side": "RIGHT",
      "diff_hunk": "@@ -34,6 +34,10 @@ def arg_to_iter(arg):\n         return [arg]\n \n \n+def is_item_like(obj):",
      "comment": "Could you please add a docstring and tests for this function?",
      "comment_id": 370310028,
      "user": "kmike",
      "created_at": "2020-01-23T19:25:41Z",
      "url": "https://github.com/scrapy/scrapy/pull/3881#discussion_r370310028"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 3881,
      "file_path": "scrapy/utils/python.py",
      "line": 26,
      "side": "RIGHT",
      "diff_hunk": "@@ -1,19 +1,32 @@\n \"\"\"\n This module contains essential stuff that should've come with Python itself ;)\n \"\"\"\n+import errno\n import gc\n+import inspect\n import os\n import re\n-import inspect\n+import sys\n import weakref\n-import errno\n from functools import partial, wraps\n from itertools import chain\n-import sys\n \n from scrapy.utils.decorators import deprecated\n \n \n+try:\n+    from dataclasses import is_dataclass, asdict as dataclass_asdict\n+except ImportError:\n+    def is_dataclass_instance(_):\n+        return False\n+\n+    def dataclass_asdict(_):\n+        raise ImportError(\"no module named 'dataclasses'\")\n+else:\n+    def is_dataclass_instance(obj):",
      "comment": "Could you please add a bit more tests to this function?",
      "comment_id": 370311116,
      "user": "kmike",
      "created_at": "2020-01-23T19:27:53Z",
      "url": "https://github.com/scrapy/scrapy/pull/3881#discussion_r370311116"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 3881,
      "file_path": "tests/test_loader.py",
      "line": 541,
      "side": "RIGHT",
      "diff_hunk": "@@ -528,7 +538,7 @@ def test_get_output_value_list(self):\n         self.assertEqual(il.get_output_value('name'), ['foo', 'bar'])\n         loaded_item = il.load_item()\n         self.assertIsInstance(loaded_item, self.item_class)\n-        self.assertEqual(loaded_item, dict({'name': ['foo', 'bar']}))\n+        self.assertEqual(self.to_dict(loaded_item), dict({'name': ['foo', 'bar']}))",
      "comment": "Is self.to_dict needed because item loaders can return dataclass instances now? If so, could you please add tests for this behavior?",
      "comment_id": 370312599,
      "user": "kmike",
      "created_at": "2020-01-23T19:31:00Z",
      "url": "https://github.com/scrapy/scrapy/pull/3881#discussion_r370312599"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 3881,
      "file_path": "tests/test_loader.py",
      "line": 541,
      "side": "RIGHT",
      "diff_hunk": "@@ -528,7 +538,7 @@ def test_get_output_value_list(self):\n         self.assertEqual(il.get_output_value('name'), ['foo', 'bar'])\n         loaded_item = il.load_item()\n         self.assertIsInstance(loaded_item, self.item_class)\n-        self.assertEqual(loaded_item, dict({'name': ['foo', 'bar']}))\n+        self.assertEqual(self.to_dict(loaded_item), dict({'name': ['foo', 'bar']}))",
      "comment": "Also, could you please check Item Loaders docs, and update it accordingly? I think it still says that Item instances are expected, or dict-like objects, which is no longer true.",
      "comment_id": 370313514,
      "user": "kmike",
      "created_at": "2020-01-23T19:33:03Z",
      "url": "https://github.com/scrapy/scrapy/pull/3881#discussion_r370313514"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 3881,
      "file_path": "tests/test_pipeline_images.py",
      "line": 133,
      "side": "RIGHT",
      "diff_hunk": "@@ -117,43 +126,74 @@ def thumb_key(self, url, thumb_id):\n         return 'thumbsup/%s/%s.jpg' % (thumb_id, thumb_guid)\n \n \n-class ImagesPipelineTestCaseFields(unittest.TestCase):\n+class ImagesPipelineTestCaseFieldsMixin:\n \n     def test_item_fields_default(self):\n-        class TestItem(Item):\n-            name = Field()\n-            image_urls = Field()\n-            images = Field()\n-\n-        for cls in TestItem, dict:\n-            url = 'http://www.example.com/images/1.jpg'\n-            item = cls({'name': 'item1', 'image_urls': [url]})\n-            pipeline = ImagesPipeline.from_settings(Settings({'IMAGES_STORE': 's3://example/images/'}))\n-            requests = list(pipeline.get_media_requests(item, None))\n-            self.assertEqual(requests[0].url, url)\n-            results = [(True, {'url': url})]\n-            pipeline.item_completed(results, item, None)\n-            self.assertEqual(item['images'], [results[0][1]])\n+        url = 'http://www.example.com/images/1.jpg'\n+        item = self.item_class(name='item1', image_urls=[url])",
      "comment": "Could you please add a dataclass example to media-pipeline.rst as well (see \"Usage example\" - it shows how to add a field for Item)?",
      "comment_id": 370316072,
      "user": "kmike",
      "created_at": "2020-01-23T19:38:35Z",
      "url": "https://github.com/scrapy/scrapy/pull/3881#discussion_r370316072"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 3881,
      "file_path": "scrapy/utils/python.py",
      "line": 26,
      "side": "RIGHT",
      "diff_hunk": "@@ -1,19 +1,32 @@\n \"\"\"\n This module contains essential stuff that should've come with Python itself ;)\n \"\"\"\n+import errno\n import gc\n+import inspect\n import os\n import re\n-import inspect\n+import sys\n import weakref\n-import errno\n from functools import partial, wraps\n from itertools import chain\n-import sys\n \n from scrapy.utils.decorators import deprecated\n \n \n+try:\n+    from dataclasses import is_dataclass, asdict as dataclass_asdict\n+except ImportError:\n+    def is_dataclass_instance(_):\n+        return False\n+\n+    def dataclass_asdict(_):\n+        raise ImportError(\"no module named 'dataclasses'\")\n+else:\n+    def is_dataclass_instance(obj):",
      "comment": "This is an upstream recipe, taken verbatim from the official docs: https://docs.python.org/3/library/dataclasses.html#dataclasses.is_dataclass",
      "comment_id": 378608814,
      "user": "elacuesta",
      "created_at": "2020-02-13T01:36:49Z",
      "url": "https://github.com/scrapy/scrapy/pull/3881#discussion_r378608814"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 3881,
      "file_path": "tests/test_loader.py",
      "line": 541,
      "side": "RIGHT",
      "diff_hunk": "@@ -528,7 +538,7 @@ def test_get_output_value_list(self):\n         self.assertEqual(il.get_output_value('name'), ['foo', 'bar'])\n         loaded_item = il.load_item()\n         self.assertIsInstance(loaded_item, self.item_class)\n-        self.assertEqual(loaded_item, dict({'name': ['foo', 'bar']}))\n+        self.assertEqual(self.to_dict(loaded_item), dict({'name': ['foo', 'bar']}))",
      "comment": "Most testing methods The `InitializationTestMixin` have an assertion to check if the produced item matches the expected type: `self.assertIsInstance(loaded_item, self.item_class)`. Would that be enough?",
      "comment_id": 392614655,
      "user": "elacuesta",
      "created_at": "2020-03-14T19:53:24Z",
      "url": "https://github.com/scrapy/scrapy/pull/3881#discussion_r392614655"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 3881,
      "file_path": "scrapy/utils/decorators.py",
      "line": 59,
      "side": "RIGHT",
      "diff_hunk": "@@ -43,3 +43,31 @@ def inthread(func):\n     def wrapped(*a, **kw):\n         return threads.deferToThread(func, *a, **kw)\n     return wrapped\n+\n+\n+try:\n+    from dataclasses import fields as dataclass_fields\n+except ImportError:\n+    pass\n+else:\n+    def subscriptable_dataclass(cls):\n+        \"\"\"\n+        Allow dictionary-like access on dataclass instances\n+        \"\"\"\n+\n+        def __getitem__(self, key):\n+            field_names = [f.name for f in dataclass_fields(self)]",
      "comment": "`if key in [f.name for f in dataclass_fields(self)]` is repeated at least 5 times in the Scrapy codebase, I wonder if we should make a small helper for that. The main reason is that it is going to be useful for people updating their middlewares to support dataclasses.",
      "comment_id": 395127888,
      "user": "kmike",
      "created_at": "2020-03-19T15:47:21Z",
      "url": "https://github.com/scrapy/scrapy/pull/3881#discussion_r395127888"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 3881,
      "file_path": "scrapy/utils/python.py",
      "line": 26,
      "side": "RIGHT",
      "diff_hunk": "@@ -1,19 +1,32 @@\n \"\"\"\n This module contains essential stuff that should've come with Python itself ;)\n \"\"\"\n+import errno\n import gc\n+import inspect\n import os\n import re\n-import inspect\n+import sys\n import weakref\n-import errno\n from functools import partial, wraps\n from itertools import chain\n-import sys\n \n from scrapy.utils.decorators import deprecated\n \n \n+try:\n+    from dataclasses import is_dataclass, asdict as dataclass_asdict\n+except ImportError:\n+    def is_dataclass_instance(_):\n+        return False\n+\n+    def dataclass_asdict(_):\n+        raise ImportError(\"no module named 'dataclasses'\")\n+else:\n+    def is_dataclass_instance(obj):",
      "comment": "Even if so, I think it is better to add tests, because the example in docs is only guaranteed to work with the Python these docs are for, while we support many Pythons, and a backport as well.",
      "comment_id": 395129879,
      "user": "kmike",
      "created_at": "2020-03-19T15:50:05Z",
      "url": "https://github.com/scrapy/scrapy/pull/3881#discussion_r395129879"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 3881,
      "file_path": "scrapy/utils/item.py",
      "line": 28,
      "side": "RIGHT",
      "diff_hunk": "@@ -0,0 +1,69 @@\n+from scrapy.item import BaseItem\n+\n+\n+def is_item_like(obj):\n+    \"\"\"\n+    Returns True if *obj* is considered a Scrapy *item*, False otherwise.\n+\n+    An object is considered an *item* if it is:\n+    - a scrapy.item.BaseItem or dict instance (or any subclass)\n+    - a dataclass object\n+    \"\"\"\n+    return isinstance(obj, (BaseItem, dict)) or _is_dataclass_instance(obj)\n+\n+\n+def _is_dataclass_instance(obj):\n+    \"\"\"\n+    Returns True if *obj* is a dataclass object, False otherwise.\n+    Taken from https://docs.python.org/3/library/dataclasses.html#dataclasses.is_dataclass.\n+    \"\"\"\n+    try:\n+        from dataclasses import is_dataclass\n+    except ImportError:\n+        return False\n+    else:\n+        return is_dataclass(obj) and not isinstance(obj, type)\n+\n+\n+class ItemAdapter:",
      "comment": "A good idea to have such class!\r\n\r\nDo you think we can make it nicer - e.g. use a more dict-like API for it, or even MutableMapping? E.g. why .get_item_field, and not just .get? Why .set_item_field, and not `[\"key\"] = value`? This could allow to reduce usages of as_dict",
      "comment_id": 406851367,
      "user": "kmike",
      "created_at": "2020-04-10T17:08:21Z",
      "url": "https://github.com/scrapy/scrapy/pull/3881#discussion_r406851367"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 3881,
      "file_path": "scrapy/utils/item.py",
      "line": 64,
      "side": "RIGHT",
      "diff_hunk": "@@ -0,0 +1,69 @@\n+from scrapy.item import BaseItem\n+\n+\n+def is_item_like(obj):\n+    \"\"\"\n+    Returns True if *obj* is considered a Scrapy *item*, False otherwise.\n+\n+    An object is considered an *item* if it is:\n+    - a scrapy.item.BaseItem or dict instance (or any subclass)\n+    - a dataclass object\n+    \"\"\"\n+    return isinstance(obj, (BaseItem, dict)) or _is_dataclass_instance(obj)\n+\n+\n+def _is_dataclass_instance(obj):\n+    \"\"\"\n+    Returns True if *obj* is a dataclass object, False otherwise.\n+    Taken from https://docs.python.org/3/library/dataclasses.html#dataclasses.is_dataclass.\n+    \"\"\"\n+    try:\n+        from dataclasses import is_dataclass\n+    except ImportError:\n+        return False\n+    else:\n+        return is_dataclass(obj) and not isinstance(obj, type)\n+\n+\n+class ItemAdapter:\n+    \"\"\"\n+    Wrapper class to interact with items. It provides a common interface for components\n+    such as middlewares and pipelines to extract and set data without having to take\n+    the item's implementation (scrapy.Item, dict, dataclass) into account.\n+    \"\"\"\n+\n+    def __init__(self, item):\n+        if not is_item_like(item):\n+            raise TypeError(\"Expected a valid item, got %s (%r) instead\" % (item, type(item)))\n+        self.item = item\n+\n+    def get_item_field(self, field, default=None):\n+        if _is_dataclass_instance(self.item):\n+            return getattr(self.item, field, default)\n+        else:\n+            return self.item.get(field, default)\n+\n+    def set_item_field(self, field, value):\n+        if _is_dataclass_instance(self.item):\n+            from dataclasses import fields as dataclass_fields\n+            field_names = [f.name for f in dataclass_fields(self.item)]\n+            if field in field_names:\n+                setattr(self.item, field, value)\n+            else:\n+                raise KeyError(\n+                    \"%s does not support field: %s\" % (self.item.__class__.__name__, field))\n+        else:\n+            self.item[field] = value\n+\n+    def as_dict(self):\n+        \"\"\"\n+        Return a class:`dict` instance with the same data as the stored item.\n+        Returns the stored item unaltered if is already a dict object.\n+        \"\"\"\n+        if isinstance(self.item, dict):\n+            return self.item",
      "comment": "Should it be a shallow copy, like in other cases? I think it is important to ensure that the behavior is consistent; it seems currently modifications in as_dict result apply to the original item if it was a dict, but not in other cases.",
      "comment_id": 406851813,
      "user": "kmike",
      "created_at": "2020-04-10T17:09:26Z",
      "url": "https://github.com/scrapy/scrapy/pull/3881#discussion_r406851813"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 3881,
      "file_path": "scrapy/utils/item.py",
      "line": 28,
      "side": "RIGHT",
      "diff_hunk": "@@ -0,0 +1,69 @@\n+from scrapy.item import BaseItem\n+\n+\n+def is_item_like(obj):\n+    \"\"\"\n+    Returns True if *obj* is considered a Scrapy *item*, False otherwise.\n+\n+    An object is considered an *item* if it is:\n+    - a scrapy.item.BaseItem or dict instance (or any subclass)\n+    - a dataclass object\n+    \"\"\"\n+    return isinstance(obj, (BaseItem, dict)) or _is_dataclass_instance(obj)\n+\n+\n+def _is_dataclass_instance(obj):\n+    \"\"\"\n+    Returns True if *obj* is a dataclass object, False otherwise.\n+    Taken from https://docs.python.org/3/library/dataclasses.html#dataclasses.is_dataclass.\n+    \"\"\"\n+    try:\n+        from dataclasses import is_dataclass\n+    except ImportError:\n+        return False\n+    else:\n+        return is_dataclass(obj) and not isinstance(obj, type)\n+\n+\n+class ItemAdapter:",
      "comment": "Thanks for the update @elacuesta! I still wonder if we should implement MutableMapping interface. It requires to implement 5 methods: `__getitem__`, `__setitem__`, `__delitem__`, `__iter__`, `__len__`; after that you get `__contains__`, `keys`, `items`, `values`, `get`, `__eq__`, `__ne__`, `pop`, `popitem`, `clear`, `update`, and `setdefault` automatically.",
      "comment_id": 407180808,
      "user": "kmike",
      "created_at": "2020-04-12T10:50:58Z",
      "url": "https://github.com/scrapy/scrapy/pull/3881#discussion_r407180808"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 3881,
      "file_path": "scrapy/utils/item.py",
      "line": 95,
      "side": "RIGHT",
      "diff_hunk": "@@ -0,0 +1,104 @@\n+from scrapy.item import BaseItem\n+\n+\n+def _is_dataclass_instance(obj):\n+    \"\"\"\n+    Returns True if *obj* is a dataclass object, False otherwise.\n+    Taken from https://docs.python.org/3/library/dataclasses.html#dataclasses.is_dataclass.\n+    \"\"\"\n+    try:\n+        from dataclasses import is_dataclass\n+    except ImportError:\n+        return False\n+    else:\n+        return is_dataclass(obj) and not isinstance(obj, type)\n+\n+\n+def is_item_like(obj):\n+    \"\"\"\n+    Returns True if *obj* is considered a Scrapy *item*, False otherwise.\n+\n+    An object is considered an *item* if it is:\n+    - a scrapy.item.BaseItem or dict instance (or any subclass)\n+    - a dataclass object\n+    \"\"\"\n+    return isinstance(obj, (BaseItem, dict)) or _is_dataclass_instance(obj)\n+\n+\n+class ItemAdapter:\n+    \"\"\"\n+    Wrapper class to interact with items. It provides a common interface for components\n+    such as middlewares and pipelines to extract and set data without having to take\n+    the item's implementation (scrapy.Item, dict, dataclass) into account.\n+    \"\"\"\n+\n+    def __init__(self, item):\n+        if not is_item_like(item):\n+            raise TypeError(\"Expected a valid item, got %r instead: %s\" % (type(item), item))\n+        self.item = item\n+\n+    def __repr__(self):\n+        return \"ItemAdapter for type %s: %r\" % (self.item.__class__.__name__, self.item)\n+\n+    def __contains__(self, field_name):\n+        if _is_dataclass_instance(self.item):\n+            from dataclasses import fields\n+            return field_name in (f.name for f in fields(self.item))\n+        return field_name in self.item\n+\n+    def __getitem__(self, field_name):\n+        if _is_dataclass_instance(self.item):\n+            if field_name in self:\n+                return getattr(self.item, field_name)\n+            raise KeyError(field_name)\n+        return self.item[field_name]\n+\n+    def __setitem__(self, field_name, value):\n+        if _is_dataclass_instance(self.item):\n+            if field_name in self:\n+                setattr(self.item, field_name, value)\n+            else:\n+                raise KeyError(\n+                    \"%s does not support field: %s\" % (self.item.__class__.__name__, field_name))\n+        else:\n+            self.item[field_name] = value\n+\n+    def get(self, field_name, default=None):\n+        if _is_dataclass_instance(self.item):\n+            return getattr(self.item, field_name, default)\n+        return self.item.get(field_name, default)\n+\n+    def get_field(self, field_name):\n+        \"\"\"\n+        Returns the appropriate class:`scrapy.item.Field` object if the wrapped item\n+        is a BaseItem object, None otherwise.\n+        \"\"\"\n+        if isinstance(self.item, BaseItem):\n+            return self.item.fields.get(field_name)\n+        return None\n+\n+    def asdict(self):\n+        \"\"\"\n+        Return a class:`dict` instance with the same data as the wrapped item.\n+        Returns a shallow copy of the wrapped item if it is already a dict object.\n+        \"\"\"\n+        if _is_dataclass_instance(self.item):\n+            from dataclasses import asdict\n+            return asdict(self.item)\n+        elif isinstance(self.item, dict):\n+            return self.item.copy()\n+        elif isinstance(self.item, BaseItem):\n+            return dict(self.item)\n+\n+    def field_names(self):\n+        \"\"\"\n+        Returns a generator with the names of the item's fields",
      "comment": "I'd prefer keys method, as key view is more useful than a generator. For example, for dict.keys() `__repr__` shows actual keys. List is also ok. I can't imagine a case where having all item keys in memory (as opposed to making them on-by-one in  a generator) would cause memory issues.",
      "comment_id": 407181212,
      "user": "kmike",
      "created_at": "2020-04-12T10:54:46Z",
      "url": "https://github.com/scrapy/scrapy/pull/3881#discussion_r407181212"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 3881,
      "file_path": "scrapy/utils/item.py",
      "line": 28,
      "side": "RIGHT",
      "diff_hunk": "@@ -0,0 +1,69 @@\n+from scrapy.item import BaseItem\n+\n+\n+def is_item_like(obj):\n+    \"\"\"\n+    Returns True if *obj* is considered a Scrapy *item*, False otherwise.\n+\n+    An object is considered an *item* if it is:\n+    - a scrapy.item.BaseItem or dict instance (or any subclass)\n+    - a dataclass object\n+    \"\"\"\n+    return isinstance(obj, (BaseItem, dict)) or _is_dataclass_instance(obj)\n+\n+\n+def _is_dataclass_instance(obj):\n+    \"\"\"\n+    Returns True if *obj* is a dataclass object, False otherwise.\n+    Taken from https://docs.python.org/3/library/dataclasses.html#dataclasses.is_dataclass.\n+    \"\"\"\n+    try:\n+        from dataclasses import is_dataclass\n+    except ImportError:\n+        return False\n+    else:\n+        return is_dataclass(obj) and not isinstance(obj, type)\n+\n+\n+class ItemAdapter:",
      "comment": "And one more thing: do you see any issues with allowing to yield ItemAdaptor instances as items? Do you see any use case for that?",
      "comment_id": 407181711,
      "user": "kmike",
      "created_at": "2020-04-12T10:59:46Z",
      "url": "https://github.com/scrapy/scrapy/pull/3881#discussion_r407181711"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 3881,
      "file_path": "scrapy/utils/item.py",
      "line": 95,
      "side": "RIGHT",
      "diff_hunk": "@@ -0,0 +1,104 @@\n+from scrapy.item import BaseItem\n+\n+\n+def _is_dataclass_instance(obj):\n+    \"\"\"\n+    Returns True if *obj* is a dataclass object, False otherwise.\n+    Taken from https://docs.python.org/3/library/dataclasses.html#dataclasses.is_dataclass.\n+    \"\"\"\n+    try:\n+        from dataclasses import is_dataclass\n+    except ImportError:\n+        return False\n+    else:\n+        return is_dataclass(obj) and not isinstance(obj, type)\n+\n+\n+def is_item_like(obj):\n+    \"\"\"\n+    Returns True if *obj* is considered a Scrapy *item*, False otherwise.\n+\n+    An object is considered an *item* if it is:\n+    - a scrapy.item.BaseItem or dict instance (or any subclass)\n+    - a dataclass object\n+    \"\"\"\n+    return isinstance(obj, (BaseItem, dict)) or _is_dataclass_instance(obj)\n+\n+\n+class ItemAdapter:\n+    \"\"\"\n+    Wrapper class to interact with items. It provides a common interface for components\n+    such as middlewares and pipelines to extract and set data without having to take\n+    the item's implementation (scrapy.Item, dict, dataclass) into account.\n+    \"\"\"\n+\n+    def __init__(self, item):\n+        if not is_item_like(item):\n+            raise TypeError(\"Expected a valid item, got %r instead: %s\" % (type(item), item))\n+        self.item = item\n+\n+    def __repr__(self):\n+        return \"ItemAdapter for type %s: %r\" % (self.item.__class__.__name__, self.item)\n+\n+    def __contains__(self, field_name):\n+        if _is_dataclass_instance(self.item):\n+            from dataclasses import fields\n+            return field_name in (f.name for f in fields(self.item))\n+        return field_name in self.item\n+\n+    def __getitem__(self, field_name):\n+        if _is_dataclass_instance(self.item):\n+            if field_name in self:\n+                return getattr(self.item, field_name)\n+            raise KeyError(field_name)\n+        return self.item[field_name]\n+\n+    def __setitem__(self, field_name, value):\n+        if _is_dataclass_instance(self.item):\n+            if field_name in self:\n+                setattr(self.item, field_name, value)\n+            else:\n+                raise KeyError(\n+                    \"%s does not support field: %s\" % (self.item.__class__.__name__, field_name))\n+        else:\n+            self.item[field_name] = value\n+\n+    def get(self, field_name, default=None):\n+        if _is_dataclass_instance(self.item):\n+            return getattr(self.item, field_name, default)\n+        return self.item.get(field_name, default)\n+\n+    def get_field(self, field_name):\n+        \"\"\"\n+        Returns the appropriate class:`scrapy.item.Field` object if the wrapped item\n+        is a BaseItem object, None otherwise.\n+        \"\"\"\n+        if isinstance(self.item, BaseItem):\n+            return self.item.fields.get(field_name)\n+        return None\n+\n+    def asdict(self):\n+        \"\"\"\n+        Return a class:`dict` instance with the same data as the wrapped item.\n+        Returns a shallow copy of the wrapped item if it is already a dict object.\n+        \"\"\"\n+        if _is_dataclass_instance(self.item):\n+            from dataclasses import asdict\n+            return asdict(self.item)\n+        elif isinstance(self.item, dict):\n+            return self.item.copy()\n+        elif isinstance(self.item, BaseItem):\n+            return dict(self.item)\n+\n+    def field_names(self):\n+        \"\"\"\n+        Returns a generator with the names of the item's fields",
      "comment": "Makes sense, I'll make it return a list to keep the return type consistent (IIRC there is no way to create `dict_keys` objects in user code).\r\nRegarding the name, I think it'd be better to keep it as it is now, to make it clear that it returns *all* field names. This method is only used in the `scrapy.exporters.BaseItemExporter` class, where sometimes there is the need to know all the defined fields for a given item. In `BaseItem`-based items, `\u00cctem.keys()` and `Item.fields.keys()` can be different if a field is defined but unset:\r\n\r\n```python\r\nIn [1]: from scrapy.item import Item, Field\r\n   ...: class TestItem(Item):\r\n   ...:     name = Field()\r\n   ...:     value = Field()\r\n   ...: i = TestItem(name=\"asdf\")\r\n   ...: print(i.keys())\r\n   ...: print(i.fields.keys())\r\n   ...:\r\ndict_keys(['name'])\r\ndict_keys(['name', 'value'])\r\n```\r\n\r\n(Edit) Interesting, I just found there might be a way to create [view objects](https://docs.python.org/3/library/collections.abc.html#collections.abc.KeysView). Not sure we need them though.",
      "comment_id": 407233847,
      "user": "elacuesta",
      "created_at": "2020-04-12T18:14:09Z",
      "url": "https://github.com/scrapy/scrapy/pull/3881#discussion_r407233847"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 3881,
      "file_path": "scrapy/utils/item.py",
      "line": 28,
      "side": "RIGHT",
      "diff_hunk": "@@ -0,0 +1,69 @@\n+from scrapy.item import BaseItem\n+\n+\n+def is_item_like(obj):\n+    \"\"\"\n+    Returns True if *obj* is considered a Scrapy *item*, False otherwise.\n+\n+    An object is considered an *item* if it is:\n+    - a scrapy.item.BaseItem or dict instance (or any subclass)\n+    - a dataclass object\n+    \"\"\"\n+    return isinstance(obj, (BaseItem, dict)) or _is_dataclass_instance(obj)\n+\n+\n+def _is_dataclass_instance(obj):\n+    \"\"\"\n+    Returns True if *obj* is a dataclass object, False otherwise.\n+    Taken from https://docs.python.org/3/library/dataclasses.html#dataclasses.is_dataclass.\n+    \"\"\"\n+    try:\n+        from dataclasses import is_dataclass\n+    except ImportError:\n+        return False\n+    else:\n+        return is_dataclass(obj) and not isinstance(obj, type)\n+\n+\n+class ItemAdapter:",
      "comment": "Implemented the `MutableMapping` interface, that simplified a few things (no need for `asdict` and `__contains__` anymore, for instance) \ud83e\udd73 \r\nJust as a note, I see no other way to implement `__delitem__` but to use [`delattr`](https://docs.python.org/3/library/functions.html#delattr), which seems to leave `dataclass` objects in an unstable state, but this also happens if we define our own `__init__` method:\r\n\r\n```python\r\n>>> from dataclasses import dataclass, fields, asdict\r\n>>> @dataclass(init=False)\r\n... class TestItem:\r\n...     name: str\r\n...     value: int\r\n...     def __init__(self, name):\r\n...         self.name = name\r\n...\r\n>>> i = TestItem(name=\"asdf\")\r\n>>>\r\n>>> [f.name for f in fields(i)]  # all good here\r\n['name', 'value']\r\n>>> i.name\r\n'asdf'\r\n>>> i.value  # expected to raise AttributeError\r\nTraceback (most recent call last):\r\n  File \"<stdin>\", line 1, in <module>\r\nAttributeError: 'TestItem' object has no attribute 'value'\r\n>>>\r\n>>> i  # __repr__ breaks\r\nTraceback (most recent call last):\r\n  File \"<stdin>\", line 1, in <module>\r\n  File \"/Library/Frameworks/Python.framework/Versions/3.7/lib/python3.7/dataclasses.py\", line 357, in wrapper\r\n    result = user_function(self)\r\n  File \"<string>\", line 2, in __repr__\r\nAttributeError: 'TestItem' object has no attribute 'value'\r\n>>>\r\n>>> asdict(i)  # this breaks too\r\nTraceback (most recent call last):\r\n  File \"<stdin>\", line 1, in <module>\r\n  File \"/Library/Frameworks/Python.framework/Versions/3.7/lib/python3.7/dataclasses.py\", line 1044, in asdict\r\n    return _asdict_inner(obj, dict_factory)\r\n  File \"/Library/Frameworks/Python.framework/Versions/3.7/lib/python3.7/dataclasses.py\", line 1051, in _asdict_inner\r\n    value = _asdict_inner(getattr(obj, f.name), dict_factory)\r\nAttributeError: 'TestItem' object has no attribute 'value'\r\n>>>\r\n```",
      "comment_id": 407255405,
      "user": "elacuesta",
      "created_at": "2020-04-12T21:40:17Z",
      "url": "https://github.com/scrapy/scrapy/pull/3881#discussion_r407255405"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 3881,
      "file_path": "scrapy/utils/item.py",
      "line": 28,
      "side": "RIGHT",
      "diff_hunk": "@@ -0,0 +1,69 @@\n+from scrapy.item import BaseItem\n+\n+\n+def is_item_like(obj):\n+    \"\"\"\n+    Returns True if *obj* is considered a Scrapy *item*, False otherwise.\n+\n+    An object is considered an *item* if it is:\n+    - a scrapy.item.BaseItem or dict instance (or any subclass)\n+    - a dataclass object\n+    \"\"\"\n+    return isinstance(obj, (BaseItem, dict)) or _is_dataclass_instance(obj)\n+\n+\n+def _is_dataclass_instance(obj):\n+    \"\"\"\n+    Returns True if *obj* is a dataclass object, False otherwise.\n+    Taken from https://docs.python.org/3/library/dataclasses.html#dataclasses.is_dataclass.\n+    \"\"\"\n+    try:\n+        from dataclasses import is_dataclass\n+    except ImportError:\n+        return False\n+    else:\n+        return is_dataclass(obj) and not isinstance(obj, type)\n+\n+\n+class ItemAdapter:",
      "comment": "Regarding allowing `ItemAdapter` objects as items, I _think_ there should be no problems, it should be only a matter of allowing it in `is_item_like`.\r\nIf we want to avoid the extra wrapping layer that it would create, we could add some `classmethod` to the class in order to return the object itself if it's already an adapter (I did some experiments with `__new__` but that didn't work). Or perhaps we don't really care about that. What do you think?",
      "comment_id": 407256467,
      "user": "elacuesta",
      "created_at": "2020-04-12T21:50:51Z",
      "url": "https://github.com/scrapy/scrapy/pull/3881#discussion_r407256467"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 3881,
      "file_path": "scrapy/utils/item.py",
      "line": 28,
      "side": "RIGHT",
      "diff_hunk": "@@ -0,0 +1,69 @@\n+from scrapy.item import BaseItem\n+\n+\n+def is_item_like(obj):\n+    \"\"\"\n+    Returns True if *obj* is considered a Scrapy *item*, False otherwise.\n+\n+    An object is considered an *item* if it is:\n+    - a scrapy.item.BaseItem or dict instance (or any subclass)\n+    - a dataclass object\n+    \"\"\"\n+    return isinstance(obj, (BaseItem, dict)) or _is_dataclass_instance(obj)\n+\n+\n+def _is_dataclass_instance(obj):\n+    \"\"\"\n+    Returns True if *obj* is a dataclass object, False otherwise.\n+    Taken from https://docs.python.org/3/library/dataclasses.html#dataclasses.is_dataclass.\n+    \"\"\"\n+    try:\n+        from dataclasses import is_dataclass\n+    except ImportError:\n+        return False\n+    else:\n+        return is_dataclass(obj) and not isinstance(obj, type)\n+\n+\n+class ItemAdapter:",
      "comment": "> And one more thing: do you see any issues with allowing to yield ItemAdaptor instances as items? Do you see any use case for that?\r\n\r\nI think we should consider preventing this, either by automatically _unwrapping_ items before moving them forward, or by raising an exception.\r\n\r\nAt the moment, if a user yields an item of a certain type from a spider callback, that user can trust that the item will be the same object the user receives in any custom middleware or pipelines. We lose this if third-party middlewares are allowed to yield these adapter objects and not just use them.\r\n\r\nI am not completely against it, but if we want to go this way, it may be better to just convert any item into an Item instance.",
      "comment_id": 408735645,
      "user": "Gallaecio",
      "created_at": "2020-04-15T10:19:06Z",
      "url": "https://github.com/scrapy/scrapy/pull/3881#discussion_r408735645"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 3881,
      "file_path": "scrapy/utils/item.py",
      "line": 95,
      "side": "RIGHT",
      "diff_hunk": "@@ -0,0 +1,104 @@\n+from scrapy.item import BaseItem\n+\n+\n+def _is_dataclass_instance(obj):\n+    \"\"\"\n+    Returns True if *obj* is a dataclass object, False otherwise.\n+    Taken from https://docs.python.org/3/library/dataclasses.html#dataclasses.is_dataclass.\n+    \"\"\"\n+    try:\n+        from dataclasses import is_dataclass\n+    except ImportError:\n+        return False\n+    else:\n+        return is_dataclass(obj) and not isinstance(obj, type)\n+\n+\n+def is_item_like(obj):\n+    \"\"\"\n+    Returns True if *obj* is considered a Scrapy *item*, False otherwise.\n+\n+    An object is considered an *item* if it is:\n+    - a scrapy.item.BaseItem or dict instance (or any subclass)\n+    - a dataclass object\n+    \"\"\"\n+    return isinstance(obj, (BaseItem, dict)) or _is_dataclass_instance(obj)\n+\n+\n+class ItemAdapter:\n+    \"\"\"\n+    Wrapper class to interact with items. It provides a common interface for components\n+    such as middlewares and pipelines to extract and set data without having to take\n+    the item's implementation (scrapy.Item, dict, dataclass) into account.\n+    \"\"\"\n+\n+    def __init__(self, item):\n+        if not is_item_like(item):\n+            raise TypeError(\"Expected a valid item, got %r instead: %s\" % (type(item), item))\n+        self.item = item\n+\n+    def __repr__(self):\n+        return \"ItemAdapter for type %s: %r\" % (self.item.__class__.__name__, self.item)\n+\n+    def __contains__(self, field_name):\n+        if _is_dataclass_instance(self.item):\n+            from dataclasses import fields\n+            return field_name in (f.name for f in fields(self.item))\n+        return field_name in self.item\n+\n+    def __getitem__(self, field_name):\n+        if _is_dataclass_instance(self.item):\n+            if field_name in self:\n+                return getattr(self.item, field_name)\n+            raise KeyError(field_name)\n+        return self.item[field_name]\n+\n+    def __setitem__(self, field_name, value):\n+        if _is_dataclass_instance(self.item):\n+            if field_name in self:\n+                setattr(self.item, field_name, value)\n+            else:\n+                raise KeyError(\n+                    \"%s does not support field: %s\" % (self.item.__class__.__name__, field_name))\n+        else:\n+            self.item[field_name] = value\n+\n+    def get(self, field_name, default=None):\n+        if _is_dataclass_instance(self.item):\n+            return getattr(self.item, field_name, default)\n+        return self.item.get(field_name, default)\n+\n+    def get_field(self, field_name):\n+        \"\"\"\n+        Returns the appropriate class:`scrapy.item.Field` object if the wrapped item\n+        is a BaseItem object, None otherwise.\n+        \"\"\"\n+        if isinstance(self.item, BaseItem):\n+            return self.item.fields.get(field_name)\n+        return None\n+\n+    def asdict(self):\n+        \"\"\"\n+        Return a class:`dict` instance with the same data as the wrapped item.\n+        Returns a shallow copy of the wrapped item if it is already a dict object.\n+        \"\"\"\n+        if _is_dataclass_instance(self.item):\n+            from dataclasses import asdict\n+            return asdict(self.item)\n+        elif isinstance(self.item, dict):\n+            return self.item.copy()\n+        elif isinstance(self.item, BaseItem):\n+            return dict(self.item)\n+\n+    def field_names(self):\n+        \"\"\"\n+        Returns a generator with the names of the item's fields",
      "comment": "I _think_ you should be getting `.keys()` method for free if you implement MutableMapping, but I haven't actually checked it.",
      "comment_id": 409037028,
      "user": "kmike",
      "created_at": "2020-04-15T18:10:27Z",
      "url": "https://github.com/scrapy/scrapy/pull/3881#discussion_r409037028"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 3881,
      "file_path": "scrapy/utils/item.py",
      "line": 95,
      "side": "RIGHT",
      "diff_hunk": "@@ -0,0 +1,104 @@\n+from scrapy.item import BaseItem\n+\n+\n+def _is_dataclass_instance(obj):\n+    \"\"\"\n+    Returns True if *obj* is a dataclass object, False otherwise.\n+    Taken from https://docs.python.org/3/library/dataclasses.html#dataclasses.is_dataclass.\n+    \"\"\"\n+    try:\n+        from dataclasses import is_dataclass\n+    except ImportError:\n+        return False\n+    else:\n+        return is_dataclass(obj) and not isinstance(obj, type)\n+\n+\n+def is_item_like(obj):\n+    \"\"\"\n+    Returns True if *obj* is considered a Scrapy *item*, False otherwise.\n+\n+    An object is considered an *item* if it is:\n+    - a scrapy.item.BaseItem or dict instance (or any subclass)\n+    - a dataclass object\n+    \"\"\"\n+    return isinstance(obj, (BaseItem, dict)) or _is_dataclass_instance(obj)\n+\n+\n+class ItemAdapter:\n+    \"\"\"\n+    Wrapper class to interact with items. It provides a common interface for components\n+    such as middlewares and pipelines to extract and set data without having to take\n+    the item's implementation (scrapy.Item, dict, dataclass) into account.\n+    \"\"\"\n+\n+    def __init__(self, item):\n+        if not is_item_like(item):\n+            raise TypeError(\"Expected a valid item, got %r instead: %s\" % (type(item), item))\n+        self.item = item\n+\n+    def __repr__(self):\n+        return \"ItemAdapter for type %s: %r\" % (self.item.__class__.__name__, self.item)\n+\n+    def __contains__(self, field_name):\n+        if _is_dataclass_instance(self.item):\n+            from dataclasses import fields\n+            return field_name in (f.name for f in fields(self.item))\n+        return field_name in self.item\n+\n+    def __getitem__(self, field_name):\n+        if _is_dataclass_instance(self.item):\n+            if field_name in self:\n+                return getattr(self.item, field_name)\n+            raise KeyError(field_name)\n+        return self.item[field_name]\n+\n+    def __setitem__(self, field_name, value):\n+        if _is_dataclass_instance(self.item):\n+            if field_name in self:\n+                setattr(self.item, field_name, value)\n+            else:\n+                raise KeyError(\n+                    \"%s does not support field: %s\" % (self.item.__class__.__name__, field_name))\n+        else:\n+            self.item[field_name] = value\n+\n+    def get(self, field_name, default=None):\n+        if _is_dataclass_instance(self.item):\n+            return getattr(self.item, field_name, default)\n+        return self.item.get(field_name, default)\n+\n+    def get_field(self, field_name):\n+        \"\"\"\n+        Returns the appropriate class:`scrapy.item.Field` object if the wrapped item\n+        is a BaseItem object, None otherwise.\n+        \"\"\"\n+        if isinstance(self.item, BaseItem):\n+            return self.item.fields.get(field_name)\n+        return None\n+\n+    def asdict(self):\n+        \"\"\"\n+        Return a class:`dict` instance with the same data as the wrapped item.\n+        Returns a shallow copy of the wrapped item if it is already a dict object.\n+        \"\"\"\n+        if _is_dataclass_instance(self.item):\n+            from dataclasses import asdict\n+            return asdict(self.item)\n+        elif isinstance(self.item, dict):\n+            return self.item.copy()\n+        elif isinstance(self.item, BaseItem):\n+            return dict(self.item)\n+\n+    def field_names(self):\n+        \"\"\"\n+        Returns a generator with the names of the item's fields",
      "comment": "Nice, indeed:\r\n```python\r\nIn [1]: from scrapy.utils.item import ItemAdapter                                                                                                                                                                                             \r\n\r\nIn [2]: ItemAdapter({}).keys()                                                                                                                                                                                                                \r\nOut[2]: KeysView(ItemAdapter for type dict: {})\r\n```\r\nI think the `field_names` function might still be necessary though, since the current exporter implementation needs all fields when exporting empty fields, and `keys` only returns those which are set:\r\n```python\r\nIn [10]: from scrapy.item import Item, Field \r\n    ...: from scrapy.utils.item import ItemAdapter \r\n    ...: class TestItem(Item): \r\n    ...:     name = Field() \r\n    ...:     value = Field() \r\n    ...: i = TestItem(name=\"asdf\") \r\n    ...: a = ItemAdapter(i) \r\n    ...: print(i.keys()) \r\n    ...: print(i.fields.keys()) \r\n    ...: print(list(a.keys()))                                                                                                                                                                                                                \r\ndict_keys(['name'])\r\ndict_keys(['name', 'value'])\r\n['name']\r\n```",
      "comment_id": 409054573,
      "user": "elacuesta",
      "created_at": "2020-04-15T18:40:25Z",
      "url": "https://github.com/scrapy/scrapy/pull/3881#discussion_r409054573"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 3881,
      "file_path": "scrapy/utils/item.py",
      "line": 8,
      "side": "RIGHT",
      "diff_hunk": "@@ -0,0 +1,104 @@\n+from collections.abc import MutableMapping\n+\n+from scrapy.item import BaseItem\n+\n+\n+def _is_dataclass_instance(obj):\n+    \"\"\"\n+    Returns True if *obj* is a dataclass object, False otherwise.",
      "comment": "a nitpick: as per [pep 257](https://www.python.org/dev/peps/pep-0257/), it should be \"Return ...\", not \"Returns ...\":\r\n\r\n> The docstring is a phrase ending in a period. It prescribes the function or method's effect as a command (\"Do this\", \"Return that\"), not as a description; e.g. don't write \"Returns the pathname ...\".",
      "comment_id": 409509298,
      "user": "kmike",
      "created_at": "2020-04-16T12:17:26Z",
      "url": "https://github.com/scrapy/scrapy/pull/3881#discussion_r409509298"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 3881,
      "file_path": "scrapy/utils/item.py",
      "line": 28,
      "side": "RIGHT",
      "diff_hunk": "@@ -0,0 +1,69 @@\n+from scrapy.item import BaseItem\n+\n+\n+def is_item_like(obj):\n+    \"\"\"\n+    Returns True if *obj* is considered a Scrapy *item*, False otherwise.\n+\n+    An object is considered an *item* if it is:\n+    - a scrapy.item.BaseItem or dict instance (or any subclass)\n+    - a dataclass object\n+    \"\"\"\n+    return isinstance(obj, (BaseItem, dict)) or _is_dataclass_instance(obj)\n+\n+\n+def _is_dataclass_instance(obj):\n+    \"\"\"\n+    Returns True if *obj* is a dataclass object, False otherwise.\n+    Taken from https://docs.python.org/3/library/dataclasses.html#dataclasses.is_dataclass.\n+    \"\"\"\n+    try:\n+        from dataclasses import is_dataclass\n+    except ImportError:\n+        return False\n+    else:\n+        return is_dataclass(obj) and not isinstance(obj, type)\n+\n+\n+class ItemAdapter:",
      "comment": "As for delitem, I think that's fine to raise NonImplementedError - but it seems you already implemented it :)",
      "comment_id": 409523222,
      "user": "kmike",
      "created_at": "2020-04-16T12:40:53Z",
      "url": "https://github.com/scrapy/scrapy/pull/3881#discussion_r409523222"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 3881,
      "file_path": "scrapy/utils/item.py",
      "line": 28,
      "side": "RIGHT",
      "diff_hunk": "@@ -0,0 +1,69 @@\n+from scrapy.item import BaseItem\n+\n+\n+def is_item_like(obj):\n+    \"\"\"\n+    Returns True if *obj* is considered a Scrapy *item*, False otherwise.\n+\n+    An object is considered an *item* if it is:\n+    - a scrapy.item.BaseItem or dict instance (or any subclass)\n+    - a dataclass object\n+    \"\"\"\n+    return isinstance(obj, (BaseItem, dict)) or _is_dataclass_instance(obj)\n+\n+\n+def _is_dataclass_instance(obj):\n+    \"\"\"\n+    Returns True if *obj* is a dataclass object, False otherwise.\n+    Taken from https://docs.python.org/3/library/dataclasses.html#dataclasses.is_dataclass.\n+    \"\"\"\n+    try:\n+        from dataclasses import is_dataclass\n+    except ImportError:\n+        return False\n+    else:\n+        return is_dataclass(obj) and not isinstance(obj, type)\n+\n+\n+class ItemAdapter:",
      "comment": "Alright, now I think we should not allow yielding adapters. It reminds me of the question of allowing to yield item loaders, the implementation should not be super hard but it doesn't add much IMHO and it's probably not necessary.\r\nRegarding `__delitem__`, I didn't think about `NonImplementedError` :thinking: \r\nSounds as reasonable as using `delattr` to me, I don't have a strong opinion on the subject.",
      "comment_id": 409623150,
      "user": "elacuesta",
      "created_at": "2020-04-16T14:55:17Z",
      "url": "https://github.com/scrapy/scrapy/pull/3881#discussion_r409623150"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 3881,
      "file_path": "scrapy/utils/item.py",
      "line": 30,
      "side": "RIGHT",
      "diff_hunk": "@@ -0,0 +1,104 @@\n+from collections.abc import MutableMapping\n+\n+from scrapy.item import BaseItem\n+\n+\n+def _is_dataclass_instance(obj):\n+    \"\"\"\n+    Return True if *obj* is a dataclass object, False otherwise.\n+    Taken from https://docs.python.org/3/library/dataclasses.html#dataclasses.is_dataclass.\n+    \"\"\"\n+    try:\n+        from dataclasses import is_dataclass\n+    except ImportError:\n+        return False\n+    else:\n+        return is_dataclass(obj) and not isinstance(obj, type)\n+\n+\n+def is_item_like(obj):\n+    \"\"\"\n+    Return True if *obj* is considered a Scrapy *item*, False otherwise.\n+\n+    An object is considered an *item* if it is:\n+    - a scrapy.item.BaseItem or dict instance (or any subclass)\n+    - a dataclass object\n+    \"\"\"\n+    return isinstance(obj, (BaseItem, dict)) or _is_dataclass_instance(obj)\n+\n+\n+class ItemAdapter(MutableMapping):",
      "comment": "I don't want to derail the PR, but I'm wondering now if we should create a separate package with ItemAdapter. A package which provides  an uniform dict-like access to various sources of data: scrapy Items, dicts, dataclasses, probably attr.s.\r\n\r\nWhere this idea comes from: scrapy.loader is being separated to a different package, and after this PR scrapy.loader depends on ItemAdapter.",
      "comment_id": 410422016,
      "user": "kmike",
      "created_at": "2020-04-17T19:17:41Z",
      "url": "https://github.com/scrapy/scrapy/pull/3881#discussion_r410422016"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 3881,
      "file_path": "scrapy/utils/item.py",
      "line": 30,
      "side": "RIGHT",
      "diff_hunk": "@@ -0,0 +1,104 @@\n+from collections.abc import MutableMapping\n+\n+from scrapy.item import BaseItem\n+\n+\n+def _is_dataclass_instance(obj):\n+    \"\"\"\n+    Return True if *obj* is a dataclass object, False otherwise.\n+    Taken from https://docs.python.org/3/library/dataclasses.html#dataclasses.is_dataclass.\n+    \"\"\"\n+    try:\n+        from dataclasses import is_dataclass\n+    except ImportError:\n+        return False\n+    else:\n+        return is_dataclass(obj) and not isinstance(obj, type)\n+\n+\n+def is_item_like(obj):\n+    \"\"\"\n+    Return True if *obj* is considered a Scrapy *item*, False otherwise.\n+\n+    An object is considered an *item* if it is:\n+    - a scrapy.item.BaseItem or dict instance (or any subclass)\n+    - a dataclass object\n+    \"\"\"\n+    return isinstance(obj, (BaseItem, dict)) or _is_dataclass_instance(obj)\n+\n+\n+class ItemAdapter(MutableMapping):",
      "comment": "@kmike That makes sense to me :+1:  My idea was to start working on `attrs` support once we got the `ItemAdapter` class merged.\r\nI can create a repo under my account and start working on it, we can transfer it later. Does that sound good?",
      "comment_id": 410463830,
      "user": "elacuesta",
      "created_at": "2020-04-17T20:52:16Z",
      "url": "https://github.com/scrapy/scrapy/pull/3881#discussion_r410463830"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 3881,
      "file_path": "scrapy/utils/item.py",
      "line": 30,
      "side": "RIGHT",
      "diff_hunk": "@@ -0,0 +1,104 @@\n+from collections.abc import MutableMapping\n+\n+from scrapy.item import BaseItem\n+\n+\n+def _is_dataclass_instance(obj):\n+    \"\"\"\n+    Return True if *obj* is a dataclass object, False otherwise.\n+    Taken from https://docs.python.org/3/library/dataclasses.html#dataclasses.is_dataclass.\n+    \"\"\"\n+    try:\n+        from dataclasses import is_dataclass\n+    except ImportError:\n+        return False\n+    else:\n+        return is_dataclass(obj) and not isinstance(obj, type)\n+\n+\n+def is_item_like(obj):\n+    \"\"\"\n+    Return True if *obj* is considered a Scrapy *item*, False otherwise.\n+\n+    An object is considered an *item* if it is:\n+    - a scrapy.item.BaseItem or dict instance (or any subclass)\n+    - a dataclass object\n+    \"\"\"\n+    return isinstance(obj, (BaseItem, dict)) or _is_dataclass_instance(obj)\n+\n+\n+class ItemAdapter(MutableMapping):",
      "comment": "Working on this at https://github.com/elacuesta/scrapy-itemadapter",
      "comment_id": 413511534,
      "user": "elacuesta",
      "created_at": "2020-04-23T05:05:29Z",
      "url": "https://github.com/scrapy/scrapy/pull/3881#discussion_r413511534"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 3881,
      "file_path": "scrapy/utils/item.py",
      "line": 30,
      "side": "RIGHT",
      "diff_hunk": "@@ -0,0 +1,104 @@\n+from collections.abc import MutableMapping\n+\n+from scrapy.item import BaseItem\n+\n+\n+def _is_dataclass_instance(obj):\n+    \"\"\"\n+    Return True if *obj* is a dataclass object, False otherwise.\n+    Taken from https://docs.python.org/3/library/dataclasses.html#dataclasses.is_dataclass.\n+    \"\"\"\n+    try:\n+        from dataclasses import is_dataclass\n+    except ImportError:\n+        return False\n+    else:\n+        return is_dataclass(obj) and not isinstance(obj, type)\n+\n+\n+def is_item_like(obj):\n+    \"\"\"\n+    Return True if *obj* is considered a Scrapy *item*, False otherwise.\n+\n+    An object is considered an *item* if it is:\n+    - a scrapy.item.BaseItem or dict instance (or any subclass)\n+    - a dataclass object\n+    \"\"\"\n+    return isinstance(obj, (BaseItem, dict)) or _is_dataclass_instance(obj)\n+\n+\n+class ItemAdapter(MutableMapping):",
      "comment": "@Gallaecio @kmike `itemadapter 0.0.1` is on PyPI, I can start updating this PR. One thing I think we might want to discuss is whether or not we want to import and use directly from the package, or maybe do something similar to what we do with Parsel. An argument in favour of this would be restricting the usage to `Item` objects in Scrapy, since I don't think we should do that in `itemadapter` (because, for the purposes of the library, any `MutableMapping` does work). What do you think?",
      "comment_id": 415754495,
      "user": "elacuesta",
      "created_at": "2020-04-27T12:04:41Z",
      "url": "https://github.com/scrapy/scrapy/pull/3881#discussion_r415754495"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 3881,
      "file_path": "scrapy/utils/item.py",
      "line": 30,
      "side": "RIGHT",
      "diff_hunk": "@@ -0,0 +1,104 @@\n+from collections.abc import MutableMapping\n+\n+from scrapy.item import BaseItem\n+\n+\n+def _is_dataclass_instance(obj):\n+    \"\"\"\n+    Return True if *obj* is a dataclass object, False otherwise.\n+    Taken from https://docs.python.org/3/library/dataclasses.html#dataclasses.is_dataclass.\n+    \"\"\"\n+    try:\n+        from dataclasses import is_dataclass\n+    except ImportError:\n+        return False\n+    else:\n+        return is_dataclass(obj) and not isinstance(obj, type)\n+\n+\n+def is_item_like(obj):\n+    \"\"\"\n+    Return True if *obj* is considered a Scrapy *item*, False otherwise.\n+\n+    An object is considered an *item* if it is:\n+    - a scrapy.item.BaseItem or dict instance (or any subclass)\n+    - a dataclass object\n+    \"\"\"\n+    return isinstance(obj, (BaseItem, dict)) or _is_dataclass_instance(obj)\n+\n+\n+class ItemAdapter(MutableMapping):",
      "comment": "My main concern is the handling of `{'fields': '\u2026'}` in non-`Item` objects. I\u2019m not sure it is safe to assume that if the attribute exists we can treat the object as a Scrapy `Item`. Best case scenario: a puzzling `TypeError` exception is raised. Worst case scenario: things work in unintended ways.",
      "comment_id": 415834019,
      "user": "Gallaecio",
      "created_at": "2020-04-27T13:55:58Z",
      "url": "https://github.com/scrapy/scrapy/pull/3881#discussion_r415834019"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 3881,
      "file_path": "scrapy/utils/item.py",
      "line": 30,
      "side": "RIGHT",
      "diff_hunk": "@@ -0,0 +1,104 @@\n+from collections.abc import MutableMapping\n+\n+from scrapy.item import BaseItem\n+\n+\n+def _is_dataclass_instance(obj):\n+    \"\"\"\n+    Return True if *obj* is a dataclass object, False otherwise.\n+    Taken from https://docs.python.org/3/library/dataclasses.html#dataclasses.is_dataclass.\n+    \"\"\"\n+    try:\n+        from dataclasses import is_dataclass\n+    except ImportError:\n+        return False\n+    else:\n+        return is_dataclass(obj) and not isinstance(obj, type)\n+\n+\n+def is_item_like(obj):\n+    \"\"\"\n+    Return True if *obj* is considered a Scrapy *item*, False otherwise.\n+\n+    An object is considered an *item* if it is:\n+    - a scrapy.item.BaseItem or dict instance (or any subclass)\n+    - a dataclass object\n+    \"\"\"\n+    return isinstance(obj, (BaseItem, dict)) or _is_dataclass_instance(obj)\n+\n+\n+class ItemAdapter(MutableMapping):",
      "comment": "@elacuesta I agree with @Gallaecio; I think scrapy.Item should be handled not in the same way as MutableMapping in itemadapter package, and it is better to do a conditional import of scrapy.Item in itemadapter.\r\n\r\nSo in a way, it is a circular dependency (not necessarily circular import). itemadapter can work without Scrapy, but supports Scrapy Items, just like it supports dataclasses or attr.s objects.\r\n\r\nFor me it looks like a separate wrapper is not required here; we can use it directly.",
      "comment_id": 415838245,
      "user": "kmike",
      "created_at": "2020-04-27T14:01:14Z",
      "url": "https://github.com/scrapy/scrapy/pull/3881#discussion_r415838245"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 3881,
      "file_path": "scrapy/utils/item.py",
      "line": 30,
      "side": "RIGHT",
      "diff_hunk": "@@ -0,0 +1,104 @@\n+from collections.abc import MutableMapping\n+\n+from scrapy.item import BaseItem\n+\n+\n+def _is_dataclass_instance(obj):\n+    \"\"\"\n+    Return True if *obj* is a dataclass object, False otherwise.\n+    Taken from https://docs.python.org/3/library/dataclasses.html#dataclasses.is_dataclass.\n+    \"\"\"\n+    try:\n+        from dataclasses import is_dataclass\n+    except ImportError:\n+        return False\n+    else:\n+        return is_dataclass(obj) and not isinstance(obj, type)\n+\n+\n+def is_item_like(obj):\n+    \"\"\"\n+    Return True if *obj* is considered a Scrapy *item*, False otherwise.\n+\n+    An object is considered an *item* if it is:\n+    - a scrapy.item.BaseItem or dict instance (or any subclass)\n+    - a dataclass object\n+    \"\"\"\n+    return isinstance(obj, (BaseItem, dict)) or _is_dataclass_instance(obj)\n+\n+\n+class ItemAdapter(MutableMapping):",
      "comment": "On the other hand, I see no reason why we could not support both. That is, you could modify those two `fields`-related methods to check for `Item`, while still supporting `MutableMapping` in general in the rest of the adapter.",
      "comment_id": 416021002,
      "user": "Gallaecio",
      "created_at": "2020-04-27T17:47:00Z",
      "url": "https://github.com/scrapy/scrapy/pull/3881#discussion_r416021002"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 3881,
      "file_path": "scrapy/utils/item.py",
      "line": 30,
      "side": "RIGHT",
      "diff_hunk": "@@ -0,0 +1,104 @@\n+from collections.abc import MutableMapping\n+\n+from scrapy.item import BaseItem\n+\n+\n+def _is_dataclass_instance(obj):\n+    \"\"\"\n+    Return True if *obj* is a dataclass object, False otherwise.\n+    Taken from https://docs.python.org/3/library/dataclasses.html#dataclasses.is_dataclass.\n+    \"\"\"\n+    try:\n+        from dataclasses import is_dataclass\n+    except ImportError:\n+        return False\n+    else:\n+        return is_dataclass(obj) and not isinstance(obj, type)\n+\n+\n+def is_item_like(obj):\n+    \"\"\"\n+    Return True if *obj* is considered a Scrapy *item*, False otherwise.\n+\n+    An object is considered an *item* if it is:\n+    - a scrapy.item.BaseItem or dict instance (or any subclass)\n+    - a dataclass object\n+    \"\"\"\n+    return isinstance(obj, (BaseItem, dict)) or _is_dataclass_instance(obj)\n+\n+\n+class ItemAdapter(MutableMapping):",
      "comment": "I think we would lose generality in `itemadapter` if we do an explicit check for Scrapy items. The way I see it is:\r\n* We check for Scrapy items, and decide to remove support for meta in general for mutable mappings. We're disallowing something that we can support and could be useful for users\r\n* We check for Scrapy items, and decide to keep support for meta in general for mutable mappings. The code for getting the fields is the same for items as it is for mutable mappings, it ends up being the same as not checking in the first place\r\n\r\nI think one alternative is to restrict things in the Scrapy side, i.e.:\r\n\r\n```python\r\n# scrapy/utils/item.py\r\nfrom itemadapter.adapter import ItemAdapter as BaseItemAdapter\r\nfrom itemadapter.utils import is_attrs_instance, is_dataclass_instance\r\n\r\nfrom scrapy.item import Item\r\n\r\n\r\ndef is_item(obj):\r\n    return isinstance(obj, Item) or is_dataclass_instance(obj) or is_attrs_instance(obj)\r\n\r\n\r\nclass ItemAdapter(BaseItemAdapter):\r\n    def __init__(self, item):\r\n        if not is_item(item):\r\n            raise TypeError(\"Expected a valid item, got %r instead: %s\" % (type(item), item))\r\n        super().__init__(item)\r\n```",
      "comment_id": 416183828,
      "user": "elacuesta",
      "created_at": "2020-04-27T22:09:51Z",
      "url": "https://github.com/scrapy/scrapy/pull/3881#discussion_r416183828"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 3881,
      "file_path": "scrapy/utils/item.py",
      "line": 30,
      "side": "RIGHT",
      "diff_hunk": "@@ -0,0 +1,104 @@\n+from collections.abc import MutableMapping\n+\n+from scrapy.item import BaseItem\n+\n+\n+def _is_dataclass_instance(obj):\n+    \"\"\"\n+    Return True if *obj* is a dataclass object, False otherwise.\n+    Taken from https://docs.python.org/3/library/dataclasses.html#dataclasses.is_dataclass.\n+    \"\"\"\n+    try:\n+        from dataclasses import is_dataclass\n+    except ImportError:\n+        return False\n+    else:\n+        return is_dataclass(obj) and not isinstance(obj, type)\n+\n+\n+def is_item_like(obj):\n+    \"\"\"\n+    Return True if *obj* is considered a Scrapy *item*, False otherwise.\n+\n+    An object is considered an *item* if it is:\n+    - a scrapy.item.BaseItem or dict instance (or any subclass)\n+    - a dataclass object\n+    \"\"\"\n+    return isinstance(obj, (BaseItem, dict)) or _is_dataclass_instance(obj)\n+\n+\n+class ItemAdapter(MutableMapping):",
      "comment": "By \u201csupport for meta\u201d do you mean the 2 methods to get field metadata? Wouldn\u2019t it make sense _not_ to support that in `MutableMapping` given `MutableMapping` does not support defining metadata?\r\n\r\nOtherwise we are saying that, in mappings used with this library, the `fields` key is reserved for field metadata. If field metadata support is desired, I think something other than a simple `dict`, `MutableMapping` or `Mapping` should be used.",
      "comment_id": 416199088,
      "user": "Gallaecio",
      "created_at": "2020-04-27T22:43:04Z",
      "url": "https://github.com/scrapy/scrapy/pull/3881#discussion_r416199088"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 3881,
      "file_path": "scrapy/utils/item.py",
      "line": 30,
      "side": "RIGHT",
      "diff_hunk": "@@ -0,0 +1,104 @@\n+from collections.abc import MutableMapping\n+\n+from scrapy.item import BaseItem\n+\n+\n+def _is_dataclass_instance(obj):\n+    \"\"\"\n+    Return True if *obj* is a dataclass object, False otherwise.\n+    Taken from https://docs.python.org/3/library/dataclasses.html#dataclasses.is_dataclass.\n+    \"\"\"\n+    try:\n+        from dataclasses import is_dataclass\n+    except ImportError:\n+        return False\n+    else:\n+        return is_dataclass(obj) and not isinstance(obj, type)\n+\n+\n+def is_item_like(obj):\n+    \"\"\"\n+    Return True if *obj* is considered a Scrapy *item*, False otherwise.\n+\n+    An object is considered an *item* if it is:\n+    - a scrapy.item.BaseItem or dict instance (or any subclass)\n+    - a dataclass object\n+    \"\"\"\n+    return isinstance(obj, (BaseItem, dict)) or _is_dataclass_instance(obj)\n+\n+\n+class ItemAdapter(MutableMapping):",
      "comment": "Not the key but the _attribute_, i.e. `obj.fields` not `obj[\"fields\"]`. My reasoning was \"if we support arbitrary dicts, why not support arbitrary dicts which also happen to define a `fields` attribute?\"\r\nAnyway, this probably will not be an issue in practice, as you say, I imagine users using other types if they need metadata, I just thought it would be nice to allow and not difficult to maintain. I can remove that in itemadapter, it's already released but it's not like many people are using it.",
      "comment_id": 416522945,
      "user": "elacuesta",
      "created_at": "2020-04-28T11:00:36Z",
      "url": "https://github.com/scrapy/scrapy/pull/3881#discussion_r416522945"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 3881,
      "file_path": "scrapy/utils/item.py",
      "line": 30,
      "side": "RIGHT",
      "diff_hunk": "@@ -0,0 +1,104 @@\n+from collections.abc import MutableMapping\n+\n+from scrapy.item import BaseItem\n+\n+\n+def _is_dataclass_instance(obj):\n+    \"\"\"\n+    Return True if *obj* is a dataclass object, False otherwise.\n+    Taken from https://docs.python.org/3/library/dataclasses.html#dataclasses.is_dataclass.\n+    \"\"\"\n+    try:\n+        from dataclasses import is_dataclass\n+    except ImportError:\n+        return False\n+    else:\n+        return is_dataclass(obj) and not isinstance(obj, type)\n+\n+\n+def is_item_like(obj):\n+    \"\"\"\n+    Return True if *obj* is considered a Scrapy *item*, False otherwise.\n+\n+    An object is considered an *item* if it is:\n+    - a scrapy.item.BaseItem or dict instance (or any subclass)\n+    - a dataclass object\n+    \"\"\"\n+    return isinstance(obj, (BaseItem, dict)) or _is_dataclass_instance(obj)\n+\n+\n+class ItemAdapter(MutableMapping):",
      "comment": "> Not the key but the attribute, i.e. obj.fields not obj[\"fields\"]\r\n\r\nI did not realize this :facepalm: . In that case I think it is OK to support it. If we do, though, the documentation should definitely cover this, and explain how to implement such an attribute.",
      "comment_id": 416526198,
      "user": "Gallaecio",
      "created_at": "2020-04-28T11:06:28Z",
      "url": "https://github.com/scrapy/scrapy/pull/3881#discussion_r416526198"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 3881,
      "file_path": "scrapy/utils/item.py",
      "line": 30,
      "side": "RIGHT",
      "diff_hunk": "@@ -0,0 +1,104 @@\n+from collections.abc import MutableMapping\n+\n+from scrapy.item import BaseItem\n+\n+\n+def _is_dataclass_instance(obj):\n+    \"\"\"\n+    Return True if *obj* is a dataclass object, False otherwise.\n+    Taken from https://docs.python.org/3/library/dataclasses.html#dataclasses.is_dataclass.\n+    \"\"\"\n+    try:\n+        from dataclasses import is_dataclass\n+    except ImportError:\n+        return False\n+    else:\n+        return is_dataclass(obj) and not isinstance(obj, type)\n+\n+\n+def is_item_like(obj):\n+    \"\"\"\n+    Return True if *obj* is considered a Scrapy *item*, False otherwise.\n+\n+    An object is considered an *item* if it is:\n+    - a scrapy.item.BaseItem or dict instance (or any subclass)\n+    - a dataclass object\n+    \"\"\"\n+    return isinstance(obj, (BaseItem, dict)) or _is_dataclass_instance(obj)\n+\n+\n+class ItemAdapter(MutableMapping):",
      "comment": "Hey! Currently in Scrapy it works like that:\r\n\r\n* dict is an item, meta is not supported\r\n* Item is an item, meta is supported\r\n\r\nAfter this PR, before itemadapter package:\r\n* dataclass instance is an item, meta is not supported (for now; we could support https://docs.python.org/3.9/library/typing.html#typing.Annotated in future)\r\n\r\nIn the itemadapter, non-controversial:\r\n* attr.s instance is an item, meta is supported (though is the support implemented?)\r\n\r\nThe thing we're discussing, a controversial change in itemadapter:\r\n* arbitrary MutableMapping is an item\r\n* for arbitrary MutableMapping meta is supported if it has \"fields\" attribute.\r\n\r\nI think the last part may require a separate discussion - do we allow any arbitrary MutableMapping as an item, or not. If we allow arbitrary MutableMapping, how to annotate fields. This change is much larger than adding dataclass support. I recall initially we decided to be very explicit, and so Scrapy is checking just for `dict` now, not for any MutableMapping - it'd be easy to add support for arbitrary MutableMapping in future, but it'd be hard to remove it, if we find some issue with that. It may have a merit, and use cases, and could be non-problematic, but I think it deserves a separate discussion.\r\n\r\nWhat do you think about focusing on non-controversial, low risk changes first, to get everything merged? I.e. rollback / move to PR controversial stiff. And then we can discuss MutableMapping thing separately.",
      "comment_id": 416773650,
      "user": "kmike",
      "created_at": "2020-04-28T16:57:09Z",
      "url": "https://github.com/scrapy/scrapy/pull/3881#discussion_r416773650"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 3881,
      "file_path": "scrapy/utils/item.py",
      "line": 30,
      "side": "RIGHT",
      "diff_hunk": "@@ -0,0 +1,104 @@\n+from collections.abc import MutableMapping\n+\n+from scrapy.item import BaseItem\n+\n+\n+def _is_dataclass_instance(obj):\n+    \"\"\"\n+    Return True if *obj* is a dataclass object, False otherwise.\n+    Taken from https://docs.python.org/3/library/dataclasses.html#dataclasses.is_dataclass.\n+    \"\"\"\n+    try:\n+        from dataclasses import is_dataclass\n+    except ImportError:\n+        return False\n+    else:\n+        return is_dataclass(obj) and not isinstance(obj, type)\n+\n+\n+def is_item_like(obj):\n+    \"\"\"\n+    Return True if *obj* is considered a Scrapy *item*, False otherwise.\n+\n+    An object is considered an *item* if it is:\n+    - a scrapy.item.BaseItem or dict instance (or any subclass)\n+    - a dataclass object\n+    \"\"\"\n+    return isinstance(obj, (BaseItem, dict)) or _is_dataclass_instance(obj)\n+\n+\n+class ItemAdapter(MutableMapping):",
      "comment": "The difference is that for dicts, scrapy.Item, dataclasses and attr.s instances we know what we're working with; for MutableMapping we don't, as all kinds af object in Python ecosystem may be implementing it. That's why I see it as a higher risk change.",
      "comment_id": 416778554,
      "user": "kmike",
      "created_at": "2020-04-28T17:04:42Z",
      "url": "https://github.com/scrapy/scrapy/pull/3881#discussion_r416778554"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 3881,
      "file_path": "scrapy/utils/item.py",
      "line": 30,
      "side": "RIGHT",
      "diff_hunk": "@@ -0,0 +1,104 @@\n+from collections.abc import MutableMapping\n+\n+from scrapy.item import BaseItem\n+\n+\n+def _is_dataclass_instance(obj):\n+    \"\"\"\n+    Return True if *obj* is a dataclass object, False otherwise.\n+    Taken from https://docs.python.org/3/library/dataclasses.html#dataclasses.is_dataclass.\n+    \"\"\"\n+    try:\n+        from dataclasses import is_dataclass\n+    except ImportError:\n+        return False\n+    else:\n+        return is_dataclass(obj) and not isinstance(obj, type)\n+\n+\n+def is_item_like(obj):\n+    \"\"\"\n+    Return True if *obj* is considered a Scrapy *item*, False otherwise.\n+\n+    An object is considered an *item* if it is:\n+    - a scrapy.item.BaseItem or dict instance (or any subclass)\n+    - a dataclass object\n+    \"\"\"\n+    return isinstance(obj, (BaseItem, dict)) or _is_dataclass_instance(obj)\n+\n+\n+class ItemAdapter(MutableMapping):",
      "comment": "Sounds fine to me, I removed meta for MutableMappings already, I'll remove MutableMappings altogether now, it'd be easy to add it back if we decide to.",
      "comment_id": 416846569,
      "user": "elacuesta",
      "created_at": "2020-04-28T18:52:34Z",
      "url": "https://github.com/scrapy/scrapy/pull/3881#discussion_r416846569"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 3881,
      "file_path": "scrapy/utils/item.py",
      "line": 30,
      "side": "RIGHT",
      "diff_hunk": "@@ -0,0 +1,104 @@\n+from collections.abc import MutableMapping\n+\n+from scrapy.item import BaseItem\n+\n+\n+def _is_dataclass_instance(obj):\n+    \"\"\"\n+    Return True if *obj* is a dataclass object, False otherwise.\n+    Taken from https://docs.python.org/3/library/dataclasses.html#dataclasses.is_dataclass.\n+    \"\"\"\n+    try:\n+        from dataclasses import is_dataclass\n+    except ImportError:\n+        return False\n+    else:\n+        return is_dataclass(obj) and not isinstance(obj, type)\n+\n+\n+def is_item_like(obj):\n+    \"\"\"\n+    Return True if *obj* is considered a Scrapy *item*, False otherwise.\n+\n+    An object is considered an *item* if it is:\n+    - a scrapy.item.BaseItem or dict instance (or any subclass)\n+    - a dataclass object\n+    \"\"\"\n+    return isinstance(obj, (BaseItem, dict)) or _is_dataclass_instance(obj)\n+\n+\n+class ItemAdapter(MutableMapping):",
      "comment": "Done in [v0.0.5](https://github.com/elacuesta/itemadapter/releases/tag/v0.0.5).\r\nOne thing I wonder is: will there be any issues when running `itemadapter`'s tests (which install Scrapy to check for `scrapy.item.Item`) if Scrapy setup requires `\u00ectemadapter`?",
      "comment_id": 416898585,
      "user": "elacuesta",
      "created_at": "2020-04-28T20:23:57Z",
      "url": "https://github.com/scrapy/scrapy/pull/3881#discussion_r416898585"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 3881,
      "file_path": "scrapy/exporters.py",
      "line": 13,
      "side": "RIGHT",
      "diff_hunk": "@@ -4,16 +4,18 @@\n \n import csv\n import io\n-import pprint\n import marshal\n-import warnings\n import pickle\n+import pprint\n+import warnings\n from xml.sax.saxutils import XMLGenerator\n \n-from scrapy.utils.serialize import ScrapyJSONEncoder\n-from scrapy.utils.python import to_bytes, to_unicode, is_listlike\n-from scrapy.item import _BaseItem\n+from itemadapter import ItemAdapter, is_item",
      "comment": ":lipstick: \r\n\r\n```suggestion\r\nfrom itemadapter import is_item, ItemAdapter\r\n```",
      "comment_id": 426709638,
      "user": "Gallaecio",
      "created_at": "2020-05-18T15:26:58Z",
      "url": "https://github.com/scrapy/scrapy/pull/3881#discussion_r426709638"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 3881,
      "file_path": "scrapy/loader/__init__.py",
      "line": 137,
      "side": "RIGHT",
      "diff_hunk": "@@ -127,13 +129,12 @@ def get_value(self, value, *processors, **kw):\n         return value\n \n     def load_item(self):\n-        item = self.item\n+        adapter = ItemAdapter(self.item)\n         for field_name in tuple(self._values):\n             value = self.get_output_value(field_name)\n             if value is not None:\n-                item[field_name] = value\n-\n-        return item\n+                adapter[field_name] = value\n+        return adapter.item",
      "comment": "It's the same object, and I'd argue that `return adapter.item` is a little bit more clear in the sense that in order to understand `return self.item` you need to know that `ItemAdapter` modifies the item in-place, which you might not know a priori.",
      "comment_id": 426944757,
      "user": "elacuesta",
      "created_at": "2020-05-18T23:23:52Z",
      "url": "https://github.com/scrapy/scrapy/pull/3881#discussion_r426944757"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 3881,
      "file_path": "scrapy/loader/__init__.py",
      "line": 137,
      "side": "RIGHT",
      "diff_hunk": "@@ -127,13 +129,12 @@ def get_value(self, value, *processors, **kw):\n         return value\n \n     def load_item(self):\n-        item = self.item\n+        adapter = ItemAdapter(self.item)\n         for field_name in tuple(self._values):\n             value = self.get_output_value(field_name)\n             if value is not None:\n-                item[field_name] = value\n-\n-        return item\n+                adapter[field_name] = value\n+        return adapter.item",
      "comment": "I think that it\u2019s precisely because it\u2019s important for people to understand that `ItemAdapter` edits the item in place that we should avoid `adapter.item` unless necessary.\r\n\r\nThat said, this is internal code and not documentation, so I guess that aspect is not that relevant.",
      "comment_id": 427332607,
      "user": "Gallaecio",
      "created_at": "2020-05-19T14:11:26Z",
      "url": "https://github.com/scrapy/scrapy/pull/3881#discussion_r427332607"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 3881,
      "file_path": "scrapy/commands/parse.py",
      "line": 120,
      "side": "RIGHT",
      "diff_hunk": "@@ -117,7 +117,7 @@ def run_callback(self, response, callback, cb_kwargs=None):\n         items, requests = [], []\n \n         for x in iterate_spider_output(callback(response, **cb_kwargs)):\n-            if isinstance(x, (_BaseItem, dict)):\n+            if is_item(x):",
      "comment": "Should print_items be modified as well? Maybe something else?",
      "comment_id": 428280906,
      "user": "kmike",
      "created_at": "2020-05-20T20:13:44Z",
      "url": "https://github.com/scrapy/scrapy/pull/3881#discussion_r428280906"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 3881,
      "file_path": "scrapy/exporters.py",
      "line": 82,
      "side": "RIGHT",
      "diff_hunk": "@@ -71,7 +76,10 @@ def _get_serialized_fields(self, item, default_value=None, include_empty=None):\n \n         for field_name in field_iter:\n             if field_name in item:\n-                field = {} if isinstance(item, dict) else item.fields[field_name]\n+                try:\n+                    field = item.get_field_meta(field_name)\n+                except TypeError:\n+                    field = {}",
      "comment": "Are there cases when `item.get_field_meta(field_name)` for an item type which doesn't support meta should return anything other than `{}`? \r\n\r\nI wonder if we should modify itemadapter to either \r\n\r\n* return something instead of raising an exception\r\n* supporting \"default\" argument for get_item_field\r\n* raising a specific exception (MetaNotSupported or something like that), instead of a generic TypeError. Catching those TypeErrors look a bit dangerous.\r\n",
      "comment_id": 428284535,
      "user": "kmike",
      "created_at": "2020-05-20T20:20:48Z",
      "url": "https://github.com/scrapy/scrapy/pull/3881#discussion_r428284535"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 3881,
      "file_path": "tests/test_loader.py",
      "line": 478,
      "side": "RIGHT",
      "diff_hunk": "@@ -466,15 +475,15 @@ def test_keep_single_value(self):\n         il = ItemLoader(item=input_item)\n         loaded_item = il.load_item()\n         self.assertIsInstance(loaded_item, self.item_class)\n-        self.assertEqual(dict(loaded_item), {'name': ['foo']})\n+        self.assertEqual(dict(ItemAdapter(loaded_item).items()), {'name': ['foo']})",
      "comment": "is .items() needed? There are a few more cases like that.",
      "comment_id": 428288378,
      "user": "kmike",
      "created_at": "2020-05-20T20:28:32Z",
      "url": "https://github.com/scrapy/scrapy/pull/3881#discussion_r428288378"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 3881,
      "file_path": "tests/test_pipeline_files.py",
      "line": 189,
      "side": "RIGHT",
      "diff_hunk": "@@ -119,43 +137,73 @@ def test_file_expired(self):\n             p.stop()\n \n \n-class FilesPipelineTestCaseFields(unittest.TestCase):\n+class FilesPipelineTestCaseFieldsMixin:\n \n     def test_item_fields_default(self):\n-        class TestItem(Item):\n-            name = Field()\n-            file_urls = Field()\n-            files = Field()\n-\n-        for cls in TestItem, dict:\n-            url = 'http://www.example.com/files/1.txt'\n-            item = cls({'name': 'item1', 'file_urls': [url]})\n-            pipeline = FilesPipeline.from_settings(Settings({'FILES_STORE': 's3://example/files/'}))\n-            requests = list(pipeline.get_media_requests(item, None))\n-            self.assertEqual(requests[0].url, url)\n-            results = [(True, {'url': url})]\n-            pipeline.item_completed(results, item, None)\n-            self.assertEqual(item['files'], [results[0][1]])\n+        url = 'http://www.example.com/files/1.txt'\n+        item = self.item_class(name='item1', file_urls=[url])\n+        pipeline = FilesPipeline.from_settings(Settings({'FILES_STORE': 's3://example/files/'}))\n+        requests = list(pipeline.get_media_requests(item, None))\n+        self.assertEqual(requests[0].url, url)\n+        results = [(True, {'url': url})]\n+        item = pipeline.item_completed(results, item, None)\n+        files = ItemAdapter(item).get(\"files\")\n+        self.assertEqual(files, [results[0][1]])\n+        self.assertIsInstance(item, self.item_class)\n \n     def test_item_fields_override_settings(self):\n-        class TestItem(Item):\n-            name = Field()\n-            files = Field()\n-            stored_file = Field()\n-\n-        for cls in TestItem, dict:\n-            url = 'http://www.example.com/files/1.txt'\n-            item = cls({'name': 'item1', 'files': [url]})\n-            pipeline = FilesPipeline.from_settings(Settings({\n-                'FILES_STORE': 's3://example/files/',\n-                'FILES_URLS_FIELD': 'files',\n-                'FILES_RESULT_FIELD': 'stored_file'\n-            }))\n-            requests = list(pipeline.get_media_requests(item, None))\n-            self.assertEqual(requests[0].url, url)\n-            results = [(True, {'url': url})]\n-            pipeline.item_completed(results, item, None)\n-            self.assertEqual(item['stored_file'], [results[0][1]])\n+        url = 'http://www.example.com/files/1.txt'\n+        item = self.item_class(name='item1', custom_file_urls=[url])\n+        pipeline = FilesPipeline.from_settings(Settings({\n+            'FILES_STORE': 's3://example/files/',\n+            'FILES_URLS_FIELD': 'custom_file_urls',\n+            'FILES_RESULT_FIELD': 'custom_files'\n+        }))\n+        requests = list(pipeline.get_media_requests(item, None))\n+        self.assertEqual(requests[0].url, url)\n+        results = [(True, {'url': url})]\n+        item = pipeline.item_completed(results, item, None)\n+        custom_files = ItemAdapter(item).get(\"custom_files\")\n+        self.assertEqual(custom_files, [results[0][1]])\n+        self.assertIsInstance(item, self.item_class)\n+\n+\n+class FilesPipelineTestCaseFieldsDict(FilesPipelineTestCaseFieldsMixin, unittest.TestCase):\n+    item_class = dict\n+\n+\n+class FilesPipelineTestItem(Item):\n+    name = Field()\n+    # default fields\n+    file_urls = Field()\n+    files = Field()\n+    # overridden fields\n+    custom_file_urls = Field()\n+    custom_files = Field()\n+\n+\n+class FilesPipelineTestCaseFieldsItem(FilesPipelineTestCaseFieldsMixin, unittest.TestCase):\n+    item_class = FilesPipelineTestItem\n+\n+\n+@skipIf(not make_dataclass, \"dataclasses module is not available\")",
      "comment": "as we advertise attr.s support in Scrapy docs, should we check that it works, i.e. have tests for attr.s as well?",
      "comment_id": 428288850,
      "user": "kmike",
      "created_at": "2020-05-20T20:29:30Z",
      "url": "https://github.com/scrapy/scrapy/pull/3881#discussion_r428288850"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 3881,
      "file_path": "scrapy/exporters.py",
      "line": 82,
      "side": "RIGHT",
      "diff_hunk": "@@ -71,7 +76,10 @@ def _get_serialized_fields(self, item, default_value=None, include_empty=None):\n \n         for field_name in field_iter:\n             if field_name in item:\n-                field = {} if isinstance(item, dict) else item.fields[field_name]\n+                try:\n+                    field = item.get_field_meta(field_name)\n+                except TypeError:\n+                    field = {}",
      "comment": "I'm not sure I understand the question, but I see how using `TypeError` could be bad. Adding a `default` parameter sounds coherent with `dict.get`. I'll make the changes in itemadapter.",
      "comment_id": 428301072,
      "user": "elacuesta",
      "created_at": "2020-05-20T20:53:38Z",
      "url": "https://github.com/scrapy/scrapy/pull/3881#discussion_r428301072"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 3881,
      "file_path": "tests/test_pipeline_files.py",
      "line": 189,
      "side": "RIGHT",
      "diff_hunk": "@@ -119,43 +137,73 @@ def test_file_expired(self):\n             p.stop()\n \n \n-class FilesPipelineTestCaseFields(unittest.TestCase):\n+class FilesPipelineTestCaseFieldsMixin:\n \n     def test_item_fields_default(self):\n-        class TestItem(Item):\n-            name = Field()\n-            file_urls = Field()\n-            files = Field()\n-\n-        for cls in TestItem, dict:\n-            url = 'http://www.example.com/files/1.txt'\n-            item = cls({'name': 'item1', 'file_urls': [url]})\n-            pipeline = FilesPipeline.from_settings(Settings({'FILES_STORE': 's3://example/files/'}))\n-            requests = list(pipeline.get_media_requests(item, None))\n-            self.assertEqual(requests[0].url, url)\n-            results = [(True, {'url': url})]\n-            pipeline.item_completed(results, item, None)\n-            self.assertEqual(item['files'], [results[0][1]])\n+        url = 'http://www.example.com/files/1.txt'\n+        item = self.item_class(name='item1', file_urls=[url])\n+        pipeline = FilesPipeline.from_settings(Settings({'FILES_STORE': 's3://example/files/'}))\n+        requests = list(pipeline.get_media_requests(item, None))\n+        self.assertEqual(requests[0].url, url)\n+        results = [(True, {'url': url})]\n+        item = pipeline.item_completed(results, item, None)\n+        files = ItemAdapter(item).get(\"files\")\n+        self.assertEqual(files, [results[0][1]])\n+        self.assertIsInstance(item, self.item_class)\n \n     def test_item_fields_override_settings(self):\n-        class TestItem(Item):\n-            name = Field()\n-            files = Field()\n-            stored_file = Field()\n-\n-        for cls in TestItem, dict:\n-            url = 'http://www.example.com/files/1.txt'\n-            item = cls({'name': 'item1', 'files': [url]})\n-            pipeline = FilesPipeline.from_settings(Settings({\n-                'FILES_STORE': 's3://example/files/',\n-                'FILES_URLS_FIELD': 'files',\n-                'FILES_RESULT_FIELD': 'stored_file'\n-            }))\n-            requests = list(pipeline.get_media_requests(item, None))\n-            self.assertEqual(requests[0].url, url)\n-            results = [(True, {'url': url})]\n-            pipeline.item_completed(results, item, None)\n-            self.assertEqual(item['stored_file'], [results[0][1]])\n+        url = 'http://www.example.com/files/1.txt'\n+        item = self.item_class(name='item1', custom_file_urls=[url])\n+        pipeline = FilesPipeline.from_settings(Settings({\n+            'FILES_STORE': 's3://example/files/',\n+            'FILES_URLS_FIELD': 'custom_file_urls',\n+            'FILES_RESULT_FIELD': 'custom_files'\n+        }))\n+        requests = list(pipeline.get_media_requests(item, None))\n+        self.assertEqual(requests[0].url, url)\n+        results = [(True, {'url': url})]\n+        item = pipeline.item_completed(results, item, None)\n+        custom_files = ItemAdapter(item).get(\"custom_files\")\n+        self.assertEqual(custom_files, [results[0][1]])\n+        self.assertIsInstance(item, self.item_class)\n+\n+\n+class FilesPipelineTestCaseFieldsDict(FilesPipelineTestCaseFieldsMixin, unittest.TestCase):\n+    item_class = dict\n+\n+\n+class FilesPipelineTestItem(Item):\n+    name = Field()\n+    # default fields\n+    file_urls = Field()\n+    files = Field()\n+    # overridden fields\n+    custom_file_urls = Field()\n+    custom_files = Field()\n+\n+\n+class FilesPipelineTestCaseFieldsItem(FilesPipelineTestCaseFieldsMixin, unittest.TestCase):\n+    item_class = FilesPipelineTestItem\n+\n+\n+@skipIf(not make_dataclass, \"dataclasses module is not available\")",
      "comment": "I\u2019m +0 here.\r\n\r\nAs long as the new library verifies that both data types work as expected when using `ItemAdapter`, and we make sure we only access items through `ItemAdapter`, I think we should be OK.\r\n\r\nOn the other hand, I cannot think of a way to make sure that we are using `ItemAdapter` other than making sure that things work with dataclasses, `attr.s`, etc.",
      "comment_id": 428602439,
      "user": "Gallaecio",
      "created_at": "2020-05-21T11:43:52Z",
      "url": "https://github.com/scrapy/scrapy/pull/3881#discussion_r428602439"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 3881,
      "file_path": "scrapy/exporters.py",
      "line": 82,
      "side": "RIGHT",
      "diff_hunk": "@@ -71,7 +76,10 @@ def _get_serialized_fields(self, item, default_value=None, include_empty=None):\n \n         for field_name in field_iter:\n             if field_name in item:\n-                field = {} if isinstance(item, dict) else item.fields[field_name]\n+                try:\n+                    field = item.get_field_meta(field_name)\n+                except TypeError:\n+                    field = {}",
      "comment": "`item.get_field_meta` currently raises an exception if an item doesn't provide a way to set meta. Now I think that there should be a way for it not to raise an exception. What's the use case for this exception?\r\n\r\nIf there is no use case, we should just return `{}`. There is no use case for an exception in Scrapy itself, as in all Scrapy usages exception handling won't be needed if a `{}` default is returned when meta is absent.\r\n\r\nIf there is a possibility that there is a use case, but it is not clear which use case is that, it'd be good to keep an option to have this exception, but make the lookup return `{}` by default, to match the common usage better. \r\n\r\nIf there is a use case, then we should consider making exception a default behavior.\r\n\r\nFor me returning empty dict as a field meta for dicts (or other future possibile items which don't provide meta) feels ok. Meta is optional in dataclasses and attrs, so it is normal behavior that the meta is not populated. As it is optional, that's not a problem that for dict meta is empty - it could be empty for attrs or dataclasses as well. The difference is that dict doesn't allow to set meta, but that's user choice. If they realize they need to set meta, they switch to scrapy Items or attrs or dataclasses. It is actually similar for attrs and dataclasses: you can't set meta if you use type annotation-based definitions; if user realizes they need meta, they switch to e.g. to an explicit attr.ib(...).",
      "comment_id": 428899339,
      "user": "kmike",
      "created_at": "2020-05-21T20:35:23Z",
      "url": "https://github.com/scrapy/scrapy/pull/3881#discussion_r428899339"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 3881,
      "file_path": "scrapy/exporters.py",
      "line": 82,
      "side": "RIGHT",
      "diff_hunk": "@@ -71,7 +76,10 @@ def _get_serialized_fields(self, item, default_value=None, include_empty=None):\n \n         for field_name in field_iter:\n             if field_name in item:\n-                field = {} if isinstance(item, dict) else item.fields[field_name]\n+                try:\n+                    field = item.get_field_meta(field_name)\n+                except TypeError:\n+                    field = {}",
      "comment": "Updated in a3672d5e81aeec76b6c5718dd9f9f61f43edf1f3, https://github.com/scrapy/itemadapter/commit/3594f8f52767e499c86182e25509dce893cbf6ae",
      "comment_id": 428969501,
      "user": "elacuesta",
      "created_at": "2020-05-21T23:35:59Z",
      "url": "https://github.com/scrapy/scrapy/pull/3881#discussion_r428969501"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 3881,
      "file_path": "tests/test_pipeline_files.py",
      "line": 189,
      "side": "RIGHT",
      "diff_hunk": "@@ -119,43 +137,73 @@ def test_file_expired(self):\n             p.stop()\n \n \n-class FilesPipelineTestCaseFields(unittest.TestCase):\n+class FilesPipelineTestCaseFieldsMixin:\n \n     def test_item_fields_default(self):\n-        class TestItem(Item):\n-            name = Field()\n-            file_urls = Field()\n-            files = Field()\n-\n-        for cls in TestItem, dict:\n-            url = 'http://www.example.com/files/1.txt'\n-            item = cls({'name': 'item1', 'file_urls': [url]})\n-            pipeline = FilesPipeline.from_settings(Settings({'FILES_STORE': 's3://example/files/'}))\n-            requests = list(pipeline.get_media_requests(item, None))\n-            self.assertEqual(requests[0].url, url)\n-            results = [(True, {'url': url})]\n-            pipeline.item_completed(results, item, None)\n-            self.assertEqual(item['files'], [results[0][1]])\n+        url = 'http://www.example.com/files/1.txt'\n+        item = self.item_class(name='item1', file_urls=[url])\n+        pipeline = FilesPipeline.from_settings(Settings({'FILES_STORE': 's3://example/files/'}))\n+        requests = list(pipeline.get_media_requests(item, None))\n+        self.assertEqual(requests[0].url, url)\n+        results = [(True, {'url': url})]\n+        item = pipeline.item_completed(results, item, None)\n+        files = ItemAdapter(item).get(\"files\")\n+        self.assertEqual(files, [results[0][1]])\n+        self.assertIsInstance(item, self.item_class)\n \n     def test_item_fields_override_settings(self):\n-        class TestItem(Item):\n-            name = Field()\n-            files = Field()\n-            stored_file = Field()\n-\n-        for cls in TestItem, dict:\n-            url = 'http://www.example.com/files/1.txt'\n-            item = cls({'name': 'item1', 'files': [url]})\n-            pipeline = FilesPipeline.from_settings(Settings({\n-                'FILES_STORE': 's3://example/files/',\n-                'FILES_URLS_FIELD': 'files',\n-                'FILES_RESULT_FIELD': 'stored_file'\n-            }))\n-            requests = list(pipeline.get_media_requests(item, None))\n-            self.assertEqual(requests[0].url, url)\n-            results = [(True, {'url': url})]\n-            pipeline.item_completed(results, item, None)\n-            self.assertEqual(item['stored_file'], [results[0][1]])\n+        url = 'http://www.example.com/files/1.txt'\n+        item = self.item_class(name='item1', custom_file_urls=[url])\n+        pipeline = FilesPipeline.from_settings(Settings({\n+            'FILES_STORE': 's3://example/files/',\n+            'FILES_URLS_FIELD': 'custom_file_urls',\n+            'FILES_RESULT_FIELD': 'custom_files'\n+        }))\n+        requests = list(pipeline.get_media_requests(item, None))\n+        self.assertEqual(requests[0].url, url)\n+        results = [(True, {'url': url})]\n+        item = pipeline.item_completed(results, item, None)\n+        custom_files = ItemAdapter(item).get(\"custom_files\")\n+        self.assertEqual(custom_files, [results[0][1]])\n+        self.assertIsInstance(item, self.item_class)\n+\n+\n+class FilesPipelineTestCaseFieldsDict(FilesPipelineTestCaseFieldsMixin, unittest.TestCase):\n+    item_class = dict\n+\n+\n+class FilesPipelineTestItem(Item):\n+    name = Field()\n+    # default fields\n+    file_urls = Field()\n+    files = Field()\n+    # overridden fields\n+    custom_file_urls = Field()\n+    custom_files = Field()\n+\n+\n+class FilesPipelineTestCaseFieldsItem(FilesPipelineTestCaseFieldsMixin, unittest.TestCase):\n+    item_class = FilesPipelineTestItem\n+\n+\n+@skipIf(not make_dataclass, \"dataclasses module is not available\")",
      "comment": "Tests for `attrs` items: b4e535721a37035db596ca8b56b3cbd4779d4568",
      "comment_id": 428983537,
      "user": "elacuesta",
      "created_at": "2020-05-22T00:29:02Z",
      "url": "https://github.com/scrapy/scrapy/pull/3881#discussion_r428983537"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 3881,
      "file_path": "scrapy/loader/__init__.py",
      "line": 180,
      "side": "RIGHT",
      "diff_hunk": "@@ -174,11 +175,12 @@ def _process_input_value(self, field_name, value):\n                                     value, type(e).__name__, str(e)))\n \n     def _get_item_field_attr(self, field_name, key, default=None):\n-        if isinstance(self.item, Item):\n-            value = self.item.fields[field_name].get(key, default)\n+        try:\n+            field_meta = ItemAdapter(self.item).get_field_meta(field_name)\n+        except TypeError:",
      "comment": "Oh nice catch, I only remembered the one in `exporters.py`",
      "comment_id": 429251892,
      "user": "elacuesta",
      "created_at": "2020-05-22T13:40:26Z",
      "url": "https://github.com/scrapy/scrapy/pull/3881#discussion_r429251892"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 4552,
      "file_path": "scrapy/commands/__init__.py",
      "line": 114,
      "side": "RIGHT",
      "diff_hunk": "@@ -104,3 +106,35 @@ def run(self, args, opts):\n         Entry point for running commands\n         \"\"\"\n         raise NotImplementedError\n+\n+\n+''''\n+The BaseRunSpiderCommands class inherits the ScrapyCommand class and it Used for\n+performing common functionality between crawl.py and runspider.py\n+'''",
      "comment": "Move this right under the `class \u2026` line below, indented.",
      "comment_id": 422501868,
      "user": "Gallaecio",
      "created_at": "2020-05-09T14:25:14Z",
      "url": "https://github.com/scrapy/scrapy/pull/4552#discussion_r422501868"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 4552,
      "file_path": "scrapy/commands/__init__.py",
      "line": 84,
      "side": "RIGHT",
      "diff_hunk": "@@ -79,7 +80,8 @@ def process_options(self, args, opts):\n             self.settings.setdict(arglist_to_dict(opts.set),\n                                   priority='cmdline')\n         except ValueError:\n-            raise UsageError(\"Invalid -s value, use -s NAME=VALUE\", print_help=False)\n+            raise UsageError(\n+                \"Invalid -s value, use -s NAME=VALUE\", print_help=False)",
      "comment": "No need to change this line. In Scrapy, even though aiming for 79-character-long lines, style changes to existing code because of line length should be avoided as long as line length is within our hard limit: 119 characters.\r\n\r\nIt also applies to a similar line in `crawl.py`.",
      "comment_id": 422502131,
      "user": "Gallaecio",
      "created_at": "2020-05-09T14:27:53Z",
      "url": "https://github.com/scrapy/scrapy/pull/4552#discussion_r422502131"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 4552,
      "file_path": "scrapy/commands/__init__.py",
      "line": 126,
      "side": "RIGHT",
      "diff_hunk": "@@ -104,3 +106,35 @@ def run(self, args, opts):\n         Entry point for running commands\n         \"\"\"\n         raise NotImplementedError\n+\n+\n+''''\n+The BaseRunSpiderCommands class inherits the ScrapyCommand class and it Used for\n+performing common functionality between crawl.py and runspider.py\n+'''\n+\n+\n+class BaseRunSpiderCommands(ScrapyCommand):\n+\n+    def add_options(self, parser):\n+        ScrapyCommand.add_options(self, parser)\n+        parser.add_option(\"-a\", dest=\"spargs\", action=\"append\", default=[],\n+                          metavar=\"NAME=VALUE\",\n+                          help=\"set spider argument (may be repeated)\")\n+        parser.add_option(\"-o\", \"--output\", metavar=\"FILE\", action=\"append\",\n+                          help=\"dump scraped items into FILE\"\n+                          + \"(use - for stdout)\")",
      "comment": "My line length comment also applies here. You should copy these two methods as is from their original location, there should be no need to change their formatting.",
      "comment_id": 422502250,
      "user": "Gallaecio",
      "created_at": "2020-05-09T14:28:52Z",
      "url": "https://github.com/scrapy/scrapy/pull/4552#discussion_r422502250"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 4552,
      "file_path": "scrapy/commands/crawl.py",
      "line": 2,
      "side": "RIGHT",
      "diff_hunk": "@@ -1,9 +1,8 @@\n-from scrapy.commands import ScrapyCommand\n-from scrapy.utils.conf import arglist_to_dict, feed_process_params_from_cli\n from scrapy.exceptions import UsageError\n+from scrapy.commands import BaseRunSpiderCommands",
      "comment": "Let\u2019s keep it alphabetical.\r\n\r\n```suggestion\r\nfrom scrapy.commands import BaseRunSpiderCommands\r\nfrom scrapy.exceptions import UsageError\r\n```",
      "comment_id": 422502285,
      "user": "Gallaecio",
      "created_at": "2020-05-09T14:29:20Z",
      "url": "https://github.com/scrapy/scrapy/pull/4552#discussion_r422502285"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 4552,
      "file_path": "scrapy/commands/__init__.py",
      "line": 114,
      "side": "RIGHT",
      "diff_hunk": "@@ -104,3 +105,30 @@ def run(self, args, opts):\n         Entry point for running commands\n         \"\"\"\n         raise NotImplementedError\n+\n+\n+class BaseRunSpiderCommands(ScrapyCommand):\n+    ''''\n+    The BaseRunSpiderCommands class inherits the ScrapyCommand class and it Used for\n+    performing common functionality between crawl.py and runspider.py\n+    '''",
      "comment": "```suggestion\r\n    \"\"\"\r\n    The BaseRunSpiderCommands class inherits the ScrapyCommand class and it Used for\r\n    performing common functionality between crawl.py and runspider.py\r\n    \"\"\"\r\n```",
      "comment_id": 423269227,
      "user": "Gallaecio",
      "created_at": "2020-05-11T19:30:15Z",
      "url": "https://github.com/scrapy/scrapy/pull/4552#discussion_r423269227"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 4552,
      "file_path": "scrapy/commands/__init__.py",
      "line": 126,
      "side": "RIGHT",
      "diff_hunk": "@@ -104,3 +106,35 @@ def run(self, args, opts):\n         Entry point for running commands\n         \"\"\"\n         raise NotImplementedError\n+\n+\n+''''\n+The BaseRunSpiderCommands class inherits the ScrapyCommand class and it Used for\n+performing common functionality between crawl.py and runspider.py\n+'''\n+\n+\n+class BaseRunSpiderCommands(ScrapyCommand):\n+\n+    def add_options(self, parser):\n+        ScrapyCommand.add_options(self, parser)\n+        parser.add_option(\"-a\", dest=\"spargs\", action=\"append\", default=[],\n+                          metavar=\"NAME=VALUE\",\n+                          help=\"set spider argument (may be repeated)\")\n+        parser.add_option(\"-o\", \"--output\", metavar=\"FILE\", action=\"append\",\n+                          help=\"dump scraped items into FILE\"\n+                          + \"(use - for stdout)\")",
      "comment": "@jay24rajput Please address this before we can merge. Thanks!",
      "comment_id": 423296691,
      "user": "elacuesta",
      "created_at": "2020-05-11T20:23:06Z",
      "url": "https://github.com/scrapy/scrapy/pull/4552#discussion_r423296691"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 4552,
      "file_path": "scrapy/commands/__init__.py",
      "line": 126,
      "side": "RIGHT",
      "diff_hunk": "@@ -104,3 +106,35 @@ def run(self, args, opts):\n         Entry point for running commands\n         \"\"\"\n         raise NotImplementedError\n+\n+\n+''''\n+The BaseRunSpiderCommands class inherits the ScrapyCommand class and it Used for\n+performing common functionality between crawl.py and runspider.py\n+'''\n+\n+\n+class BaseRunSpiderCommands(ScrapyCommand):\n+\n+    def add_options(self, parser):\n+        ScrapyCommand.add_options(self, parser)\n+        parser.add_option(\"-a\", dest=\"spargs\", action=\"append\", default=[],\n+                          metavar=\"NAME=VALUE\",\n+                          help=\"set spider argument (may be repeated)\")\n+        parser.add_option(\"-o\", \"--output\", metavar=\"FILE\", action=\"append\",\n+                          help=\"dump scraped items into FILE\"\n+                          + \"(use - for stdout)\")",
      "comment": "@elacuesta Done! Is there anything else that needs to be done? Thanks!",
      "comment_id": 423613141,
      "user": "jay24rajput",
      "created_at": "2020-05-12T09:59:36Z",
      "url": "https://github.com/scrapy/scrapy/pull/4552#discussion_r423613141"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 4552,
      "file_path": "scrapy/commands/__init__.py",
      "line": 126,
      "side": "RIGHT",
      "diff_hunk": "@@ -104,3 +106,35 @@ def run(self, args, opts):\n         Entry point for running commands\n         \"\"\"\n         raise NotImplementedError\n+\n+\n+''''\n+The BaseRunSpiderCommands class inherits the ScrapyCommand class and it Used for\n+performing common functionality between crawl.py and runspider.py\n+'''\n+\n+\n+class BaseRunSpiderCommands(ScrapyCommand):\n+\n+    def add_options(self, parser):\n+        ScrapyCommand.add_options(self, parser)\n+        parser.add_option(\"-a\", dest=\"spargs\", action=\"append\", default=[],\n+                          metavar=\"NAME=VALUE\",\n+                          help=\"set spider argument (may be repeated)\")\n+        parser.add_option(\"-o\", \"--output\", metavar=\"FILE\", action=\"append\",\n+                          help=\"dump scraped items into FILE\"\n+                          + \"(use - for stdout)\")",
      "comment": "@elacuesta the Travis CI build is failing. On the local system ```tox scrapy``` is building successfully and along with flake8. Can you please help me find where the problem is?",
      "comment_id": 423667207,
      "user": "jay24rajput",
      "created_at": "2020-05-12T11:42:01Z",
      "url": "https://github.com/scrapy/scrapy/pull/4552#discussion_r423667207"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 4552,
      "file_path": "scrapy/commands/__init__.py",
      "line": 126,
      "side": "RIGHT",
      "diff_hunk": "@@ -104,3 +106,35 @@ def run(self, args, opts):\n         Entry point for running commands\n         \"\"\"\n         raise NotImplementedError\n+\n+\n+''''\n+The BaseRunSpiderCommands class inherits the ScrapyCommand class and it Used for\n+performing common functionality between crawl.py and runspider.py\n+'''\n+\n+\n+class BaseRunSpiderCommands(ScrapyCommand):\n+\n+    def add_options(self, parser):\n+        ScrapyCommand.add_options(self, parser)\n+        parser.add_option(\"-a\", dest=\"spargs\", action=\"append\", default=[],\n+                          metavar=\"NAME=VALUE\",\n+                          help=\"set spider argument (may be repeated)\")\n+        parser.add_option(\"-o\", \"--output\", metavar=\"FILE\", action=\"append\",\n+                          help=\"dump scraped items into FILE\"\n+                          + \"(use - for stdout)\")",
      "comment": "Right, I've seen this error in other PRs as well, it seems to be directly related to `pytest-flake8`:\r\n```\r\n.tox/flake8/lib/python3.8/site-packages/pytest_flake8.py:191: in check_file\r\n    app.parse_preliminary_options_and_args(args)\r\nE   AttributeError: 'Application' object has no attribute 'parse_preliminary_options_and_args'\r\n```\r\nThis seems safe and unrelated to that, I'll open a new issue to keep track of the build error.",
      "comment_id": 423733121,
      "user": "elacuesta",
      "created_at": "2020-05-12T13:29:30Z",
      "url": "https://github.com/scrapy/scrapy/pull/4552#discussion_r423733121"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 4552,
      "file_path": "scrapy/commands/__init__.py",
      "line": 109,
      "side": "RIGHT",
      "diff_hunk": "@@ -104,3 +104,28 @@ def run(self, args, opts):\n         Entry point for running commands\n         \"\"\"\n         raise NotImplementedError\n+\n+\n+class BaseRunSpiderCommands(ScrapyCommand):",
      "comment": "```suggestion\r\nclass BaseRunSpiderCommand(ScrapyCommand):\r\n```\r\nAnd the corresponding updates in child classes.",
      "comment_id": 425985539,
      "user": "elacuesta",
      "created_at": "2020-05-15T18:47:33Z",
      "url": "https://github.com/scrapy/scrapy/pull/4552#discussion_r425985539"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 4552,
      "file_path": "scrapy/commands/__init__.py",
      "line": 112,
      "side": "RIGHT",
      "diff_hunk": "@@ -104,3 +104,28 @@ def run(self, args, opts):\n         Entry point for running commands\n         \"\"\"\n         raise NotImplementedError\n+\n+\n+class BaseRunSpiderCommand(ScrapyCommand):\n+    \"\"\"\n+    The BaseRunSpiderCommands class inherits the ScrapyCommand class and it Used for\n+    performing common functionality between crawl.py and runspider.py",
      "comment": "```suggestion\r\n    Common class used to share functionality between the crawl and runspider commands\r\n```\r\nSimplify, remove a minor typo and duplicated information (no need to name the classes nor their inheritance, it's clear from the class definition)",
      "comment_id": 426022672,
      "user": "elacuesta",
      "created_at": "2020-05-15T20:07:46Z",
      "url": "https://github.com/scrapy/scrapy/pull/4552#discussion_r426022672"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 4609,
      "file_path": "scrapy/utils/spider.py",
      "line": 25,
      "side": "RIGHT",
      "diff_hunk": "@@ -18,7 +18,11 @@ def iterate_spider_output(result):\n         d = deferred_from_coro(collect_asyncgen(result))\n         d.addCallback(iterate_spider_output)\n         return d\n-    return arg_to_iter(deferred_from_coro(result))\n+    elif inspect.iscoroutine(result):\n+        d = deferred_from_coro(result)\n+        d.addCallback(iterate_spider_output)\n+        return d\n+    return arg_to_iter(result)",
      "comment": "It's safe to remove the `deferred_from_coro` call here, because at this point [this condition](https://github.com/scrapy/scrapy/blob/2.1.0/scrapy/utils/defer.py#L135) is `False` so the passed object is returned unmodified.",
      "comment_id": 433466521,
      "user": "elacuesta",
      "created_at": "2020-06-01T20:18:50Z",
      "url": "https://github.com/scrapy/scrapy/pull/4609#discussion_r433466521"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 4574,
      "file_path": "scrapy/http/response/text.py",
      "line": 74,
      "side": "RIGHT",
      "diff_hunk": "@@ -68,6 +69,10 @@ def body_as_unicode(self):\n                       ScrapyDeprecationWarning)\n         return self.text\n \n+    @property\n+    def json(self):\n+        return json.loads(self.text)",
      "comment": "- It should include a docstring, and you should add `.. autoattribute:: TextResponse.json` to `docs/topics/request-response.rst`.\r\n- It\u2019s not a blocker, but I would consider https://github.com/scrapy/scrapy/pull/4460\u2019s caching approach including https://github.com/scrapy/scrapy/pull/4460#discussion_r401033472",
      "comment_id": 424727592,
      "user": "Gallaecio",
      "created_at": "2020-05-13T20:59:31Z",
      "url": "https://github.com/scrapy/scrapy/pull/4574#discussion_r424727592"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 4574,
      "file_path": "scrapy/http/response/text.py",
      "line": 74,
      "side": "RIGHT",
      "diff_hunk": "@@ -68,6 +69,10 @@ def body_as_unicode(self):\n                       ScrapyDeprecationWarning)\n         return self.text\n \n+    @property\n+    def json(self):\n+        return json.loads(self.text)",
      "comment": "Many thanks for the review. Added in https://github.com/scrapy/scrapy/pull/4574/commits/b17a007f3a3d48957fc08e51b4cec483f7494af5",
      "comment_id": 424920777,
      "user": "bulatbulat48",
      "created_at": "2020-05-14T07:19:32Z",
      "url": "https://github.com/scrapy/scrapy/pull/4574#discussion_r424920777"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 4574,
      "file_path": "tests/test_http_response.py",
      "line": 680,
      "side": "RIGHT",
      "diff_hunk": "@@ -669,6 +669,21 @@ def test_body_as_unicode_deprecation_warning(self):\n             self.assertEqual(len(warnings), 1)\n             self.assertEqual(warnings[0].category, ScrapyDeprecationWarning)\n \n+    def test_json_response(self):\n+        json_body = b\"\"\"{\"ip\": \"109.187.217.200\"}\"\"\"\n+        json_response = self.response_class(\"http://www.example.com\", body=json_body)\n+        self.assertEqual(json_response.json(), {'ip': '109.187.217.200'})\n+\n+        json_body = b\"\"\"null\"\"\"\n+        json_response = self.response_class(\"http://www.example.com\", body=json_body)\n+        _NONE = object()\n+        self.assertNotEqual(json_response.json(), _NONE)",
      "comment": "I think this would pass even with the old implementation (`_NONE` here is not the same as `_NONE` in the implementation).\r\n\r\nIn any case, I believe what we need to test is that `json.loads` is only called once when you call `json_response.json()` twice. We probably need to use `mock` here.\r\n",
      "comment_id": 425740168,
      "user": "Gallaecio",
      "created_at": "2020-05-15T11:31:16Z",
      "url": "https://github.com/scrapy/scrapy/pull/4574#discussion_r425740168"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 4574,
      "file_path": "tests/test_http_response.py",
      "line": 680,
      "side": "RIGHT",
      "diff_hunk": "@@ -669,6 +669,21 @@ def test_body_as_unicode_deprecation_warning(self):\n             self.assertEqual(len(warnings), 1)\n             self.assertEqual(warnings[0].category, ScrapyDeprecationWarning)\n \n+    def test_json_response(self):\n+        json_body = b\"\"\"{\"ip\": \"109.187.217.200\"}\"\"\"\n+        json_response = self.response_class(\"http://www.example.com\", body=json_body)\n+        self.assertEqual(json_response.json(), {'ip': '109.187.217.200'})\n+\n+        json_body = b\"\"\"null\"\"\"\n+        json_response = self.response_class(\"http://www.example.com\", body=json_body)\n+        _NONE = object()\n+        self.assertNotEqual(json_response.json(), _NONE)",
      "comment": "@Gallaecio great suggestion, thank you! Added mock test. Please review.",
      "comment_id": 426182717,
      "user": "bulatbulat48",
      "created_at": "2020-05-16T19:19:50Z",
      "url": "https://github.com/scrapy/scrapy/pull/4574#discussion_r426182717"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 4574,
      "file_path": "scrapy/http/response/text.py",
      "line": 81,
      "side": "RIGHT",
      "diff_hunk": "@@ -68,6 +72,15 @@ def body_as_unicode(self):\n                       ScrapyDeprecationWarning)\n         return self.text\n \n+    def json(self):\n+        \"\"\"\n+        Deserialize a JSON document to a Python object.\n+        \"\"\"\n+        if self._cached_decoded_json is _NONE:\n+            self._cached_decoded_json = json.loads(self.text)\n+",
      "comment": "@elacuesta thank you, good catch! Fixed. If possible, can we merge it?",
      "comment_id": 430016601,
      "user": "bulatbulat48",
      "created_at": "2020-05-25T16:48:41Z",
      "url": "https://github.com/scrapy/scrapy/pull/4574#discussion_r430016601"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 4568,
      "file_path": "scrapy/selector/__init__.py",
      "line": 6,
      "side": "RIGHT",
      "diff_hunk": "@@ -1,4 +1,6 @@\n \"\"\"\n Selectors\n \"\"\"\n-from scrapy.selector.unified import *  # noqa: F401\n+\n+# top-level imports\n+from scrapy.selector.unified import Selector, SelectorList",
      "comment": "This is safe, these two classes are the only ones that have been exposed from [the very beginning](https://github.com/scrapy/scrapy/blame/2.1.0/scrapy/selector/unified.py#L11).",
      "comment_id": 426096199,
      "user": "elacuesta",
      "created_at": "2020-05-16T00:21:10Z",
      "url": "https://github.com/scrapy/scrapy/pull/4568#discussion_r426096199"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 2400,
      "file_path": "scrapy/downloadermiddlewares/cookies.py",
      "line": null,
      "side": "RIGHT",
      "diff_hunk": "@@ -81,6 +82,14 @@ def _format_cookie(self, cookie):\n         return cookie_str\n \n     def _get_request_cookies(self, jar, request):\n+        # from 'Cookie' request header\n+        cookie_header = request.headers.get('Cookie', '')\n+        cookie_list = re.split(';\\s*', cookie_header.decode('latin1'))",
      "comment": "Are there stdlib functions to parse cookies?\r\n\r\nAlso, cookies should be UTF-8 in most cases (but other encodings are also possible, so the code must be robust); .decode('latin1') never fails, but I wonder if non-ascii UTF-8 cookies are preserved correctly now. Could you please add a test for it?",
      "comment_id": 88844580,
      "user": "kmike",
      "created_at": "2016-11-21T08:06:24Z",
      "url": "https://github.com/scrapy/scrapy/pull/2400#discussion_r88844580"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 2400,
      "file_path": "tests/test_downloadermiddleware_cookies.py",
      "line": 260,
      "side": "RIGHT",
      "diff_hunk": "@@ -229,3 +229,17 @@ def test_local_domain(self):\n         assert self.mw.process_request(request, self.spider) is None\n         self.assertIn('Cookie', request.headers)\n         self.assertEqual(b'currencyCookie=USD', request.headers['Cookie'])\n+\n+    def test_keep_cookie_header(self):",
      "comment": "could you please also add a test which checks that it works with DEFAULT_HEADERS_MIDDLEWARE?",
      "comment_id": 88844690,
      "user": "kmike",
      "created_at": "2016-11-21T08:07:28Z",
      "url": "https://github.com/scrapy/scrapy/pull/2400#discussion_r88844690"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 2400,
      "file_path": "scrapy/downloadermiddlewares/cookies.py",
      "line": null,
      "side": "RIGHT",
      "diff_hunk": "@@ -81,6 +82,14 @@ def _format_cookie(self, cookie):\n         return cookie_str\n \n     def _get_request_cookies(self, jar, request):\n+        # from 'Cookie' request header\n+        cookie_header = request.headers.get('Cookie', '')\n+        cookie_list = re.split(';\\s*', cookie_header.decode('latin1'))",
      "comment": "It seems like the classes from the `cookielib` module (https://docs.python.org/2/library/cookielib.html#cookiejar-and-filecookiejar-objects) are not useful for extracting cookies from request objects (both `extract_cookies` and `make_cookies` only read cookies from responses).\r\nAlso the classes from the `Cookie` module (https://docs.python.org/2/library/cookie.html#cookie-objects) don't work well in this case:\r\n```\r\n>>> from Cookie import SimpleCookie\r\n>>> c = SimpleCookie()\r\n>>> c.load(u'some=v\u00e2lue'.encode('utf8'))\r\n>>> c\r\n<SimpleCookie: >\r\n>>> c.load('some=value')\r\n>>> c\r\n<SimpleCookie: some='value'>\r\n>>> c.load(u'some=value')\r\nTraceback (most recent call last):\r\n  File \"<stdin>\", line 1, in <module>\r\n  File \"/usr/local/Cellar/python/2.7.11/Frameworks/Python.framework/Versions/2.7/lib/python2.7/Cookie.py\", line 643, in load\r\n    for k, v in rawdata.items():\r\nAttributeError: 'unicode' object has no attribute 'items'\r\n```\r\n\r\nI added a small modification and a test to check non-ascii utf8 chars in https://github.com/scrapy/scrapy/pull/2400/commits/c3a08fe, I hope that's enough :-)",
      "comment_id": 88930199,
      "user": "elacuesta",
      "created_at": "2016-11-21T16:20:32Z",
      "url": "https://github.com/scrapy/scrapy/pull/2400#discussion_r88930199"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 2400,
      "file_path": "scrapy/downloadermiddlewares/cookies.py",
      "line": 106,
      "side": "RIGHT",
      "diff_hunk": "@@ -69,26 +69,60 @@ def _debug_set_cookie(self, response, spider):\n                 msg = \"Received cookies from: {}\\n{}\".format(response, cookies)\n                 logger.debug(msg, extra={'spider': spider})\n \n-    def _format_cookie(self, cookie):\n-        # build cookie string\n-        cookie_str = '%s=%s' % (cookie['name'], cookie['value'])\n-\n-        if cookie.get('path', None):\n-            cookie_str += '; Path=%s' % cookie['path']\n-        if cookie.get('domain', None):\n-            cookie_str += '; Domain=%s' % cookie['domain']\n-\n+    def _format_cookie(self, cookie, request):\n+        \"\"\"\n+        Given a dict consisting of cookie components, return its string representation.\n+        Decode from bytes if necessary.\n+        \"\"\"\n+        decoded = {}\n+        for key in ('name', 'value', 'path', 'domain'):\n+            if not cookie.get(key):\n+                if key in ('name', 'value'):\n+                    msg = 'Invalid cookie found in request {}: {} (\\'{}\\' is missing)'.format(request, cookie, key)\n+                    logger.warning(msg)\n+                    return\n+                continue\n+            if isinstance(cookie[key], six.text_type):\n+                decoded[key] = cookie[key]\n+            else:\n+                try:\n+                    decoded[key] = cookie[key].decode('utf8')\n+                except UnicodeDecodeError:\n+                    logger.warning('Non UTF-8 encoded cookie found in request %s: %s', request, cookie)\n+                    decoded[key] = cookie[key].decode('latin1', errors='replace')\n+\n+        cookie_str = u'{}={}'.format(decoded.pop('name'), decoded.pop('value'))\n+        for key, value in six.iteritems(decoded):  # path, domain\n+            cookie_str += u'; {}={}'.format(key.capitalize(), value)\n         return cookie_str\n \n     def _get_request_cookies(self, jar, request):\n-        if isinstance(request.cookies, dict):\n-            cookie_list = [{'name': k, 'value': v} for k, v in \\\n-                    six.iteritems(request.cookies)]\n-        else:\n-            cookie_list = request.cookies\n-\n-        cookies = [self._format_cookie(x) for x in cookie_list]\n-        headers = {'Set-Cookie': cookies}\n-        response = Response(request.url, headers=headers)\n-\n-        return jar.make_cookies(response, request)\n+        \"\"\"\n+        Extract cookies from a Request. Values from the `Request.cookies` attribute\n+        take precedence over values from the `Cookie` request header.\n+        \"\"\"\n+        def get_cookies_from_header(jar, request):\n+            cookie_header = request.headers.get('Cookie') or b''\n+            cookie_list_bytes = re.split(b';\\s*', cookie_header)",
      "comment": "`_get_request_cookies` is on every request path, considering that we should precompile regexes and exit earlier if `Cookie` header is not set.",
      "comment_id": 266863215,
      "user": "dangra",
      "created_at": "2019-03-19T12:34:28Z",
      "url": "https://github.com/scrapy/scrapy/pull/2400#discussion_r266863215"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 2400,
      "file_path": "scrapy/downloadermiddlewares/cookies.py",
      "line": 21,
      "side": "RIGHT",
      "diff_hunk": "@@ -17,6 +18,7 @@ class CookiesMiddleware(object):\n     def __init__(self, debug=False):\n         self.jars = defaultdict(CookieJar)\n         self.debug = debug\n+        self.re_cookie_header = re.compile(b';\\s*')",
      "comment": "```suggestion\r\n        self.re_cookie_header = re.compile(br';\\s*')\r\n```\r\n\r\nOtherwise, I think it will result in a warning due to `\\s`.\r\n\r\nI also wonder if it would make sense to add `\\s*` before the semicolon as well.",
      "comment_id": 268095558,
      "user": "Gallaecio",
      "created_at": "2019-03-22T09:39:49Z",
      "url": "https://github.com/scrapy/scrapy/pull/2400#discussion_r268095558"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 2400,
      "file_path": "scrapy/downloadermiddlewares/cookies.py",
      "line": 21,
      "side": "RIGHT",
      "diff_hunk": "@@ -17,6 +18,7 @@ class CookiesMiddleware(object):\n     def __init__(self, debug=False):\n         self.jars = defaultdict(CookieJar)\n         self.debug = debug\n+        self.re_cookie_header = re.compile(b';\\s*')",
      "comment": "Changed the approach, not using `re` anymore, `bytes.split` and `bytes.strip` are more efficient in this case.",
      "comment_id": 268373805,
      "user": "elacuesta",
      "created_at": "2019-03-23T00:43:31Z",
      "url": "https://github.com/scrapy/scrapy/pull/2400#discussion_r268373805"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 4559,
      "file_path": "scrapy/signalmanager.py",
      "line": 3,
      "side": "RIGHT",
      "diff_hunk": "@@ -1,6 +1,7 @@\n-from pydispatch import dispatcher\n from scrapy.utils import signal as _signal\n \n+from pydispatch import dispatcher\n+",
      "comment": ":lipstick: Third parties before the current library (Scrapy).",
      "comment_id": 423950089,
      "user": "Gallaecio",
      "created_at": "2020-05-12T18:36:24Z",
      "url": "https://github.com/scrapy/scrapy/pull/4559#discussion_r423950089"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 4559,
      "file_path": "tests/test_engine.py",
      "line": 404,
      "side": "RIGHT",
      "diff_hunk": "@@ -357,6 +369,46 @@ def test_close_engine_spiders_downloader(self):\n         self.assertEqual(len(e.open_spiders), 0)\n \n \n+class CancelledRequestEngineTest(EngineTest):\n+\n+    @defer.inlineCallbacks\n+    def test_crawler(self):\n+        for spider in TestSpider, DictItemsSpider:\n+            self.run = CancelledRequestCrawlerRun(spider)\n+            with LogCapture() as log:\n+                yield self.run.run()\n+                log.check_present((\"scrapy.core.downloader.handlers.http11\",\n+                                   \"DEBUG\",\n+                                   \"Cancelled request <GET http://localhost:{}/redirected> from signal handler\"\n+                                   \" CancelledRequestCrawlerRun.bytes_received\".format(self.run.portno)))\n+                log.check_present((\"scrapy.core.downloader.handlers.http11\",\n+                                   \"DEBUG\",\n+                                   \"Cancelled request <GET http://localhost:{}/> from signal handler\"\n+                                   \" CancelledRequestCrawlerRun.bytes_received\".format(self.run.portno)))\n+                log.check_present((\"scrapy.core.downloader.handlers.http11\",\n+                                   \"DEBUG\",\n+                                   \"Cancelled request <GET http://localhost:{}/numbers> from signal handler\"\n+                                   \" CancelledRequestCrawlerRun.bytes_received\".format(self.run.portno)))\n+            self._assert_visited_urls()\n+            self._assert_scheduled_requests(urls_to_visit=9)\n+            self._assert_downloaded_responses()\n+            self._assert_signals_caught()\n+            self._assert_bytes_received()\n+\n+    def _assert_bytes_received(self):\n+        self.assertEqual(9, len(self.run.bytes))\n+        for request, data in self.run.bytes.items():\n+            joined_data = b\"\".join(data)\n+            self.assertTrue(len(data) == 1)  # signal was fired only once\n+            if self.run.getpath(request.url) == \"/numbers\":\n+                self.assertTrue(len(data) == 1)  # signal was fired only once",
      "comment": "This seems redundant, given the line two lines above.",
      "comment_id": 423951978,
      "user": "Gallaecio",
      "created_at": "2020-05-12T18:39:41Z",
      "url": "https://github.com/scrapy/scrapy/pull/4559#discussion_r423951978"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 4559,
      "file_path": "scrapy/signalmanager.py",
      "line": 3,
      "side": "RIGHT",
      "diff_hunk": "@@ -1,6 +1,7 @@\n-from pydispatch import dispatcher\n from scrapy.utils import signal as _signal\n \n+from pydispatch import dispatcher\n+",
      "comment": "I don't even know how this change got here! :shrug: ",
      "comment_id": 423976678,
      "user": "elacuesta",
      "created_at": "2020-05-12T19:22:14Z",
      "url": "https://github.com/scrapy/scrapy/pull/4559#discussion_r423976678"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 4559,
      "file_path": "scrapy/core/downloader/handlers/http11.py",
      "line": 449,
      "side": "RIGHT",
      "diff_hunk": "@@ -440,6 +441,14 @@ def _cb_bodydone(self, result, request, url):\n             certificate=result[\"certificate\"],\n             ip_address=result[\"ip_address\"],\n         )\n+        if result.get(\"failure\"):\n+            # This failure is not the same object that will reach the errback,\n+            # so we need to temporarily store the response in the exception.\n+            # It will be moved to the failure in core/scraper.py\n+            failure = result[\"failure\"]\n+            failure.value.response = response",
      "comment": "I wish I could do `failure.response = response`, but the attribute gets lost somewhere and it doesn't reach the errback. I'm open to suggestions if you can think of a more elegant alternative.",
      "comment_id": 425334750,
      "user": "elacuesta",
      "created_at": "2020-05-14T18:07:29Z",
      "url": "https://github.com/scrapy/scrapy/pull/4559#discussion_r425334750"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 4559,
      "file_path": "scrapy/core/downloader/handlers/http11.py",
      "line": 450,
      "side": "RIGHT",
      "diff_hunk": "@@ -440,6 +441,14 @@ def _cb_bodydone(self, result, request, url):\n             certificate=result[\"certificate\"],\n             ip_address=result[\"ip_address\"],\n         )\n+        if result.get(\"failure\"):\n+            # This failure is not the same object that will reach the errback,\n+            # so we need to temporarily store the response in the exception.\n+            # It will be moved to the failure in core/scraper.py\n+            failure = result[\"failure\"]\n+            failure.value.response = response\n+            raise failure",
      "comment": "hm, I was not aware raising a Failure instances directly is what people do.. Could you please double-check that it doesn't cause any issues, as compared to e.g. calling a method on failure to raise an exception? Or maybe it is possible to return a failure instead of raising it? Sorry, I'm clueless :)",
      "comment_id": 427575141,
      "user": "kmike",
      "created_at": "2020-05-19T20:19:50Z",
      "url": "https://github.com/scrapy/scrapy/pull/4559#discussion_r427575141"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 4559,
      "file_path": "scrapy/core/downloader/handlers/http11.py",
      "line": 450,
      "side": "RIGHT",
      "diff_hunk": "@@ -440,6 +441,14 @@ def _cb_bodydone(self, result, request, url):\n             certificate=result[\"certificate\"],\n             ip_address=result[\"ip_address\"],\n         )\n+        if result.get(\"failure\"):\n+            # This failure is not the same object that will reach the errback,\n+            # so we need to temporarily store the response in the exception.\n+            # It will be moved to the failure in core/scraper.py\n+            failure = result[\"failure\"]\n+            failure.value.response = response\n+            raise failure",
      "comment": "I _believe_ it is the same thing, but I'm not 100% sure so don't quote me on that. Tests are not affected by this change, but in any case, let's play it safe and return instead. I hoped it would have been the key to resolve https://github.com/scrapy/scrapy/pull/4559#discussion_r425334750, but sadly it is not.",
      "comment_id": 427623469,
      "user": "elacuesta",
      "created_at": "2020-05-19T21:55:56Z",
      "url": "https://github.com/scrapy/scrapy/pull/4559#discussion_r427623469"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 4559,
      "file_path": "scrapy/core/scraper.py",
      "line": 157,
      "side": "RIGHT",
      "diff_hunk": "@@ -147,6 +147,14 @@ def _scrape2(self, request_result, request, spider):\n \n     def call_spider(self, result, request, spider):\n         result.request = request\n+        # StopDownload exceptions: make the partial response an attribute of the failure\n+        if (\n+            isinstance(result, Failure)\n+            and isinstance(result.value, StopDownload)\n+            and hasattr(result.value, \"response\")\n+        ):\n+            result.response = result.value.response\n+            delattr(result.value, \"response\")",
      "comment": "No reason in particular, I just didn't think of it. Do you think `del` is more readable than `dellattr`? I don't really have a strong opinion on this.",
      "comment_id": 427624503,
      "user": "elacuesta",
      "created_at": "2020-05-19T21:58:13Z",
      "url": "https://github.com/scrapy/scrapy/pull/4559#discussion_r427624503"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 4559,
      "file_path": "scrapy/core/scraper.py",
      "line": 157,
      "side": "RIGHT",
      "diff_hunk": "@@ -147,6 +147,14 @@ def _scrape2(self, request_result, request, spider):\n \n     def call_spider(self, result, request, spider):\n         result.request = request\n+        # StopDownload exceptions: make the partial response an attribute of the failure\n+        if (\n+            isinstance(result, Failure)\n+            and isinstance(result.value, StopDownload)\n+            and hasattr(result.value, \"response\")\n+        ):\n+            result.response = result.value.response\n+            delattr(result.value, \"response\")",
      "comment": "I think the main difference is that delattr allows arbitrary string variables, while del needs a Python expression. So for me delattr here feels like using `setattr(foo, \"bar\", 5)` instead of `foo.bar = 5`. \r\n\r\nOn the other hand, with `delattr(result.value, \"response\")` is is more clear that we're deleting the response attribute, while with `del result.value.response` it is not immediately clear what's being deleted.\r\n\r\nSo that's fine to keep it as-is as well :)",
      "comment_id": 427626362,
      "user": "kmike",
      "created_at": "2020-05-19T22:02:35Z",
      "url": "https://github.com/scrapy/scrapy/pull/4559#discussion_r427626362"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 4559,
      "file_path": "scrapy/core/scraper.py",
      "line": 156,
      "side": "RIGHT",
      "diff_hunk": "@@ -147,6 +147,14 @@ def _scrape2(self, request_result, request, spider):\n \n     def call_spider(self, result, request, spider):\n         result.request = request\n+        # StopDownload exceptions: make the partial response an attribute of the failure\n+        if (\n+            isinstance(result, Failure)\n+            and isinstance(result.value, StopDownload)\n+            and hasattr(result.value, \"response\")\n+        ):\n+            result.response = result.value.response",
      "comment": "Actually I wonder if we should just keep failure.value.response as-is. This seems to be consistent with https://docs.scrapy.org/en/latest/topics/request-response.html#using-errbacks-to-catch-exceptions-in-request-processing example.",
      "comment_id": 430733143,
      "user": "kmike",
      "created_at": "2020-05-26T22:04:01Z",
      "url": "https://github.com/scrapy/scrapy/pull/4559#discussion_r430733143"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 4559,
      "file_path": "scrapy/core/downloader/handlers/http11.py",
      "line": 449,
      "side": "RIGHT",
      "diff_hunk": "@@ -440,6 +441,14 @@ def _cb_bodydone(self, result, request, url):\n             certificate=result[\"certificate\"],\n             ip_address=result[\"ip_address\"],\n         )\n+        if result.get(\"failure\"):\n+            # This failure is not the same object that will reach the errback,\n+            # so we need to temporarily store the response in the exception.\n+            # It will be moved to the failure in core/scraper.py\n+            failure = result[\"failure\"]\n+            failure.value.response = response",
      "comment": "This seems to be consistent with https://docs.scrapy.org/en/latest/topics/request-response.html#using-errbacks-to-catch-exceptions-in-request-processing, so I wonder if we just document that the way to get a response in a callback is failure.value.response when StopException is received.",
      "comment_id": 430734006,
      "user": "kmike",
      "created_at": "2020-05-26T22:06:14Z",
      "url": "https://github.com/scrapy/scrapy/pull/4559#discussion_r430734006"
    },
    {
      "repo": "scrapy/scrapy",
      "pr_number": 4559,
      "file_path": "scrapy/core/scraper.py",
      "line": 156,
      "side": "RIGHT",
      "diff_hunk": "@@ -147,6 +147,14 @@ def _scrape2(self, request_result, request, spider):\n \n     def call_spider(self, result, request, spider):\n         result.request = request\n+        # StopDownload exceptions: make the partial response an attribute of the failure\n+        if (\n+            isinstance(result, Failure)\n+            and isinstance(result.value, StopDownload)\n+            and hasattr(result.value, \"response\")\n+        ):\n+            result.response = result.value.response",
      "comment": "Good catch. It would make this change simpler too.",
      "comment_id": 431129473,
      "user": "elacuesta",
      "created_at": "2020-05-27T13:27:07Z",
      "url": "https://github.com/scrapy/scrapy/pull/4559#discussion_r431129473"
    }
  ]
}