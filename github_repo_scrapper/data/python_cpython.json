{
  "repo": "python/cpython",
  "scraped_at": "2026-02-03T14:05:36.838118",
  "stats": {
    "total_comments": 760,
    "filtered": {
      "not_python": 377,
      "too_short": 150,
      "no_diff_hunk": 12,
      "too_long": 2,
      "skip_pattern:thank you": 1,
      "skip_pattern:looks good": 1,
      "skip_pattern:thanks!": 1,
      "skip_pattern:+1": 1
    },
    "kept": 215
  },
  "examples": [
    {
      "repo": "python/cpython",
      "pr_number": 144393,
      "file_path": "Lib/test/test_xpickle.py",
      "line": 128,
      "side": "RIGHT",
      "diff_hunk": "@@ -101,8 +113,31 @@ def setUpClass(cls):\n         cls.enterClassContext(support.swap_attr(pickle, 'HIGHEST_PROTOCOL',\n                                                 highest_protocol))\n \n-    @staticmethod\n-    def send_to_worker(python, data):\n+    @classmethod\n+    def start_worker(cls):\n+        target = os.path.join(os.path.dirname(__file__), 'xpickle_worker.py')\n+        worker = subprocess.Popen([*python, target],\n+                                  stdin=subprocess.PIPE,\n+                                  stdout=subprocess.PIPE,\n+                                  stderr=subprocess.PIPE,\n+                                  # For windows bpo-17023.\n+                                  shell=is_windows)\n+        cls.worker = worker\n+\n+    @classmethod\n+    def close_worker(cls):",
      "comment": "\"stop_worker()\" name would be better to have start/stop_worker methods.",
      "comment_id": 2754196212,
      "user": "vstinner",
      "created_at": "2026-02-02T12:54:23Z",
      "url": "https://github.com/python/cpython/pull/144393#discussion_r2754196212"
    },
    {
      "repo": "python/cpython",
      "pr_number": 144393,
      "file_path": "Lib/test/test_xpickle.py",
      "line": 124,
      "side": "RIGHT",
      "diff_hunk": "@@ -101,8 +113,31 @@ def setUpClass(cls):\n         cls.enterClassContext(support.swap_attr(pickle, 'HIGHEST_PROTOCOL',\n                                                 highest_protocol))\n \n-    @staticmethod\n-    def send_to_worker(python, data):\n+    @classmethod\n+    def start_worker(cls):\n+        target = os.path.join(os.path.dirname(__file__), 'xpickle_worker.py')\n+        worker = subprocess.Popen([*python, target],\n+                                  stdin=subprocess.PIPE,\n+                                  stdout=subprocess.PIPE,\n+                                  stderr=subprocess.PIPE,\n+                                  # For windows bpo-17023.\n+                                  shell=is_windows)",
      "comment": "You should use `text=True` to fix this code below:\n\n```py\n            _, stderr = worker.communicate()\n            raise RuntimeError(stderr)\n```",
      "comment_id": 2754219881,
      "user": "vstinner",
      "created_at": "2026-02-02T13:00:32Z",
      "url": "https://github.com/python/cpython/pull/144393#discussion_r2754219881"
    },
    {
      "repo": "python/cpython",
      "pr_number": 144393,
      "file_path": "Lib/test/test_xpickle.py",
      "line": 153,
      "side": "RIGHT",
      "diff_hunk": "@@ -112,33 +147,40 @@ def send_to_worker(python, data):\n         Returns:\n             The pickled data received from the child process.\n         \"\"\"\n-        target = os.path.join(os.path.dirname(__file__), 'xpickle_worker.py')\n-        worker = subprocess.Popen([*python, target],\n-                                  stdin=subprocess.PIPE,\n-                                  stdout=subprocess.PIPE,\n-                                  stderr=subprocess.PIPE,\n-                                  # For windows bpo-17023.\n-                                  shell=is_windows)\n-        stdout, stderr = worker.communicate(data)\n-        if worker.returncode == 0:\n-            return stdout\n-        # if the worker fails, it will write the exception to stdout\n+        worker = cls.worker\n+        if worker is None:\n+            target = os.path.join(os.path.dirname(__file__), 'xpickle_worker.py')\n+            worker = subprocess.Popen([*python, target],",
      "comment": "Oh, this is a remnant. I was not sure whether it is worth to move this code out into a method.",
      "comment_id": 2754305335,
      "user": "serhiy-storchaka",
      "created_at": "2026-02-02T13:21:09Z",
      "url": "https://github.com/python/cpython/pull/144393#discussion_r2754305335"
    },
    {
      "repo": "python/cpython",
      "pr_number": 144393,
      "file_path": "Lib/test/test_xpickle.py",
      "line": 124,
      "side": "RIGHT",
      "diff_hunk": "@@ -101,8 +113,31 @@ def setUpClass(cls):\n         cls.enterClassContext(support.swap_attr(pickle, 'HIGHEST_PROTOCOL',\n                                                 highest_protocol))\n \n-    @staticmethod\n-    def send_to_worker(python, data):\n+    @classmethod\n+    def start_worker(cls):\n+        target = os.path.join(os.path.dirname(__file__), 'xpickle_worker.py')\n+        worker = subprocess.Popen([*python, target],\n+                                  stdin=subprocess.PIPE,\n+                                  stdout=subprocess.PIPE,\n+                                  stderr=subprocess.PIPE,\n+                                  # For windows bpo-17023.\n+                                  shell=is_windows)",
      "comment": "But we do binary IO for stdin/stdout in normal case.\n\nThis code is only for troubleshooting. It is not executed when the tests pass.",
      "comment_id": 2754317977,
      "user": "serhiy-storchaka",
      "created_at": "2026-02-02T13:24:17Z",
      "url": "https://github.com/python/cpython/pull/144393#discussion_r2754317977"
    },
    {
      "repo": "python/cpython",
      "pr_number": 103678,
      "file_path": "Lib/argparse.py",
      "line": 923,
      "side": "RIGHT",
      "diff_hunk": "@@ -901,6 +904,24 @@ def __init__(self,\n                 option_string = '--no-' + option_string[2:]\n                 _option_strings.append(option_string)\n \n+        # We need `_deprecated` special value to ban explicit arguments that\n+        # match default value. Like:\n+        #   parser.add_argument('-f', action=BooleanOptionalAction, type=int)\n+        for field_name in ('type', 'choices', 'metavar'):\n+            if locals()[field_name] is not _deprecated_default:\n+                warnings._deprecated(\n+                    field_name,\n+                    \"{name!r} is deprecated as of Python 3.12 and will be \"\n+                    \"removed in Python {remove}.\",\n+                    remove=(3, 14))\n+\n+        if type is _deprecated_default:\n+            type = None\n+        if choices is _deprecated_default:\n+            choices = None\n+        if metavar is _deprecated_default:\n+            metavar = None",
      "comment": "Could we remove these three if checks and reset all three back to `None`, with a comment? ",
      "comment_id": 1181374360,
      "user": "hugovk",
      "created_at": "2023-05-01T03:49:08Z",
      "url": "https://github.com/python/cpython/pull/103678#discussion_r1181374360"
    },
    {
      "repo": "python/cpython",
      "pr_number": 103678,
      "file_path": "Lib/argparse.py",
      "line": 923,
      "side": "RIGHT",
      "diff_hunk": "@@ -901,6 +904,24 @@ def __init__(self,\n                 option_string = '--no-' + option_string[2:]\n                 _option_strings.append(option_string)\n \n+        # We need `_deprecated` special value to ban explicit arguments that\n+        # match default value. Like:\n+        #   parser.add_argument('-f', action=BooleanOptionalAction, type=int)\n+        for field_name in ('type', 'choices', 'metavar'):\n+            if locals()[field_name] is not _deprecated_default:\n+                warnings._deprecated(\n+                    field_name,\n+                    \"{name!r} is deprecated as of Python 3.12 and will be \"\n+                    \"removed in Python {remove}.\",\n+                    remove=(3, 14))\n+\n+        if type is _deprecated_default:\n+            type = None\n+        if choices is _deprecated_default:\n+            choices = None\n+        if metavar is _deprecated_default:\n+            metavar = None",
      "comment": "It feels safer not to do that. Right now my change does not change any behavior (for subclasses, etc). But, setting these 3 params to `None` without conditions might change it for some corner cases. So, I would rather not :)",
      "comment_id": 1181446122,
      "user": "sobolevn",
      "created_at": "2023-05-01T07:49:50Z",
      "url": "https://github.com/python/cpython/pull/103678#discussion_r1181446122"
    },
    {
      "repo": "python/cpython",
      "pr_number": 139582,
      "file_path": "Apple/__main__.py",
      "line": 316,
      "side": "RIGHT",
      "diff_hunk": "@@ -312,11 +312,18 @@ def unpack_deps(\n     On iOS, as a safety mechanism, any dynamic libraries will be purged from\n     the unpacked dependencies.\n     \"\"\"\n+    # To create new builds of these dependencies, usually all that's necessary\n+    # is to push a tag to the cpython-apple-source-deps repository, and GitHub",
      "comment": "Looks like for this one it's more of pushing a simple Makefile update (and a tag) rather than just a tag.",
      "comment_id": 2404226993,
      "user": "zware",
      "created_at": "2025-10-05T01:08:52Z",
      "url": "https://github.com/python/cpython/pull/139582#discussion_r2404226993"
    },
    {
      "repo": "python/cpython",
      "pr_number": 139582,
      "file_path": "Apple/__main__.py",
      "line": 321,
      "side": "RIGHT",
      "diff_hunk": "@@ -312,11 +312,18 @@ def unpack_deps(\n     On iOS, as a safety mechanism, any dynamic libraries will be purged from\n     the unpacked dependencies.\n     \"\"\"\n+    # To create new builds of these dependencies, usually all that's necessary\n+    # is to push a tag to the cpython-apple-source-deps repository, and GitHub\n+    # Actions will do the rest.\n+    #\n+    # If you're a member of the Python core team, and you'd like to be able to\n+    # push these tags yourself, please contact Malcolm Smith or Russell\n+    # Keith-Magee.",
      "comment": "If you're looking for an increase of bus factor for these, I'm happy to oblige :)",
      "comment_id": 2404227043,
      "user": "zware",
      "created_at": "2025-10-05T01:09:17Z",
      "url": "https://github.com/python/cpython/pull/139582#discussion_r2404227043"
    },
    {
      "repo": "python/cpython",
      "pr_number": 139582,
      "file_path": "Apple/__main__.py",
      "line": 316,
      "side": "RIGHT",
      "diff_hunk": "@@ -312,11 +312,18 @@ def unpack_deps(\n     On iOS, as a safety mechanism, any dynamic libraries will be purged from\n     the unpacked dependencies.\n     \"\"\"\n+    # To create new builds of these dependencies, usually all that's necessary\n+    # is to push a tag to the cpython-apple-source-deps repository, and GitHub",
      "comment": "It will actually work on a tag; the Makefile does encode the \"default\" for the purposes of other CI checks, but a tag is sufficient to make the release. \r\n\r\nOf course, a PR doesn't *hurt*, either.",
      "comment_id": 2404227613,
      "user": "freakboy3742",
      "created_at": "2025-10-05T01:12:02Z",
      "url": "https://github.com/python/cpython/pull/139582#discussion_r2404227613"
    },
    {
      "repo": "python/cpython",
      "pr_number": 139582,
      "file_path": "Apple/__main__.py",
      "line": 321,
      "side": "RIGHT",
      "diff_hunk": "@@ -312,11 +312,18 @@ def unpack_deps(\n     On iOS, as a safety mechanism, any dynamic libraries will be purged from\n     the unpacked dependencies.\n     \"\"\"\n+    # To create new builds of these dependencies, usually all that's necessary\n+    # is to push a tag to the cpython-apple-source-deps repository, and GitHub\n+    # Actions will do the rest.\n+    #\n+    # If you're a member of the Python core team, and you'd like to be able to\n+    # push these tags yourself, please contact Malcolm Smith or Russell\n+    # Keith-Magee.",
      "comment": "I've sent you an invite to both the Apple and Android repos. Hugo, Gregory and Erlend already had access to the Android repo.",
      "comment_id": 2404228040,
      "user": "freakboy3742",
      "created_at": "2025-10-05T01:14:39Z",
      "url": "https://github.com/python/cpython/pull/139582#discussion_r2404228040"
    },
    {
      "repo": "python/cpython",
      "pr_number": 118655,
      "file_path": "Lib/test/test_cmd_line.py",
      "line": 1062,
      "side": "RIGHT",
      "diff_hunk": "@@ -1054,6 +1054,20 @@ def test_cpu_count_default(self):\n         res = assert_python_ok('-c', code, PYTHON_CPU_COUNT='default')\n         self.assertEqual(self.res2int(res), (os.cpu_count(), os.process_cpu_count()))\n \n+    def test_import_time(self):\n+        code = \"import os\"\n+        res = assert_python_ok('-X', 'importtime', '-c', code)\n+        self.assertRegex(\n+            res.err.decode(\"utf-8\"),\n+            r\"import time: \\s*\\d+ | \\s*\\d+ | \\s*os\"",
      "comment": "It would be nice to check that this line occurs only once.\r\n\r\nYou can also check that the line with \"cached\" is not output.",
      "comment_id": 1744871343,
      "user": "serhiy-storchaka",
      "created_at": "2024-09-05T06:24:47Z",
      "url": "https://github.com/python/cpython/pull/118655#discussion_r1744871343"
    },
    {
      "repo": "python/cpython",
      "pr_number": 118655,
      "file_path": "Lib/test/test_cmd_line.py",
      "line": 1062,
      "side": "RIGHT",
      "diff_hunk": "@@ -1054,6 +1054,20 @@ def test_cpu_count_default(self):\n         res = assert_python_ok('-c', code, PYTHON_CPU_COUNT='default')\n         self.assertEqual(self.res2int(res), (os.cpu_count(), os.process_cpu_count()))\n \n+    def test_import_time(self):\n+        code = \"import os\"\n+        res = assert_python_ok('-X', 'importtime', '-c', code)\n+        self.assertRegex(\n+            res.err.decode(\"utf-8\"),\n+            r\"import time: \\s*\\d+ | \\s*\\d+ | \\s*os\"",
      "comment": "I've added a check to ensure `-Ximporttime` does not include `=2` output. I added a rudimentary check that `-Ximporttime` only shows `os` once, though this may be flaky if the structure of the `os` module changes.",
      "comment_id": 1781837648,
      "user": "noahbkim",
      "created_at": "2024-09-30T22:04:51Z",
      "url": "https://github.com/python/cpython/pull/118655#discussion_r1781837648"
    },
    {
      "repo": "python/cpython",
      "pr_number": 118655,
      "file_path": "Lib/_pyrepl/unix_console.py",
      "line": 43,
      "side": "RIGHT",
      "diff_hunk": "@@ -39,6 +40,13 @@\n from .unix_eventqueue import EventQueue\n from .utils import wlen\n \n+# declare posix optional to allow None assignment on other platforms",
      "comment": "I think it's just easier to have a `# type: ignore[...]` instead of a type annotation.",
      "comment_id": 1913883627,
      "user": "picnixz",
      "created_at": "2025-01-13T22:28:15Z",
      "url": "https://github.com/python/cpython/pull/118655#discussion_r1913883627"
    },
    {
      "repo": "python/cpython",
      "pr_number": 118655,
      "file_path": "Lib/_pyrepl/unix_console.py",
      "line": 43,
      "side": "RIGHT",
      "diff_hunk": "@@ -39,6 +40,13 @@\n from .unix_eventqueue import EventQueue\n from .utils import wlen\n \n+# declare posix optional to allow None assignment on other platforms",
      "comment": "for what it's worth, doing so requires two mypy ignores, one at import time and one for the `posix is not None` check, which triggers `[redundant]`",
      "comment_id": 1915197627,
      "user": "noahbkim",
      "created_at": "2025-01-14T16:32:01Z",
      "url": "https://github.com/python/cpython/pull/118655#discussion_r1915197627"
    },
    {
      "repo": "python/cpython",
      "pr_number": 118655,
      "file_path": "Lib/_pyrepl/unix_console.py",
      "line": 43,
      "side": "RIGHT",
      "diff_hunk": "@@ -39,6 +40,13 @@\n from .unix_eventqueue import EventQueue\n from .utils import wlen\n \n+# declare posix optional to allow None assignment on other platforms",
      "comment": "Ah, I thought it was a single ignore that would be needed =/ I will leave it to @pablogsal's choice as he's one the REPL maintainers. I would honestly prefer keeping two `# type: ignore[]` because that saves an import to `types` (*if* we keep the type annotation, I think *every* REPL session will import `types` (if the latter is already imported, it doesn't matter but I don't think it's imported))",
      "comment_id": 1915206598,
      "user": "picnixz",
      "created_at": "2025-01-14T16:36:48Z",
      "url": "https://github.com/python/cpython/pull/118655#discussion_r1915206598"
    },
    {
      "repo": "python/cpython",
      "pr_number": 118655,
      "file_path": "Lib/_pyrepl/unix_console.py",
      "line": 43,
      "side": "RIGHT",
      "diff_hunk": "@@ -39,6 +40,13 @@\n from .unix_eventqueue import EventQueue\n from .utils import wlen\n \n+# declare posix optional to allow None assignment on other platforms",
      "comment": "iirc, `types` is either a) not a real module or b) already loaded at interpreter start, so this shouldn't be a big deal. a rudimentary test:\r\n\r\n```\r\n>>> timeit.timeit(\"import sys\")\r\n0.3161898439284414\r\n>>> timeit.timeit(\"import types\")\r\n0.05900560016743839\r\n```",
      "comment_id": 1915225527,
      "user": "noahbkim",
      "created_at": "2025-01-14T16:44:17Z",
      "url": "https://github.com/python/cpython/pull/118655#discussion_r1915225527"
    },
    {
      "repo": "python/cpython",
      "pr_number": 118655,
      "file_path": "Lib/_pyrepl/unix_console.py",
      "line": 43,
      "side": "RIGHT",
      "diff_hunk": "@@ -39,6 +40,13 @@\n from .unix_eventqueue import EventQueue\n from .utils import wlen\n \n+# declare posix optional to allow None assignment on other platforms",
      "comment": "I'm not on my dev session but what does `-X importtime` shows when just doing `python -X importtime -c 'pass'`? does it show `types` or not?",
      "comment_id": 1915233937,
      "user": "picnixz",
      "created_at": "2025-01-14T16:48:39Z",
      "url": "https://github.com/python/cpython/pull/118655#discussion_r1915233937"
    },
    {
      "repo": "python/cpython",
      "pr_number": 118655,
      "file_path": "Lib/_pyrepl/unix_console.py",
      "line": 43,
      "side": "RIGHT",
      "diff_hunk": "@@ -39,6 +40,13 @@\n from .unix_eventqueue import EventQueue\n from .utils import wlen\n \n+# declare posix optional to allow None assignment on other platforms",
      "comment": "it does not show `types`, but `python -X importtime -i -c 'pass'` does \r\n\r\n```\r\nimport time:      1098 |       1098 | readline\r\nimport time:        32 |         32 |   atexit\r\nimport time:       251 |        251 |           types\r\n```\r\n\r\nso it's probably fine in this context?",
      "comment_id": 1915281413,
      "user": "noahbkim",
      "created_at": "2025-01-14T17:14:49Z",
      "url": "https://github.com/python/cpython/pull/118655#discussion_r1915281413"
    },
    {
      "repo": "python/cpython",
      "pr_number": 118655,
      "file_path": "Lib/_pyrepl/unix_console.py",
      "line": 43,
      "side": "RIGHT",
      "diff_hunk": "@@ -39,6 +40,13 @@\n from .unix_eventqueue import EventQueue\n from .utils import wlen\n \n+# declare posix optional to allow None assignment on other platforms",
      "comment": "Oh ok it's fine. It's imported because of `ast` which is needed by the REPL itself I think, right? So we can leave the import to `types` where it's needed.",
      "comment_id": 1915297672,
      "user": "picnixz",
      "created_at": "2025-01-14T17:24:20Z",
      "url": "https://github.com/python/cpython/pull/118655#discussion_r1915297672"
    },
    {
      "repo": "python/cpython",
      "pr_number": 118655,
      "file_path": "Lib/_pyrepl/unix_console.py",
      "line": 580,
      "side": "RIGHT",
      "diff_hunk": "@@ -566,11 +574,9 @@ def clear(self):\n \n     @property\n     def input_hook(self):\n-        try:\n-            import posix\n-        except ImportError:\n-            return None\n-        if posix._is_inputhook_installed():\n+        # avoid inline imports here so the repl doesn't get flooded with import\n+        # logging from -Ximporttime=2\n+        if posix is not None and posix._is_inputhook_installed():\n             return posix._inputhook",
      "comment": "perhaps use `try`/`except NameError` here, instead of the `None` checks?",
      "comment_id": 2023226712,
      "user": "AA-Turner",
      "created_at": "2025-04-01T16:51:23Z",
      "url": "https://github.com/python/cpython/pull/118655#discussion_r2023226712"
    },
    {
      "repo": "python/cpython",
      "pr_number": 118655,
      "file_path": "Lib/_pyrepl/unix_console.py",
      "line": 580,
      "side": "RIGHT",
      "diff_hunk": "@@ -566,11 +574,9 @@ def clear(self):\n \n     @property\n     def input_hook(self):\n-        try:\n-            import posix\n-        except ImportError:\n-            return None\n-        if posix._is_inputhook_installed():\n+        # avoid inline imports here so the repl doesn't get flooded with import\n+        # logging from -Ximporttime=2\n+        if posix is not None and posix._is_inputhook_installed():\n             return posix._inputhook",
      "comment": "to me that feels like too broad of an `except`, for example it would suppress a desired exception in the event that the `posix` API changes.",
      "comment_id": 2023482968,
      "user": "noahbkim",
      "created_at": "2025-04-01T18:33:34Z",
      "url": "https://github.com/python/cpython/pull/118655#discussion_r2023482968"
    },
    {
      "repo": "python/cpython",
      "pr_number": 118655,
      "file_path": "Lib/_pyrepl/unix_console.py",
      "line": 580,
      "side": "RIGHT",
      "diff_hunk": "@@ -566,11 +574,9 @@ def clear(self):\n \n     @property\n     def input_hook(self):\n-        try:\n-            import posix\n-        except ImportError:\n-            return None\n-        if posix._is_inputhook_installed():\n+        # avoid inline imports here so the repl doesn't get flooded with import\n+        # logging from -Ximporttime=2\n+        if posix is not None and posix._is_inputhook_installed():\n             return posix._inputhook",
      "comment": "The `is not None` check is shorter than a try:except: block. Let's leave as is.",
      "comment_id": 2023548536,
      "user": "ambv",
      "created_at": "2025-04-01T19:21:26Z",
      "url": "https://github.com/python/cpython/pull/118655#discussion_r2023548536"
    },
    {
      "repo": "python/cpython",
      "pr_number": 118655,
      "file_path": "Lib/_pyrepl/unix_console.py",
      "line": 577,
      "side": "RIGHT",
      "diff_hunk": "@@ -566,11 +574,9 @@ def clear(self):\n \n     @property\n     def input_hook(self):\n-        try:\n-            import posix\n-        except ImportError:\n-            return None\n-        if posix._is_inputhook_installed():\n+        # avoid inline imports here so the repl doesn't get flooded with import",
      "comment": "A similar change might be needed for `WindowsConsole.input_hook`:\r\nhttps://github.com/python/cpython/blob/b8633f9aca9b198e5592106b649389d638cbc620/Lib/_pyrepl/windows_console.py#L236-L243",
      "comment_id": 2071102969,
      "user": "chris-eibl",
      "created_at": "2025-05-02T05:09:40Z",
      "url": "https://github.com/python/cpython/pull/118655#discussion_r2071102969"
    },
    {
      "repo": "python/cpython",
      "pr_number": 118655,
      "file_path": "Lib/_pyrepl/unix_console.py",
      "line": 577,
      "side": "RIGHT",
      "diff_hunk": "@@ -566,11 +574,9 @@ def clear(self):\n \n     @property\n     def input_hook(self):\n-        try:\n-            import posix\n-        except ImportError:\n-            return None\n-        if posix._is_inputhook_installed():\n+        # avoid inline imports here so the repl doesn't get flooded with import",
      "comment": "Good catch, thanks for taking a look. I can verify this on my PC over the weekend.",
      "comment_id": 2071717498,
      "user": "noahbkim",
      "created_at": "2025-05-02T14:41:48Z",
      "url": "https://github.com/python/cpython/pull/118655#discussion_r2071717498"
    },
    {
      "repo": "python/cpython",
      "pr_number": 118655,
      "file_path": "Lib/_pyrepl/windows_console.py",
      "line": 131,
      "side": "RIGHT",
      "diff_hunk": "@@ -121,9 +128,8 @@ class _error(Exception):\n \n def _supports_vt():\n     try:\n-        import nt\n-        return nt._supports_virtual_terminal()\n-    except (ImportError, AttributeError):\n+        nt._supports_virtual_terminal()",
      "comment": "```suggestion\r\n        return nt._supports_virtual_terminal()\r\n```\r\nThis is missing a return and would never enable virtual terminal anymore.",
      "comment_id": 2072312449,
      "user": "chris-eibl",
      "created_at": "2025-05-03T04:02:09Z",
      "url": "https://github.com/python/cpython/pull/118655#discussion_r2072312449"
    },
    {
      "repo": "python/cpython",
      "pr_number": 144394,
      "file_path": "Lib/test/test_capi/test_opt.py",
      "line": 1208,
      "side": "LEFT",
      "diff_hunk": "@@ -1193,19 +1189,8 @@ def testfunc(n):\n         self.assertEqual(uop_names.count(\"_RETURN_VALUE\"), 15)\n \n         self.assertEqual(uop_names.count(\"_CHECK_STACK_SPACE\"), 0)\n-        self.assertEqual(uop_names.count(\"_CHECK_STACK_SPACE_OPERAND\"), 1)\n-        largest_stack = (\n-            _testinternalcapi.get_co_framesize(dummy6.__code__) +\n-            _testinternalcapi.get_co_framesize(dummy5.__code__) +\n-            _testinternalcapi.get_co_framesize(dummy2.__code__) +\n-            _testinternalcapi.get_co_framesize(dummy1.__code__) +\n-            _testinternalcapi.get_co_framesize(dummy0.__code__)\n-        )\n-        self.assertIn(\n-            (\"_CHECK_STACK_SPACE_OPERAND\", largest_stack), uops_and_operands\n-        )\n+        self.assertEqual(uop_names.count(\"_CHECK_STACK_SPACE_OPERAND\"), 15)\n \n-    @unittest.skip(\"gh-139109 WIP\")",
      "comment": "Is it still necessary to retain these tests? I thinks these tests primarily test the logic on converting multiple `_CHECK_STACK_SPACEs` into a single `_CHECK_STACK_SPACE_OPERAND`. ",
      "comment_id": 2754604472,
      "user": "cocolato",
      "created_at": "2026-02-02T14:24:59Z",
      "url": "https://github.com/python/cpython/pull/144394#discussion_r2754604472"
    },
    {
      "repo": "python/cpython",
      "pr_number": 144394,
      "file_path": "Lib/test/test_capi/test_opt.py",
      "line": 1208,
      "side": "LEFT",
      "diff_hunk": "@@ -1193,19 +1189,8 @@ def testfunc(n):\n         self.assertEqual(uop_names.count(\"_RETURN_VALUE\"), 15)\n \n         self.assertEqual(uop_names.count(\"_CHECK_STACK_SPACE\"), 0)\n-        self.assertEqual(uop_names.count(\"_CHECK_STACK_SPACE_OPERAND\"), 1)\n-        largest_stack = (\n-            _testinternalcapi.get_co_framesize(dummy6.__code__) +\n-            _testinternalcapi.get_co_framesize(dummy5.__code__) +\n-            _testinternalcapi.get_co_framesize(dummy2.__code__) +\n-            _testinternalcapi.get_co_framesize(dummy1.__code__) +\n-            _testinternalcapi.get_co_framesize(dummy0.__code__)\n-        )\n-        self.assertIn(\n-            (\"_CHECK_STACK_SPACE_OPERAND\", largest_stack), uops_and_operands\n-        )\n+        self.assertEqual(uop_names.count(\"_CHECK_STACK_SPACE_OPERAND\"), 15)\n \n-    @unittest.skip(\"gh-139109 WIP\")",
      "comment": "I think it is fine to remove this test.\r\n\r\nShould we combine multiple `_CHECK_STACK_SPACE_OPERAND`s into one in the future, then we can reinstate this test.",
      "comment_id": 2754791249,
      "user": "markshannon",
      "created_at": "2026-02-02T15:02:26Z",
      "url": "https://github.com/python/cpython/pull/144394#discussion_r2754791249"
    },
    {
      "repo": "python/cpython",
      "pr_number": 142713,
      "file_path": "Lib/test/test_array.py",
      "line": 1687,
      "side": "RIGHT",
      "diff_hunk": "@@ -1680,6 +1680,64 @@ def test_gh_128961(self):\n         it.__setstate__(0)\n         self.assertRaises(StopIteration, next, it)\n \n+    def test_array_validity_after_call_user_method(self):\n+        # gh-142555: Test for null pointer dereference in array.__setitem__\n+        # via re-entrant __index__ or __float__.\n+\n+        def test_clear_array(victim):",
      "comment": "Can you write the tests as follows instead:\r\n\r\n```py\r\n@subTests(\r\n    (\"dtype\", \"items\"),\r\n    (\r\n        (\"b\", [0] * 64),\r\n        ...\r\n    ),\r\n)\r\ndef test_setitem_use_after_clear_with_int_data(self, dtype, items):\r\n    array = array.array(dtype, items)\r\n\r\n    class Index:\r\n        def __index__(self):\r\n            array.clear()\r\n            return 0\r\n\r\n    self.assertRaises(IndexError, array.__setitem__, 1, Index())\r\n    self.assertEqual(len(array), 0)\r\n```\r\n\r\nThen a separate test for shrinking, and a separate test for clearing with floats:\r\n\r\n```py\r\ndef test_setitem_use_after_clear_with_float_data(self, dtype, items): ...\r\n\r\ndef test_setitem_use_after_shrink_with_int_data(self, dtype, items): ...\r\n```",
      "comment_id": 2649083473,
      "user": "picnixz",
      "created_at": "2025-12-27T10:55:07Z",
      "url": "https://github.com/python/cpython/pull/142713#discussion_r2649083473"
    },
    {
      "repo": "python/cpython",
      "pr_number": 142713,
      "file_path": "Lib/test/test_array.py",
      "line": 1688,
      "side": "RIGHT",
      "diff_hunk": "@@ -1680,6 +1681,61 @@ def test_gh_128961(self):\n         it.__setstate__(0)\n         self.assertRaises(StopIteration, next, it)\n \n+    @subTests(\n+        (\"dtype\", \"items\"),\n+        [\n+            (\"b\", [0] * 64),\n+            (\"B\", [1, 2, 3]),",
      "comment": "Any reason we need [0] * 64 and [1,2,3]? if not, we can just always use `list(range(64))` as the data.",
      "comment_id": 2649221818,
      "user": "picnixz",
      "created_at": "2025-12-27T16:46:42Z",
      "url": "https://github.com/python/cpython/pull/142713#discussion_r2649221818"
    },
    {
      "repo": "python/cpython",
      "pr_number": 142713,
      "file_path": "Lib/test/test_array.py",
      "line": 1701,
      "side": "RIGHT",
      "diff_hunk": "@@ -1680,6 +1681,61 @@ def test_gh_128961(self):\n         it.__setstate__(0)\n         self.assertRaises(StopIteration, next, it)\n \n+    @subTests(\n+        (\"dtype\", \"items\"),\n+        [\n+            (\"b\", [0] * 64),\n+            (\"B\", [1, 2, 3]),\n+            (\"h\", [1, 2, 3]),\n+            (\"H\", [1, 2, 3]),\n+            (\"i\", [1, 2, 3]),\n+            (\"l\", [1, 2, 3]),\n+            (\"q\", [1, 2, 3]),\n+            (\"I\", [1, 2, 3]),\n+            (\"L\", [1, 2, 3]),\n+            (\"Q\", [1, 2, 3]),\n+        ],\n+    )\n+    def test_setitem_use_after_clear_with_int_data(self, dtype, items):\n+        # gh-142555: Test for null pointer dereference in array.__setitem__\n+        # via re-entrant __index__ that clears the array.",
      "comment": "As Serhiy told me, it's not a re-entrancy issue but rather a concurrency issue so let's use:\r\n\r\n```py\r\n# Tests for NULL pointer dereference in array.__setitem__\r\n# when the index conversion mutates the array.\r\n# See: github.com/python/cpython/issues/142555.\r\n\r\n@subTests(...)\r\ndef test_setitem_use_after_clear_with_int_data(...): ...\r\n...\r\n...\r\n```\r\n\r\nIOW, let's forget about comments for each test and put one big comment as \"test\" section.\r\n",
      "comment_id": 2649223342,
      "user": "picnixz",
      "created_at": "2025-12-27T16:48:37Z",
      "url": "https://github.com/python/cpython/pull/142713#discussion_r2649223342"
    },
    {
      "repo": "python/cpython",
      "pr_number": 142713,
      "file_path": "Lib/test/test_array.py",
      "line": 1699,
      "side": "RIGHT",
      "diff_hunk": "@@ -1681,24 +1681,25 @@ def test_gh_128961(self):\n         it.__setstate__(0)\n         self.assertRaises(StopIteration, next, it)\n \n+    # Tests for NULL pointer dereference in array.__setitem__\n+    # when the index conversion mutates the array.\n+    # See: gh-142555.\n     @subTests(\n         (\"dtype\", \"items\"),\n         [\n-            (\"b\", [0] * 64),\n-            (\"B\", [1, 2, 3]),\n-            (\"h\", [1, 2, 3]),\n-            (\"H\", [1, 2, 3]),\n-            (\"i\", [1, 2, 3]),\n-            (\"l\", [1, 2, 3]),\n-            (\"q\", [1, 2, 3]),\n-            (\"I\", [1, 2, 3]),\n-            (\"L\", [1, 2, 3]),\n-            (\"Q\", [1, 2, 3]),\n+            (\"b\", list(range(64))),\n+            (\"B\", list(range(64))),\n+            (\"h\", list(range(64))),\n+            (\"H\", list(range(64))),\n+            (\"i\", list(range(64))),\n+            (\"l\", list(range(64))),\n+            (\"q\", list(range(64))),\n+            (\"I\", list(range(64))),\n+            (\"L\", list(range(64))),\n+            (\"Q\", list(range(64))),",
      "comment": "In this case, you don't need to pass `items`  and you can construct it in the test directly.",
      "comment_id": 2649236952,
      "user": "picnixz",
      "created_at": "2025-12-27T17:20:02Z",
      "url": "https://github.com/python/cpython/pull/142713#discussion_r2649236952"
    },
    {
      "repo": "python/cpython",
      "pr_number": 142713,
      "file_path": "Lib/test/test_array.py",
      "line": 1686,
      "side": "RIGHT",
      "diff_hunk": "@@ -1680,6 +1681,44 @@ def test_gh_128961(self):\n         it.__setstate__(0)\n         self.assertRaises(StopIteration, next, it)\n \n+    # Tests for NULL pointer dereference in array.__setitem__\n+    # when the index conversion mutates the array.\n+    # See: gh-142555.",
      "comment": "I don't know where my comment went but can you keep the full URL instead of gh-XXX please? I allows me to jump to the webpage from the IDE directly (in addition, add a blank line after the comment)",
      "comment_id": 2649246289,
      "user": "picnixz",
      "created_at": "2025-12-27T17:38:25Z",
      "url": "https://github.com/python/cpython/pull/142713#discussion_r2649246289"
    },
    {
      "repo": "python/cpython",
      "pr_number": 142713,
      "file_path": "Lib/test/test_array.py",
      "line": 1686,
      "side": "RIGHT",
      "diff_hunk": "@@ -1680,6 +1681,45 @@ def test_gh_128961(self):\n         it.__setstate__(0)\n         self.assertRaises(StopIteration, next, it)\n \n+    # Tests for NULL pointer dereference in array.__setitem__\n+    # when the index conversion mutates the array.\n+    # See: github.com/python/cpython/issues/142555.",
      "comment": "```suggestion\r\n    # See: https://github.com/python/cpython/issues/142555.\r\n```\r\n\r\nI also need the https:// part (sorry xD)",
      "comment_id": 2649255817,
      "user": "picnixz",
      "created_at": "2025-12-27T18:01:45Z",
      "url": "https://github.com/python/cpython/pull/142713#discussion_r2649255817"
    },
    {
      "repo": "python/cpython",
      "pr_number": 142713,
      "file_path": "Lib/test/test_array.py",
      "line": 1686,
      "side": "RIGHT",
      "diff_hunk": "@@ -1680,6 +1681,44 @@ def test_gh_128961(self):\n         it.__setstate__(0)\n         self.assertRaises(StopIteration, next, it)\n \n+    # Tests for NULL pointer dereference in array.__setitem__\n+    # when the index conversion mutates the array.\n+    # See: gh-142555.",
      "comment": "I noticed there are many uses of gh-XXX, so I assumed this style is more common in the codebase and modified your comment accordingly. Updated now.",
      "comment_id": 2649256473,
      "user": "aisk",
      "created_at": "2025-12-27T18:03:12Z",
      "url": "https://github.com/python/cpython/pull/142713#discussion_r2649256473"
    },
    {
      "repo": "python/cpython",
      "pr_number": 115232,
      "file_path": "Lib/test/test_funcattrs.py",
      "line": 472,
      "side": "RIGHT",
      "diff_hunk": "@@ -453,6 +453,29 @@ class BuiltinFunctionPropertiesTest(unittest.TestCase):\n     # XXX Not sure where this should really go since I can't find a\n     # test module specifically for builtin_function_or_method.\n \n+    def test_builtin__module__(self):\n+        import decimal\n+        import math\n+\n+        # builtin function:\n+        self.assertEqual(len.__module__, 'builtins')\n+        self.assertEqual(math.sin.__module__, 'math')\n+\n+        # instance method:\n+        self.assertRaises(AttributeError, getattr, int.to_bytes, '__module__')\n+        self.assertRaises(AttributeError, getattr, decimal.Decimal.exp, '__module__')\n+        self.assertEqual(int.to_bytes.__objclass__.__module__, 'builtins')\n+        self.assertEqual(decimal.Decimal.exp.__objclass__.__module__, 'decimal')\n+\n+        # builtin classmethod:\n+        self.assertEqual(int.from_bytes.__module__, None)\n+        self.assertEqual(int.from_bytes.__self__.__module__, 'builtins')",
      "comment": "Note that for classmethods the ``__module__`` attribute is also empty.  We could extend proposed solution to cover this case as well.  But this looks as a less severe issue for me: the module value is available in this case via the ``__self__`` attribute.",
      "comment_id": 1484942697,
      "user": "skirpichev",
      "created_at": "2024-02-10T03:37:06Z",
      "url": "https://github.com/python/cpython/pull/115232#discussion_r1484942697"
    },
    {
      "repo": "python/cpython",
      "pr_number": 115232,
      "file_path": "Lib/test/test_funcattrs.py",
      "line": 463,
      "side": "RIGHT",
      "diff_hunk": "@@ -459,6 +459,24 @@ class BuiltinFunctionPropertiesTest(unittest.TestCase):\n     # XXX Not sure where this should really go since I can't find a\n     # test module specifically for builtin_function_or_method.\n \n+    def test_builtin__module__(self):\n+        import math",
      "comment": "I'm ok with this, but the module is used just by single test.  `test_builtin__self__` has separate imports.\n",
      "comment_id": 2746149066,
      "user": "skirpichev",
      "created_at": "2026-01-30T12:57:33Z",
      "url": "https://github.com/python/cpython/pull/115232#discussion_r2746149066"
    },
    {
      "repo": "python/cpython",
      "pr_number": 110778,
      "file_path": "Lib/multiprocessing/shared_memory.py",
      "line": 120,
      "side": "RIGHT",
      "diff_hunk": "@@ -116,8 +117,8 @@ def __init__(self, name=None, create=False, size=0):\n             except OSError:\n                 self.unlink()\n                 raise\n-\n-            resource_tracker.register(self._name, \"shared_memory\")\n+            if track:",
      "comment": "Better perhaps to use `if self._track:` so if someone refactors this code it will not have to be changed?",
      "comment_id": 1359806038,
      "user": "gvanrossum",
      "created_at": "2023-10-15T07:54:49Z",
      "url": "https://github.com/python/cpython/pull/110778#discussion_r1359806038"
    },
    {
      "repo": "python/cpython",
      "pr_number": 110778,
      "file_path": "Lib/multiprocessing/shared_memory.py",
      "line": 242,
      "side": "RIGHT",
      "diff_hunk": "@@ -239,6 +240,9 @@ def unlink(self):\n         In order to ensure proper cleanup of resources, unlink should be\n         called once (and only once) across all processes which have access\n         to the shared memory block.\"\"\"",
      "comment": "This docstring seems to tell a different story than the docs you (re)write above. Maybe this constraint (of calling it once per **group** of process) should be mentioned there?\r\n\r\n",
      "comment_id": 1359806550,
      "user": "gvanrossum",
      "created_at": "2023-10-15T07:58:26Z",
      "url": "https://github.com/python/cpython/pull/110778#discussion_r1359806550"
    },
    {
      "repo": "python/cpython",
      "pr_number": 110778,
      "file_path": "Lib/multiprocessing/shared_memory.py",
      "line": 74,
      "side": "RIGHT",
      "diff_hunk": "@@ -72,7 +72,7 @@ class SharedMemory:\n     _mode = 0o600\n     _prepend_leading_slash = True if _USE_POSIX else False\n ",
      "comment": "I recommend adding `_track = True` here, since this appears to be a complete listing of all instance vars.",
      "comment_id": 1359806780,
      "user": "gvanrossum",
      "created_at": "2023-10-15T08:00:11Z",
      "url": "https://github.com/python/cpython/pull/110778#discussion_r1359806780"
    },
    {
      "repo": "python/cpython",
      "pr_number": 110778,
      "file_path": "Lib/multiprocessing/shared_memory.py",
      "line": 244,
      "side": "RIGHT",
      "diff_hunk": "@@ -239,6 +240,9 @@ def unlink(self):\n         In order to ensure proper cleanup of resources, unlink should be\n         called once (and only once) across all processes which have access\n         to the shared memory block.\"\"\"\n+        if not self._track:\n+            raise TypeError(\"unlink() must be called by a tracking instance\")",
      "comment": "This seems not promising due to 2 facts:\r\n\r\n1. It's not a `TypeError` because tracking or not is not reflected on the type itself.\r\n2. This makes `unlink`-ing a shared memory impossible. I suggest doing the `shm_unlink` but not calling `unregister` if not tracked.",
      "comment_id": 1359807964,
      "user": "wtdcode",
      "created_at": "2023-10-15T08:08:33Z",
      "url": "https://github.com/python/cpython/pull/110778#discussion_r1359807964"
    },
    {
      "repo": "python/cpython",
      "pr_number": 110778,
      "file_path": "Lib/multiprocessing/shared_memory.py",
      "line": 242,
      "side": "RIGHT",
      "diff_hunk": "@@ -239,6 +240,9 @@ def unlink(self):\n         In order to ensure proper cleanup of resources, unlink should be\n         called once (and only once) across all processes which have access\n         to the shared memory block.\"\"\"",
      "comment": "`unlink` is essentially a file delete so it should only happen once. Maybe I lost track of the bigger picture. I will reread my changes.",
      "comment_id": 1359932324,
      "user": "pan324",
      "created_at": "2023-10-15T19:23:56Z",
      "url": "https://github.com/python/cpython/pull/110778#discussion_r1359932324"
    },
    {
      "repo": "python/cpython",
      "pr_number": 110778,
      "file_path": "Lib/multiprocessing/shared_memory.py",
      "line": 244,
      "side": "RIGHT",
      "diff_hunk": "@@ -239,6 +240,9 @@ def unlink(self):\n         In order to ensure proper cleanup of resources, unlink should be\n         called once (and only once) across all processes which have access\n         to the shared memory block.\"\"\"\n+        if not self._track:\n+            raise TypeError(\"unlink() must be called by a tracking instance\")",
      "comment": "Can you elaborate? What would the right error be? Unlinking the memory is perfectly possible by using `track=True` which is even the default. \r\n\r\nLet's follow your suggestion, then a typical scenario may unfold like this:\r\n\r\n1. Some main process creates shared memory and hands over the name to some subprocess.\r\n2. The subprocess attaches without tracker but unlinks the memory. \r\n3. The main process terminates and its resource tracker will first complain about the lingering shared memory and then print an exception message about being unable to delete a file.\r\n\r\nIf we are fine with the warnings by the resource tracker then you're right that the error is not needed. If we see the warnings as something that the user should fix in the code, then the error helps the user discover the issue possibly much earlier. Though I do see the point that an error is too extreme for something that would result in a warning eventually.",
      "comment_id": 1359935318,
      "user": "pan324",
      "created_at": "2023-10-15T19:41:38Z",
      "url": "https://github.com/python/cpython/pull/110778#discussion_r1359935318"
    },
    {
      "repo": "python/cpython",
      "pr_number": 110778,
      "file_path": "Lib/multiprocessing/shared_memory.py",
      "line": 244,
      "side": "RIGHT",
      "diff_hunk": "@@ -239,6 +240,9 @@ def unlink(self):\n         In order to ensure proper cleanup of resources, unlink should be\n         called once (and only once) across all processes which have access\n         to the shared memory block.\"\"\"\n+        if not self._track:\n+            raise TypeError(\"unlink() must be called by a tracking instance\")",
      "comment": "I will undo this part and add a check to the resource tracker to not complain if the user did clean up, after all.",
      "comment_id": 1359939886,
      "user": "pan324",
      "created_at": "2023-10-15T19:50:57Z",
      "url": "https://github.com/python/cpython/pull/110778#discussion_r1359939886"
    },
    {
      "repo": "python/cpython",
      "pr_number": 110778,
      "file_path": "Lib/test/_test_multiprocessing.py",
      "line": 4446,
      "side": "RIGHT",
      "diff_hunk": "@@ -4440,6 +4440,31 @@ def test_shared_memory_cleaned_after_process_termination(self):\n                     \"resource_tracker: There appear to be 1 leaked \"\n                     \"shared_memory objects to clean up at shutdown\", err)\n \n+    @unittest.skipIf(os.name != \"posix\", \"resource_tracker is posix only\")\n+    def test_shared_memory_untracking(self):\n+        # gh-82300: When a separate Python process accesses shared memory\n+        # with track=False, it must not register with the resource tracker.",
      "comment": "Which part of this test would fail if `track=False` did not work properly?",
      "comment_id": 1364436812,
      "user": "pitrou",
      "created_at": "2023-10-18T19:40:56Z",
      "url": "https://github.com/python/cpython/pull/110778#discussion_r1364436812"
    },
    {
      "repo": "python/cpython",
      "pr_number": 110778,
      "file_path": "Lib/test/_test_multiprocessing.py",
      "line": 4465,
      "side": "RIGHT",
      "diff_hunk": "@@ -4440,6 +4440,31 @@ def test_shared_memory_cleaned_after_process_termination(self):\n                     \"resource_tracker: There appear to be 1 leaked \"\n                     \"shared_memory objects to clean up at shutdown\", err)\n \n+    @unittest.skipIf(os.name != \"posix\", \"resource_tracker is posix only\")\n+    def test_shared_memory_untracking(self):\n+        # gh-82300: When a separate Python process accesses shared memory\n+        # with track=False, it must not register with the resource tracker.\n+        cmd = '''if 1:\n+            import sys\n+            from unittest.mock import Mock\n+            from multiprocessing import resource_tracker\n+            from multiprocessing.shared_memory import SharedMemory\n+            resource_tracker.register = Mock(side_effect=AssertionError)\n+            mem = SharedMemory(create=False, name=sys.argv[1], track=False)\n+            mem.close()\n+        '''\n+        mem = shared_memory.SharedMemory(create=True, size=10)\n+        try:\n+            *_, err = test.support.script_helper.assert_python_ok(\"-c\", cmd,\n+                                                                  mem.name)\n+            self.assertEqual(err, b'')\n+        finally:\n+            mem.close()\n+            try:\n+                mem.unlink()\n+            except OSError:",
      "comment": "Is there a situation where `OSError` would be raised here?",
      "comment_id": 1364437101,
      "user": "pitrou",
      "created_at": "2023-10-18T19:41:12Z",
      "url": "https://github.com/python/cpython/pull/110778#discussion_r1364437101"
    },
    {
      "repo": "python/cpython",
      "pr_number": 110778,
      "file_path": "Lib/test/_test_multiprocessing.py",
      "line": 4446,
      "side": "RIGHT",
      "diff_hunk": "@@ -4440,6 +4440,31 @@ def test_shared_memory_cleaned_after_process_termination(self):\n                     \"resource_tracker: There appear to be 1 leaked \"\n                     \"shared_memory objects to clean up at shutdown\", err)\n \n+    @unittest.skipIf(os.name != \"posix\", \"resource_tracker is posix only\")\n+    def test_shared_memory_untracking(self):\n+        # gh-82300: When a separate Python process accesses shared memory\n+        # with track=False, it must not register with the resource tracker.",
      "comment": "The sole effect of `track=False` is that `register` is not called. Thus it would be faulty behavior if `register` is called when `track=False`. The function checks the error message from the subprocess and will fail when that happens.",
      "comment_id": 1365319245,
      "user": "pan324",
      "created_at": "2023-10-19T11:07:13Z",
      "url": "https://github.com/python/cpython/pull/110778#discussion_r1365319245"
    },
    {
      "repo": "python/cpython",
      "pr_number": 110778,
      "file_path": "Lib/test/_test_multiprocessing.py",
      "line": 4465,
      "side": "RIGHT",
      "diff_hunk": "@@ -4440,6 +4440,31 @@ def test_shared_memory_cleaned_after_process_termination(self):\n                     \"resource_tracker: There appear to be 1 leaked \"\n                     \"shared_memory objects to clean up at shutdown\", err)\n \n+    @unittest.skipIf(os.name != \"posix\", \"resource_tracker is posix only\")\n+    def test_shared_memory_untracking(self):\n+        # gh-82300: When a separate Python process accesses shared memory\n+        # with track=False, it must not register with the resource tracker.\n+        cmd = '''if 1:\n+            import sys\n+            from unittest.mock import Mock\n+            from multiprocessing import resource_tracker\n+            from multiprocessing.shared_memory import SharedMemory\n+            resource_tracker.register = Mock(side_effect=AssertionError)\n+            mem = SharedMemory(create=False, name=sys.argv[1], track=False)\n+            mem.close()\n+        '''\n+        mem = shared_memory.SharedMemory(create=True, size=10)\n+        try:\n+            *_, err = test.support.script_helper.assert_python_ok(\"-c\", cmd,\n+                                                                  mem.name)\n+            self.assertEqual(err, b'')\n+        finally:\n+            mem.close()\n+            try:\n+                mem.unlink()\n+            except OSError:",
      "comment": "Good point. The subprocess is never given the chance to register the resource tracker so there is never any risk of the subprocess resource tracker cleaning up. Will remove the try-except.",
      "comment_id": 1365321761,
      "user": "pan324",
      "created_at": "2023-10-19T11:09:37Z",
      "url": "https://github.com/python/cpython/pull/110778#discussion_r1365321761"
    },
    {
      "repo": "python/cpython",
      "pr_number": 110778,
      "file_path": "Lib/test/_test_multiprocessing.py",
      "line": 4446,
      "side": "RIGHT",
      "diff_hunk": "@@ -4440,6 +4440,31 @@ def test_shared_memory_cleaned_after_process_termination(self):\n                     \"resource_tracker: There appear to be 1 leaked \"\n                     \"shared_memory objects to clean up at shutdown\", err)\n \n+    @unittest.skipIf(os.name != \"posix\", \"resource_tracker is posix only\")\n+    def test_shared_memory_untracking(self):\n+        # gh-82300: When a separate Python process accesses shared memory\n+        # with track=False, it must not register with the resource tracker.",
      "comment": "Rather than relying on mocking, I think it would be better to test the actual situation that we're trying to fix:\r\n1) create shared memory segment in parent\r\n2) pass its name to child that will reference it and then close it\r\n3) check that the segment can still be used in parent\r\n",
      "comment_id": 1370522990,
      "user": "pitrou",
      "created_at": "2023-10-24T16:46:55Z",
      "url": "https://github.com/python/cpython/pull/110778#discussion_r1370522990"
    },
    {
      "repo": "python/cpython",
      "pr_number": 110778,
      "file_path": "Lib/test/_test_multiprocessing.py",
      "line": 4446,
      "side": "RIGHT",
      "diff_hunk": "@@ -4440,6 +4440,31 @@ def test_shared_memory_cleaned_after_process_termination(self):\n                     \"resource_tracker: There appear to be 1 leaked \"\n                     \"shared_memory objects to clean up at shutdown\", err)\n \n+    @unittest.skipIf(os.name != \"posix\", \"resource_tracker is posix only\")\n+    def test_shared_memory_untracking(self):\n+        # gh-82300: When a separate Python process accesses shared memory\n+        # with track=False, it must not register with the resource tracker.",
      "comment": "The main concern I had with that approach is the indeterminate amount of time between closing the process and the resource tracker kicking in. Right now such a time is not needed because the test waits until stderr is fully available and that includes the resource tracker itself. But that's only due to the way the resource tracker is created. If we do rely on that internal behavior then the current test would be in the same vein. Otherwise, what would a good delay be? A second?",
      "comment_id": 1370780307,
      "user": "pan324",
      "created_at": "2023-10-24T20:32:17Z",
      "url": "https://github.com/python/cpython/pull/110778#discussion_r1370780307"
    },
    {
      "repo": "python/cpython",
      "pr_number": 110778,
      "file_path": "Lib/test/_test_multiprocessing.py",
      "line": 4446,
      "side": "RIGHT",
      "diff_hunk": "@@ -4440,6 +4440,31 @@ def test_shared_memory_cleaned_after_process_termination(self):\n                     \"resource_tracker: There appear to be 1 leaked \"\n                     \"shared_memory objects to clean up at shutdown\", err)\n \n+    @unittest.skipIf(os.name != \"posix\", \"resource_tracker is posix only\")\n+    def test_shared_memory_untracking(self):\n+        # gh-82300: When a separate Python process accesses shared memory\n+        # with track=False, it must not register with the resource tracker.",
      "comment": "Hmm, that's a good point and that complicates things a bit...",
      "comment_id": 1371280596,
      "user": "pitrou",
      "created_at": "2023-10-25T07:31:51Z",
      "url": "https://github.com/python/cpython/pull/110778#discussion_r1371280596"
    },
    {
      "repo": "python/cpython",
      "pr_number": 110778,
      "file_path": "Lib/test/_test_multiprocessing.py",
      "line": 4446,
      "side": "RIGHT",
      "diff_hunk": "@@ -4440,6 +4440,31 @@ def test_shared_memory_cleaned_after_process_termination(self):\n                     \"resource_tracker: There appear to be 1 leaked \"\n                     \"shared_memory objects to clean up at shutdown\", err)\n \n+    @unittest.skipIf(os.name != \"posix\", \"resource_tracker is posix only\")\n+    def test_shared_memory_untracking(self):\n+        # gh-82300: When a separate Python process accesses shared memory\n+        # with track=False, it must not register with the resource tracker.",
      "comment": "I think technically the previous test guarantees that but I have now added both the `track=False` and `track=True` cases explicitly. The second case needs something from stderr and so it would fail if the resource tracker did not use the same pipe.",
      "comment_id": 1372138986,
      "user": "pan324",
      "created_at": "2023-10-25T18:07:43Z",
      "url": "https://github.com/python/cpython/pull/110778#discussion_r1372138986"
    },
    {
      "repo": "python/cpython",
      "pr_number": 110778,
      "file_path": "Lib/multiprocessing/shared_memory.py",
      "line": 242,
      "side": "RIGHT",
      "diff_hunk": "@@ -239,6 +240,9 @@ def unlink(self):\n         In order to ensure proper cleanup of resources, unlink should be\n         called once (and only once) across all processes which have access\n         to the shared memory block.\"\"\"",
      "comment": "This docstring could just be replaced with a copy of what was re-written up in the `.rst` docs.  Both are technically correct, but the new docs are more clear about the details.",
      "comment_id": 1410359361,
      "user": "gpshead",
      "created_at": "2023-11-30T09:03:04Z",
      "url": "https://github.com/python/cpython/pull/110778#discussion_r1410359361"
    },
    {
      "repo": "python/cpython",
      "pr_number": 110778,
      "file_path": "Lib/test/_test_multiprocessing.py",
      "line": 4465,
      "side": "RIGHT",
      "diff_hunk": "@@ -4440,6 +4440,31 @@ def test_shared_memory_cleaned_after_process_termination(self):\n                     \"resource_tracker: There appear to be 1 leaked \"\n                     \"shared_memory objects to clean up at shutdown\", err)\n \n+    @unittest.skipIf(os.name != \"posix\", \"resource_tracker is posix only\")\n+    def test_shared_memory_untracking(self):\n+        # gh-82300: When a separate Python process accesses shared memory\n+        # with track=False, it must not register with the resource tracker.\n+        cmd = '''if 1:\n+            import sys\n+            from unittest.mock import Mock\n+            from multiprocessing import resource_tracker\n+            from multiprocessing.shared_memory import SharedMemory\n+            resource_tracker.register = Mock(side_effect=AssertionError)\n+            mem = SharedMemory(create=False, name=sys.argv[1], track=False)\n+            mem.close()\n+        '''\n+        mem = shared_memory.SharedMemory(create=True, size=10)\n+        try:\n+            *_, err = test.support.script_helper.assert_python_ok(\"-c\", cmd,\n+                                                                  mem.name)\n+            self.assertEqual(err, b'')\n+        finally:\n+            mem.close()\n+            try:\n+                mem.unlink()\n+            except OSError:",
      "comment": "technically you don't know why the subprocess died. it could've started the resource tracker and died for any reason (before or after registering the memory with the tracker)... This is a test suite run in CI on prerelease code... these things happen \ud83d\ude05.\r\n\r\nSo I think moving the `assert_python_ok` within the `try:` block and accepting that even `resource_tracker.unregister` may fail as well as `mem.unlink` is good defensive state cleanup coding here.",
      "comment_id": 1410364169,
      "user": "gpshead",
      "created_at": "2023-11-30T09:07:06Z",
      "url": "https://github.com/python/cpython/pull/110778#discussion_r1410364169"
    },
    {
      "repo": "python/cpython",
      "pr_number": 110778,
      "file_path": "Lib/test/_test_multiprocessing.py",
      "line": 4465,
      "side": "RIGHT",
      "diff_hunk": "@@ -4440,6 +4440,31 @@ def test_shared_memory_cleaned_after_process_termination(self):\n                     \"resource_tracker: There appear to be 1 leaked \"\n                     \"shared_memory objects to clean up at shutdown\", err)\n \n+    @unittest.skipIf(os.name != \"posix\", \"resource_tracker is posix only\")\n+    def test_shared_memory_untracking(self):\n+        # gh-82300: When a separate Python process accesses shared memory\n+        # with track=False, it must not register with the resource tracker.\n+        cmd = '''if 1:\n+            import sys\n+            from unittest.mock import Mock\n+            from multiprocessing import resource_tracker\n+            from multiprocessing.shared_memory import SharedMemory\n+            resource_tracker.register = Mock(side_effect=AssertionError)\n+            mem = SharedMemory(create=False, name=sys.argv[1], track=False)\n+            mem.close()\n+        '''\n+        mem = shared_memory.SharedMemory(create=True, size=10)\n+        try:\n+            *_, err = test.support.script_helper.assert_python_ok(\"-c\", cmd,\n+                                                                  mem.name)\n+            self.assertEqual(err, b'')\n+        finally:\n+            mem.close()\n+            try:\n+                mem.unlink()\n+            except OSError:",
      "comment": "Good points. The code should be a bit more defensive on cleanup now. \r\n\r\nUnregistering of the resource tracker should not be allowed to fail. This is the resource tracker process that belongs to the main process.",
      "comment_id": 1410989588,
      "user": "pan324",
      "created_at": "2023-11-30T17:13:48Z",
      "url": "https://github.com/python/cpython/pull/110778#discussion_r1410989588"
    },
    {
      "repo": "python/cpython",
      "pr_number": 110778,
      "file_path": "Lib/test/_test_multiprocessing.py",
      "line": 4461,
      "side": "RIGHT",
      "diff_hunk": "@@ -4440,6 +4440,53 @@ def test_shared_memory_cleaned_after_process_termination(self):\n                     \"resource_tracker: There appear to be 1 leaked \"\n                     \"shared_memory objects to clean up at shutdown\", err)\n \n+    @unittest.skipIf(os.name != \"posix\", \"resource_tracker is posix only\")\n+    def test_shared_memory_untracking(self):\n+        # gh-82300: When a separate Python process accesses shared memory\n+        # with track=False, it must not cause the memory to be deleted\n+        # when terminating. When accessing with track=True, it must be\n+        # deleted.\n+        cmd = '''if 1:\n+            import sys\n+            from multiprocessing.shared_memory import SharedMemory\n+            mem = SharedMemory(create=False, name=sys.argv[1], track=False)\n+            mem.close()\n+        '''\n+        mem = shared_memory.SharedMemory(create=True, size=10)\n+        # The resource tracker shares pipes with the subprocess, and so\n+        # err existing means that the tracker process has terminated now.\n+        try:\n+            rc, out, err = script_helper.assert_python_ok(\"-c\", cmd, mem.name)\n+            self.assertEqual(rc, 0)\n+            mem2 = shared_memory.SharedMemory(create=False, name=mem.name)",
      "comment": "it might seem a bit redundant but adding a `self.assertNotIn(b\"resource_tracker\", err)` here also makes sense from the point of view of identifying the specific way something could have gone wrong if the implementation regressed.",
      "comment_id": 1411716249,
      "user": "gpshead",
      "created_at": "2023-12-01T07:27:36Z",
      "url": "https://github.com/python/cpython/pull/110778#discussion_r1411716249"
    },
    {
      "repo": "python/cpython",
      "pr_number": 110778,
      "file_path": "Lib/test/_test_multiprocessing.py",
      "line": 4444,
      "side": "RIGHT",
      "diff_hunk": "@@ -4440,6 +4440,53 @@ def test_shared_memory_cleaned_after_process_termination(self):\n                     \"resource_tracker: There appear to be 1 leaked \"\n                     \"shared_memory objects to clean up at shutdown\", err)\n \n+    @unittest.skipIf(os.name != \"posix\", \"resource_tracker is posix only\")\n+    def test_shared_memory_untracking(self):",
      "comment": "this is really two test cases in one right now, split it into two test methods one each for a child not using and using a tracker.",
      "comment_id": 1411716839,
      "user": "gpshead",
      "created_at": "2023-12-01T07:28:24Z",
      "url": "https://github.com/python/cpython/pull/110778#discussion_r1411716839"
    },
    {
      "repo": "python/cpython",
      "pr_number": 110778,
      "file_path": "Lib/test/_test_multiprocessing.py",
      "line": 4446,
      "side": "RIGHT",
      "diff_hunk": "@@ -4440,6 +4440,31 @@ def test_shared_memory_cleaned_after_process_termination(self):\n                     \"resource_tracker: There appear to be 1 leaked \"\n                     \"shared_memory objects to clean up at shutdown\", err)\n \n+    @unittest.skipIf(os.name != \"posix\", \"resource_tracker is posix only\")\n+    def test_shared_memory_untracking(self):\n+        # gh-82300: When a separate Python process accesses shared memory\n+        # with track=False, it must not register with the resource tracker.",
      "comment": "As much as I don't love depending on that stderr connection to indicate resource tracker termination, I think it is practical. you have a comment mentioning it, that is good enough.  it is an implementation behavior that is unlikely to ever be changed.",
      "comment_id": 1411719381,
      "user": "gpshead",
      "created_at": "2023-12-01T07:32:07Z",
      "url": "https://github.com/python/cpython/pull/110778#discussion_r1411719381"
    },
    {
      "repo": "python/cpython",
      "pr_number": 142285,
      "file_path": "Lib/multiprocessing/resource_tracker.py",
      "line": 323,
      "side": "RIGHT",
      "diff_hunk": "@@ -296,6 +315,30 @@ def _send(self, cmd, name, rtype):\n getfd = _resource_tracker.getfd\n \n \n+def _decode_message(line):\n+    if line.startswith(b'{'):\n+        try:\n+            obj = json.loads(line.decode('ascii'))\n+        except Exception as e:\n+            raise ValueError(\"malformed resource_tracker message: %r\" % (line,)) from e",
      "comment": "```suggestion\n        except Exception as exc:\n            raise ValueError(\"malformed resource_tracker message: %r\" % (line,)) from exc\n```\n\nSame suggestion for the similar try/except below.",
      "comment_id": 2592407664,
      "user": "vstinner",
      "created_at": "2025-12-05T11:44:08Z",
      "url": "https://github.com/python/cpython/pull/142285#discussion_r2592407664"
    },
    {
      "repo": "python/cpython",
      "pr_number": 142285,
      "file_path": "Lib/multiprocessing/resource_tracker.py",
      "line": 323,
      "side": "RIGHT",
      "diff_hunk": "@@ -296,6 +315,30 @@ def _send(self, cmd, name, rtype):\n getfd = _resource_tracker.getfd\n \n \n+def _decode_message(line):\n+    if line.startswith(b'{'):\n+        try:\n+            obj = json.loads(line.decode('ascii'))\n+        except Exception as e:\n+            raise ValueError(\"malformed resource_tracker message: %r\" % (line,)) from e",
      "comment": "I didn't see this message; I merged at the same time you sent it :(\r\n\r\nAnyway, I wouldn't change style in a backport.\r\n(Also note that this part of the code was moved -- see `git show --color-moved --color-moved-ws=allow-indentation-change f130b06da` or a fancy Git client.)\r\n",
      "comment_id": 2610934735,
      "user": "encukou",
      "created_at": "2025-12-11T15:01:26Z",
      "url": "https://github.com/python/cpython/pull/142285#discussion_r2610934735"
    },
    {
      "repo": "python/cpython",
      "pr_number": 138473,
      "file_path": "Lib/multiprocessing/resource_tracker.py",
      "line": 293,
      "side": "RIGHT",
      "diff_hunk": "@@ -285,7 +285,12 @@ def main(fd):\n         with open(fd, 'rb') as f:\n             for line in f:\n                 try:\n-                    cmd, name, rtype = line.strip().decode('ascii').split(':')\n+                    parts = line.strip().decode('ascii').split(':')\n+                    if len(parts) < 3:\n+                        raise ValueError(\"malformed resource_tracker message: %r\" % (parts,))\n+                    cmd = parts[0]\n+                    rtype = parts[-1]\n+                    name = ':'.join(parts[1:-1])",
      "comment": "How about this?\r\n```suggestion\r\n                    cmd, *name_parts, rtype = line.strip().decode('ascii').split(':')\r\n                    name = ':'.join(name_parts)\r\n```",
      "comment_id": 2490602397,
      "user": "encukou",
      "created_at": "2025-11-04T13:51:25Z",
      "url": "https://github.com/python/cpython/pull/138473#discussion_r2490602397"
    },
    {
      "repo": "python/cpython",
      "pr_number": 138473,
      "file_path": "Lib/multiprocessing/resource_tracker.py",
      "line": 297,
      "side": "RIGHT",
      "diff_hunk": "@@ -285,7 +292,13 @@ def main(fd):\n         with open(fd, 'rb') as f:\n             for line in f:\n                 try:\n-                    cmd, name, rtype = line.strip().decode('ascii').split(':')\n+                    cmd, enc_name, rtype = line.rstrip(b'\\n').decode('ascii').split(':', 2)\n+                    if rtype == \"shared_memory\":\n+                        name = base64.urlsafe_b64decode(enc_name.encode('ascii')).decode('utf-8', 'surrogateescape')",
      "comment": "Decoding is OK with strings.\r\n```suggestion\r\n                        name = base64.urlsafe_b64decode(enc_name).decode('utf-8', 'surrogateescape')\r\n```",
      "comment_id": 2498051055,
      "user": "encukou",
      "created_at": "2025-11-06T08:48:40Z",
      "url": "https://github.com/python/cpython/pull/138473#discussion_r2498051055"
    },
    {
      "repo": "python/cpython",
      "pr_number": 138473,
      "file_path": "Lib/multiprocessing/resource_tracker.py",
      "line": 297,
      "side": "RIGHT",
      "diff_hunk": "@@ -285,7 +292,13 @@ def main(fd):\n         with open(fd, 'rb') as f:\n             for line in f:\n                 try:\n-                    cmd, name, rtype = line.strip().decode('ascii').split(':')\n+                    cmd, enc_name, rtype = line.rstrip(b'\\n').decode('ascii').split(':', 2)\n+                    if rtype == \"shared_memory\":\n+                        name = base64.urlsafe_b64decode(enc_name.encode('ascii')).decode('utf-8', 'surrogateescape')",
      "comment": "Thanks for your comment. I like your suggestion to consider using JSON to encode the message. \r\n\r\nAlso, in the original implementation there was a check that the message is not longer than 512 bytes, since writes shorter than `PIPE_BUF` (512 bytes on POSIX) are guaranteed to be atomic. But there was no check on the name length.  \r\n\r\nNow I check that the name is at most 255 bytes long, which is the value of `NAME_MAX` on Linux (including the leading slash that POSIX requires in shared memory and semaphore names).  \r\n\r\nI still encode the name using Base64, because `json.dumps(..., ensure_ascii=True)` would otherwise expand each non-ASCII byte into a 6-character escape like `\\uDC80`. Using Base64 ensures that a 255-byte name becomes at most 340 bytes long, so the total JSON message always remains well below 512 bytes.  \r\n\r\nAs a result, the previous runtime check for the message length is now replaced by an `assert`.\r\n\r\nWhat do you think?",
      "comment_id": 2506903207,
      "user": "rani-pinchuk",
      "created_at": "2025-11-08T12:50:37Z",
      "url": "https://github.com/python/cpython/pull/138473#discussion_r2506903207"
    },
    {
      "repo": "python/cpython",
      "pr_number": 138473,
      "file_path": "Lib/multiprocessing/resource_tracker.py",
      "line": 316,
      "side": "RIGHT",
      "diff_hunk": "@@ -283,9 +309,28 @@ def main(fd):\n     try:\n         # keep track of registered/unregistered resources\n         with open(fd, 'rb') as f:\n-            for line in f:\n+            for raw in f:\n                 try:\n-                    cmd, name, rtype = line.strip().decode('ascii').split(':')\n+                    line = raw.rstrip(b'\\n')\n+                    try:\n+                        obj = json.loads(line.decode('ascii'))",
      "comment": "Stripping and decoding shouldn't be needed; `json.loads` can handle bytes and trailing newlines.",
      "comment_id": 2510490678,
      "user": "encukou",
      "created_at": "2025-11-10T12:58:21Z",
      "url": "https://github.com/python/cpython/pull/138473#discussion_r2510490678"
    },
    {
      "repo": "python/cpython",
      "pr_number": 138473,
      "file_path": "Lib/multiprocessing/resource_tracker.py",
      "line": 254,
      "side": "LEFT",
      "diff_hunk": "@@ -248,11 +262,23 @@ def _write(self, msg):\n         assert nbytes == len(msg), f\"{nbytes=} != {len(msg)=}\"\n \n     def _send(self, cmd, name, rtype):\n-        msg = f\"{cmd}:{name}:{rtype}\\n\".encode(\"ascii\")\n-        if len(msg) > 512:\n-            # posix guarantees that writes to a pipe of less than PIPE_BUF\n-            # bytes are atomic, and that PIPE_BUF >= 512",
      "comment": "Please keep this comment. Without it, the connection between atomicity and 512 (on Posix) isn't clear.",
      "comment_id": 2510505184,
      "user": "encukou",
      "created_at": "2025-11-10T13:03:46Z",
      "url": "https://github.com/python/cpython/pull/138473#discussion_r2510505184"
    },
    {
      "repo": "python/cpython",
      "pr_number": 138473,
      "file_path": "Lib/multiprocessing/resource_tracker.py",
      "line": 322,
      "side": "RIGHT",
      "diff_hunk": "@@ -283,9 +309,28 @@ def main(fd):\n     try:\n         # keep track of registered/unregistered resources\n         with open(fd, 'rb') as f:\n-            for line in f:\n+            for raw in f:\n                 try:\n-                    cmd, name, rtype = line.strip().decode('ascii').split(':')\n+                    line = raw.rstrip(b'\\n')\n+                    try:\n+                        obj = json.loads(line.decode('ascii'))\n+                    except Exception as e:\n+                        raise ValueError(\"malformed resource_tracker message: %r\" % (line,)) from e\n+\n+                    cmd = obj.get(\"cmd\")\n+                    rtype = obj.get(\"rtype\")\n+                    b64  = obj.get(\"base64_name\")",
      "comment": "You don't need `get` with constant arguments:\r\n```suggestion\r\n                    cmd = obj[\"cmd\"]\r\n                    rtype = obj[\"rtype\"]\r\n                    b64  = obj[\"base64_name\"]\r\n```",
      "comment_id": 2510506949,
      "user": "encukou",
      "created_at": "2025-11-10T13:04:24Z",
      "url": "https://github.com/python/cpython/pull/138473#discussion_r2510506949"
    },
    {
      "repo": "python/cpython",
      "pr_number": 138473,
      "file_path": "Lib/multiprocessing/resource_tracker.py",
      "line": 322,
      "side": "RIGHT",
      "diff_hunk": "@@ -283,9 +309,28 @@ def main(fd):\n     try:\n         # keep track of registered/unregistered resources\n         with open(fd, 'rb') as f:\n-            for line in f:\n+            for raw in f:\n                 try:\n-                    cmd, name, rtype = line.strip().decode('ascii').split(':')\n+                    line = raw.rstrip(b'\\n')\n+                    try:\n+                        obj = json.loads(line.decode('ascii'))\n+                    except Exception as e:\n+                        raise ValueError(\"malformed resource_tracker message: %r\" % (line,)) from e\n+\n+                    cmd = obj.get(\"cmd\")\n+                    rtype = obj.get(\"rtype\")\n+                    b64  = obj.get(\"base64_name\")",
      "comment": "Alternately, make some fields optional -- then the PROBE message can be shorter:\r\n```suggestion\r\n                    cmd = obj[\"cmd\"]\r\n                    rtype = obj[\"rtype\"]\r\n                    b64  = obj.get(\"base64_name\", \"\")\r\n```",
      "comment_id": 2510509246,
      "user": "encukou",
      "created_at": "2025-11-10T13:05:11Z",
      "url": "https://github.com/python/cpython/pull/138473#discussion_r2510509246"
    },
    {
      "repo": "python/cpython",
      "pr_number": 138473,
      "file_path": "Lib/multiprocessing/resource_tracker.py",
      "line": 254,
      "side": "LEFT",
      "diff_hunk": "@@ -248,11 +262,23 @@ def _write(self, msg):\n         assert nbytes == len(msg), f\"{nbytes=} != {len(msg)=}\"\n \n     def _send(self, cmd, name, rtype):\n-        msg = f\"{cmd}:{name}:{rtype}\\n\".encode(\"ascii\")\n-        if len(msg) > 512:\n-            # posix guarantees that writes to a pipe of less than PIPE_BUF\n-            # bytes are atomic, and that PIPE_BUF >= 512",
      "comment": "I have added the explanation to the comment in the start of the method. ",
      "comment_id": 2512017366,
      "user": "rani-pinchuk",
      "created_at": "2025-11-10T21:25:21Z",
      "url": "https://github.com/python/cpython/pull/138473#discussion_r2512017366"
    },
    {
      "repo": "python/cpython",
      "pr_number": 138473,
      "file_path": "Lib/test/_test_multiprocessing.py",
      "line": 7338,
      "side": "RIGHT",
      "diff_hunk": "@@ -7335,3 +7335,46 @@ def test_forkpty(self):\n         res = assert_python_failure(\"-c\", code, PYTHONWARNINGS='error')\n         self.assertIn(b'DeprecationWarning', res.err)\n         self.assertIn(b'is multi-threaded, use of forkpty() may lead to deadlocks in the child', res.err)\n+",
      "comment": "```suggestion\n\n\n```\nThis should have been a double line gap. I'll fix it in the backports.",
      "comment_id": 2557770591,
      "user": "StanFromIreland",
      "created_at": "2025-11-24T21:26:29Z",
      "url": "https://github.com/python/cpython/pull/138473#discussion_r2557770591"
    },
    {
      "repo": "python/cpython",
      "pr_number": 143749,
      "file_path": "Tools/build/compute-changes.py",
      "line": 92,
      "side": "RIGHT",
      "diff_hunk": "@@ -50,11 +50,58 @@\n MACOS_DIRS = frozenset({\"Mac\"})\n WASI_DIRS = frozenset({Path(\"Tools\", \"wasm\")})\n \n+LIBRARY_FUZZER_PATHS = frozenset({\n+    # All C/CPP fuzzers.\n+    Path(\"configure\"),\n+    Path(\".github/workflows/reusable-cifuzz.yml\"),\n+    # ast\n+    Path(\"Lib/ast.py\"),\n+    Path(\"Python/ast.c\"),\n+    # configparser\n+    Path(\"Lib/configparser.py\"),\n+    # csv\n+    Path(\"Lib/csv.py\"),\n+    Path(\"Modules/_csv.c\"),\n+    # decode\n+    Path(\"Lib/encodings/\"),\n+    Path(\"Modules/_codecsmodule.c\"),\n+    Path(\"Modules/cjkcodecs/\"),\n+    Path(\"Modules/unicodedata*\"),\n+    # difflib\n+    Path(\"Lib/difflib.py\"),\n+    # email\n+    Path(\"Lib/email/\"),\n+    # html\n+    Path(\"Lib/html/\"),\n+    Path(\"Lib/_markupbase.py\"),\n+    # http.client\n+    Path(\"Lib/http/client.py\"),\n+    # json\n+    Path(\"Lib/json/\"),\n+    Path(\"Modules/_json.c\"),\n+    # plist\n+    Path(\"Lib/plistlib.py\"),\n+    # re\n+    Path(\"Lib/re/\"),\n+    Path(\"Modules/_sre/\"),\n+    # tarfile\n+    Path(\"Lib/tarfile.py\"),\n+    # tomllib\n+    Path(\"Modules/tomllib/\"),\n+    # xml\n+    Path(\"Lib/xml/\"),",
      "comment": "There is also `Modules/pyexpat.c` that could be worth I guess?",
      "comment_id": 2684274696,
      "user": "picnixz",
      "created_at": "2026-01-12T23:44:38Z",
      "url": "https://github.com/python/cpython/pull/143749#discussion_r2684274696"
    },
    {
      "repo": "python/cpython",
      "pr_number": 143749,
      "file_path": "Tools/build/compute-changes.py",
      "line": 227,
      "side": "RIGHT",
      "diff_hunk": "@@ -162,8 +224,8 @@ def process_changed_files(changed_files: Set[Path]) -> Outputs:\n         doc_file = file.suffix in SUFFIXES_DOCUMENTATION or doc_or_misc\n \n         if file.parent == GITHUB_WORKFLOWS_PATH:\n-            if file.name == \"build.yml\":\n-                run_tests = run_ci_fuzz = True\n+            if file.name == \"build.yml\" or file.name == \"reusable-cifuzz.yml\":",
      "comment": "```suggestion\r\n            if file.name in (\"build.yml\", \"reusable-cifuzz.yml\"):\r\n```",
      "comment_id": 2695920184,
      "user": "hugovk",
      "created_at": "2026-01-15T20:51:37Z",
      "url": "https://github.com/python/cpython/pull/143749#discussion_r2695920184"
    },
    {
      "repo": "python/cpython",
      "pr_number": 143749,
      "file_path": "Tools/build/compute-changes.py",
      "line": 150,
      "side": "RIGHT",
      "diff_hunk": "@@ -96,6 +144,11 @@ def compute_changes() -> None:\n     else:\n         print(\"Branch too old for CIFuzz tests; or no C files were changed\")\n \n+    if outputs.run_ci_fuzz_stdlib:\n+        print(\"Run CIFuzz tests for libraries\")\n+    else:\n+        print(\"Branch too old for CIFuzz tests; or no library files were changed\")",
      "comment": "```suggestion\r\n        print(\"Run CIFuzz tests for stdlib\")\r\n    else:\r\n        print(\"Branch too old for CIFuzz tests; or no stdlib files were changed\")\r\n```",
      "comment_id": 2695927211,
      "user": "hugovk",
      "created_at": "2026-01-15T20:54:14Z",
      "url": "https://github.com/python/cpython/pull/143749#discussion_r2695927211"
    },
    {
      "repo": "python/cpython",
      "pr_number": 143426,
      "file_path": "Lib/profiling/sampling/sample.py",
      "line": 76,
      "side": "RIGHT",
      "diff_hunk": "@@ -71,11 +73,19 @@ def _new_unwinder(self, native, gc, opcodes, skip_non_matching_threads):\n                 cache_frames=True, stats=self.collect_stats\n             )\n         else:\n-            unwinder = _remote_debugging.RemoteUnwinder(\n-                self.pid, only_active_thread=bool(self.all_threads), mode=self.mode, native=native, gc=gc,\n-                opcodes=opcodes, skip_non_matching_threads=skip_non_matching_threads,\n-                cache_frames=True, stats=self.collect_stats\n-            )\n+            # FIX: Properly handle all_threads vs only_active_thread parameters",
      "comment": "> Additionally, I have updated _new_unwinder to properly handle the all_threads vs only_active_thread parameters based on the detected build type.\n\nI suggest reverting this change and open a separated PR for it.",
      "comment_id": 2672735956,
      "user": "vstinner",
      "created_at": "2026-01-08T15:09:34Z",
      "url": "https://github.com/python/cpython/pull/143426#discussion_r2672735956"
    },
    {
      "repo": "python/cpython",
      "pr_number": 143426,
      "file_path": "Lib/profiling/sampling/sample.py",
      "line": 76,
      "side": "RIGHT",
      "diff_hunk": "@@ -71,11 +73,19 @@ def _new_unwinder(self, native, gc, opcodes, skip_non_matching_threads):\n                 cache_frames=True, stats=self.collect_stats\n             )\n         else:\n-            unwinder = _remote_debugging.RemoteUnwinder(\n-                self.pid, only_active_thread=bool(self.all_threads), mode=self.mode, native=native, gc=gc,\n-                opcodes=opcodes, skip_non_matching_threads=skip_non_matching_threads,\n-                cache_frames=True, stats=self.collect_stats\n-            )\n+            # FIX: Properly handle all_threads vs only_active_thread parameters",
      "comment": "@vstinner I attempted to revert the changes to `_new_unwinder` as requested, but I found that they are actually required for the tests to pass.\r\n\r\nIf I revert to the original code, `test_profiling` fails because `idle_worker` threads are missing from the stats.\r\n\r\n**The Traceback:**\r\n```text\r\ntest test_profiling failed -- Traceback (most recent call last):\r\n  File \"/workspaces/cpython/Lib/test/test_profiling/test_sampling_profiler/test_modes.py\", line 197, in test_cpu_mode_integration_filtering\r\n    self.assertIn(\"idle_worker\", wall_mode_output)\r\nAssertionError: 'idle_worker' not found in 'Captured 401 samples...\r\n```\r\nThe Logic Error: The issue lies in the original code: `only_active_thread=bool(self.all_threads)`\r\n\r\nWhen `self.all_threads` is True, this sets `only_active_thread=True.` This effectively hides idle threads, which contradicts the intention of all_threads and causes the test failure shown above.\r\n\r\nIt seems my main fix (correcting _FREE_THREADED_BUILD) unmasked this existing logic bug, as the code now enters this path where it previously didn't.\r\n\r\nGiven this dependency, is it okay to keep the _new_unwinder fix in this PR?",
      "comment_id": 2672910430,
      "user": "DCchoudhury15",
      "created_at": "2026-01-08T15:53:05Z",
      "url": "https://github.com/python/cpython/pull/143426#discussion_r2672910430"
    },
    {
      "repo": "python/cpython",
      "pr_number": 143426,
      "file_path": "Lib/profiling/sampling/sample.py",
      "line": 76,
      "side": "RIGHT",
      "diff_hunk": "@@ -71,11 +73,19 @@ def _new_unwinder(self, native, gc, opcodes, skip_non_matching_threads):\n                 cache_frames=True, stats=self.collect_stats\n             )\n         else:\n-            unwinder = _remote_debugging.RemoteUnwinder(\n-                self.pid, only_active_thread=bool(self.all_threads), mode=self.mode, native=native, gc=gc,\n-                opcodes=opcodes, skip_non_matching_threads=skip_non_matching_threads,\n-                cache_frames=True, stats=self.collect_stats\n-            )\n+            # FIX: Properly handle all_threads vs only_active_thread parameters",
      "comment": "In this case, the `if self.all_threads:` change should be merged first. But I still consider that it would be better to have 2 pull requests.",
      "comment_id": 2672932501,
      "user": "vstinner",
      "created_at": "2026-01-08T15:58:58Z",
      "url": "https://github.com/python/cpython/pull/143426#discussion_r2672932501"
    },
    {
      "repo": "python/cpython",
      "pr_number": 143426,
      "file_path": "Lib/profiling/sampling/sample.py",
      "line": 87,
      "side": "RIGHT",
      "diff_hunk": "@@ -71,11 +73,19 @@ def _new_unwinder(self, native, gc, opcodes, skip_non_matching_threads):\n                 cache_frames=True, stats=self.collect_stats\n             )\n         else:\n-            unwinder = _remote_debugging.RemoteUnwinder(\n-                self.pid, only_active_thread=bool(self.all_threads), mode=self.mode, native=native, gc=gc,\n-                opcodes=opcodes, skip_non_matching_threads=skip_non_matching_threads,\n-                cache_frames=True, stats=self.collect_stats\n-            )\n+            # FIX: Properly handle all_threads vs only_active_thread parameters\n+            if self.all_threads:\n+                unwinder = _remote_debugging.RemoteUnwinder(\n+                    self.pid, all_threads=self.all_threads, mode=self.mode, native=native, gc=gc,\n+                    opcodes=opcodes, skip_non_matching_threads=skip_non_matching_threads,\n+                    cache_frames=True, stats=self.collect_stats\n+                )\n+            else:\n+                unwinder = _remote_debugging.RemoteUnwinder(\n+                    self.pid, only_active_thread=bool(self.all_threads), mode=self.mode, native=native, gc=gc,\n+                    opcodes=opcodes, skip_non_matching_threads=skip_non_matching_threads,\n+                    cache_frames=True, stats=self.collect_stats",
      "comment": "This code is almost the same as above. You should do something like:\n\n```py\nkwargs = {}\nif self.all_threads:\n    kwargs['all_threads' = self.all_threads\nunwinder = _remote_debugging.RemoteUnwinder(..., **kwargs)\n```",
      "comment_id": 2672937067,
      "user": "vstinner",
      "created_at": "2026-01-08T16:00:10Z",
      "url": "https://github.com/python/cpython/pull/143426#discussion_r2672937067"
    },
    {
      "repo": "python/cpython",
      "pr_number": 143426,
      "file_path": "Lib/profiling/sampling/sample.py",
      "line": 76,
      "side": "RIGHT",
      "diff_hunk": "@@ -71,11 +73,19 @@ def _new_unwinder(self, native, gc, opcodes, skip_non_matching_threads):\n                 cache_frames=True, stats=self.collect_stats\n             )\n         else:\n-            unwinder = _remote_debugging.RemoteUnwinder(\n-                self.pid, only_active_thread=bool(self.all_threads), mode=self.mode, native=native, gc=gc,\n-                opcodes=opcodes, skip_non_matching_threads=skip_non_matching_threads,\n-                cache_frames=True, stats=self.collect_stats\n-            )\n+            # FIX: Properly handle all_threads vs only_active_thread parameters",
      "comment": "@vstinner I have updated the PR as requested. \r\n\r\n1. Refactored the `_new_unwinder` logic to use `**kwargs`, which removes the code duplication.\r\n2. Reverted the `_FREE_THREADED_BUILD` detection fix.\r\n\r\nThis PR now focuses strictly on resolving the thread-handling logic bug. I will submit the build detection fix in a separate PR once this has been addressed.",
      "comment_id": 2673073448,
      "user": "DCchoudhury15",
      "created_at": "2026-01-08T16:38:02Z",
      "url": "https://github.com/python/cpython/pull/143426#discussion_r2673073448"
    },
    {
      "repo": "python/cpython",
      "pr_number": 144047,
      "file_path": "Lib/subprocess.py",
      "line": 2127,
      "side": "RIGHT",
      "diff_hunk": "@@ -2046,14 +2104,100 @@ def _try_wait(self, wait_flags):\n                 sts = 0\n             return (pid, sts)\n \n+        def _wait_pidfd(self, timeout):\n+            \"\"\"Wait for PID to terminate using pidfd_open() + poll().\n+            Linux >= 5.3 only.\n+            \"\"\"\n+            if not _CAN_USE_PIDFD_OPEN:\n+                return False\n+            try:\n+                pidfd = os.pidfd_open(self.pid, 0)\n+            except OSError:\n+                # May be:\n+                # - ESRCH: no such process\n+                # - EMFILE, ENFILE: too many open files (usually 1024)\n+                # - ENODEV: anonymous inode filesystem not supported\n+                # - EPERM, EACCES, ENOSYS: undocumented; may happen if\n+                #   blocked by security policy like SECCOMP\n+                return False\n+\n+            try:\n+                poller = select.poll()\n+                poller.register(pidfd, select.POLLIN)\n+                events = poller.poll(math.ceil(timeout * 1000))",
      "comment": "In Python 3.15, select.poll.poll() supports timeout with nanosecond resolution. It does round the timeout away from zero (ROUND_UP). I don't think that an explicit ceil() is needed here:\n\n```suggestion\n                events = poller.poll(timeout * 1000)\n```",
      "comment_id": 2712832025,
      "user": "vstinner",
      "created_at": "2026-01-21T14:30:13Z",
      "url": "https://github.com/python/cpython/pull/144047#discussion_r2712832025"
    },
    {
      "repo": "python/cpython",
      "pr_number": 144047,
      "file_path": "Lib/subprocess.py",
      "line": 2153,
      "side": "RIGHT",
      "diff_hunk": "@@ -2046,14 +2104,100 @@ def _try_wait(self, wait_flags):\n                 sts = 0\n             return (pid, sts)\n \n+        def _wait_pidfd(self, timeout):\n+            \"\"\"Wait for PID to terminate using pidfd_open() + poll().\n+            Linux >= 5.3 only.\n+            \"\"\"\n+            if not _CAN_USE_PIDFD_OPEN:\n+                return False\n+            try:\n+                pidfd = os.pidfd_open(self.pid, 0)\n+            except OSError:\n+                # May be:\n+                # - ESRCH: no such process\n+                # - EMFILE, ENFILE: too many open files (usually 1024)\n+                # - ENODEV: anonymous inode filesystem not supported\n+                # - EPERM, EACCES, ENOSYS: undocumented; may happen if\n+                #   blocked by security policy like SECCOMP\n+                return False\n+\n+            try:\n+                poller = select.poll()\n+                poller.register(pidfd, select.POLLIN)\n+                events = poller.poll(math.ceil(timeout * 1000))\n+                if not events:\n+                    raise TimeoutExpired(self.args, timeout)\n+                return True\n+            finally:\n+                os.close(pidfd)\n+\n+        def _wait_kqueue(self, timeout):\n+            \"\"\"Wait for PID to terminate using kqueue(). macOS and BSD only.\"\"\"\n+            if not _CAN_USE_KQUEUE:\n+                return False\n+            try:\n+                kq = select.kqueue()\n+            except OSError:\n+                # likely EMFILE / ENFILE (too many open files)\n+                return False\n+\n+            try:\n+                kev = select.kevent(\n+                    self.pid,\n+                    filter=select.KQ_FILTER_PROC,\n+                    flags=select.KQ_EV_ADD | select.KQ_EV_ONESHOT,\n+                    fflags=select.KQ_NOTE_EXIT,\n+                )\n+                try:\n+                    events = kq.control([kev], 1, timeout)  # wait\n+                except OSError as err:  # should never happen",
      "comment": "```suggestion\n                except OSError:  # should never happen\n```",
      "comment_id": 2712835659,
      "user": "vstinner",
      "created_at": "2026-01-21T14:31:02Z",
      "url": "https://github.com/python/cpython/pull/144047#discussion_r2712835659"
    },
    {
      "repo": "python/cpython",
      "pr_number": 144047,
      "file_path": "Lib/test/test_subprocess.py",
      "line": 4163,
      "side": "RIGHT",
      "diff_hunk": "@@ -4094,5 +4096,125 @@ def test_broken_pipe_cleanup(self):\n         self.assertTrue(proc.stdin.closed)\n \n \n+\n+class FastWaitTestCase(BaseTestCase):\n+    \"\"\"Tests for efficient (pidfd_open() + poll() / kqueue()) process\n+    waiting in subprocess.Popen.wait().\n+    \"\"\"\n+    CAN_USE_PIDFD_OPEN = subprocess._CAN_USE_PIDFD_OPEN\n+    CAN_USE_KQUEUE = subprocess._CAN_USE_KQUEUE\n+\n+    def assert_fast_waitpid_error(self, patch_point):\n+        # Emulate a case where pidfd_open() or kqueue() fails.\n+        # Busy-poll wait should be used as fallback.\n+        exc = OSError(errno.EMFILE, os.strerror(errno.EMFILE))\n+        with mock.patch(patch_point, side_effect=exc) as m:\n+            p = subprocess.Popen([sys.executable,\n+                                  \"-c\", \"import time; time.sleep(0.3)\"])\n+            with self.assertRaises(subprocess.TimeoutExpired):\n+                p.wait(timeout=0.0001)\n+            self.assertEqual(p.wait(timeout=support.SHORT_TIMEOUT), 0)\n+        assert m.called\n+\n+    @unittest.skipIf(not CAN_USE_PIDFD_OPEN, reason=\"needs pidfd_open()\")\n+    def test_wait_pidfd_open_error(self):\n+        self.assert_fast_waitpid_error(\"os.pidfd_open\")\n+\n+    @unittest.skipIf(not CAN_USE_KQUEUE, reason=\"needs kqueue() for proc\")\n+    def test_wait_kqueue_error(self):\n+        self.assert_fast_waitpid_error(\"select.kqueue\")\n+\n+    @unittest.skipIf(not CAN_USE_KQUEUE, reason=\"needs kqueue() for proc\")\n+    def test_kqueue_control_error(self):\n+        # Emulate a case where kqueue.control() fails. Busy-poll wait\n+        # should be used as fallback.\n+        p = subprocess.Popen([sys.executable,\n+                              \"-c\", \"import time; time.sleep(0.3)\"])\n+        kq_mock = mock.Mock()\n+        kq_mock.control.side_effect = OSError(\n+            errno.EPERM, os.strerror(errno.EPERM)\n+        )\n+        kq_mock.close = mock.Mock()\n+\n+        with mock.patch(\"select.kqueue\", return_value=kq_mock) as m:\n+            with self.assertRaises(subprocess.TimeoutExpired):\n+                p.wait(timeout=0.0001)\n+            self.assertEqual(p.wait(timeout=support.SHORT_TIMEOUT), 0)\n+        assert m.called\n+\n+    def assert_wait_race_condition(self, patch_target, real_func):\n+        # Call pidfd_open() / kqueue(), then terminate the process.\n+        # Make sure that the wait call (poll() / kqueue.control())\n+        # still works for a terminated PID.\n+        p = subprocess.Popen([sys.executable,\n+                              \"-c\", \"import time; time.sleep(0.3)\"])\n+\n+        def wrapper(*args, **kwargs):\n+            ret = real_func(*args, **kwargs)\n+            try:\n+                os.kill(p.pid, signal.SIGTERM)\n+                os.waitpid(p.pid, 0)\n+            except OSError:\n+                pass\n+            return ret\n+\n+        with mock.patch(patch_target, side_effect=wrapper) as m:\n+            status = p.wait(timeout=support.SHORT_TIMEOUT)\n+        assert m.called",
      "comment": "`assert` is skipped if Python is run with `-O` option.\n\n```suggestion\n        self.assertTrue(m.called)\n```",
      "comment_id": 2712902931,
      "user": "vstinner",
      "created_at": "2026-01-21T14:46:31Z",
      "url": "https://github.com/python/cpython/pull/144047#discussion_r2712902931"
    },
    {
      "repo": "python/cpython",
      "pr_number": 144047,
      "file_path": "Lib/test/test_subprocess.py",
      "line": 4194,
      "side": "RIGHT",
      "diff_hunk": "@@ -4094,5 +4096,125 @@ def test_broken_pipe_cleanup(self):\n         self.assertTrue(proc.stdin.closed)\n \n \n+\n+class FastWaitTestCase(BaseTestCase):\n+    \"\"\"Tests for efficient (pidfd_open() + poll() / kqueue()) process\n+    waiting in subprocess.Popen.wait().\n+    \"\"\"\n+    CAN_USE_PIDFD_OPEN = subprocess._CAN_USE_PIDFD_OPEN\n+    CAN_USE_KQUEUE = subprocess._CAN_USE_KQUEUE\n+\n+    def assert_fast_waitpid_error(self, patch_point):\n+        # Emulate a case where pidfd_open() or kqueue() fails.\n+        # Busy-poll wait should be used as fallback.\n+        exc = OSError(errno.EMFILE, os.strerror(errno.EMFILE))\n+        with mock.patch(patch_point, side_effect=exc) as m:\n+            p = subprocess.Popen([sys.executable,\n+                                  \"-c\", \"import time; time.sleep(0.3)\"])\n+            with self.assertRaises(subprocess.TimeoutExpired):\n+                p.wait(timeout=0.0001)\n+            self.assertEqual(p.wait(timeout=support.SHORT_TIMEOUT), 0)\n+        assert m.called\n+\n+    @unittest.skipIf(not CAN_USE_PIDFD_OPEN, reason=\"needs pidfd_open()\")\n+    def test_wait_pidfd_open_error(self):\n+        self.assert_fast_waitpid_error(\"os.pidfd_open\")\n+\n+    @unittest.skipIf(not CAN_USE_KQUEUE, reason=\"needs kqueue() for proc\")\n+    def test_wait_kqueue_error(self):\n+        self.assert_fast_waitpid_error(\"select.kqueue\")\n+\n+    @unittest.skipIf(not CAN_USE_KQUEUE, reason=\"needs kqueue() for proc\")\n+    def test_kqueue_control_error(self):\n+        # Emulate a case where kqueue.control() fails. Busy-poll wait\n+        # should be used as fallback.\n+        p = subprocess.Popen([sys.executable,\n+                              \"-c\", \"import time; time.sleep(0.3)\"])\n+        kq_mock = mock.Mock()\n+        kq_mock.control.side_effect = OSError(\n+            errno.EPERM, os.strerror(errno.EPERM)\n+        )\n+        kq_mock.close = mock.Mock()\n+\n+        with mock.patch(\"select.kqueue\", return_value=kq_mock) as m:\n+            with self.assertRaises(subprocess.TimeoutExpired):\n+                p.wait(timeout=0.0001)\n+            self.assertEqual(p.wait(timeout=support.SHORT_TIMEOUT), 0)\n+        assert m.called\n+\n+    def assert_wait_race_condition(self, patch_target, real_func):\n+        # Call pidfd_open() / kqueue(), then terminate the process.\n+        # Make sure that the wait call (poll() / kqueue.control())\n+        # still works for a terminated PID.\n+        p = subprocess.Popen([sys.executable,\n+                              \"-c\", \"import time; time.sleep(0.3)\"])\n+\n+        def wrapper(*args, **kwargs):\n+            ret = real_func(*args, **kwargs)\n+            try:\n+                os.kill(p.pid, signal.SIGTERM)\n+                os.waitpid(p.pid, 0)\n+            except OSError:\n+                pass\n+            return ret\n+\n+        with mock.patch(patch_target, side_effect=wrapper) as m:\n+            status = p.wait(timeout=support.SHORT_TIMEOUT)\n+        assert m.called\n+        self.assertEqual(status, 0)\n+\n+    @unittest.skipIf(not CAN_USE_PIDFD_OPEN, reason=\"needs pidfd_open()\")\n+    def test_pidfd_open_race(self):\n+        self.assert_wait_race_condition(\"os.pidfd_open\", os.pidfd_open)\n+\n+    @unittest.skipIf(not CAN_USE_KQUEUE, reason=\"needs kqueue() for proc\")\n+    def test_kqueue_race(self):\n+        self.assert_wait_race_condition(\"select.kqueue\", select.kqueue)\n+\n+    def assert_notification_without_immediate_reap(self, patch_target):\n+        # Verify fallback to busy polling when poll() / kqueue()\n+        # succeeds, but waitpid(pid, WNOHANG) returns (0, 0).\n+        def waitpid_wrapper(pid, flags):\n+            nonlocal ncalls\n+            ncalls += 1\n+            if ncalls == 1:\n+                return (0, 0)\n+            return real_waitpid(pid, flags)\n+\n+        ncalls = 0\n+        real_waitpid = os.waitpid\n+        with mock.patch.object(subprocess.Popen, patch_target, return_value=True) as m1:\n+            with mock.patch(\"os.waitpid\", side_effect=waitpid_wrapper) as m2:\n+                p = subprocess.Popen([sys.executable,\n+                                      \"-c\", \"import time; time.sleep(0.3)\"])\n+                with self.assertRaises(subprocess.TimeoutExpired):\n+                    p.wait(timeout=0.0001)\n+                self.assertEqual(p.wait(timeout=support.SHORT_TIMEOUT), 0)\n+        assert m1.called\n+        assert m2.called",
      "comment": "```suggestion\n        self.assertTrue(m1.called)\n        self.assertTrue(m2.called)\n```",
      "comment_id": 2712915942,
      "user": "vstinner",
      "created_at": "2026-01-21T14:49:32Z",
      "url": "https://github.com/python/cpython/pull/144047#discussion_r2712915942"
    },
    {
      "repo": "python/cpython",
      "pr_number": 144047,
      "file_path": "Lib/test/test_subprocess.py",
      "line": 4105,
      "side": "RIGHT",
      "diff_hunk": "@@ -4094,5 +4096,125 @@ def test_broken_pipe_cleanup(self):\n         self.assertTrue(proc.stdin.closed)\n \n \n+\n+class FastWaitTestCase(BaseTestCase):\n+    \"\"\"Tests for efficient (pidfd_open() + poll() / kqueue()) process\n+    waiting in subprocess.Popen.wait().\n+    \"\"\"\n+    CAN_USE_PIDFD_OPEN = subprocess._CAN_USE_PIDFD_OPEN\n+    CAN_USE_KQUEUE = subprocess._CAN_USE_KQUEUE",
      "comment": "You may extract constants to ease changing them if needed:\n\n```\n    COMMAND = [sys.executable, \"-c\", \"import time; time.sleep(0.3)\"]\n    WAIT_TIMEOUT = 0.0001  # 0.1 ms\n```",
      "comment_id": 2712934617,
      "user": "vstinner",
      "created_at": "2026-01-21T14:53:58Z",
      "url": "https://github.com/python/cpython/pull/144047#discussion_r2712934617"
    },
    {
      "repo": "python/cpython",
      "pr_number": 144047,
      "file_path": "Lib/test/test_subprocess.py",
      "line": 4217,
      "side": "RIGHT",
      "diff_hunk": "@@ -4094,5 +4096,125 @@ def test_broken_pipe_cleanup(self):\n         self.assertTrue(proc.stdin.closed)\n \n \n+\n+class FastWaitTestCase(BaseTestCase):\n+    \"\"\"Tests for efficient (pidfd_open() + poll() / kqueue()) process\n+    waiting in subprocess.Popen.wait().\n+    \"\"\"\n+    CAN_USE_PIDFD_OPEN = subprocess._CAN_USE_PIDFD_OPEN\n+    CAN_USE_KQUEUE = subprocess._CAN_USE_KQUEUE\n+\n+    def assert_fast_waitpid_error(self, patch_point):\n+        # Emulate a case where pidfd_open() or kqueue() fails.\n+        # Busy-poll wait should be used as fallback.\n+        exc = OSError(errno.EMFILE, os.strerror(errno.EMFILE))\n+        with mock.patch(patch_point, side_effect=exc) as m:\n+            p = subprocess.Popen([sys.executable,\n+                                  \"-c\", \"import time; time.sleep(0.3)\"])\n+            with self.assertRaises(subprocess.TimeoutExpired):\n+                p.wait(timeout=0.0001)\n+            self.assertEqual(p.wait(timeout=support.SHORT_TIMEOUT), 0)\n+        assert m.called\n+\n+    @unittest.skipIf(not CAN_USE_PIDFD_OPEN, reason=\"needs pidfd_open()\")\n+    def test_wait_pidfd_open_error(self):\n+        self.assert_fast_waitpid_error(\"os.pidfd_open\")\n+\n+    @unittest.skipIf(not CAN_USE_KQUEUE, reason=\"needs kqueue() for proc\")\n+    def test_wait_kqueue_error(self):\n+        self.assert_fast_waitpid_error(\"select.kqueue\")\n+\n+    @unittest.skipIf(not CAN_USE_KQUEUE, reason=\"needs kqueue() for proc\")\n+    def test_kqueue_control_error(self):\n+        # Emulate a case where kqueue.control() fails. Busy-poll wait\n+        # should be used as fallback.\n+        p = subprocess.Popen([sys.executable,\n+                              \"-c\", \"import time; time.sleep(0.3)\"])\n+        kq_mock = mock.Mock()\n+        kq_mock.control.side_effect = OSError(\n+            errno.EPERM, os.strerror(errno.EPERM)\n+        )\n+        kq_mock.close = mock.Mock()\n+\n+        with mock.patch(\"select.kqueue\", return_value=kq_mock) as m:\n+            with self.assertRaises(subprocess.TimeoutExpired):\n+                p.wait(timeout=0.0001)\n+            self.assertEqual(p.wait(timeout=support.SHORT_TIMEOUT), 0)\n+        assert m.called\n+\n+    def assert_wait_race_condition(self, patch_target, real_func):\n+        # Call pidfd_open() / kqueue(), then terminate the process.\n+        # Make sure that the wait call (poll() / kqueue.control())\n+        # still works for a terminated PID.\n+        p = subprocess.Popen([sys.executable,\n+                              \"-c\", \"import time; time.sleep(0.3)\"])\n+\n+        def wrapper(*args, **kwargs):\n+            ret = real_func(*args, **kwargs)\n+            try:\n+                os.kill(p.pid, signal.SIGTERM)\n+                os.waitpid(p.pid, 0)\n+            except OSError:\n+                pass\n+            return ret\n+\n+        with mock.patch(patch_target, side_effect=wrapper) as m:\n+            status = p.wait(timeout=support.SHORT_TIMEOUT)\n+        assert m.called\n+        self.assertEqual(status, 0)\n+\n+    @unittest.skipIf(not CAN_USE_PIDFD_OPEN, reason=\"needs pidfd_open()\")\n+    def test_pidfd_open_race(self):\n+        self.assert_wait_race_condition(\"os.pidfd_open\", os.pidfd_open)\n+\n+    @unittest.skipIf(not CAN_USE_KQUEUE, reason=\"needs kqueue() for proc\")\n+    def test_kqueue_race(self):\n+        self.assert_wait_race_condition(\"select.kqueue\", select.kqueue)\n+\n+    def assert_notification_without_immediate_reap(self, patch_target):\n+        # Verify fallback to busy polling when poll() / kqueue()\n+        # succeeds, but waitpid(pid, WNOHANG) returns (0, 0).\n+        def waitpid_wrapper(pid, flags):\n+            nonlocal ncalls\n+            ncalls += 1\n+            if ncalls == 1:\n+                return (0, 0)\n+            return real_waitpid(pid, flags)\n+\n+        ncalls = 0\n+        real_waitpid = os.waitpid\n+        with mock.patch.object(subprocess.Popen, patch_target, return_value=True) as m1:\n+            with mock.patch(\"os.waitpid\", side_effect=waitpid_wrapper) as m2:\n+                p = subprocess.Popen([sys.executable,\n+                                      \"-c\", \"import time; time.sleep(0.3)\"])\n+                with self.assertRaises(subprocess.TimeoutExpired):\n+                    p.wait(timeout=0.0001)\n+                self.assertEqual(p.wait(timeout=support.SHORT_TIMEOUT), 0)\n+        assert m1.called\n+        assert m2.called\n+\n+    @unittest.skipIf(not CAN_USE_PIDFD_OPEN, reason=\"needs pidfd_open()\")\n+    def test_pidfd_open_notification_without_immediate_reap(self):\n+        self.assert_notification_without_immediate_reap(\"_wait_pidfd\")\n+\n+    @unittest.skipIf(not CAN_USE_KQUEUE, reason=\"needs kqueue() for proc\")\n+    def test_kqueue_notification_without_immediate_reap(self):\n+        self.assert_notification_without_immediate_reap(\"_wait_kqueue\")\n+\n+    @unittest.skipUnless(\n+        CAN_USE_PIDFD_OPEN or CAN_USE_KQUEUE,\n+        \"fast wait mechanism not available\"\n+    )\n+    def test_fast_path_avoid_busy_loop(self):\n+        # assert that the busy loop is not called as long as the fast\n+        # wait is available\n+        with mock.patch('time.sleep') as m:\n+            p = subprocess.Popen([sys.executable,\n+                                  \"-c\", \"import time; time.sleep(0.3)\"])\n+            with self.assertRaises(subprocess.TimeoutExpired):\n+                p.wait(timeout=0.0001)\n+            self.assertEqual(p.wait(timeout=support.LONG_TIMEOUT), 0)\n+        assert not m.called",
      "comment": "```suggestion\n        self.assertFalse(m.called)\n```",
      "comment_id": 2712949311,
      "user": "vstinner",
      "created_at": "2026-01-21T14:57:24Z",
      "url": "https://github.com/python/cpython/pull/144047#discussion_r2712949311"
    },
    {
      "repo": "python/cpython",
      "pr_number": 144047,
      "file_path": "Lib/subprocess.py",
      "line": 54,
      "side": "RIGHT",
      "diff_hunk": "@@ -51,6 +51,7 @@\n import threading\n import warnings\n import contextlib\n+import select",
      "comment": "This change also imports select on Windows, whereas it's not used on Windows. Am I right? Why not leaving the import at line 124 to not import it on Windows?",
      "comment_id": 2713495900,
      "user": "vstinner",
      "created_at": "2026-01-21T16:59:04Z",
      "url": "https://github.com/python/cpython/pull/144047#discussion_r2713495900"
    },
    {
      "repo": "python/cpython",
      "pr_number": 140234,
      "file_path": "Lib/test/test_sys.py",
      "line": 1882,
      "side": "RIGHT",
      "diff_hunk": "@@ -1876,7 +1876,10 @@ class S(set):\n         check(S(), set(), '3P')\n         class FS(frozenset):\n             __slots__ = 'a', 'b', 'c'\n-        check(FS(), frozenset(), '3P')\n+\n+        class mytuple(tuple):\n+            pass\n+        check(FS([mytuple()]), frozenset([mytuple()]), '3P')",
      "comment": "Should we explicitly check if object is tracked or no? ",
      "comment_id": 2438623083,
      "user": "sergey-miryanov",
      "created_at": "2025-10-17T07:08:53Z",
      "url": "https://github.com/python/cpython/pull/140234#discussion_r2438623083"
    },
    {
      "repo": "python/cpython",
      "pr_number": 140234,
      "file_path": "Lib/test/test_sys.py",
      "line": 1882,
      "side": "RIGHT",
      "diff_hunk": "@@ -1876,7 +1876,10 @@ class S(set):\n         check(S(), set(), '3P')\n         class FS(frozenset):\n             __slots__ = 'a', 'b', 'c'\n-        check(FS(), frozenset(), '3P')\n+\n+        class mytuple(tuple):\n+            pass\n+        check(FS([mytuple()]), frozenset([mytuple()]), '3P')",
      "comment": "Maybe. Whether an object is tracked or not is an implementation detail that I would rather not introduce here (if possible). The checks seems to be about slots not taking additional memory beyond the obvious pointers for each slot. Adding a test for the untracked `frozenset` is not as simple as adding a check with `gc.is_tracked` as it seems whether or not the gc header takes additional memory is platform dependent. I will leave this as is for now so other devs can comment.",
      "comment_id": 2438749363,
      "user": "eendebakpt",
      "created_at": "2025-10-17T08:00:34Z",
      "url": "https://github.com/python/cpython/pull/140234#discussion_r2438749363"
    },
    {
      "repo": "python/cpython",
      "pr_number": 140234,
      "file_path": "Lib/test/test_set.py",
      "line": 2172,
      "side": "RIGHT",
      "diff_hunk": "@@ -2154,6 +2155,30 @@ def test_cuboctahedron(self):\n             for cubevert in edge:\n                 self.assertIn(cubevert, g)\n \n+class TestPySet_Add(unittest.TestCase):\n+    def test_set(self):\n+        # Test the PySet_Add c-api for set objects\n+        s = set()\n+        assert _testcapi.pyset_add(s, 1) == {1}\n+        self.assertRaises(TypeError, _testcapi.pyset_add, s, [])\n+\n+    def test_frozenset(self):\n+        # Test the PySet_Add c-api for fronzetset objects\n+        assert _testcapi.pyset_add(frozenset(), 1) == frozenset([1])\n+        frozen_set = frozenset()\n+        self.assertRaises(SystemError, _testcapi.pyset_add, frozen_set, 1)\n+\n+    def test_frozenset_gc_tracking(self):\n+        # see gh-140234",
      "comment": "IIUC, we add issue number (140232), not PR number.",
      "comment_id": 2464095793,
      "user": "efimov-mikhail",
      "created_at": "2025-10-26T20:23:19Z",
      "url": "https://github.com/python/cpython/pull/140234#discussion_r2464095793"
    },
    {
      "repo": "python/cpython",
      "pr_number": 140234,
      "file_path": "Lib/test/test_set.py",
      "line": 2166,
      "side": "RIGHT",
      "diff_hunk": "@@ -2154,6 +2155,30 @@ def test_cuboctahedron(self):\n             for cubevert in edge:\n                 self.assertIn(cubevert, g)\n \n+class TestPySet_Add(unittest.TestCase):\n+    def test_set(self):\n+        # Test the PySet_Add c-api for set objects\n+        s = set()\n+        assert _testcapi.pyset_add(s, 1) == {1}\n+        self.assertRaises(TypeError, _testcapi.pyset_add, s, [])\n+\n+    def test_frozenset(self):\n+        # Test the PySet_Add c-api for fronzetset objects",
      "comment": "```suggestion\n        # Test the PySet_Add c-api for frozenset objects\n```",
      "comment_id": 2464096058,
      "user": "efimov-mikhail",
      "created_at": "2025-10-26T20:23:58Z",
      "url": "https://github.com/python/cpython/pull/140234#discussion_r2464096058"
    },
    {
      "repo": "python/cpython",
      "pr_number": 140234,
      "file_path": "Lib/test/test_set.py",
      "line": 2172,
      "side": "RIGHT",
      "diff_hunk": "@@ -2154,6 +2155,30 @@ def test_cuboctahedron(self):\n             for cubevert in edge:\n                 self.assertIn(cubevert, g)\n \n+class TestPySet_Add(unittest.TestCase):\n+    def test_set(self):\n+        # Test the PySet_Add c-api for set objects\n+        s = set()\n+        assert _testcapi.pyset_add(s, 1) == {1}\n+        self.assertRaises(TypeError, _testcapi.pyset_add, s, [])\n+\n+    def test_frozenset(self):\n+        # Test the PySet_Add c-api for fronzetset objects\n+        assert _testcapi.pyset_add(frozenset(), 1) == frozenset([1])\n+        frozen_set = frozenset()\n+        self.assertRaises(SystemError, _testcapi.pyset_add, frozen_set, 1)\n+\n+    def test_frozenset_gc_tracking(self):\n+        # see gh-140234",
      "comment": "I would prefer the PR, as there is the detailed discussion. But I have no strong feelings on this, the other item is just 1 click away.",
      "comment_id": 2465761752,
      "user": "eendebakpt",
      "created_at": "2025-10-27T13:51:11Z",
      "url": "https://github.com/python/cpython/pull/140234#discussion_r2465761752"
    },
    {
      "repo": "python/cpython",
      "pr_number": 140234,
      "file_path": "Lib/test/test_set.py",
      "line": 2162,
      "side": "RIGHT",
      "diff_hunk": "@@ -2154,6 +2155,30 @@ def test_cuboctahedron(self):\n             for cubevert in edge:\n                 self.assertIn(cubevert, g)\n \n+class TestPySet_Add(unittest.TestCase):\n+    def test_set(self):\n+        # Test the PySet_Add c-api for set objects\n+        s = set()\n+        assert _testcapi.pyset_add(s, 1) == {1}",
      "comment": "Please use assertEqual():\r\n\r\n```suggestion\r\n        self.assertEqual(_testcapi.pyset_add(s, 1), {1})\r\n```\r\n\r\nSame remark for other tests.",
      "comment_id": 2470311100,
      "user": "vstinner",
      "created_at": "2025-10-28T16:48:33Z",
      "url": "https://github.com/python/cpython/pull/140234#discussion_r2470311100"
    },
    {
      "repo": "python/cpython",
      "pr_number": 140234,
      "file_path": "Lib/test/test_set.py",
      "line": 2169,
      "side": "RIGHT",
      "diff_hunk": "@@ -2154,6 +2155,30 @@ def test_cuboctahedron(self):\n             for cubevert in edge:\n                 self.assertIn(cubevert, g)\n \n+class TestPySet_Add(unittest.TestCase):\n+    def test_set(self):\n+        # Test the PySet_Add c-api for set objects\n+        s = set()\n+        assert _testcapi.pyset_add(s, 1) == {1}\n+        self.assertRaises(TypeError, _testcapi.pyset_add, s, [])\n+\n+    def test_frozenset(self):\n+        # Test the PySet_Add c-api for frozenset objects\n+        assert _testcapi.pyset_add(frozenset(), 1) == frozenset([1])\n+        frozen_set = frozenset()\n+        self.assertRaises(SystemError, _testcapi.pyset_add, frozen_set, 1)",
      "comment": "I don't understand why the second test fails, whereas the first succeed.",
      "comment_id": 2470316584,
      "user": "vstinner",
      "created_at": "2025-10-28T16:50:19Z",
      "url": "https://github.com/python/cpython/pull/140234#discussion_r2470316584"
    },
    {
      "repo": "python/cpython",
      "pr_number": 140234,
      "file_path": "Lib/test/test_set.py",
      "line": 2180,
      "side": "RIGHT",
      "diff_hunk": "@@ -2154,6 +2155,30 @@ def test_cuboctahedron(self):\n             for cubevert in edge:\n                 self.assertIn(cubevert, g)\n \n+class TestPySet_Add(unittest.TestCase):\n+    def test_set(self):\n+        # Test the PySet_Add c-api for set objects\n+        s = set()\n+        assert _testcapi.pyset_add(s, 1) == {1}\n+        self.assertRaises(TypeError, _testcapi.pyset_add, s, [])\n+\n+    def test_frozenset(self):\n+        # Test the PySet_Add c-api for frozenset objects\n+        assert _testcapi.pyset_add(frozenset(), 1) == frozenset([1])\n+        frozen_set = frozenset()\n+        self.assertRaises(SystemError, _testcapi.pyset_add, frozen_set, 1)\n+\n+    def test_frozenset_gc_tracking(self):\n+        # see gh-140234\n+        class TrackedHashableClass():\n+            pass\n+\n+        a = TrackedHashableClass()\n+        result_set = _testcapi.pyset_add(frozenset(), 1)\n+        assert not gc.is_tracked(result_set)\n+        result_set = _testcapi.pyset_add(frozenset(), a)\n+        assert gc.is_tracked(result_set)",
      "comment": "```suggestion\r\n        result_set = _testcapi.pyset_add(frozenset(), 1)\r\n        self.assertFalse(gc.is_tracked(result_set))\r\n        result_set = _testcapi.pyset_add(frozenset(), a)\r\n        self.assertTrue(gc.is_tracked(result_set))\r\n```",
      "comment_id": 2470318526,
      "user": "vstinner",
      "created_at": "2025-10-28T16:50:53Z",
      "url": "https://github.com/python/cpython/pull/140234#discussion_r2470318526"
    },
    {
      "repo": "python/cpython",
      "pr_number": 140234,
      "file_path": "Lib/test/test_set.py",
      "line": 2169,
      "side": "RIGHT",
      "diff_hunk": "@@ -2154,6 +2155,30 @@ def test_cuboctahedron(self):\n             for cubevert in edge:\n                 self.assertIn(cubevert, g)\n \n+class TestPySet_Add(unittest.TestCase):\n+    def test_set(self):\n+        # Test the PySet_Add c-api for set objects\n+        s = set()\n+        assert _testcapi.pyset_add(s, 1) == {1}\n+        self.assertRaises(TypeError, _testcapi.pyset_add, s, [])\n+\n+    def test_frozenset(self):\n+        # Test the PySet_Add c-api for frozenset objects\n+        assert _testcapi.pyset_add(frozenset(), 1) == frozenset([1])\n+        frozen_set = frozenset()\n+        self.assertRaises(SystemError, _testcapi.pyset_add, frozen_set, 1)",
      "comment": "The second test fails because the argument `frozen_set` is not uniquely referenced. The error is raised here: \r\n\r\nhttps://github.com/python/cpython/blob/ce4b0ede16aea62ee7b1e02df7e1538102a356da/Objects/setobject.c#L2777\r\n\r\nI will add a comment to the test ",
      "comment_id": 2471013615,
      "user": "eendebakpt",
      "created_at": "2025-10-28T20:55:39Z",
      "url": "https://github.com/python/cpython/pull/140234#discussion_r2471013615"
    },
    {
      "repo": "python/cpython",
      "pr_number": 140234,
      "file_path": "Lib/test/test_set.py",
      "line": 2216,
      "side": "RIGHT",
      "diff_hunk": "@@ -2212,6 +2213,31 @@ def test_cuboctahedron(self):\n             for cubevert in edge:\n                 self.assertIn(cubevert, g)\n \n+class TestPySet_Add(unittest.TestCase):",
      "comment": "Please move these tests to Lib/test/test_capi/test_set.py.",
      "comment_id": 2720968817,
      "user": "vstinner",
      "created_at": "2026-01-23T12:15:34Z",
      "url": "https://github.com/python/cpython/pull/140234#discussion_r2720968817"
    },
    {
      "repo": "python/cpython",
      "pr_number": 140234,
      "file_path": "Lib/test/test_set.py",
      "line": 2215,
      "side": "RIGHT",
      "diff_hunk": "@@ -2212,7 +2212,6 @@ def test_cuboctahedron(self):\n             for cubevert in edge:\n                 self.assertIn(cubevert, g)\n \n-\n #==============================================================================",
      "comment": "```suggestion\r\n\r\n#==============================================================================\r\n```",
      "comment_id": 2723021688,
      "user": "eendebakpt",
      "created_at": "2026-01-23T22:09:25Z",
      "url": "https://github.com/python/cpython/pull/140234#discussion_r2723021688"
    },
    {
      "repo": "python/cpython",
      "pr_number": 144250,
      "file_path": "Lib/test/test_ssl.py",
      "line": 1234,
      "side": "RIGHT",
      "diff_hunk": "@@ -1229,6 +1230,11 @@ def test_load_cert_chain(self):\n         with self.assertRaises(OSError) as cm:\n             ctx.load_cert_chain(NONEXISTINGCERT)\n         self.assertEqual(cm.exception.errno, errno.ENOENT)\n+        self.assertEqual(cm.exception.filename, NONEXISTINGCERT)\n+        with self.assertRaises(OSError) as cm:",
      "comment": "@picnixz I'm not sure what you mean in this context (?)",
      "comment_id": 2732118713,
      "user": "romuald",
      "created_at": "2026-01-27T13:52:34Z",
      "url": "https://github.com/python/cpython/pull/144250#discussion_r2732118713"
    },
    {
      "repo": "python/cpython",
      "pr_number": 144250,
      "file_path": "Lib/test/test_ssl.py",
      "line": 1234,
      "side": "RIGHT",
      "diff_hunk": "@@ -1229,6 +1230,11 @@ def test_load_cert_chain(self):\n         with self.assertRaises(OSError) as cm:\n             ctx.load_cert_chain(NONEXISTINGCERT)\n         self.assertEqual(cm.exception.errno, errno.ENOENT)\n+        self.assertEqual(cm.exception.filename, NONEXISTINGCERT)\n+        with self.assertRaises(OSError) as cm:",
      "comment": "Something like?\r\n\r\n```\r\nwith self.assertRaisesRegex(OSError, f\"No such file or directory.*{NONEXISTINGCERT}\"):\r\n  ctx.load_cert_chain(NONEXISTINGCERT)\r\n```",
      "comment_id": 2732207061,
      "user": "romuald",
      "created_at": "2026-01-27T14:12:45Z",
      "url": "https://github.com/python/cpython/pull/144250#discussion_r2732207061"
    },
    {
      "repo": "python/cpython",
      "pr_number": 144250,
      "file_path": "Lib/test/test_ssl.py",
      "line": 1234,
      "side": "RIGHT",
      "diff_hunk": "@@ -1229,6 +1230,11 @@ def test_load_cert_chain(self):\n         with self.assertRaises(OSError) as cm:\n             ctx.load_cert_chain(NONEXISTINGCERT)\n         self.assertEqual(cm.exception.errno, errno.ENOENT)\n+        self.assertEqual(cm.exception.filename, NONEXISTINGCERT)\n+        with self.assertRaises(OSError) as cm:",
      "comment": "That was what I had in mind, but maybe not that important actually. You can forget about this one actually (otherwise for consistency we would need to add it everywhere else)",
      "comment_id": 2732453543,
      "user": "picnixz",
      "created_at": "2026-01-27T15:02:58Z",
      "url": "https://github.com/python/cpython/pull/144250#discussion_r2732453543"
    },
    {
      "repo": "python/cpython",
      "pr_number": 144250,
      "file_path": "Lib/test/test_ssl.py",
      "line": 1234,
      "side": "RIGHT",
      "diff_hunk": "@@ -1229,6 +1230,11 @@ def test_load_cert_chain(self):\n         with self.assertRaises(OSError) as cm:\n             ctx.load_cert_chain(NONEXISTINGCERT)\n         self.assertEqual(cm.exception.errno, errno.ENOENT)\n+        self.assertEqual(cm.exception.filename, NONEXISTINGCERT)\n+        with self.assertRaises(OSError) as cm:",
      "comment": "No problem, my main issue what that the regexp was going to be pretty long, and I also have no idea if the errors can be localized in some cases",
      "comment_id": 2732464805,
      "user": "romuald",
      "created_at": "2026-01-27T15:05:43Z",
      "url": "https://github.com/python/cpython/pull/144250#discussion_r2732464805"
    },
    {
      "repo": "python/cpython",
      "pr_number": 144250,
      "file_path": "Lib/test/test_ssl.py",
      "line": 1234,
      "side": "RIGHT",
      "diff_hunk": "@@ -1229,6 +1230,11 @@ def test_load_cert_chain(self):\n         with self.assertRaises(OSError) as cm:\n             ctx.load_cert_chain(NONEXISTINGCERT)\n         self.assertEqual(cm.exception.errno, errno.ENOENT)\n+        self.assertEqual(cm.exception.filename, NONEXISTINGCERT)\n+        with self.assertRaises(OSError) as cm:",
      "comment": "The error message is not hardcoded in Python, but comes from `strerror(ENOENT)`.  I don't think that we should test it in test_ssl.",
      "comment_id": 2732515457,
      "user": "vstinner",
      "created_at": "2026-01-27T15:17:08Z",
      "url": "https://github.com/python/cpython/pull/144250#discussion_r2732515457"
    },
    {
      "repo": "python/cpython",
      "pr_number": 144260,
      "file_path": "Lib/test/test_ast/test_ast.py",
      "line": 1144,
      "side": "RIGHT",
      "diff_hunk": "@@ -1141,6 +1141,13 @@ def test_copy_with_parents(self):\n                     self.assertEqual(to_tuple(child.parent), to_tuple(node))\n \n \n+    def test_replace_non_str_kwarg(self):",
      "comment": "Oh, this test should be removed: ast.AST has no `__replace__()` method in Python 3.13.",
      "comment_id": 2731168951,
      "user": "vstinner",
      "created_at": "2026-01-27T09:53:04Z",
      "url": "https://github.com/python/cpython/pull/144260#discussion_r2731168951"
    },
    {
      "repo": "python/cpython",
      "pr_number": 123380,
      "file_path": "Lib/test/test_capi/test_exceptions.py",
      "line": 470,
      "side": "RIGHT",
      "diff_hunk": "@@ -415,6 +415,69 @@ def test_err_formatunraisable(self):\n         # CRASHES formatunraisable(NULL, NULL)\n \n \n+class PyUnicodeTranslateError(UnicodeTranslateError):\n+    # UnicodeTranslateError takes 4 arguments instead of 5,\n+    # so we just make a UnicodeTranslateError class that is\n+    # compatible with the UnicodeError.__init__.\n+    def __init__(self, encoding, *args, **kwargs):\n+        super().__init__(*args, **kwargs)\n+\n+\n+class TestUnicodeError(unittest.TestCase):\n+\n+    def test_unicode_error_start_value(self):\n+        # negative start is not allowed\n+        for exc_type, literal in [\n+            (UnicodeEncodeError, 'x'),\n+            (UnicodeDecodeError, b'x'),\n+            (PyUnicodeTranslateError, 'x'),\n+        ]:\n+            for obj_len in [0, 1, 2]:\n+                s = literal * obj_len\n+                with self.subTest(exc_type=exc_type, obj_len=obj_len):\n+                    self.assertRaises(ValueError, exc_type, 'utf-8', s, -1, 0, '?')\n+\n+    def test_unicode_encode_error_get_start(self):\n+        test_func = _testcapi.unicode_encode_get_start\n+        self._test_unicode_error_get_start('x', UnicodeEncodeError, test_func)\n+\n+    def test_unicode_decode_error_get_start(self):\n+        test_func = _testcapi.unicode_decode_get_start\n+        self._test_unicode_error_get_start(b'x', UnicodeDecodeError, test_func)\n+\n+    def test_unicode_translate_error_get_start(self):\n+        test_func = _testcapi.unicode_translate_get_start\n+        self._test_unicode_error_get_start('x', PyUnicodeTranslateError, test_func)\n+\n+    def _test_unicode_error_get_start(self, literal, exc_type, test_func):\n+        for obj_len, py_start, c_start in [\n+            # normal cases\n+            (5, 0, 0),\n+            (5, 1, 1),\n+            (5, 2, 2),\n+            # out of range start is clamped to max(0, obj_len - 1)\n+            (0, 0, 0),\n+            (0, 1, 0),\n+            (0, 10, 0),\n+            (5, 5, 4),\n+            (5, 10, 4),\n+        ]:\n+            c_start_computed = py_start\n+            if c_start_computed >= obj_len:\n+                if obj_len == 0:\n+                    c_start_computed = 0\n+                else:\n+                    c_start_computed = obj_len - 1",
      "comment": "I don't see the point of recomputing c_start value. Why not just using c_start?",
      "comment_id": 1735057529,
      "user": "vstinner",
      "created_at": "2024-08-28T17:31:11Z",
      "url": "https://github.com/python/cpython/pull/123380#discussion_r1735057529"
    },
    {
      "repo": "python/cpython",
      "pr_number": 123380,
      "file_path": "Lib/test/test_capi/test_exceptions.py",
      "line": 470,
      "side": "RIGHT",
      "diff_hunk": "@@ -415,6 +415,69 @@ def test_err_formatunraisable(self):\n         # CRASHES formatunraisable(NULL, NULL)\n \n \n+class PyUnicodeTranslateError(UnicodeTranslateError):\n+    # UnicodeTranslateError takes 4 arguments instead of 5,\n+    # so we just make a UnicodeTranslateError class that is\n+    # compatible with the UnicodeError.__init__.\n+    def __init__(self, encoding, *args, **kwargs):\n+        super().__init__(*args, **kwargs)\n+\n+\n+class TestUnicodeError(unittest.TestCase):\n+\n+    def test_unicode_error_start_value(self):\n+        # negative start is not allowed\n+        for exc_type, literal in [\n+            (UnicodeEncodeError, 'x'),\n+            (UnicodeDecodeError, b'x'),\n+            (PyUnicodeTranslateError, 'x'),\n+        ]:\n+            for obj_len in [0, 1, 2]:\n+                s = literal * obj_len\n+                with self.subTest(exc_type=exc_type, obj_len=obj_len):\n+                    self.assertRaises(ValueError, exc_type, 'utf-8', s, -1, 0, '?')\n+\n+    def test_unicode_encode_error_get_start(self):\n+        test_func = _testcapi.unicode_encode_get_start\n+        self._test_unicode_error_get_start('x', UnicodeEncodeError, test_func)\n+\n+    def test_unicode_decode_error_get_start(self):\n+        test_func = _testcapi.unicode_decode_get_start\n+        self._test_unicode_error_get_start(b'x', UnicodeDecodeError, test_func)\n+\n+    def test_unicode_translate_error_get_start(self):\n+        test_func = _testcapi.unicode_translate_get_start\n+        self._test_unicode_error_get_start('x', PyUnicodeTranslateError, test_func)\n+\n+    def _test_unicode_error_get_start(self, literal, exc_type, test_func):\n+        for obj_len, py_start, c_start in [\n+            # normal cases\n+            (5, 0, 0),\n+            (5, 1, 1),\n+            (5, 2, 2),\n+            # out of range start is clamped to max(0, obj_len - 1)\n+            (0, 0, 0),\n+            (0, 1, 0),\n+            (0, 10, 0),\n+            (5, 5, 4),\n+            (5, 10, 4),\n+        ]:\n+            c_start_computed = py_start\n+            if c_start_computed >= obj_len:\n+                if obj_len == 0:\n+                    c_start_computed = 0\n+                else:\n+                    c_start_computed = obj_len - 1",
      "comment": "Sorry, it was a remnant of my tests to check that the C implementation behaved as I though. It's no more needed. Thanks for spotting it.",
      "comment_id": 1735712197,
      "user": "picnixz",
      "created_at": "2024-08-29T07:32:26Z",
      "url": "https://github.com/python/cpython/pull/123380#discussion_r1735712197"
    },
    {
      "repo": "python/cpython",
      "pr_number": 123380,
      "file_path": "Lib/test/test_capi/test_exceptions.py",
      "line": 419,
      "side": "RIGHT",
      "diff_hunk": "@@ -415,6 +416,60 @@ def test_err_formatunraisable(self):\n         # CRASHES formatunraisable(NULL, NULL)\n \n \n+class PyUnicodeTranslateError(UnicodeTranslateError):",
      "comment": "I suggest to rename it to TestUnicodeTranslateError.",
      "comment_id": 1735846346,
      "user": "vstinner",
      "created_at": "2024-08-29T09:04:35Z",
      "url": "https://github.com/python/cpython/pull/123380#discussion_r1735846346"
    },
    {
      "repo": "python/cpython",
      "pr_number": 134010,
      "file_path": "Lib/test/test_fractions.py",
      "line": 427,
      "side": "RIGHT",
      "diff_hunk": "@@ -419,116 +421,101 @@ def testFromString(self):\n         self.assertRaisesMessage(\n             ZeroDivisionError, \"Fraction(3, 0)\",\n             F, \"3/0\")\n-        self.assertRaisesMessage(\n-            ValueError, \"Invalid literal for Fraction: '3/'\",\n-            F, \"3/\")\n-        self.assertRaisesMessage(\n-            ValueError, \"Invalid literal for Fraction: '/2'\",\n-            F, \"/2\")\n-        self.assertRaisesMessage(\n-            # Denominators don't need a sign.\n-            ValueError, \"Invalid literal for Fraction: '3/+2'\",\n-            F, \"3/+2\")\n-        self.assertRaisesMessage(\n-            # Imitate float's parsing.\n-            ValueError, \"Invalid literal for Fraction: '+ 3/2'\",\n-            F, \"+ 3/2\")\n-        self.assertRaisesMessage(\n-            # Avoid treating '.' as a regex special character.\n-            ValueError, \"Invalid literal for Fraction: '3a2'\",\n-            F, \"3a2\")\n-        self.assertRaisesMessage(\n-            # Don't accept combinations of decimals and rationals.\n-            ValueError, \"Invalid literal for Fraction: '3/7.2'\",\n-            F, \"3/7.2\")\n-        self.assertRaisesMessage(\n-            # Don't accept combinations of decimals and rationals.\n-            ValueError, \"Invalid literal for Fraction: '3.2/7'\",\n-            F, \"3.2/7\")\n-        self.assertRaisesMessage(\n-            # Allow 3. and .3, but not .\n-            ValueError, \"Invalid literal for Fraction: '.'\",\n-            F, \".\")\n-        self.assertRaisesMessage(\n-            ValueError, \"Invalid literal for Fraction: '_'\",\n-            F, \"_\")\n-        self.assertRaisesMessage(\n-            ValueError, \"Invalid literal for Fraction: '_1'\",\n-            F, \"_1\")\n-        self.assertRaisesMessage(\n-            ValueError, \"Invalid literal for Fraction: '1__2'\",\n-            F, \"1__2\")\n-        self.assertRaisesMessage(\n-            ValueError, \"Invalid literal for Fraction: '/_'\",\n-            F, \"/_\")\n-        self.assertRaisesMessage(\n-            ValueError, \"Invalid literal for Fraction: '1_/'\",\n-            F, \"1_/\")\n-        self.assertRaisesMessage(\n-            ValueError, \"Invalid literal for Fraction: '_1/'\",\n-            F, \"_1/\")\n-        self.assertRaisesMessage(\n-            ValueError, \"Invalid literal for Fraction: '1__2/'\",\n-            F, \"1__2/\")\n-        self.assertRaisesMessage(\n-            ValueError, \"Invalid literal for Fraction: '1/_'\",\n-            F, \"1/_\")\n-        self.assertRaisesMessage(\n-            ValueError, \"Invalid literal for Fraction: '1/_1'\",\n-            F, \"1/_1\")\n-        self.assertRaisesMessage(\n-            ValueError, \"Invalid literal for Fraction: '1/1__2'\",\n-            F, \"1/1__2\")\n-        self.assertRaisesMessage(\n-            ValueError, \"Invalid literal for Fraction: '1._111'\",\n-            F, \"1._111\")\n-        self.assertRaisesMessage(\n-            ValueError, \"Invalid literal for Fraction: '1.1__1'\",\n-            F, \"1.1__1\")\n-        self.assertRaisesMessage(\n-            ValueError, \"Invalid literal for Fraction: '1.1e+_1'\",\n-            F, \"1.1e+_1\")\n-        self.assertRaisesMessage(\n-            ValueError, \"Invalid literal for Fraction: '1.1e+1__1'\",\n-            F, \"1.1e+1__1\")\n-        self.assertRaisesMessage(\n-            ValueError, \"Invalid literal for Fraction: '123.dd'\",\n-            F, \"123.dd\")\n-        self.assertRaisesMessage(\n-            ValueError, \"Invalid literal for Fraction: '123.5_dd'\",\n-            F, \"123.5_dd\")\n-        self.assertRaisesMessage(\n-            ValueError, \"Invalid literal for Fraction: 'dd.5'\",\n-            F, \"dd.5\")\n-        self.assertRaisesMessage(\n-            ValueError, \"Invalid literal for Fraction: '7_dd'\",\n-            F, \"7_dd\")\n-        self.assertRaisesMessage(\n-            ValueError, \"Invalid literal for Fraction: '1/dd'\",\n-            F, \"1/dd\")\n-        self.assertRaisesMessage(\n-            ValueError, \"Invalid literal for Fraction: '1/123_dd'\",\n-            F, \"1/123_dd\")\n-        self.assertRaisesMessage(\n-            ValueError, \"Invalid literal for Fraction: '789edd'\",\n-            F, \"789edd\")\n-        self.assertRaisesMessage(\n-            ValueError, \"Invalid literal for Fraction: '789e2_dd'\",\n-            F, \"789e2_dd\")\n+\n+        def check_invalid(s):\n+            msg = \"Invalid literal for Fraction: \" + repr(s)\n+            self.assertRaisesMessage(ValueError, msg, F, s)",
      "comment": "This looks fine.\r\n\r\nBut maybe use subTest?\r\n\r\n```py\r\nfor value in [\"3/\", \"/2\",  # there can be a lot of...\r\n              # Denominators don't need a sign.\r\n              \"3/+2\", \"3/-2\",\r\n              # Imitate float's parsing.\r\n              ...]:\r\n    with self.subTest(value=value):\r\n        check_invalid(value)\r\n```",
      "comment_id": 2089222828,
      "user": "skirpichev",
      "created_at": "2025-05-14T15:31:49Z",
      "url": "https://github.com/python/cpython/pull/134010#discussion_r2089222828"
    },
    {
      "repo": "python/cpython",
      "pr_number": 134010,
      "file_path": "Lib/test/test_fractions.py",
      "line": 403,
      "side": "RIGHT",
      "diff_hunk": "@@ -395,12 +395,14 @@ class B(metaclass=M):\n \n     def testFromString(self):\n         self.assertEqual((5, 1), _components(F(\"5\")))\n+        self.assertEqual((5, 1), _components(F(\"005\")))\n         self.assertEqual((3, 2), _components(F(\"3/2\")))\n         self.assertEqual((3, 2), _components(F(\"3 / 2\")))\n         self.assertEqual((3, 2), _components(F(\" \\n  +3/2\")))\n         self.assertEqual((-3, 2), _components(F(\"-3/2  \")))\n-        self.assertEqual((13, 2), _components(F(\"    013/02 \\n  \")))\n+        self.assertEqual((13, 2), _components(F(\"    0013/002 \\n  \")))",
      "comment": "It is virtually the same test, but tests that more than one zero is accepted. There were no tests for leading zero in other forms, so they were added.",
      "comment_id": 2089264737,
      "user": "serhiy-storchaka",
      "created_at": "2025-05-14T15:53:15Z",
      "url": "https://github.com/python/cpython/pull/134010#discussion_r2089264737"
    },
    {
      "repo": "python/cpython",
      "pr_number": 134010,
      "file_path": "Lib/test/test_fractions.py",
      "line": 427,
      "side": "RIGHT",
      "diff_hunk": "@@ -419,116 +421,101 @@ def testFromString(self):\n         self.assertRaisesMessage(\n             ZeroDivisionError, \"Fraction(3, 0)\",\n             F, \"3/0\")\n-        self.assertRaisesMessage(\n-            ValueError, \"Invalid literal for Fraction: '3/'\",\n-            F, \"3/\")\n-        self.assertRaisesMessage(\n-            ValueError, \"Invalid literal for Fraction: '/2'\",\n-            F, \"/2\")\n-        self.assertRaisesMessage(\n-            # Denominators don't need a sign.\n-            ValueError, \"Invalid literal for Fraction: '3/+2'\",\n-            F, \"3/+2\")\n-        self.assertRaisesMessage(\n-            # Imitate float's parsing.\n-            ValueError, \"Invalid literal for Fraction: '+ 3/2'\",\n-            F, \"+ 3/2\")\n-        self.assertRaisesMessage(\n-            # Avoid treating '.' as a regex special character.\n-            ValueError, \"Invalid literal for Fraction: '3a2'\",\n-            F, \"3a2\")\n-        self.assertRaisesMessage(\n-            # Don't accept combinations of decimals and rationals.\n-            ValueError, \"Invalid literal for Fraction: '3/7.2'\",\n-            F, \"3/7.2\")\n-        self.assertRaisesMessage(\n-            # Don't accept combinations of decimals and rationals.\n-            ValueError, \"Invalid literal for Fraction: '3.2/7'\",\n-            F, \"3.2/7\")\n-        self.assertRaisesMessage(\n-            # Allow 3. and .3, but not .\n-            ValueError, \"Invalid literal for Fraction: '.'\",\n-            F, \".\")\n-        self.assertRaisesMessage(\n-            ValueError, \"Invalid literal for Fraction: '_'\",\n-            F, \"_\")\n-        self.assertRaisesMessage(\n-            ValueError, \"Invalid literal for Fraction: '_1'\",\n-            F, \"_1\")\n-        self.assertRaisesMessage(\n-            ValueError, \"Invalid literal for Fraction: '1__2'\",\n-            F, \"1__2\")\n-        self.assertRaisesMessage(\n-            ValueError, \"Invalid literal for Fraction: '/_'\",\n-            F, \"/_\")\n-        self.assertRaisesMessage(\n-            ValueError, \"Invalid literal for Fraction: '1_/'\",\n-            F, \"1_/\")\n-        self.assertRaisesMessage(\n-            ValueError, \"Invalid literal for Fraction: '_1/'\",\n-            F, \"_1/\")\n-        self.assertRaisesMessage(\n-            ValueError, \"Invalid literal for Fraction: '1__2/'\",\n-            F, \"1__2/\")\n-        self.assertRaisesMessage(\n-            ValueError, \"Invalid literal for Fraction: '1/_'\",\n-            F, \"1/_\")\n-        self.assertRaisesMessage(\n-            ValueError, \"Invalid literal for Fraction: '1/_1'\",\n-            F, \"1/_1\")\n-        self.assertRaisesMessage(\n-            ValueError, \"Invalid literal for Fraction: '1/1__2'\",\n-            F, \"1/1__2\")\n-        self.assertRaisesMessage(\n-            ValueError, \"Invalid literal for Fraction: '1._111'\",\n-            F, \"1._111\")\n-        self.assertRaisesMessage(\n-            ValueError, \"Invalid literal for Fraction: '1.1__1'\",\n-            F, \"1.1__1\")\n-        self.assertRaisesMessage(\n-            ValueError, \"Invalid literal for Fraction: '1.1e+_1'\",\n-            F, \"1.1e+_1\")\n-        self.assertRaisesMessage(\n-            ValueError, \"Invalid literal for Fraction: '1.1e+1__1'\",\n-            F, \"1.1e+1__1\")\n-        self.assertRaisesMessage(\n-            ValueError, \"Invalid literal for Fraction: '123.dd'\",\n-            F, \"123.dd\")\n-        self.assertRaisesMessage(\n-            ValueError, \"Invalid literal for Fraction: '123.5_dd'\",\n-            F, \"123.5_dd\")\n-        self.assertRaisesMessage(\n-            ValueError, \"Invalid literal for Fraction: 'dd.5'\",\n-            F, \"dd.5\")\n-        self.assertRaisesMessage(\n-            ValueError, \"Invalid literal for Fraction: '7_dd'\",\n-            F, \"7_dd\")\n-        self.assertRaisesMessage(\n-            ValueError, \"Invalid literal for Fraction: '1/dd'\",\n-            F, \"1/dd\")\n-        self.assertRaisesMessage(\n-            ValueError, \"Invalid literal for Fraction: '1/123_dd'\",\n-            F, \"1/123_dd\")\n-        self.assertRaisesMessage(\n-            ValueError, \"Invalid literal for Fraction: '789edd'\",\n-            F, \"789edd\")\n-        self.assertRaisesMessage(\n-            ValueError, \"Invalid literal for Fraction: '789e2_dd'\",\n-            F, \"789e2_dd\")\n+\n+        def check_invalid(s):\n+            msg = \"Invalid literal for Fraction: \" + repr(s)\n+            self.assertRaisesMessage(ValueError, msg, F, s)",
      "comment": "The main reason is that if we make error messages more specific, it is easier to add an optional parameter, while keeping default for most tests. For example, I originally planned to add the tests here that are currently in test_limit_int.",
      "comment_id": 2089279916,
      "user": "serhiy-storchaka",
      "created_at": "2025-05-14T16:01:55Z",
      "url": "https://github.com/python/cpython/pull/134010#discussion_r2089279916"
    },
    {
      "repo": "python/cpython",
      "pr_number": 140711,
      "file_path": "Lib/test/test_free_threading/test_lzma.py",
      "line": 27,
      "side": "RIGHT",
      "diff_hunk": "@@ -0,0 +1,56 @@\n+import unittest\n+\n+from test.support import import_helper, threading_helper\n+from test.support.threading_helper import run_concurrently\n+\n+lzma = import_helper.import_module(\"lzma\")\n+from lzma import LZMACompressor, LZMADecompressor\n+\n+from test.test_lzma import INPUT\n+\n+\n+NTHREADS = 10\n+\n+\n+@threading_helper.requires_working_threading()\n+class TestLZMA(unittest.TestCase):\n+    def test_compressor(self):\n+        lzc = LZMACompressor()\n+\n+        # First compress() outputs LZMA header\n+        header = lzc.compress(INPUT)\n+        self.assertGreater(len(header), 0)\n+\n+        def worker():\n+            # it should return empty bytes as it buffers data internally\n+            data = lzc.compress(INPUT)\n+            self.assertEqual(data, b\"\")",
      "comment": "The assertion `self.assertEqual(data, b\"\")` is flaky. In free-threaded mode, `compress()` may return data chunks non-deterministically due to race conditions in internal buffering.",
      "comment_id": 2470362000,
      "user": "ashm-dev",
      "created_at": "2025-10-28T17:04:16Z",
      "url": "https://github.com/python/cpython/pull/140711#discussion_r2470362000"
    },
    {
      "repo": "python/cpython",
      "pr_number": 140711,
      "file_path": "Lib/test/test_free_threading/test_lzma.py",
      "line": 47,
      "side": "RIGHT",
      "diff_hunk": "@@ -0,0 +1,56 @@\n+import unittest\n+\n+from test.support import import_helper, threading_helper\n+from test.support.threading_helper import run_concurrently\n+\n+lzma = import_helper.import_module(\"lzma\")\n+from lzma import LZMACompressor, LZMADecompressor\n+\n+from test.test_lzma import INPUT\n+\n+\n+NTHREADS = 10\n+\n+\n+@threading_helper.requires_working_threading()\n+class TestLZMA(unittest.TestCase):\n+    def test_compressor(self):\n+        lzc = LZMACompressor()\n+\n+        # First compress() outputs LZMA header\n+        header = lzc.compress(INPUT)\n+        self.assertGreater(len(header), 0)\n+\n+        def worker():\n+            # it should return empty bytes as it buffers data internally\n+            data = lzc.compress(INPUT)\n+            self.assertEqual(data, b\"\")\n+\n+        run_concurrently(worker_func=worker, nthreads=NTHREADS - 1)\n+        full_compressed = header + lzc.flush()\n+        decompressed = lzma.decompress(full_compressed)\n+        # The decompressed data should be INPUT repeated NTHREADS times\n+        self.assertEqual(decompressed, INPUT * NTHREADS)\n+\n+    def test_decompressor(self):\n+        chunk_size = 128\n+        chunks = [bytes([ord(\"a\") + i]) * chunk_size for i in range(NTHREADS)]\n+        input_data = b\"\".join(chunks)\n+        compressed = lzma.compress(input_data)\n+\n+        lzd = LZMADecompressor()\n+        output = []\n+\n+        def worker():\n+            data = lzd.decompress(compressed, chunk_size)\n+            self.assertEqual(len(data), chunk_size)\n+            output.append(data)",
      "comment": "`output.append(data)` without synchronization causes race conditions in free-threaded mode, potentially losing data or corrupting the list.",
      "comment_id": 2470363937,
      "user": "ashm-dev",
      "created_at": "2025-10-28T17:05:00Z",
      "url": "https://github.com/python/cpython/pull/140711#discussion_r2470363937"
    },
    {
      "repo": "python/cpython",
      "pr_number": 140711,
      "file_path": "Lib/test/test_free_threading/test_lzma.py",
      "line": 46,
      "side": "RIGHT",
      "diff_hunk": "@@ -0,0 +1,56 @@\n+import unittest\n+\n+from test.support import import_helper, threading_helper\n+from test.support.threading_helper import run_concurrently\n+\n+lzma = import_helper.import_module(\"lzma\")\n+from lzma import LZMACompressor, LZMADecompressor\n+\n+from test.test_lzma import INPUT\n+\n+\n+NTHREADS = 10\n+\n+\n+@threading_helper.requires_working_threading()\n+class TestLZMA(unittest.TestCase):\n+    def test_compressor(self):\n+        lzc = LZMACompressor()\n+\n+        # First compress() outputs LZMA header\n+        header = lzc.compress(INPUT)\n+        self.assertGreater(len(header), 0)\n+\n+        def worker():\n+            # it should return empty bytes as it buffers data internally\n+            data = lzc.compress(INPUT)\n+            self.assertEqual(data, b\"\")\n+\n+        run_concurrently(worker_func=worker, nthreads=NTHREADS - 1)\n+        full_compressed = header + lzc.flush()\n+        decompressed = lzma.decompress(full_compressed)\n+        # The decompressed data should be INPUT repeated NTHREADS times\n+        self.assertEqual(decompressed, INPUT * NTHREADS)\n+\n+    def test_decompressor(self):\n+        chunk_size = 128\n+        chunks = [bytes([ord(\"a\") + i]) * chunk_size for i in range(NTHREADS)]\n+        input_data = b\"\".join(chunks)\n+        compressed = lzma.compress(input_data)\n+\n+        lzd = LZMADecompressor()\n+        output = []\n+\n+        def worker():\n+            data = lzd.decompress(compressed, chunk_size)\n+            self.assertEqual(len(data), chunk_size)",
      "comment": "`self.assertEqual(len(data), chunk_size)` is wrong. `decompress()` may return less than `max_length` bytes. ",
      "comment_id": 2470367962,
      "user": "ashm-dev",
      "created_at": "2025-10-28T17:06:31Z",
      "url": "https://github.com/python/cpython/pull/140711#discussion_r2470367962"
    },
    {
      "repo": "python/cpython",
      "pr_number": 140711,
      "file_path": "Lib/test/test_free_threading/test_lzma.py",
      "line": 47,
      "side": "RIGHT",
      "diff_hunk": "@@ -0,0 +1,56 @@\n+import unittest\n+\n+from test.support import import_helper, threading_helper\n+from test.support.threading_helper import run_concurrently\n+\n+lzma = import_helper.import_module(\"lzma\")\n+from lzma import LZMACompressor, LZMADecompressor\n+\n+from test.test_lzma import INPUT\n+\n+\n+NTHREADS = 10\n+\n+\n+@threading_helper.requires_working_threading()\n+class TestLZMA(unittest.TestCase):\n+    def test_compressor(self):\n+        lzc = LZMACompressor()\n+\n+        # First compress() outputs LZMA header\n+        header = lzc.compress(INPUT)\n+        self.assertGreater(len(header), 0)\n+\n+        def worker():\n+            # it should return empty bytes as it buffers data internally\n+            data = lzc.compress(INPUT)\n+            self.assertEqual(data, b\"\")\n+\n+        run_concurrently(worker_func=worker, nthreads=NTHREADS - 1)\n+        full_compressed = header + lzc.flush()\n+        decompressed = lzma.decompress(full_compressed)\n+        # The decompressed data should be INPUT repeated NTHREADS times\n+        self.assertEqual(decompressed, INPUT * NTHREADS)\n+\n+    def test_decompressor(self):\n+        chunk_size = 128\n+        chunks = [bytes([ord(\"a\") + i]) * chunk_size for i in range(NTHREADS)]\n+        input_data = b\"\".join(chunks)\n+        compressed = lzma.compress(input_data)\n+\n+        lzd = LZMADecompressor()\n+        output = []\n+\n+        def worker():\n+            data = lzd.decompress(compressed, chunk_size)\n+            self.assertEqual(len(data), chunk_size)\n+            output.append(data)",
      "comment": "> `output.append(data)` without synchronization causes race conditions in free-threaded mode, potentially losing data or corrupting the list.\r\n\r\n@ashm-dev `list` is thread safe in free-threaded build.",
      "comment_id": 2470432112,
      "user": "yoney",
      "created_at": "2025-10-28T17:28:22Z",
      "url": "https://github.com/python/cpython/pull/140711#discussion_r2470432112"
    },
    {
      "repo": "python/cpython",
      "pr_number": 140711,
      "file_path": "Lib/test/test_free_threading/test_lzma.py",
      "line": 27,
      "side": "RIGHT",
      "diff_hunk": "@@ -0,0 +1,56 @@\n+import unittest\n+\n+from test.support import import_helper, threading_helper\n+from test.support.threading_helper import run_concurrently\n+\n+lzma = import_helper.import_module(\"lzma\")\n+from lzma import LZMACompressor, LZMADecompressor\n+\n+from test.test_lzma import INPUT\n+\n+\n+NTHREADS = 10\n+\n+\n+@threading_helper.requires_working_threading()\n+class TestLZMA(unittest.TestCase):\n+    def test_compressor(self):\n+        lzc = LZMACompressor()\n+\n+        # First compress() outputs LZMA header\n+        header = lzc.compress(INPUT)\n+        self.assertGreater(len(header), 0)\n+\n+        def worker():\n+            # it should return empty bytes as it buffers data internally\n+            data = lzc.compress(INPUT)\n+            self.assertEqual(data, b\"\")",
      "comment": "@ashm-dev Thanks for your comment. I\u2019m trying to verify/test the mutex is protecting the internal state and buffering, so there shouldn\u2019t be a race condition. Could you please explain which race condition you mean? That would help me understand your point better.",
      "comment_id": 2470586829,
      "user": "yoney",
      "created_at": "2025-10-28T18:13:35Z",
      "url": "https://github.com/python/cpython/pull/140711#discussion_r2470586829"
    },
    {
      "repo": "python/cpython",
      "pr_number": 140711,
      "file_path": "Lib/test/test_free_threading/test_lzma.py",
      "line": 47,
      "side": "RIGHT",
      "diff_hunk": "@@ -0,0 +1,56 @@\n+import unittest\n+\n+from test.support import import_helper, threading_helper\n+from test.support.threading_helper import run_concurrently\n+\n+lzma = import_helper.import_module(\"lzma\")\n+from lzma import LZMACompressor, LZMADecompressor\n+\n+from test.test_lzma import INPUT\n+\n+\n+NTHREADS = 10\n+\n+\n+@threading_helper.requires_working_threading()\n+class TestLZMA(unittest.TestCase):\n+    def test_compressor(self):\n+        lzc = LZMACompressor()\n+\n+        # First compress() outputs LZMA header\n+        header = lzc.compress(INPUT)\n+        self.assertGreater(len(header), 0)\n+\n+        def worker():\n+            # it should return empty bytes as it buffers data internally\n+            data = lzc.compress(INPUT)\n+            self.assertEqual(data, b\"\")\n+\n+        run_concurrently(worker_func=worker, nthreads=NTHREADS - 1)\n+        full_compressed = header + lzc.flush()\n+        decompressed = lzma.decompress(full_compressed)\n+        # The decompressed data should be INPUT repeated NTHREADS times\n+        self.assertEqual(decompressed, INPUT * NTHREADS)\n+\n+    def test_decompressor(self):\n+        chunk_size = 128\n+        chunks = [bytes([ord(\"a\") + i]) * chunk_size for i in range(NTHREADS)]\n+        input_data = b\"\".join(chunks)\n+        compressed = lzma.compress(input_data)\n+\n+        lzd = LZMADecompressor()\n+        output = []\n+\n+        def worker():\n+            data = lzd.decompress(compressed, chunk_size)\n+            self.assertEqual(len(data), chunk_size)\n+            output.append(data)",
      "comment": "In the free-threaded build, `list` operations use internal locks to avoid crashes, but thread safety isn\u2019t guaranteed for concurrent mutations \u2014 see [Python free-threading HOWTO](https://docs.python.org/3/howto/free-threading-python.html#concurrent-mutations).",
      "comment_id": 2470888626,
      "user": "ashm-dev",
      "created_at": "2025-10-28T20:05:02Z",
      "url": "https://github.com/python/cpython/pull/140711#discussion_r2470888626"
    },
    {
      "repo": "python/cpython",
      "pr_number": 140711,
      "file_path": "Lib/test/test_free_threading/test_lzma.py",
      "line": 46,
      "side": "RIGHT",
      "diff_hunk": "@@ -0,0 +1,56 @@\n+import unittest\n+\n+from test.support import import_helper, threading_helper\n+from test.support.threading_helper import run_concurrently\n+\n+lzma = import_helper.import_module(\"lzma\")\n+from lzma import LZMACompressor, LZMADecompressor\n+\n+from test.test_lzma import INPUT\n+\n+\n+NTHREADS = 10\n+\n+\n+@threading_helper.requires_working_threading()\n+class TestLZMA(unittest.TestCase):\n+    def test_compressor(self):\n+        lzc = LZMACompressor()\n+\n+        # First compress() outputs LZMA header\n+        header = lzc.compress(INPUT)\n+        self.assertGreater(len(header), 0)\n+\n+        def worker():\n+            # it should return empty bytes as it buffers data internally\n+            data = lzc.compress(INPUT)\n+            self.assertEqual(data, b\"\")\n+\n+        run_concurrently(worker_func=worker, nthreads=NTHREADS - 1)\n+        full_compressed = header + lzc.flush()\n+        decompressed = lzma.decompress(full_compressed)\n+        # The decompressed data should be INPUT repeated NTHREADS times\n+        self.assertEqual(decompressed, INPUT * NTHREADS)\n+\n+    def test_decompressor(self):\n+        chunk_size = 128\n+        chunks = [bytes([ord(\"a\") + i]) * chunk_size for i in range(NTHREADS)]\n+        input_data = b\"\".join(chunks)\n+        compressed = lzma.compress(input_data)\n+\n+        lzd = LZMADecompressor()\n+        output = []\n+\n+        def worker():\n+            data = lzd.decompress(compressed, chunk_size)\n+            self.assertEqual(len(data), chunk_size)",
      "comment": "@ashm-dev I agree that `decompress()` can return less than `max_length` if there isn\u2019t enough input. In this test, I\u2019m providing input that should produce at least `max_length` bytes. Is there anything else I might be missing? If I give enough valid input, is there any reason why `lzma` wouldn\u2019t return `max_length`?\r\n\r\nThere are other tests making similar assumptions. \r\n\r\nhttps://github.com/python/cpython/blob/ce4b0ede16aea62ee7b1e02df7e1538102a356da/Lib/test/test_lzma.py#L164-L169",
      "comment_id": 2470943130,
      "user": "yoney",
      "created_at": "2025-10-28T20:26:28Z",
      "url": "https://github.com/python/cpython/pull/140711#discussion_r2470943130"
    },
    {
      "repo": "python/cpython",
      "pr_number": 140711,
      "file_path": "Lib/test/test_free_threading/test_lzma.py",
      "line": 27,
      "side": "RIGHT",
      "diff_hunk": "@@ -0,0 +1,56 @@\n+import unittest\n+\n+from test.support import import_helper, threading_helper\n+from test.support.threading_helper import run_concurrently\n+\n+lzma = import_helper.import_module(\"lzma\")\n+from lzma import LZMACompressor, LZMADecompressor\n+\n+from test.test_lzma import INPUT\n+\n+\n+NTHREADS = 10\n+\n+\n+@threading_helper.requires_working_threading()\n+class TestLZMA(unittest.TestCase):\n+    def test_compressor(self):\n+        lzc = LZMACompressor()\n+\n+        # First compress() outputs LZMA header\n+        header = lzc.compress(INPUT)\n+        self.assertGreater(len(header), 0)\n+\n+        def worker():\n+            # it should return empty bytes as it buffers data internally\n+            data = lzc.compress(INPUT)\n+            self.assertEqual(data, b\"\")",
      "comment": "@ashm-dev Are you using ChatGPT or another LLM to review for you? If so, please don't -- it's not helpful. If not, please try to be clearer in your responses.",
      "comment_id": 2471368279,
      "user": "ZeroIntensity",
      "created_at": "2025-10-28T23:47:02Z",
      "url": "https://github.com/python/cpython/pull/140711#discussion_r2471368279"
    },
    {
      "repo": "python/cpython",
      "pr_number": 140711,
      "file_path": "Lib/test/test_free_threading/test_lzma.py",
      "line": 47,
      "side": "RIGHT",
      "diff_hunk": "@@ -0,0 +1,56 @@\n+import unittest\n+\n+from test.support import import_helper, threading_helper\n+from test.support.threading_helper import run_concurrently\n+\n+lzma = import_helper.import_module(\"lzma\")\n+from lzma import LZMACompressor, LZMADecompressor\n+\n+from test.test_lzma import INPUT\n+\n+\n+NTHREADS = 10\n+\n+\n+@threading_helper.requires_working_threading()\n+class TestLZMA(unittest.TestCase):\n+    def test_compressor(self):\n+        lzc = LZMACompressor()\n+\n+        # First compress() outputs LZMA header\n+        header = lzc.compress(INPUT)\n+        self.assertGreater(len(header), 0)\n+\n+        def worker():\n+            # it should return empty bytes as it buffers data internally\n+            data = lzc.compress(INPUT)\n+            self.assertEqual(data, b\"\")\n+\n+        run_concurrently(worker_func=worker, nthreads=NTHREADS - 1)\n+        full_compressed = header + lzc.flush()\n+        decompressed = lzma.decompress(full_compressed)\n+        # The decompressed data should be INPUT repeated NTHREADS times\n+        self.assertEqual(decompressed, INPUT * NTHREADS)\n+\n+    def test_decompressor(self):\n+        chunk_size = 128\n+        chunks = [bytes([ord(\"a\") + i]) * chunk_size for i in range(NTHREADS)]\n+        input_data = b\"\".join(chunks)\n+        compressed = lzma.compress(input_data)\n+\n+        lzd = LZMADecompressor()\n+        output = []\n+\n+        def worker():\n+            data = lzd.decompress(compressed, chunk_size)\n+            self.assertEqual(len(data), chunk_size)\n+            output.append(data)",
      "comment": "I think there may be some misunderstanding, could you please check the list test code below?\r\n\r\nhttps://github.com/python/cpython/blob/a3ce2f77f0813c214896ec66be3a26121f52361e/Lib/test/test_free_threading/test_list.py#L20-L28\r\n\r\n@ashm-dev I\u2019ve tried to address all your comments, but some are still unclear to me. Could you please clarify or resolve them? Thank you!",
      "comment_id": 2478547224,
      "user": "yoney",
      "created_at": "2025-10-30T15:26:02Z",
      "url": "https://github.com/python/cpython/pull/140711#discussion_r2478547224"
    },
    {
      "repo": "python/cpython",
      "pr_number": 140711,
      "file_path": "Lib/test/test_free_threading/test_lzma.py",
      "line": 52,
      "side": "RIGHT",
      "diff_hunk": "@@ -0,0 +1,56 @@\n+import unittest\n+\n+from test.support import import_helper, threading_helper\n+from test.support.threading_helper import run_concurrently\n+\n+lzma = import_helper.import_module(\"lzma\")\n+from lzma import LZMACompressor, LZMADecompressor\n+\n+from test.test_lzma import INPUT\n+\n+\n+NTHREADS = 10\n+\n+\n+@threading_helper.requires_working_threading()\n+class TestLZMA(unittest.TestCase):\n+    def test_compressor(self):\n+        lzc = LZMACompressor()\n+\n+        # First compress() outputs LZMA header\n+        header = lzc.compress(INPUT)\n+        self.assertGreater(len(header), 0)\n+\n+        def worker():\n+            # it should return empty bytes as it buffers data internally\n+            data = lzc.compress(INPUT)\n+            self.assertEqual(data, b\"\")\n+\n+        run_concurrently(worker_func=worker, nthreads=NTHREADS - 1)\n+        full_compressed = header + lzc.flush()\n+        decompressed = lzma.decompress(full_compressed)\n+        # The decompressed data should be INPUT repeated NTHREADS times\n+        self.assertEqual(decompressed, INPUT * NTHREADS)\n+\n+    def test_decompressor(self):\n+        chunk_size = 128\n+        chunks = [bytes([ord(\"a\") + i]) * chunk_size for i in range(NTHREADS)]\n+        input_data = b\"\".join(chunks)\n+        compressed = lzma.compress(input_data)\n+\n+        lzd = LZMADecompressor()\n+        output = []\n+\n+        def worker():\n+            data = lzd.decompress(compressed, chunk_size)\n+            self.assertEqual(len(data), chunk_size)\n+            output.append(data)\n+\n+        run_concurrently(worker_func=worker, nthreads=NTHREADS)\n+        self.assertEqual(len(output), NTHREADS)\n+        # Verify the expected chunks (order doesn't matter due to append race)\n+        self.assertEqual(set(output), set(chunks))",
      "comment": "```suggestion\n        self.assertSetEqual(set(output), set(chunks))\n```",
      "comment_id": 2499349053,
      "user": "kumaraditya303",
      "created_at": "2025-11-06T15:07:02Z",
      "url": "https://github.com/python/cpython/pull/140711#discussion_r2499349053"
    },
    {
      "repo": "python/cpython",
      "pr_number": 144137,
      "file_path": "Lib/test/test_frame_pointer_unwind.py",
      "line": 101,
      "side": "RIGHT",
      "diff_hunk": "@@ -0,0 +1,222 @@\n+import json\n+import os\n+import platform\n+import subprocess\n+import sys\n+import sysconfig\n+import unittest\n+\n+from test import support\n+from test.support import import_helper\n+\n+\n+_testinternalcapi = import_helper.import_module(\"_testinternalcapi\")\n+\n+\n+if not support.has_subprocess_support:\n+    raise unittest.SkipTest(\"test requires subprocess support\")\n+\n+\n+def _frame_pointers_expected(machine):\n+    cflags = \" \".join(\n+        value for value in (\n+            sysconfig.get_config_var(\"PY_CORE_CFLAGS\"),\n+            sysconfig.get_config_var(\"CFLAGS\"),\n+        )\n+        if value\n+    )\n+    if \"no-omit-frame-pointer\" in cflags:\n+        return True\n+    if \"omit-frame-pointer\" in cflags:\n+        return False\n+    if sys.platform == \"darwin\":\n+        # macOS x86_64/ARM64 always have frame pointer by default.\n+        return True\n+    if sys.platform == \"linux\":\n+        if machine in {\"aarch64\", \"arm64\"}:\n+            # 32-bit Linux is not supported\n+            if sys.maxsize < 2**32:\n+                return None\n+            return True\n+        if machine == \"x86_64\":\n+            return False\n+    if sys.platform == \"win32\":\n+        # MSVC ignores /Oy and /Oy- on x64/ARM64.\n+        if machine == \"arm64\":\n+            # Windows ARM64 guidelines recommend frame pointers (x29) for stack walking.\n+            return True\n+        elif machine == \"x86_64\":\n+            # Windows x64 uses unwind metadata; frame pointers are not required.\n+            return None\n+    return None\n+\n+\n+def _build_stack_and_unwind():\n+    import operator\n+\n+    def build_stack(n, unwinder, warming_up_caller=False):\n+        if warming_up_caller:\n+            return\n+        if n == 0:\n+            return unwinder()\n+        warming_up = True\n+        while warming_up:\n+            # Can't branch on JIT state inside JITted code, so compute here.\n+            warming_up = (\n+                hasattr(sys, \"_jit\")\n+                and sys._jit.is_enabled()\n+                and not sys._jit.is_active()\n+            )\n+            result = operator.call(build_stack, n - 1, unwinder, warming_up)\n+        return result\n+\n+    stack = build_stack(10, _testinternalcapi.manual_frame_pointer_unwind)\n+    return stack\n+\n+\n+def _classify_stack(stack, jit_enabled):\n+    labels = _testinternalcapi.classify_stack_addresses(stack, jit_enabled)\n+\n+    annotated = []\n+    jit_frames = 0\n+    python_frames = 0\n+    other_frames = 0\n+    for idx, (frame, tag) in enumerate(zip(stack, labels)):\n+        addr = int(frame)\n+        if tag == \"jit\":\n+            jit_frames += 1\n+        elif tag == \"python\":\n+            python_frames += 1\n+        else:\n+            other_frames += 1\n+        annotated.append((idx, addr, tag))\n+    return annotated, python_frames, jit_frames, other_frames\n+\n+\n+def _annotate_unwind():\n+    stack = _build_stack_and_unwind()\n+    jit_enabled = hasattr(sys, \"_jit\") and sys._jit.is_enabled()\n+    jit_backend = _testinternalcapi.get_jit_backend()\n+    ranges = _testinternalcapi.get_jit_code_ranges() if jit_enabled else []\n+    jit_code_ranges = len(ranges)",
      "comment": "that's a leftover of a previous logic to test the existence of JIT frames. Will be removing it.",
      "comment_id": 2720625552,
      "user": "diegorusso",
      "created_at": "2026-01-23T10:26:06Z",
      "url": "https://github.com/python/cpython/pull/144137#discussion_r2720625552"
    },
    {
      "repo": "python/cpython",
      "pr_number": 144137,
      "file_path": "Lib/test/test_frame_pointer_unwind.py",
      "line": 101,
      "side": "RIGHT",
      "diff_hunk": "@@ -0,0 +1,222 @@\n+import json\n+import os\n+import platform\n+import subprocess\n+import sys\n+import sysconfig\n+import unittest\n+\n+from test import support\n+from test.support import import_helper\n+\n+\n+_testinternalcapi = import_helper.import_module(\"_testinternalcapi\")\n+\n+\n+if not support.has_subprocess_support:\n+    raise unittest.SkipTest(\"test requires subprocess support\")\n+\n+\n+def _frame_pointers_expected(machine):\n+    cflags = \" \".join(\n+        value for value in (\n+            sysconfig.get_config_var(\"PY_CORE_CFLAGS\"),\n+            sysconfig.get_config_var(\"CFLAGS\"),\n+        )\n+        if value\n+    )\n+    if \"no-omit-frame-pointer\" in cflags:\n+        return True\n+    if \"omit-frame-pointer\" in cflags:\n+        return False\n+    if sys.platform == \"darwin\":\n+        # macOS x86_64/ARM64 always have frame pointer by default.\n+        return True\n+    if sys.platform == \"linux\":\n+        if machine in {\"aarch64\", \"arm64\"}:\n+            # 32-bit Linux is not supported\n+            if sys.maxsize < 2**32:\n+                return None\n+            return True\n+        if machine == \"x86_64\":\n+            return False\n+    if sys.platform == \"win32\":\n+        # MSVC ignores /Oy and /Oy- on x64/ARM64.\n+        if machine == \"arm64\":\n+            # Windows ARM64 guidelines recommend frame pointers (x29) for stack walking.\n+            return True\n+        elif machine == \"x86_64\":\n+            # Windows x64 uses unwind metadata; frame pointers are not required.\n+            return None\n+    return None\n+\n+\n+def _build_stack_and_unwind():\n+    import operator\n+\n+    def build_stack(n, unwinder, warming_up_caller=False):\n+        if warming_up_caller:\n+            return\n+        if n == 0:\n+            return unwinder()\n+        warming_up = True\n+        while warming_up:\n+            # Can't branch on JIT state inside JITted code, so compute here.\n+            warming_up = (\n+                hasattr(sys, \"_jit\")\n+                and sys._jit.is_enabled()\n+                and not sys._jit.is_active()\n+            )\n+            result = operator.call(build_stack, n - 1, unwinder, warming_up)\n+        return result\n+\n+    stack = build_stack(10, _testinternalcapi.manual_frame_pointer_unwind)\n+    return stack\n+\n+\n+def _classify_stack(stack, jit_enabled):\n+    labels = _testinternalcapi.classify_stack_addresses(stack, jit_enabled)\n+\n+    annotated = []\n+    jit_frames = 0\n+    python_frames = 0\n+    other_frames = 0\n+    for idx, (frame, tag) in enumerate(zip(stack, labels)):\n+        addr = int(frame)\n+        if tag == \"jit\":\n+            jit_frames += 1\n+        elif tag == \"python\":\n+            python_frames += 1\n+        else:\n+            other_frames += 1\n+        annotated.append((idx, addr, tag))\n+    return annotated, python_frames, jit_frames, other_frames\n+\n+\n+def _annotate_unwind():\n+    stack = _build_stack_and_unwind()\n+    jit_enabled = hasattr(sys, \"_jit\") and sys._jit.is_enabled()\n+    jit_backend = _testinternalcapi.get_jit_backend()\n+    ranges = _testinternalcapi.get_jit_code_ranges() if jit_enabled else []\n+    jit_code_ranges = len(ranges)",
      "comment": "I guess you referred only to `jit_code_ranges = len(ranges)`. The rest is needed.",
      "comment_id": 2720661008,
      "user": "diegorusso",
      "created_at": "2026-01-23T10:35:47Z",
      "url": "https://github.com/python/cpython/pull/144137#discussion_r2720661008"
    },
    {
      "repo": "python/cpython",
      "pr_number": 144137,
      "file_path": "Lib/test/test_frame_pointer_unwind.py",
      "line": 211,
      "side": "RIGHT",
      "diff_hunk": "@@ -0,0 +1,221 @@\n+import json\n+import os\n+import platform\n+import subprocess\n+import sys\n+import sysconfig\n+import unittest\n+\n+from test import support\n+from test.support import import_helper\n+\n+\n+_testinternalcapi = import_helper.import_module(\"_testinternalcapi\")\n+\n+\n+if not support.has_subprocess_support:\n+    raise unittest.SkipTest(\"test requires subprocess support\")\n+\n+\n+def _frame_pointers_expected(machine):\n+    cflags = \" \".join(\n+        value for value in (\n+            sysconfig.get_config_var(\"PY_CORE_CFLAGS\"),\n+            sysconfig.get_config_var(\"CFLAGS\"),\n+        )\n+        if value\n+    )\n+    if \"no-omit-frame-pointer\" in cflags:\n+        return True\n+    if \"omit-frame-pointer\" in cflags:\n+        return False\n+    if sys.platform == \"darwin\":\n+        # macOS x86_64/ARM64 always have frame pointer by default.\n+        return True\n+    if sys.platform == \"linux\":\n+        if machine in {\"aarch64\", \"arm64\"}:\n+            # 32-bit Linux is not supported\n+            if sys.maxsize < 2**32:\n+                return None\n+            return True\n+        if machine == \"x86_64\":\n+            return False\n+    if sys.platform == \"win32\":\n+        # MSVC ignores /Oy and /Oy- on x64/ARM64.\n+        if machine == \"arm64\":\n+            # Windows ARM64 guidelines recommend frame pointers (x29) for stack walking.\n+            return True\n+        elif machine == \"x86_64\":\n+            # Windows x64 uses unwind metadata; frame pointers are not required.\n+            return None\n+    return None\n+\n+\n+def _build_stack_and_unwind():\n+    import operator\n+\n+    def build_stack(n, unwinder, warming_up_caller=False):\n+        if warming_up_caller:\n+            return\n+        if n == 0:\n+            return unwinder()\n+        warming_up = True\n+        while warming_up:\n+            # Can't branch on JIT state inside JITted code, so compute here.\n+            warming_up = (\n+                hasattr(sys, \"_jit\")\n+                and sys._jit.is_enabled()\n+                and not sys._jit.is_active()\n+            )\n+            result = operator.call(build_stack, n - 1, unwinder, warming_up)\n+        return result\n+\n+    stack = build_stack(10, _testinternalcapi.manual_frame_pointer_unwind)\n+    return stack\n+\n+\n+def _classify_stack(stack, jit_enabled):\n+    labels = _testinternalcapi.classify_stack_addresses(stack, jit_enabled)\n+\n+    annotated = []\n+    jit_frames = 0\n+    python_frames = 0\n+    other_frames = 0\n+    for idx, (frame, tag) in enumerate(zip(stack, labels)):\n+        addr = int(frame)\n+        if tag == \"jit\":\n+            jit_frames += 1\n+        elif tag == \"python\":\n+            python_frames += 1\n+        else:\n+            other_frames += 1\n+        annotated.append((idx, addr, tag))\n+    return annotated, python_frames, jit_frames, other_frames\n+\n+\n+def _annotate_unwind():\n+    stack = _build_stack_and_unwind()\n+    jit_enabled = hasattr(sys, \"_jit\") and sys._jit.is_enabled()\n+    jit_backend = _testinternalcapi.get_jit_backend()\n+    ranges = _testinternalcapi.get_jit_code_ranges() if jit_enabled else []\n+    if jit_enabled and ranges:\n+        print(\"JIT ranges:\")\n+        for start, end in ranges:\n+            print(f\"  {int(start):#x}-{int(end):#x}\")\n+    annotated, python_frames, jit_frames, other_frames = _classify_stack(\n+        stack, jit_enabled\n+    )\n+    for idx, addr, tag in annotated:\n+        print(f\"#{idx:02d} {addr:#x} -> {tag}\")\n+    return json.dumps({\n+        \"length\": len(stack),\n+        \"python_frames\": python_frames,\n+        \"jit_frames\": jit_frames,\n+        \"other_frames\": other_frames,\n+        \"jit_backend\": jit_backend,\n+    })\n+\n+\n+def _manual_unwind_length(**env):\n+    code = (\n+        \"from test.test_frame_pointer_unwind import _annotate_unwind; \"\n+        \"print(_annotate_unwind());\"\n+    )\n+    run_env = os.environ.copy()\n+    run_env.update(env)\n+    proc = subprocess.run(\n+        [sys.executable, \"-c\", code],\n+        env=run_env,\n+        capture_output=True,\n+        text=True,\n+    )\n+    # Surface the output for debugging/visibility when running this test\n+    if proc.stdout:\n+        print(proc.stdout, end=\"\")\n+    if proc.returncode:\n+        raise RuntimeError(\n+            f\"unwind helper failed (rc={proc.returncode}): {proc.stderr or proc.stdout}\"\n+        )\n+    stdout_lines = proc.stdout.strip().splitlines()\n+    if not stdout_lines:\n+        raise RuntimeError(\"unwind helper produced no output\")\n+    try:\n+        return json.loads(stdout_lines[-1])\n+    except ValueError as exc:\n+        raise RuntimeError(\n+            f\"unexpected output from unwind helper: {proc.stdout!r}\"\n+        ) from exc\n+\n+\n+@support.requires_gil_enabled(\"test requires the GIL enabled\")\n+@unittest.skipIf(support.is_wasi, \"test not supported on WASI\")\n+class FramePointerUnwindTests(unittest.TestCase):\n+\n+    def setUp(self):\n+        super().setUp()\n+        machine = platform.machine().lower()\n+        expected = _frame_pointers_expected(machine)\n+        if expected is None:\n+            self.skipTest(f\"unsupported architecture for frame pointer check: {machine}\")\n+        try:\n+            _testinternalcapi.manual_frame_pointer_unwind()\n+        except RuntimeError as exc:\n+            if \"not supported\" in str(exc):\n+                self.skipTest(\"manual frame pointer unwinding not supported on this platform\")\n+            raise\n+        self.machine = machine\n+        self.frame_pointers_expected = expected\n+\n+    def test_manual_unwind_respects_frame_pointers(self):\n+        jit_available = hasattr(sys, \"_jit\") and sys._jit.is_available()\n+        envs = [({\"PYTHON_JIT\": \"0\"}, False)]\n+        if jit_available:\n+            envs.append(({\"PYTHON_JIT\": \"1\"}, True))\n+\n+        for env, using_jit in envs:\n+            with self.subTest(env=env):\n+                result = _manual_unwind_length(**env)\n+                jit_frames = result[\"jit_frames\"]\n+                python_frames = result.get(\"python_frames\", 0)\n+                jit_backend = result.get(\"jit_backend\")\n+                if self.frame_pointers_expected:\n+                    self.assertGreater(\n+                        python_frames,\n+                        0,\n+                        f\"expected to find Python frames on {self.machine} with env {env}\",\n+                    )\n+                    if using_jit:\n+                        if jit_backend == \"jit\":\n+                            self.assertGreater(\n+                                jit_frames,\n+                                0,\n+                                f\"expected to find JIT frames on {self.machine} with env {env}\",\n+                            )\n+                        else:\n+                            # jit_backend is \"interpreter\" or not present\n+                            self.assertEqual(\n+                                jit_frames,\n+                                0,\n+                                f\"unexpected JIT frames counted on {self.machine} with env {env}\",\n+                            )\n+                    else:\n+                        self.assertEqual(\n+                            jit_frames,\n+                            0,\n+                            f\"unexpected JIT frames counted on {self.machine} with env {env}\",\n+                        )\n+                else:\n+                    self.assertEqual(\n+                        python_frames,\n+                        1,\n+                        f\"unexpected Python frames counted on {self.machine} with env {env}\",",
      "comment": "We can see how CI behaves here but when frame pointers aren't expected, asserting exactly 1 Python frame seems brittle. If the unwinder happens to traverse one valid frame before hitting invalid data, this works, but this behavior isn't guaranteed. Consider whether <= 1 perhaps?",
      "comment_id": 2729673096,
      "user": "pablogsal",
      "created_at": "2026-01-26T23:30:03Z",
      "url": "https://github.com/python/cpython/pull/144137#discussion_r2729673096"
    },
    {
      "repo": "python/cpython",
      "pr_number": 144024,
      "file_path": "Lib/base64.py",
      "line": 29,
      "side": "RIGHT",
      "diff_hunk": "@@ -26,6 +26,8 @@\n     ]\n \n \n+_NOT_SPECIFIED = ['NOT SPECIFIED']",
      "comment": "Mmh, can't we use object() or a dummy class with its own repr instead? (your sentinel suggestion is smart though...)",
      "comment_id": 2723387400,
      "user": "picnixz",
      "created_at": "2026-01-24T01:28:40Z",
      "url": "https://github.com/python/cpython/pull/144024#discussion_r2723387400"
    },
    {
      "repo": "python/cpython",
      "pr_number": 144024,
      "file_path": "Lib/test/test_base64.py",
      "line": 334,
      "side": "RIGHT",
      "diff_hunk": "@@ -322,6 +326,19 @@ def test_b64decode_invalid_chars(self):\n                 base64.b64decode(bstr, validate=True)\n             with self.assertRaises(binascii.Error):\n                 base64.b64decode(bstr.decode('ascii'), validate=True)\n+            with self.assertRaises(binascii.Error):\n+                base64.b64decode(bstr, ignorechars=b'')\n+            if ignorechars is not None:\n+                self.assertEqual(\n+                    base64.b64decode(bstr, ignorechars=ignorechars),\n+                                 res)",
      "comment": "Maybe split this into two? (the alignment looks weird though)",
      "comment_id": 2723390377,
      "user": "picnixz",
      "created_at": "2026-01-24T01:29:48Z",
      "url": "https://github.com/python/cpython/pull/144024#discussion_r2723390377"
    },
    {
      "repo": "python/cpython",
      "pr_number": 144024,
      "file_path": "Lib/base64.py",
      "line": 29,
      "side": "RIGHT",
      "diff_hunk": "@@ -26,6 +26,8 @@\n     ]\n \n \n+_NOT_SPECIFIED = ['NOT SPECIFIED']",
      "comment": "We can use `object()`, but a list is better, it's repr gives you some idea what is it about. I always use it for such kind of singletons.\r\n\r\nI do not think it is worth to introduce a special class for this.",
      "comment_id": 2723853383,
      "user": "serhiy-storchaka",
      "created_at": "2026-01-24T07:50:25Z",
      "url": "https://github.com/python/cpython/pull/144024#discussion_r2723853383"
    },
    {
      "repo": "python/cpython",
      "pr_number": 144178,
      "file_path": "Lib/test/test_ast/test_ast.py",
      "line": 1448,
      "side": "RIGHT",
      "diff_hunk": "@@ -1443,6 +1443,12 @@ def test_replace_reject_unknown_instance_fields(self):\n         self.assertIs(node.ctx, context)\n         self.assertRaises(AttributeError, getattr, node, 'unknown')\n \n+    def test_replace_non_str_kwarg(self):\n+        node = ast.Name(id=\"x\")\n+        with self.assertRaisesRegex(TypeError, \"got an unexpected keyword argument <object object\"):",
      "comment": "This line is longer than 80 columns, I suggest to write it like that:\n\n```suggestion\n        errmsg = \"got an unexpected keyword argument <object object\"\n        with self.assertRaisesRegex(TypeError, errmsg):\n```",
      "comment_id": 2721584768,
      "user": "vstinner",
      "created_at": "2026-01-23T15:04:16Z",
      "url": "https://github.com/python/cpython/pull/144178#discussion_r2721584768"
    },
    {
      "repo": "python/cpython",
      "pr_number": 144178,
      "file_path": "Lib/test/test_ast/test_ast.py",
      "line": 3317,
      "side": "RIGHT",
      "diff_hunk": "@@ -3304,6 +3310,26 @@ class _AllFieldTypes(ast.AST):\n         self.assertIs(obj.a, None)\n         self.assertEqual(obj.b, [])\n \n+    def test_non_str_kwarg(self):\n+        with (\n+            self.assertRaises(TypeError),\n+            self.assertWarnsRegex(DeprecationWarning, \"got an unexpected keyword argument <object object\"),\n+        ):",
      "comment": "The last line is longer than 80 columns. I suggest to write it like that:\n\n\n```suggestion\n        warn_msg = \"got an unexpected keyword argument <object object\"\n        with (\n            self.assertRaises(TypeError),\n            self.assertWarnsRegex(DeprecationWarning, warn_msg),\n        ):\n```",
      "comment_id": 2721589492,
      "user": "vstinner",
      "created_at": "2026-01-23T15:05:18Z",
      "url": "https://github.com/python/cpython/pull/144178#discussion_r2721589492"
    },
    {
      "repo": "python/cpython",
      "pr_number": 144178,
      "file_path": "Parser/asdl_c.py",
      "line": 946,
      "side": "RIGHT",
      "diff_hunk": "@@ -942,7 +942,7 @@ def visitModule(self, mod):\n                 }\n                 if (p == 0) {\n                     PyErr_Format(PyExc_TypeError,\n-                        \"%.400s got multiple values for argument '%U'\",\n+                        \"%.400s got multiple values for argument %R\",\n                         Py_TYPE(self)->tp_name, key);",
      "comment": "Since we are modifying the error message, you must use the safer `%T` format:\n\n```suggestion\n                        \"%T got multiple values for argument %R\",\n                       self, key);\n```\n\nSame remark for the two other changes below.",
      "comment_id": 2721595406,
      "user": "vstinner",
      "created_at": "2026-01-23T15:06:33Z",
      "url": "https://github.com/python/cpython/pull/144178#discussion_r2721595406"
    },
    {
      "repo": "python/cpython",
      "pr_number": 144178,
      "file_path": "Parser/asdl_c.py",
      "line": 946,
      "side": "RIGHT",
      "diff_hunk": "@@ -942,7 +942,7 @@ def visitModule(self, mod):\n                 }\n                 if (p == 0) {\n                     PyErr_Format(PyExc_TypeError,\n-                        \"%.400s got multiple values for argument '%U'\",\n+                        \"%.400s got multiple values for argument %R\",\n                         Py_TYPE(self)->tp_name, key);",
      "comment": "It looks like this changes the error message to include the module name:\r\n\r\n```\r\n$ python3.14 -Wall -c 'import ast; ast.Name(idx=3)'\r\n<string>:1: DeprecationWarning: Name.__init__ got an unexpected keyword argument 'idx'. Support for arbitrary keyword arguments is deprecated and will be removed in Python 3.15.\r\n<string>:1: DeprecationWarning: Name.__init__ missing 1 required positional argument: 'id'. This will become an error in Python 3.15.\r\n$ ./python.exe -Wall -c 'import ast; ast.Name(idx=3)'\r\n<string>:1: DeprecationWarning: ast.Name.__init__ got an unexpected keyword argument 'idx'. Support for arbitrary keyword arguments is deprecated and will be removed in Python 3.15.\r\n<string>:1: DeprecationWarning: ast.Name.__init__ missing 1 required positional argument: 'id'. This will become an error in Python 3.15.\r\n```\r\n\r\nI feel like that's a change we should only make in 3.15, not in the bugfix releases.\r\n\r\nWhy is %T safer?",
      "comment_id": 2723574574,
      "user": "JelleZijlstra",
      "created_at": "2026-01-24T04:05:45Z",
      "url": "https://github.com/python/cpython/pull/144178#discussion_r2723574574"
    },
    {
      "repo": "python/cpython",
      "pr_number": 144126,
      "file_path": "Lib/test/test_email/test_generator.py",
      "line": 338,
      "side": "RIGHT",
      "diff_hunk": "@@ -334,6 +334,8 @@ def fold(self, **kwargs):\n \n                 with self.assertRaises(email.errors.HeaderWriteError):\n                     message.as_string()\n+                with self.assertRaises(email.errors.HeaderWriteError):\n+                    message.as_bytes()",
      "comment": "Ah, I see, this is the added test.  Yes, this looks fine.\r\n\r\nThat docstring on the test method should be a comment, though (I know that's pre-existing).",
      "comment_id": 2714351470,
      "user": "bitdancer",
      "created_at": "2026-01-21T21:09:38Z",
      "url": "https://github.com/python/cpython/pull/144126#discussion_r2714351470"
    },
    {
      "repo": "python/cpython",
      "pr_number": 144126,
      "file_path": "Lib/test/test_email/test_policy.py",
      "line": 322,
      "side": "RIGHT",
      "diff_hunk": "@@ -319,6 +319,10 @@ def fold(self, **kwargs):\n                     message.as_string(),\n                     f\"{text}\\nBody\",\n                 )\n+                self.assertEqual(",
      "comment": "Likewise here the test docstring should be a comment.",
      "comment_id": 2714352061,
      "user": "bitdancer",
      "created_at": "2026-01-21T21:09:51Z",
      "url": "https://github.com/python/cpython/pull/144126#discussion_r2714352061"
    },
    {
      "repo": "python/cpython",
      "pr_number": 144126,
      "file_path": "Lib/test/test_email/test_policy.py",
      "line": 322,
      "side": "RIGHT",
      "diff_hunk": "@@ -319,6 +319,10 @@ def fold(self, **kwargs):\n                     message.as_string(),\n                     f\"{text}\\nBody\",\n                 )\n+                self.assertEqual(",
      "comment": "Done in https://github.com/python/cpython/pull/144126/commits/697163bd4dd5d2959e8f8cacd68901711a814801",
      "comment_id": 2717356815,
      "user": "sethmlarson",
      "created_at": "2026-01-22T15:17:35Z",
      "url": "https://github.com/python/cpython/pull/144126#discussion_r2717356815"
    },
    {
      "repo": "python/cpython",
      "pr_number": 144126,
      "file_path": "Lib/test/test_email/test_generator.py",
      "line": 338,
      "side": "RIGHT",
      "diff_hunk": "@@ -334,6 +334,8 @@ def fold(self, **kwargs):\n \n                 with self.assertRaises(email.errors.HeaderWriteError):\n                     message.as_string()\n+                with self.assertRaises(email.errors.HeaderWriteError):\n+                    message.as_bytes()",
      "comment": "Done in https://github.com/python/cpython/pull/144126/commits/697163bd4dd5d2959e8f8cacd68901711a814801",
      "comment_id": 2717357681,
      "user": "sethmlarson",
      "created_at": "2026-01-22T15:17:49Z",
      "url": "https://github.com/python/cpython/pull/144126#discussion_r2717357681"
    },
    {
      "repo": "python/cpython",
      "pr_number": 140559,
      "file_path": "Lib/test/support/__init__.py",
      "line": 3189,
      "side": "RIGHT",
      "diff_hunk": "@@ -3184,3 +3184,47 @@ def linked_to_musl():\n         return _linked_to_musl\n     _linked_to_musl = tuple(map(int, version.split('.')))\n     return _linked_to_musl\n+\n+\n+try:",
      "comment": "I think this will be easier to do in `Lib/test/test_capi/test_misc.py`. In particular only need to\r\n1. Add a new `_testcapimodule.c` entry point that makes a Py_buffer C API of the PyObject passed to it, gets the pointer and turns that pointer into a `PyObject *` (https://docs.python.org/3/c-api/long.html#c.PyLong_FromVoidPtr) which it returns\r\n2. one alignment test across the range of types and constructions care about.\r\n\r\nI like how your existing test iterates through / tests all the different array typecodes.\r\n\r\nI think it would be good to extend the test to both test empty (the size that caused this bug) + non-empty arrays (they should also be aligned)",
      "comment_id": 2479914586,
      "user": "cmaloney",
      "created_at": "2025-10-31T01:22:59Z",
      "url": "https://github.com/python/cpython/pull/140559#discussion_r2479914586"
    },
    {
      "repo": "python/cpython",
      "pr_number": 140559,
      "file_path": "Lib/test/support/__init__.py",
      "line": 3189,
      "side": "RIGHT",
      "diff_hunk": "@@ -3184,3 +3184,47 @@ def linked_to_musl():\n         return _linked_to_musl\n     _linked_to_musl = tuple(map(int, version.split('.')))\n     return _linked_to_musl\n+\n+\n+try:",
      "comment": "Actually found a better test file for the alignment pieces to live in: `Lib/test/test_buffer.py`; still should implement \"get the pointer\" in _testcapimodule.c",
      "comment_id": 2480020131,
      "user": "cmaloney",
      "created_at": "2025-10-31T02:59:49Z",
      "url": "https://github.com/python/cpython/pull/140559#discussion_r2480020131"
    },
    {
      "repo": "python/cpython",
      "pr_number": 140559,
      "file_path": "Lib/test/test_buffer.py",
      "line": 4452,
      "side": "RIGHT",
      "diff_hunk": "@@ -4447,6 +4447,43 @@ def test_bytearray_release_buffer_read_flag(self):\n         with self.assertRaises(SystemError):\n             obj.__buffer__(inspect.BufferFlags.WRITE)\n \n+    @support.cpython_only\n+    @unittest.skipIf(_testcapi is None, \"requires _testcapi\")\n+    @unittest.skipIf(struct is None, \"requires struct\")",
      "comment": "I think the `struct` / `_struct` module is always compiled in with `CPython` nowadays so this skipIf can be removed as it's covered by `cpython_only`",
      "comment_id": 2666997247,
      "user": "cmaloney",
      "created_at": "2026-01-07T04:06:34Z",
      "url": "https://github.com/python/cpython/pull/140559#discussion_r2666997247"
    },
    {
      "repo": "python/cpython",
      "pr_number": 140559,
      "file_path": "Lib/test/test_buffer.py",
      "line": 4452,
      "side": "RIGHT",
      "diff_hunk": "@@ -4447,6 +4447,43 @@ def test_bytearray_release_buffer_read_flag(self):\n         with self.assertRaises(SystemError):\n             obj.__buffer__(inspect.BufferFlags.WRITE)\n \n+    @support.cpython_only\n+    @unittest.skipIf(_testcapi is None, \"requires _testcapi\")\n+    @unittest.skipIf(struct is None, \"requires struct\")",
      "comment": "the `unittest.skipIf(struct is None, ...)` check can be removed here, it's implied by `support.cpython_only` (that `struct` can be None / is optional was added with the `struct` module ~13 years ago it looks like is no longer needed. Not something to fix in this PR though)",
      "comment_id": 2667003149,
      "user": "cmaloney",
      "created_at": "2026-01-07T04:11:05Z",
      "url": "https://github.com/python/cpython/pull/140559#discussion_r2667003149"
    },
    {
      "repo": "python/cpython",
      "pr_number": 140559,
      "file_path": "Lib/test/test_buffer.py",
      "line": 4470,
      "side": "RIGHT",
      "diff_hunk": "@@ -4447,6 +4447,41 @@ def test_bytearray_release_buffer_read_flag(self):\n         with self.assertRaises(SystemError):\n             obj.__buffer__(inspect.BufferFlags.WRITE)\n \n+    @support.cpython_only\n+    @unittest.skipIf(_testcapi is None, \"requires _testcapi\")\n+    def test_bytearray_alignment(self):\n+        # gh-140557: pointer alignment of buffers including empty allocation\n+        # should be at least to `size_t`.\n+        align = struct.calcsize(\"N\")\n+        cases = [\n+            bytearray(),\n+            bytearray(1),\n+            bytearray(b\"0123456789abcdef\"),\n+            bytearray(16),\n+        ]\n+        ptrs = [_testcapi.buffer_pointer_as_int(array) for array in cases]\n+        self.assertEqual([ptr % align for ptr in ptrs], [0]*len(ptrs))\n+\n+    @support.cpython_only\n+    @unittest.skipIf(_testcapi is None, \"requires _testcapi\")\n+    def test_array_alignment(self):\n+        # gh-140557: pointer alignment of buffers including empty allocation\n+        # should be at least to `size_t`.\n+        align = struct.calcsize(\"N\")",
      "comment": "Chatted with a Rust export on the \"Rust for CPython Discord\". Came to the conclusion with them that we should align `array.array` to 8 bytes since it can store 8 byte things (typecodes: \"qQd\", https://docs.python.org/3/library/array.html#array.array). On 32 bit platforms `size_t` will only require 4 byte alignment.\n\nRather than `struct.calcsize(\"N\")` I think we can just use the constant 8 here + have a comment pointing to the item size table in the `array.array`doc?",
      "comment_id": 2671464284,
      "user": "cmaloney",
      "created_at": "2026-01-08T08:50:37Z",
      "url": "https://github.com/python/cpython/pull/140559#discussion_r2671464284"
    },
    {
      "repo": "python/cpython",
      "pr_number": 140559,
      "file_path": "Lib/test/test_buffer.py",
      "line": 4470,
      "side": "RIGHT",
      "diff_hunk": "@@ -4447,6 +4447,41 @@ def test_bytearray_release_buffer_read_flag(self):\n         with self.assertRaises(SystemError):\n             obj.__buffer__(inspect.BufferFlags.WRITE)\n \n+    @support.cpython_only\n+    @unittest.skipIf(_testcapi is None, \"requires _testcapi\")\n+    def test_bytearray_alignment(self):\n+        # gh-140557: pointer alignment of buffers including empty allocation\n+        # should be at least to `size_t`.\n+        align = struct.calcsize(\"N\")\n+        cases = [\n+            bytearray(),\n+            bytearray(1),\n+            bytearray(b\"0123456789abcdef\"),\n+            bytearray(16),\n+        ]\n+        ptrs = [_testcapi.buffer_pointer_as_int(array) for array in cases]\n+        self.assertEqual([ptr % align for ptr in ptrs], [0]*len(ptrs))\n+\n+    @support.cpython_only\n+    @unittest.skipIf(_testcapi is None, \"requires _testcapi\")\n+    def test_array_alignment(self):\n+        # gh-140557: pointer alignment of buffers including empty allocation\n+        # should be at least to `size_t`.\n+        align = struct.calcsize(\"N\")",
      "comment": "Chiming in to confirm that we had this discussion. :+1: for aligning to 8 bytes on all platforms; it seems simpler and less surprising than trying to marginally optimize for the *subset* of 4-byte platforms where `long long` and `double` are 4-byte aligned. Might also have benefits for other purposes, such as SIMD algorithms.\n\nPer https://en.wikipedia.org/wiki/Data_structure_alignment:\n\n> when compiling for 32-bit x86:\n[...]\n> A double (eight bytes) will be 8-byte aligned on Windows and 4-byte aligned on Linux (8-byte with -malign-double compile time option).\n> A long long (eight bytes) will be 8-byte aligned on Windows and 4-byte aligned on Linux (8-byte with -malign-double compile time option).",
      "comment_id": 2671475566,
      "user": "joshtriplett",
      "created_at": "2026-01-08T08:54:07Z",
      "url": "https://github.com/python/cpython/pull/140559#discussion_r2671475566"
    },
    {
      "repo": "python/cpython",
      "pr_number": 140559,
      "file_path": "Lib/test/test_buffer.py",
      "line": 4470,
      "side": "RIGHT",
      "diff_hunk": "@@ -4447,6 +4447,41 @@ def test_bytearray_release_buffer_read_flag(self):\n         with self.assertRaises(SystemError):\n             obj.__buffer__(inspect.BufferFlags.WRITE)\n \n+    @support.cpython_only\n+    @unittest.skipIf(_testcapi is None, \"requires _testcapi\")\n+    def test_bytearray_alignment(self):\n+        # gh-140557: pointer alignment of buffers including empty allocation\n+        # should be at least to `size_t`.\n+        align = struct.calcsize(\"N\")\n+        cases = [\n+            bytearray(),\n+            bytearray(1),\n+            bytearray(b\"0123456789abcdef\"),\n+            bytearray(16),\n+        ]\n+        ptrs = [_testcapi.buffer_pointer_as_int(array) for array in cases]\n+        self.assertEqual([ptr % align for ptr in ptrs], [0]*len(ptrs))\n+\n+    @support.cpython_only\n+    @unittest.skipIf(_testcapi is None, \"requires _testcapi\")\n+    def test_array_alignment(self):\n+        # gh-140557: pointer alignment of buffers including empty allocation\n+        # should be at least to `size_t`.\n+        align = struct.calcsize(\"N\")",
      "comment": "Oh yeah thanks - I was overly focused on how the buffer inside `PyBytes` ends up aligned and not thinking properly.   I changed the test of `array.array` to take the max item size from all available formats for the platform, though I can change it to be hard-coded 8 if that's preferred.",
      "comment_id": 2671756845,
      "user": "jakelishman",
      "created_at": "2026-01-08T10:17:05Z",
      "url": "https://github.com/python/cpython/pull/140559#discussion_r2671756845"
    },
    {
      "repo": "python/cpython",
      "pr_number": 140559,
      "file_path": "Lib/test/test_buffer.py",
      "line": 4470,
      "side": "RIGHT",
      "diff_hunk": "@@ -4447,6 +4447,41 @@ def test_bytearray_release_buffer_read_flag(self):\n         with self.assertRaises(SystemError):\n             obj.__buffer__(inspect.BufferFlags.WRITE)\n \n+    @support.cpython_only\n+    @unittest.skipIf(_testcapi is None, \"requires _testcapi\")\n+    def test_bytearray_alignment(self):\n+        # gh-140557: pointer alignment of buffers including empty allocation\n+        # should be at least to `size_t`.\n+        align = struct.calcsize(\"N\")\n+        cases = [\n+            bytearray(),\n+            bytearray(1),\n+            bytearray(b\"0123456789abcdef\"),\n+            bytearray(16),\n+        ]\n+        ptrs = [_testcapi.buffer_pointer_as_int(array) for array in cases]\n+        self.assertEqual([ptr % align for ptr in ptrs], [0]*len(ptrs))\n+\n+    @support.cpython_only\n+    @unittest.skipIf(_testcapi is None, \"requires _testcapi\")\n+    def test_array_alignment(self):\n+        # gh-140557: pointer alignment of buffers including empty allocation\n+        # should be at least to `size_t`.\n+        align = struct.calcsize(\"N\")",
      "comment": "Max of `array.array`'s elements I like / means both new element adding or buffer allocation changes would result in the test needing an intentional update / helps ensure changes are intentional",
      "comment_id": 2672989681,
      "user": "cmaloney",
      "created_at": "2026-01-08T16:13:48Z",
      "url": "https://github.com/python/cpython/pull/140559#discussion_r2672989681"
    },
    {
      "repo": "python/cpython",
      "pr_number": 140559,
      "file_path": "Lib/test/test_buffer.py",
      "line": 4470,
      "side": "RIGHT",
      "diff_hunk": "@@ -4447,6 +4447,41 @@ def test_bytearray_release_buffer_read_flag(self):\n         with self.assertRaises(SystemError):\n             obj.__buffer__(inspect.BufferFlags.WRITE)\n \n+    @support.cpython_only\n+    @unittest.skipIf(_testcapi is None, \"requires _testcapi\")\n+    def test_bytearray_alignment(self):\n+        # gh-140557: pointer alignment of buffers including empty allocation\n+        # should be at least to `size_t`.\n+        align = struct.calcsize(\"N\")\n+        cases = [\n+            bytearray(),\n+            bytearray(1),\n+            bytearray(b\"0123456789abcdef\"),\n+            bytearray(16),\n+        ]\n+        ptrs = [_testcapi.buffer_pointer_as_int(array) for array in cases]\n+        self.assertEqual([ptr % align for ptr in ptrs], [0]*len(ptrs))\n+\n+    @support.cpython_only\n+    @unittest.skipIf(_testcapi is None, \"requires _testcapi\")\n+    def test_array_alignment(self):\n+        # gh-140557: pointer alignment of buffers including empty allocation\n+        # should be at least to `size_t`.\n+        align = struct.calcsize(\"N\")",
      "comment": "I haven't fully paged in to this (awesome!) workstream yet, but I wanted to note that I'm *incredibly* inspired by the unstable rust `core::simd` feature, and I maintain both the https://docs rs/re2 and https://docs.rs/vectrorscan-async (hyperscan) rust wrapper crates.\r\n\r\nWith regards to SIMD, I have two ideas:\r\n1. Reflecting the FFI constraints into SIMD-compatible memory for rust `core::simd` could be a great investigation for rust's external types proposal: https://github.com/rust-lang/rust/issues/43467#issuecomment-3741642799\r\n2. I have begun work that searches for SIMD instructions in the cpython configure script: https://discuss.python.org/t/add-zero-copy-conversion-of-bytearray-to-bytes-by-providing-bytes/79164/70\r\n    - I would be very interested to discuss this sort of thing further. In that post I mention two specific use cases (one of them being url quoting in pip) which would produce very noticeable real-world speedups in foundational python tooling like pip.\r\n\r\nI'm also right now doing a cleanroom implementation of zstd in rust (I can explain my concerns with ruzstd) and making use of alignment for SIMD to improve over the zstd C implementation (currently working on a ring buffer component), which I very much intend to plug into a python native module.\r\n\r\nThis comment is in full support of this PR and this workstream. Please let me know if I can follow up and learn more about this! Thanks! \\^\\_\\^",
      "comment_id": 2694056220,
      "user": "cosmicexplorer",
      "created_at": "2026-01-15T11:42:12Z",
      "url": "https://github.com/python/cpython/pull/140559#discussion_r2694056220"
    },
    {
      "repo": "python/cpython",
      "pr_number": 144138,
      "file_path": "Lib/test/test_array.py",
      "line": 80,
      "side": "RIGHT",
      "diff_hunk": "@@ -67,6 +67,25 @@ def test_empty(self):\n         a += a\n         self.assertEqual(len(a), 0)\n \n+    def test_fromlist_reentrant_index_mutation(self):\n+\n+        class Evil:\n+            def __init__(self, lst):\n+                self.lst = lst\n+            def __index__(self):\n+                self.lst.clear()\n+                return \"not an int\"\n+\n+        for typecode in ('I', 'L', 'Q'):\n+            lst = []",
      "comment": "Let's wrap this in a `with self.subTest(typecode=typecode)`",
      "comment_id": 2721376850,
      "user": "ZeroIntensity",
      "created_at": "2026-01-23T14:15:48Z",
      "url": "https://github.com/python/cpython/pull/144138#discussion_r2721376850"
    },
    {
      "repo": "python/cpython",
      "pr_number": 144138,
      "file_path": "Lib/test/test_array.py",
      "line": 84,
      "side": "RIGHT",
      "diff_hunk": "@@ -67,6 +67,26 @@ def test_empty(self):\n         a += a\n         self.assertEqual(len(a), 0)\n \n+    def test_fromlist_reentrant_index_mutation(self):\n+\n+        class Evil:\n+            def __init__(self, lst):\n+                self.lst = lst\n+            def __index__(self):\n+                self.lst.clear()\n+                return \"not an int\"\n+\n+        for typecode in ('I', 'L', 'Q'):\n+            with self.subTest(typecode=typecode):\n+                lst = []\n+                e = Evil(lst)\n+                lst.append(e)\n+                del e",
      "comment": "```suggestion\n                lst.append(Evil(lst))\n```",
      "comment_id": 2721645594,
      "user": "vstinner",
      "created_at": "2026-01-23T15:17:45Z",
      "url": "https://github.com/python/cpython/pull/144138#discussion_r2721645594"
    },
    {
      "repo": "python/cpython",
      "pr_number": 144138,
      "file_path": "Lib/test/test_array.py",
      "line": 88,
      "side": "RIGHT",
      "diff_hunk": "@@ -67,6 +67,26 @@ def test_empty(self):\n         a += a\n         self.assertEqual(len(a), 0)\n \n+    def test_fromlist_reentrant_index_mutation(self):\n+\n+        class Evil:\n+            def __init__(self, lst):\n+                self.lst = lst\n+            def __index__(self):\n+                self.lst.clear()\n+                return \"not an int\"\n+\n+        for typecode in ('I', 'L', 'Q'):\n+            with self.subTest(typecode=typecode):\n+                lst = []\n+                e = Evil(lst)\n+                lst.append(e)\n+                del e\n+                a = array.array(typecode)\n+                with self.assertRaises(TypeError):\n+                    a.fromlist(lst)\n+",
      "comment": "Please remove one empty line: 2 empty lines are enough.",
      "comment_id": 2721647471,
      "user": "vstinner",
      "created_at": "2026-01-23T15:18:11Z",
      "url": "https://github.com/python/cpython/pull/144138#discussion_r2721647471"
    },
    {
      "repo": "python/cpython",
      "pr_number": 137464,
      "file_path": "Lib/test/test_collections.py",
      "line": 966,
      "side": "RIGHT",
      "diff_hunk": "@@ -963,7 +963,7 @@ class AnextOnly:\n             async def __anext__(self):\n                 raise StopAsyncIteration\n         self.assertNotIsInstance(AnextOnly(), AsyncIterator)\n-        self.validate_abstract_methods(AsyncIterator, '__anext__', '__aiter__')\n+        self.validate_abstract_methods(AsyncIterator, '__anext__')",
      "comment": "Since `AsyncIterator.__aiter__` is not abstract, it is correct to remove it here.",
      "comment_id": 2259176685,
      "user": "sobolevn",
      "created_at": "2025-08-07T06:07:45Z",
      "url": "https://github.com/python/cpython/pull/137464#discussion_r2259176685"
    },
    {
      "repo": "python/cpython",
      "pr_number": 137464,
      "file_path": "Lib/test/test_collections.py",
      "line": 1861,
      "side": "RIGHT",
      "diff_hunk": "@@ -1859,7 +1858,7 @@ def test_MutableMapping(self):\n         for sample in [dict]:\n             self.assertIsInstance(sample(), MutableMapping)\n             self.assertIsSubclass(sample, MutableMapping)\n-        self.validate_abstract_methods(MutableMapping, '__contains__', '__iter__', '__len__',\n+        self.validate_abstract_methods(MutableMapping, '__iter__', '__len__',",
      "comment": "`__contains__` is also not abstract, except for `Container.__contains__`",
      "comment_id": 2259182086,
      "user": "sobolevn",
      "created_at": "2025-08-07T06:09:00Z",
      "url": "https://github.com/python/cpython/pull/137464#discussion_r2259182086"
    },
    {
      "repo": "python/cpython",
      "pr_number": 144108,
      "file_path": "Lib/test/test_ctypes/test_pointers.py",
      "line": 479,
      "side": "RIGHT",
      "diff_hunk": "@@ -472,6 +473,23 @@ class C(Structure):\n         ptr.set_type(c_int)\n         self.assertIs(ptr._type_, c_int)\n \n+class TestPointerStringProto(unittest.TestCase):\n+    def test_pointer_string_proto_argtypes_error(self):\n+        with self.assertWarns(DeprecationWarning):\n+            BadType = ctypes.POINTER(\"BugTrigger\")",
      "comment": "I would prefer to avoid deprecated code path. You should be able to use:\n\n```suggestion\n        class BadType(ctypes._Pointer):                                   \n            # _type_ is not defined on purpose                            \n            pass\n```",
      "comment_id": 2722092876,
      "user": "vstinner",
      "created_at": "2026-01-23T17:00:55Z",
      "url": "https://github.com/python/cpython/pull/144108#discussion_r2722092876"
    },
    {
      "repo": "python/cpython",
      "pr_number": 144108,
      "file_path": "Lib/test/test_ctypes/test_pointers.py",
      "line": 488,
      "side": "RIGHT",
      "diff_hunk": "@@ -472,6 +473,23 @@ class C(Structure):\n         ptr.set_type(c_int)\n         self.assertIs(ptr._type_, c_int)\n \n+class TestPointerStringProto(unittest.TestCase):\n+    def test_pointer_string_proto_argtypes_error(self):\n+        with self.assertWarns(DeprecationWarning):\n+            BadType = ctypes.POINTER(\"BugTrigger\")\n+\n+        if os.name == \"nt\":\n+            libc = ctypes.WinDLL(\"kernel32.dll\")\n+            func = libc.GetCurrentProcessId\n+        else:\n+            libc = ctypes.CDLL(None)\n+            func = libc.getpid\n+\n+        func.argtypes = (BadType,)",
      "comment": "You can  use the Python C API:\n\n```suggestion\n        func = ctypes.pythonapi.Py_GetVersion\n        func.argtypes = (BadType,)\n```",
      "comment_id": 2722097649,
      "user": "vstinner",
      "created_at": "2026-01-23T17:02:21Z",
      "url": "https://github.com/python/cpython/pull/144108#discussion_r2722097649"
    },
    {
      "repo": "python/cpython",
      "pr_number": 144108,
      "file_path": "Lib/test/test_ctypes/test_pointers.py",
      "line": 476,
      "side": "RIGHT",
      "diff_hunk": "@@ -472,6 +473,23 @@ class C(Structure):\n         ptr.set_type(c_int)\n         self.assertIs(ptr._type_, c_int)\n \n+class TestPointerStringProto(unittest.TestCase):",
      "comment": "I would prefer to add the test to the end of PointersTestCase, instead of adding a new test case.",
      "comment_id": 2722100584,
      "user": "vstinner",
      "created_at": "2026-01-23T17:03:12Z",
      "url": "https://github.com/python/cpython/pull/144108#discussion_r2722100584"
    },
    {
      "repo": "python/cpython",
      "pr_number": 143549,
      "file_path": "Lib/symtable.py",
      "line": 240,
      "side": "RIGHT",
      "diff_hunk": "@@ -229,6 +230,14 @@ def get_frees(self):\n             self.__frees = self.__idents_matching(is_free)\n         return self.__frees\n \n+    def get_cells(self):\n+        \"\"\"Return a tuple of cells in the function.\"\"\"\n+        if self.__cells is None:\n+            is_cell = lambda x: _get_scope(x) == CELL\n+            self.__cells = self.__idents_matching(is_cell)\n+        return self.__cells\n+\n+",
      "comment": "According to the PEP8, there should be only two blank lines.\n\n```suggestion\n```",
      "comment_id": 2671695258,
      "user": "aisk",
      "created_at": "2026-01-08T09:58:29Z",
      "url": "https://github.com/python/cpython/pull/143549#discussion_r2671695258"
    },
    {
      "repo": "python/cpython",
      "pr_number": 143549,
      "file_path": "Lib/symtable.py",
      "line": 187,
      "side": "RIGHT",
      "diff_hunk": "@@ -184,6 +189,7 @@ class Function(SymbolTable):\n     __frees = None\n     __globals = None\n     __nonlocals = None\n+    __cells = None",
      "comment": "No, I was using it for another version of the code which didn't end up working out, I'll be removing it now.",
      "comment_id": 2713708139,
      "user": "Yashp002",
      "created_at": "2026-01-21T17:55:33Z",
      "url": "https://github.com/python/cpython/pull/143549#discussion_r2713708139"
    },
    {
      "repo": "python/cpython",
      "pr_number": 143549,
      "file_path": "Lib/symtable.py",
      "line": 234,
      "side": "RIGHT",
      "diff_hunk": "@@ -229,6 +229,10 @@ def get_frees(self):\n             self.__frees = self.__idents_matching(is_free)\n         return self.__frees\n \n+    def get_cells(self):\n+        \"\"\"Return a list of cell variable names in the table.\"\"\"\n+        return [s.get_name() for s in self.get_symbols() if s.is_cell()]",
      "comment": "Why does this not follow the pattern of get_frees and get_nonlocals?",
      "comment_id": 2713861720,
      "user": "iritkatriel",
      "created_at": "2026-01-21T18:37:01Z",
      "url": "https://github.com/python/cpython/pull/143549#discussion_r2713861720"
    },
    {
      "repo": "python/cpython",
      "pr_number": 143549,
      "file_path": "Lib/test/test_symtable.py",
      "line": 293,
      "side": "RIGHT",
      "diff_hunk": "@@ -284,6 +284,20 @@ def test_local(self):\n     def test_free(self):\n         self.assertTrue(self.internal.lookup(\"x\").is_free())\n \n+    def test_cells(self):\n+        #test for addition of is_cell() and get_cells()\n+        #see https://github.com/python/cpython/issues/143504\n+        code=\"\"\"def outer():\n+                    x=1\n+                    def inner():\n+                        return x\"\"\"",
      "comment": "the other tests don't do all this. Can we follow the same pattern in this one?",
      "comment_id": 2713865930,
      "user": "iritkatriel",
      "created_at": "2026-01-21T18:38:12Z",
      "url": "https://github.com/python/cpython/pull/143549#discussion_r2713865930"
    },
    {
      "repo": "python/cpython",
      "pr_number": 143549,
      "file_path": "Lib/symtable.py",
      "line": 234,
      "side": "RIGHT",
      "diff_hunk": "@@ -229,6 +229,10 @@ def get_frees(self):\n             self.__frees = self.__idents_matching(is_free)\n         return self.__frees\n \n+    def get_cells(self):\n+        \"\"\"Return a list of cell variable names in the table.\"\"\"\n+        return [s.get_name() for s in self.get_symbols() if s.is_cell()]",
      "comment": "We'll have to use the _cells variable then, I'll add it.",
      "comment_id": 2713890107,
      "user": "Yashp002",
      "created_at": "2026-01-21T18:45:14Z",
      "url": "https://github.com/python/cpython/pull/143549#discussion_r2713890107"
    },
    {
      "repo": "python/cpython",
      "pr_number": 143549,
      "file_path": "Lib/test/test_symtable.py",
      "line": 293,
      "side": "RIGHT",
      "diff_hunk": "@@ -284,6 +284,20 @@ def test_local(self):\n     def test_free(self):\n         self.assertTrue(self.internal.lookup(\"x\").is_free())\n \n+    def test_cells(self):\n+        #test for addition of is_cell() and get_cells()\n+        #see https://github.com/python/cpython/issues/143504\n+        code=\"\"\"def outer():\n+                    x=1\n+                    def inner():\n+                        return x\"\"\"",
      "comment": "@iritkatriel I've implemented the change in symtable.py with get_cells\r\n\r\nBut the current test_cells seems to be the only one that keeps working after I've change it up quite a few times.\r\n\r\nIs it really a requirement for it all to have the same pattern?",
      "comment_id": 2713992392,
      "user": "Yashp002",
      "created_at": "2026-01-21T19:15:29Z",
      "url": "https://github.com/python/cpython/pull/143549#discussion_r2713992392"
    },
    {
      "repo": "python/cpython",
      "pr_number": 143549,
      "file_path": "Lib/test/test_symtable.py",
      "line": 293,
      "side": "RIGHT",
      "diff_hunk": "@@ -284,6 +284,20 @@ def test_local(self):\n     def test_free(self):\n         self.assertTrue(self.internal.lookup(\"x\").is_free())\n \n+    def test_cells(self):\n+        #test for addition of is_cell() and get_cells()\n+        #see https://github.com/python/cpython/issues/143504\n+        code=\"\"\"def outer():\n+                    x=1\n+                    def inner():\n+                        return x\"\"\"",
      "comment": "Unless there's a reason why we can't, then we should follow the same pattern. What's the difference between the cases?",
      "comment_id": 2714646182,
      "user": "iritkatriel",
      "created_at": "2026-01-21T22:59:34Z",
      "url": "https://github.com/python/cpython/pull/143549#discussion_r2714646182"
    },
    {
      "repo": "python/cpython",
      "pr_number": 143549,
      "file_path": "Lib/test/test_symtable.py",
      "line": 293,
      "side": "RIGHT",
      "diff_hunk": "@@ -284,6 +284,20 @@ def test_local(self):\n     def test_free(self):\n         self.assertTrue(self.internal.lookup(\"x\").is_free())\n \n+    def test_cells(self):\n+        #test for addition of is_cell() and get_cells()\n+        #see https://github.com/python/cpython/issues/143504\n+        code=\"\"\"def outer():\n+                    x=1\n+                    def inner():\n+                        return x\"\"\"",
      "comment": "self.internal has x as FREE var (for test_free). we need x as CELL var (outer scope). setUp doesn't have that so inline code is needed. However I've removed the unnecessary comments and changed the rest of it to\r\n\r\n        top=symtable.symtable(code,\"?\",\"exec\")\r\n        outer = find_block(top, \"outer\")\r\n        self.assertEqual(outer.get_cells(), [\"x\"])\r\n        self.assertTrue(outer.lookup(\"x\").is_cell())\r\n        self.assertFalse(outer.lookup(\"inner\").is_cell()) to use assert.Equal,true and false like the rest of the functions.\r\n        \r\n        WOuld this be satisfactory as a commit?",
      "comment_id": 2716215056,
      "user": "Yashp002",
      "created_at": "2026-01-22T10:12:08Z",
      "url": "https://github.com/python/cpython/pull/143549#discussion_r2716215056"
    },
    {
      "repo": "python/cpython",
      "pr_number": 143549,
      "file_path": "Lib/test/test_symtable.py",
      "line": 293,
      "side": "RIGHT",
      "diff_hunk": "@@ -284,6 +284,20 @@ def test_local(self):\n     def test_free(self):\n         self.assertTrue(self.internal.lookup(\"x\").is_free())\n \n+    def test_cells(self):\n+        #test for addition of is_cell() and get_cells()\n+        #see https://github.com/python/cpython/issues/143504\n+        code=\"\"\"def outer():\n+                    x=1\n+                    def inner():\n+                        return x\"\"\"",
      "comment": "and get_cells test should be next to get_frees test.",
      "comment_id": 2721955006,
      "user": "iritkatriel",
      "created_at": "2026-01-23T16:31:10Z",
      "url": "https://github.com/python/cpython/pull/143549#discussion_r2721955006"
    },
    {
      "repo": "python/cpython",
      "pr_number": 143549,
      "file_path": "Lib/test/test_symtable.py",
      "line": 293,
      "side": "RIGHT",
      "diff_hunk": "@@ -284,6 +284,20 @@ def test_local(self):\n     def test_free(self):\n         self.assertTrue(self.internal.lookup(\"x\").is_free())\n \n+    def test_cells(self):\n+        #test for addition of is_cell() and get_cells()\n+        #see https://github.com/python/cpython/issues/143504\n+        code=\"\"\"def outer():\n+                    x=1\n+                    def inner():\n+                        return x\"\"\"",
      "comment": "> and get_cells test should be next to get_frees test.\r\n\r\nisn't test_cells already next to test_free?\r\n",
      "comment_id": 2722302757,
      "user": "Yashp002",
      "created_at": "2026-01-23T18:08:57Z",
      "url": "https://github.com/python/cpython/pull/143549#discussion_r2722302757"
    },
    {
      "repo": "python/cpython",
      "pr_number": 143549,
      "file_path": "Lib/test/test_symtable.py",
      "line": 290,
      "side": "RIGHT",
      "diff_hunk": "@@ -285,18 +285,8 @@ def test_free(self):\n         self.assertTrue(self.internal.lookup(\"x\").is_free())\n \n     def test_cells(self):\n-        #test for addition of is_cell() and get_cells()\n-        #see https://github.com/python/cpython/issues/143504\n-        code=\"\"\"def outer():\n-                    x=1\n-                    def inner():\n-                        return x\"\"\"\n-\n-        top=symtable.symtable(code,\"?\",\"exec\")\n-        outer = find_block(top, \"outer\")\n-        self.assertIn(\"x\",outer.get_cells())\n-        self.assertTrue(outer.lookup(\"x\").is_cell())\n-        self.assertFalse(outer.lookup(\"inner\").is_cell())\n+        self.assertTrue(self.spam.lookup(\"x\").is_cell())\n+\n ",
      "comment": "Add it to test_function_info:\r\n\r\n\r\n```\r\n@@ -255,6 +255,7 @@ def test_function_info(self):\r\n         self.assertEqual(sorted(func.get_locals()), expected)\r\n         self.assertEqual(sorted(func.get_globals()), [\"bar\", \"glob\", \"some_assigned_global_var\"])\r\n         self.assertEqual(self.internal.get_frees(), (\"x\",))\r\n+        self.assertEqual(self.spam.get_cells(), (\"some_var\", \"x\",))\r\n\r\n```",
      "comment_id": 2722822879,
      "user": "iritkatriel",
      "created_at": "2026-01-23T20:59:43Z",
      "url": "https://github.com/python/cpython/pull/143549#discussion_r2722822879"
    },
    {
      "repo": "python/cpython",
      "pr_number": 143549,
      "file_path": "Lib/symtable.py",
      "line": 237,
      "side": "RIGHT",
      "diff_hunk": "@@ -230,8 +231,11 @@ def get_frees(self):\n         return self.__frees\n \n     def get_cells(self):\n-        \"\"\"Return a list of cell variable names in the table.\"\"\"\n-        return [s.get_name() for s in self.get_symbols() if s.is_cell()]\n+        \"\"\"Return a list of cell variable names in the table.\n+        \"\"\"\n+        if self.__cells is None:\n+            self.__cells = [s.get_name() for s in self.get_symbols() if s.is_cell()]",
      "comment": "Let's follow the pattern that it used in get_frees:\r\n\r\n```suggestion\r\n            is_cell = lambda x: _get_scope(x) == CELL\r\n            self.__cells = self.__idents_matching(is_cell)\r\n```",
      "comment_id": 2722830871,
      "user": "iritkatriel",
      "created_at": "2026-01-23T21:02:32Z",
      "url": "https://github.com/python/cpython/pull/143549#discussion_r2722830871"
    },
    {
      "repo": "python/cpython",
      "pr_number": 143549,
      "file_path": "Lib/symtable.py",
      "line": 234,
      "side": "RIGHT",
      "diff_hunk": "@@ -229,6 +230,13 @@ def get_frees(self):\n             self.__frees = self.__idents_matching(is_free)\n         return self.__frees\n \n+    def get_cells(self):\n+        \"\"\"Return a list of cell variable names in the table.",
      "comment": "```suggestion\n        \"\"\"Return a tuple of cell variable names in the table.\n```\n",
      "comment_id": 2723085980,
      "user": "picnixz",
      "created_at": "2026-01-23T22:36:45Z",
      "url": "https://github.com/python/cpython/pull/143549#discussion_r2723085980"
    },
    {
      "repo": "python/cpython",
      "pr_number": 143549,
      "file_path": "Lib/test/test_symtable.py",
      "line": 290,
      "side": "RIGHT",
      "diff_hunk": "@@ -284,6 +284,10 @@ def test_local(self):\n     def test_free(self):\n         self.assertTrue(self.internal.lookup(\"x\").is_free())\n \n+    def test_cells(self):\n+        self.assertTrue(self.spam.lookup(\"x\").is_cell())\n+\n+",
      "comment": "```suggestion\n```\n\nThere ate 2 blanks instead of 1 here.",
      "comment_id": 2723087675,
      "user": "picnixz",
      "created_at": "2026-01-23T22:37:28Z",
      "url": "https://github.com/python/cpython/pull/143549#discussion_r2723087675"
    },
    {
      "repo": "python/cpython",
      "pr_number": 143549,
      "file_path": "Lib/symtable.py",
      "line": 234,
      "side": "RIGHT",
      "diff_hunk": "@@ -229,6 +230,14 @@ def get_frees(self):\n             self.__frees = self.__idents_matching(is_free)\n         return self.__frees\n \n+    def get_cells(self):\n+        \"\"\"Return a tuple of cell variable names in the table.",
      "comment": "```suggestion\r\n        \"\"\"Return a tuple of cell variables in the function.\r\n```",
      "comment_id": 2725498697,
      "user": "iritkatriel",
      "created_at": "2026-01-25T13:05:27Z",
      "url": "https://github.com/python/cpython/pull/143549#discussion_r2725498697"
    },
    {
      "repo": "python/cpython",
      "pr_number": 143250,
      "file_path": "Lib/test/test_asyncio/test_windows_utils.py",
      "line": 154,
      "side": "RIGHT",
      "diff_hunk": "@@ -129,5 +129,45 @@ def test_popen(self):\n             pass\n \n \n+class OverlappedLeakTests(unittest.TestCase):\n+    def _invalid_socket_handle(self):\n+        return 0\n+\n+    def test_overlapped_wsasendto_failure_releases_user_buffer(self):\n+        ov = _overlapped.Overlapped()\n+        buf = bytearray(4096)\n+        with self.assertRaises(OSError):\n+            ov.WSASendTo(self._invalid_socket_handle(),\n+                         memoryview(buf), 0, (\"127.0.0.1\", 1))\n+        # If the exported buffer is still held, this will raise BufferError.\n+        buf.append(1)\n+\n+    def test_overlapped_wsarecvfrominto_failure_releases_user_buffer(self):\n+        ov = _overlapped.Overlapped()\n+        buf = bytearray(4096)\n+        with self.assertRaises(OSError):\n+            ov.WSARecvFromInto(self._invalid_socket_handle(),\n+                               memoryview(buf), len(buf), 0)\n+        # If the exported buffer is still held, this will raise BufferError.\n+        buf.append(1)\n+\n+    @support.refcount_test",
      "comment": "Do we really need this? I think you can just run `-R :` from the CLI to check if three is a refleak. It's more robust as well.",
      "comment_id": 2649786112,
      "user": "picnixz",
      "created_at": "2025-12-28T16:05:26Z",
      "url": "https://github.com/python/cpython/pull/143250#discussion_r2649786112"
    },
    {
      "repo": "python/cpython",
      "pr_number": 143250,
      "file_path": "Lib/test/test_asyncio/test_windows_utils.py",
      "line": 154,
      "side": "RIGHT",
      "diff_hunk": "@@ -129,5 +129,45 @@ def test_popen(self):\n             pass\n \n \n+class OverlappedLeakTests(unittest.TestCase):\n+    def _invalid_socket_handle(self):\n+        return 0\n+\n+    def test_overlapped_wsasendto_failure_releases_user_buffer(self):\n+        ov = _overlapped.Overlapped()\n+        buf = bytearray(4096)\n+        with self.assertRaises(OSError):\n+            ov.WSASendTo(self._invalid_socket_handle(),\n+                         memoryview(buf), 0, (\"127.0.0.1\", 1))\n+        # If the exported buffer is still held, this will raise BufferError.\n+        buf.append(1)\n+\n+    def test_overlapped_wsarecvfrominto_failure_releases_user_buffer(self):\n+        ov = _overlapped.Overlapped()\n+        buf = bytearray(4096)\n+        with self.assertRaises(OSError):\n+            ov.WSARecvFromInto(self._invalid_socket_handle(),\n+                               memoryview(buf), len(buf), 0)\n+        # If the exported buffer is still held, this will raise BufferError.\n+        buf.append(1)\n+\n+    @support.refcount_test",
      "comment": "Thanks for the guidance \u2014 that makes sense now. I\u2019ve updated the test case, and here are the results from my local run.\r\n### Without the patch\r\n``` bash\r\nd:\\MyCode\\cpython>PCbuild\\amd64\\python_d.exe -m test -R 3:3 test_asyncio.test_windows_utils\r\nUsing random seed: 514712329\r\n0:00:00 Run 1 test sequentially in a single process\r\n0:00:00 [1/1] test_asyncio.test_windows_utils\r\nbeginning 6 repetitions. Showing number of leaks (. for 0 or less, X for 10 or more)\r\n123:456\r\nXX5 555\r\ntest_asyncio.test_windows_utils leaked [5, 5, 5] references, sum=15\r\n0:00:01 [1/1/1] test_asyncio.test_windows_utils failed (reference leak)\r\n\r\n== Tests result: FAILURE ==\r\n\r\n1 test failed:\r\n    test_asyncio.test_windows_utils\r\n\r\nTotal duration: 1.2 sec\r\nTotal tests: run=6\r\nTotal test files: run=1/1 failed=1\r\nResult: FAILURE\r\n```\r\n### with the patch\r\n``` bash\r\nd:\\MyCode\\cpython>PCbuild\\amd64\\python_d.exe -m test -R 3:3 test_asyncio.test_windows_utils\r\nUsing random seed: 3834115587\r\n0:00:00 Run 1 test sequentially in a single process\r\n0:00:00 [1/1] test_asyncio.test_windows_utils\r\nbeginning 6 repetitions. Showing number of leaks (. for 0 or less, X for 10 or more)\r\n123:456\r\nXX. ...\r\n0:00:01 [1/1] test_asyncio.test_windows_utils passed\r\n\r\n== Tests result: SUCCESS ==\r\n\r\n1 test OK.\r\n\r\nTotal duration: 1.2 sec\r\nTotal tests: run=6\r\nTotal test files: run=1/1\r\nResult: SUCCESS\r\n\r\n```",
      "comment_id": 2649805351,
      "user": "hyongtao-code",
      "created_at": "2025-12-28T16:42:39Z",
      "url": "https://github.com/python/cpython/pull/143250#discussion_r2649805351"
    },
    {
      "repo": "python/cpython",
      "pr_number": 143250,
      "file_path": "Lib/test/test_asyncio/test_windows_utils.py",
      "line": 150,
      "side": "RIGHT",
      "diff_hunk": "@@ -129,5 +129,24 @@ def test_popen(self):\n             pass\n \n \n+class OverlappedRefleakTests(unittest.TestCase):\n+\n+    def test_wsasendto_failure(self):\n+        ov = _overlapped.Overlapped()\n+        buf = bytearray(4096)\n+        with self.assertRaises(OSError):\n+            ov.WSASendTo(0x1234, buf, 0, (\"127.0.0.1\", 1))\n+\n+    def test_wsarecvfrom_failure(self):\n+        ov = _overlapped.Overlapped()\n+        with self.assertRaises(OSError):\n+            ov.WSARecvFrom(0x1234, 1024, 0)\n+\n+    def test_wsarecvfrominto_failure(self):\n+        ov = _overlapped.Overlapped()\n+        buf = bytearray(4096)\n+        with self.assertRaises(OSError):\n+            ov.WSARecvFromInto(0x1234, buf, len(buf), 0)\n+",
      "comment": "```suggestion\r\n            ov.WSARecvFromInto(0x1234, buf, len(buf), 0)\r\n\r\n\r\n```",
      "comment_id": 2649830381,
      "user": "picnixz",
      "created_at": "2025-12-28T17:34:01Z",
      "url": "https://github.com/python/cpython/pull/143250#discussion_r2649830381"
    },
    {
      "repo": "python/cpython",
      "pr_number": 142081,
      "file_path": "Lib/test/test_format.py",
      "line": 282,
      "side": "RIGHT",
      "diff_hunk": "@@ -272,45 +271,149 @@ def test_common_format(self):\n \n         if verbose:\n             print('Testing exceptions')\n-        test_exc_common('%', (), ValueError, \"incomplete format\")\n-        test_exc_common('% %s', 1, ValueError,\n-                        \"unsupported format character '%' (0x25) at index 2\")\n+        test_exc_common('abc %', (), ValueError, \"stray % at position 4\")\n+        test_exc_common('abc % %s', 1, ValueError,\n+                        \"stray % at position 4 or unexpected format character '%' at position 6\")\n+        test_exc_common('abc %z', 1, ValueError,\n+                        \"unsupported format %z at position 4\")\n+        test_exc_common(\"abc %Id\", 1, ValueError,\n+                        \"unsupported format %I at position 4\")\n+        test_exc_common(\"abc %'d\", 1, ValueError,\n+                        \"stray % at position 4 or unexpected format character ''' at position 5\")",
      "comment": "`'''` is not very readable. Would it be possible to format it as U+HHHH or 0xHH?",
      "comment_id": 2577210575,
      "user": "vstinner",
      "created_at": "2025-12-01T14:00:36Z",
      "url": "https://github.com/python/cpython/pull/142081#discussion_r2577210575"
    },
    {
      "repo": "python/cpython",
      "pr_number": 142081,
      "file_path": "Lib/test/test_format.py",
      "line": 318,
      "side": "RIGHT",
      "diff_hunk": "@@ -272,45 +271,149 @@ def test_common_format(self):\n \n         if verbose:\n             print('Testing exceptions')\n-        test_exc_common('%', (), ValueError, \"incomplete format\")\n-        test_exc_common('% %s', 1, ValueError,\n-                        \"unsupported format character '%' (0x25) at index 2\")\n+        test_exc_common('abc %', (), ValueError, \"stray % at position 4\")\n+        test_exc_common('abc % %s', 1, ValueError,\n+                        \"stray % at position 4 or unexpected format character '%' at position 6\")\n+        test_exc_common('abc %z', 1, ValueError,\n+                        \"unsupported format %z at position 4\")\n+        test_exc_common(\"abc %Id\", 1, ValueError,\n+                        \"unsupported format %I at position 4\")\n+        test_exc_common(\"abc %'d\", 1, ValueError,\n+                        \"stray % at position 4 or unexpected format character ''' at position 5\")\n+        test_exc_common(\"abc %1 d\", 1, ValueError,\n+                        \"stray % at position 4 or unexpected format character ' ' at position 6\")\n+        test_exc_common('abc % (x)r', {}, ValueError,\n+                        \"stray % at position 4 or unexpected format character '(' at position 6\")\n+        test_exc_common('abc %((x)r', {}, ValueError,\n+                        \"stray % or incomplete format key at position 4\")\n+        test_exc_common('%r %r', 1, TypeError,\n+                        \"not enough arguments for format string (got 1)\")\n+        test_exc_common('%r %r', (1,), TypeError,\n+                        \"not enough arguments for format string (got 1)\")\n+        test_exc_common('%r', (), TypeError,\n+                        \"not enough arguments for format string (got 0)\")\n+        test_exc_common('abc %' + '9'*50 + 'r', 1, ValueError,\n+                        \"width too big at position 4\")\n+        test_exc_common('abc %.' + '9'*50 + 'r', 1, ValueError,\n+                        \"precision too big at position 4\")\n+        test_exc_common('%r %*r', 1, TypeError,\n+                        \"not enough arguments for format string (got 1)\")\n+        test_exc_common('%r %*r', (1,), TypeError,\n+                        \"not enough arguments for format string (got 1)\")\n+        test_exc_common('%*r', (1,), TypeError,\n+                        \"not enough arguments for format string (got 1)\")\n+        test_exc_common('%*r', (), TypeError,\n+                        \"not enough arguments for format string (got 0)\")\n+        test_exc_common('%r %.*r', 1, TypeError,\n+                        \"not enough arguments for format string (got 1)\")\n+        test_exc_common('%r %.*r', (1,), TypeError,\n+                        \"not enough arguments for format string (got 1)\")\n+        test_exc_common('%.*r', (1,), TypeError,\n+                        \"not enough arguments for format string (got 1)\")\n+        test_exc_common('%.*r', (), TypeError,\n+                        \"not enough arguments for format string (got 0)\")\n+        test_exc_common('%(x)r', 1, TypeError,\n+                        \"format requires a mapping, not int\")\n+        test_exc_common('%*r', 3.14, TypeError,\n+                        \"* requires int, not float\")",
      "comment": "Without context, it's uneasy to understand that the error comes from a format string. Maybe write `%*` instead?\n\n```suggestion\n                        \"%* requires int, not float\")\n```",
      "comment_id": 2577215968,
      "user": "vstinner",
      "created_at": "2025-12-01T14:02:10Z",
      "url": "https://github.com/python/cpython/pull/142081#discussion_r2577215968"
    },
    {
      "repo": "python/cpython",
      "pr_number": 142081,
      "file_path": "Lib/test/test_format.py",
      "line": 326,
      "side": "RIGHT",
      "diff_hunk": "@@ -272,45 +271,149 @@ def test_common_format(self):\n \n         if verbose:\n             print('Testing exceptions')\n-        test_exc_common('%', (), ValueError, \"incomplete format\")\n-        test_exc_common('% %s', 1, ValueError,\n-                        \"unsupported format character '%' (0x25) at index 2\")\n+        test_exc_common('abc %', (), ValueError, \"stray % at position 4\")\n+        test_exc_common('abc % %s', 1, ValueError,\n+                        \"stray % at position 4 or unexpected format character '%' at position 6\")\n+        test_exc_common('abc %z', 1, ValueError,\n+                        \"unsupported format %z at position 4\")\n+        test_exc_common(\"abc %Id\", 1, ValueError,\n+                        \"unsupported format %I at position 4\")\n+        test_exc_common(\"abc %'d\", 1, ValueError,\n+                        \"stray % at position 4 or unexpected format character ''' at position 5\")\n+        test_exc_common(\"abc %1 d\", 1, ValueError,\n+                        \"stray % at position 4 or unexpected format character ' ' at position 6\")\n+        test_exc_common('abc % (x)r', {}, ValueError,\n+                        \"stray % at position 4 or unexpected format character '(' at position 6\")\n+        test_exc_common('abc %((x)r', {}, ValueError,\n+                        \"stray % or incomplete format key at position 4\")\n+        test_exc_common('%r %r', 1, TypeError,\n+                        \"not enough arguments for format string (got 1)\")\n+        test_exc_common('%r %r', (1,), TypeError,\n+                        \"not enough arguments for format string (got 1)\")\n+        test_exc_common('%r', (), TypeError,\n+                        \"not enough arguments for format string (got 0)\")\n+        test_exc_common('abc %' + '9'*50 + 'r', 1, ValueError,\n+                        \"width too big at position 4\")\n+        test_exc_common('abc %.' + '9'*50 + 'r', 1, ValueError,\n+                        \"precision too big at position 4\")\n+        test_exc_common('%r %*r', 1, TypeError,\n+                        \"not enough arguments for format string (got 1)\")\n+        test_exc_common('%r %*r', (1,), TypeError,\n+                        \"not enough arguments for format string (got 1)\")\n+        test_exc_common('%*r', (1,), TypeError,\n+                        \"not enough arguments for format string (got 1)\")\n+        test_exc_common('%*r', (), TypeError,\n+                        \"not enough arguments for format string (got 0)\")\n+        test_exc_common('%r %.*r', 1, TypeError,\n+                        \"not enough arguments for format string (got 1)\")\n+        test_exc_common('%r %.*r', (1,), TypeError,\n+                        \"not enough arguments for format string (got 1)\")\n+        test_exc_common('%.*r', (1,), TypeError,\n+                        \"not enough arguments for format string (got 1)\")\n+        test_exc_common('%.*r', (), TypeError,\n+                        \"not enough arguments for format string (got 0)\")\n+        test_exc_common('%(x)r', 1, TypeError,\n+                        \"format requires a mapping, not int\")\n+        test_exc_common('%*r', 3.14, TypeError,\n+                        \"* requires int, not float\")\n+        test_exc_common('%*r', (3.14, 1), TypeError,\n+                        \"format argument 1: * requires int, not float\")\n+        test_exc_common('%.*r', 3.14, TypeError,\n+                        \"* requires int, not float\")\n+        test_exc_common('%.*r', (3.14, 1), TypeError,\n+                        \"format argument 1: * requires int, not float\")\n+        test_exc_common('%*r', (2**1000, 1), OverflowError,\n+                        \"format argument 1: too big for width\")",
      "comment": "```suggestion\n                        \"format argument 1: width is too big\")\n```",
      "comment_id": 2577221036,
      "user": "vstinner",
      "created_at": "2025-12-01T14:03:43Z",
      "url": "https://github.com/python/cpython/pull/142081#discussion_r2577221036"
    },
    {
      "repo": "python/cpython",
      "pr_number": 142081,
      "file_path": "Lib/test/test_format.py",
      "line": 330,
      "side": "RIGHT",
      "diff_hunk": "@@ -272,45 +271,149 @@ def test_common_format(self):\n \n         if verbose:\n             print('Testing exceptions')\n-        test_exc_common('%', (), ValueError, \"incomplete format\")\n-        test_exc_common('% %s', 1, ValueError,\n-                        \"unsupported format character '%' (0x25) at index 2\")\n+        test_exc_common('abc %', (), ValueError, \"stray % at position 4\")\n+        test_exc_common('abc % %s', 1, ValueError,\n+                        \"stray % at position 4 or unexpected format character '%' at position 6\")\n+        test_exc_common('abc %z', 1, ValueError,\n+                        \"unsupported format %z at position 4\")\n+        test_exc_common(\"abc %Id\", 1, ValueError,\n+                        \"unsupported format %I at position 4\")\n+        test_exc_common(\"abc %'d\", 1, ValueError,\n+                        \"stray % at position 4 or unexpected format character ''' at position 5\")\n+        test_exc_common(\"abc %1 d\", 1, ValueError,\n+                        \"stray % at position 4 or unexpected format character ' ' at position 6\")\n+        test_exc_common('abc % (x)r', {}, ValueError,\n+                        \"stray % at position 4 or unexpected format character '(' at position 6\")\n+        test_exc_common('abc %((x)r', {}, ValueError,\n+                        \"stray % or incomplete format key at position 4\")\n+        test_exc_common('%r %r', 1, TypeError,\n+                        \"not enough arguments for format string (got 1)\")\n+        test_exc_common('%r %r', (1,), TypeError,\n+                        \"not enough arguments for format string (got 1)\")\n+        test_exc_common('%r', (), TypeError,\n+                        \"not enough arguments for format string (got 0)\")\n+        test_exc_common('abc %' + '9'*50 + 'r', 1, ValueError,\n+                        \"width too big at position 4\")\n+        test_exc_common('abc %.' + '9'*50 + 'r', 1, ValueError,\n+                        \"precision too big at position 4\")\n+        test_exc_common('%r %*r', 1, TypeError,\n+                        \"not enough arguments for format string (got 1)\")\n+        test_exc_common('%r %*r', (1,), TypeError,\n+                        \"not enough arguments for format string (got 1)\")\n+        test_exc_common('%*r', (1,), TypeError,\n+                        \"not enough arguments for format string (got 1)\")\n+        test_exc_common('%*r', (), TypeError,\n+                        \"not enough arguments for format string (got 0)\")\n+        test_exc_common('%r %.*r', 1, TypeError,\n+                        \"not enough arguments for format string (got 1)\")\n+        test_exc_common('%r %.*r', (1,), TypeError,\n+                        \"not enough arguments for format string (got 1)\")\n+        test_exc_common('%.*r', (1,), TypeError,\n+                        \"not enough arguments for format string (got 1)\")\n+        test_exc_common('%.*r', (), TypeError,\n+                        \"not enough arguments for format string (got 0)\")\n+        test_exc_common('%(x)r', 1, TypeError,\n+                        \"format requires a mapping, not int\")\n+        test_exc_common('%*r', 3.14, TypeError,\n+                        \"* requires int, not float\")\n+        test_exc_common('%*r', (3.14, 1), TypeError,\n+                        \"format argument 1: * requires int, not float\")\n+        test_exc_common('%.*r', 3.14, TypeError,\n+                        \"* requires int, not float\")\n+        test_exc_common('%.*r', (3.14, 1), TypeError,\n+                        \"format argument 1: * requires int, not float\")\n+        test_exc_common('%*r', (2**1000, 1), OverflowError,\n+                        \"format argument 1: too big for width\")\n+        test_exc_common('%*r', (-2**1000, 1), OverflowError,\n+                        \"format argument 1: too big for width\")\n+        test_exc_common('%.*r', (2**1000, 1), OverflowError,\n+                        \"format argument 1: too big for precision\")",
      "comment": "```suggestion\n                        \"format argument 1: precision is too big\")\n```",
      "comment_id": 2577221809,
      "user": "vstinner",
      "created_at": "2025-12-01T14:03:57Z",
      "url": "https://github.com/python/cpython/pull/142081#discussion_r2577221809"
    },
    {
      "repo": "python/cpython",
      "pr_number": 142081,
      "file_path": "Lib/test/test_format.py",
      "line": 334,
      "side": "RIGHT",
      "diff_hunk": "@@ -272,45 +271,149 @@ def test_common_format(self):\n \n         if verbose:\n             print('Testing exceptions')\n-        test_exc_common('%', (), ValueError, \"incomplete format\")\n-        test_exc_common('% %s', 1, ValueError,\n-                        \"unsupported format character '%' (0x25) at index 2\")\n+        test_exc_common('abc %', (), ValueError, \"stray % at position 4\")\n+        test_exc_common('abc % %s', 1, ValueError,\n+                        \"stray % at position 4 or unexpected format character '%' at position 6\")\n+        test_exc_common('abc %z', 1, ValueError,\n+                        \"unsupported format %z at position 4\")\n+        test_exc_common(\"abc %Id\", 1, ValueError,\n+                        \"unsupported format %I at position 4\")\n+        test_exc_common(\"abc %'d\", 1, ValueError,\n+                        \"stray % at position 4 or unexpected format character ''' at position 5\")\n+        test_exc_common(\"abc %1 d\", 1, ValueError,\n+                        \"stray % at position 4 or unexpected format character ' ' at position 6\")\n+        test_exc_common('abc % (x)r', {}, ValueError,\n+                        \"stray % at position 4 or unexpected format character '(' at position 6\")\n+        test_exc_common('abc %((x)r', {}, ValueError,\n+                        \"stray % or incomplete format key at position 4\")\n+        test_exc_common('%r %r', 1, TypeError,\n+                        \"not enough arguments for format string (got 1)\")\n+        test_exc_common('%r %r', (1,), TypeError,\n+                        \"not enough arguments for format string (got 1)\")\n+        test_exc_common('%r', (), TypeError,\n+                        \"not enough arguments for format string (got 0)\")\n+        test_exc_common('abc %' + '9'*50 + 'r', 1, ValueError,\n+                        \"width too big at position 4\")\n+        test_exc_common('abc %.' + '9'*50 + 'r', 1, ValueError,\n+                        \"precision too big at position 4\")\n+        test_exc_common('%r %*r', 1, TypeError,\n+                        \"not enough arguments for format string (got 1)\")\n+        test_exc_common('%r %*r', (1,), TypeError,\n+                        \"not enough arguments for format string (got 1)\")\n+        test_exc_common('%*r', (1,), TypeError,\n+                        \"not enough arguments for format string (got 1)\")\n+        test_exc_common('%*r', (), TypeError,\n+                        \"not enough arguments for format string (got 0)\")\n+        test_exc_common('%r %.*r', 1, TypeError,\n+                        \"not enough arguments for format string (got 1)\")\n+        test_exc_common('%r %.*r', (1,), TypeError,\n+                        \"not enough arguments for format string (got 1)\")\n+        test_exc_common('%.*r', (1,), TypeError,\n+                        \"not enough arguments for format string (got 1)\")\n+        test_exc_common('%.*r', (), TypeError,\n+                        \"not enough arguments for format string (got 0)\")\n+        test_exc_common('%(x)r', 1, TypeError,\n+                        \"format requires a mapping, not int\")\n+        test_exc_common('%*r', 3.14, TypeError,\n+                        \"* requires int, not float\")\n+        test_exc_common('%*r', (3.14, 1), TypeError,\n+                        \"format argument 1: * requires int, not float\")\n+        test_exc_common('%.*r', 3.14, TypeError,\n+                        \"* requires int, not float\")\n+        test_exc_common('%.*r', (3.14, 1), TypeError,\n+                        \"format argument 1: * requires int, not float\")\n+        test_exc_common('%*r', (2**1000, 1), OverflowError,\n+                        \"format argument 1: too big for width\")\n+        test_exc_common('%*r', (-2**1000, 1), OverflowError,\n+                        \"format argument 1: too big for width\")\n+        test_exc_common('%.*r', (2**1000, 1), OverflowError,\n+                        \"format argument 1: too big for precision\")\n+        test_exc_common('%.*r', (-2**1000, 1), OverflowError,\n+                        \"format argument 1: too big for precision\")\n         test_exc_common('%d', '1', TypeError,\n-                        \"%d format: a real number is required, not str\")\n+                        \"a real number is required for format %d, not str\")",
      "comment": "is it really a real number which is expected, or an integer?",
      "comment_id": 2577228456,
      "user": "vstinner",
      "created_at": "2025-12-01T14:06:00Z",
      "url": "https://github.com/python/cpython/pull/142081#discussion_r2577228456"
    },
    {
      "repo": "python/cpython",
      "pr_number": 142081,
      "file_path": "Lib/test/test_format.py",
      "line": 404,
      "side": "RIGHT",
      "diff_hunk": "@@ -272,45 +271,149 @@ def test_common_format(self):\n \n         if verbose:\n             print('Testing exceptions')\n-        test_exc_common('%', (), ValueError, \"incomplete format\")\n-        test_exc_common('% %s', 1, ValueError,\n-                        \"unsupported format character '%' (0x25) at index 2\")\n+        test_exc_common('abc %', (), ValueError, \"stray % at position 4\")\n+        test_exc_common('abc % %s', 1, ValueError,\n+                        \"stray % at position 4 or unexpected format character '%' at position 6\")\n+        test_exc_common('abc %z', 1, ValueError,\n+                        \"unsupported format %z at position 4\")\n+        test_exc_common(\"abc %Id\", 1, ValueError,\n+                        \"unsupported format %I at position 4\")\n+        test_exc_common(\"abc %'d\", 1, ValueError,\n+                        \"stray % at position 4 or unexpected format character ''' at position 5\")\n+        test_exc_common(\"abc %1 d\", 1, ValueError,\n+                        \"stray % at position 4 or unexpected format character ' ' at position 6\")\n+        test_exc_common('abc % (x)r', {}, ValueError,\n+                        \"stray % at position 4 or unexpected format character '(' at position 6\")\n+        test_exc_common('abc %((x)r', {}, ValueError,\n+                        \"stray % or incomplete format key at position 4\")\n+        test_exc_common('%r %r', 1, TypeError,\n+                        \"not enough arguments for format string (got 1)\")\n+        test_exc_common('%r %r', (1,), TypeError,\n+                        \"not enough arguments for format string (got 1)\")\n+        test_exc_common('%r', (), TypeError,\n+                        \"not enough arguments for format string (got 0)\")\n+        test_exc_common('abc %' + '9'*50 + 'r', 1, ValueError,\n+                        \"width too big at position 4\")\n+        test_exc_common('abc %.' + '9'*50 + 'r', 1, ValueError,\n+                        \"precision too big at position 4\")\n+        test_exc_common('%r %*r', 1, TypeError,\n+                        \"not enough arguments for format string (got 1)\")\n+        test_exc_common('%r %*r', (1,), TypeError,\n+                        \"not enough arguments for format string (got 1)\")\n+        test_exc_common('%*r', (1,), TypeError,\n+                        \"not enough arguments for format string (got 1)\")\n+        test_exc_common('%*r', (), TypeError,\n+                        \"not enough arguments for format string (got 0)\")\n+        test_exc_common('%r %.*r', 1, TypeError,\n+                        \"not enough arguments for format string (got 1)\")\n+        test_exc_common('%r %.*r', (1,), TypeError,\n+                        \"not enough arguments for format string (got 1)\")\n+        test_exc_common('%.*r', (1,), TypeError,\n+                        \"not enough arguments for format string (got 1)\")\n+        test_exc_common('%.*r', (), TypeError,\n+                        \"not enough arguments for format string (got 0)\")\n+        test_exc_common('%(x)r', 1, TypeError,\n+                        \"format requires a mapping, not int\")\n+        test_exc_common('%*r', 3.14, TypeError,\n+                        \"* requires int, not float\")\n+        test_exc_common('%*r', (3.14, 1), TypeError,\n+                        \"format argument 1: * requires int, not float\")\n+        test_exc_common('%.*r', 3.14, TypeError,\n+                        \"* requires int, not float\")\n+        test_exc_common('%.*r', (3.14, 1), TypeError,\n+                        \"format argument 1: * requires int, not float\")\n+        test_exc_common('%*r', (2**1000, 1), OverflowError,\n+                        \"format argument 1: too big for width\")\n+        test_exc_common('%*r', (-2**1000, 1), OverflowError,\n+                        \"format argument 1: too big for width\")\n+        test_exc_common('%.*r', (2**1000, 1), OverflowError,\n+                        \"format argument 1: too big for precision\")\n+        test_exc_common('%.*r', (-2**1000, 1), OverflowError,\n+                        \"format argument 1: too big for precision\")\n         test_exc_common('%d', '1', TypeError,\n-                        \"%d format: a real number is required, not str\")\n+                        \"a real number is required for format %d, not str\")\n         test_exc_common('%d', b'1', TypeError,\n-                        \"%d format: a real number is required, not bytes\")\n+                        \"a real number is required for format %d, not bytes\")\n+        test_exc_common('%d', ('1',), TypeError,\n+                        \"format argument 1: a real number is required for format %d, not str\")\n         test_exc_common('%x', '1', TypeError,\n-                        \"%x format: an integer is required, not str\")\n+                        \"an integer is required for format %x, not str\")\n         test_exc_common('%x', 3.14, TypeError,\n-                        \"%x format: an integer is required, not float\")\n+                        \"an integer is required for format %x, not float\")\n+        test_exc_common('%x', ('1',), TypeError,\n+                        \"format argument 1: an integer is required for format %x, not str\")\n         test_exc_common('%i', '1', TypeError,\n-                        \"%i format: a real number is required, not str\")\n+                        \"a real number is required for format %i, not str\")\n         test_exc_common('%i', b'1', TypeError,\n-                        \"%i format: a real number is required, not bytes\")\n+                        \"a real number is required for format %i, not bytes\")\n+        test_exc_common('%g', '1', TypeError,\n+                        \"a real number is required for format %g, not str\")\n+        test_exc_common('%g', ('1',), TypeError,\n+                        \"format argument 1: a real number is required for format %g, not str\")\n \n     def test_str_format(self):\n         testformat(\"%r\", \"\\u0378\", \"'\\\\u0378'\")  # non printable\n         testformat(\"%a\", \"\\u0378\", \"'\\\\u0378'\")  # non printable\n         testformat(\"%r\", \"\\u0374\", \"'\\u0374'\")   # printable\n         testformat(\"%a\", \"\\u0374\", \"'\\\\u0374'\")  # printable\n+        testformat('%(x)r', {'x': 1}, '1')\n \n         # Test exception for unknown format characters, etc.\n         if verbose:\n             print('Testing exceptions')\n         test_exc('abc %b', 1, ValueError,\n-                 \"unsupported format character 'b' (0x62) at index 5\")\n-        #test_exc(unicode('abc %\\u3000','raw-unicode-escape'), 1, ValueError,\n-        #         \"unsupported format character '?' (0x3000) at index 5\")\n-        test_exc('%g', '1', TypeError, \"must be real number, not str\")\n+                 \"unsupported format %b at position 4\")\n+        test_exc(\"abc %\\nd\", 1, ValueError,\n+                 \"stray % at position 4 or unexpected format character U+000A at position 5\")\n+        test_exc(\"abc %\\x1fd\", 1, ValueError,\n+                 \"stray % at position 4 or unexpected format character U+001F at position 5\")\n+        test_exc(\"abc %\\x7fd\", 1, ValueError,\n+                 \"stray % at position 4 or unexpected format character U+007F at position 5\")\n+        test_exc(\"abc %\\x80d\", 1, ValueError,\n+                 \"stray % at position 4 or unexpected format character U+0080 at position 5\")\n+        test_exc('abc %\u00e4d', 1, ValueError,\n+                 \"stray % at position 4 or unexpected format character '\u00e4' (U+00E4) at position 5\")\n+        test_exc('abc %\u20acd', 1, ValueError,\n+                 \"stray % at position 4 or unexpected format character '\u20ac' (U+20AC) at position 5\")\n         test_exc('no format', '1', TypeError,\n-                 \"not all arguments converted during string formatting\")\n-        test_exc('%c', -1, OverflowError, \"%c arg not in range(0x110000)\")\n+                 \"not all arguments converted during string formatting (required 0, got 1)\")\n+        test_exc('%r', (1, 2), TypeError,\n+                 \"not all arguments converted during string formatting (required 1, got 2)\")\n+        test_exc('%(x)r %r', {'x': 1}, ValueError,\n+                 \"format requires a parenthesised mapping key at position 6\")\n+        test_exc('%(x)*r', {'x': 1}, ValueError,\n+                 \"* cannot be used with a parenthesised mapping key at position 0\")\n+        test_exc('%(x).*r', {'x': 1}, ValueError,\n+                 \"* cannot be used with a parenthesised mapping key at position 0\")\n+        test_exc('%(x)d', {'x': '1'}, TypeError,\n+                 \"format argument 'x': a real number is required for format %d, not str\")\n+        test_exc('%(x)x', {'x': '1'}, TypeError,\n+                 \"format argument 'x': an integer is required for format %x, not str\")\n+        test_exc('%(x)g', {'x': '1'}, TypeError,\n+                 \"format argument 'x': a real number is required for format %g, not str\")\n+        test_exc('%c', -1, OverflowError, \"%c argument not in range(0x110000)\")\n+        test_exc('%c', (-1,), OverflowError,\n+                 \"format argument 1: %c argument not in range(0x110000)\")\n+        test_exc('%(x)c', {'x': -1}, OverflowError,\n+                 \"format argument 'x': %c argument not in range(0x110000)\")\n         test_exc('%c', sys.maxunicode+1, OverflowError,\n-                 \"%c arg not in range(0x110000)\")\n-        #test_exc('%c', 2**128, OverflowError, \"%c arg not in range(0x110000)\")\n-        test_exc('%c', 3.14, TypeError, \"%c requires an int or a unicode character, not float\")\n-        test_exc('%c', 'ab', TypeError, \"%c requires an int or a unicode character, not a string of length 2\")\n-        test_exc('%c', b'x', TypeError, \"%c requires an int or a unicode character, not bytes\")\n+                 \"%c argument not in range(0x110000)\")\n+        test_exc('%c', 2**128, OverflowError,\n+                 \"%c argument not in range(0x110000)\")\n+        test_exc('%c', 3.14, TypeError,\n+                 \"%c requires an integer or a unicode character, not float\")",
      "comment": "```suggestion\n                 \"%c requires an integer or a Unicode character, not float\")\n```",
      "comment_id": 2577237964,
      "user": "vstinner",
      "created_at": "2025-12-01T14:08:53Z",
      "url": "https://github.com/python/cpython/pull/142081#discussion_r2577237964"
    },
    {
      "repo": "python/cpython",
      "pr_number": 142081,
      "file_path": "Lib/test/test_format.py",
      "line": 326,
      "side": "RIGHT",
      "diff_hunk": "@@ -272,45 +271,149 @@ def test_common_format(self):\n \n         if verbose:\n             print('Testing exceptions')\n-        test_exc_common('%', (), ValueError, \"incomplete format\")\n-        test_exc_common('% %s', 1, ValueError,\n-                        \"unsupported format character '%' (0x25) at index 2\")\n+        test_exc_common('abc %', (), ValueError, \"stray % at position 4\")\n+        test_exc_common('abc % %s', 1, ValueError,\n+                        \"stray % at position 4 or unexpected format character '%' at position 6\")\n+        test_exc_common('abc %z', 1, ValueError,\n+                        \"unsupported format %z at position 4\")\n+        test_exc_common(\"abc %Id\", 1, ValueError,\n+                        \"unsupported format %I at position 4\")\n+        test_exc_common(\"abc %'d\", 1, ValueError,\n+                        \"stray % at position 4 or unexpected format character ''' at position 5\")\n+        test_exc_common(\"abc %1 d\", 1, ValueError,\n+                        \"stray % at position 4 or unexpected format character ' ' at position 6\")\n+        test_exc_common('abc % (x)r', {}, ValueError,\n+                        \"stray % at position 4 or unexpected format character '(' at position 6\")\n+        test_exc_common('abc %((x)r', {}, ValueError,\n+                        \"stray % or incomplete format key at position 4\")\n+        test_exc_common('%r %r', 1, TypeError,\n+                        \"not enough arguments for format string (got 1)\")\n+        test_exc_common('%r %r', (1,), TypeError,\n+                        \"not enough arguments for format string (got 1)\")\n+        test_exc_common('%r', (), TypeError,\n+                        \"not enough arguments for format string (got 0)\")\n+        test_exc_common('abc %' + '9'*50 + 'r', 1, ValueError,\n+                        \"width too big at position 4\")\n+        test_exc_common('abc %.' + '9'*50 + 'r', 1, ValueError,\n+                        \"precision too big at position 4\")\n+        test_exc_common('%r %*r', 1, TypeError,\n+                        \"not enough arguments for format string (got 1)\")\n+        test_exc_common('%r %*r', (1,), TypeError,\n+                        \"not enough arguments for format string (got 1)\")\n+        test_exc_common('%*r', (1,), TypeError,\n+                        \"not enough arguments for format string (got 1)\")\n+        test_exc_common('%*r', (), TypeError,\n+                        \"not enough arguments for format string (got 0)\")\n+        test_exc_common('%r %.*r', 1, TypeError,\n+                        \"not enough arguments for format string (got 1)\")\n+        test_exc_common('%r %.*r', (1,), TypeError,\n+                        \"not enough arguments for format string (got 1)\")\n+        test_exc_common('%.*r', (1,), TypeError,\n+                        \"not enough arguments for format string (got 1)\")\n+        test_exc_common('%.*r', (), TypeError,\n+                        \"not enough arguments for format string (got 0)\")\n+        test_exc_common('%(x)r', 1, TypeError,\n+                        \"format requires a mapping, not int\")\n+        test_exc_common('%*r', 3.14, TypeError,\n+                        \"* requires int, not float\")\n+        test_exc_common('%*r', (3.14, 1), TypeError,\n+                        \"format argument 1: * requires int, not float\")\n+        test_exc_common('%.*r', 3.14, TypeError,\n+                        \"* requires int, not float\")\n+        test_exc_common('%.*r', (3.14, 1), TypeError,\n+                        \"format argument 1: * requires int, not float\")\n+        test_exc_common('%*r', (2**1000, 1), OverflowError,\n+                        \"format argument 1: too big for width\")",
      "comment": "This would mean that the width for format argument 1 is too big, isn't? But actually, format argument 1 is itself a width, and it is too big.",
      "comment_id": 2577491629,
      "user": "serhiy-storchaka",
      "created_at": "2025-12-01T15:12:18Z",
      "url": "https://github.com/python/cpython/pull/142081#discussion_r2577491629"
    },
    {
      "repo": "python/cpython",
      "pr_number": 142081,
      "file_path": "Lib/test/test_format.py",
      "line": 318,
      "side": "RIGHT",
      "diff_hunk": "@@ -272,45 +271,149 @@ def test_common_format(self):\n \n         if verbose:\n             print('Testing exceptions')\n-        test_exc_common('%', (), ValueError, \"incomplete format\")\n-        test_exc_common('% %s', 1, ValueError,\n-                        \"unsupported format character '%' (0x25) at index 2\")\n+        test_exc_common('abc %', (), ValueError, \"stray % at position 4\")\n+        test_exc_common('abc % %s', 1, ValueError,\n+                        \"stray % at position 4 or unexpected format character '%' at position 6\")\n+        test_exc_common('abc %z', 1, ValueError,\n+                        \"unsupported format %z at position 4\")\n+        test_exc_common(\"abc %Id\", 1, ValueError,\n+                        \"unsupported format %I at position 4\")\n+        test_exc_common(\"abc %'d\", 1, ValueError,\n+                        \"stray % at position 4 or unexpected format character ''' at position 5\")\n+        test_exc_common(\"abc %1 d\", 1, ValueError,\n+                        \"stray % at position 4 or unexpected format character ' ' at position 6\")\n+        test_exc_common('abc % (x)r', {}, ValueError,\n+                        \"stray % at position 4 or unexpected format character '(' at position 6\")\n+        test_exc_common('abc %((x)r', {}, ValueError,\n+                        \"stray % or incomplete format key at position 4\")\n+        test_exc_common('%r %r', 1, TypeError,\n+                        \"not enough arguments for format string (got 1)\")\n+        test_exc_common('%r %r', (1,), TypeError,\n+                        \"not enough arguments for format string (got 1)\")\n+        test_exc_common('%r', (), TypeError,\n+                        \"not enough arguments for format string (got 0)\")\n+        test_exc_common('abc %' + '9'*50 + 'r', 1, ValueError,\n+                        \"width too big at position 4\")\n+        test_exc_common('abc %.' + '9'*50 + 'r', 1, ValueError,\n+                        \"precision too big at position 4\")\n+        test_exc_common('%r %*r', 1, TypeError,\n+                        \"not enough arguments for format string (got 1)\")\n+        test_exc_common('%r %*r', (1,), TypeError,\n+                        \"not enough arguments for format string (got 1)\")\n+        test_exc_common('%*r', (1,), TypeError,\n+                        \"not enough arguments for format string (got 1)\")\n+        test_exc_common('%*r', (), TypeError,\n+                        \"not enough arguments for format string (got 0)\")\n+        test_exc_common('%r %.*r', 1, TypeError,\n+                        \"not enough arguments for format string (got 1)\")\n+        test_exc_common('%r %.*r', (1,), TypeError,\n+                        \"not enough arguments for format string (got 1)\")\n+        test_exc_common('%.*r', (1,), TypeError,\n+                        \"not enough arguments for format string (got 1)\")\n+        test_exc_common('%.*r', (), TypeError,\n+                        \"not enough arguments for format string (got 0)\")\n+        test_exc_common('%(x)r', 1, TypeError,\n+                        \"format requires a mapping, not int\")\n+        test_exc_common('%*r', 3.14, TypeError,\n+                        \"* requires int, not float\")",
      "comment": "It is perhaps better to remove this test, because the example is incorrect in more than one way. If `*` is used, then we need more than one argument, and in that case we will get \"format argument N\" in the error message, like in the following line..",
      "comment_id": 2577511114,
      "user": "serhiy-storchaka",
      "created_at": "2025-12-01T15:16:45Z",
      "url": "https://github.com/python/cpython/pull/142081#discussion_r2577511114"
    },
    {
      "repo": "python/cpython",
      "pr_number": 142081,
      "file_path": "Lib/test/test_format.py",
      "line": 404,
      "side": "RIGHT",
      "diff_hunk": "@@ -272,45 +271,149 @@ def test_common_format(self):\n \n         if verbose:\n             print('Testing exceptions')\n-        test_exc_common('%', (), ValueError, \"incomplete format\")\n-        test_exc_common('% %s', 1, ValueError,\n-                        \"unsupported format character '%' (0x25) at index 2\")\n+        test_exc_common('abc %', (), ValueError, \"stray % at position 4\")\n+        test_exc_common('abc % %s', 1, ValueError,\n+                        \"stray % at position 4 or unexpected format character '%' at position 6\")\n+        test_exc_common('abc %z', 1, ValueError,\n+                        \"unsupported format %z at position 4\")\n+        test_exc_common(\"abc %Id\", 1, ValueError,\n+                        \"unsupported format %I at position 4\")\n+        test_exc_common(\"abc %'d\", 1, ValueError,\n+                        \"stray % at position 4 or unexpected format character ''' at position 5\")\n+        test_exc_common(\"abc %1 d\", 1, ValueError,\n+                        \"stray % at position 4 or unexpected format character ' ' at position 6\")\n+        test_exc_common('abc % (x)r', {}, ValueError,\n+                        \"stray % at position 4 or unexpected format character '(' at position 6\")\n+        test_exc_common('abc %((x)r', {}, ValueError,\n+                        \"stray % or incomplete format key at position 4\")\n+        test_exc_common('%r %r', 1, TypeError,\n+                        \"not enough arguments for format string (got 1)\")\n+        test_exc_common('%r %r', (1,), TypeError,\n+                        \"not enough arguments for format string (got 1)\")\n+        test_exc_common('%r', (), TypeError,\n+                        \"not enough arguments for format string (got 0)\")\n+        test_exc_common('abc %' + '9'*50 + 'r', 1, ValueError,\n+                        \"width too big at position 4\")\n+        test_exc_common('abc %.' + '9'*50 + 'r', 1, ValueError,\n+                        \"precision too big at position 4\")\n+        test_exc_common('%r %*r', 1, TypeError,\n+                        \"not enough arguments for format string (got 1)\")\n+        test_exc_common('%r %*r', (1,), TypeError,\n+                        \"not enough arguments for format string (got 1)\")\n+        test_exc_common('%*r', (1,), TypeError,\n+                        \"not enough arguments for format string (got 1)\")\n+        test_exc_common('%*r', (), TypeError,\n+                        \"not enough arguments for format string (got 0)\")\n+        test_exc_common('%r %.*r', 1, TypeError,\n+                        \"not enough arguments for format string (got 1)\")\n+        test_exc_common('%r %.*r', (1,), TypeError,\n+                        \"not enough arguments for format string (got 1)\")\n+        test_exc_common('%.*r', (1,), TypeError,\n+                        \"not enough arguments for format string (got 1)\")\n+        test_exc_common('%.*r', (), TypeError,\n+                        \"not enough arguments for format string (got 0)\")\n+        test_exc_common('%(x)r', 1, TypeError,\n+                        \"format requires a mapping, not int\")\n+        test_exc_common('%*r', 3.14, TypeError,\n+                        \"* requires int, not float\")\n+        test_exc_common('%*r', (3.14, 1), TypeError,\n+                        \"format argument 1: * requires int, not float\")\n+        test_exc_common('%.*r', 3.14, TypeError,\n+                        \"* requires int, not float\")\n+        test_exc_common('%.*r', (3.14, 1), TypeError,\n+                        \"format argument 1: * requires int, not float\")\n+        test_exc_common('%*r', (2**1000, 1), OverflowError,\n+                        \"format argument 1: too big for width\")\n+        test_exc_common('%*r', (-2**1000, 1), OverflowError,\n+                        \"format argument 1: too big for width\")\n+        test_exc_common('%.*r', (2**1000, 1), OverflowError,\n+                        \"format argument 1: too big for precision\")\n+        test_exc_common('%.*r', (-2**1000, 1), OverflowError,\n+                        \"format argument 1: too big for precision\")\n         test_exc_common('%d', '1', TypeError,\n-                        \"%d format: a real number is required, not str\")\n+                        \"a real number is required for format %d, not str\")\n         test_exc_common('%d', b'1', TypeError,\n-                        \"%d format: a real number is required, not bytes\")\n+                        \"a real number is required for format %d, not bytes\")\n+        test_exc_common('%d', ('1',), TypeError,\n+                        \"format argument 1: a real number is required for format %d, not str\")\n         test_exc_common('%x', '1', TypeError,\n-                        \"%x format: an integer is required, not str\")\n+                        \"an integer is required for format %x, not str\")\n         test_exc_common('%x', 3.14, TypeError,\n-                        \"%x format: an integer is required, not float\")\n+                        \"an integer is required for format %x, not float\")\n+        test_exc_common('%x', ('1',), TypeError,\n+                        \"format argument 1: an integer is required for format %x, not str\")\n         test_exc_common('%i', '1', TypeError,\n-                        \"%i format: a real number is required, not str\")\n+                        \"a real number is required for format %i, not str\")\n         test_exc_common('%i', b'1', TypeError,\n-                        \"%i format: a real number is required, not bytes\")\n+                        \"a real number is required for format %i, not bytes\")\n+        test_exc_common('%g', '1', TypeError,\n+                        \"a real number is required for format %g, not str\")\n+        test_exc_common('%g', ('1',), TypeError,\n+                        \"format argument 1: a real number is required for format %g, not str\")\n \n     def test_str_format(self):\n         testformat(\"%r\", \"\\u0378\", \"'\\\\u0378'\")  # non printable\n         testformat(\"%a\", \"\\u0378\", \"'\\\\u0378'\")  # non printable\n         testformat(\"%r\", \"\\u0374\", \"'\\u0374'\")   # printable\n         testformat(\"%a\", \"\\u0374\", \"'\\\\u0374'\")  # printable\n+        testformat('%(x)r', {'x': 1}, '1')\n \n         # Test exception for unknown format characters, etc.\n         if verbose:\n             print('Testing exceptions')\n         test_exc('abc %b', 1, ValueError,\n-                 \"unsupported format character 'b' (0x62) at index 5\")\n-        #test_exc(unicode('abc %\\u3000','raw-unicode-escape'), 1, ValueError,\n-        #         \"unsupported format character '?' (0x3000) at index 5\")\n-        test_exc('%g', '1', TypeError, \"must be real number, not str\")\n+                 \"unsupported format %b at position 4\")\n+        test_exc(\"abc %\\nd\", 1, ValueError,\n+                 \"stray % at position 4 or unexpected format character U+000A at position 5\")\n+        test_exc(\"abc %\\x1fd\", 1, ValueError,\n+                 \"stray % at position 4 or unexpected format character U+001F at position 5\")\n+        test_exc(\"abc %\\x7fd\", 1, ValueError,\n+                 \"stray % at position 4 or unexpected format character U+007F at position 5\")\n+        test_exc(\"abc %\\x80d\", 1, ValueError,\n+                 \"stray % at position 4 or unexpected format character U+0080 at position 5\")\n+        test_exc('abc %\u00e4d', 1, ValueError,\n+                 \"stray % at position 4 or unexpected format character '\u00e4' (U+00E4) at position 5\")\n+        test_exc('abc %\u20acd', 1, ValueError,\n+                 \"stray % at position 4 or unexpected format character '\u20ac' (U+20AC) at position 5\")\n         test_exc('no format', '1', TypeError,\n-                 \"not all arguments converted during string formatting\")\n-        test_exc('%c', -1, OverflowError, \"%c arg not in range(0x110000)\")\n+                 \"not all arguments converted during string formatting (required 0, got 1)\")\n+        test_exc('%r', (1, 2), TypeError,\n+                 \"not all arguments converted during string formatting (required 1, got 2)\")\n+        test_exc('%(x)r %r', {'x': 1}, ValueError,\n+                 \"format requires a parenthesised mapping key at position 6\")\n+        test_exc('%(x)*r', {'x': 1}, ValueError,\n+                 \"* cannot be used with a parenthesised mapping key at position 0\")\n+        test_exc('%(x).*r', {'x': 1}, ValueError,\n+                 \"* cannot be used with a parenthesised mapping key at position 0\")\n+        test_exc('%(x)d', {'x': '1'}, TypeError,\n+                 \"format argument 'x': a real number is required for format %d, not str\")\n+        test_exc('%(x)x', {'x': '1'}, TypeError,\n+                 \"format argument 'x': an integer is required for format %x, not str\")\n+        test_exc('%(x)g', {'x': '1'}, TypeError,\n+                 \"format argument 'x': a real number is required for format %g, not str\")\n+        test_exc('%c', -1, OverflowError, \"%c argument not in range(0x110000)\")\n+        test_exc('%c', (-1,), OverflowError,\n+                 \"format argument 1: %c argument not in range(0x110000)\")\n+        test_exc('%(x)c', {'x': -1}, OverflowError,\n+                 \"format argument 'x': %c argument not in range(0x110000)\")\n         test_exc('%c', sys.maxunicode+1, OverflowError,\n-                 \"%c arg not in range(0x110000)\")\n-        #test_exc('%c', 2**128, OverflowError, \"%c arg not in range(0x110000)\")\n-        test_exc('%c', 3.14, TypeError, \"%c requires an int or a unicode character, not float\")\n-        test_exc('%c', 'ab', TypeError, \"%c requires an int or a unicode character, not a string of length 2\")\n-        test_exc('%c', b'x', TypeError, \"%c requires an int or a unicode character, not bytes\")\n+                 \"%c argument not in range(0x110000)\")\n+        test_exc('%c', 2**128, OverflowError,\n+                 \"%c argument not in range(0x110000)\")\n+        test_exc('%c', 3.14, TypeError,\n+                 \"%c requires an integer or a unicode character, not float\")",
      "comment": "This is used in many other places. We should do all such changes at once -- either capitalize \"unicode\", or remove it.",
      "comment_id": 2577519377,
      "user": "serhiy-storchaka",
      "created_at": "2025-12-01T15:19:01Z",
      "url": "https://github.com/python/cpython/pull/142081#discussion_r2577519377"
    },
    {
      "repo": "python/cpython",
      "pr_number": 142081,
      "file_path": "Lib/test/test_format.py",
      "line": 326,
      "side": "RIGHT",
      "diff_hunk": "@@ -272,45 +271,149 @@ def test_common_format(self):\n \n         if verbose:\n             print('Testing exceptions')\n-        test_exc_common('%', (), ValueError, \"incomplete format\")\n-        test_exc_common('% %s', 1, ValueError,\n-                        \"unsupported format character '%' (0x25) at index 2\")\n+        test_exc_common('abc %', (), ValueError, \"stray % at position 4\")\n+        test_exc_common('abc % %s', 1, ValueError,\n+                        \"stray % at position 4 or unexpected format character '%' at position 6\")\n+        test_exc_common('abc %z', 1, ValueError,\n+                        \"unsupported format %z at position 4\")\n+        test_exc_common(\"abc %Id\", 1, ValueError,\n+                        \"unsupported format %I at position 4\")\n+        test_exc_common(\"abc %'d\", 1, ValueError,\n+                        \"stray % at position 4 or unexpected format character ''' at position 5\")\n+        test_exc_common(\"abc %1 d\", 1, ValueError,\n+                        \"stray % at position 4 or unexpected format character ' ' at position 6\")\n+        test_exc_common('abc % (x)r', {}, ValueError,\n+                        \"stray % at position 4 or unexpected format character '(' at position 6\")\n+        test_exc_common('abc %((x)r', {}, ValueError,\n+                        \"stray % or incomplete format key at position 4\")\n+        test_exc_common('%r %r', 1, TypeError,\n+                        \"not enough arguments for format string (got 1)\")\n+        test_exc_common('%r %r', (1,), TypeError,\n+                        \"not enough arguments for format string (got 1)\")\n+        test_exc_common('%r', (), TypeError,\n+                        \"not enough arguments for format string (got 0)\")\n+        test_exc_common('abc %' + '9'*50 + 'r', 1, ValueError,\n+                        \"width too big at position 4\")\n+        test_exc_common('abc %.' + '9'*50 + 'r', 1, ValueError,\n+                        \"precision too big at position 4\")\n+        test_exc_common('%r %*r', 1, TypeError,\n+                        \"not enough arguments for format string (got 1)\")\n+        test_exc_common('%r %*r', (1,), TypeError,\n+                        \"not enough arguments for format string (got 1)\")\n+        test_exc_common('%*r', (1,), TypeError,\n+                        \"not enough arguments for format string (got 1)\")\n+        test_exc_common('%*r', (), TypeError,\n+                        \"not enough arguments for format string (got 0)\")\n+        test_exc_common('%r %.*r', 1, TypeError,\n+                        \"not enough arguments for format string (got 1)\")\n+        test_exc_common('%r %.*r', (1,), TypeError,\n+                        \"not enough arguments for format string (got 1)\")\n+        test_exc_common('%.*r', (1,), TypeError,\n+                        \"not enough arguments for format string (got 1)\")\n+        test_exc_common('%.*r', (), TypeError,\n+                        \"not enough arguments for format string (got 0)\")\n+        test_exc_common('%(x)r', 1, TypeError,\n+                        \"format requires a mapping, not int\")\n+        test_exc_common('%*r', 3.14, TypeError,\n+                        \"* requires int, not float\")\n+        test_exc_common('%*r', (3.14, 1), TypeError,\n+                        \"format argument 1: * requires int, not float\")\n+        test_exc_common('%.*r', 3.14, TypeError,\n+                        \"* requires int, not float\")\n+        test_exc_common('%.*r', (3.14, 1), TypeError,\n+                        \"format argument 1: * requires int, not float\")\n+        test_exc_common('%*r', (2**1000, 1), OverflowError,\n+                        \"format argument 1: too big for width\")",
      "comment": "Oh, I misunderstood the error message. My suggestion is wrong.",
      "comment_id": 2578097911,
      "user": "vstinner",
      "created_at": "2025-12-01T17:56:14Z",
      "url": "https://github.com/python/cpython/pull/142081#discussion_r2578097911"
    },
    {
      "repo": "python/cpython",
      "pr_number": 142081,
      "file_path": "Lib/test/test_bytes.py",
      "line": 784,
      "side": "RIGHT",
      "diff_hunk": "@@ -781,16 +781,16 @@ def __int__(self):\n         pi = PseudoFloat(3.1415)\n \n         exceptions_params = [\n-            ('%x format: an integer is required, not float', b'%x', 3.14),\n-            ('%X format: an integer is required, not float', b'%X', 2.11),\n-            ('%o format: an integer is required, not float', b'%o', 1.79),\n-            ('%x format: an integer is required, not PseudoFloat', b'%x', pi),\n-            ('%x format: an integer is required, not complex', b'%x', 3j),\n-            ('%X format: an integer is required, not complex', b'%X', 2j),\n-            ('%o format: an integer is required, not complex', b'%o', 1j),\n-            ('%u format: a real number is required, not complex', b'%u', 3j),\n-            ('%i format: a real number is required, not complex', b'%i', 2j),\n-            ('%d format: a real number is required, not complex', b'%d', 2j),\n+            ('%x requires an integer, not float', b'%x', 3.14),",
      "comment": "I would prefer to keep the word \"format\", like:\n\n```suggestion\n            ('%x format requires an integer, not float', b'%x', 3.14),\n```",
      "comment_id": 2681739653,
      "user": "vstinner",
      "created_at": "2026-01-12T10:50:52Z",
      "url": "https://github.com/python/cpython/pull/142081#discussion_r2681739653"
    },
    {
      "repo": "python/cpython",
      "pr_number": 142081,
      "file_path": "Lib/test/test_peepholer.py",
      "line": 736,
      "side": "RIGHT",
      "diff_hunk": "@@ -733,22 +733,27 @@ def test_format_errors(self):\n         with self.assertRaisesRegex(TypeError,\n                     'not all arguments converted during string formatting'):\n             eval(\"'%s' % (x, y)\", {'x': 1, 'y': 2})\n-        with self.assertRaisesRegex(ValueError, 'incomplete format'):\n+        with self.assertRaisesRegex(ValueError, 'stray % at position 2'):",
      "comment": "You might keep the word \"format\", like:\n\n```suggestion\n        with self.assertRaisesRegex(ValueError, 'incomplete format: stray % at position 2'):\n```",
      "comment_id": 2681741343,
      "user": "vstinner",
      "created_at": "2026-01-12T10:51:19Z",
      "url": "https://github.com/python/cpython/pull/142081#discussion_r2681741343"
    },
    {
      "repo": "python/cpython",
      "pr_number": 142081,
      "file_path": "Lib/test/test_peepholer.py",
      "line": 736,
      "side": "RIGHT",
      "diff_hunk": "@@ -733,22 +733,27 @@ def test_format_errors(self):\n         with self.assertRaisesRegex(TypeError,\n                     'not all arguments converted during string formatting'):\n             eval(\"'%s' % (x, y)\", {'x': 1, 'y': 2})\n-        with self.assertRaisesRegex(ValueError, 'incomplete format'):\n+        with self.assertRaisesRegex(ValueError, 'stray % at position 2'):",
      "comment": "I think that stray % is more common error than incomplete format.",
      "comment_id": 2682254984,
      "user": "serhiy-storchaka",
      "created_at": "2026-01-12T13:21:39Z",
      "url": "https://github.com/python/cpython/pull/142081#discussion_r2682254984"
    },
    {
      "repo": "python/cpython",
      "pr_number": 142081,
      "file_path": "Lib/test/test_bytes.py",
      "line": 784,
      "side": "RIGHT",
      "diff_hunk": "@@ -781,16 +781,16 @@ def __int__(self):\n         pi = PseudoFloat(3.1415)\n \n         exceptions_params = [\n-            ('%x format: an integer is required, not float', b'%x', 3.14),\n-            ('%X format: an integer is required, not float', b'%X', 2.11),\n-            ('%o format: an integer is required, not float', b'%o', 1.79),\n-            ('%x format: an integer is required, not PseudoFloat', b'%x', pi),\n-            ('%x format: an integer is required, not complex', b'%x', 3j),\n-            ('%X format: an integer is required, not complex', b'%X', 2j),\n-            ('%o format: an integer is required, not complex', b'%o', 1j),\n-            ('%u format: a real number is required, not complex', b'%u', 3j),\n-            ('%i format: a real number is required, not complex', b'%i', 2j),\n-            ('%d format: a real number is required, not complex', b'%d', 2j),\n+            ('%x requires an integer, not float', b'%x', 3.14),",
      "comment": "I removed \"format\" because in \"format argument 1: %x format requires an integer, not float\" it would be repeated twice.\n\nWe can add the \"format argument\" prefix (without argument number or name) for the case when the operand is not a tuple or dict: \"format argument: %x requires an integer, not float\".",
      "comment_id": 2682270600,
      "user": "serhiy-storchaka",
      "created_at": "2026-01-12T13:25:39Z",
      "url": "https://github.com/python/cpython/pull/142081#discussion_r2682270600"
    },
    {
      "repo": "python/cpython",
      "pr_number": 142081,
      "file_path": "Lib/test/test_bytes.py",
      "line": 784,
      "side": "RIGHT",
      "diff_hunk": "@@ -781,16 +781,16 @@ def __int__(self):\n         pi = PseudoFloat(3.1415)\n \n         exceptions_params = [\n-            ('%x format: an integer is required, not float', b'%x', 3.14),\n-            ('%X format: an integer is required, not float', b'%X', 2.11),\n-            ('%o format: an integer is required, not float', b'%o', 1.79),\n-            ('%x format: an integer is required, not PseudoFloat', b'%x', pi),\n-            ('%x format: an integer is required, not complex', b'%x', 3j),\n-            ('%X format: an integer is required, not complex', b'%X', 2j),\n-            ('%o format: an integer is required, not complex', b'%o', 1j),\n-            ('%u format: a real number is required, not complex', b'%u', 3j),\n-            ('%i format: a real number is required, not complex', b'%i', 2j),\n-            ('%d format: a real number is required, not complex', b'%d', 2j),\n+            ('%x requires an integer, not float', b'%x', 3.14),",
      "comment": "The error message doesn't contain `format argument 1: `:\r\n\r\n```\r\n>>> \"%x\" % \"abc\"\r\nTypeError: %x requires an integer, not str\r\n```\r\n\r\nIn which case `format argument 1: ` is added?",
      "comment_id": 2698746934,
      "user": "vstinner",
      "created_at": "2026-01-16T14:34:21Z",
      "url": "https://github.com/python/cpython/pull/142081#discussion_r2698746934"
    },
    {
      "repo": "python/cpython",
      "pr_number": 142081,
      "file_path": "Lib/test/test_bytes.py",
      "line": 784,
      "side": "RIGHT",
      "diff_hunk": "@@ -781,16 +781,16 @@ def __int__(self):\n         pi = PseudoFloat(3.1415)\n \n         exceptions_params = [\n-            ('%x format: an integer is required, not float', b'%x', 3.14),\n-            ('%X format: an integer is required, not float', b'%X', 2.11),\n-            ('%o format: an integer is required, not float', b'%o', 1.79),\n-            ('%x format: an integer is required, not PseudoFloat', b'%x', pi),\n-            ('%x format: an integer is required, not complex', b'%x', 3j),\n-            ('%X format: an integer is required, not complex', b'%X', 2j),\n-            ('%o format: an integer is required, not complex', b'%o', 1j),\n-            ('%u format: a real number is required, not complex', b'%u', 3j),\n-            ('%i format: a real number is required, not complex', b'%i', 2j),\n-            ('%d format: a real number is required, not complex', b'%d', 2j),\n+            ('%x requires an integer, not float', b'%x', 3.14),",
      "comment": "When you have several format arguments. For example:\r\n\r\n```pycon\r\n>>> \"%x %s\" % (\"abc\", 42)\r\nTypeError: format argument 1: %x requires an integer, not str\r\n>>> \"%(a)x %(b)s\" % {\"a\": \"abc\", \"b\": 42}\r\nTypeError: format argument 'a': %x requires an integer, not str\r\n```\r\n\r\nWe can add it for single non-tuple argument:\r\n\r\n```pycon\r\n>>> \"%x\" % \"abc\"\r\nTypeError: format argument: %x requires an integer, not str\r\n```\r\n\r\nWhat would be better?",
      "comment_id": 2699231621,
      "user": "serhiy-storchaka",
      "created_at": "2026-01-16T16:45:09Z",
      "url": "https://github.com/python/cpython/pull/142081#discussion_r2699231621"
    },
    {
      "repo": "python/cpython",
      "pr_number": 142081,
      "file_path": "Lib/test/test_bytes.py",
      "line": 784,
      "side": "RIGHT",
      "diff_hunk": "@@ -781,16 +781,16 @@ def __int__(self):\n         pi = PseudoFloat(3.1415)\n \n         exceptions_params = [\n-            ('%x format: an integer is required, not float', b'%x', 3.14),\n-            ('%X format: an integer is required, not float', b'%X', 2.11),\n-            ('%o format: an integer is required, not float', b'%o', 1.79),\n-            ('%x format: an integer is required, not PseudoFloat', b'%x', pi),\n-            ('%x format: an integer is required, not complex', b'%x', 3j),\n-            ('%X format: an integer is required, not complex', b'%X', 2j),\n-            ('%o format: an integer is required, not complex', b'%o', 1j),\n-            ('%u format: a real number is required, not complex', b'%u', 3j),\n-            ('%i format: a real number is required, not complex', b'%i', 2j),\n-            ('%d format: a real number is required, not complex', b'%d', 2j),\n+            ('%x requires an integer, not float', b'%x', 3.14),",
      "comment": "`format argument: %x requires an integer, not str` is better than just `%x requires an integer, not str`. It gives more context.",
      "comment_id": 2699302465,
      "user": "vstinner",
      "created_at": "2026-01-16T17:07:37Z",
      "url": "https://github.com/python/cpython/pull/142081#discussion_r2699302465"
    },
    {
      "repo": "python/cpython",
      "pr_number": 142081,
      "file_path": "Lib/test/test_bytes.py",
      "line": 784,
      "side": "RIGHT",
      "diff_hunk": "@@ -781,16 +781,16 @@ def __int__(self):\n         pi = PseudoFloat(3.1415)\n \n         exceptions_params = [\n-            ('%x format: an integer is required, not float', b'%x', 3.14),\n-            ('%X format: an integer is required, not float', b'%X', 2.11),\n-            ('%o format: an integer is required, not float', b'%o', 1.79),\n-            ('%x format: an integer is required, not PseudoFloat', b'%x', pi),\n-            ('%x format: an integer is required, not complex', b'%x', 3j),\n-            ('%X format: an integer is required, not complex', b'%X', 2j),\n-            ('%o format: an integer is required, not complex', b'%o', 1j),\n-            ('%u format: a real number is required, not complex', b'%u', 3j),\n-            ('%i format: a real number is required, not complex', b'%i', 2j),\n-            ('%d format: a real number is required, not complex', b'%d', 2j),\n+            ('%x requires an integer, not float', b'%x', 3.14),",
      "comment": "```\r\n>>> \"%x\" % \"abc\"\r\nTypeError: format argument: %x requires an integer, not str\r\n```\r\n\r\nI like this error message, thanks.",
      "comment_id": 2720982017,
      "user": "vstinner",
      "created_at": "2026-01-23T12:20:00Z",
      "url": "https://github.com/python/cpython/pull/142081#discussion_r2720982017"
    },
    {
      "repo": "python/cpython",
      "pr_number": 142081,
      "file_path": "Lib/test/test_bytes.py",
      "line": 784,
      "side": "RIGHT",
      "diff_hunk": "@@ -781,16 +781,16 @@ def __int__(self):\n         pi = PseudoFloat(3.1415)\n \n         exceptions_params = [\n-            ('%x format: an integer is required, not float', b'%x', 3.14),\n-            ('%X format: an integer is required, not float', b'%X', 2.11),\n-            ('%o format: an integer is required, not float', b'%o', 1.79),\n-            ('%x format: an integer is required, not PseudoFloat', b'%x', pi),\n-            ('%x format: an integer is required, not complex', b'%x', 3j),\n-            ('%X format: an integer is required, not complex', b'%X', 2j),\n-            ('%o format: an integer is required, not complex', b'%o', 1j),\n-            ('%u format: a real number is required, not complex', b'%u', 3j),\n-            ('%i format: a real number is required, not complex', b'%i', 2j),\n-            ('%d format: a real number is required, not complex', b'%d', 2j),\n+            ('%x requires an integer, not float', b'%x', 3.14),",
      "comment": "You should match the whole error message, to check that `format argument: ` is present:\n\n```suggestion\n            ('format argument: %x requires an integer, not float', b'%x', 3.14),\n```",
      "comment_id": 2720995423,
      "user": "vstinner",
      "created_at": "2026-01-23T12:24:33Z",
      "url": "https://github.com/python/cpython/pull/142081#discussion_r2720995423"
    },
    {
      "repo": "python/cpython",
      "pr_number": 142081,
      "file_path": "Lib/test/test_format.py",
      "line": 421,
      "side": "RIGHT",
      "diff_hunk": "@@ -272,45 +271,154 @@ def test_common_format(self):\n \n         if verbose:\n             print('Testing exceptions')\n-        test_exc_common('%', (), ValueError, \"incomplete format\")\n-        test_exc_common('% %s', 1, ValueError,\n-                        \"unsupported format character '%' (0x25) at index 2\")\n+        test_exc_common('abc %', (), ValueError, \"stray % at position 4\")\n+        test_exc_common('abc % %s', 1, ValueError,\n+                        \"stray % at position 4 or unexpected format character '%' at position 6\")\n+        test_exc_common('abc %z', 1, ValueError,\n+                        \"unsupported format %z at position 4\")\n+        test_exc_common(\"abc %Id\", 1, ValueError,\n+                        \"unsupported format %I at position 4\")\n+        test_exc_common(\"abc %'d\", 1, ValueError,\n+                        \"stray % at position 4 or unexpected format character \\\"'\\\" at position 5\")\n+        test_exc_common(\"abc %1 d\", 1, ValueError,\n+                        \"stray % at position 4 or unexpected format character ' ' at position 6\")\n+        test_exc_common('abc % (x)r', {}, ValueError,\n+                        \"stray % at position 4 or unexpected format character '(' at position 6\")\n+        test_exc_common('abc %((x)r', {}, ValueError,\n+                        \"stray % or incomplete format key at position 4\")\n+        test_exc_common('%r %r', 1, TypeError,\n+                        \"not enough arguments for format string (got 1)\")\n+        test_exc_common('%r %r', (1,), TypeError,\n+                        \"not enough arguments for format string (got 1)\")\n+        test_exc_common('%r', (), TypeError,\n+                        \"not enough arguments for format string (got 0)\")\n+        test_exc_common('abc %' + '9'*50 + 'r', 1, ValueError,\n+                        \"width too big at position 4\")\n+        test_exc_common('abc %.' + '9'*50 + 'r', 1, ValueError,\n+                        \"precision too big at position 4\")\n+        test_exc_common('%r %*r', 1, TypeError,\n+                        \"not enough arguments for format string (got 1)\")\n+        test_exc_common('%r %*r', (1,), TypeError,\n+                        \"not enough arguments for format string (got 1)\")\n+        test_exc_common('%*r', (1,), TypeError,\n+                        \"not enough arguments for format string (got 1)\")\n+        test_exc_common('%*r', (), TypeError,\n+                        \"not enough arguments for format string (got 0)\")\n+        test_exc_common('%r %.*r', 1, TypeError,\n+                        \"not enough arguments for format string (got 1)\")\n+        test_exc_common('%r %.*r', (1,), TypeError,\n+                        \"not enough arguments for format string (got 1)\")\n+        test_exc_common('%.*r', (1,), TypeError,\n+                        \"not enough arguments for format string (got 1)\")\n+        test_exc_common('%.*r', (), TypeError,\n+                        \"not enough arguments for format string (got 0)\")\n+        test_exc_common('%(x)r', 1, TypeError,\n+                        \"format requires a mapping, not int\")\n+        test_exc_common('%*r', 1, TypeError,\n+                        \"not enough arguments for format string (got 1)\")\n+        test_exc_common('%*r', 3.14, TypeError,\n+                        \"not enough arguments for format string (got 1)\")\n+        test_exc_common('%*r', (3.14, 1), TypeError,\n+                        \"format argument 1: * requires int, not float\")\n+        test_exc_common('%.*r', 1, TypeError,\n+                        \"not enough arguments for format string (got 1)\")\n+        test_exc_common('%.*r', 3.14, TypeError,\n+                        \"not enough arguments for format string (got 1)\")\n+        test_exc_common('%.*r', (3.14, 1), TypeError,\n+                        \"format argument 1: * requires int, not float\")\n+        test_exc_common('%*r', (2**1000, 1), OverflowError,\n+                        \"format argument 1: too big for width\")\n+        test_exc_common('%*r', (-2**1000, 1), OverflowError,\n+                        \"format argument 1: too big for width\")\n+        test_exc_common('%.*r', (2**1000, 1), OverflowError,\n+                        \"format argument 1: too big for precision\")\n+        test_exc_common('%.*r', (-2**1000, 1), OverflowError,\n+                        \"format argument 1: too big for precision\")\n         test_exc_common('%d', '1', TypeError,\n-                        \"%d format: a real number is required, not str\")\n+                        \"format argument: %d requires a real number, not str\")\n         test_exc_common('%d', b'1', TypeError,\n-                        \"%d format: a real number is required, not bytes\")\n+                        \"format argument: %d requires a real number, not bytes\")\n+        test_exc_common('%d', ('1',), TypeError,\n+                        \"format argument 1: %d requires a real number, not str\")\n         test_exc_common('%x', '1', TypeError,\n-                        \"%x format: an integer is required, not str\")\n+                        \"format argument: %x requires an integer, not str\")\n         test_exc_common('%x', 3.14, TypeError,\n-                        \"%x format: an integer is required, not float\")\n+                        \"format argument: %x requires an integer, not float\")\n+        test_exc_common('%x', ('1',), TypeError,\n+                        \"format argument 1: %x requires an integer, not str\")\n         test_exc_common('%i', '1', TypeError,\n-                        \"%i format: a real number is required, not str\")\n+                        \"format argument: %i requires a real number, not str\")\n         test_exc_common('%i', b'1', TypeError,\n-                        \"%i format: a real number is required, not bytes\")\n+                        \"format argument: %i requires a real number, not bytes\")\n+        test_exc_common('%g', '1', TypeError,\n+                        \"format argument: %g requires a real number, not str\")\n+        test_exc_common('%g', ('1',), TypeError,\n+                        \"format argument 1: %g requires a real number, not str\")\n \n     def test_str_format(self):\n         testformat(\"%r\", \"\\u0378\", \"'\\\\u0378'\")  # non printable\n         testformat(\"%a\", \"\\u0378\", \"'\\\\u0378'\")  # non printable\n         testformat(\"%r\", \"\\u0374\", \"'\\u0374'\")   # printable\n         testformat(\"%a\", \"\\u0374\", \"'\\\\u0374'\")  # printable\n+        testformat('%(x)r', {'x': 1}, '1')\n \n         # Test exception for unknown format characters, etc.\n         if verbose:\n             print('Testing exceptions')\n         test_exc('abc %b', 1, ValueError,\n-                 \"unsupported format character 'b' (0x62) at index 5\")\n-        #test_exc(unicode('abc %\\u3000','raw-unicode-escape'), 1, ValueError,\n-        #         \"unsupported format character '?' (0x3000) at index 5\")\n-        test_exc('%g', '1', TypeError, \"must be real number, not str\")\n+                 \"unsupported format %b at position 4\")\n+        test_exc(\"abc %\\nd\", 1, ValueError,\n+                 \"stray % at position 4 or unexpected format character U+000A at position 5\")\n+        test_exc(\"abc %\\x1fd\", 1, ValueError,\n+                 \"stray % at position 4 or unexpected format character U+001F at position 5\")\n+        test_exc(\"abc %\\x7fd\", 1, ValueError,\n+                 \"stray % at position 4 or unexpected format character U+007F at position 5\")\n+        test_exc(\"abc %\\x80d\", 1, ValueError,\n+                 \"stray % at position 4 or unexpected format character U+0080 at position 5\")\n+        test_exc('abc %\u00e4d', 1, ValueError,\n+                 \"stray % at position 4 or unexpected format character '\u00e4' (U+00E4) at position 5\")\n+        test_exc('abc %\u20acd', 1, ValueError,\n+                 \"stray % at position 4 or unexpected format character '\u20ac' (U+20AC) at position 5\")\n         test_exc('no format', '1', TypeError,\n-                 \"not all arguments converted during string formatting\")\n-        test_exc('%c', -1, OverflowError, \"%c arg not in range(0x110000)\")\n+                 \"not all arguments converted during string formatting (required 0, got 1)\")\n+        test_exc('%r', (1, 2), TypeError,\n+                 \"not all arguments converted during string formatting (required 1, got 2)\")\n+        test_exc('%(x)r %r', {'x': 1}, ValueError,\n+                 \"format requires a parenthesised mapping key at position 6\")\n+        test_exc('%(x)*r', {'x': 1}, ValueError,\n+                 \"* cannot be used with a parenthesised mapping key at position 0\")\n+        test_exc('%(x).*r', {'x': 1}, ValueError,\n+                 \"* cannot be used with a parenthesised mapping key at position 0\")\n+        test_exc('%(x)d', {'x': '1'}, TypeError,\n+                 \"format argument 'x': %d requires a real number, not str\")\n+        test_exc('%(x)x', {'x': '1'}, TypeError,\n+                 \"format argument 'x': %x requires an integer, not str\")\n+        test_exc('%(x)g', {'x': '1'}, TypeError,\n+                 \"format argument 'x': %g requires a real number, not str\")\n+        test_exc('%c', -1, OverflowError,\n+                 \"format argument: %c argument not in range(0x110000)\")\n+        test_exc('%c', (-1,), OverflowError,\n+                 \"format argument 1: %c argument not in range(0x110000)\")\n+        test_exc('%(x)c', {'x': -1}, OverflowError,\n+                 \"format argument 'x': %c argument not in range(0x110000)\")\n         test_exc('%c', sys.maxunicode+1, OverflowError,\n-                 \"%c arg not in range(0x110000)\")\n-        #test_exc('%c', 2**128, OverflowError, \"%c arg not in range(0x110000)\")\n-        test_exc('%c', 3.14, TypeError, \"%c requires an int or a unicode character, not float\")\n-        test_exc('%c', 'ab', TypeError, \"%c requires an int or a unicode character, not a string of length 2\")\n-        test_exc('%c', b'x', TypeError, \"%c requires an int or a unicode character, not bytes\")\n+                 \"format argument: %c argument not in range(0x110000)\")\n+        test_exc('%c', 2**128, OverflowError,\n+                 \"format argument: %c argument not in range(0x110000)\")\n+        test_exc('%c', 3.14, TypeError,\n+                 \"format argument: %c requires an integer or a unicode character, not float\")\n+        test_exc('%c', (3.14,), TypeError,\n+                 \"format argument 1: %c requires an integer or a unicode character, not float\")\n+        test_exc('%(x)c', {'x': 3.14}, TypeError,\n+                 \"format argument 'x': %c requires an integer or a unicode character, not float\")\n+        test_exc('%c', 'ab', TypeError,\n+                 \"format argument: %c requires an integer or a unicode character, not a string of length 2\")\n+        test_exc('%c', ('ab',), TypeError,\n+                 \"format argument 1: %c requires an integer or a unicode character, not a string of length 2\")\n+        test_exc('%(x)c', {'x': 'ab'}, TypeError,\n+                 \"format argument 'x': %c requires an integer or a unicode character, not a string of length 2\")\n+        test_exc('%c', b'x', TypeError,\n+                 \"format argument: %c requires an integer or a unicode character, not bytes\")",
      "comment": "Since we are changing error messages, I suggest to write Unicode with an uppercase U.",
      "comment_id": 2721034896,
      "user": "vstinner",
      "created_at": "2026-01-23T12:37:41Z",
      "url": "https://github.com/python/cpython/pull/142081#discussion_r2721034896"
    },
    {
      "repo": "python/cpython",
      "pr_number": 142081,
      "file_path": "Lib/test/test_str.py",
      "line": 1581,
      "side": "RIGHT",
      "diff_hunk": "@@ -1578,17 +1578,17 @@ def __int__(self):\n         self.assertEqual('%X' % letter_m, '6D')\n         self.assertEqual('%o' % letter_m, '155')\n         self.assertEqual('%c' % letter_m, 'm')\n-        self.assertRaisesRegex(TypeError, '%x format: an integer is required, not float', operator.mod, '%x', 3.14)\n-        self.assertRaisesRegex(TypeError, '%X format: an integer is required, not float', operator.mod, '%X', 2.11)\n-        self.assertRaisesRegex(TypeError, '%o format: an integer is required, not float', operator.mod, '%o', 1.79)\n-        self.assertRaisesRegex(TypeError, '%x format: an integer is required, not PseudoFloat', operator.mod, '%x', pi)\n-        self.assertRaisesRegex(TypeError, '%x format: an integer is required, not complex', operator.mod, '%x', 3j)\n-        self.assertRaisesRegex(TypeError, '%X format: an integer is required, not complex', operator.mod, '%X', 2j)\n-        self.assertRaisesRegex(TypeError, '%o format: an integer is required, not complex', operator.mod, '%o', 1j)\n-        self.assertRaisesRegex(TypeError, '%u format: a real number is required, not complex', operator.mod, '%u', 3j)\n-        self.assertRaisesRegex(TypeError, '%i format: a real number is required, not complex', operator.mod, '%i', 2j)\n-        self.assertRaisesRegex(TypeError, '%d format: a real number is required, not complex', operator.mod, '%d', 1j)\n-        self.assertRaisesRegex(TypeError, r'%c requires an int or a unicode character, not .*\\.PseudoFloat', operator.mod, '%c', pi)\n+        self.assertRaisesRegex(TypeError, '%x requires an integer, not float', operator.mod, '%x', 3.14)",
      "comment": "I would prefer to check also the `format argument: ` prefix.",
      "comment_id": 2721047234,
      "user": "vstinner",
      "created_at": "2026-01-23T12:41:48Z",
      "url": "https://github.com/python/cpython/pull/142081#discussion_r2721047234"
    },
    {
      "repo": "python/cpython",
      "pr_number": 142081,
      "file_path": "Lib/test/test_format.py",
      "line": 421,
      "side": "RIGHT",
      "diff_hunk": "@@ -272,45 +271,154 @@ def test_common_format(self):\n \n         if verbose:\n             print('Testing exceptions')\n-        test_exc_common('%', (), ValueError, \"incomplete format\")\n-        test_exc_common('% %s', 1, ValueError,\n-                        \"unsupported format character '%' (0x25) at index 2\")\n+        test_exc_common('abc %', (), ValueError, \"stray % at position 4\")\n+        test_exc_common('abc % %s', 1, ValueError,\n+                        \"stray % at position 4 or unexpected format character '%' at position 6\")\n+        test_exc_common('abc %z', 1, ValueError,\n+                        \"unsupported format %z at position 4\")\n+        test_exc_common(\"abc %Id\", 1, ValueError,\n+                        \"unsupported format %I at position 4\")\n+        test_exc_common(\"abc %'d\", 1, ValueError,\n+                        \"stray % at position 4 or unexpected format character \\\"'\\\" at position 5\")\n+        test_exc_common(\"abc %1 d\", 1, ValueError,\n+                        \"stray % at position 4 or unexpected format character ' ' at position 6\")\n+        test_exc_common('abc % (x)r', {}, ValueError,\n+                        \"stray % at position 4 or unexpected format character '(' at position 6\")\n+        test_exc_common('abc %((x)r', {}, ValueError,\n+                        \"stray % or incomplete format key at position 4\")\n+        test_exc_common('%r %r', 1, TypeError,\n+                        \"not enough arguments for format string (got 1)\")\n+        test_exc_common('%r %r', (1,), TypeError,\n+                        \"not enough arguments for format string (got 1)\")\n+        test_exc_common('%r', (), TypeError,\n+                        \"not enough arguments for format string (got 0)\")\n+        test_exc_common('abc %' + '9'*50 + 'r', 1, ValueError,\n+                        \"width too big at position 4\")\n+        test_exc_common('abc %.' + '9'*50 + 'r', 1, ValueError,\n+                        \"precision too big at position 4\")\n+        test_exc_common('%r %*r', 1, TypeError,\n+                        \"not enough arguments for format string (got 1)\")\n+        test_exc_common('%r %*r', (1,), TypeError,\n+                        \"not enough arguments for format string (got 1)\")\n+        test_exc_common('%*r', (1,), TypeError,\n+                        \"not enough arguments for format string (got 1)\")\n+        test_exc_common('%*r', (), TypeError,\n+                        \"not enough arguments for format string (got 0)\")\n+        test_exc_common('%r %.*r', 1, TypeError,\n+                        \"not enough arguments for format string (got 1)\")\n+        test_exc_common('%r %.*r', (1,), TypeError,\n+                        \"not enough arguments for format string (got 1)\")\n+        test_exc_common('%.*r', (1,), TypeError,\n+                        \"not enough arguments for format string (got 1)\")\n+        test_exc_common('%.*r', (), TypeError,\n+                        \"not enough arguments for format string (got 0)\")\n+        test_exc_common('%(x)r', 1, TypeError,\n+                        \"format requires a mapping, not int\")\n+        test_exc_common('%*r', 1, TypeError,\n+                        \"not enough arguments for format string (got 1)\")\n+        test_exc_common('%*r', 3.14, TypeError,\n+                        \"not enough arguments for format string (got 1)\")\n+        test_exc_common('%*r', (3.14, 1), TypeError,\n+                        \"format argument 1: * requires int, not float\")\n+        test_exc_common('%.*r', 1, TypeError,\n+                        \"not enough arguments for format string (got 1)\")\n+        test_exc_common('%.*r', 3.14, TypeError,\n+                        \"not enough arguments for format string (got 1)\")\n+        test_exc_common('%.*r', (3.14, 1), TypeError,\n+                        \"format argument 1: * requires int, not float\")\n+        test_exc_common('%*r', (2**1000, 1), OverflowError,\n+                        \"format argument 1: too big for width\")\n+        test_exc_common('%*r', (-2**1000, 1), OverflowError,\n+                        \"format argument 1: too big for width\")\n+        test_exc_common('%.*r', (2**1000, 1), OverflowError,\n+                        \"format argument 1: too big for precision\")\n+        test_exc_common('%.*r', (-2**1000, 1), OverflowError,\n+                        \"format argument 1: too big for precision\")\n         test_exc_common('%d', '1', TypeError,\n-                        \"%d format: a real number is required, not str\")\n+                        \"format argument: %d requires a real number, not str\")\n         test_exc_common('%d', b'1', TypeError,\n-                        \"%d format: a real number is required, not bytes\")\n+                        \"format argument: %d requires a real number, not bytes\")\n+        test_exc_common('%d', ('1',), TypeError,\n+                        \"format argument 1: %d requires a real number, not str\")\n         test_exc_common('%x', '1', TypeError,\n-                        \"%x format: an integer is required, not str\")\n+                        \"format argument: %x requires an integer, not str\")\n         test_exc_common('%x', 3.14, TypeError,\n-                        \"%x format: an integer is required, not float\")\n+                        \"format argument: %x requires an integer, not float\")\n+        test_exc_common('%x', ('1',), TypeError,\n+                        \"format argument 1: %x requires an integer, not str\")\n         test_exc_common('%i', '1', TypeError,\n-                        \"%i format: a real number is required, not str\")\n+                        \"format argument: %i requires a real number, not str\")\n         test_exc_common('%i', b'1', TypeError,\n-                        \"%i format: a real number is required, not bytes\")\n+                        \"format argument: %i requires a real number, not bytes\")\n+        test_exc_common('%g', '1', TypeError,\n+                        \"format argument: %g requires a real number, not str\")\n+        test_exc_common('%g', ('1',), TypeError,\n+                        \"format argument 1: %g requires a real number, not str\")\n \n     def test_str_format(self):\n         testformat(\"%r\", \"\\u0378\", \"'\\\\u0378'\")  # non printable\n         testformat(\"%a\", \"\\u0378\", \"'\\\\u0378'\")  # non printable\n         testformat(\"%r\", \"\\u0374\", \"'\\u0374'\")   # printable\n         testformat(\"%a\", \"\\u0374\", \"'\\\\u0374'\")  # printable\n+        testformat('%(x)r', {'x': 1}, '1')\n \n         # Test exception for unknown format characters, etc.\n         if verbose:\n             print('Testing exceptions')\n         test_exc('abc %b', 1, ValueError,\n-                 \"unsupported format character 'b' (0x62) at index 5\")\n-        #test_exc(unicode('abc %\\u3000','raw-unicode-escape'), 1, ValueError,\n-        #         \"unsupported format character '?' (0x3000) at index 5\")\n-        test_exc('%g', '1', TypeError, \"must be real number, not str\")\n+                 \"unsupported format %b at position 4\")\n+        test_exc(\"abc %\\nd\", 1, ValueError,\n+                 \"stray % at position 4 or unexpected format character U+000A at position 5\")\n+        test_exc(\"abc %\\x1fd\", 1, ValueError,\n+                 \"stray % at position 4 or unexpected format character U+001F at position 5\")\n+        test_exc(\"abc %\\x7fd\", 1, ValueError,\n+                 \"stray % at position 4 or unexpected format character U+007F at position 5\")\n+        test_exc(\"abc %\\x80d\", 1, ValueError,\n+                 \"stray % at position 4 or unexpected format character U+0080 at position 5\")\n+        test_exc('abc %\u00e4d', 1, ValueError,\n+                 \"stray % at position 4 or unexpected format character '\u00e4' (U+00E4) at position 5\")\n+        test_exc('abc %\u20acd', 1, ValueError,\n+                 \"stray % at position 4 or unexpected format character '\u20ac' (U+20AC) at position 5\")\n         test_exc('no format', '1', TypeError,\n-                 \"not all arguments converted during string formatting\")\n-        test_exc('%c', -1, OverflowError, \"%c arg not in range(0x110000)\")\n+                 \"not all arguments converted during string formatting (required 0, got 1)\")\n+        test_exc('%r', (1, 2), TypeError,\n+                 \"not all arguments converted during string formatting (required 1, got 2)\")\n+        test_exc('%(x)r %r', {'x': 1}, ValueError,\n+                 \"format requires a parenthesised mapping key at position 6\")\n+        test_exc('%(x)*r', {'x': 1}, ValueError,\n+                 \"* cannot be used with a parenthesised mapping key at position 0\")\n+        test_exc('%(x).*r', {'x': 1}, ValueError,\n+                 \"* cannot be used with a parenthesised mapping key at position 0\")\n+        test_exc('%(x)d', {'x': '1'}, TypeError,\n+                 \"format argument 'x': %d requires a real number, not str\")\n+        test_exc('%(x)x', {'x': '1'}, TypeError,\n+                 \"format argument 'x': %x requires an integer, not str\")\n+        test_exc('%(x)g', {'x': '1'}, TypeError,\n+                 \"format argument 'x': %g requires a real number, not str\")\n+        test_exc('%c', -1, OverflowError,\n+                 \"format argument: %c argument not in range(0x110000)\")\n+        test_exc('%c', (-1,), OverflowError,\n+                 \"format argument 1: %c argument not in range(0x110000)\")\n+        test_exc('%(x)c', {'x': -1}, OverflowError,\n+                 \"format argument 'x': %c argument not in range(0x110000)\")\n         test_exc('%c', sys.maxunicode+1, OverflowError,\n-                 \"%c arg not in range(0x110000)\")\n-        #test_exc('%c', 2**128, OverflowError, \"%c arg not in range(0x110000)\")\n-        test_exc('%c', 3.14, TypeError, \"%c requires an int or a unicode character, not float\")\n-        test_exc('%c', 'ab', TypeError, \"%c requires an int or a unicode character, not a string of length 2\")\n-        test_exc('%c', b'x', TypeError, \"%c requires an int or a unicode character, not bytes\")\n+                 \"format argument: %c argument not in range(0x110000)\")\n+        test_exc('%c', 2**128, OverflowError,\n+                 \"format argument: %c argument not in range(0x110000)\")\n+        test_exc('%c', 3.14, TypeError,\n+                 \"format argument: %c requires an integer or a unicode character, not float\")\n+        test_exc('%c', (3.14,), TypeError,\n+                 \"format argument 1: %c requires an integer or a unicode character, not float\")\n+        test_exc('%(x)c', {'x': 3.14}, TypeError,\n+                 \"format argument 'x': %c requires an integer or a unicode character, not float\")\n+        test_exc('%c', 'ab', TypeError,\n+                 \"format argument: %c requires an integer or a unicode character, not a string of length 2\")\n+        test_exc('%c', ('ab',), TypeError,\n+                 \"format argument 1: %c requires an integer or a unicode character, not a string of length 2\")\n+        test_exc('%(x)c', {'x': 'ab'}, TypeError,\n+                 \"format argument 'x': %c requires an integer or a unicode character, not a string of length 2\")\n+        test_exc('%c', b'x', TypeError,\n+                 \"format argument: %c requires an integer or a unicode character, not bytes\")",
      "comment": "This is a different issue. \"unicode character\" is used in other error messages which this error message was based on.",
      "comment_id": 2724013574,
      "user": "serhiy-storchaka",
      "created_at": "2026-01-24T10:19:04Z",
      "url": "https://github.com/python/cpython/pull/142081#discussion_r2724013574"
    },
    {
      "repo": "python/cpython",
      "pr_number": 142081,
      "file_path": "Lib/test/test_str.py",
      "line": 1581,
      "side": "RIGHT",
      "diff_hunk": "@@ -1578,17 +1578,17 @@ def __int__(self):\n         self.assertEqual('%X' % letter_m, '6D')\n         self.assertEqual('%o' % letter_m, '155')\n         self.assertEqual('%c' % letter_m, 'm')\n-        self.assertRaisesRegex(TypeError, '%x format: an integer is required, not float', operator.mod, '%x', 3.14)\n-        self.assertRaisesRegex(TypeError, '%X format: an integer is required, not float', operator.mod, '%X', 2.11)\n-        self.assertRaisesRegex(TypeError, '%o format: an integer is required, not float', operator.mod, '%o', 1.79)\n-        self.assertRaisesRegex(TypeError, '%x format: an integer is required, not PseudoFloat', operator.mod, '%x', pi)\n-        self.assertRaisesRegex(TypeError, '%x format: an integer is required, not complex', operator.mod, '%x', 3j)\n-        self.assertRaisesRegex(TypeError, '%X format: an integer is required, not complex', operator.mod, '%X', 2j)\n-        self.assertRaisesRegex(TypeError, '%o format: an integer is required, not complex', operator.mod, '%o', 1j)\n-        self.assertRaisesRegex(TypeError, '%u format: a real number is required, not complex', operator.mod, '%u', 3j)\n-        self.assertRaisesRegex(TypeError, '%i format: a real number is required, not complex', operator.mod, '%i', 2j)\n-        self.assertRaisesRegex(TypeError, '%d format: a real number is required, not complex', operator.mod, '%d', 1j)\n-        self.assertRaisesRegex(TypeError, r'%c requires an int or a unicode character, not .*\\.PseudoFloat', operator.mod, '%c', pi)\n+        self.assertRaisesRegex(TypeError, '%x requires an integer, not float', operator.mod, '%x', 3.14)",
      "comment": "I am not sure that it is related to the purpose of this test, but I'll do this. Although it make the lines obscenely long.",
      "comment_id": 2724027572,
      "user": "serhiy-storchaka",
      "created_at": "2026-01-24T10:39:34Z",
      "url": "https://github.com/python/cpython/pull/142081#discussion_r2724027572"
    },
    {
      "repo": "python/cpython",
      "pr_number": 144011,
      "file_path": "Lib/test/test_capi/test_opt.py",
      "line": 2914,
      "side": "LEFT",
      "diff_hunk": "@@ -2911,8 +2932,6 @@ def testfunc(n):\n         self.assertIsNotNone(ex)\n         uops = get_opnames(ex)\n         self.assertIn(\"_BINARY_OP_EXTEND\", uops)\n-        self.assertIn(\"_POP_TOP_NOP\", uops)",
      "comment": "Sorry, this was removed by accident during the merge, resolved again.",
      "comment_id": 2723472089,
      "user": "aisk",
      "created_at": "2026-01-24T02:44:36Z",
      "url": "https://github.com/python/cpython/pull/144011#discussion_r2723472089"
    },
    {
      "repo": "python/cpython",
      "pr_number": 144195,
      "file_path": "Lib/test/test_unicodedata.py",
      "line": 1087,
      "side": "RIGHT",
      "diff_hunk": "@@ -1077,25 +1082,10 @@ class MyStr(str):\n \n \n class GraphemeBreakTest(unittest.TestCase):\n-    @staticmethod\n-    def check_version(testfile):\n-        hdr = testfile.readline()\n-        return unicodedata.unidata_version in hdr\n-\n     @requires_resource('network')\n     def test_grapheme_break(self):\n-        TESTDATAFILE = \"auxiliary/GraphemeBreakTest.txt\"\n-        TESTDATAURL = f\"https://www.unicode.org/Public/{unicodedata.unidata_version}/ucd/{TESTDATAFILE}\"\n-\n-        # Hit the exception early\n-        try:\n-            testdata = open_urlresource(TESTDATAURL, encoding=\"utf-8\",\n-                                        check=self.check_version)\n-        except PermissionError:\n-            self.skipTest(f\"Permission error when downloading {TESTDATAURL} \"\n-                          f\"into the test data directory\")\n-        except (OSError, HTTPException) as exc:\n-            self.skipTest(f\"Failed to download {TESTDATAURL}: {exc}\")\n+        TESTDATAFILE = \"GraphemeBreakTest.txt\"",
      "comment": "It is not; since we only have [three files in there](https://github.com/python/pythontestdotnet/tree/master/www/unicode/17.0.0) (up from two before adding this one), the extra directory seemed unnecessary.  Easy enough to add back if you want it, though.",
      "comment_id": 2722660117,
      "user": "zware",
      "created_at": "2026-01-23T20:06:51Z",
      "url": "https://github.com/python/cpython/pull/144195#discussion_r2722660117"
    },
    {
      "repo": "python/cpython",
      "pr_number": 144028,
      "file_path": "Lib/test/test_base64.py",
      "line": 962,
      "side": "RIGHT",
      "diff_hunk": "@@ -948,6 +948,19 @@ def test_a85decode_errors(self):\n         self.assertRaises(ValueError, base64.a85decode, b'aaaay',\n                           foldspaces=True)\n \n+        self.assertEqual(base64.a85decode(b\"a b\\nc\", ignorechars=b\" \\n\"),\n+                         b'\\xc9\\x89')\n+        with self.assertRaises(ValueError):\n+            base64.a85decode(b\"a b\\nc\", ignorechars=b\"\")\n+        with self.assertRaises(ValueError):\n+            base64.a85decode(b\"a b\\nc\", ignorechars=b\" \")\n+        with self.assertRaises(ValueError):\n+            base64.a85decode(b\"a b\\nc\", ignorechars=b\"\\n\")\n+        with self.assertRaises(TypeError):\n+            base64.a85decode(b\"a b\\nc\", ignorechars=\" \\n\")\n+        with self.assertRaises(TypeError):\n+            base64.a85decode(b\"a b\\nc\", ignorechars=None)",
      "comment": "You could also add passing tests for bytearray, array.array, and memoryview here for the ignorechars argument if we want to be complete?",
      "comment_id": 2710239199,
      "user": "bitdancer",
      "created_at": "2026-01-20T22:06:24Z",
      "url": "https://github.com/python/cpython/pull/144028#discussion_r2710239199"
    },
    {
      "repo": "python/cpython",
      "pr_number": 122217,
      "file_path": "Lib/_pyrepl/reader.py",
      "line": 57,
      "side": "RIGHT",
      "diff_hunk": "@@ -52,7 +54,10 @@ def disp_str(buffer: str) -> tuple[str, list[int]]:\n     b: list[int] = []\n     s: list[str] = []\n     for c in buffer:\n-        if ord(c) < 128:\n+        if c == '\\x1a':",
      "comment": "Would it make sense to put `'\\x1a'` in a constant like `CTRL_Z`so it's obvious what it represents?",
      "comment_id": 1689534035,
      "user": "devdanzin",
      "created_at": "2024-07-24T10:26:31Z",
      "url": "https://github.com/python/cpython/pull/122217#discussion_r1689534035"
    },
    {
      "repo": "python/cpython",
      "pr_number": 123305,
      "file_path": "Lib/urllib/parse.py",
      "line": 329,
      "side": "RIGHT",
      "diff_hunk": "@@ -245,11 +275,70 @@ def _hostinfo(self):\n         return hostname, port\n \n \n-_DefragResultBase = namedtuple('_DefragResultBase', 'url fragment')\n-_SplitResultBase = namedtuple(\n-    '_SplitResultBase', 'scheme netloc path query fragment')\n-_ParseResultBase = namedtuple(\n-    '_ParseResultBase', 'scheme netloc path params query fragment')\n+_UNSPECIFIED = ['not specified']\n+_MISSING_AS_NONE_DEFAULT = False\n+\n+class _ResultBase:\n+    __slots__ = ()\n+\n+    def __replace__(self, /, **kwargs):\n+        result = super().__replace__(**kwargs)\n+        try:\n+            result._keep_empty = self._keep_empty\n+        except AttributeError:\n+            pass\n+        return result\n+\n+    def _replace(self, /, **kwargs):\n+        result = super()._replace(**kwargs)\n+        try:\n+            result._keep_empty = self._keep_empty\n+        except AttributeError:\n+            pass\n+        return result\n+\n+    def __copy__(self):\n+        return self\n+\n+    def __deepcopy__(self, memo):\n+        return self\n+\n+    def __getstate__(self):\n+        state = super().__getstate__()\n+        try:\n+            if state[1]['_keep_empty'] == _MISSING_AS_NONE_DEFAULT:\n+                del state[1]['_keep_empty']\n+                if state == (None, {}):\n+                    state = None\n+        except LookupError:\n+            pass\n+        return state\n+\n+\n+class _DefragResultBase(_ResultBase, namedtuple('_DefragResultBase', 'url fragment')):\n+    __slots__ = ('_keep_empty',)\n+\n+    def geturl(self):\n+        if self.fragment or (self.fragment is not None and\n+                             getattr(self, '_keep_empty', _MISSING_AS_NONE_DEFAULT)):\n+            return self.url + self._HASH + self.fragment\n+        else:\n+            return self.url\n+\n+class _SplitResultBase(_ResultBase, namedtuple(\n+    '_SplitResultBase', 'scheme netloc path query fragment')):",
      "comment": "Avoid visually aligning lines that are not part of the same logical block:\n```suggestion\n        '_SplitResultBase', 'scheme netloc path query fragment')):\n```",
      "comment_id": 2665554047,
      "user": "merwok",
      "created_at": "2026-01-06T16:41:52Z",
      "url": "https://github.com/python/cpython/pull/123305#discussion_r2665554047"
    },
    {
      "repo": "python/cpython",
      "pr_number": 123305,
      "file_path": "Lib/urllib/parse.py",
      "line": 336,
      "side": "RIGHT",
      "diff_hunk": "@@ -245,11 +275,70 @@ def _hostinfo(self):\n         return hostname, port\n \n \n-_DefragResultBase = namedtuple('_DefragResultBase', 'url fragment')\n-_SplitResultBase = namedtuple(\n-    '_SplitResultBase', 'scheme netloc path query fragment')\n-_ParseResultBase = namedtuple(\n-    '_ParseResultBase', 'scheme netloc path params query fragment')\n+_UNSPECIFIED = ['not specified']\n+_MISSING_AS_NONE_DEFAULT = False\n+\n+class _ResultBase:\n+    __slots__ = ()\n+\n+    def __replace__(self, /, **kwargs):\n+        result = super().__replace__(**kwargs)\n+        try:\n+            result._keep_empty = self._keep_empty\n+        except AttributeError:\n+            pass\n+        return result\n+\n+    def _replace(self, /, **kwargs):\n+        result = super()._replace(**kwargs)\n+        try:\n+            result._keep_empty = self._keep_empty\n+        except AttributeError:\n+            pass\n+        return result\n+\n+    def __copy__(self):\n+        return self\n+\n+    def __deepcopy__(self, memo):\n+        return self\n+\n+    def __getstate__(self):\n+        state = super().__getstate__()\n+        try:\n+            if state[1]['_keep_empty'] == _MISSING_AS_NONE_DEFAULT:\n+                del state[1]['_keep_empty']\n+                if state == (None, {}):\n+                    state = None\n+        except LookupError:\n+            pass\n+        return state\n+\n+\n+class _DefragResultBase(_ResultBase, namedtuple('_DefragResultBase', 'url fragment')):\n+    __slots__ = ('_keep_empty',)\n+\n+    def geturl(self):\n+        if self.fragment or (self.fragment is not None and\n+                             getattr(self, '_keep_empty', _MISSING_AS_NONE_DEFAULT)):\n+            return self.url + self._HASH + self.fragment\n+        else:\n+            return self.url\n+\n+class _SplitResultBase(_ResultBase, namedtuple(\n+    '_SplitResultBase', 'scheme netloc path query fragment')):\n+    __slots__ = ('_keep_empty',)\n+\n+    def geturl(self):\n+        return urlunsplit(self)\n+\n+class _ParseResultBase(_ResultBase, namedtuple(\n+    '_ParseResultBase', 'scheme netloc path params query fragment')):",
      "comment": "```suggestion\n        '_ParseResultBase', 'scheme netloc path params query fragment')):\n```",
      "comment_id": 2665554465,
      "user": "merwok",
      "created_at": "2026-01-06T16:41:59Z",
      "url": "https://github.com/python/cpython/pull/123305#discussion_r2665554465"
    },
    {
      "repo": "python/cpython",
      "pr_number": 123305,
      "file_path": "Lib/urllib/parse.py",
      "line": 333,
      "side": "RIGHT",
      "diff_hunk": "@@ -245,11 +275,70 @@ def _hostinfo(self):\n         return hostname, port\n \n \n-_DefragResultBase = namedtuple('_DefragResultBase', 'url fragment')\n-_SplitResultBase = namedtuple(\n-    '_SplitResultBase', 'scheme netloc path query fragment')\n-_ParseResultBase = namedtuple(\n-    '_ParseResultBase', 'scheme netloc path params query fragment')\n+_UNSPECIFIED = ['not specified']\n+_MISSING_AS_NONE_DEFAULT = False\n+\n+class _ResultBase:\n+    __slots__ = ()\n+\n+    def __replace__(self, /, **kwargs):\n+        result = super().__replace__(**kwargs)\n+        try:\n+            result._keep_empty = self._keep_empty\n+        except AttributeError:\n+            pass\n+        return result\n+\n+    def _replace(self, /, **kwargs):\n+        result = super()._replace(**kwargs)\n+        try:\n+            result._keep_empty = self._keep_empty\n+        except AttributeError:\n+            pass\n+        return result\n+\n+    def __copy__(self):\n+        return self\n+\n+    def __deepcopy__(self, memo):\n+        return self\n+\n+    def __getstate__(self):\n+        state = super().__getstate__()\n+        try:\n+            if state[1]['_keep_empty'] == _MISSING_AS_NONE_DEFAULT:\n+                del state[1]['_keep_empty']\n+                if state == (None, {}):\n+                    state = None\n+        except LookupError:\n+            pass\n+        return state\n+\n+\n+class _DefragResultBase(_ResultBase, namedtuple('_DefragResultBase', 'url fragment')):\n+    __slots__ = ('_keep_empty',)\n+\n+    def geturl(self):\n+        if self.fragment or (self.fragment is not None and\n+                             getattr(self, '_keep_empty', _MISSING_AS_NONE_DEFAULT)):\n+            return self.url + self._HASH + self.fragment\n+        else:\n+            return self.url\n+\n+class _SplitResultBase(_ResultBase, namedtuple(\n+    '_SplitResultBase', 'scheme netloc path query fragment')):\n+    __slots__ = ('_keep_empty',)\n+\n+    def geturl(self):\n+        return urlunsplit(self)",
      "comment": "`urlunsplit()` has the `keep_empty` parameter, `geturl()` does not.\n\nThis code was not changed.",
      "comment_id": 2665591979,
      "user": "serhiy-storchaka",
      "created_at": "2026-01-06T16:54:06Z",
      "url": "https://github.com/python/cpython/pull/123305#discussion_r2665591979"
    },
    {
      "repo": "python/cpython",
      "pr_number": 123305,
      "file_path": "Lib/urllib/parse.py",
      "line": 116,
      "side": "RIGHT",
      "diff_hunk": "@@ -112,21 +112,29 @@ def _encode_result(obj, encoding=_implicit_encoding,\n \n def _decode_args(args, encoding=_implicit_encoding,\n                        errors=_implicit_errors):\n-    return tuple(x.decode(encoding, errors) if x else '' for x in args)\n+    return tuple(x.decode(encoding, errors) if x else '' if x is not None else x\n+                 for x in args)",
      "comment": "```suggestion\r\n    return tuple(x.decode(encoding, errors) if x else ('' if x is not None else x)\r\n                 for x in args)\r\n```",
      "comment_id": 2710642359,
      "user": "orsenthil",
      "created_at": "2026-01-21T01:34:56Z",
      "url": "https://github.com/python/cpython/pull/123305#discussion_r2710642359"
    },
    {
      "repo": "python/cpython",
      "pr_number": 123305,
      "file_path": "Lib/urllib/parse.py",
      "line": 116,
      "side": "RIGHT",
      "diff_hunk": "@@ -112,21 +112,29 @@ def _encode_result(obj, encoding=_implicit_encoding,\n \n def _decode_args(args, encoding=_implicit_encoding,\n                        errors=_implicit_errors):\n-    return tuple(x.decode(encoding, errors) if x else '' for x in args)\n+    return tuple(x.decode(encoding, errors) if x else '' if x is not None else x\n+                 for x in args)",
      "comment": "I understand your confusion, but chained ternary operator is idiomatic code in C and Python and does not need parentheses (unlike to PHP).\n\nMaybe splitting it on several line will help readability?\n",
      "comment_id": 2711312791,
      "user": "serhiy-storchaka",
      "created_at": "2026-01-21T07:32:32Z",
      "url": "https://github.com/python/cpython/pull/123305#discussion_r2711312791"
    },
    {
      "repo": "python/cpython",
      "pr_number": 123305,
      "file_path": "Lib/urllib/parse.py",
      "line": 116,
      "side": "RIGHT",
      "diff_hunk": "@@ -112,21 +112,29 @@ def _encode_result(obj, encoding=_implicit_encoding,\n \n def _decode_args(args, encoding=_implicit_encoding,\n                        errors=_implicit_errors):\n-    return tuple(x.decode(encoding, errors) if x else '' for x in args)\n+    return tuple(x.decode(encoding, errors) if x else '' if x is not None else x\n+                 for x in args)",
      "comment": "That's fine. I suggested it merely for better readability. Keeping it same is fine! Once I parsed it in my mind properly, I read it again totally fine. ",
      "comment_id": 2713921113,
      "user": "orsenthil",
      "created_at": "2026-01-21T18:54:07Z",
      "url": "https://github.com/python/cpython/pull/123305#discussion_r2713921113"
    },
    {
      "repo": "python/cpython",
      "pr_number": 144003,
      "file_path": "Lib/test/test_sys.py",
      "line": 1568,
      "side": "RIGHT",
      "diff_hunk": "@@ -1566,6 +1565,8 @@ def test_default(self):\n         self.assertEqual(sys.getsizeof(True, -1), size('') + self.longdigit)\n \n     def test_objecttypes(self):\n+        import _datetime",
      "comment": "I suggest to import it just before it is used, like collections.\n\nAnd since it is optional, skip the corresponding test if the import fails.",
      "comment_id": 2707633336,
      "user": "serhiy-storchaka",
      "created_at": "2026-01-20T10:02:55Z",
      "url": "https://github.com/python/cpython/pull/144003#discussion_r2707633336"
    },
    {
      "repo": "python/cpython",
      "pr_number": 144003,
      "file_path": "Lib/test/test_sys.py",
      "line": 1568,
      "side": "RIGHT",
      "diff_hunk": "@@ -1566,6 +1565,8 @@ def test_default(self):\n         self.assertEqual(sys.getsizeof(True, -1), size('') + self.longdigit)\n \n     def test_objecttypes(self):\n+        import _datetime",
      "comment": "> And since it is optional, skip the corresponding test if the import fails.\r\n\r\n`_datetime` is now a built-in module, it's not really optional.",
      "comment_id": 2712794851,
      "user": "vstinner",
      "created_at": "2026-01-21T14:21:18Z",
      "url": "https://github.com/python/cpython/pull/144003#discussion_r2712794851"
    },
    {
      "repo": "python/cpython",
      "pr_number": 144003,
      "file_path": "Lib/test/test_sys.py",
      "line": 1568,
      "side": "RIGHT",
      "diff_hunk": "@@ -1566,6 +1565,8 @@ def test_default(self):\n         self.assertEqual(sys.getsizeof(True, -1), size('') + self.longdigit)\n \n     def test_objecttypes(self):\n+        import _datetime",
      "comment": "Isn't it just an implementation detail? It was made builtin to solve a particular technical issue which can be solved in other way.",
      "comment_id": 2712887507,
      "user": "serhiy-storchaka",
      "created_at": "2026-01-21T14:42:56Z",
      "url": "https://github.com/python/cpython/pull/144003#discussion_r2712887507"
    },
    {
      "repo": "python/cpython",
      "pr_number": 144003,
      "file_path": "Lib/test/test_sys.py",
      "line": 1745,
      "side": "RIGHT",
      "diff_hunk": "@@ -1742,6 +1741,7 @@ def delx(self): del self.__x\n             x = property(getx, setx, delx, \"\")\n             check(x, size('5Pi'))\n         # PyCapsule\n+        import _datetime\n         check(_datetime.datetime_CAPI, size('6P'))",
      "comment": "As @serhiy-storchaka requested, this line should only be run if _datetime is available. Something like:\n\n```py\ntry:\n    import _datetime\nexcept ImportError:\n    pass\nelse:\n    check(_datetime.datetime_CAPI, size('6P'))\n```",
      "comment_id": 2712973831,
      "user": "vstinner",
      "created_at": "2026-01-21T15:03:10Z",
      "url": "https://github.com/python/cpython/pull/144003#discussion_r2712973831"
    },
    {
      "repo": "python/cpython",
      "pr_number": 143895,
      "file_path": "Lib/test/test_capi/test_opt.py",
      "line": 3576,
      "side": "RIGHT",
      "diff_hunk": "@@ -3534,6 +3534,46 @@ def test_is_none(n):\n         self.assertIn(\"_POP_TOP_NOP\", uops)\n         self.assertLessEqual(count_ops(ex, \"_POP_TOP\"), 2)\n \n+    def test_is_true_narrows_to_constant(self):\n+        def f(n):\n+            def return_true():\n+                return True\n+\n+            hits = 0\n+            v = return_true()\n+            for i in range(n):\n+                if v is True:\n+                    hits += v + 1\n+            return hits\n+\n+        res, ex = self._run_with_optimizer(f, TIER2_THRESHOLD)\n+        self.assertEqual(res, TIER2_THRESHOLD * 2)\n+        self.assertIsNotNone(ex)\n+        uops = get_opnames(ex)\n+\n+        # v + 1 should be constant folded\n+        self.assertNotIn(\"_BINARY_OP\", uops)\n+\n+    def test_is_false_narrows_to_constant(self):\n+        def f(n):\n+            def return_false():\n+                return False\n+\n+            hits = 0\n+            v = return_false()\n+            for i in range(n):\n+                if v is False:\n+                    hits += v + 1\n+            return hits\n+\n+        res, ex = self._run_with_optimizer(f, TIER2_THRESHOLD)\n+        self.assertEqual(res, TIER2_THRESHOLD)\n+        self.assertIsNotNone(ex)\n+        uops = get_opnames(ex)\n+\n+        # v + 1 should be constant folded\n+        self.assertNotIn(\"_BINARY_OP\", uops)\n+",
      "comment": "Please add a testing a normal constant too, e.g. `a is 1`",
      "comment_id": 2701578938,
      "user": "Fidget-Spinner",
      "created_at": "2026-01-17T21:09:24Z",
      "url": "https://github.com/python/cpython/pull/143895#discussion_r2701578938"
    },
    {
      "repo": "python/cpython",
      "pr_number": 143895,
      "file_path": "Lib/test/test_capi/test_opt.py",
      "line": 3576,
      "side": "RIGHT",
      "diff_hunk": "@@ -3534,6 +3534,46 @@ def test_is_none(n):\n         self.assertIn(\"_POP_TOP_NOP\", uops)\n         self.assertLessEqual(count_ops(ex, \"_POP_TOP\"), 2)\n \n+    def test_is_true_narrows_to_constant(self):\n+        def f(n):\n+            def return_true():\n+                return True\n+\n+            hits = 0\n+            v = return_true()\n+            for i in range(n):\n+                if v is True:\n+                    hits += v + 1\n+            return hits\n+\n+        res, ex = self._run_with_optimizer(f, TIER2_THRESHOLD)\n+        self.assertEqual(res, TIER2_THRESHOLD * 2)\n+        self.assertIsNotNone(ex)\n+        uops = get_opnames(ex)\n+\n+        # v + 1 should be constant folded\n+        self.assertNotIn(\"_BINARY_OP\", uops)\n+\n+    def test_is_false_narrows_to_constant(self):\n+        def f(n):\n+            def return_false():\n+                return False\n+\n+            hits = 0\n+            v = return_false()\n+            for i in range(n):\n+                if v is False:\n+                    hits += v + 1\n+            return hits\n+\n+        res, ex = self._run_with_optimizer(f, TIER2_THRESHOLD)\n+        self.assertEqual(res, TIER2_THRESHOLD)\n+        self.assertIsNotNone(ex)\n+        uops = get_opnames(ex)\n+\n+        # v + 1 should be constant folded\n+        self.assertNotIn(\"_BINARY_OP\", uops)\n+",
      "comment": "@reidenong thanks for adding a test at the C level! I think we still need a test here in Python.",
      "comment_id": 2702530920,
      "user": "Fidget-Spinner",
      "created_at": "2026-01-18T16:05:24Z",
      "url": "https://github.com/python/cpython/pull/143895#discussion_r2702530920"
    },
    {
      "repo": "python/cpython",
      "pr_number": 143942,
      "file_path": "Tools/wasm/wasi/__main__.py",
      "line": 14,
      "side": "RIGHT",
      "diff_hunk": "@@ -1,554 +1,14 @@\n-#!/usr/bin/env python3\n-\n-import argparse\n-import contextlib\n-import functools\n-import os\n-\n-import tomllib\n-\n-try:\n-    from os import process_cpu_count as cpu_count\n-except ImportError:\n-    from os import cpu_count\n-import pathlib\n-import shutil\n-import subprocess\n-import sys\n-import sysconfig\n-import tempfile\n-\n-HERE = pathlib.Path(__file__).parent\n-\n-# Path is: cpython/Tools/wasm/wasi\n-CHECKOUT = HERE.parent.parent.parent\n-assert (CHECKOUT / \"configure\").is_file(), (\n-    \"Please update the location of the file\"\n-)\n-\n-CROSS_BUILD_DIR = CHECKOUT / \"cross-build\"\n-# Build platform can also be found via `config.guess`.\n-BUILD_DIR = CROSS_BUILD_DIR / sysconfig.get_config_var(\"BUILD_GNU_TYPE\")\n-\n-LOCAL_SETUP = CHECKOUT / \"Modules\" / \"Setup.local\"\n-LOCAL_SETUP_MARKER = (\n-    b\"# Generated by Tools/wasm/wasi .\\n\"\n-    b\"# Required to statically build extension modules.\"\n-)\n-\n-WASI_SDK_VERSION = 29\n-\n-WASMTIME_VAR_NAME = \"WASMTIME\"\n-WASMTIME_HOST_RUNNER_VAR = f\"{{{WASMTIME_VAR_NAME}}}\"\n-\n-\n-def separator():\n-    \"\"\"Print a separator line across the terminal width.\"\"\"\n-    try:\n-        tput_output = subprocess.check_output(\n-            [\"tput\", \"cols\"], encoding=\"utf-8\"\n-        )\n-    except subprocess.CalledProcessError:\n-        terminal_width = 80\n-    else:\n-        terminal_width = int(tput_output.strip())\n-    print(\"\u23af\" * terminal_width)\n-\n-\n-def log(emoji, message, *, spacing=None):\n-    \"\"\"Print a notification with an emoji.\n-\n-    If 'spacing' is None, calculate the spacing based on the number of code points\n-    in the emoji as terminals \"eat\" a space when the emoji has multiple code points.\n-    \"\"\"\n-    if spacing is None:\n-        spacing = \" \" if len(emoji) == 1 else \"  \"\n-    print(\"\".join([emoji, spacing, message]))\n-\n-\n-def updated_env(updates={}):\n-    \"\"\"Create a new dict representing the environment to use.\n-\n-    The changes made to the execution environment are printed out.\n-    \"\"\"\n-    env_defaults = {}\n-    # https://reproducible-builds.org/docs/source-date-epoch/\n-    git_epoch_cmd = [\"git\", \"log\", \"-1\", \"--pretty=%ct\"]\n-    try:\n-        epoch = subprocess.check_output(\n-            git_epoch_cmd, encoding=\"utf-8\"\n-        ).strip()\n-        env_defaults[\"SOURCE_DATE_EPOCH\"] = epoch\n-    except subprocess.CalledProcessError:\n-        pass  # Might be building from a tarball.\n-    # This layering lets SOURCE_DATE_EPOCH from os.environ takes precedence.\n-    environment = env_defaults | os.environ | updates\n-\n-    env_diff = {}\n-    for key, value in environment.items():\n-        if os.environ.get(key) != value:\n-            env_diff[key] = value\n-\n-    env_vars = (\n-        f\"\\n     {key}={item}\" for key, item in sorted(env_diff.items())\n-    )\n-    log(\"\ud83c\udf0e\", f\"Environment changes:{''.join(env_vars)}\")\n-\n-    return environment\n-\n-\n-def subdir(working_dir, *, clean_ok=False):\n-    \"\"\"Decorator to change to a working directory.\"\"\"\n-\n-    def decorator(func):\n-        @functools.wraps(func)\n-        def wrapper(context):\n-            nonlocal working_dir\n-\n-            if callable(working_dir):\n-                working_dir = working_dir(context)\n-            separator()\n-            log(\"\ud83d\udcc1\", os.fsdecode(working_dir))\n-            if (\n-                clean_ok\n-                and getattr(context, \"clean\", False)\n-                and working_dir.exists()\n-            ):\n-                log(\"\ud83d\udeae\", \"Deleting directory (--clean)...\")\n-                shutil.rmtree(working_dir)\n-\n-            working_dir.mkdir(parents=True, exist_ok=True)\n-\n-            with contextlib.chdir(working_dir):\n-                return func(context, working_dir)\n-\n-        return wrapper\n-\n-    return decorator\n-\n-\n-def call(command, *, context=None, quiet=False, logdir=None, **kwargs):\n-    \"\"\"Execute a command.\n-\n-    If 'quiet' is true, then redirect stdout and stderr to a temporary file.\n-    \"\"\"\n-    if context is not None:\n-        quiet = context.quiet\n-        logdir = context.logdir\n-    elif quiet and logdir is None:\n-        raise ValueError(\"When quiet is True, logdir must be specified\")\n-\n-    log(\"\u276f\", \" \".join(map(str, command)), spacing=\"  \")\n-    if not quiet:\n-        stdout = None\n-        stderr = None\n-    else:\n-        stdout = tempfile.NamedTemporaryFile(\n-            \"w\",\n-            encoding=\"utf-8\",\n-            delete=False,\n-            dir=logdir,\n-            prefix=\"cpython-wasi-\",\n-            suffix=\".log\",\n-        )\n-        stderr = subprocess.STDOUT\n-        log(\"\ud83d\udcdd\", f\"Logging output to {stdout.name} (--quiet)...\")\n-\n-    subprocess.check_call(command, **kwargs, stdout=stdout, stderr=stderr)\n-\n-\n-def build_python_path():\n-    \"\"\"The path to the build Python binary.\"\"\"\n-    binary = BUILD_DIR / \"python\"\n-    if not binary.is_file():\n-        binary = binary.with_suffix(\".exe\")\n-        if not binary.is_file():\n-            raise FileNotFoundError(\n-                f\"Unable to find `python(.exe)` in {BUILD_DIR}\"\n-            )\n-\n-    return binary\n-\n-\n-def build_python_is_pydebug():\n-    \"\"\"Find out if the build Python is a pydebug build.\"\"\"\n-    test = \"import sys, test.support; sys.exit(test.support.Py_DEBUG)\"\n-    result = subprocess.run(\n-        [build_python_path(), \"-c\", test],\n-        capture_output=True,\n-    )\n-    return bool(result.returncode)\n-\n-\n-@subdir(BUILD_DIR, clean_ok=True)\n-def configure_build_python(context, working_dir):\n-    \"\"\"Configure the build/host Python.\"\"\"\n-    if LOCAL_SETUP.exists():\n-        if LOCAL_SETUP.read_bytes() == LOCAL_SETUP_MARKER:\n-            log(\"\ud83d\udc4d\", f\"{LOCAL_SETUP} exists ...\")\n-        else:\n-            log(\"\u26a0\ufe0f\", f\"{LOCAL_SETUP} exists, but has unexpected contents\")\n-    else:\n-        log(\"\ud83d\udcdd\", f\"Creating {LOCAL_SETUP} ...\")\n-        LOCAL_SETUP.write_bytes(LOCAL_SETUP_MARKER)\n-\n-    configure = [os.path.relpath(CHECKOUT / \"configure\", working_dir)]\n-    if context.args:\n-        configure.extend(context.args)\n-\n-    call(configure, context=context)\n-\n-\n-@subdir(BUILD_DIR)\n-def make_build_python(context, working_dir):\n-    \"\"\"Make/build the build Python.\"\"\"\n-    call([\"make\", \"--jobs\", str(cpu_count()), \"all\"], context=context)\n-\n-    binary = build_python_path()\n-    cmd = [\n-        binary,\n-        \"-c\",\n-        \"import sys; \"\n-        \"print(f'{sys.version_info.major}.{sys.version_info.minor}')\",\n-    ]\n-    version = subprocess.check_output(cmd, encoding=\"utf-8\").strip()\n-\n-    log(\"\ud83c\udf89\", f\"{binary} {version}\")\n-\n-\n-def find_wasi_sdk(config):\n-    \"\"\"Find the path to the WASI SDK.\"\"\"\n-    wasi_sdk_path = None\n-    wasi_sdk_version = config[\"targets\"][\"wasi-sdk\"]\n-\n-    if wasi_sdk_path_env_var := os.environ.get(\"WASI_SDK_PATH\"):\n-        wasi_sdk_path = pathlib.Path(wasi_sdk_path_env_var)\n-    else:\n-        opt_path = pathlib.Path(\"/opt\")\n-        # WASI SDK versions have a ``.0`` suffix, but it's a constant; the WASI SDK team\n-        # has said they don't plan to ever do a point release and all of their Git tags\n-        # lack the ``.0`` suffix.\n-        # Starting with WASI SDK 23, the tarballs went from containing a directory named\n-        # ``wasi-sdk-{WASI_SDK_VERSION}.0`` to e.g.\n-        # ``wasi-sdk-{WASI_SDK_VERSION}.0-x86_64-linux``.\n-        potential_sdks = [\n-            path\n-            for path in opt_path.glob(f\"wasi-sdk-{wasi_sdk_version}.0*\")\n-            if path.is_dir()\n-        ]\n-        if len(potential_sdks) == 1:\n-            wasi_sdk_path = potential_sdks[0]\n-        elif (default_path := opt_path / \"wasi-sdk\").is_dir():\n-            wasi_sdk_path = default_path\n-\n-    # Starting with WASI SDK 25, a VERSION file is included in the root\n-    # of the SDK directory that we can read to warn folks when they are using\n-    # an unsupported version.\n-    if wasi_sdk_path and (version_file := wasi_sdk_path / \"VERSION\").is_file():\n-        version_details = version_file.read_text(encoding=\"utf-8\")\n-        found_version = version_details.splitlines()[0]\n-        # Make sure there's a trailing dot to avoid false positives if somehow the\n-        # supported version is a prefix of the found version (e.g. `25` and `2567`).\n-        if not found_version.startswith(f\"{wasi_sdk_version}.\"):\n-            major_version = found_version.partition(\".\")[0]\n-            log(\n-                \"\u26a0\ufe0f\",\n-                f\" Found WASI SDK {major_version}, \"\n-                f\"but WASI SDK {wasi_sdk_version} is the supported version\",\n-            )\n-\n-    return wasi_sdk_path\n-\n-\n-def wasi_sdk_env(context):\n-    \"\"\"Calculate environment variables for building with wasi-sdk.\"\"\"\n-    wasi_sdk_path = context.wasi_sdk_path\n-    sysroot = wasi_sdk_path / \"share\" / \"wasi-sysroot\"\n-    env = {\n-        \"CC\": \"clang\",\n-        \"CPP\": \"clang-cpp\",\n-        \"CXX\": \"clang++\",\n-        \"AR\": \"llvm-ar\",\n-        \"RANLIB\": \"ranlib\",\n-    }\n-\n-    for env_var, binary_name in list(env.items()):\n-        env[env_var] = os.fsdecode(wasi_sdk_path / \"bin\" / binary_name)\n-\n-    if not wasi_sdk_path.name.startswith(\"wasi-sdk\"):\n-        for compiler in [\"CC\", \"CPP\", \"CXX\"]:\n-            env[compiler] += f\" --sysroot={sysroot}\"\n-\n-    env[\"PKG_CONFIG_PATH\"] = \"\"\n-    env[\"PKG_CONFIG_LIBDIR\"] = os.pathsep.join(\n-        map(\n-            os.fsdecode,\n-            [sysroot / \"lib\" / \"pkgconfig\", sysroot / \"share\" / \"pkgconfig\"],\n-        )\n-    )\n-    env[\"PKG_CONFIG_SYSROOT_DIR\"] = os.fsdecode(sysroot)\n-\n-    env[\"WASI_SDK_PATH\"] = os.fsdecode(wasi_sdk_path)\n-    env[\"WASI_SYSROOT\"] = os.fsdecode(sysroot)\n-\n-    env[\"PATH\"] = os.pathsep.join([\n-        os.fsdecode(wasi_sdk_path / \"bin\"),\n-        os.environ[\"PATH\"],\n-    ])\n-\n-    return env\n-\n-\n-@subdir(lambda context: CROSS_BUILD_DIR / context.host_triple, clean_ok=True)\n-def configure_wasi_python(context, working_dir):\n-    \"\"\"Configure the WASI/host build.\"\"\"\n-    if not context.wasi_sdk_path or not context.wasi_sdk_path.exists():\n-        raise ValueError(\n-            \"WASI-SDK not found; \"\n-            \"download from \"\n-            \"https://github.com/WebAssembly/wasi-sdk and/or \"\n-            \"specify via $WASI_SDK_PATH or --wasi-sdk\"\n-        )\n-\n-    config_site = os.fsdecode(HERE / \"config.site-wasm32-wasi\")\n-\n-    wasi_build_dir = working_dir.relative_to(CHECKOUT)\n-\n-    python_build_dir = BUILD_DIR / \"build\"\n-    lib_dirs = list(python_build_dir.glob(\"lib.*\"))\n-    assert len(lib_dirs) == 1, (\n-        f\"Expected a single lib.* directory in {python_build_dir}\"\n-    )\n-    lib_dir = os.fsdecode(lib_dirs[0])\n-    python_version = lib_dir.rpartition(\"-\")[-1]\n-    sysconfig_data_dir = (\n-        f\"{wasi_build_dir}/build/lib.wasi-wasm32-{python_version}\"\n-    )\n-\n-    # Use PYTHONPATH to include sysconfig data which must be anchored to the\n-    # WASI guest's `/` directory.\n-    args = {\n-        \"PYTHONPATH\": f\"/{sysconfig_data_dir}\",\n-        \"PYTHON_WASM\": working_dir / \"python.wasm\",\n-    }\n-    # Check dynamically for wasmtime in case it was specified manually via\n-    # `--host-runner`.\n-    if WASMTIME_HOST_RUNNER_VAR in context.host_runner:\n-        if wasmtime := shutil.which(\"wasmtime\"):\n-            args[WASMTIME_VAR_NAME] = wasmtime\n-        else:\n-            raise FileNotFoundError(\n-                \"wasmtime not found; download from \"\n-                \"https://github.com/bytecodealliance/wasmtime\"\n-            )\n-    host_runner = context.host_runner.format_map(args)\n-    env_additions = {\"CONFIG_SITE\": config_site, \"HOSTRUNNER\": host_runner}\n-    build_python = os.fsdecode(build_python_path())\n-    # The path to `configure` MUST be relative, else `python.wasm` is unable\n-    # to find the stdlib due to Python not recognizing that it's being\n-    # executed from within a checkout.\n-    configure = [\n-        os.path.relpath(CHECKOUT / \"configure\", working_dir),\n-        f\"--host={context.host_triple}\",\n-        f\"--build={BUILD_DIR.name}\",\n-        f\"--with-build-python={build_python}\",\n-    ]\n-    if build_python_is_pydebug():\n-        configure.append(\"--with-pydebug\")\n-    if context.args:\n-        configure.extend(context.args)\n-    call(\n-        configure,\n-        env=updated_env(env_additions | wasi_sdk_env(context)),\n-        context=context,\n-    )\n-\n-    python_wasm = working_dir / \"python.wasm\"\n-    exec_script = working_dir / \"python.sh\"\n-    with exec_script.open(\"w\", encoding=\"utf-8\") as file:\n-        file.write(f'#!/bin/sh\\nexec {host_runner} {python_wasm} \"$@\"\\n')\n-    exec_script.chmod(0o755)\n-    log(\"\ud83c\udfc3\", f\"Created {exec_script} (--host-runner)... \")\n-    sys.stdout.flush()\n-\n-\n-@subdir(lambda context: CROSS_BUILD_DIR / context.host_triple)\n-def make_wasi_python(context, working_dir):\n-    \"\"\"Run `make` for the WASI/host build.\"\"\"\n-    call(\n-        [\"make\", \"--jobs\", str(cpu_count()), \"all\"],\n-        env=updated_env(),\n-        context=context,\n-    )\n-\n-    exec_script = working_dir / \"python.sh\"\n-    call([exec_script, \"--version\"], quiet=False)\n-    log(\n-        \"\ud83c\udf89\",\n-        f\"Use `{exec_script.relative_to(context.init_dir)}` \"\n-        \"to run CPython w/ the WASI host specified by --host-runner\",\n-    )\n-\n-\n-def clean_contents(context):\n-    \"\"\"Delete all files created by this script.\"\"\"\n-    if CROSS_BUILD_DIR.exists():\n-        log(\"\ud83e\uddf9\", f\"Deleting {CROSS_BUILD_DIR} ...\")\n-        shutil.rmtree(CROSS_BUILD_DIR)\n-\n-    if LOCAL_SETUP.exists():\n-        if LOCAL_SETUP.read_bytes() == LOCAL_SETUP_MARKER:\n-            log(\"\ud83e\uddf9\", f\"Deleting generated {LOCAL_SETUP} ...\")\n-\n-\n-def build_steps(*steps):\n-    \"\"\"Construct a command from other steps.\"\"\"\n-\n-    def builder(context):\n-        for step in steps:\n-            step(context)\n-\n-    return builder\n-\n-\n-def main():\n-    with (HERE / \"config.toml\").open(\"rb\") as file:\n-        config = tomllib.load(file)\n-    default_wasi_sdk = find_wasi_sdk(config)\n-    default_host_triple = config[\"targets\"][\"host-triple\"]\n-    default_host_runner = (\n-        f\"{WASMTIME_HOST_RUNNER_VAR} run \"\n-        # For setting PYTHONPATH to the sysconfig data directory.\n-        \"--env PYTHONPATH={PYTHONPATH} \"\n-        # Map the checkout to / to load the stdlib from /Lib.\n-        f\"--dir {os.fsdecode(CHECKOUT)}::/ \"\n-        # Flags involving --optimize, --codegen, --debug, --wasm, and --wasi can be kept\n-        # in a config file.\n-        # We are using such a file to act as defaults in case a user wants to override\n-        # only some of the settings themselves, make it easy to modify settings\n-        # post-build so that they immediately apply to the Makefile instead of having to\n-        # regenerate it, and allow for easy copying of the settings for anyone else who\n-        # may want to use them.\n-        f\"--config {os.fsdecode(HERE / 'wasmtime.toml')}\"\n-    )\n-    default_logdir = pathlib.Path(tempfile.gettempdir())\n+if __name__ == \"__main__\":\n+    import pathlib\n+    import runpy\n+    import sys\n \n-    parser = argparse.ArgumentParser()\n-    subcommands = parser.add_subparsers(dest=\"subcommand\")\n-    build = subcommands.add_parser(\"build\", help=\"Build everything\")\n-    configure_build = subcommands.add_parser(\n-        \"configure-build-python\", help=\"Run `configure` for the build Python\"\n-    )\n-    make_build = subcommands.add_parser(\n-        \"make-build-python\", help=\"Run `make` for the build Python\"\n-    )\n-    build_python = subcommands.add_parser(\n-        \"build-python\", help=\"Build the build Python\"\n-    )\n-    configure_host = subcommands.add_parser(\n-        \"configure-host\",\n-        help=\"Run `configure` for the \"\n-        \"host/WASI (pydebug builds \"\n-        \"are inferred from the build \"\n-        \"Python)\",\n-    )\n-    make_host = subcommands.add_parser(\n-        \"make-host\", help=\"Run `make` for the host/WASI\"\n+    print(\n+        \"\u26a0\ufe0f WARNING: This script is deprecated and slated for removal in Python 3.20; \"\n+        \"execute the `Platforms/WASI/` directory instead (i.e. `python Platforms/WASI`)\\n\",\n+        file=sys.stderr,\n     )\n-    build_host = subcommands.add_parser(\n-        \"build-host\", help=\"Build the host/WASI Python\"\n-    )\n-    subcommands.add_parser(\n-        \"clean\", help=\"Delete files and directories created by this script\"\n-    )\n-    for subcommand in (\n-        build,\n-        configure_build,\n-        make_build,\n-        build_python,\n-        configure_host,\n-        make_host,\n-        build_host,\n-    ):\n-        subcommand.add_argument(\n-            \"--quiet\",\n-            action=\"store_true\",\n-            default=False,\n-            dest=\"quiet\",\n-            help=\"Redirect output from subprocesses to a log file\",\n-        )\n-        subcommand.add_argument(\n-            \"--logdir\",\n-            type=pathlib.Path,\n-            default=default_logdir,\n-            help=f\"Directory to store log files; defaults to {default_logdir}\",\n-        )\n-    for subcommand in (\n-        configure_build,\n-        configure_host,\n-        build_python,\n-        build_host,\n-    ):\n-        subcommand.add_argument(\n-            \"--clean\",\n-            action=\"store_true\",\n-            default=False,\n-            dest=\"clean\",\n-            help=\"Delete any relevant directories before building\",\n-        )\n-    for subcommand in (\n-        build,\n-        configure_build,\n-        configure_host,\n-        build_python,\n-        build_host,\n-    ):\n-        subcommand.add_argument(\n-            \"args\", nargs=\"*\", help=\"Extra arguments to pass to `configure`\"\n-        )\n-    for subcommand in build, configure_host, build_host:\n-        subcommand.add_argument(\n-            \"--wasi-sdk\",\n-            type=pathlib.Path,\n-            dest=\"wasi_sdk_path\",\n-            default=default_wasi_sdk,\n-            help=f\"Path to the WASI SDK; defaults to {default_wasi_sdk}\",\n-        )\n-        subcommand.add_argument(\n-            \"--host-runner\",\n-            action=\"store\",\n-            default=default_host_runner,\n-            dest=\"host_runner\",\n-            help=\"Command template for running the WASI host; defaults to \"\n-            f\"`{default_host_runner}`\",\n-        )\n-    for subcommand in build, configure_host, make_host, build_host:\n-        subcommand.add_argument(\n-            \"--host-triple\",\n-            action=\"store\",\n-            default=default_host_triple,\n-            help=\"The target triple for the WASI host build; \"\n-            f\"defaults to {default_host_triple}\",\n-        )\n-\n-    context = parser.parse_args()\n-    context.init_dir = pathlib.Path().absolute()\n \n-    build_build_python = build_steps(configure_build_python, make_build_python)\n-    build_wasi_python = build_steps(configure_wasi_python, make_wasi_python)\n+    checkout = pathlib.Path(__file__).parent.parent.parent.parent\n \n-    dispatch = {\n-        \"configure-build-python\": configure_build_python,\n-        \"make-build-python\": make_build_python,\n-        \"build-python\": build_build_python,\n-        \"configure-host\": configure_wasi_python,\n-        \"make-host\": make_wasi_python,\n-        \"build-host\": build_wasi_python,\n-        \"build\": build_steps(build_build_python, build_wasi_python),\n-        \"clean\": clean_contents,\n-    }\n-    dispatch[context.subcommand](context)\n-\n-\n-if __name__ == \"__main__\":\n-    main()\n+    runpy.run_path(checkout / \"Platforms\" / \"WASI\", run_name=\"__main__\")",
      "comment": "For nicer history, it might be better to just do the full rename in this PR and follow it up with adding the new redirect here.\n\nI'll suppress my rant about only allowing squash merges :)",
      "comment_id": 2700263437,
      "user": "zware",
      "created_at": "2026-01-16T22:55:42Z",
      "url": "https://github.com/python/cpython/pull/143942#discussion_r2700263437"
    },
    {
      "repo": "python/cpython",
      "pr_number": 143942,
      "file_path": "Tools/wasm/wasi/__main__.py",
      "line": 14,
      "side": "RIGHT",
      "diff_hunk": "@@ -1,554 +1,14 @@\n-#!/usr/bin/env python3\n-\n-import argparse\n-import contextlib\n-import functools\n-import os\n-\n-import tomllib\n-\n-try:\n-    from os import process_cpu_count as cpu_count\n-except ImportError:\n-    from os import cpu_count\n-import pathlib\n-import shutil\n-import subprocess\n-import sys\n-import sysconfig\n-import tempfile\n-\n-HERE = pathlib.Path(__file__).parent\n-\n-# Path is: cpython/Tools/wasm/wasi\n-CHECKOUT = HERE.parent.parent.parent\n-assert (CHECKOUT / \"configure\").is_file(), (\n-    \"Please update the location of the file\"\n-)\n-\n-CROSS_BUILD_DIR = CHECKOUT / \"cross-build\"\n-# Build platform can also be found via `config.guess`.\n-BUILD_DIR = CROSS_BUILD_DIR / sysconfig.get_config_var(\"BUILD_GNU_TYPE\")\n-\n-LOCAL_SETUP = CHECKOUT / \"Modules\" / \"Setup.local\"\n-LOCAL_SETUP_MARKER = (\n-    b\"# Generated by Tools/wasm/wasi .\\n\"\n-    b\"# Required to statically build extension modules.\"\n-)\n-\n-WASI_SDK_VERSION = 29\n-\n-WASMTIME_VAR_NAME = \"WASMTIME\"\n-WASMTIME_HOST_RUNNER_VAR = f\"{{{WASMTIME_VAR_NAME}}}\"\n-\n-\n-def separator():\n-    \"\"\"Print a separator line across the terminal width.\"\"\"\n-    try:\n-        tput_output = subprocess.check_output(\n-            [\"tput\", \"cols\"], encoding=\"utf-8\"\n-        )\n-    except subprocess.CalledProcessError:\n-        terminal_width = 80\n-    else:\n-        terminal_width = int(tput_output.strip())\n-    print(\"\u23af\" * terminal_width)\n-\n-\n-def log(emoji, message, *, spacing=None):\n-    \"\"\"Print a notification with an emoji.\n-\n-    If 'spacing' is None, calculate the spacing based on the number of code points\n-    in the emoji as terminals \"eat\" a space when the emoji has multiple code points.\n-    \"\"\"\n-    if spacing is None:\n-        spacing = \" \" if len(emoji) == 1 else \"  \"\n-    print(\"\".join([emoji, spacing, message]))\n-\n-\n-def updated_env(updates={}):\n-    \"\"\"Create a new dict representing the environment to use.\n-\n-    The changes made to the execution environment are printed out.\n-    \"\"\"\n-    env_defaults = {}\n-    # https://reproducible-builds.org/docs/source-date-epoch/\n-    git_epoch_cmd = [\"git\", \"log\", \"-1\", \"--pretty=%ct\"]\n-    try:\n-        epoch = subprocess.check_output(\n-            git_epoch_cmd, encoding=\"utf-8\"\n-        ).strip()\n-        env_defaults[\"SOURCE_DATE_EPOCH\"] = epoch\n-    except subprocess.CalledProcessError:\n-        pass  # Might be building from a tarball.\n-    # This layering lets SOURCE_DATE_EPOCH from os.environ takes precedence.\n-    environment = env_defaults | os.environ | updates\n-\n-    env_diff = {}\n-    for key, value in environment.items():\n-        if os.environ.get(key) != value:\n-            env_diff[key] = value\n-\n-    env_vars = (\n-        f\"\\n     {key}={item}\" for key, item in sorted(env_diff.items())\n-    )\n-    log(\"\ud83c\udf0e\", f\"Environment changes:{''.join(env_vars)}\")\n-\n-    return environment\n-\n-\n-def subdir(working_dir, *, clean_ok=False):\n-    \"\"\"Decorator to change to a working directory.\"\"\"\n-\n-    def decorator(func):\n-        @functools.wraps(func)\n-        def wrapper(context):\n-            nonlocal working_dir\n-\n-            if callable(working_dir):\n-                working_dir = working_dir(context)\n-            separator()\n-            log(\"\ud83d\udcc1\", os.fsdecode(working_dir))\n-            if (\n-                clean_ok\n-                and getattr(context, \"clean\", False)\n-                and working_dir.exists()\n-            ):\n-                log(\"\ud83d\udeae\", \"Deleting directory (--clean)...\")\n-                shutil.rmtree(working_dir)\n-\n-            working_dir.mkdir(parents=True, exist_ok=True)\n-\n-            with contextlib.chdir(working_dir):\n-                return func(context, working_dir)\n-\n-        return wrapper\n-\n-    return decorator\n-\n-\n-def call(command, *, context=None, quiet=False, logdir=None, **kwargs):\n-    \"\"\"Execute a command.\n-\n-    If 'quiet' is true, then redirect stdout and stderr to a temporary file.\n-    \"\"\"\n-    if context is not None:\n-        quiet = context.quiet\n-        logdir = context.logdir\n-    elif quiet and logdir is None:\n-        raise ValueError(\"When quiet is True, logdir must be specified\")\n-\n-    log(\"\u276f\", \" \".join(map(str, command)), spacing=\"  \")\n-    if not quiet:\n-        stdout = None\n-        stderr = None\n-    else:\n-        stdout = tempfile.NamedTemporaryFile(\n-            \"w\",\n-            encoding=\"utf-8\",\n-            delete=False,\n-            dir=logdir,\n-            prefix=\"cpython-wasi-\",\n-            suffix=\".log\",\n-        )\n-        stderr = subprocess.STDOUT\n-        log(\"\ud83d\udcdd\", f\"Logging output to {stdout.name} (--quiet)...\")\n-\n-    subprocess.check_call(command, **kwargs, stdout=stdout, stderr=stderr)\n-\n-\n-def build_python_path():\n-    \"\"\"The path to the build Python binary.\"\"\"\n-    binary = BUILD_DIR / \"python\"\n-    if not binary.is_file():\n-        binary = binary.with_suffix(\".exe\")\n-        if not binary.is_file():\n-            raise FileNotFoundError(\n-                f\"Unable to find `python(.exe)` in {BUILD_DIR}\"\n-            )\n-\n-    return binary\n-\n-\n-def build_python_is_pydebug():\n-    \"\"\"Find out if the build Python is a pydebug build.\"\"\"\n-    test = \"import sys, test.support; sys.exit(test.support.Py_DEBUG)\"\n-    result = subprocess.run(\n-        [build_python_path(), \"-c\", test],\n-        capture_output=True,\n-    )\n-    return bool(result.returncode)\n-\n-\n-@subdir(BUILD_DIR, clean_ok=True)\n-def configure_build_python(context, working_dir):\n-    \"\"\"Configure the build/host Python.\"\"\"\n-    if LOCAL_SETUP.exists():\n-        if LOCAL_SETUP.read_bytes() == LOCAL_SETUP_MARKER:\n-            log(\"\ud83d\udc4d\", f\"{LOCAL_SETUP} exists ...\")\n-        else:\n-            log(\"\u26a0\ufe0f\", f\"{LOCAL_SETUP} exists, but has unexpected contents\")\n-    else:\n-        log(\"\ud83d\udcdd\", f\"Creating {LOCAL_SETUP} ...\")\n-        LOCAL_SETUP.write_bytes(LOCAL_SETUP_MARKER)\n-\n-    configure = [os.path.relpath(CHECKOUT / \"configure\", working_dir)]\n-    if context.args:\n-        configure.extend(context.args)\n-\n-    call(configure, context=context)\n-\n-\n-@subdir(BUILD_DIR)\n-def make_build_python(context, working_dir):\n-    \"\"\"Make/build the build Python.\"\"\"\n-    call([\"make\", \"--jobs\", str(cpu_count()), \"all\"], context=context)\n-\n-    binary = build_python_path()\n-    cmd = [\n-        binary,\n-        \"-c\",\n-        \"import sys; \"\n-        \"print(f'{sys.version_info.major}.{sys.version_info.minor}')\",\n-    ]\n-    version = subprocess.check_output(cmd, encoding=\"utf-8\").strip()\n-\n-    log(\"\ud83c\udf89\", f\"{binary} {version}\")\n-\n-\n-def find_wasi_sdk(config):\n-    \"\"\"Find the path to the WASI SDK.\"\"\"\n-    wasi_sdk_path = None\n-    wasi_sdk_version = config[\"targets\"][\"wasi-sdk\"]\n-\n-    if wasi_sdk_path_env_var := os.environ.get(\"WASI_SDK_PATH\"):\n-        wasi_sdk_path = pathlib.Path(wasi_sdk_path_env_var)\n-    else:\n-        opt_path = pathlib.Path(\"/opt\")\n-        # WASI SDK versions have a ``.0`` suffix, but it's a constant; the WASI SDK team\n-        # has said they don't plan to ever do a point release and all of their Git tags\n-        # lack the ``.0`` suffix.\n-        # Starting with WASI SDK 23, the tarballs went from containing a directory named\n-        # ``wasi-sdk-{WASI_SDK_VERSION}.0`` to e.g.\n-        # ``wasi-sdk-{WASI_SDK_VERSION}.0-x86_64-linux``.\n-        potential_sdks = [\n-            path\n-            for path in opt_path.glob(f\"wasi-sdk-{wasi_sdk_version}.0*\")\n-            if path.is_dir()\n-        ]\n-        if len(potential_sdks) == 1:\n-            wasi_sdk_path = potential_sdks[0]\n-        elif (default_path := opt_path / \"wasi-sdk\").is_dir():\n-            wasi_sdk_path = default_path\n-\n-    # Starting with WASI SDK 25, a VERSION file is included in the root\n-    # of the SDK directory that we can read to warn folks when they are using\n-    # an unsupported version.\n-    if wasi_sdk_path and (version_file := wasi_sdk_path / \"VERSION\").is_file():\n-        version_details = version_file.read_text(encoding=\"utf-8\")\n-        found_version = version_details.splitlines()[0]\n-        # Make sure there's a trailing dot to avoid false positives if somehow the\n-        # supported version is a prefix of the found version (e.g. `25` and `2567`).\n-        if not found_version.startswith(f\"{wasi_sdk_version}.\"):\n-            major_version = found_version.partition(\".\")[0]\n-            log(\n-                \"\u26a0\ufe0f\",\n-                f\" Found WASI SDK {major_version}, \"\n-                f\"but WASI SDK {wasi_sdk_version} is the supported version\",\n-            )\n-\n-    return wasi_sdk_path\n-\n-\n-def wasi_sdk_env(context):\n-    \"\"\"Calculate environment variables for building with wasi-sdk.\"\"\"\n-    wasi_sdk_path = context.wasi_sdk_path\n-    sysroot = wasi_sdk_path / \"share\" / \"wasi-sysroot\"\n-    env = {\n-        \"CC\": \"clang\",\n-        \"CPP\": \"clang-cpp\",\n-        \"CXX\": \"clang++\",\n-        \"AR\": \"llvm-ar\",\n-        \"RANLIB\": \"ranlib\",\n-    }\n-\n-    for env_var, binary_name in list(env.items()):\n-        env[env_var] = os.fsdecode(wasi_sdk_path / \"bin\" / binary_name)\n-\n-    if not wasi_sdk_path.name.startswith(\"wasi-sdk\"):\n-        for compiler in [\"CC\", \"CPP\", \"CXX\"]:\n-            env[compiler] += f\" --sysroot={sysroot}\"\n-\n-    env[\"PKG_CONFIG_PATH\"] = \"\"\n-    env[\"PKG_CONFIG_LIBDIR\"] = os.pathsep.join(\n-        map(\n-            os.fsdecode,\n-            [sysroot / \"lib\" / \"pkgconfig\", sysroot / \"share\" / \"pkgconfig\"],\n-        )\n-    )\n-    env[\"PKG_CONFIG_SYSROOT_DIR\"] = os.fsdecode(sysroot)\n-\n-    env[\"WASI_SDK_PATH\"] = os.fsdecode(wasi_sdk_path)\n-    env[\"WASI_SYSROOT\"] = os.fsdecode(sysroot)\n-\n-    env[\"PATH\"] = os.pathsep.join([\n-        os.fsdecode(wasi_sdk_path / \"bin\"),\n-        os.environ[\"PATH\"],\n-    ])\n-\n-    return env\n-\n-\n-@subdir(lambda context: CROSS_BUILD_DIR / context.host_triple, clean_ok=True)\n-def configure_wasi_python(context, working_dir):\n-    \"\"\"Configure the WASI/host build.\"\"\"\n-    if not context.wasi_sdk_path or not context.wasi_sdk_path.exists():\n-        raise ValueError(\n-            \"WASI-SDK not found; \"\n-            \"download from \"\n-            \"https://github.com/WebAssembly/wasi-sdk and/or \"\n-            \"specify via $WASI_SDK_PATH or --wasi-sdk\"\n-        )\n-\n-    config_site = os.fsdecode(HERE / \"config.site-wasm32-wasi\")\n-\n-    wasi_build_dir = working_dir.relative_to(CHECKOUT)\n-\n-    python_build_dir = BUILD_DIR / \"build\"\n-    lib_dirs = list(python_build_dir.glob(\"lib.*\"))\n-    assert len(lib_dirs) == 1, (\n-        f\"Expected a single lib.* directory in {python_build_dir}\"\n-    )\n-    lib_dir = os.fsdecode(lib_dirs[0])\n-    python_version = lib_dir.rpartition(\"-\")[-1]\n-    sysconfig_data_dir = (\n-        f\"{wasi_build_dir}/build/lib.wasi-wasm32-{python_version}\"\n-    )\n-\n-    # Use PYTHONPATH to include sysconfig data which must be anchored to the\n-    # WASI guest's `/` directory.\n-    args = {\n-        \"PYTHONPATH\": f\"/{sysconfig_data_dir}\",\n-        \"PYTHON_WASM\": working_dir / \"python.wasm\",\n-    }\n-    # Check dynamically for wasmtime in case it was specified manually via\n-    # `--host-runner`.\n-    if WASMTIME_HOST_RUNNER_VAR in context.host_runner:\n-        if wasmtime := shutil.which(\"wasmtime\"):\n-            args[WASMTIME_VAR_NAME] = wasmtime\n-        else:\n-            raise FileNotFoundError(\n-                \"wasmtime not found; download from \"\n-                \"https://github.com/bytecodealliance/wasmtime\"\n-            )\n-    host_runner = context.host_runner.format_map(args)\n-    env_additions = {\"CONFIG_SITE\": config_site, \"HOSTRUNNER\": host_runner}\n-    build_python = os.fsdecode(build_python_path())\n-    # The path to `configure` MUST be relative, else `python.wasm` is unable\n-    # to find the stdlib due to Python not recognizing that it's being\n-    # executed from within a checkout.\n-    configure = [\n-        os.path.relpath(CHECKOUT / \"configure\", working_dir),\n-        f\"--host={context.host_triple}\",\n-        f\"--build={BUILD_DIR.name}\",\n-        f\"--with-build-python={build_python}\",\n-    ]\n-    if build_python_is_pydebug():\n-        configure.append(\"--with-pydebug\")\n-    if context.args:\n-        configure.extend(context.args)\n-    call(\n-        configure,\n-        env=updated_env(env_additions | wasi_sdk_env(context)),\n-        context=context,\n-    )\n-\n-    python_wasm = working_dir / \"python.wasm\"\n-    exec_script = working_dir / \"python.sh\"\n-    with exec_script.open(\"w\", encoding=\"utf-8\") as file:\n-        file.write(f'#!/bin/sh\\nexec {host_runner} {python_wasm} \"$@\"\\n')\n-    exec_script.chmod(0o755)\n-    log(\"\ud83c\udfc3\", f\"Created {exec_script} (--host-runner)... \")\n-    sys.stdout.flush()\n-\n-\n-@subdir(lambda context: CROSS_BUILD_DIR / context.host_triple)\n-def make_wasi_python(context, working_dir):\n-    \"\"\"Run `make` for the WASI/host build.\"\"\"\n-    call(\n-        [\"make\", \"--jobs\", str(cpu_count()), \"all\"],\n-        env=updated_env(),\n-        context=context,\n-    )\n-\n-    exec_script = working_dir / \"python.sh\"\n-    call([exec_script, \"--version\"], quiet=False)\n-    log(\n-        \"\ud83c\udf89\",\n-        f\"Use `{exec_script.relative_to(context.init_dir)}` \"\n-        \"to run CPython w/ the WASI host specified by --host-runner\",\n-    )\n-\n-\n-def clean_contents(context):\n-    \"\"\"Delete all files created by this script.\"\"\"\n-    if CROSS_BUILD_DIR.exists():\n-        log(\"\ud83e\uddf9\", f\"Deleting {CROSS_BUILD_DIR} ...\")\n-        shutil.rmtree(CROSS_BUILD_DIR)\n-\n-    if LOCAL_SETUP.exists():\n-        if LOCAL_SETUP.read_bytes() == LOCAL_SETUP_MARKER:\n-            log(\"\ud83e\uddf9\", f\"Deleting generated {LOCAL_SETUP} ...\")\n-\n-\n-def build_steps(*steps):\n-    \"\"\"Construct a command from other steps.\"\"\"\n-\n-    def builder(context):\n-        for step in steps:\n-            step(context)\n-\n-    return builder\n-\n-\n-def main():\n-    with (HERE / \"config.toml\").open(\"rb\") as file:\n-        config = tomllib.load(file)\n-    default_wasi_sdk = find_wasi_sdk(config)\n-    default_host_triple = config[\"targets\"][\"host-triple\"]\n-    default_host_runner = (\n-        f\"{WASMTIME_HOST_RUNNER_VAR} run \"\n-        # For setting PYTHONPATH to the sysconfig data directory.\n-        \"--env PYTHONPATH={PYTHONPATH} \"\n-        # Map the checkout to / to load the stdlib from /Lib.\n-        f\"--dir {os.fsdecode(CHECKOUT)}::/ \"\n-        # Flags involving --optimize, --codegen, --debug, --wasm, and --wasi can be kept\n-        # in a config file.\n-        # We are using such a file to act as defaults in case a user wants to override\n-        # only some of the settings themselves, make it easy to modify settings\n-        # post-build so that they immediately apply to the Makefile instead of having to\n-        # regenerate it, and allow for easy copying of the settings for anyone else who\n-        # may want to use them.\n-        f\"--config {os.fsdecode(HERE / 'wasmtime.toml')}\"\n-    )\n-    default_logdir = pathlib.Path(tempfile.gettempdir())\n+if __name__ == \"__main__\":\n+    import pathlib\n+    import runpy\n+    import sys\n \n-    parser = argparse.ArgumentParser()\n-    subcommands = parser.add_subparsers(dest=\"subcommand\")\n-    build = subcommands.add_parser(\"build\", help=\"Build everything\")\n-    configure_build = subcommands.add_parser(\n-        \"configure-build-python\", help=\"Run `configure` for the build Python\"\n-    )\n-    make_build = subcommands.add_parser(\n-        \"make-build-python\", help=\"Run `make` for the build Python\"\n-    )\n-    build_python = subcommands.add_parser(\n-        \"build-python\", help=\"Build the build Python\"\n-    )\n-    configure_host = subcommands.add_parser(\n-        \"configure-host\",\n-        help=\"Run `configure` for the \"\n-        \"host/WASI (pydebug builds \"\n-        \"are inferred from the build \"\n-        \"Python)\",\n-    )\n-    make_host = subcommands.add_parser(\n-        \"make-host\", help=\"Run `make` for the host/WASI\"\n+    print(\n+        \"\u26a0\ufe0f WARNING: This script is deprecated and slated for removal in Python 3.20; \"\n+        \"execute the `Platforms/WASI/` directory instead (i.e. `python Platforms/WASI`)\\n\",\n+        file=sys.stderr,\n     )\n-    build_host = subcommands.add_parser(\n-        \"build-host\", help=\"Build the host/WASI Python\"\n-    )\n-    subcommands.add_parser(\n-        \"clean\", help=\"Delete files and directories created by this script\"\n-    )\n-    for subcommand in (\n-        build,\n-        configure_build,\n-        make_build,\n-        build_python,\n-        configure_host,\n-        make_host,\n-        build_host,\n-    ):\n-        subcommand.add_argument(\n-            \"--quiet\",\n-            action=\"store_true\",\n-            default=False,\n-            dest=\"quiet\",\n-            help=\"Redirect output from subprocesses to a log file\",\n-        )\n-        subcommand.add_argument(\n-            \"--logdir\",\n-            type=pathlib.Path,\n-            default=default_logdir,\n-            help=f\"Directory to store log files; defaults to {default_logdir}\",\n-        )\n-    for subcommand in (\n-        configure_build,\n-        configure_host,\n-        build_python,\n-        build_host,\n-    ):\n-        subcommand.add_argument(\n-            \"--clean\",\n-            action=\"store_true\",\n-            default=False,\n-            dest=\"clean\",\n-            help=\"Delete any relevant directories before building\",\n-        )\n-    for subcommand in (\n-        build,\n-        configure_build,\n-        configure_host,\n-        build_python,\n-        build_host,\n-    ):\n-        subcommand.add_argument(\n-            \"args\", nargs=\"*\", help=\"Extra arguments to pass to `configure`\"\n-        )\n-    for subcommand in build, configure_host, build_host:\n-        subcommand.add_argument(\n-            \"--wasi-sdk\",\n-            type=pathlib.Path,\n-            dest=\"wasi_sdk_path\",\n-            default=default_wasi_sdk,\n-            help=f\"Path to the WASI SDK; defaults to {default_wasi_sdk}\",\n-        )\n-        subcommand.add_argument(\n-            \"--host-runner\",\n-            action=\"store\",\n-            default=default_host_runner,\n-            dest=\"host_runner\",\n-            help=\"Command template for running the WASI host; defaults to \"\n-            f\"`{default_host_runner}`\",\n-        )\n-    for subcommand in build, configure_host, make_host, build_host:\n-        subcommand.add_argument(\n-            \"--host-triple\",\n-            action=\"store\",\n-            default=default_host_triple,\n-            help=\"The target triple for the WASI host build; \"\n-            f\"defaults to {default_host_triple}\",\n-        )\n-\n-    context = parser.parse_args()\n-    context.init_dir = pathlib.Path().absolute()\n \n-    build_build_python = build_steps(configure_build_python, make_build_python)\n-    build_wasi_python = build_steps(configure_wasi_python, make_wasi_python)\n+    checkout = pathlib.Path(__file__).parent.parent.parent.parent\n \n-    dispatch = {\n-        \"configure-build-python\": configure_build_python,\n-        \"make-build-python\": make_build_python,\n-        \"build-python\": build_build_python,\n-        \"configure-host\": configure_wasi_python,\n-        \"make-host\": make_wasi_python,\n-        \"build-host\": build_wasi_python,\n-        \"build\": build_steps(build_build_python, build_wasi_python),\n-        \"clean\": clean_contents,\n-    }\n-    dispatch[context.subcommand](context)\n-\n-\n-if __name__ == \"__main__\":\n-    main()\n+    runpy.run_path(checkout / \"Platforms\" / \"WASI\", run_name=\"__main__\")",
      "comment": "But if I just did a rename it would break the buildbots and leave the repo after this commit in a somewhat broken state for anyone else building.",
      "comment_id": 2700336834,
      "user": "brettcannon",
      "created_at": "2026-01-16T23:42:51Z",
      "url": "https://github.com/python/cpython/pull/143942#discussion_r2700336834"
    },
    {
      "repo": "python/cpython",
      "pr_number": 143942,
      "file_path": "Tools/wasm/wasi/__main__.py",
      "line": 14,
      "side": "RIGHT",
      "diff_hunk": "@@ -1,554 +1,14 @@\n-#!/usr/bin/env python3\n-\n-import argparse\n-import contextlib\n-import functools\n-import os\n-\n-import tomllib\n-\n-try:\n-    from os import process_cpu_count as cpu_count\n-except ImportError:\n-    from os import cpu_count\n-import pathlib\n-import shutil\n-import subprocess\n-import sys\n-import sysconfig\n-import tempfile\n-\n-HERE = pathlib.Path(__file__).parent\n-\n-# Path is: cpython/Tools/wasm/wasi\n-CHECKOUT = HERE.parent.parent.parent\n-assert (CHECKOUT / \"configure\").is_file(), (\n-    \"Please update the location of the file\"\n-)\n-\n-CROSS_BUILD_DIR = CHECKOUT / \"cross-build\"\n-# Build platform can also be found via `config.guess`.\n-BUILD_DIR = CROSS_BUILD_DIR / sysconfig.get_config_var(\"BUILD_GNU_TYPE\")\n-\n-LOCAL_SETUP = CHECKOUT / \"Modules\" / \"Setup.local\"\n-LOCAL_SETUP_MARKER = (\n-    b\"# Generated by Tools/wasm/wasi .\\n\"\n-    b\"# Required to statically build extension modules.\"\n-)\n-\n-WASI_SDK_VERSION = 29\n-\n-WASMTIME_VAR_NAME = \"WASMTIME\"\n-WASMTIME_HOST_RUNNER_VAR = f\"{{{WASMTIME_VAR_NAME}}}\"\n-\n-\n-def separator():\n-    \"\"\"Print a separator line across the terminal width.\"\"\"\n-    try:\n-        tput_output = subprocess.check_output(\n-            [\"tput\", \"cols\"], encoding=\"utf-8\"\n-        )\n-    except subprocess.CalledProcessError:\n-        terminal_width = 80\n-    else:\n-        terminal_width = int(tput_output.strip())\n-    print(\"\u23af\" * terminal_width)\n-\n-\n-def log(emoji, message, *, spacing=None):\n-    \"\"\"Print a notification with an emoji.\n-\n-    If 'spacing' is None, calculate the spacing based on the number of code points\n-    in the emoji as terminals \"eat\" a space when the emoji has multiple code points.\n-    \"\"\"\n-    if spacing is None:\n-        spacing = \" \" if len(emoji) == 1 else \"  \"\n-    print(\"\".join([emoji, spacing, message]))\n-\n-\n-def updated_env(updates={}):\n-    \"\"\"Create a new dict representing the environment to use.\n-\n-    The changes made to the execution environment are printed out.\n-    \"\"\"\n-    env_defaults = {}\n-    # https://reproducible-builds.org/docs/source-date-epoch/\n-    git_epoch_cmd = [\"git\", \"log\", \"-1\", \"--pretty=%ct\"]\n-    try:\n-        epoch = subprocess.check_output(\n-            git_epoch_cmd, encoding=\"utf-8\"\n-        ).strip()\n-        env_defaults[\"SOURCE_DATE_EPOCH\"] = epoch\n-    except subprocess.CalledProcessError:\n-        pass  # Might be building from a tarball.\n-    # This layering lets SOURCE_DATE_EPOCH from os.environ takes precedence.\n-    environment = env_defaults | os.environ | updates\n-\n-    env_diff = {}\n-    for key, value in environment.items():\n-        if os.environ.get(key) != value:\n-            env_diff[key] = value\n-\n-    env_vars = (\n-        f\"\\n     {key}={item}\" for key, item in sorted(env_diff.items())\n-    )\n-    log(\"\ud83c\udf0e\", f\"Environment changes:{''.join(env_vars)}\")\n-\n-    return environment\n-\n-\n-def subdir(working_dir, *, clean_ok=False):\n-    \"\"\"Decorator to change to a working directory.\"\"\"\n-\n-    def decorator(func):\n-        @functools.wraps(func)\n-        def wrapper(context):\n-            nonlocal working_dir\n-\n-            if callable(working_dir):\n-                working_dir = working_dir(context)\n-            separator()\n-            log(\"\ud83d\udcc1\", os.fsdecode(working_dir))\n-            if (\n-                clean_ok\n-                and getattr(context, \"clean\", False)\n-                and working_dir.exists()\n-            ):\n-                log(\"\ud83d\udeae\", \"Deleting directory (--clean)...\")\n-                shutil.rmtree(working_dir)\n-\n-            working_dir.mkdir(parents=True, exist_ok=True)\n-\n-            with contextlib.chdir(working_dir):\n-                return func(context, working_dir)\n-\n-        return wrapper\n-\n-    return decorator\n-\n-\n-def call(command, *, context=None, quiet=False, logdir=None, **kwargs):\n-    \"\"\"Execute a command.\n-\n-    If 'quiet' is true, then redirect stdout and stderr to a temporary file.\n-    \"\"\"\n-    if context is not None:\n-        quiet = context.quiet\n-        logdir = context.logdir\n-    elif quiet and logdir is None:\n-        raise ValueError(\"When quiet is True, logdir must be specified\")\n-\n-    log(\"\u276f\", \" \".join(map(str, command)), spacing=\"  \")\n-    if not quiet:\n-        stdout = None\n-        stderr = None\n-    else:\n-        stdout = tempfile.NamedTemporaryFile(\n-            \"w\",\n-            encoding=\"utf-8\",\n-            delete=False,\n-            dir=logdir,\n-            prefix=\"cpython-wasi-\",\n-            suffix=\".log\",\n-        )\n-        stderr = subprocess.STDOUT\n-        log(\"\ud83d\udcdd\", f\"Logging output to {stdout.name} (--quiet)...\")\n-\n-    subprocess.check_call(command, **kwargs, stdout=stdout, stderr=stderr)\n-\n-\n-def build_python_path():\n-    \"\"\"The path to the build Python binary.\"\"\"\n-    binary = BUILD_DIR / \"python\"\n-    if not binary.is_file():\n-        binary = binary.with_suffix(\".exe\")\n-        if not binary.is_file():\n-            raise FileNotFoundError(\n-                f\"Unable to find `python(.exe)` in {BUILD_DIR}\"\n-            )\n-\n-    return binary\n-\n-\n-def build_python_is_pydebug():\n-    \"\"\"Find out if the build Python is a pydebug build.\"\"\"\n-    test = \"import sys, test.support; sys.exit(test.support.Py_DEBUG)\"\n-    result = subprocess.run(\n-        [build_python_path(), \"-c\", test],\n-        capture_output=True,\n-    )\n-    return bool(result.returncode)\n-\n-\n-@subdir(BUILD_DIR, clean_ok=True)\n-def configure_build_python(context, working_dir):\n-    \"\"\"Configure the build/host Python.\"\"\"\n-    if LOCAL_SETUP.exists():\n-        if LOCAL_SETUP.read_bytes() == LOCAL_SETUP_MARKER:\n-            log(\"\ud83d\udc4d\", f\"{LOCAL_SETUP} exists ...\")\n-        else:\n-            log(\"\u26a0\ufe0f\", f\"{LOCAL_SETUP} exists, but has unexpected contents\")\n-    else:\n-        log(\"\ud83d\udcdd\", f\"Creating {LOCAL_SETUP} ...\")\n-        LOCAL_SETUP.write_bytes(LOCAL_SETUP_MARKER)\n-\n-    configure = [os.path.relpath(CHECKOUT / \"configure\", working_dir)]\n-    if context.args:\n-        configure.extend(context.args)\n-\n-    call(configure, context=context)\n-\n-\n-@subdir(BUILD_DIR)\n-def make_build_python(context, working_dir):\n-    \"\"\"Make/build the build Python.\"\"\"\n-    call([\"make\", \"--jobs\", str(cpu_count()), \"all\"], context=context)\n-\n-    binary = build_python_path()\n-    cmd = [\n-        binary,\n-        \"-c\",\n-        \"import sys; \"\n-        \"print(f'{sys.version_info.major}.{sys.version_info.minor}')\",\n-    ]\n-    version = subprocess.check_output(cmd, encoding=\"utf-8\").strip()\n-\n-    log(\"\ud83c\udf89\", f\"{binary} {version}\")\n-\n-\n-def find_wasi_sdk(config):\n-    \"\"\"Find the path to the WASI SDK.\"\"\"\n-    wasi_sdk_path = None\n-    wasi_sdk_version = config[\"targets\"][\"wasi-sdk\"]\n-\n-    if wasi_sdk_path_env_var := os.environ.get(\"WASI_SDK_PATH\"):\n-        wasi_sdk_path = pathlib.Path(wasi_sdk_path_env_var)\n-    else:\n-        opt_path = pathlib.Path(\"/opt\")\n-        # WASI SDK versions have a ``.0`` suffix, but it's a constant; the WASI SDK team\n-        # has said they don't plan to ever do a point release and all of their Git tags\n-        # lack the ``.0`` suffix.\n-        # Starting with WASI SDK 23, the tarballs went from containing a directory named\n-        # ``wasi-sdk-{WASI_SDK_VERSION}.0`` to e.g.\n-        # ``wasi-sdk-{WASI_SDK_VERSION}.0-x86_64-linux``.\n-        potential_sdks = [\n-            path\n-            for path in opt_path.glob(f\"wasi-sdk-{wasi_sdk_version}.0*\")\n-            if path.is_dir()\n-        ]\n-        if len(potential_sdks) == 1:\n-            wasi_sdk_path = potential_sdks[0]\n-        elif (default_path := opt_path / \"wasi-sdk\").is_dir():\n-            wasi_sdk_path = default_path\n-\n-    # Starting with WASI SDK 25, a VERSION file is included in the root\n-    # of the SDK directory that we can read to warn folks when they are using\n-    # an unsupported version.\n-    if wasi_sdk_path and (version_file := wasi_sdk_path / \"VERSION\").is_file():\n-        version_details = version_file.read_text(encoding=\"utf-8\")\n-        found_version = version_details.splitlines()[0]\n-        # Make sure there's a trailing dot to avoid false positives if somehow the\n-        # supported version is a prefix of the found version (e.g. `25` and `2567`).\n-        if not found_version.startswith(f\"{wasi_sdk_version}.\"):\n-            major_version = found_version.partition(\".\")[0]\n-            log(\n-                \"\u26a0\ufe0f\",\n-                f\" Found WASI SDK {major_version}, \"\n-                f\"but WASI SDK {wasi_sdk_version} is the supported version\",\n-            )\n-\n-    return wasi_sdk_path\n-\n-\n-def wasi_sdk_env(context):\n-    \"\"\"Calculate environment variables for building with wasi-sdk.\"\"\"\n-    wasi_sdk_path = context.wasi_sdk_path\n-    sysroot = wasi_sdk_path / \"share\" / \"wasi-sysroot\"\n-    env = {\n-        \"CC\": \"clang\",\n-        \"CPP\": \"clang-cpp\",\n-        \"CXX\": \"clang++\",\n-        \"AR\": \"llvm-ar\",\n-        \"RANLIB\": \"ranlib\",\n-    }\n-\n-    for env_var, binary_name in list(env.items()):\n-        env[env_var] = os.fsdecode(wasi_sdk_path / \"bin\" / binary_name)\n-\n-    if not wasi_sdk_path.name.startswith(\"wasi-sdk\"):\n-        for compiler in [\"CC\", \"CPP\", \"CXX\"]:\n-            env[compiler] += f\" --sysroot={sysroot}\"\n-\n-    env[\"PKG_CONFIG_PATH\"] = \"\"\n-    env[\"PKG_CONFIG_LIBDIR\"] = os.pathsep.join(\n-        map(\n-            os.fsdecode,\n-            [sysroot / \"lib\" / \"pkgconfig\", sysroot / \"share\" / \"pkgconfig\"],\n-        )\n-    )\n-    env[\"PKG_CONFIG_SYSROOT_DIR\"] = os.fsdecode(sysroot)\n-\n-    env[\"WASI_SDK_PATH\"] = os.fsdecode(wasi_sdk_path)\n-    env[\"WASI_SYSROOT\"] = os.fsdecode(sysroot)\n-\n-    env[\"PATH\"] = os.pathsep.join([\n-        os.fsdecode(wasi_sdk_path / \"bin\"),\n-        os.environ[\"PATH\"],\n-    ])\n-\n-    return env\n-\n-\n-@subdir(lambda context: CROSS_BUILD_DIR / context.host_triple, clean_ok=True)\n-def configure_wasi_python(context, working_dir):\n-    \"\"\"Configure the WASI/host build.\"\"\"\n-    if not context.wasi_sdk_path or not context.wasi_sdk_path.exists():\n-        raise ValueError(\n-            \"WASI-SDK not found; \"\n-            \"download from \"\n-            \"https://github.com/WebAssembly/wasi-sdk and/or \"\n-            \"specify via $WASI_SDK_PATH or --wasi-sdk\"\n-        )\n-\n-    config_site = os.fsdecode(HERE / \"config.site-wasm32-wasi\")\n-\n-    wasi_build_dir = working_dir.relative_to(CHECKOUT)\n-\n-    python_build_dir = BUILD_DIR / \"build\"\n-    lib_dirs = list(python_build_dir.glob(\"lib.*\"))\n-    assert len(lib_dirs) == 1, (\n-        f\"Expected a single lib.* directory in {python_build_dir}\"\n-    )\n-    lib_dir = os.fsdecode(lib_dirs[0])\n-    python_version = lib_dir.rpartition(\"-\")[-1]\n-    sysconfig_data_dir = (\n-        f\"{wasi_build_dir}/build/lib.wasi-wasm32-{python_version}\"\n-    )\n-\n-    # Use PYTHONPATH to include sysconfig data which must be anchored to the\n-    # WASI guest's `/` directory.\n-    args = {\n-        \"PYTHONPATH\": f\"/{sysconfig_data_dir}\",\n-        \"PYTHON_WASM\": working_dir / \"python.wasm\",\n-    }\n-    # Check dynamically for wasmtime in case it was specified manually via\n-    # `--host-runner`.\n-    if WASMTIME_HOST_RUNNER_VAR in context.host_runner:\n-        if wasmtime := shutil.which(\"wasmtime\"):\n-            args[WASMTIME_VAR_NAME] = wasmtime\n-        else:\n-            raise FileNotFoundError(\n-                \"wasmtime not found; download from \"\n-                \"https://github.com/bytecodealliance/wasmtime\"\n-            )\n-    host_runner = context.host_runner.format_map(args)\n-    env_additions = {\"CONFIG_SITE\": config_site, \"HOSTRUNNER\": host_runner}\n-    build_python = os.fsdecode(build_python_path())\n-    # The path to `configure` MUST be relative, else `python.wasm` is unable\n-    # to find the stdlib due to Python not recognizing that it's being\n-    # executed from within a checkout.\n-    configure = [\n-        os.path.relpath(CHECKOUT / \"configure\", working_dir),\n-        f\"--host={context.host_triple}\",\n-        f\"--build={BUILD_DIR.name}\",\n-        f\"--with-build-python={build_python}\",\n-    ]\n-    if build_python_is_pydebug():\n-        configure.append(\"--with-pydebug\")\n-    if context.args:\n-        configure.extend(context.args)\n-    call(\n-        configure,\n-        env=updated_env(env_additions | wasi_sdk_env(context)),\n-        context=context,\n-    )\n-\n-    python_wasm = working_dir / \"python.wasm\"\n-    exec_script = working_dir / \"python.sh\"\n-    with exec_script.open(\"w\", encoding=\"utf-8\") as file:\n-        file.write(f'#!/bin/sh\\nexec {host_runner} {python_wasm} \"$@\"\\n')\n-    exec_script.chmod(0o755)\n-    log(\"\ud83c\udfc3\", f\"Created {exec_script} (--host-runner)... \")\n-    sys.stdout.flush()\n-\n-\n-@subdir(lambda context: CROSS_BUILD_DIR / context.host_triple)\n-def make_wasi_python(context, working_dir):\n-    \"\"\"Run `make` for the WASI/host build.\"\"\"\n-    call(\n-        [\"make\", \"--jobs\", str(cpu_count()), \"all\"],\n-        env=updated_env(),\n-        context=context,\n-    )\n-\n-    exec_script = working_dir / \"python.sh\"\n-    call([exec_script, \"--version\"], quiet=False)\n-    log(\n-        \"\ud83c\udf89\",\n-        f\"Use `{exec_script.relative_to(context.init_dir)}` \"\n-        \"to run CPython w/ the WASI host specified by --host-runner\",\n-    )\n-\n-\n-def clean_contents(context):\n-    \"\"\"Delete all files created by this script.\"\"\"\n-    if CROSS_BUILD_DIR.exists():\n-        log(\"\ud83e\uddf9\", f\"Deleting {CROSS_BUILD_DIR} ...\")\n-        shutil.rmtree(CROSS_BUILD_DIR)\n-\n-    if LOCAL_SETUP.exists():\n-        if LOCAL_SETUP.read_bytes() == LOCAL_SETUP_MARKER:\n-            log(\"\ud83e\uddf9\", f\"Deleting generated {LOCAL_SETUP} ...\")\n-\n-\n-def build_steps(*steps):\n-    \"\"\"Construct a command from other steps.\"\"\"\n-\n-    def builder(context):\n-        for step in steps:\n-            step(context)\n-\n-    return builder\n-\n-\n-def main():\n-    with (HERE / \"config.toml\").open(\"rb\") as file:\n-        config = tomllib.load(file)\n-    default_wasi_sdk = find_wasi_sdk(config)\n-    default_host_triple = config[\"targets\"][\"host-triple\"]\n-    default_host_runner = (\n-        f\"{WASMTIME_HOST_RUNNER_VAR} run \"\n-        # For setting PYTHONPATH to the sysconfig data directory.\n-        \"--env PYTHONPATH={PYTHONPATH} \"\n-        # Map the checkout to / to load the stdlib from /Lib.\n-        f\"--dir {os.fsdecode(CHECKOUT)}::/ \"\n-        # Flags involving --optimize, --codegen, --debug, --wasm, and --wasi can be kept\n-        # in a config file.\n-        # We are using such a file to act as defaults in case a user wants to override\n-        # only some of the settings themselves, make it easy to modify settings\n-        # post-build so that they immediately apply to the Makefile instead of having to\n-        # regenerate it, and allow for easy copying of the settings for anyone else who\n-        # may want to use them.\n-        f\"--config {os.fsdecode(HERE / 'wasmtime.toml')}\"\n-    )\n-    default_logdir = pathlib.Path(tempfile.gettempdir())\n+if __name__ == \"__main__\":\n+    import pathlib\n+    import runpy\n+    import sys\n \n-    parser = argparse.ArgumentParser()\n-    subcommands = parser.add_subparsers(dest=\"subcommand\")\n-    build = subcommands.add_parser(\"build\", help=\"Build everything\")\n-    configure_build = subcommands.add_parser(\n-        \"configure-build-python\", help=\"Run `configure` for the build Python\"\n-    )\n-    make_build = subcommands.add_parser(\n-        \"make-build-python\", help=\"Run `make` for the build Python\"\n-    )\n-    build_python = subcommands.add_parser(\n-        \"build-python\", help=\"Build the build Python\"\n-    )\n-    configure_host = subcommands.add_parser(\n-        \"configure-host\",\n-        help=\"Run `configure` for the \"\n-        \"host/WASI (pydebug builds \"\n-        \"are inferred from the build \"\n-        \"Python)\",\n-    )\n-    make_host = subcommands.add_parser(\n-        \"make-host\", help=\"Run `make` for the host/WASI\"\n+    print(\n+        \"\u26a0\ufe0f WARNING: This script is deprecated and slated for removal in Python 3.20; \"\n+        \"execute the `Platforms/WASI/` directory instead (i.e. `python Platforms/WASI`)\\n\",\n+        file=sys.stderr,\n     )\n-    build_host = subcommands.add_parser(\n-        \"build-host\", help=\"Build the host/WASI Python\"\n-    )\n-    subcommands.add_parser(\n-        \"clean\", help=\"Delete files and directories created by this script\"\n-    )\n-    for subcommand in (\n-        build,\n-        configure_build,\n-        make_build,\n-        build_python,\n-        configure_host,\n-        make_host,\n-        build_host,\n-    ):\n-        subcommand.add_argument(\n-            \"--quiet\",\n-            action=\"store_true\",\n-            default=False,\n-            dest=\"quiet\",\n-            help=\"Redirect output from subprocesses to a log file\",\n-        )\n-        subcommand.add_argument(\n-            \"--logdir\",\n-            type=pathlib.Path,\n-            default=default_logdir,\n-            help=f\"Directory to store log files; defaults to {default_logdir}\",\n-        )\n-    for subcommand in (\n-        configure_build,\n-        configure_host,\n-        build_python,\n-        build_host,\n-    ):\n-        subcommand.add_argument(\n-            \"--clean\",\n-            action=\"store_true\",\n-            default=False,\n-            dest=\"clean\",\n-            help=\"Delete any relevant directories before building\",\n-        )\n-    for subcommand in (\n-        build,\n-        configure_build,\n-        configure_host,\n-        build_python,\n-        build_host,\n-    ):\n-        subcommand.add_argument(\n-            \"args\", nargs=\"*\", help=\"Extra arguments to pass to `configure`\"\n-        )\n-    for subcommand in build, configure_host, build_host:\n-        subcommand.add_argument(\n-            \"--wasi-sdk\",\n-            type=pathlib.Path,\n-            dest=\"wasi_sdk_path\",\n-            default=default_wasi_sdk,\n-            help=f\"Path to the WASI SDK; defaults to {default_wasi_sdk}\",\n-        )\n-        subcommand.add_argument(\n-            \"--host-runner\",\n-            action=\"store\",\n-            default=default_host_runner,\n-            dest=\"host_runner\",\n-            help=\"Command template for running the WASI host; defaults to \"\n-            f\"`{default_host_runner}`\",\n-        )\n-    for subcommand in build, configure_host, make_host, build_host:\n-        subcommand.add_argument(\n-            \"--host-triple\",\n-            action=\"store\",\n-            default=default_host_triple,\n-            help=\"The target triple for the WASI host build; \"\n-            f\"defaults to {default_host_triple}\",\n-        )\n-\n-    context = parser.parse_args()\n-    context.init_dir = pathlib.Path().absolute()\n \n-    build_build_python = build_steps(configure_build_python, make_build_python)\n-    build_wasi_python = build_steps(configure_wasi_python, make_wasi_python)\n+    checkout = pathlib.Path(__file__).parent.parent.parent.parent\n \n-    dispatch = {\n-        \"configure-build-python\": configure_build_python,\n-        \"make-build-python\": make_build_python,\n-        \"build-python\": build_build_python,\n-        \"configure-host\": configure_wasi_python,\n-        \"make-host\": make_wasi_python,\n-        \"build-host\": build_wasi_python,\n-        \"build\": build_steps(build_build_python, build_wasi_python),\n-        \"clean\": clean_contents,\n-    }\n-    dispatch[context.subcommand](context)\n-\n-\n-if __name__ == \"__main__\":\n-    main()\n+    runpy.run_path(checkout / \"Platforms\" / \"WASI\", run_name=\"__main__\")",
      "comment": "It looks like modern `git blame -C` is actually smart enough to track changes in `Platforms/WASI/__main__.py` even back to `Tools/wasm/wasi.py`, so this doesn't look like it's actually worth worrying about.",
      "comment_id": 2705416874,
      "user": "zware",
      "created_at": "2026-01-19T16:28:35Z",
      "url": "https://github.com/python/cpython/pull/143942#discussion_r2705416874"
    },
    {
      "repo": "python/cpython",
      "pr_number": 143942,
      "file_path": "Tools/wasm/wasi/__main__.py",
      "line": 14,
      "side": "RIGHT",
      "diff_hunk": "@@ -1,554 +1,14 @@\n-#!/usr/bin/env python3\n-\n-import argparse\n-import contextlib\n-import functools\n-import os\n-\n-import tomllib\n-\n-try:\n-    from os import process_cpu_count as cpu_count\n-except ImportError:\n-    from os import cpu_count\n-import pathlib\n-import shutil\n-import subprocess\n-import sys\n-import sysconfig\n-import tempfile\n-\n-HERE = pathlib.Path(__file__).parent\n-\n-# Path is: cpython/Tools/wasm/wasi\n-CHECKOUT = HERE.parent.parent.parent\n-assert (CHECKOUT / \"configure\").is_file(), (\n-    \"Please update the location of the file\"\n-)\n-\n-CROSS_BUILD_DIR = CHECKOUT / \"cross-build\"\n-# Build platform can also be found via `config.guess`.\n-BUILD_DIR = CROSS_BUILD_DIR / sysconfig.get_config_var(\"BUILD_GNU_TYPE\")\n-\n-LOCAL_SETUP = CHECKOUT / \"Modules\" / \"Setup.local\"\n-LOCAL_SETUP_MARKER = (\n-    b\"# Generated by Tools/wasm/wasi .\\n\"\n-    b\"# Required to statically build extension modules.\"\n-)\n-\n-WASI_SDK_VERSION = 29\n-\n-WASMTIME_VAR_NAME = \"WASMTIME\"\n-WASMTIME_HOST_RUNNER_VAR = f\"{{{WASMTIME_VAR_NAME}}}\"\n-\n-\n-def separator():\n-    \"\"\"Print a separator line across the terminal width.\"\"\"\n-    try:\n-        tput_output = subprocess.check_output(\n-            [\"tput\", \"cols\"], encoding=\"utf-8\"\n-        )\n-    except subprocess.CalledProcessError:\n-        terminal_width = 80\n-    else:\n-        terminal_width = int(tput_output.strip())\n-    print(\"\u23af\" * terminal_width)\n-\n-\n-def log(emoji, message, *, spacing=None):\n-    \"\"\"Print a notification with an emoji.\n-\n-    If 'spacing' is None, calculate the spacing based on the number of code points\n-    in the emoji as terminals \"eat\" a space when the emoji has multiple code points.\n-    \"\"\"\n-    if spacing is None:\n-        spacing = \" \" if len(emoji) == 1 else \"  \"\n-    print(\"\".join([emoji, spacing, message]))\n-\n-\n-def updated_env(updates={}):\n-    \"\"\"Create a new dict representing the environment to use.\n-\n-    The changes made to the execution environment are printed out.\n-    \"\"\"\n-    env_defaults = {}\n-    # https://reproducible-builds.org/docs/source-date-epoch/\n-    git_epoch_cmd = [\"git\", \"log\", \"-1\", \"--pretty=%ct\"]\n-    try:\n-        epoch = subprocess.check_output(\n-            git_epoch_cmd, encoding=\"utf-8\"\n-        ).strip()\n-        env_defaults[\"SOURCE_DATE_EPOCH\"] = epoch\n-    except subprocess.CalledProcessError:\n-        pass  # Might be building from a tarball.\n-    # This layering lets SOURCE_DATE_EPOCH from os.environ takes precedence.\n-    environment = env_defaults | os.environ | updates\n-\n-    env_diff = {}\n-    for key, value in environment.items():\n-        if os.environ.get(key) != value:\n-            env_diff[key] = value\n-\n-    env_vars = (\n-        f\"\\n     {key}={item}\" for key, item in sorted(env_diff.items())\n-    )\n-    log(\"\ud83c\udf0e\", f\"Environment changes:{''.join(env_vars)}\")\n-\n-    return environment\n-\n-\n-def subdir(working_dir, *, clean_ok=False):\n-    \"\"\"Decorator to change to a working directory.\"\"\"\n-\n-    def decorator(func):\n-        @functools.wraps(func)\n-        def wrapper(context):\n-            nonlocal working_dir\n-\n-            if callable(working_dir):\n-                working_dir = working_dir(context)\n-            separator()\n-            log(\"\ud83d\udcc1\", os.fsdecode(working_dir))\n-            if (\n-                clean_ok\n-                and getattr(context, \"clean\", False)\n-                and working_dir.exists()\n-            ):\n-                log(\"\ud83d\udeae\", \"Deleting directory (--clean)...\")\n-                shutil.rmtree(working_dir)\n-\n-            working_dir.mkdir(parents=True, exist_ok=True)\n-\n-            with contextlib.chdir(working_dir):\n-                return func(context, working_dir)\n-\n-        return wrapper\n-\n-    return decorator\n-\n-\n-def call(command, *, context=None, quiet=False, logdir=None, **kwargs):\n-    \"\"\"Execute a command.\n-\n-    If 'quiet' is true, then redirect stdout and stderr to a temporary file.\n-    \"\"\"\n-    if context is not None:\n-        quiet = context.quiet\n-        logdir = context.logdir\n-    elif quiet and logdir is None:\n-        raise ValueError(\"When quiet is True, logdir must be specified\")\n-\n-    log(\"\u276f\", \" \".join(map(str, command)), spacing=\"  \")\n-    if not quiet:\n-        stdout = None\n-        stderr = None\n-    else:\n-        stdout = tempfile.NamedTemporaryFile(\n-            \"w\",\n-            encoding=\"utf-8\",\n-            delete=False,\n-            dir=logdir,\n-            prefix=\"cpython-wasi-\",\n-            suffix=\".log\",\n-        )\n-        stderr = subprocess.STDOUT\n-        log(\"\ud83d\udcdd\", f\"Logging output to {stdout.name} (--quiet)...\")\n-\n-    subprocess.check_call(command, **kwargs, stdout=stdout, stderr=stderr)\n-\n-\n-def build_python_path():\n-    \"\"\"The path to the build Python binary.\"\"\"\n-    binary = BUILD_DIR / \"python\"\n-    if not binary.is_file():\n-        binary = binary.with_suffix(\".exe\")\n-        if not binary.is_file():\n-            raise FileNotFoundError(\n-                f\"Unable to find `python(.exe)` in {BUILD_DIR}\"\n-            )\n-\n-    return binary\n-\n-\n-def build_python_is_pydebug():\n-    \"\"\"Find out if the build Python is a pydebug build.\"\"\"\n-    test = \"import sys, test.support; sys.exit(test.support.Py_DEBUG)\"\n-    result = subprocess.run(\n-        [build_python_path(), \"-c\", test],\n-        capture_output=True,\n-    )\n-    return bool(result.returncode)\n-\n-\n-@subdir(BUILD_DIR, clean_ok=True)\n-def configure_build_python(context, working_dir):\n-    \"\"\"Configure the build/host Python.\"\"\"\n-    if LOCAL_SETUP.exists():\n-        if LOCAL_SETUP.read_bytes() == LOCAL_SETUP_MARKER:\n-            log(\"\ud83d\udc4d\", f\"{LOCAL_SETUP} exists ...\")\n-        else:\n-            log(\"\u26a0\ufe0f\", f\"{LOCAL_SETUP} exists, but has unexpected contents\")\n-    else:\n-        log(\"\ud83d\udcdd\", f\"Creating {LOCAL_SETUP} ...\")\n-        LOCAL_SETUP.write_bytes(LOCAL_SETUP_MARKER)\n-\n-    configure = [os.path.relpath(CHECKOUT / \"configure\", working_dir)]\n-    if context.args:\n-        configure.extend(context.args)\n-\n-    call(configure, context=context)\n-\n-\n-@subdir(BUILD_DIR)\n-def make_build_python(context, working_dir):\n-    \"\"\"Make/build the build Python.\"\"\"\n-    call([\"make\", \"--jobs\", str(cpu_count()), \"all\"], context=context)\n-\n-    binary = build_python_path()\n-    cmd = [\n-        binary,\n-        \"-c\",\n-        \"import sys; \"\n-        \"print(f'{sys.version_info.major}.{sys.version_info.minor}')\",\n-    ]\n-    version = subprocess.check_output(cmd, encoding=\"utf-8\").strip()\n-\n-    log(\"\ud83c\udf89\", f\"{binary} {version}\")\n-\n-\n-def find_wasi_sdk(config):\n-    \"\"\"Find the path to the WASI SDK.\"\"\"\n-    wasi_sdk_path = None\n-    wasi_sdk_version = config[\"targets\"][\"wasi-sdk\"]\n-\n-    if wasi_sdk_path_env_var := os.environ.get(\"WASI_SDK_PATH\"):\n-        wasi_sdk_path = pathlib.Path(wasi_sdk_path_env_var)\n-    else:\n-        opt_path = pathlib.Path(\"/opt\")\n-        # WASI SDK versions have a ``.0`` suffix, but it's a constant; the WASI SDK team\n-        # has said they don't plan to ever do a point release and all of their Git tags\n-        # lack the ``.0`` suffix.\n-        # Starting with WASI SDK 23, the tarballs went from containing a directory named\n-        # ``wasi-sdk-{WASI_SDK_VERSION}.0`` to e.g.\n-        # ``wasi-sdk-{WASI_SDK_VERSION}.0-x86_64-linux``.\n-        potential_sdks = [\n-            path\n-            for path in opt_path.glob(f\"wasi-sdk-{wasi_sdk_version}.0*\")\n-            if path.is_dir()\n-        ]\n-        if len(potential_sdks) == 1:\n-            wasi_sdk_path = potential_sdks[0]\n-        elif (default_path := opt_path / \"wasi-sdk\").is_dir():\n-            wasi_sdk_path = default_path\n-\n-    # Starting with WASI SDK 25, a VERSION file is included in the root\n-    # of the SDK directory that we can read to warn folks when they are using\n-    # an unsupported version.\n-    if wasi_sdk_path and (version_file := wasi_sdk_path / \"VERSION\").is_file():\n-        version_details = version_file.read_text(encoding=\"utf-8\")\n-        found_version = version_details.splitlines()[0]\n-        # Make sure there's a trailing dot to avoid false positives if somehow the\n-        # supported version is a prefix of the found version (e.g. `25` and `2567`).\n-        if not found_version.startswith(f\"{wasi_sdk_version}.\"):\n-            major_version = found_version.partition(\".\")[0]\n-            log(\n-                \"\u26a0\ufe0f\",\n-                f\" Found WASI SDK {major_version}, \"\n-                f\"but WASI SDK {wasi_sdk_version} is the supported version\",\n-            )\n-\n-    return wasi_sdk_path\n-\n-\n-def wasi_sdk_env(context):\n-    \"\"\"Calculate environment variables for building with wasi-sdk.\"\"\"\n-    wasi_sdk_path = context.wasi_sdk_path\n-    sysroot = wasi_sdk_path / \"share\" / \"wasi-sysroot\"\n-    env = {\n-        \"CC\": \"clang\",\n-        \"CPP\": \"clang-cpp\",\n-        \"CXX\": \"clang++\",\n-        \"AR\": \"llvm-ar\",\n-        \"RANLIB\": \"ranlib\",\n-    }\n-\n-    for env_var, binary_name in list(env.items()):\n-        env[env_var] = os.fsdecode(wasi_sdk_path / \"bin\" / binary_name)\n-\n-    if not wasi_sdk_path.name.startswith(\"wasi-sdk\"):\n-        for compiler in [\"CC\", \"CPP\", \"CXX\"]:\n-            env[compiler] += f\" --sysroot={sysroot}\"\n-\n-    env[\"PKG_CONFIG_PATH\"] = \"\"\n-    env[\"PKG_CONFIG_LIBDIR\"] = os.pathsep.join(\n-        map(\n-            os.fsdecode,\n-            [sysroot / \"lib\" / \"pkgconfig\", sysroot / \"share\" / \"pkgconfig\"],\n-        )\n-    )\n-    env[\"PKG_CONFIG_SYSROOT_DIR\"] = os.fsdecode(sysroot)\n-\n-    env[\"WASI_SDK_PATH\"] = os.fsdecode(wasi_sdk_path)\n-    env[\"WASI_SYSROOT\"] = os.fsdecode(sysroot)\n-\n-    env[\"PATH\"] = os.pathsep.join([\n-        os.fsdecode(wasi_sdk_path / \"bin\"),\n-        os.environ[\"PATH\"],\n-    ])\n-\n-    return env\n-\n-\n-@subdir(lambda context: CROSS_BUILD_DIR / context.host_triple, clean_ok=True)\n-def configure_wasi_python(context, working_dir):\n-    \"\"\"Configure the WASI/host build.\"\"\"\n-    if not context.wasi_sdk_path or not context.wasi_sdk_path.exists():\n-        raise ValueError(\n-            \"WASI-SDK not found; \"\n-            \"download from \"\n-            \"https://github.com/WebAssembly/wasi-sdk and/or \"\n-            \"specify via $WASI_SDK_PATH or --wasi-sdk\"\n-        )\n-\n-    config_site = os.fsdecode(HERE / \"config.site-wasm32-wasi\")\n-\n-    wasi_build_dir = working_dir.relative_to(CHECKOUT)\n-\n-    python_build_dir = BUILD_DIR / \"build\"\n-    lib_dirs = list(python_build_dir.glob(\"lib.*\"))\n-    assert len(lib_dirs) == 1, (\n-        f\"Expected a single lib.* directory in {python_build_dir}\"\n-    )\n-    lib_dir = os.fsdecode(lib_dirs[0])\n-    python_version = lib_dir.rpartition(\"-\")[-1]\n-    sysconfig_data_dir = (\n-        f\"{wasi_build_dir}/build/lib.wasi-wasm32-{python_version}\"\n-    )\n-\n-    # Use PYTHONPATH to include sysconfig data which must be anchored to the\n-    # WASI guest's `/` directory.\n-    args = {\n-        \"PYTHONPATH\": f\"/{sysconfig_data_dir}\",\n-        \"PYTHON_WASM\": working_dir / \"python.wasm\",\n-    }\n-    # Check dynamically for wasmtime in case it was specified manually via\n-    # `--host-runner`.\n-    if WASMTIME_HOST_RUNNER_VAR in context.host_runner:\n-        if wasmtime := shutil.which(\"wasmtime\"):\n-            args[WASMTIME_VAR_NAME] = wasmtime\n-        else:\n-            raise FileNotFoundError(\n-                \"wasmtime not found; download from \"\n-                \"https://github.com/bytecodealliance/wasmtime\"\n-            )\n-    host_runner = context.host_runner.format_map(args)\n-    env_additions = {\"CONFIG_SITE\": config_site, \"HOSTRUNNER\": host_runner}\n-    build_python = os.fsdecode(build_python_path())\n-    # The path to `configure` MUST be relative, else `python.wasm` is unable\n-    # to find the stdlib due to Python not recognizing that it's being\n-    # executed from within a checkout.\n-    configure = [\n-        os.path.relpath(CHECKOUT / \"configure\", working_dir),\n-        f\"--host={context.host_triple}\",\n-        f\"--build={BUILD_DIR.name}\",\n-        f\"--with-build-python={build_python}\",\n-    ]\n-    if build_python_is_pydebug():\n-        configure.append(\"--with-pydebug\")\n-    if context.args:\n-        configure.extend(context.args)\n-    call(\n-        configure,\n-        env=updated_env(env_additions | wasi_sdk_env(context)),\n-        context=context,\n-    )\n-\n-    python_wasm = working_dir / \"python.wasm\"\n-    exec_script = working_dir / \"python.sh\"\n-    with exec_script.open(\"w\", encoding=\"utf-8\") as file:\n-        file.write(f'#!/bin/sh\\nexec {host_runner} {python_wasm} \"$@\"\\n')\n-    exec_script.chmod(0o755)\n-    log(\"\ud83c\udfc3\", f\"Created {exec_script} (--host-runner)... \")\n-    sys.stdout.flush()\n-\n-\n-@subdir(lambda context: CROSS_BUILD_DIR / context.host_triple)\n-def make_wasi_python(context, working_dir):\n-    \"\"\"Run `make` for the WASI/host build.\"\"\"\n-    call(\n-        [\"make\", \"--jobs\", str(cpu_count()), \"all\"],\n-        env=updated_env(),\n-        context=context,\n-    )\n-\n-    exec_script = working_dir / \"python.sh\"\n-    call([exec_script, \"--version\"], quiet=False)\n-    log(\n-        \"\ud83c\udf89\",\n-        f\"Use `{exec_script.relative_to(context.init_dir)}` \"\n-        \"to run CPython w/ the WASI host specified by --host-runner\",\n-    )\n-\n-\n-def clean_contents(context):\n-    \"\"\"Delete all files created by this script.\"\"\"\n-    if CROSS_BUILD_DIR.exists():\n-        log(\"\ud83e\uddf9\", f\"Deleting {CROSS_BUILD_DIR} ...\")\n-        shutil.rmtree(CROSS_BUILD_DIR)\n-\n-    if LOCAL_SETUP.exists():\n-        if LOCAL_SETUP.read_bytes() == LOCAL_SETUP_MARKER:\n-            log(\"\ud83e\uddf9\", f\"Deleting generated {LOCAL_SETUP} ...\")\n-\n-\n-def build_steps(*steps):\n-    \"\"\"Construct a command from other steps.\"\"\"\n-\n-    def builder(context):\n-        for step in steps:\n-            step(context)\n-\n-    return builder\n-\n-\n-def main():\n-    with (HERE / \"config.toml\").open(\"rb\") as file:\n-        config = tomllib.load(file)\n-    default_wasi_sdk = find_wasi_sdk(config)\n-    default_host_triple = config[\"targets\"][\"host-triple\"]\n-    default_host_runner = (\n-        f\"{WASMTIME_HOST_RUNNER_VAR} run \"\n-        # For setting PYTHONPATH to the sysconfig data directory.\n-        \"--env PYTHONPATH={PYTHONPATH} \"\n-        # Map the checkout to / to load the stdlib from /Lib.\n-        f\"--dir {os.fsdecode(CHECKOUT)}::/ \"\n-        # Flags involving --optimize, --codegen, --debug, --wasm, and --wasi can be kept\n-        # in a config file.\n-        # We are using such a file to act as defaults in case a user wants to override\n-        # only some of the settings themselves, make it easy to modify settings\n-        # post-build so that they immediately apply to the Makefile instead of having to\n-        # regenerate it, and allow for easy copying of the settings for anyone else who\n-        # may want to use them.\n-        f\"--config {os.fsdecode(HERE / 'wasmtime.toml')}\"\n-    )\n-    default_logdir = pathlib.Path(tempfile.gettempdir())\n+if __name__ == \"__main__\":\n+    import pathlib\n+    import runpy\n+    import sys\n \n-    parser = argparse.ArgumentParser()\n-    subcommands = parser.add_subparsers(dest=\"subcommand\")\n-    build = subcommands.add_parser(\"build\", help=\"Build everything\")\n-    configure_build = subcommands.add_parser(\n-        \"configure-build-python\", help=\"Run `configure` for the build Python\"\n-    )\n-    make_build = subcommands.add_parser(\n-        \"make-build-python\", help=\"Run `make` for the build Python\"\n-    )\n-    build_python = subcommands.add_parser(\n-        \"build-python\", help=\"Build the build Python\"\n-    )\n-    configure_host = subcommands.add_parser(\n-        \"configure-host\",\n-        help=\"Run `configure` for the \"\n-        \"host/WASI (pydebug builds \"\n-        \"are inferred from the build \"\n-        \"Python)\",\n-    )\n-    make_host = subcommands.add_parser(\n-        \"make-host\", help=\"Run `make` for the host/WASI\"\n+    print(\n+        \"\u26a0\ufe0f WARNING: This script is deprecated and slated for removal in Python 3.20; \"\n+        \"execute the `Platforms/WASI/` directory instead (i.e. `python Platforms/WASI`)\\n\",\n+        file=sys.stderr,\n     )\n-    build_host = subcommands.add_parser(\n-        \"build-host\", help=\"Build the host/WASI Python\"\n-    )\n-    subcommands.add_parser(\n-        \"clean\", help=\"Delete files and directories created by this script\"\n-    )\n-    for subcommand in (\n-        build,\n-        configure_build,\n-        make_build,\n-        build_python,\n-        configure_host,\n-        make_host,\n-        build_host,\n-    ):\n-        subcommand.add_argument(\n-            \"--quiet\",\n-            action=\"store_true\",\n-            default=False,\n-            dest=\"quiet\",\n-            help=\"Redirect output from subprocesses to a log file\",\n-        )\n-        subcommand.add_argument(\n-            \"--logdir\",\n-            type=pathlib.Path,\n-            default=default_logdir,\n-            help=f\"Directory to store log files; defaults to {default_logdir}\",\n-        )\n-    for subcommand in (\n-        configure_build,\n-        configure_host,\n-        build_python,\n-        build_host,\n-    ):\n-        subcommand.add_argument(\n-            \"--clean\",\n-            action=\"store_true\",\n-            default=False,\n-            dest=\"clean\",\n-            help=\"Delete any relevant directories before building\",\n-        )\n-    for subcommand in (\n-        build,\n-        configure_build,\n-        configure_host,\n-        build_python,\n-        build_host,\n-    ):\n-        subcommand.add_argument(\n-            \"args\", nargs=\"*\", help=\"Extra arguments to pass to `configure`\"\n-        )\n-    for subcommand in build, configure_host, build_host:\n-        subcommand.add_argument(\n-            \"--wasi-sdk\",\n-            type=pathlib.Path,\n-            dest=\"wasi_sdk_path\",\n-            default=default_wasi_sdk,\n-            help=f\"Path to the WASI SDK; defaults to {default_wasi_sdk}\",\n-        )\n-        subcommand.add_argument(\n-            \"--host-runner\",\n-            action=\"store\",\n-            default=default_host_runner,\n-            dest=\"host_runner\",\n-            help=\"Command template for running the WASI host; defaults to \"\n-            f\"`{default_host_runner}`\",\n-        )\n-    for subcommand in build, configure_host, make_host, build_host:\n-        subcommand.add_argument(\n-            \"--host-triple\",\n-            action=\"store\",\n-            default=default_host_triple,\n-            help=\"The target triple for the WASI host build; \"\n-            f\"defaults to {default_host_triple}\",\n-        )\n-\n-    context = parser.parse_args()\n-    context.init_dir = pathlib.Path().absolute()\n \n-    build_build_python = build_steps(configure_build_python, make_build_python)\n-    build_wasi_python = build_steps(configure_wasi_python, make_wasi_python)\n+    checkout = pathlib.Path(__file__).parent.parent.parent.parent\n \n-    dispatch = {\n-        \"configure-build-python\": configure_build_python,\n-        \"make-build-python\": make_build_python,\n-        \"build-python\": build_build_python,\n-        \"configure-host\": configure_wasi_python,\n-        \"make-host\": make_wasi_python,\n-        \"build-host\": build_wasi_python,\n-        \"build\": build_steps(build_build_python, build_wasi_python),\n-        \"clean\": clean_contents,\n-    }\n-    dispatch[context.subcommand](context)\n-\n-\n-if __name__ == \"__main__\":\n-    main()\n+    runpy.run_path(checkout / \"Platforms\" / \"WASI\", run_name=\"__main__\")",
      "comment": "> But if I just did a rename it would break the buildbots and leave the repo after this commit in a somewhat broken state for anyone else building.\n\nI believe the point was that this wouldn't be a problem with natural (non-squash merges) as those would preserve carefully curated intermediate commits while allowing fast-forward to skip triggering builds for them...",
      "comment_id": 2705893999,
      "user": "webknjaz",
      "created_at": "2026-01-19T19:38:32Z",
      "url": "https://github.com/python/cpython/pull/143942#discussion_r2705893999"
    },
    {
      "repo": "python/cpython",
      "pr_number": 144031,
      "file_path": "Lib/test/test_functools.py",
      "line": 2164,
      "side": "RIGHT",
      "diff_hunk": "@@ -2157,6 +2157,11 @@ def fib(n):\n                 with self.assertRaises(RecursionError):\n                     fib(support.exceeds_recursion_limit())\n \n+    def test_lru_checks_arg_is_callable(self):\n+        with self.assertRaises(TypeError) as te:\n+            self.module.lru_cache(1)('hello')\n+        self.assertIn(\"the first argument must be callable\", str(te.exception))\n+",
      "comment": "```suggestion\r\n        with self.assertRaisesRegex(\r\n            TypeError,\r\n            \"the first argument must be callable\",\r\n        ):\r\n            self.module.lru_cache(1)('hello')\r\n\r\n```",
      "comment_id": 2704877728,
      "user": "sobolevn",
      "created_at": "2026-01-19T13:56:45Z",
      "url": "https://github.com/python/cpython/pull/144031#discussion_r2704877728"
    },
    {
      "repo": "python/cpython",
      "pr_number": 144031,
      "file_path": "Lib/functools.py",
      "line": 605,
      "side": "RIGHT",
      "diff_hunk": "@@ -602,6 +602,9 @@ def decorating_function(user_function):\n     return decorating_function\n \n def _lru_cache_wrapper(user_function, maxsize, typed, _CacheInfo):\n+    if not callable(user_function):",
      "comment": "Can we move this check in lru_wrapper directly? it should only be done in def decorating_function() I think.\n\nWe are doing the check twice otherwise (when we do not call the decorator with ())\n",
      "comment_id": 2705560715,
      "user": "picnixz",
      "created_at": "2026-01-19T17:03:48Z",
      "url": "https://github.com/python/cpython/pull/144031#discussion_r2705560715"
    },
    {
      "repo": "python/cpython",
      "pr_number": 144031,
      "file_path": "Lib/functools.py",
      "line": 605,
      "side": "RIGHT",
      "diff_hunk": "@@ -602,6 +602,9 @@ def decorating_function(user_function):\n     return decorating_function\n \n def _lru_cache_wrapper(user_function, maxsize, typed, _CacheInfo):\n+    if not callable(user_function):",
      "comment": "that means we *are* doing the \"is it callable\" already twice then. in practice, cpython never uses the pure python version of this code, and the \"is it callable\" check happens in the C version of `_lru_cache_wrapper`. my change is just mirroring what the C code is already doing.\r\n\r\nunless there is a huge push for it, I kind of don't want to do a big refactoring of the C/Python code here.",
      "comment_id": 2707712254,
      "user": "cfbolz",
      "created_at": "2026-01-20T10:23:08Z",
      "url": "https://github.com/python/cpython/pull/144031#discussion_r2707712254"
    },
    {
      "repo": "python/cpython",
      "pr_number": 144031,
      "file_path": "Lib/functools.py",
      "line": 605,
      "side": "RIGHT",
      "diff_hunk": "@@ -602,6 +602,9 @@ def decorating_function(user_function):\n     return decorating_function\n \n def _lru_cache_wrapper(user_function, maxsize, typed, _CacheInfo):\n+    if not callable(user_function):",
      "comment": "There is no big refactoring actually. It is just about moving your check in another function (a few lines above). Considering the LRU wrapper cache function is already an implementation detail, I expect the caller to check for callability, not the wrapper itself. ",
      "comment_id": 2709474183,
      "user": "picnixz",
      "created_at": "2026-01-20T17:57:10Z",
      "url": "https://github.com/python/cpython/pull/144031#discussion_r2709474183"
    },
    {
      "repo": "python/cpython",
      "pr_number": 144031,
      "file_path": "Lib/functools.py",
      "line": 605,
      "side": "RIGHT",
      "diff_hunk": "@@ -602,6 +602,9 @@ def decorating_function(user_function):\n     return decorating_function\n \n def _lru_cache_wrapper(user_function, maxsize, typed, _CacheInfo):\n+    if not callable(user_function):",
      "comment": "I would definitely be a bigger change. if we move it to the caller, we would also have to touch the [C code](https://github.com/python/cpython/blob/main/Modules/_functoolsmodule.c#L1605C1-L1609C6) in `_funtoolsmodule.c`:\r\n\r\n```c\r\n    if (!PyCallable_Check(func)) {\r\n        PyErr_SetString(PyExc_TypeError,\r\n                        \"the first argument must be callable\");\r\n        return NULL;\r\n    }\r\n```\r\n\r\nmy goal in this PR is to get the behaviour of the C-version of `_lru_cache_wrapper` and the Python version of the same function into alignment (which they should have been from the start).",
      "comment_id": 2712158444,
      "user": "cfbolz",
      "created_at": "2026-01-21T11:31:21Z",
      "url": "https://github.com/python/cpython/pull/144031#discussion_r2712158444"
    },
    {
      "repo": "python/cpython",
      "pr_number": 141128,
      "file_path": "Lib/test/test_base64.py",
      "line": 397,
      "side": "LEFT",
      "diff_hunk": "@@ -394,10 +399,6 @@ def test_b32decode_casefold(self):\n         self.assertRaises(binascii.Error, base64.b32decode, b'me======')\n         self.assertRaises(binascii.Error, base64.b32decode, 'me======')\n \n-        # Mapping zero and one",
      "comment": "Is there a reason these tests are removed? I didn't see a mention of `b32decode` behavior changes in the changelog.",
      "comment_id": 2499208699,
      "user": "sethmlarson",
      "created_at": "2025-11-06T14:39:16Z",
      "url": "https://github.com/python/cpython/pull/141128#discussion_r2499208699"
    },
    {
      "repo": "python/cpython",
      "pr_number": 141128,
      "file_path": "Lib/test/test_base64.py",
      "line": 397,
      "side": "LEFT",
      "diff_hunk": "@@ -394,10 +399,6 @@ def test_b32decode_casefold(self):\n         self.assertRaises(binascii.Error, base64.b32decode, b'me======')\n         self.assertRaises(binascii.Error, base64.b32decode, 'me======')\n \n-        # Mapping zero and one",
      "comment": "Do not mind. This is a clean up after other change. I already have cleaned up this in other PR.",
      "comment_id": 2500866602,
      "user": "serhiy-storchaka",
      "created_at": "2025-11-06T21:05:46Z",
      "url": "https://github.com/python/cpython/pull/141128#discussion_r2500866602"
    }
  ]
}