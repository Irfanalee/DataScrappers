{
  "repo": "apache/airflow",
  "scraped_at": "2026-02-03T14:17:07.132927",
  "stats": {
    "total_comments": 2283,
    "filtered": {
      "not_python": 575,
      "too_short": 552,
      "too_long": 9,
      "skip_pattern:nit:": 6,
      "no_diff_hunk": 66
    },
    "kept": 1075
  },
  "examples": [
    {
      "repo": "apache/airflow",
      "pr_number": 59688,
      "file_path": "providers/microsoft/azure/src/airflow/providers/microsoft/azure/hooks/msgraph.py",
      "line": 66,
      "side": "RIGHT",
      "diff_hunk": "@@ -58,6 +58,12 @@\n     from kiota_abstractions.serialization import ParsableFactory\n \n     from airflow.providers.common.compat.sdk import Connection\n+    from airflow.sdk._shared.secrets_masker import redact\n+else:\n+    try:\n+        from airflow.sdk._shared.secrets_masker import redact\n+    except ImportError:\n+        from airflow.sdk.execution_time.secrets_masker import redact",
      "comment": "Hmm, a provider is not supposed to import from an underscore module (private), or from `execution_time`. Maybe we should expose `secrets_masker` at the top sdk namespace like `timezone`?",
      "comment_id": 2638562944,
      "user": "uranusjr",
      "created_at": "2025-12-22T04:02:17Z",
      "url": "https://github.com/apache/airflow/pull/59688#discussion_r2638562944"
    },
    {
      "repo": "apache/airflow",
      "pr_number": 59688,
      "file_path": "providers/microsoft/azure/src/airflow/providers/microsoft/azure/hooks/msgraph.py",
      "line": 64,
      "side": "RIGHT",
      "diff_hunk": "@@ -58,6 +58,12 @@\n     from kiota_abstractions.serialization import ParsableFactory\n \n     from airflow.providers.common.compat.sdk import Connection\n+    from airflow.sdk._shared.secrets_masker import redact\n+else:\n+    try:\n+        from airflow.sdk._shared.secrets_masker import redact",
      "comment": "I do not like this. Can't we use the `airflow.providers.common.compat.sdk ` module here? Mind you that you might need to re export `redact` in: `task-sdk/src/airflow/sdk/log.py` and use that path instead.",
      "comment_id": 2638817115,
      "user": "amoghrajesh",
      "created_at": "2025-12-22T06:28:10Z",
      "url": "https://github.com/apache/airflow/pull/59688#discussion_r2638817115"
    },
    {
      "repo": "apache/airflow",
      "pr_number": 59688,
      "file_path": "providers/microsoft/azure/src/airflow/providers/microsoft/azure/hooks/msgraph.py",
      "line": 64,
      "side": "RIGHT",
      "diff_hunk": "@@ -58,6 +58,12 @@\n     from kiota_abstractions.serialization import ParsableFactory\n \n     from airflow.providers.common.compat.sdk import Connection\n+    from airflow.sdk._shared.secrets_masker import redact\n+else:\n+    try:\n+        from airflow.sdk._shared.secrets_masker import redact",
      "comment": "I wasn't aware of `airflow.providers.common.compat.sdk`. I can use this.",
      "comment_id": 2638866083,
      "user": "sunank200",
      "created_at": "2025-12-22T06:55:57Z",
      "url": "https://github.com/apache/airflow/pull/59688#discussion_r2638866083"
    },
    {
      "repo": "apache/airflow",
      "pr_number": 59688,
      "file_path": "providers/microsoft/azure/src/airflow/providers/microsoft/azure/hooks/msgraph.py",
      "line": 64,
      "side": "RIGHT",
      "diff_hunk": "@@ -58,6 +58,12 @@\n     from kiota_abstractions.serialization import ParsableFactory\n \n     from airflow.providers.common.compat.sdk import Connection\n+    from airflow.sdk._shared.secrets_masker import redact\n+else:\n+    try:\n+        from airflow.sdk._shared.secrets_masker import redact",
      "comment": "I do not think we should allow `_shared` (private symlink) imports in providers. Mind working on a precommit for it?",
      "comment_id": 2638870677,
      "user": "amoghrajesh",
      "created_at": "2025-12-22T06:58:27Z",
      "url": "https://github.com/apache/airflow/pull/59688#discussion_r2638870677"
    },
    {
      "repo": "apache/airflow",
      "pr_number": 59688,
      "file_path": "providers/microsoft/azure/src/airflow/providers/microsoft/azure/hooks/msgraph.py",
      "line": 64,
      "side": "RIGHT",
      "diff_hunk": "@@ -58,6 +58,12 @@\n     from kiota_abstractions.serialization import ParsableFactory\n \n     from airflow.providers.common.compat.sdk import Connection\n+    from airflow.sdk._shared.secrets_masker import redact\n+else:\n+    try:\n+        from airflow.sdk._shared.secrets_masker import redact",
      "comment": "Yes. Thanks right. I can create a pre-commit for this",
      "comment_id": 2638884959,
      "user": "sunank200",
      "created_at": "2025-12-22T07:06:28Z",
      "url": "https://github.com/apache/airflow/pull/59688#discussion_r2638884959"
    },
    {
      "repo": "apache/airflow",
      "pr_number": 59688,
      "file_path": "providers/microsoft/azure/src/airflow/providers/microsoft/azure/hooks/msgraph.py",
      "line": 66,
      "side": "RIGHT",
      "diff_hunk": "@@ -58,6 +58,12 @@\n     from kiota_abstractions.serialization import ParsableFactory\n \n     from airflow.providers.common.compat.sdk import Connection\n+    from airflow.sdk._shared.secrets_masker import redact\n+else:\n+    try:\n+        from airflow.sdk._shared.secrets_masker import redact\n+    except ImportError:\n+        from airflow.sdk.execution_time.secrets_masker import redact",
      "comment": "Compact for provider distribution was failing initially.",
      "comment_id": 2639196726,
      "user": "sunank200",
      "created_at": "2025-12-22T09:16:46Z",
      "url": "https://github.com/apache/airflow/pull/59688#discussion_r2639196726"
    },
    {
      "repo": "apache/airflow",
      "pr_number": 59688,
      "file_path": "task-sdk/src/airflow/sdk/log.py",
      "line": 50,
      "side": "RIGHT",
      "diff_hunk": "@@ -37,7 +37,20 @@\n     from airflow.sdk.types import Logger, RuntimeTaskInstanceProtocol as RuntimeTI\n \n \n-__all__ = [\"configure_logging\", \"reset_logging\", \"mask_secret\"]\n+def redact(\n+    value: Any, name: str | None = None, max_depth: int | None = None, replacement: str = \"***\"\n+) -> Any:\n+    \"\"\"\n+    Redact any secrets found in ``value`` with the given replacement.\n+\n+    This is a re-export from airflow.sdk._shared.secrets_masker for provider compatibility.\n+    \"\"\"\n+    from airflow.sdk._shared.secrets_masker import redact as _redact\n+\n+    return _redact(value, name, max_depth, replacement)",
      "comment": "Can we not just re-export? Why do we need the wrapper?\n\n```\nfrom airflow.sdk._shared.secrets_masker import redact as _redact\n```\n\nShould be enough",
      "comment_id": 2642122108,
      "user": "amoghrajesh",
      "created_at": "2025-12-23T06:23:45Z",
      "url": "https://github.com/apache/airflow/pull/59688#discussion_r2642122108"
    },
    {
      "repo": "apache/airflow",
      "pr_number": 59688,
      "file_path": "providers/common/compat/src/airflow/providers/common/compat/sdk.py",
      "line": 93,
      "side": "RIGHT",
      "diff_hunk": "@@ -90,6 +90,7 @@\n         TaskDeferred as TaskDeferred,\n         XComNotFound as XComNotFound,\n     )\n+    from airflow.sdk.log import redact as redact",
      "comment": "```suggestion\n    from airflow.sdk.log import redact\n```",
      "comment_id": 2642392323,
      "user": "amoghrajesh",
      "created_at": "2025-12-23T08:35:30Z",
      "url": "https://github.com/apache/airflow/pull/59688#discussion_r2642392323"
    },
    {
      "repo": "apache/airflow",
      "pr_number": 59688,
      "file_path": "task-sdk/src/airflow/sdk/log.py",
      "line": 40,
      "side": "RIGHT",
      "diff_hunk": "@@ -37,7 +37,7 @@\n     from airflow.sdk.types import Logger, RuntimeTaskInstanceProtocol as RuntimeTI\n \n \n-__all__ = [\"configure_logging\", \"reset_logging\", \"mask_secret\"]\n+from airflow.sdk._shared.secrets_masker import redact",
      "comment": "We will likely need a `as redact` or it may complain with `noqa`",
      "comment_id": 2642395382,
      "user": "amoghrajesh",
      "created_at": "2025-12-23T08:36:31Z",
      "url": "https://github.com/apache/airflow/pull/59688#discussion_r2642395382"
    },
    {
      "repo": "apache/airflow",
      "pr_number": 59688,
      "file_path": "providers/common/compat/src/airflow/providers/common/compat/sdk.py",
      "line": 93,
      "side": "RIGHT",
      "diff_hunk": "@@ -90,6 +90,7 @@\n         TaskDeferred as TaskDeferred,\n         XComNotFound as XComNotFound,\n     )\n+    from airflow.sdk.log import redact as redact",
      "comment": "We need as redact else add # noqa: F401. So keeping it as it is.",
      "comment_id": 2642525814,
      "user": "sunank200",
      "created_at": "2025-12-23T09:19:13Z",
      "url": "https://github.com/apache/airflow/pull/59688#discussion_r2642525814"
    },
    {
      "repo": "apache/airflow",
      "pr_number": 59688,
      "file_path": "task-sdk/src/airflow/sdk/log.py",
      "line": 40,
      "side": "RIGHT",
      "diff_hunk": "@@ -37,7 +37,7 @@\n     from airflow.sdk.types import Logger, RuntimeTaskInstanceProtocol as RuntimeTI\n \n \n-__all__ = [\"configure_logging\", \"reset_logging\", \"mask_secret\"]\n+from airflow.sdk._shared.secrets_masker import redact",
      "comment": "Would this not need `as redact`? We are re-exporting here",
      "comment_id": 2642652004,
      "user": "amoghrajesh",
      "created_at": "2025-12-23T10:03:28Z",
      "url": "https://github.com/apache/airflow/pull/59688#discussion_r2642652004"
    },
    {
      "repo": "apache/airflow",
      "pr_number": 59688,
      "file_path": "providers/common/compat/src/airflow/providers/common/compat/sdk.py",
      "line": 94,
      "side": "RIGHT",
      "diff_hunk": "@@ -90,6 +90,7 @@\n         TaskDeferred as TaskDeferred,\n         XComNotFound as XComNotFound,\n     )\n+    from airflow.sdk.log import redact as redact\n     from airflow.sdk.observability.stats import Stats  # noqa: F401",
      "comment": "Unrelate to this PR, could you fix the pattern on this line too to get rid of noqa?",
      "comment_id": 2642653345,
      "user": "amoghrajesh",
      "created_at": "2025-12-23T10:03:58Z",
      "url": "https://github.com/apache/airflow/pull/59688#discussion_r2642653345"
    },
    {
      "repo": "apache/airflow",
      "pr_number": 59688,
      "file_path": "task-sdk/src/airflow/sdk/log.py",
      "line": 40,
      "side": "RIGHT",
      "diff_hunk": "@@ -37,7 +37,7 @@\n     from airflow.sdk.types import Logger, RuntimeTaskInstanceProtocol as RuntimeTI\n \n \n-__all__ = [\"configure_logging\", \"reset_logging\", \"mask_secret\"]\n+from airflow.sdk._shared.secrets_masker import redact",
      "comment": "No `redact` is used in line 67 in `mask_logs` method. That is why it is not needed here.",
      "comment_id": 2643398572,
      "user": "sunank200",
      "created_at": "2025-12-23T14:30:21Z",
      "url": "https://github.com/apache/airflow/pull/59688#discussion_r2643398572"
    },
    {
      "repo": "apache/airflow",
      "pr_number": 61287,
      "file_path": "providers/fab/src/airflow/providers/fab/auth_manager/views/auth_oauth.py",
      "line": 78,
      "side": "RIGHT",
      "diff_hunk": "@@ -0,0 +1,85 @@\n+# Licensed to the Apache Software Foundation (ASF) under one\n+# or more contributor license agreements.  See the NOTICE file\n+# distributed with this work for additional information\n+# regarding copyright ownership.  The ASF licenses this file\n+# to you under the Apache License, Version 2.0 (the\n+# \"License\"); you may not use this file except in compliance\n+# with the License.  You may obtain a copy of the License at\n+#\n+#   http://www.apache.org/licenses/LICENSE-2.0\n+#\n+# Unless required by applicable law or agreed to in writing,\n+# software distributed under the License is distributed on an\n+# \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+# KIND, either express or implied.  See the License for the\n+# specific language governing permissions and limitations\n+# under the License.\n+\n+\"\"\"Custom OAuth authentication view to fix session timing race condition.\"\"\"\n+\n+from __future__ import annotations\n+\n+import logging\n+\n+from flask import session\n+from flask_appbuilder.security.views import AuthOAuthView\n+\n+from airflow.configuration import conf\n+\n+log = logging.getLogger(__name__)\n+\n+\n+class CustomAuthOAuthView(AuthOAuthView):\n+    \"\"\"\n+    Custom OAuth authentication view that ensures session is committed before redirect.\n+\n+    Fixes issue #57981 where UI requests fail with 401 during OAuth flow because\n+    the Flask session is not yet committed when the redirect response is sent.\n+    \"\"\"\n+\n+    def oauth_authorized(self, provider):\n+        \"\"\"\n+        OAuth callback handler that explicitly commits session before redirect.\n+\n+        This method overrides the parent's oauth_authorized to ensure that the\n+        Flask session (containing OAuth tokens and user authentication) is fully\n+        committed to the session backend (cookie or database) before redirecting\n+        the user to the UI.\n+\n+        This prevents the race condition where the UI makes API requests before\n+        the session is available, causing temporary 401 errors during login.\n+\n+        Args:\n+            provider: OAuth provider name (e.g., 'azure', 'google', 'github')\n+\n+        Returns:\n+            Flask response object (redirect to original URL or home page)\n+        \"\"\"\n+        log.debug(\"OAuth callback received for provider: %s\", provider)\n+\n+        # Call parent's OAuth callback handling\n+        # This processes the OAuth response, authenticates the user, and sets session data\n+        response = super().oauth_authorized(provider)\n+\n+        # Explicitly commit the Flask session to ensure it's persisted\n+        # This is critical for the race condition fix\n+        session_backend = conf.get(\"fab\", \"SESSION_BACKEND\", fallback=\"securecookie\")\n+\n+        if session_backend == \"database\":\n+            # For database sessions, Flask-Session automatically handles commit\n+            # but we explicitly mark the session as modified to ensure it's saved\n+            session.modified = True\n+            log.debug(\"Marked session as modified for database backend\")\n+        else:\n+            # For securecookie sessions, session is automatically encoded into cookie\n+            # but we still mark it as modified to ensure fresh encoding\n+            session.modified = True\n+            log.debug(\"Marked session as modified for securecookie backend\")\n+",
      "comment": "Seems like the branching here is redundant. Is logging the only reason for doing this? If that is the case, I would recommend the following in place of lines 68-77:\n\n```\nsession.modified = True\nlog.debug (\"Marked session as modified for %s backend\", session_backend)\n```",
      "comment_id": 2752088108,
      "user": "SameerMesiah97",
      "created_at": "2026-02-01T23:05:01Z",
      "url": "https://github.com/apache/airflow/pull/61287#discussion_r2752088108"
    },
    {
      "repo": "apache/airflow",
      "pr_number": 61287,
      "file_path": "providers/fab/src/airflow/providers/fab/auth_manager/views/auth_oauth.py",
      "line": 84,
      "side": "RIGHT",
      "diff_hunk": "@@ -0,0 +1,85 @@\n+# Licensed to the Apache Software Foundation (ASF) under one\n+# or more contributor license agreements.  See the NOTICE file\n+# distributed with this work for additional information\n+# regarding copyright ownership.  The ASF licenses this file\n+# to you under the Apache License, Version 2.0 (the\n+# \"License\"); you may not use this file except in compliance\n+# with the License.  You may obtain a copy of the License at\n+#\n+#   http://www.apache.org/licenses/LICENSE-2.0\n+#\n+# Unless required by applicable law or agreed to in writing,\n+# software distributed under the License is distributed on an\n+# \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+# KIND, either express or implied.  See the License for the\n+# specific language governing permissions and limitations\n+# under the License.\n+\n+\"\"\"Custom OAuth authentication view to fix session timing race condition.\"\"\"\n+\n+from __future__ import annotations\n+\n+import logging\n+\n+from flask import session\n+from flask_appbuilder.security.views import AuthOAuthView\n+\n+from airflow.configuration import conf\n+\n+log = logging.getLogger(__name__)\n+\n+\n+class CustomAuthOAuthView(AuthOAuthView):\n+    \"\"\"\n+    Custom OAuth authentication view that ensures session is committed before redirect.\n+\n+    Fixes issue #57981 where UI requests fail with 401 during OAuth flow because\n+    the Flask session is not yet committed when the redirect response is sent.\n+    \"\"\"\n+\n+    def oauth_authorized(self, provider):\n+        \"\"\"\n+        OAuth callback handler that explicitly commits session before redirect.\n+\n+        This method overrides the parent's oauth_authorized to ensure that the\n+        Flask session (containing OAuth tokens and user authentication) is fully\n+        committed to the session backend (cookie or database) before redirecting\n+        the user to the UI.\n+\n+        This prevents the race condition where the UI makes API requests before\n+        the session is available, causing temporary 401 errors during login.\n+\n+        Args:\n+            provider: OAuth provider name (e.g., 'azure', 'google', 'github')\n+\n+        Returns:\n+            Flask response object (redirect to original URL or home page)\n+        \"\"\"\n+        log.debug(\"OAuth callback received for provider: %s\", provider)\n+\n+        # Call parent's OAuth callback handling\n+        # This processes the OAuth response, authenticates the user, and sets session data\n+        response = super().oauth_authorized(provider)\n+\n+        # Explicitly commit the Flask session to ensure it's persisted\n+        # This is critical for the race condition fix\n+        session_backend = conf.get(\"fab\", \"SESSION_BACKEND\", fallback=\"securecookie\")\n+\n+        if session_backend == \"database\":\n+            # For database sessions, Flask-Session automatically handles commit\n+            # but we explicitly mark the session as modified to ensure it's saved\n+            session.modified = True\n+            log.debug(\"Marked session as modified for database backend\")\n+        else:\n+            # For securecookie sessions, session is automatically encoded into cookie\n+            # but we still mark it as modified to ensure fresh encoding\n+            session.modified = True\n+            log.debug(\"Marked session as modified for securecookie backend\")\n+\n+        # The session will be saved when this request completes, before the redirect\n+        # response is sent to the client. Flask's session interface handles this\n+        # automatically via the after_request handler\n+\n+        log.debug(\"OAuth authentication completed successfully for provider: %s\", provider)\n+",
      "comment": "Looks like this message will be logged even when when authentication fails. `oauth_authorized` might not always raise in that scenario. Perhaps, this would be more accurate:\n\n`log.debug(\"OAuth callback handling completed for provider: %s\", provider)`",
      "comment_id": 2752099745,
      "user": "SameerMesiah97",
      "created_at": "2026-02-01T23:18:40Z",
      "url": "https://github.com/apache/airflow/pull/61287#discussion_r2752099745"
    },
    {
      "repo": "apache/airflow",
      "pr_number": 61287,
      "file_path": "providers/fab/tests/unit/fab/auth_manager/views/test_auth_oauth.py",
      "line": 39,
      "side": "RIGHT",
      "diff_hunk": "@@ -0,0 +1,88 @@\n+# Licensed to the Apache Software Foundation (ASF) under one\n+# or more contributor license agreements.  See the NOTICE file\n+# distributed with this work for additional information\n+# regarding copyright ownership.  The ASF licenses this file\n+# to you under the Apache License, Version 2.0 (the\n+# \"License\"); you may not use this file except in compliance\n+# with the License.  You may obtain a copy of the License at\n+#\n+#   http://www.apache.org/licenses/LICENSE-2.0\n+#\n+# Unless required by applicable law or agreed to in writing,\n+# software distributed under the License is distributed on an\n+# \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+# KIND, either express or implied.  See the License for the\n+# specific language governing permissions and limitations\n+# under the License.\n+\n+from __future__ import annotations\n+\n+from unittest import mock\n+\n+from airflow.providers.fab.auth_manager.views.auth_oauth import CustomAuthOAuthView\n+\n+\n+class TestCustomAuthOAuthView:\n+    \"\"\"Test CustomAuthOAuthView.\"\"\"\n+\n+    @mock.patch(\"airflow.providers.fab.auth_manager.views.auth_oauth.conf\")\n+    @mock.patch(\"airflow.providers.fab.auth_manager.views.auth_oauth.session\")\n+    def test_oauth_authorized_marks_session_modified_database_backend(self, mock_session, mock_conf):\n+        \"\"\"Test that oauth_authorized marks session as modified for database backend.\"\"\"\n+        # Setup\n+        mock_conf.get.return_value = \"database\"\n+        view = CustomAuthOAuthView()\n+\n+        # Mock parent's oauth_authorized to return a mock response\n+        with mock.patch.object(\n+            view.__class__.__bases__[0], \"oauth_authorized\", return_value=mock.Mock()\n+        ) as mock_parent:",
      "comment": "Why not patch `AuthOAuthView` instead of `view.__class__.__bases__[0]`? It would be more explicit and less brittle. ",
      "comment_id": 2752134338,
      "user": "SameerMesiah97",
      "created_at": "2026-02-01T23:48:34Z",
      "url": "https://github.com/apache/airflow/pull/61287#discussion_r2752134338"
    },
    {
      "repo": "apache/airflow",
      "pr_number": 61305,
      "file_path": "providers/keycloak/src/airflow/providers/keycloak/auth_manager/keycloak_auth_manager.py",
      "line": 416,
      "side": "RIGHT",
      "diff_hunk": "@@ -412,7 +412,10 @@ def _is_batch_authorized(\n \n     @staticmethod\n     def _get_token_url(server_url, realm):\n-        return f\"{server_url}/realms/{realm}/protocol/openid-connect/token\"\n+        # Normalize server_url by removing trailing slashes to prevent double-slash URLs\n+        # when constructing paths. This is required for Keycloak 26.4+ which strictly\n+        # rejects non-normalized paths with HTTP 400.\n+        return f\"{server_url.rstrip('/')}/realms/{realm}/protocol/openid-connect/token\"",
      "comment": "This comment seems too verbose . It can be  easily inferred from the code that trailing forward  slashes are being removed. I would shorten it to this:\r\n\r\n`# Normalize server_url to avoid double slashes (required for Keycloak 26.4+ strict path validation).`",
      "comment_id": 2751927745,
      "user": "SameerMesiah97",
      "created_at": "2026-02-01T20:44:26Z",
      "url": "https://github.com/apache/airflow/pull/61305#discussion_r2751927745"
    },
    {
      "repo": "apache/airflow",
      "pr_number": 61305,
      "file_path": "providers/keycloak/tests/unit/keycloak/auth_manager/test_keycloak_auth_manager.py",
      "line": 563,
      "side": "RIGHT",
      "diff_hunk": "@@ -559,3 +559,25 @@ def test_get_keycloak_client_with_no_credentials(self, mock_keycloak_openid, aut\n             client_secret_key=\"client_secret\",\n         )\n         assert client == mock_keycloak_openid.return_value\n+\n+    def test_get_token_url_without_trailing_slash(self, auth_manager):",
      "comment": "I like those tests but could be one test with multiple parameter using `@pytest.mark.parametrize`. Can you please do that?",
      "comment_id": 2754725479,
      "user": "vincbeck",
      "created_at": "2026-02-02T14:50:00Z",
      "url": "https://github.com/apache/airflow/pull/61305#discussion_r2754725479"
    },
    {
      "repo": "apache/airflow",
      "pr_number": 61305,
      "file_path": "providers/keycloak/tests/unit/keycloak/auth_manager/test_keycloak_auth_manager.py",
      "line": 563,
      "side": "RIGHT",
      "diff_hunk": "@@ -559,3 +559,25 @@ def test_get_keycloak_client_with_no_credentials(self, mock_keycloak_openid, aut\n             client_secret_key=\"client_secret\",\n         )\n         assert client == mock_keycloak_openid.return_value\n+\n+    def test_get_token_url_without_trailing_slash(self, auth_manager):",
      "comment": "Sure. Thanks for the review. In the most recent commit, I have implemented  4 separate test methods into a single parametrized test",
      "comment_id": 2755081073,
      "user": "y-sudharshan",
      "created_at": "2026-02-02T16:02:52Z",
      "url": "https://github.com/apache/airflow/pull/61305#discussion_r2755081073"
    },
    {
      "repo": "apache/airflow",
      "pr_number": 61311,
      "file_path": "providers/celery/tests/integration/celery/test_celery_executor.py",
      "line": 204,
      "side": "RIGHT",
      "diff_hunk": "@@ -199,8 +199,24 @@ def fake_execute(input: str) -> None:  # Use same parameter name as Airflow 3 ve\n                     TaskInstanceKey(\"id\", \"fail\", \"abc\", 0, -1),\n                 ]\n                 for w in (\n-                    workloads.ExecuteTask.model_construct(ti=ti),\n-                    workloads.ExecuteTask.model_construct(ti=ti.model_copy(update={\"task_id\": \"fail\"})),\n+                    workloads.ExecuteTask.model_construct(\n+                        ti=ti,\n+                        token=\"token\",",
      "comment": "This could work. Maybe we should use `make` rather than `model_construct` so that such as token generation can be from generated and using defaults\n\nhttps://github.com/apache/airflow/blob/40f6ec1c6021f242e80e010043273d2a4cbd4887/airflow-core/src/airflow/executors/workloads.py#L111-L146\n",
      "comment_id": 2751492038,
      "user": "bugraoz93",
      "created_at": "2026-02-01T16:09:53Z",
      "url": "https://github.com/apache/airflow/pull/61311#discussion_r2751492038"
    },
    {
      "repo": "apache/airflow",
      "pr_number": 61311,
      "file_path": "providers/celery/tests/integration/celery/test_celery_executor.py",
      "line": 219,
      "side": "RIGHT",
      "diff_hunk": "@@ -199,8 +199,20 @@ def fake_execute(input: str) -> None:  # Use same parameter name as Airflow 3 ve\n                     TaskInstanceKey(\"id\", \"fail\", \"abc\", 0, -1),\n                 ]\n                 for w in (\n-                    workloads.ExecuteTask.model_construct(ti=ti),\n-                    workloads.ExecuteTask.model_construct(ti=ti.model_copy(update={\"task_id\": \"fail\"})),\n+                    workloads.ExecuteTask.make(\n+                        ti=ti,\n+                        dag_rel_path=\"dag_rel_path\",\n+                        generator=None,\n+                        bundle_info=None,\n+                        sentry_integration=\"\",\n+                    ),\n+                    workloads.ExecuteTask.make(\n+                        ti=ti.model_copy(update={\"task_id\": \"fail\"}),\n+                        dag_rel_path=\"dag_rel_path\",\n+                        generator=None,\n+                        bundle_info=None,\n+                        sentry_integration=\"\",\n+                    ),",
      "comment": "Yes seems like the right thing to do, actual executors do `make` cos `model_construct` bypasses validation: https://docs.pydantic.dev/latest/api/base_model/#pydantic.BaseModel.model_construct\n\n",
      "comment_id": 2752894389,
      "user": "amoghrajesh",
      "created_at": "2026-02-02T07:13:11Z",
      "url": "https://github.com/apache/airflow/pull/61311#discussion_r2752894389"
    },
    {
      "repo": "apache/airflow",
      "pr_number": 61311,
      "file_path": "providers/celery/tests/integration/celery/test_celery_executor.py",
      "line": 219,
      "side": "RIGHT",
      "diff_hunk": "@@ -199,8 +199,20 @@ def fake_execute(input: str) -> None:  # Use same parameter name as Airflow 3 ve\n                     TaskInstanceKey(\"id\", \"fail\", \"abc\", 0, -1),\n                 ]\n                 for w in (\n-                    workloads.ExecuteTask.model_construct(ti=ti),\n-                    workloads.ExecuteTask.model_construct(ti=ti.model_copy(update={\"task_id\": \"fail\"})),\n+                    workloads.ExecuteTask.make(\n+                        ti=ti,\n+                        dag_rel_path=\"dag_rel_path\",\n+                        generator=None,\n+                        bundle_info=None,\n+                        sentry_integration=\"\",\n+                    ),\n+                    workloads.ExecuteTask.make(\n+                        ti=ti.model_copy(update={\"task_id\": \"fail\"}),\n+                        dag_rel_path=\"dag_rel_path\",\n+                        generator=None,\n+                        bundle_info=None,\n+                        sentry_integration=\"\",\n+                    ),",
      "comment": "Nice ! Updated !! \r\n\r\nI have tested it on my local let's see here ",
      "comment_id": 2753862392,
      "user": "Prab-27",
      "created_at": "2026-02-02T11:24:12Z",
      "url": "https://github.com/apache/airflow/pull/61311#discussion_r2753862392"
    },
    {
      "repo": "apache/airflow",
      "pr_number": 61311,
      "file_path": "providers/celery/tests/integration/celery/test_celery_executor.py",
      "line": 132,
      "side": "RIGHT",
      "diff_hunk": "@@ -126,6 +128,17 @@ def teardown_method(self) -> None:\n         db.clear_db_runs()\n         db.clear_db_jobs()\n \n+\n+def setup_dagrun(dag_maker):",
      "comment": "```suggestion\ndef setup_dagrun_with_success_and_fail_tasks(dag_maker):\n```",
      "comment_id": 2754488740,
      "user": "amoghrajesh",
      "created_at": "2026-02-02T14:01:12Z",
      "url": "https://github.com/apache/airflow/pull/61311#discussion_r2754488740"
    },
    {
      "repo": "apache/airflow",
      "pr_number": 61227,
      "file_path": "airflow-core/src/airflow/ti_deps/deps/pool_slots_available_dep.py",
      "line": 58,
      "side": "RIGHT",
      "diff_hunk": "@@ -53,6 +55,21 @@ def _get_dep_statuses(self, ti, session, dep_context=None):\n             )\n             return\n \n+        # Check team compatibility",
      "comment": "When is this actually going to get evaluated? Does this ultimately get called at parse time? Or scheduler/runtime?",
      "comment_id": 2743286564,
      "user": "o-nikolas",
      "created_at": "2026-01-29T19:58:32Z",
      "url": "https://github.com/apache/airflow/pull/61227#discussion_r2743286564"
    },
    {
      "repo": "apache/airflow",
      "pr_number": 61227,
      "file_path": "airflow-core/src/airflow/ti_deps/deps/pool_slots_available_dep.py",
      "line": 58,
      "side": "RIGHT",
      "diff_hunk": "@@ -53,6 +55,21 @@ def _get_dep_statuses(self, ti, session, dep_context=None):\n             )\n             return\n \n+        # Check team compatibility",
      "comment": "Scheduler/runtime. I also wanted to do it at parse time, but because the Dag file processor does not have access to the DB, it makes it more complicated than it seems. This is also what is happening today if a user specifies a non existing pool in their Dag. Parsing goes fine, it only fails at runtime.",
      "comment_id": 2743373508,
      "user": "vincbeck",
      "created_at": "2026-01-29T20:21:39Z",
      "url": "https://github.com/apache/airflow/pull/61227#discussion_r2743373508"
    },
    {
      "repo": "apache/airflow",
      "pr_number": 61227,
      "file_path": "airflow-core/src/airflow/ti_deps/deps/pool_slots_available_dep.py",
      "line": 58,
      "side": "RIGHT",
      "diff_hunk": "@@ -53,6 +55,21 @@ def _get_dep_statuses(self, ti, session, dep_context=None):\n             )\n             return\n \n+        # Check team compatibility",
      "comment": "What is needed from the DB in the dag processor to verify this condition?",
      "comment_id": 2743470558,
      "user": "o-nikolas",
      "created_at": "2026-01-29T20:45:58Z",
      "url": "https://github.com/apache/airflow/pull/61227#discussion_r2743470558"
    },
    {
      "repo": "apache/airflow",
      "pr_number": 61227,
      "file_path": "airflow-core/src/airflow/ti_deps/deps/pool_slots_available_dep.py",
      "line": 58,
      "side": "RIGHT",
      "diff_hunk": "@@ -53,6 +55,21 @@ def _get_dep_statuses(self, ti, session, dep_context=None):\n             )\n             return\n \n+        # Check team compatibility",
      "comment": "Pool -> team association. Given a pool name, I want to know which team is associated to this pool (if any)",
      "comment_id": 2743682815,
      "user": "vincbeck",
      "created_at": "2026-01-29T21:43:59Z",
      "url": "https://github.com/apache/airflow/pull/61227#discussion_r2743682815"
    },
    {
      "repo": "apache/airflow",
      "pr_number": 61273,
      "file_path": "airflow-core/src/airflow/api_fastapi/core_api/routes/ui/grid.py",
      "line": 185,
      "side": "RIGHT",
      "diff_hunk": "@@ -176,12 +178,22 @@ def get_dag_structure(\n         nodes = [task_group_to_dict_grid(x) for x in task_group_sort(latest_dag.task_group)]\n         return [GridNodeResponse(**n) for n in nodes]\n \n-    serdags = session.scalars(\n-        select(SerializedDagModel).where(\n+    # Process and merge the latest serdag first\n+    merged_nodes: list[dict[str, Any]] = []\n+    nodes = [task_group_to_dict_grid(x) for x in task_group_sort(latest_dag.task_group)]\n+    _merge_node_dicts(merged_nodes, nodes)\n+    del latest_dag",
      "comment": "Explicitly deleting `latest_dag` may not effectively free memory since the DAG object could still be referenced elsewhere (e.g., within `merged_nodes` through the task_group_to_dict_grid conversion). Consider removing this line as the expunge operation on line 147 is the primary mechanism for memory management, and explicit deletion provides no guaranteed benefit here.\n```suggestion\n\n```",
      "comment_id": 2748482989,
      "user": "Copilot",
      "created_at": "2026-01-30T23:59:23Z",
      "url": "https://github.com/apache/airflow/pull/61273#discussion_r2748482989"
    },
    {
      "repo": "apache/airflow",
      "pr_number": 61273,
      "file_path": "airflow-core/src/airflow/api_fastapi/core_api/routes/ui/grid.py",
      "line": 222,
      "side": "RIGHT",
      "diff_hunk": "@@ -205,10 +217,11 @@ def get_dag_structure(\n                     include_downstream=include_downstream,\n                     depth=depth,\n                 )\n-            dags.append(filtered_dag)\n-    for dag in dags:\n-        nodes = [task_group_to_dict_grid(x) for x in task_group_sort(dag.task_group)]\n-        _merge_node_dicts(merged_nodes, nodes)\n+            # Merge immediately instead of collecting all DAGs in memory\n+            nodes = [task_group_to_dict_grid(x) for x in task_group_sort(filtered_dag.task_group)]\n+            _merge_node_dicts(merged_nodes, nodes)",
      "comment": "The variable `nodes` is created but not reused after merging. Consider inlining the list comprehension directly into the `_merge_node_dicts` call to avoid creating an intermediate list variable: `_merge_node_dicts(merged_nodes, [task_group_to_dict_grid(x) for x in task_group_sort(filtered_dag.task_group)])`",
      "comment_id": 2748482998,
      "user": "Copilot",
      "created_at": "2026-01-30T23:59:23Z",
      "url": "https://github.com/apache/airflow/pull/61273#discussion_r2748482998"
    },
    {
      "repo": "apache/airflow",
      "pr_number": 61273,
      "file_path": "airflow-core/src/airflow/api_fastapi/core_api/routes/ui/grid.py",
      "line": 206,
      "side": "RIGHT",
      "diff_hunk": "@@ -191,10 +203,10 @@ def get_dag_structure(\n                 .distinct()\n             ),\n         )\n+        .execution_options(yield_per=5)",
      "comment": "This seems like a reasonable balance between not loading too much in memory, but also not doing too many round trips.",
      "comment_id": 2748491872,
      "user": "jedcunningham",
      "created_at": "2026-01-31T00:02:20Z",
      "url": "https://github.com/apache/airflow/pull/61273#discussion_r2748491872"
    },
    {
      "repo": "apache/airflow",
      "pr_number": 61273,
      "file_path": "airflow-core/src/airflow/api_fastapi/core_api/routes/ui/grid.py",
      "line": 210,
      "side": "RIGHT",
      "diff_hunk": "@@ -191,10 +203,10 @@ def get_dag_structure(\n                 .distinct()\n             ),\n         )\n+        .execution_options(yield_per=5)\n     )\n-    merged_nodes: list[dict[str, Any]] = []\n-    dags = [latest_dag]\n-    for serdag in serdags:\n+\n+    for serdag in session.scalars(serdags_query):\n         if serdag:",
      "comment": "No. I was going to leave it, but I should clean it up while I'm in here.",
      "comment_id": 2750647759,
      "user": "jedcunningham",
      "created_at": "2026-02-01T07:02:16Z",
      "url": "https://github.com/apache/airflow/pull/61273#discussion_r2750647759"
    },
    {
      "repo": "apache/airflow",
      "pr_number": 61144,
      "file_path": "providers/oracle/src/airflow/providers/oracle/hooks/oracle.py",
      "line": 92,
      "side": "RIGHT",
      "diff_hunk": "@@ -63,6 +64,43 @@ def _get_first_bool(*vals):\n     return None\n \n \n+def _safe_read(val):\n+    if val is not None and callable(getattr(val, \"read\", None)):\n+        return val.read()\n+    return val\n+\n+\n+def _safe_read_row(row):\n+    if row is not None:\n+        return tuple([_safe_read(value) for value in row])\n+    return row\n+\n+\n+def fetch_all_handler(cursor) -> list[tuple] | None:\n+    \"\"\"Return results for DbApiHook.run().\"\"\"\n+    if not hasattr(cursor, \"description\"):\n+        raise RuntimeError(\n+            \"The database we interact with does not support DBAPI 2.0. Use operator and \"\n+            \"handlers that are specifically designed for your database.\"\n+        )\n+    if cursor.description is not None:\n+        results = [_safe_read_row(row) for row in cursor.fetchall()]\n+        return results\n+    return None\n+\n+\n+def fetch_one_handler(cursor) -> list[tuple] | None:",
      "comment": "```suggestion\ndef fetch_one_handler(cursor) -> tuple | None:\n```",
      "comment_id": 2736567063,
      "user": "henry3260",
      "created_at": "2026-01-28T13:10:16Z",
      "url": "https://github.com/apache/airflow/pull/61144#discussion_r2736567063"
    },
    {
      "repo": "apache/airflow",
      "pr_number": 61144,
      "file_path": "providers/oracle/src/airflow/providers/oracle/hooks/oracle.py",
      "line": 92,
      "side": "RIGHT",
      "diff_hunk": "@@ -63,6 +64,43 @@ def _get_first_bool(*vals):\n     return None\n \n \n+def _safe_read(val):\n+    if val is not None and callable(getattr(val, \"read\", None)):\n+        return val.read()\n+    return val\n+\n+\n+def _safe_read_row(row):\n+    if row is not None:\n+        return tuple([_safe_read(value) for value in row])\n+    return row\n+\n+\n+def fetch_all_handler(cursor) -> list[tuple] | None:\n+    \"\"\"Return results for DbApiHook.run().\"\"\"\n+    if not hasattr(cursor, \"description\"):\n+        raise RuntimeError(\n+            \"The database we interact with does not support DBAPI 2.0. Use operator and \"\n+            \"handlers that are specifically designed for your database.\"\n+        )\n+    if cursor.description is not None:\n+        results = [_safe_read_row(row) for row in cursor.fetchall()]\n+        return results\n+    return None\n+\n+\n+def fetch_one_handler(cursor) -> list[tuple] | None:",
      "comment": "Yeah saw that too, original one is also wrong then in sql module, will fix it there also.",
      "comment_id": 2738059158,
      "user": "dabla",
      "created_at": "2026-01-28T18:53:46Z",
      "url": "https://github.com/apache/airflow/pull/61144#discussion_r2738059158"
    },
    {
      "repo": "apache/airflow",
      "pr_number": 61144,
      "file_path": "providers/common/sql/src/airflow/providers/common/sql/hooks/handlers.py",
      "line": 66,
      "side": "RIGHT",
      "diff_hunk": "@@ -63,7 +63,7 @@ def fetch_all_handler(cursor) -> list[tuple] | None:\n     return None\n \n \n-def fetch_one_handler(cursor) -> list[tuple] | None:\n+def fetch_one_handler(cursor) -> tuple | None:",
      "comment": "Technically this is a breaking change but I assume this is \"right\"!",
      "comment_id": 2738249421,
      "user": "jscheffl",
      "created_at": "2026-01-28T19:29:59Z",
      "url": "https://github.com/apache/airflow/pull/61144#discussion_r2738249421"
    },
    {
      "repo": "apache/airflow",
      "pr_number": 61144,
      "file_path": "providers/common/sql/src/airflow/providers/common/sql/hooks/handlers.py",
      "line": 66,
      "side": "RIGHT",
      "diff_hunk": "@@ -63,7 +63,7 @@ def fetch_all_handler(cursor) -> list[tuple] | None:\n     return None\n \n \n-def fetch_one_handler(cursor) -> list[tuple] | None:\n+def fetch_one_handler(cursor) -> tuple | None:",
      "comment": "Yes, the original type is actually wrong as @henry3260 correctly stated.  Or do you prefer we leave it \"wrong\" in original handlers?",
      "comment_id": 2738262824,
      "user": "dabla",
      "created_at": "2026-01-28T19:32:36Z",
      "url": "https://github.com/apache/airflow/pull/61144#discussion_r2738262824"
    },
    {
      "repo": "apache/airflow",
      "pr_number": 60675,
      "file_path": "providers/celery/src/airflow/providers/celery/executors/celery_executor_utils.py",
      "line": 76,
      "side": "RIGHT",
      "diff_hunk": "@@ -73,7 +73,7 @@\n     # the type as the union of both kinds\n     CommandType = Sequence[str]\n \n-    TaskInstanceInCelery: TypeAlias = tuple[TaskInstanceKey, workloads.All | CommandType, str | None, Task]\n+    TaskInstanceInCelery: TypeAlias = tuple[TaskInstanceKey, workloads.All | CommandType, str | None, str]",
      "comment": "The fourth element is typed as str (non-optional), but self.team_name in the BaseExecutor class is typed as str | None. When the code creates tuples with self.team_name, it's passing a potentially None value where a non-optional str is expected.\n```suggestion\n    TaskInstanceInCelery: TypeAlias = tuple[\n        TaskInstanceKey, workloads.All | CommandType, str | None, str | None\n    ]\n```",
      "comment_id": 2701247925,
      "user": "dheerajturaga",
      "created_at": "2026-01-17T16:07:07Z",
      "url": "https://github.com/apache/airflow/pull/60675#discussion_r2701247925"
    },
    {
      "repo": "apache/airflow",
      "pr_number": 60675,
      "file_path": "providers/celery/tests/integration/celery/test_celery_executor.py",
      "line": 178,
      "side": "RIGHT",
      "diff_hunk": "@@ -152,11 +162,24 @@ def teardown_method(self) -> None:\n     def test_celery_integration(self, broker_url, executor_config):\n         from airflow.providers.celery.executors import celery_executor, celery_executor_utils\n \n-        def fake_execute_workload(command):\n-            if \"fail\" in command:\n-                raise AirflowException(\"fail\")\n-\n-        with _prepare_app(broker_url, execute=fake_execute_workload) as app:\n+        if AIRFLOW_V_3_0_PLUS:\n+            # Airflow 3: execute_workload receives JSON string\n+            def fake_execute(input: str):\n+                \"\"\"Fake execute_workload that parses JSON and fails for tasks with 'fail' in task_id.\"\"\"\n+                import json\n+\n+                workload_dict = json.loads(input)\n+                # Check if this is a task that should fail (task_id contains \"fail\")\n+                if \"ti\" in workload_dict and \"task_id\" in workload_dict[\"ti\"]:\n+                    if \"fail\" in workload_dict[\"ti\"][\"task_id\"]:\n+                        raise AirflowException(\"fail\")\n+        else:\n+            # Airflow 2: execute_command receives command list\n+            def fake_execute(command):",
      "comment": "Mypy requires all conditional function variants to have identical signatures\n```suggestion\n            def fake_execute(command: str):\n```",
      "comment_id": 2701252026,
      "user": "dheerajturaga",
      "created_at": "2026-01-17T16:13:14Z",
      "url": "https://github.com/apache/airflow/pull/60675#discussion_r2701252026"
    },
    {
      "repo": "apache/airflow",
      "pr_number": 60675,
      "file_path": "providers/celery/src/airflow/providers/celery/executors/celery_executor_utils.py",
      "line": 107,
      "side": "RIGHT",
      "diff_hunk": "@@ -102,6 +104,38 @@ def _get_celery_app() -> Celery:\n     return Celery(celery_app_name, config_source=get_celery_configuration())\n \n \n+def create_celery_app(team_conf) -> Celery:",
      "comment": "Do we know the type? If yes, it would be better to have type annotation",
      "comment_id": 2713195448,
      "user": "vincbeck",
      "created_at": "2026-01-21T15:50:41Z",
      "url": "https://github.com/apache/airflow/pull/60675#discussion_r2713195448"
    },
    {
      "repo": "apache/airflow",
      "pr_number": 60675,
      "file_path": "providers/celery/src/airflow/providers/celery/executors/celery_executor.py",
      "line": 220,
      "side": "RIGHT",
      "diff_hunk": "@@ -206,6 +217,8 @@ def _send_tasks_to_celery(self, task_tuples_to_send: Sequence[TaskInstanceInCele\n         chunksize = self._num_tasks_per_send_process(len(task_tuples_to_send))\n         num_processes = min(len(task_tuples_to_send), self._sync_parallelism)\n \n+        # Use ProcessPoolExecutor with team_name instead of task objects to avoid pickling issues.",
      "comment": "The process pool is below and the team name is plumbed through the `task_tuples_to_send` object ",
      "comment_id": 2713772911,
      "user": "o-nikolas",
      "created_at": "2026-01-21T18:12:42Z",
      "url": "https://github.com/apache/airflow/pull/60675#discussion_r2713772911"
    },
    {
      "repo": "apache/airflow",
      "pr_number": 60675,
      "file_path": "providers/celery/src/airflow/providers/celery/cli/celery_command.py",
      "line": 240,
      "side": "RIGHT",
      "diff_hunk": "@@ -218,8 +237,8 @@ def worker(args):\n     autoscale = args.autoscale\n     skip_serve_logs = args.skip_serve_logs\n \n-    if autoscale is None and conf.has_option(\"celery\", \"worker_autoscale\"):\n-        autoscale = conf.get(\"celery\", \"worker_autoscale\")\n+    if autoscale is None and config.has_option(\"celery\", \"worker_autoscale\"):",
      "comment": "@o-nikolas, this is failing backward compatibility. In Airflow 3.1.3, ExecutorConf exists but lacks critical methods like has_option, getsection, etc. were added in commit 5ba75af409 for Airflow 3.2+\n```\n    if autoscale is None and config.has_option(\"celery\", \"worker_autoscale\"):\nAttributeError: 'ExecutorConf' object has no attribute 'has_option'\n```",
      "comment_id": 2724353852,
      "user": "dheerajturaga",
      "created_at": "2026-01-24T16:48:51Z",
      "url": "https://github.com/apache/airflow/pull/60675#discussion_r2724353852"
    },
    {
      "repo": "apache/airflow",
      "pr_number": 60675,
      "file_path": "providers/celery/src/airflow/providers/celery/cli/celery_command.py",
      "line": 201,
      "side": "RIGHT",
      "diff_hunk": "@@ -189,8 +189,27 @@ def filter(self, record):\n @_providers_configuration_loaded\n def worker(args):\n     \"\"\"Start Airflow Celery worker.\"\"\"\n-    # This needs to be imported locally to not trigger Providers Manager initialization\n-    from airflow.providers.celery.executors.celery_executor import app as celery_app\n+    team_config = None\n+    if hasattr(args, \"team\") and args.team:\n+        # Multi-team is enabled, create team-specific Celery app and use team based config\n+        try:\n+            from airflow.executors.base_executor import ExecutorConf\n+        except ImportError:\n+            raise SystemExit(\n+                f\"Error: Multi-team support (--team {args.team}) requires Airflow >=3.2. \"\n+                \"Please upgrade Airflow or remove the --team parameter.\"\n+            )",
      "comment": "Add attribute check before creating the ExecutorConf object?\n\n```suggestion\n            )\n\n        # Check if ExecutorConf has required methods for multi-team support\n        if not hasattr(ExecutorConf, 'getsection'):\n            raise SystemExit(\n                f\"Error: Multi-team support (--team {args.team}) requires Airflow >=3.2. \"\n                \"Please upgrade Airflow or remove the --team parameter.\"\n            )\n            \n```",
      "comment_id": 2724383833,
      "user": "dheerajturaga",
      "created_at": "2026-01-24T17:13:44Z",
      "url": "https://github.com/apache/airflow/pull/60675#discussion_r2724383833"
    },
    {
      "repo": "apache/airflow",
      "pr_number": 60675,
      "file_path": "providers/celery/src/airflow/providers/celery/cli/celery_command.py",
      "line": 240,
      "side": "RIGHT",
      "diff_hunk": "@@ -218,8 +237,8 @@ def worker(args):\n     autoscale = args.autoscale\n     skip_serve_logs = args.skip_serve_logs\n \n-    if autoscale is None and conf.has_option(\"celery\", \"worker_autoscale\"):\n-        autoscale = conf.get(\"celery\", \"worker_autoscale\")\n+    if autoscale is None and config.has_option(\"celery\", \"worker_autoscale\"):",
      "comment": "Thanks for testing! I had seen the same failure already and added checks in other places in the code for 3.2+ and/or attribute checks on ExecutorConf. But apparently some are missed in our unit/integ tests? Or we don't run that version on CI. I'll patch these up!",
      "comment_id": 2729130277,
      "user": "o-nikolas",
      "created_at": "2026-01-26T20:25:51Z",
      "url": "https://github.com/apache/airflow/pull/60675#discussion_r2729130277"
    },
    {
      "repo": "apache/airflow",
      "pr_number": 60675,
      "file_path": "providers/celery/src/airflow/providers/celery/cli/celery_command.py",
      "line": 240,
      "side": "RIGHT",
      "diff_hunk": "@@ -218,8 +237,8 @@ def worker(args):\n     autoscale = args.autoscale\n     skip_serve_logs = args.skip_serve_logs\n \n-    if autoscale is None and conf.has_option(\"celery\", \"worker_autoscale\"):\n-        autoscale = conf.get(\"celery\", \"worker_autoscale\")\n+    if autoscale is None and config.has_option(\"celery\", \"worker_autoscale\"):",
      "comment": "What were your steps for this reproduction by the way? I'd like to test the same way you did\r\n",
      "comment_id": 2729131365,
      "user": "o-nikolas",
      "created_at": "2026-01-26T20:26:15Z",
      "url": "https://github.com/apache/airflow/pull/60675#discussion_r2729131365"
    },
    {
      "repo": "apache/airflow",
      "pr_number": 60675,
      "file_path": "providers/celery/src/airflow/providers/celery/cli/celery_command.py",
      "line": 240,
      "side": "RIGHT",
      "diff_hunk": "@@ -218,8 +237,8 @@ def worker(args):\n     autoscale = args.autoscale\n     skip_serve_logs = args.skip_serve_logs\n \n-    if autoscale is None and conf.has_option(\"celery\", \"worker_autoscale\"):\n-        autoscale = conf.get(\"celery\", \"worker_autoscale\")\n+    if autoscale is None and config.has_option(\"celery\", \"worker_autoscale\"):",
      "comment": "this is what I'm using for these backward compatibility tests:\r\n\r\nBuild the local airflow wheel:\r\n`breeze release-management prepare-provider-distributions --skip-tag-check celery`\r\n\r\nStart specific airflow version:\r\n`breeze start-airflow -d -e --user-airflow-version 3.1.3 --executor CeleryExecutor --airflow-extras celery`\r\n\r\nthen within the container, shutdown the airflow celery worker. Then `pip install ./dist/<celery>.whl`\r\n\r\nthen launch the worker with `airflow celery worker --team my_team`",
      "comment_id": 2729408062,
      "user": "dheerajturaga",
      "created_at": "2026-01-26T21:55:41Z",
      "url": "https://github.com/apache/airflow/pull/60675#discussion_r2729408062"
    },
    {
      "repo": "apache/airflow",
      "pr_number": 60675,
      "file_path": "providers/celery/src/airflow/providers/celery/cli/celery_command.py",
      "line": 240,
      "side": "RIGHT",
      "diff_hunk": "@@ -218,8 +237,8 @@ def worker(args):\n     autoscale = args.autoscale\n     skip_serve_logs = args.skip_serve_logs\n \n-    if autoscale is None and conf.has_option(\"celery\", \"worker_autoscale\"):\n-        autoscale = conf.get(\"celery\", \"worker_autoscale\")\n+    if autoscale is None and config.has_option(\"celery\", \"worker_autoscale\"):",
      "comment": "We should probably add a backward compatibility test for this",
      "comment_id": 2729411288,
      "user": "dheerajturaga",
      "created_at": "2026-01-26T21:56:54Z",
      "url": "https://github.com/apache/airflow/pull/60675#discussion_r2729411288"
    },
    {
      "repo": "apache/airflow",
      "pr_number": 60675,
      "file_path": "providers/celery/src/airflow/providers/celery/cli/celery_command.py",
      "line": 196,
      "side": "RIGHT",
      "diff_hunk": "@@ -192,13 +192,18 @@ def worker(args):\n     team_config = None\n     if hasattr(args, \"team\") and args.team:\n         # Multi-team is enabled, create team-specific Celery app and use team based config\n-        try:\n-            from airflow.executors.base_executor import ExecutorConf\n-        except ImportError:\n-            raise SystemExit(\n-                f\"Error: Multi-team support (--team {args.team}) requires Airflow >=3.2. \"\n-                \"Please upgrade Airflow or remove the --team parameter.\"\n+        # This requires Airflow 3.2+, and core.multi_team config to be true to be enabled.\n+        if not AIRFLOW_V_3_2_PLUS:",
      "comment": "Nice, this should be much safer than the previous approach",
      "comment_id": 2738263398,
      "user": "dheerajturaga",
      "created_at": "2026-01-28T19:32:44Z",
      "url": "https://github.com/apache/airflow/pull/60675#discussion_r2738263398"
    },
    {
      "repo": "apache/airflow",
      "pr_number": 60675,
      "file_path": "providers/celery/src/airflow/providers/celery/cli/celery_command.py",
      "line": 240,
      "side": "RIGHT",
      "diff_hunk": "@@ -218,8 +237,8 @@ def worker(args):\n     autoscale = args.autoscale\n     skip_serve_logs = args.skip_serve_logs\n \n-    if autoscale is None and conf.has_option(\"celery\", \"worker_autoscale\"):\n-        autoscale = conf.get(\"celery\", \"worker_autoscale\")\n+    if autoscale is None and config.has_option(\"celery\", \"worker_autoscale\"):",
      "comment": "It is a bit of an invalid use case, it requires the user to be trying to use a feature on a version of Airflow where the feature doesn't exist. But it may happen. I can look into writing a test to cover it. ",
      "comment_id": 2742724345,
      "user": "o-nikolas",
      "created_at": "2026-01-29T17:22:09Z",
      "url": "https://github.com/apache/airflow/pull/60675#discussion_r2742724345"
    },
    {
      "repo": "apache/airflow",
      "pr_number": 60675,
      "file_path": "providers/celery/src/airflow/providers/celery/cli/celery_command.py",
      "line": 240,
      "side": "RIGHT",
      "diff_hunk": "@@ -218,8 +237,8 @@ def worker(args):\n     autoscale = args.autoscale\n     skip_serve_logs = args.skip_serve_logs\n \n-    if autoscale is None and conf.has_option(\"celery\", \"worker_autoscale\"):\n-        autoscale = conf.get(\"celery\", \"worker_autoscale\")\n+    if autoscale is None and config.has_option(\"celery\", \"worker_autoscale\"):",
      "comment": "I've made the fixes and added the unit test. Can you remove the request for changes and do another review @dheerajturaga ? Thanks!",
      "comment_id": 2743923583,
      "user": "o-nikolas",
      "created_at": "2026-01-29T23:15:39Z",
      "url": "https://github.com/apache/airflow/pull/60675#discussion_r2743923583"
    },
    {
      "repo": "apache/airflow",
      "pr_number": 60675,
      "file_path": "providers/celery/src/airflow/providers/celery/cli/celery_command.py",
      "line": 240,
      "side": "RIGHT",
      "diff_hunk": "@@ -218,8 +237,8 @@ def worker(args):\n     autoscale = args.autoscale\n     skip_serve_logs = args.skip_serve_logs\n \n-    if autoscale is None and conf.has_option(\"celery\", \"worker_autoscale\"):\n-        autoscale = conf.get(\"celery\", \"worker_autoscale\")\n+    if autoscale is None and config.has_option(\"celery\", \"worker_autoscale\"):",
      "comment": "@o-nikolas, many users may not be aware of what airflow version they are on. It could happen that they may just read the documentation available online and try out a feature that probably doesn't exist. I removed the request for changes, I will do a review in a couple of hours! thanks for addressing these !",
      "comment_id": 2743932450,
      "user": "dheerajturaga",
      "created_at": "2026-01-29T23:20:16Z",
      "url": "https://github.com/apache/airflow/pull/60675#discussion_r2743932450"
    },
    {
      "repo": "apache/airflow",
      "pr_number": 60675,
      "file_path": "providers/celery/src/airflow/providers/celery/cli/definition.py",
      "line": 106,
      "side": "RIGHT",
      "diff_hunk": "@@ -101,6 +101,10 @@\n     help=\"Don't subscribe to other workers events\",\n     action=\"store_true\",\n )\n+ARG_TEAM = Arg(\n+    (\"-t\", \"--team\"),\n+    help=\"Team name for team-specific multi-team configuration (requires Airflow 3.1+)\",",
      "comment": "```suggestion\n    help=\"Team name for team-specific multi-team configuration (requires Airflow 3.2+)\",\n```",
      "comment_id": 2744588631,
      "user": "dheerajturaga",
      "created_at": "2026-01-30T04:48:58Z",
      "url": "https://github.com/apache/airflow/pull/60675#discussion_r2744588631"
    },
    {
      "repo": "apache/airflow",
      "pr_number": 60675,
      "file_path": "providers/celery/src/airflow/providers/celery/cli/celery_command.py",
      "line": 197,
      "side": "RIGHT",
      "diff_hunk": "@@ -189,8 +189,32 @@ def filter(self, record):\n @_providers_configuration_loaded\n def worker(args):\n     \"\"\"Start Airflow Celery worker.\"\"\"\n-    # This needs to be imported locally to not trigger Providers Manager initialization\n-    from airflow.providers.celery.executors.celery_executor import app as celery_app\n+    team_config = None\n+    if hasattr(args, \"team\") and args.team:\n+        # Multi-team is enabled, create team-specific Celery app and use team based config\n+        # This requires Airflow 3.2+, and core.multi_team config to be true to be enabled.\n+        if not AIRFLOW_V_3_2_PLUS:\n+            raise AirflowConfigException(",
      "comment": "Can we raise SystemExit instead, that way we are aligned with the other SystemExit exceptions thrown for other missing arguments? Current approach throws a stack trace which can be confusing to the user.\r\n\r\n```suggestion\r\n            raise SystemExit(\r\n```",
      "comment_id": 2744596079,
      "user": "dheerajturaga",
      "created_at": "2026-01-30T04:53:25Z",
      "url": "https://github.com/apache/airflow/pull/60675#discussion_r2744596079"
    },
    {
      "repo": "apache/airflow",
      "pr_number": 60675,
      "file_path": "providers/celery/src/airflow/providers/celery/cli/celery_command.py",
      "line": 202,
      "side": "RIGHT",
      "diff_hunk": "@@ -189,8 +189,32 @@ def filter(self, record):\n @_providers_configuration_loaded\n def worker(args):\n     \"\"\"Start Airflow Celery worker.\"\"\"\n-    # This needs to be imported locally to not trigger Providers Manager initialization\n-    from airflow.providers.celery.executors.celery_executor import app as celery_app\n+    team_config = None\n+    if hasattr(args, \"team\") and args.team:\n+        # Multi-team is enabled, create team-specific Celery app and use team based config\n+        # This requires Airflow 3.2+, and core.multi_team config to be true to be enabled.\n+        if not AIRFLOW_V_3_2_PLUS:\n+            raise AirflowConfigException(\n+                \"Multi-team Celery workers require Airflow version 3.2 or higher. \"\n+                \"Please upgrade your Airflow installation or remove the --team argument.\"\n+            )\n+        if not conf.getboolean(\"core\", \"multi_team\", fallback=False):\n+            raise AirflowConfigException(",
      "comment": "Same here\n```suggestion\n            raise SystemExit(\n```",
      "comment_id": 2744597046,
      "user": "dheerajturaga",
      "created_at": "2026-01-30T04:53:57Z",
      "url": "https://github.com/apache/airflow/pull/60675#discussion_r2744597046"
    },
    {
      "repo": "apache/airflow",
      "pr_number": 60675,
      "file_path": "providers/celery/src/airflow/providers/celery/cli/celery_command.py",
      "line": 203,
      "side": "RIGHT",
      "diff_hunk": "@@ -189,8 +189,32 @@ def filter(self, record):\n @_providers_configuration_loaded\n def worker(args):\n     \"\"\"Start Airflow Celery worker.\"\"\"\n-    # This needs to be imported locally to not trigger Providers Manager initialization\n-    from airflow.providers.celery.executors.celery_executor import app as celery_app\n+    team_config = None\n+    if hasattr(args, \"team\") and args.team:\n+        # Multi-team is enabled, create team-specific Celery app and use team based config\n+        # This requires Airflow 3.2+, and core.multi_team config to be true to be enabled.\n+        if not AIRFLOW_V_3_2_PLUS:\n+            raise AirflowConfigException(\n+                \"Multi-team Celery workers require Airflow version 3.2 or higher. \"\n+                \"Please upgrade your Airflow installation or remove the --team argument.\"\n+            )\n+        if not conf.getboolean(\"core\", \"multi_team\", fallback=False):\n+            raise AirflowConfigException(\n+                \"Multi-team Celery workers require core.multi_team configuration to be enabled. \"",
      "comment": "```suggestion\n                \"Error: Multi-team Celery workers require core.multi_team configuration to be enabled. \"\n```",
      "comment_id": 2744598503,
      "user": "dheerajturaga",
      "created_at": "2026-01-30T04:54:43Z",
      "url": "https://github.com/apache/airflow/pull/60675#discussion_r2744598503"
    },
    {
      "repo": "apache/airflow",
      "pr_number": 60675,
      "file_path": "providers/celery/src/airflow/providers/celery/cli/celery_command.py",
      "line": 198,
      "side": "RIGHT",
      "diff_hunk": "@@ -189,8 +189,32 @@ def filter(self, record):\n @_providers_configuration_loaded\n def worker(args):\n     \"\"\"Start Airflow Celery worker.\"\"\"\n-    # This needs to be imported locally to not trigger Providers Manager initialization\n-    from airflow.providers.celery.executors.celery_executor import app as celery_app\n+    team_config = None\n+    if hasattr(args, \"team\") and args.team:\n+        # Multi-team is enabled, create team-specific Celery app and use team based config\n+        # This requires Airflow 3.2+, and core.multi_team config to be true to be enabled.\n+        if not AIRFLOW_V_3_2_PLUS:\n+            raise AirflowConfigException(\n+                \"Multi-team Celery workers require Airflow version 3.2 or higher. \"",
      "comment": "```suggestion\n                \"Error: Multi-team Celery workers require Airflow version 3.2 or higher. \"\n```",
      "comment_id": 2744599687,
      "user": "dheerajturaga",
      "created_at": "2026-01-30T04:55:10Z",
      "url": "https://github.com/apache/airflow/pull/60675#discussion_r2744599687"
    },
    {
      "repo": "apache/airflow",
      "pr_number": 61242,
      "file_path": "airflow-core/tests/integration/otel/test_otel.py",
      "line": 59,
      "side": "RIGHT",
      "diff_hunk": "@@ -55,6 +56,36 @@\n log = logging.getLogger(\"integration.otel.test_otel\")\n \n \n+def wait_for_otel_collector(host: str, port: int, timeout: int = 30) -> None:",
      "comment": "Let's increase to 1 minute.\r\n\r\n```suggestion\r\ndef wait_for_otel_collector(host: str, port: int, timeout: int = 60) -> None:\r\n```",
      "comment_id": 2745360692,
      "user": "jason810496",
      "created_at": "2026-01-30T09:21:03Z",
      "url": "https://github.com/apache/airflow/pull/61242#discussion_r2745360692"
    },
    {
      "repo": "apache/airflow",
      "pr_number": 61242,
      "file_path": "airflow-core/tests/integration/otel/test_otel.py",
      "line": 75,
      "side": "RIGHT",
      "diff_hunk": "@@ -55,6 +56,44 @@\n log = logging.getLogger(\"integration.otel.test_otel\")\n \n \n+def wait_for_otel_collector(host: str, port: int, timeout: int = 120) -> None:\n+    \"\"\"\n+    Wait for the OTel collector to be reachable before running tests.\n+\n+    This prevents flaky test failures caused by transient DNS resolution issues\n+    (e.g., 'Temporary failure in name resolution' for breeze-otel-collector).\n+\n+    Note: If the collector is not reachable after timeout, logs a warning but\n+    does not fail - allows tests to run and fail naturally if needed.\n+    \"\"\"\n+    deadline = time.monotonic() + timeout\n+    last_error = None\n+    while time.monotonic() < deadline:\n+        try:\n+            # Test DNS resolution and TCP connectivity\n+            sock = socket.create_connection((host, port), timeout=5)\n+            sock.close()",
      "comment": "```suggestion\n            with socket.create_connection((host, port), timeout=5):\n                pass\n```",
      "comment_id": 2745661156,
      "user": "henry3260",
      "created_at": "2026-01-30T10:40:31Z",
      "url": "https://github.com/apache/airflow/pull/61242#discussion_r2745661156"
    },
    {
      "repo": "apache/airflow",
      "pr_number": 61242,
      "file_path": "airflow-core/tests/integration/otel/test_otel.py",
      "line": 75,
      "side": "RIGHT",
      "diff_hunk": "@@ -55,6 +56,44 @@\n log = logging.getLogger(\"integration.otel.test_otel\")\n \n \n+def wait_for_otel_collector(host: str, port: int, timeout: int = 120) -> None:\n+    \"\"\"\n+    Wait for the OTel collector to be reachable before running tests.\n+\n+    This prevents flaky test failures caused by transient DNS resolution issues\n+    (e.g., 'Temporary failure in name resolution' for breeze-otel-collector).\n+\n+    Note: If the collector is not reachable after timeout, logs a warning but\n+    does not fail - allows tests to run and fail naturally if needed.\n+    \"\"\"\n+    deadline = time.monotonic() + timeout\n+    last_error = None\n+    while time.monotonic() < deadline:\n+        try:\n+            # Test DNS resolution and TCP connectivity\n+            sock = socket.create_connection((host, port), timeout=5)\n+            sock.close()",
      "comment": "Good catch, Henry! Using a context manager is much cleaner. I\u2019ll update the implementation to use with `socket.create_connection` to ensure the socket is always properly closed.",
      "comment_id": 2745688602,
      "user": "Abhishekmishra2808",
      "created_at": "2026-01-30T10:49:11Z",
      "url": "https://github.com/apache/airflow/pull/61242#discussion_r2745688602"
    },
    {
      "repo": "apache/airflow",
      "pr_number": 60688,
      "file_path": "providers/google/src/airflow/providers/google/cloud/hooks/datafusion.py",
      "line": 178,
      "side": "RIGHT",
      "diff_hunk": "@@ -168,6 +171,11 @@ def _cdap_request(\n \n     @staticmethod\n     def _check_response_status_and_data(response, message: str) -> None:\n+        if not response:\n+            raise AirflowException(\n+                \"Invalid / Empty response received. Please, check for possible root \"\n+                \"causes of this behavior either in DAG code or on Cloud DataFusion side\"\n+            )",
      "comment": "I'd like to ask to refactor all usages of `AirflowException` in the code, as according to a [recent policy](https://github.com/astronomer/airflow/blob/d8b768b71509b6895744d4d8a32f06a5daeebb12/contributing-docs/05_pull_requests.rst#dont-raise-airflowexception-directly) we want to avoid further usage of this exception at all (more about that in the [dev list thread](https://lists.apache.org/thread/5rv4tz0oc27bgr4khx0on0jz8fpxvh55)).\nYou may use a simple `ValueError` exception instead.",
      "comment_id": 2724290110,
      "user": "shahar1",
      "created_at": "2026-01-24T16:00:52Z",
      "url": "https://github.com/apache/airflow/pull/60688#discussion_r2724290110"
    },
    {
      "repo": "apache/airflow",
      "pr_number": 60688,
      "file_path": "providers/google/src/airflow/providers/google/cloud/hooks/datafusion.py",
      "line": 493,
      "side": "RIGHT",
      "diff_hunk": "@@ -469,33 +477,50 @@ def start_pipeline(\n             is always default. If your pipeline belongs to an Enterprise edition instance, you\n             can create a namespace.\n         \"\"\"\n-        # TODO: This API endpoint starts multiple pipelines. There will eventually be a fix\n-        #  return the run Id as part of the API request to run a single pipeline.\n-        #  https://github.com/apache/airflow/pull/8954#discussion_r438223116\n         url = os.path.join(\n             instance_url,\n             \"v3\",\n             \"namespaces\",\n             quote(namespace),\n             \"start\",\n         )\n+\n         runtime_args = runtime_args or {}\n+        program_id = self.cdap_program_id(pipeline_type=pipeline_type)\n         body = [\n             {\n                 \"appId\": pipeline_name,\n+                \"programType\": \"workflow\" if pipeline_type == DataFusionPipelineType.BATCH else \"spark\",",
      "comment": "Small suggestion - maybe encapsulate the programType in an enum?",
      "comment_id": 2724306070,
      "user": "shahar1",
      "created_at": "2026-01-24T16:11:40Z",
      "url": "https://github.com/apache/airflow/pull/60688#discussion_r2724306070"
    },
    {
      "repo": "apache/airflow",
      "pr_number": 60688,
      "file_path": "providers/google/src/airflow/providers/google/cloud/hooks/datafusion.py",
      "line": 511,
      "side": "LEFT",
      "diff_hunk": "@@ -508,8 +545,8 @@ def stop_pipeline(self, pipeline_name: str, instance_url: str, namespace: str =\n         url = os.path.join(\n             self._base_url(instance_url, namespace),\n             quote(pipeline_name),\n-            \"workflows\",",
      "comment": "However @shahar1 I have a suggestion here\nThe current implemetation of the stop_pipeline hook actually implements https://cdap.atlassian.net/wiki/spaces/DOCS/pages/477560983/Lifecycle+Microservices#Stop-a-Program which actually stops a program not a Run\n\nMaybe we can explore https://cdap.atlassian.net/wiki/spaces/DOCS/pages/477560983/Lifecycle+Microservices#Stop-a-Program-Run here.\n\n\nAlso this was only handling the case of stoping BATCH pipelines, which has been refactored",
      "comment_id": 2726943814,
      "user": "chirodip98",
      "created_at": "2026-01-26T09:46:52Z",
      "url": "https://github.com/apache/airflow/pull/60688#discussion_r2726943814"
    },
    {
      "repo": "apache/airflow",
      "pr_number": 60688,
      "file_path": "providers/google/src/airflow/providers/google/cloud/hooks/datafusion.py",
      "line": 511,
      "side": "LEFT",
      "diff_hunk": "@@ -508,8 +545,8 @@ def stop_pipeline(self, pipeline_name: str, instance_url: str, namespace: str =\n         url = os.path.join(\n             self._base_url(instance_url, namespace),\n             quote(pipeline_name),\n-            \"workflows\",",
      "comment": "https://docs.cloud.google.com/data-fusion/docs/reference/cdap-reference#stop_a_batch_pipeline\r\nhttps://docs.cloud.google.com/data-fusion/docs/reference/cdap-reference#stop_a_real-time_pipeline",
      "comment_id": 2726948374,
      "user": "chirodip98",
      "created_at": "2026-01-26T09:48:27Z",
      "url": "https://github.com/apache/airflow/pull/60688#discussion_r2726948374"
    },
    {
      "repo": "apache/airflow",
      "pr_number": 60688,
      "file_path": "providers/google/src/airflow/providers/google/cloud/hooks/datafusion.py",
      "line": 511,
      "side": "LEFT",
      "diff_hunk": "@@ -508,8 +545,8 @@ def stop_pipeline(self, pipeline_name: str, instance_url: str, namespace: str =\n         url = os.path.join(\n             self._base_url(instance_url, namespace),\n             quote(pipeline_name),\n-            \"workflows\",",
      "comment": "A pipeline can have multiple runs identified by runId",
      "comment_id": 2726957384,
      "user": "chirodip98",
      "created_at": "2026-01-26T09:51:26Z",
      "url": "https://github.com/apache/airflow/pull/60688#discussion_r2726957384"
    },
    {
      "repo": "apache/airflow",
      "pr_number": 60688,
      "file_path": "providers/google/src/airflow/providers/google/cloud/hooks/datafusion.py",
      "line": 511,
      "side": "LEFT",
      "diff_hunk": "@@ -508,8 +545,8 @@ def stop_pipeline(self, pipeline_name: str, instance_url: str, namespace: str =\n         url = os.path.join(\n             self._base_url(instance_url, namespace),\n             quote(pipeline_name),\n-            \"workflows\",",
      "comment": "Made it a feature request: https://github.com/apache/airflow/issues/61224\r\nThanks for raising it!",
      "comment_id": 2742824642,
      "user": "shahar1",
      "created_at": "2026-01-29T17:50:18Z",
      "url": "https://github.com/apache/airflow/pull/60688#discussion_r2742824642"
    },
    {
      "repo": "apache/airflow",
      "pr_number": 60876,
      "file_path": "providers/google/src/airflow/providers/google/cloud/transfers/gcs_to_bigquery.py",
      "line": 780,
      "side": "RIGHT",
      "diff_hunk": "@@ -716,29 +736,51 @@ def _validate_src_fmt_configs(\n         src_fmt_configs: dict,\n         valid_configs: list[str],\n         backward_compatibility_configs: dict | None = None,\n+        src_fmt_param: str | None = None,\n+        valid_nested_configs: list[str] | None = None,\n     ) -> dict:\n         \"\"\"\n-        Validate the given src_fmt_configs against a valid configuration for the source format.\n+        Validate and format the given src_fmt_configs against a valid configuration for the source format.\n \n         Adds the backward compatibility config to the src_fmt_configs.\n \n+        Adds nested source format configurations if valid_nested_configs is provided.\n+\n         :param source_format: File format to export.\n         :param src_fmt_configs: Configure optional fields specific to the source format.\n         :param valid_configs: Valid configuration specific to the source format\n         :param backward_compatibility_configs: The top-level params for backward-compatibility\n+        :param src_fmt_param: The source format parameter for nested configurations.\n+        Required when valid_nested_configs is provided.\n+        :param valid_nested_configs: Valid nested configuration specific to the source format.\n         \"\"\"\n+        valid_src_fmt_configs = {}\n+\n         if backward_compatibility_configs is None:\n             backward_compatibility_configs = {}\n \n         for k, v in backward_compatibility_configs.items():\n             if k not in src_fmt_configs and k in valid_configs:\n-                src_fmt_configs[k] = v\n+                valid_src_fmt_configs[k] = v\n+\n+        if valid_nested_configs is None:\n+            valid_nested_configs = []\n+\n+        if valid_nested_configs:\n+            if src_fmt_param is None:\n+                raise ValueError(\"src_fmt_param is required when valid_nested_configs is provided.\")\n \n-        for k in src_fmt_configs:\n-            if k not in valid_configs:\n+            valid_src_fmt_configs[src_fmt_param] = {}\n+\n+        for k, v in src_fmt_configs.items():\n+            if k in valid_configs:\n+                valid_src_fmt_configs[k] = v\n+            elif k in valid_nested_configs:\n+                valid_src_fmt_configs[src_fmt_param][k] = v\n+            else:",
      "comment": "I'm not wild about adding complexity here, I think its pretty gross. \n\nThe issue is that both the external table and non external table code paths allow `src_fmt_configs` and use this method, but the non external table code path previously only allowed arguments that were available at the top level of the job config rather than nested `<srcFmt>Options` options.\n\nI'm totally open to suggestions if you think this warrants a larger refactor.",
      "comment_id": 2713134066,
      "user": "mlauter",
      "created_at": "2026-01-21T15:37:12Z",
      "url": "https://github.com/apache/airflow/pull/60876#discussion_r2713134066"
    },
    {
      "repo": "apache/airflow",
      "pr_number": 61042,
      "file_path": "airflow-ctl/src/airflowctl/api/client.py",
      "line": 193,
      "side": "RIGHT",
      "diff_hunk": "@@ -168,7 +168,39 @@ def load(self) -> Credentials:\n                         debug_credentials = json.load(df)\n                         self.api_token = debug_credentials.get(f\"api_token_{self.api_environment}\")\n                 else:\n-                    self.api_token = keyring.get_password(\"airflowctl\", f\"api_token_{self.api_environment}\")\n+                    try:\n+                        self.api_token = keyring.get_password(\n+                            \"airflowctl\", f\"api_token_{self.api_environment}\"\n+                        )\n+                    except ValueError as e:\n+                        # Incorrect keyring password\n+                        if self.client_kind == ClientKind.AUTH:\n+                            # For AUTH kind, log warning and continue (user is logging in)\n+                            log.warning(\n+                                \"Could not access keyring for environment %s: %s\", self.api_environment, e\n+                            )\n+                            self.api_token = None\n+                        else:\n+                            # For CLI kind, provide helpful error and raise\n+                            error_msg = (\n+                                f\"Failed to access system keyring for environment '{self.api_environment}'. \"\n+                                f\"This usually means an incorrect keyring password was entered.\\n\"\n+                                f\"To fix this:\\n\"\n+                                f\"  1. Ensure your system keyring password is correct\\n\"\n+                                f\"  2. Or use AIRFLOW_CLI_DEBUG_MODE=true to bypass keyring\\n\"\n+                                f\"  3. Or run 'airflowctl auth login' to re-authenticate\"\n+                            )\n+                            raise AirflowCtlCredentialNotFoundException(error_msg) from e",
      "comment": "Looks good but one nit.\n\nShould we just print the erorr aand `sys.exit(42)` here ?  cc: @bugraoz93 \n\nI see that we are already handling it elsewhere:\n\n```\n    try:\n        function(args)\n    except (\n        AirflowCtlCredentialNotFoundException,\n        AirflowCtlConnectionException,\n        AirflowCtlNotFoundException,\n    ) as e:\n        rich.print(f\"command failed due to {e}\")\n        sys.exit(1)\n```\n\n\nI think in case of a fatal error in CLIs, I find the default exception handling as verbose and unnecessary - so my usual approach for fatal CLI errors is to print as descriptive and actionable error message as possible, with possibly even more details in debug mode, and .... exit with error. \n\nOtherwise - at least by default - your helpful error message will be overwhelmed by the stack trace printed by default - which usually in CLIs is very misleading, unhelpful for the users, confusing and intimidating.\n\nSo I would generally handle that in one of the two ways:\n\n1) print error message + sys.exit()\n2) raise a deliberate \"ExitKindOfException\" with appropriate error message, and handle it in one place with printing - but only printing THE MESSAGE - not the exception itself. \n\nI found such `sys.exit()` a bit better  because you can decide how to print he message, you can format and colour it apropriately (\"actual error in red, warning - i.e. somtething to check -  in yellow, instructions to follow in white\"),  this is pretty much approach we folow in breeze and it works nicely even for technical users of breeze, who could be - in principle - interested in stack trace and details, but  in fact they really want to understand what error it is and how they can fix it.\n\nApproach 2 is also good (you can have some implicit dependency on rich and format your message when you prepare it with rich directives)  - also you can use some conventions to handle it differently in case of verbose output.\n\nWDYT @bugraoz93 ? ",
      "comment_id": 2727493641,
      "user": "potiuk",
      "created_at": "2026-01-26T12:51:09Z",
      "url": "https://github.com/apache/airflow/pull/61042#discussion_r2727493641"
    },
    {
      "repo": "apache/airflow",
      "pr_number": 61058,
      "file_path": "airflow-core/tests/unit/api_fastapi/core_api/routes/ui/test_gantt.py",
      "line": 255,
      "side": "RIGHT",
      "diff_hunk": "@@ -0,0 +1,310 @@\n+# Licensed to the Apache Software Foundation (ASF) under one\n+# or more contributor license agreements.  See the NOTICE file\n+# distributed with this work for additional information\n+# regarding copyright ownership.  The ASF licenses this file\n+# to you under the Apache License, Version 2.0 (the\n+# \"License\"); you may not use this file except in compliance\n+# with the License.  You may obtain a copy of the License at\n+#\n+#   http://www.apache.org/licenses/LICENSE-2.0\n+#\n+# Unless required by applicable law or agreed to in writing,\n+# software distributed under the License is distributed on an\n+# \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+# KIND, either express or implied.  See the License for the\n+# specific language governing permissions and limitations\n+# under the License.\n+\n+from __future__ import annotations\n+\n+from operator import attrgetter\n+\n+import pendulum\n+import pytest\n+\n+from airflow._shared.timezones import timezone\n+from airflow.models.dagbag import DBDagBag\n+from airflow.providers.standard.operators.empty import EmptyOperator\n+from airflow.utils.session import provide_session\n+from airflow.utils.state import DagRunState, TaskInstanceState\n+from airflow.utils.types import DagRunTriggeredByType, DagRunType\n+\n+from tests_common.test_utils.asserts import assert_queries_count\n+from tests_common.test_utils.db import clear_db_assets, clear_db_dags, clear_db_runs, clear_db_serialized_dags\n+from tests_common.test_utils.mock_operators import MockOperator\n+\n+pytestmark = pytest.mark.db_test\n+\n+DAG_ID = \"test_gantt_dag\"\n+DAG_ID_2 = \"test_gantt_dag_2\"\n+DAG_ID_3 = \"test_gantt_dag_3\"\n+TASK_ID = \"task\"\n+TASK_ID_2 = \"task2\"\n+TASK_ID_3 = \"task3\"\n+MAPPED_TASK_ID = \"mapped_task\"\n+\n+GANTT_TASK_1 = {\n+    \"task_id\": \"task\",\n+    \"try_number\": 1,\n+    \"state\": \"success\",\n+    \"start_date\": \"2024-11-30T10:00:00Z\",\n+    \"end_date\": \"2024-11-30T10:05:00Z\",\n+    \"is_group\": False,\n+    \"is_mapped\": False,\n+}\n+\n+GANTT_TASK_2 = {\n+    \"task_id\": \"task2\",\n+    \"try_number\": 1,\n+    \"state\": \"failed\",\n+    \"start_date\": \"2024-11-30T10:05:00Z\",\n+    \"end_date\": \"2024-11-30T10:10:00Z\",\n+    \"is_group\": False,\n+    \"is_mapped\": False,\n+}\n+\n+GANTT_TASK_3 = {\n+    \"task_id\": \"task3\",\n+    \"try_number\": 1,\n+    \"state\": \"running\",\n+    \"start_date\": \"2024-11-30T10:10:00Z\",\n+    \"end_date\": None,\n+    \"is_group\": False,\n+    \"is_mapped\": False,\n+}\n+\n+\n+@pytest.fixture(autouse=True, scope=\"module\")\n+def examples_dag_bag():\n+    return DBDagBag()\n+\n+\n+@pytest.fixture(autouse=True)\n+@provide_session\n+def setup(dag_maker, session=None):\n+    clear_db_runs()\n+    clear_db_dags()\n+    clear_db_serialized_dags()\n+\n+    triggered_by_kwargs = {\"triggered_by\": DagRunTriggeredByType.TEST}\n+\n+    # DAG 1: Multiple tasks with different states (success, failed, running)\n+    with dag_maker(dag_id=DAG_ID, serialized=True, session=session) as dag:\n+        EmptyOperator(task_id=TASK_ID)\n+        EmptyOperator(task_id=TASK_ID_2)\n+        EmptyOperator(task_id=TASK_ID_3)\n+\n+    logical_date = timezone.datetime(2024, 11, 30)\n+    data_interval = dag.timetable.infer_manual_data_interval(run_after=logical_date)\n+\n+    run_1 = dag_maker.create_dagrun(\n+        run_id=\"run_1\",\n+        state=DagRunState.RUNNING,\n+        run_type=DagRunType.MANUAL,\n+        logical_date=logical_date,\n+        data_interval=data_interval,\n+        **triggered_by_kwargs,\n+    )\n+\n+    for ti in sorted(run_1.task_instances, key=attrgetter(\"task_id\")):\n+        if ti.task_id == TASK_ID:\n+            ti.state = TaskInstanceState.SUCCESS\n+            ti.try_number = 1\n+            ti.start_date = pendulum.DateTime(2024, 11, 30, 10, 0, 0, tzinfo=pendulum.UTC)\n+            ti.end_date = pendulum.DateTime(2024, 11, 30, 10, 5, 0, tzinfo=pendulum.UTC)\n+        elif ti.task_id == TASK_ID_2:\n+            ti.state = TaskInstanceState.FAILED\n+            ti.try_number = 1\n+            ti.start_date = pendulum.DateTime(2024, 11, 30, 10, 5, 0, tzinfo=pendulum.UTC)\n+            ti.end_date = pendulum.DateTime(2024, 11, 30, 10, 10, 0, tzinfo=pendulum.UTC)\n+        elif ti.task_id == TASK_ID_3:\n+            ti.state = TaskInstanceState.RUNNING\n+            ti.try_number = 1\n+            ti.start_date = pendulum.DateTime(2024, 11, 30, 10, 10, 0, tzinfo=pendulum.UTC)\n+            ti.end_date = None\n+\n+    # DAG 2: With mapped tasks (only non-mapped should be returned)\n+    with dag_maker(dag_id=DAG_ID_2, serialized=True, session=session) as dag_2:\n+        EmptyOperator(task_id=TASK_ID)\n+        MockOperator.partial(task_id=MAPPED_TASK_ID).expand(arg1=[\"a\", \"b\", \"c\"])\n+\n+    logical_date_2 = timezone.datetime(2024, 12, 1)\n+    data_interval_2 = dag_2.timetable.infer_manual_data_interval(run_after=logical_date_2)\n+\n+    run_2 = dag_maker.create_dagrun(\n+        run_id=\"run_2\",\n+        state=DagRunState.SUCCESS,\n+        run_type=DagRunType.MANUAL,\n+        logical_date=logical_date_2,\n+        data_interval=data_interval_2,\n+        **triggered_by_kwargs,\n+    )\n+\n+    for ti in run_2.task_instances:\n+        ti.state = TaskInstanceState.SUCCESS\n+        ti.try_number = 1\n+        ti.start_date = pendulum.DateTime(2024, 12, 1, 10, 0, 0, tzinfo=pendulum.UTC)\n+        ti.end_date = pendulum.DateTime(2024, 12, 1, 10, 5, 0, tzinfo=pendulum.UTC)\n+\n+    # DAG 3: With UP_FOR_RETRY state (should be excluded from results)\n+    with dag_maker(dag_id=DAG_ID_3, serialized=True, session=session) as dag_3:\n+        EmptyOperator(task_id=TASK_ID)\n+        EmptyOperator(task_id=TASK_ID_2)\n+\n+    logical_date_3 = timezone.datetime(2024, 12, 2)\n+    data_interval_3 = dag_3.timetable.infer_manual_data_interval(run_after=logical_date_3)\n+\n+    run_3 = dag_maker.create_dagrun(\n+        run_id=\"run_3\",\n+        state=DagRunState.RUNNING,\n+        run_type=DagRunType.MANUAL,\n+        logical_date=logical_date_3,\n+        data_interval=data_interval_3,\n+        **triggered_by_kwargs,\n+    )\n+\n+    for ti in sorted(run_3.task_instances, key=attrgetter(\"task_id\")):\n+        if ti.task_id == TASK_ID:\n+            ti.state = TaskInstanceState.SUCCESS\n+            ti.try_number = 1\n+            ti.start_date = pendulum.DateTime(2024, 12, 2, 10, 0, 0, tzinfo=pendulum.UTC)\n+            ti.end_date = pendulum.DateTime(2024, 12, 2, 10, 5, 0, tzinfo=pendulum.UTC)\n+        elif ti.task_id == TASK_ID_2:\n+            # UP_FOR_RETRY should be excluded (historical tries are in TaskInstanceHistory)\n+            ti.state = TaskInstanceState.UP_FOR_RETRY\n+            ti.try_number = 2\n+            ti.start_date = pendulum.DateTime(2024, 12, 2, 10, 5, 0, tzinfo=pendulum.UTC)\n+            ti.end_date = pendulum.DateTime(2024, 12, 2, 10, 10, 0, tzinfo=pendulum.UTC)\n+\n+    session.commit()\n+\n+\n+@pytest.fixture(autouse=True)\n+def _clean():\n+    clear_db_runs()\n+    clear_db_assets()\n+    yield\n+    clear_db_runs()\n+    clear_db_assets()\n+\n+\n+@pytest.mark.usefixtures(\"setup\")\n+class TestGetGanttDataEndpoint:\n+    def test_should_response_200(self, test_client):\n+        with assert_queries_count(3):\n+            response = test_client.get(f\"/gantt/{DAG_ID}/run_1\")\n+        assert response.status_code == 200\n+        data = response.json()\n+        assert data[\"dag_id\"] == DAG_ID\n+        assert data[\"run_id\"] == \"run_1\"\n+        actual = sorted(data[\"task_instances\"], key=lambda x: x[\"task_id\"])\n+        assert actual == [GANTT_TASK_1, GANTT_TASK_2, GANTT_TASK_3]\n+\n+    @pytest.mark.parametrize(\n+        (\"dag_id\", \"run_id\", \"expected_task_ids\", \"expected_states\"),\n+        [\n+            pytest.param(\n+                DAG_ID,\n+                \"run_1\",\n+                [\"task\", \"task2\", \"task3\"],\n+                {\"success\", \"failed\", \"running\"},\n+                id=\"dag1_multiple_states\",\n+            ),\n+            pytest.param(\n+                DAG_ID_2,\n+                \"run_2\",\n+                [\"task\"],\n+                {\"success\"},\n+                id=\"dag2_filters_mapped_tasks\",\n+            ),\n+            pytest.param(\n+                DAG_ID_3,\n+                \"run_3\",\n+                [\"task\"],\n+                {\"success\"},\n+                id=\"dag3_excludes_up_for_retry\",\n+            ),\n+        ],\n+    )\n+    def test_task_filtering_and_states(self, test_client, dag_id, run_id, expected_task_ids, expected_states):\n+        response = test_client.get(f\"/gantt/{dag_id}/{run_id}\")\n+        assert response.status_code == 200\n+        data = response.json()\n+\n+        actual_task_ids = sorted([ti[\"task_id\"] for ti in data[\"task_instances\"]])\n+        assert actual_task_ids == expected_task_ids\n+\n+        actual_states = {ti[\"state\"] for ti in data[\"task_instances\"]}\n+        assert actual_states == expected_states\n+\n+    @pytest.mark.parametrize(\n+        (\"dag_id\", \"run_id\", \"task_id\", \"expected_start\", \"expected_end\", \"expected_state\"),\n+        [\n+            pytest.param(\n+                DAG_ID,\n+                \"run_1\",\n+                \"task\",\n+                \"2024-11-30T10:00:00Z\",\n+                \"2024-11-30T10:05:00Z\",\n+                \"success\",\n+                id=\"success_task_has_dates\",\n+            ),\n+            pytest.param(\n+                DAG_ID,\n+                \"run_1\",",
      "comment": "Can you add db queries guards, just to ensure that this doesn't explode later when updating that endpoint. (and to make sure there isn't N+1 db queries problem, there doesn't seem to be btw)",
      "comment_id": 2746909295,
      "user": "pierrejeambrun",
      "created_at": "2026-01-30T15:55:29Z",
      "url": "https://github.com/apache/airflow/pull/61058#discussion_r2746909295"
    },
    {
      "repo": "apache/airflow",
      "pr_number": 60993,
      "file_path": "dev/breeze/src/airflow_breeze/commands/release_management_validation.py",
      "line": 33,
      "side": "RIGHT",
      "diff_hunk": "@@ -28,18 +28,28 @@\n \n \n @release_management_group.command(\n-    name=\"validate-rc-by-pmc\",\n-    help=\"Validate release candidate for PMC voting\",\n+    name=\"verify-rc-by-pmc\",\n+    help=(\n+        \"Verify a release candidate for PMC voting (EXPERIMENTAL).\\n\"",
      "comment": "```suggestion\n        \"[EXPERIMENTAL] Verify a release candidate for PMC voting.\\n\"\n```",
      "comment_id": 2741061046,
      "user": "amoghrajesh",
      "created_at": "2026-01-29T10:53:27Z",
      "url": "https://github.com/apache/airflow/pull/60993#discussion_r2741061046"
    },
    {
      "repo": "apache/airflow",
      "pr_number": 59115,
      "file_path": "airflow-core/src/airflow/dag_processing/collection.py",
      "line": 181,
      "side": "RIGHT",
      "diff_hunk": "@@ -144,7 +178,23 @@ def calculate(cls, dag: LazyDeserializedDAG, *, session: Session) -> Self:\n         if not dag.timetable.can_be_scheduled:\n             return cls(None, 0)\n \n-        latest_run = session.scalar(_get_latest_runs_stmt(dag_id=dag.dag_id))\n+        if isinstance(  # todo: AIP-76 what's a more general way to detect?",
      "comment": "If we're not adding a new attribute, then this is probably what we can do?",
      "comment_id": 2689806730,
      "user": "Lee-W",
      "created_at": "2026-01-14T10:12:35Z",
      "url": "https://github.com/apache/airflow/pull/59115#discussion_r2689806730"
    },
    {
      "repo": "apache/airflow",
      "pr_number": 59115,
      "file_path": "airflow-core/src/airflow/jobs/scheduler_job_runner.py",
      "line": 1810,
      "side": "RIGHT",
      "diff_hunk": "@@ -1765,24 +1767,48 @@ def _create_dag_runs(self, dag_models: Collection[DagModel], session: Session) -\n         # as DagModel.dag_id and DagModel.next_dagrun\n         # This list is used to verify if the DagRun already exist so that we don't attempt to create\n         # duplicate DagRuns\n-        existing_dagruns = (\n-            session.execute(\n-                select(DagRun.dag_id, DagRun.logical_date).where(\n+        existing_dagrun_objects = (\n+            session.scalars(\n+                select(DagRun)\n+                .where(\n                     tuple_(DagRun.dag_id, DagRun.logical_date).in_(\n                         (dm.dag_id, dm.next_dagrun) for dm in dag_models\n-                    ),\n+                    )\n                 )\n+                .options(load_only(DagRun.dag_id, DagRun.logical_date))\n             )\n             .unique()\n             .all()\n         )\n+        existing_dagruns = {(x.dag_id, x.logical_date): x for x in existing_dagrun_objects}\n+\n+        # todo: AIP-76 we may want to update check existing to also check partitioned dag runs,\n+        #  but the thing is, there is not actually a restriction that\n+        #  we don't create new runs with the same partition key\n+        #  so it's unclear whether we should / need to.\n+\n+        partitioned_dags = set()\n+        non_partitioned_dags: list[DagModel] = []\n+        missing_dags = set()\n+        serdags: dict[str, SerializedDAG] = {}\n+        for dag in dag_models:\n+            serdag = _get_current_dag(dag_id=dag.dag_id, session=session)\n+            if serdag:\n+                serdags[serdag.dag_id] = serdag\n+                if isinstance(serdag.timetable, CronPartitionTimetable):\n+                    # todo: AIP-76 there may be a better way to identify this!\n+                    #  should we use an attribute on BaseTimetable instead?",
      "comment": "a base partition timetable or an attribute will do. I kinda like base partition timetable better",
      "comment_id": 2689817778,
      "user": "Lee-W",
      "created_at": "2026-01-14T10:15:16Z",
      "url": "https://github.com/apache/airflow/pull/59115#discussion_r2689817778"
    },
    {
      "repo": "apache/airflow",
      "pr_number": 59115,
      "file_path": "airflow-core/src/airflow/api/common/mark_tasks.py",
      "line": 74,
      "side": "RIGHT",
      "diff_hunk": "@@ -70,6 +70,9 @@ def set_state(\n     :param commit: Commit tasks to be altered to the database\n     :param session: database session\n     :return: list of tasks that have been created and updated\n+\n+    TODO: \"past\" and \"future\" params currently depend on logical date, which is not always populated.",
      "comment": "raise an warning and not doing anything for cases without logical_date maybe?",
      "comment_id": 2697588013,
      "user": "Lee-W",
      "created_at": "2026-01-16T09:07:44Z",
      "url": "https://github.com/apache/airflow/pull/59115#discussion_r2697588013"
    },
    {
      "repo": "apache/airflow",
      "pr_number": 59115,
      "file_path": "airflow-core/src/airflow/dag_processing/collection.py",
      "line": 148,
      "side": "RIGHT",
      "diff_hunk": "@@ -129,6 +130,39 @@ def _get_latest_runs_stmt(dag_id: str) -> Select:\n     )\n \n \n+def _get_latest_runs_stmt_partitioned(dag_id: str) -> Select:\n+    \"\"\"Build a select statement to retrieve the last automated run for each dag.\"\"\"\n+    # todo: AIP-76 we should add a partition date field\n+    latest_run_id = (\n+        select(DagRun.id)\n+        .where(\n+            DagRun.dag_id == dag_id,\n+            DagRun.run_type.in_(\n+                (\n+                    DagRunType.BACKFILL_JOB,\n+                    DagRunType.SCHEDULED,\n+                )\n+            ),\n+            DagRun.partition_key.is_not(None),\n+        )\n+        .order_by(DagRun.id.desc())",
      "comment": "Looks like we're using `DagRun.id` to decide the latest run?",
      "comment_id": 2697604296,
      "user": "Lee-W",
      "created_at": "2026-01-16T09:12:40Z",
      "url": "https://github.com/apache/airflow/pull/59115#discussion_r2697604296"
    },
    {
      "repo": "apache/airflow",
      "pr_number": 59115,
      "file_path": "airflow-core/src/airflow/dag_processing/collection.py",
      "line": 134,
      "side": "RIGHT",
      "diff_hunk": "@@ -129,6 +130,39 @@ def _get_latest_runs_stmt(dag_id: str) -> Select:\n     )\n \n \n+def _get_latest_runs_stmt_partitioned(dag_id: str) -> Select:\n+    \"\"\"Build a select statement to retrieve the last automated run for each dag.\"\"\"",
      "comment": "```suggestion\n    \"\"\"Build a select statement to retrieve the last partitioned Dag run for each Dag.\"\"\"\n```",
      "comment_id": 2697605385,
      "user": "Lee-W",
      "created_at": "2026-01-16T09:13:01Z",
      "url": "https://github.com/apache/airflow/pull/59115#discussion_r2697605385"
    },
    {
      "repo": "apache/airflow",
      "pr_number": 59115,
      "file_path": "airflow-core/src/airflow/dag_processing/collection.py",
      "line": 133,
      "side": "RIGHT",
      "diff_hunk": "@@ -129,6 +130,39 @@ def _get_latest_runs_stmt(dag_id: str) -> Select:\n     )\n \n \n+def _get_latest_runs_stmt_partitioned(dag_id: str) -> Select:",
      "comment": "```suggestion\ndef _get_latest_partitioned_runs_stmt(dag_id: str) -> Select:\n```",
      "comment_id": 2697606287,
      "user": "Lee-W",
      "created_at": "2026-01-16T09:13:17Z",
      "url": "https://github.com/apache/airflow/pull/59115#discussion_r2697606287"
    },
    {
      "repo": "apache/airflow",
      "pr_number": 59115,
      "file_path": "airflow-core/src/airflow/jobs/scheduler_job_runner.py",
      "line": 1816,
      "side": "RIGHT",
      "diff_hunk": "@@ -1765,24 +1767,48 @@ def _create_dag_runs(self, dag_models: Collection[DagModel], session: Session) -\n         # as DagModel.dag_id and DagModel.next_dagrun\n         # This list is used to verify if the DagRun already exist so that we don't attempt to create\n         # duplicate DagRuns\n-        existing_dagruns = (\n-            session.execute(\n-                select(DagRun.dag_id, DagRun.logical_date).where(\n+        existing_dagrun_objects = (\n+            session.scalars(\n+                select(DagRun)\n+                .where(\n                     tuple_(DagRun.dag_id, DagRun.logical_date).in_(\n                         (dm.dag_id, dm.next_dagrun) for dm in dag_models\n-                    ),\n+                    )\n                 )\n+                .options(load_only(DagRun.dag_id, DagRun.logical_date))\n             )\n             .unique()\n             .all()\n         )\n+        existing_dagruns = {(x.dag_id, x.logical_date): x for x in existing_dagrun_objects}",
      "comment": "Why do we need it? I thought `unique()` already deduplicate Dag runs?",
      "comment_id": 2697689941,
      "user": "Lee-W",
      "created_at": "2026-01-16T09:32:28Z",
      "url": "https://github.com/apache/airflow/pull/59115#discussion_r2697689941"
    },
    {
      "repo": "apache/airflow",
      "pr_number": 59115,
      "file_path": "airflow-core/src/airflow/models/backfill.py",
      "line": 436,
      "side": "RIGHT",
      "diff_hunk": "@@ -428,7 +433,11 @@ def _get_info_list(\n ) -> list[DagRunInfo]:\n     infos = dag.iter_dagrun_infos_between(from_date, to_date)\n     now = timezone.utcnow()\n-    dagrun_info_list = [x for x in infos if x.data_interval.end < now]\n+    dagrun_info_list = []\n+    for x in infos:\n+        # todo: AIP-76 update for partitioned dags\n+        if x.data_interval and x.data_interval.end < now:\n+            dagrun_info_list.append(x)",
      "comment": "```suggestion\n    dagrun_info_list = [\n        x\n        for x in infos\n        # todo: AIP-76 update for partitioned dags\n        if x.data_interval and x.data_interval.end < now\n    ]\n```\n\ncomprehension still looks better IMO \ud83e\udd14 ",
      "comment_id": 2697696657,
      "user": "Lee-W",
      "created_at": "2026-01-16T09:34:03Z",
      "url": "https://github.com/apache/airflow/pull/59115#discussion_r2697696657"
    },
    {
      "repo": "apache/airflow",
      "pr_number": 59115,
      "file_path": "airflow-core/src/airflow/models/dag.py",
      "line": 147,
      "side": "RIGHT",
      "diff_hunk": "@@ -140,6 +143,12 @@ def get_run_data_interval(timetable: Timetable, run: DagRun) -> DataInterval:\n \n     :meta private:\n     \"\"\"\n+    if not run:\n+        return run\n+\n+    if run.partition_key is not None:\n+        return None",
      "comment": "```suggestion\n    if not run or run.partition_key is not None:\n        return None\n```",
      "comment_id": 2697701830,
      "user": "Lee-W",
      "created_at": "2026-01-16T09:35:12Z",
      "url": "https://github.com/apache/airflow/pull/59115#discussion_r2697701830"
    },
    {
      "repo": "apache/airflow",
      "pr_number": 59115,
      "file_path": "airflow-core/src/airflow/models/dag.py",
      "line": 728,
      "side": "RIGHT",
      "diff_hunk": "@@ -702,36 +711,64 @@ def dag_ready(dag_id: str, cond: SerializedAssetBase, statuses: dict[UKey, bool]\n             triggered_date_by_dag,\n         )\n \n+    def _get_run_info(self, run: DagRun | None, timetable: Timetable) -> DagRunInfo | None:\n+        run_info = None\n+        interval = None\n+        partition_date = None\n+        if run:\n+            run_after = timezone.coerce_datetime(run.run_after)\n+            if not run.partition_key:\n+                interval = get_run_data_interval(timetable, run)\n+            if isinstance(timetable, CronPartitionTimetable):\n+                # todo: AIP-76 store this on DagRun so we don't need to recalculate?\n+                # todo: AIP-76 this needs to be public\n+                partition_date = timetable.get_partition_date(run_date=run.run_after)\n+            run_info = DagRunInfo(\n+                run_after=run_after,\n+                data_interval=interval,\n+                partition_date=partition_date,\n+                partition_key=run.partition_key,\n+            )\n+        return run_info",
      "comment": "```suggestion\n    def _get_run_info(self, run: DagRun | None, timetable: Timetable) -> DagRunInfo | None:\n        if not run:\n            return None\n\n        interval = None\n        if not run.partition_key:\n            interval = get_run_data_interval(timetable, run)\n\n        partition_date = None\n        if isinstance(timetable, CronPartitionTimetable):\n            # todo: AIP-76 store this on DagRun so we don't need to recalculate?\n            # todo: AIP-76 this needs to be public\n            partition_date = timetable.get_partition_date(run_date=run.run_after)\n            \n        return DagRunInfo(\n            run_after=timezone.coerce_datetime(run.run_after),\n            data_interval=interval,\n            partition_date=partition_date,\n            partition_key=run.partition_key,\n        )\n```",
      "comment_id": 2697715930,
      "user": "Lee-W",
      "created_at": "2026-01-16T09:38:23Z",
      "url": "https://github.com/apache/airflow/pull/59115#discussion_r2697715930"
    },
    {
      "repo": "apache/airflow",
      "pr_number": 59115,
      "file_path": "airflow-core/src/airflow/timetables/base.py",
      "line": 336,
      "side": "RIGHT",
      "diff_hunk": "@@ -315,3 +329,24 @@ def generate_run_id(\n         :param data_interval: The data interval of the DAG run.\n         \"\"\"\n         return run_type.generate_run_id(suffix=run_after.isoformat())\n+\n+    def next_dagrun_info_v2(self, *, last_dagrun_info: DagRunInfo | None, restriction: TimeRestriction):",
      "comment": "```suggestion\n    def next_dagrun_info_v2(self, *, last_dagrun_info: DagRunInfo | None, restriction: TimeRestriction) -> DagRunInfo | None:\n```",
      "comment_id": 2697738829,
      "user": "Lee-W",
      "created_at": "2026-01-16T09:43:56Z",
      "url": "https://github.com/apache/airflow/pull/59115#discussion_r2697738829"
    },
    {
      "repo": "apache/airflow",
      "pr_number": 59115,
      "file_path": "airflow-core/src/airflow/timetables/base.py",
      "line": 344,
      "side": "RIGHT",
      "diff_hunk": "@@ -315,3 +329,24 @@ def generate_run_id(\n         :param data_interval: The data interval of the DAG run.\n         \"\"\"\n         return run_type.generate_run_id(suffix=run_after.isoformat())\n+\n+    def next_dagrun_info_v2(self, *, last_dagrun_info: DagRunInfo | None, restriction: TimeRestriction):\n+        \"\"\"\n+        Provide information to schedule the next DagRun.\n+\n+        The default implementation raises ``NotImplementedError``.\n+\n+        :param last_dagrun_info: The DagRunInfo object of the\n+            Dag's last scheduled or backfilled run.\n+        :param restriction: Restriction to apply when scheduling the DAG run.",
      "comment": "```suggestion\n        :param restriction: Restriction to apply when scheduling the Dag run.\n```",
      "comment_id": 2697740371,
      "user": "Lee-W",
      "created_at": "2026-01-16T09:44:20Z",
      "url": "https://github.com/apache/airflow/pull/59115#discussion_r2697740371"
    },
    {
      "repo": "apache/airflow",
      "pr_number": 59115,
      "file_path": "airflow-core/src/airflow/timetables/base.py",
      "line": 349,
      "side": "RIGHT",
      "diff_hunk": "@@ -315,3 +329,24 @@ def generate_run_id(\n         :param data_interval: The data interval of the DAG run.\n         \"\"\"\n         return run_type.generate_run_id(suffix=run_after.isoformat())\n+\n+    def next_dagrun_info_v2(self, *, last_dagrun_info: DagRunInfo | None, restriction: TimeRestriction):\n+        \"\"\"\n+        Provide information to schedule the next DagRun.\n+\n+        The default implementation raises ``NotImplementedError``.\n+\n+        :param last_dagrun_info: The DagRunInfo object of the\n+            Dag's last scheduled or backfilled run.\n+        :param restriction: Restriction to apply when scheduling the DAG run.\n+            See documentation of :class:`TimeRestriction` for details.\n+\n+        :return: Information on when the next DagRun can be scheduled. None\n+            means a DagRun should not be created. This does not mean no more runs\n+            will be scheduled ever again for this DAG; the timetable can return",
      "comment": "```suggestion\n            will be scheduled ever again for this Dag; the timetable can return\n```",
      "comment_id": 2697741597,
      "user": "Lee-W",
      "created_at": "2026-01-16T09:44:38Z",
      "url": "https://github.com/apache/airflow/pull/59115#discussion_r2697741597"
    },
    {
      "repo": "apache/airflow",
      "pr_number": 59115,
      "file_path": "airflow-core/src/airflow/timetables/trigger.py",
      "line": 360,
      "side": "RIGHT",
      "diff_hunk": "@@ -338,8 +347,175 @@ def _dagrun_info_sort_key_no_catchup(info: DagRunInfo | None, *, now: float) ->\n         order values by ``-logical_date`` if they are earlier than or at current\n         time, but ``+logical_date`` if later.\n         \"\"\"\n-        if info is None:\n+        if info is None or info.logical_date is None:\n             return math.inf\n         if (ts := info.logical_date.timestamp()) <= now:\n             return -ts\n         return ts\n+\n+\n+class CronPartitionTimetable(CronTriggerTimetable):\n+    \"\"\"\n+    Timetable that triggers DAG runs according to a cron expression.",
      "comment": "```suggestion\n    Timetable that triggers Dag runs according to a cron expression.\n```",
      "comment_id": 2697744169,
      "user": "Lee-W",
      "created_at": "2026-01-16T09:45:11Z",
      "url": "https://github.com/apache/airflow/pull/59115#discussion_r2697744169"
    },
    {
      "repo": "apache/airflow",
      "pr_number": 59115,
      "file_path": "task-sdk/src/airflow/sdk/bases/timetable.py",
      "line": 50,
      "side": "RIGHT",
      "diff_hunk": "@@ -47,6 +47,8 @@ class BaseTimetable:\n \n     asset_condition: BaseAsset | None = None\n \n+    # TODO: AIP-76 just add partition-driven field here to differentiate the behavior",
      "comment": "* partitioned\n* is_partitioned\n* partiion_driven\n\nBut even if we add such a field, we probably still need a base class, so we don't need to set it to `True` every time? Then, probably using the class itself to check is not a bad idea.\n",
      "comment_id": 2697758956,
      "user": "Lee-W",
      "created_at": "2026-01-16T09:48:51Z",
      "url": "https://github.com/apache/airflow/pull/59115#discussion_r2697758956"
    },
    {
      "repo": "apache/airflow",
      "pr_number": 59115,
      "file_path": "airflow-core/src/airflow/timetables/trigger.py",
      "line": 378,
      "side": "RIGHT",
      "diff_hunk": "@@ -338,8 +347,175 @@ def _dagrun_info_sort_key_no_catchup(info: DagRunInfo | None, *, now: float) ->\n         order values by ``-logical_date`` if they are earlier than or at current\n         time, but ``+logical_date`` if later.\n         \"\"\"\n-        if info is None:\n+        if info is None or info.logical_date is None:\n             return math.inf\n         if (ts := info.logical_date.timestamp()) <= now:\n             return -ts\n         return ts\n+\n+\n+class CronPartitionTimetable(CronTriggerTimetable):\n+    \"\"\"\n+    Timetable that triggers DAG runs according to a cron expression.\n+\n+    Creates runs for partition keys.\n+\n+    The cron expression determines the sequence of run dates. And\n+    the partition dates are derived from those according to the ``run_offset``.\n+    The partition key is then formatted using the partition date.\n+\n+    A ``run_offset`` of 1 means the partition_date will be one cron interval\n+    after the run date; negative means the partition date will be one cron\n+    interval prior to the run date.\n+\n+    :param cron: cron string that defines when to run\n+    :param timezone: Which timezone to use to interpret the cron string\n+    :param run_offset: Integer offset that determines which partition date to run for.\n+        The partition key will be derived from the partition date.\n+    :param key_format: How to translate the partition date into a string partition key.\n+\n+    *run_immediately* controls, if no *start_time* is given to the DAG, when",
      "comment": "```suggestion\n    *run_immediately* controls, if no *start_time* is given to the Dag, when\n```",
      "comment_id": 2697769798,
      "user": "Lee-W",
      "created_at": "2026-01-16T09:51:05Z",
      "url": "https://github.com/apache/airflow/pull/59115#discussion_r2697769798"
    },
    {
      "repo": "apache/airflow",
      "pr_number": 59115,
      "file_path": "airflow-core/src/airflow/timetables/trigger.py",
      "line": 379,
      "side": "RIGHT",
      "diff_hunk": "@@ -338,8 +347,175 @@ def _dagrun_info_sort_key_no_catchup(info: DagRunInfo | None, *, now: float) ->\n         order values by ``-logical_date`` if they are earlier than or at current\n         time, but ``+logical_date`` if later.\n         \"\"\"\n-        if info is None:\n+        if info is None or info.logical_date is None:\n             return math.inf\n         if (ts := info.logical_date.timestamp()) <= now:\n             return -ts\n         return ts\n+\n+\n+class CronPartitionTimetable(CronTriggerTimetable):\n+    \"\"\"\n+    Timetable that triggers DAG runs according to a cron expression.\n+\n+    Creates runs for partition keys.\n+\n+    The cron expression determines the sequence of run dates. And\n+    the partition dates are derived from those according to the ``run_offset``.\n+    The partition key is then formatted using the partition date.\n+\n+    A ``run_offset`` of 1 means the partition_date will be one cron interval\n+    after the run date; negative means the partition date will be one cron\n+    interval prior to the run date.\n+\n+    :param cron: cron string that defines when to run\n+    :param timezone: Which timezone to use to interpret the cron string\n+    :param run_offset: Integer offset that determines which partition date to run for.\n+        The partition key will be derived from the partition date.\n+    :param key_format: How to translate the partition date into a string partition key.\n+\n+    *run_immediately* controls, if no *start_time* is given to the DAG, when\n+    the first run of the DAG should be scheduled. It has no effect if there",
      "comment": "```suggestion\n    the first run of the Dag should be scheduled. It has no effect if there\n```",
      "comment_id": 2697773116,
      "user": "Lee-W",
      "created_at": "2026-01-16T09:51:42Z",
      "url": "https://github.com/apache/airflow/pull/59115#discussion_r2697773116"
    },
    {
      "repo": "apache/airflow",
      "pr_number": 59115,
      "file_path": "airflow-core/src/airflow/timetables/trigger.py",
      "line": 443,
      "side": "RIGHT",
      "diff_hunk": "@@ -338,8 +347,175 @@ def _dagrun_info_sort_key_no_catchup(info: DagRunInfo | None, *, now: float) ->\n         order values by ``-logical_date`` if they are earlier than or at current\n         time, but ``+logical_date`` if later.\n         \"\"\"\n-        if info is None:\n+        if info is None or info.logical_date is None:\n             return math.inf\n         if (ts := info.logical_date.timestamp()) <= now:\n             return -ts\n         return ts\n+\n+\n+class CronPartitionTimetable(CronTriggerTimetable):\n+    \"\"\"\n+    Timetable that triggers DAG runs according to a cron expression.\n+\n+    Creates runs for partition keys.\n+\n+    The cron expression determines the sequence of run dates. And\n+    the partition dates are derived from those according to the ``run_offset``.\n+    The partition key is then formatted using the partition date.\n+\n+    A ``run_offset`` of 1 means the partition_date will be one cron interval\n+    after the run date; negative means the partition date will be one cron\n+    interval prior to the run date.\n+\n+    :param cron: cron string that defines when to run\n+    :param timezone: Which timezone to use to interpret the cron string\n+    :param run_offset: Integer offset that determines which partition date to run for.\n+        The partition key will be derived from the partition date.\n+    :param key_format: How to translate the partition date into a string partition key.\n+\n+    *run_immediately* controls, if no *start_time* is given to the DAG, when\n+    the first run of the DAG should be scheduled. It has no effect if there\n+    already exist runs for this DAG.\n+\n+    * If *True*, always run immediately the most recent possible DAG run.\n+    * If *False*, wait to run until the next scheduled time in the future.\n+    * If passed a ``timedelta``, will run the most recent possible DAG run\n+      if that run's ``data_interval_end`` is within timedelta of now.\n+    * If *None*, the timedelta is calculated as 10% of the time between the\n+      most recent past scheduled time and the next scheduled time. E.g. if\n+      running every hour, this would run the previous time if less than 6\n+      minutes had past since the previous run time, otherwise it would wait\n+      until the next hour.\n+\n+    # todo: AIP-76 talk about how we can have auto-reprocessing of partitions\n+    # todo: AIP-76 we could allow a tuple of integer + time-based\n+\n+    \"\"\"\n+\n+    def __init__(\n+        self,\n+        cron: str,\n+        *,\n+        timezone: str | Timezone | FixedTimezone,\n+        run_offset: int | datetime.timedelta | relativedelta | None = None,\n+        run_immediately: bool | datetime.timedelta = False,\n+        key_format: str = \"%Y-%m-%dT%H:%M:%S\",  # todo: AIP-76 we can't infer partition date from this, so we need to store it separately\n+    ) -> None:\n+        super().__init__(cron, timezone=timezone, run_immediately=run_immediately)\n+        if not isinstance(run_offset, (int, NoneType)):\n+            # todo: AIP-76 implement timedelta / relative delta?\n+            raise ValueError(\"Run offset other than integer not supported yet.\")\n+        self._run_offset = run_offset or 0\n+        self._key_format = key_format\n+\n+    @classmethod\n+    def deserialize(cls, data: dict[str, Any]) -> Timetable:\n+        from airflow.serialization.decoders import decode_run_immediately\n+\n+        offset = data[\"run_offset\"]\n+        if not isinstance(offset, (int, NoneType)):\n+            offset = None\n+            log.warning(\n+                \"Unexpected offset type on deserialization. Only int supported in this version.\",\n+                run_offset=offset,\n+            )\n+\n+        return cls(\n+            cron=data[\"expression\"],\n+            timezone=parse_timezone(data[\"timezone\"]),\n+            run_offset=offset,\n+            run_immediately=decode_run_immediately(data.get(\"run_immediately\", False)),\n+            key_format=data[\"key_format\"],\n+        )\n+\n+    def serialize(self) -> dict[str, Any]:\n+        from airflow.serialization.encoders import encode_run_immediately, encode_timezone\n+\n+        return {\n+            \"expression\": self._expression,\n+            \"timezone\": encode_timezone(self._timezone),\n+            \"run_immediately\": encode_run_immediately(self._run_immediately),\n+            \"run_offset\": self._run_offset,\n+            \"key_format\": self._key_format,\n+        }\n+\n+    def get_partition_date(self, *, run_date):",
      "comment": "```suggestion\n    def get_partition_date(self, *, run_date) -> datetime:\n```",
      "comment_id": 2697778530,
      "user": "Lee-W",
      "created_at": "2026-01-16T09:52:51Z",
      "url": "https://github.com/apache/airflow/pull/59115#discussion_r2697778530"
    },
    {
      "repo": "apache/airflow",
      "pr_number": 59115,
      "file_path": "airflow-core/src/airflow/timetables/trigger.py",
      "line": 504,
      "side": "RIGHT",
      "diff_hunk": "@@ -338,8 +347,175 @@ def _dagrun_info_sort_key_no_catchup(info: DagRunInfo | None, *, now: float) ->\n         order values by ``-logical_date`` if they are earlier than or at current\n         time, but ``+logical_date`` if later.\n         \"\"\"\n-        if info is None:\n+        if info is None or info.logical_date is None:\n             return math.inf\n         if (ts := info.logical_date.timestamp()) <= now:\n             return -ts\n         return ts\n+\n+\n+class CronPartitionTimetable(CronTriggerTimetable):\n+    \"\"\"\n+    Timetable that triggers DAG runs according to a cron expression.\n+\n+    Creates runs for partition keys.\n+\n+    The cron expression determines the sequence of run dates. And\n+    the partition dates are derived from those according to the ``run_offset``.\n+    The partition key is then formatted using the partition date.\n+\n+    A ``run_offset`` of 1 means the partition_date will be one cron interval\n+    after the run date; negative means the partition date will be one cron\n+    interval prior to the run date.\n+\n+    :param cron: cron string that defines when to run\n+    :param timezone: Which timezone to use to interpret the cron string\n+    :param run_offset: Integer offset that determines which partition date to run for.\n+        The partition key will be derived from the partition date.\n+    :param key_format: How to translate the partition date into a string partition key.\n+\n+    *run_immediately* controls, if no *start_time* is given to the DAG, when\n+    the first run of the DAG should be scheduled. It has no effect if there\n+    already exist runs for this DAG.\n+\n+    * If *True*, always run immediately the most recent possible DAG run.\n+    * If *False*, wait to run until the next scheduled time in the future.\n+    * If passed a ``timedelta``, will run the most recent possible DAG run\n+      if that run's ``data_interval_end`` is within timedelta of now.\n+    * If *None*, the timedelta is calculated as 10% of the time between the\n+      most recent past scheduled time and the next scheduled time. E.g. if\n+      running every hour, this would run the previous time if less than 6\n+      minutes had past since the previous run time, otherwise it would wait\n+      until the next hour.\n+\n+    # todo: AIP-76 talk about how we can have auto-reprocessing of partitions\n+    # todo: AIP-76 we could allow a tuple of integer + time-based\n+\n+    \"\"\"\n+\n+    def __init__(\n+        self,\n+        cron: str,\n+        *,\n+        timezone: str | Timezone | FixedTimezone,\n+        run_offset: int | datetime.timedelta | relativedelta | None = None,\n+        run_immediately: bool | datetime.timedelta = False,\n+        key_format: str = \"%Y-%m-%dT%H:%M:%S\",  # todo: AIP-76 we can't infer partition date from this, so we need to store it separately\n+    ) -> None:\n+        super().__init__(cron, timezone=timezone, run_immediately=run_immediately)\n+        if not isinstance(run_offset, (int, NoneType)):\n+            # todo: AIP-76 implement timedelta / relative delta?\n+            raise ValueError(\"Run offset other than integer not supported yet.\")\n+        self._run_offset = run_offset or 0\n+        self._key_format = key_format\n+\n+    @classmethod\n+    def deserialize(cls, data: dict[str, Any]) -> Timetable:\n+        from airflow.serialization.decoders import decode_run_immediately\n+\n+        offset = data[\"run_offset\"]\n+        if not isinstance(offset, (int, NoneType)):\n+            offset = None\n+            log.warning(\n+                \"Unexpected offset type on deserialization. Only int supported in this version.\",\n+                run_offset=offset,\n+            )\n+\n+        return cls(\n+            cron=data[\"expression\"],\n+            timezone=parse_timezone(data[\"timezone\"]),\n+            run_offset=offset,\n+            run_immediately=decode_run_immediately(data.get(\"run_immediately\", False)),\n+            key_format=data[\"key_format\"],\n+        )\n+\n+    def serialize(self) -> dict[str, Any]:\n+        from airflow.serialization.encoders import encode_run_immediately, encode_timezone\n+\n+        return {\n+            \"expression\": self._expression,\n+            \"timezone\": encode_timezone(self._timezone),\n+            \"run_immediately\": encode_run_immediately(self._run_immediately),\n+            \"run_offset\": self._run_offset,\n+            \"key_format\": self._key_format,\n+        }\n+\n+    def get_partition_date(self, *, run_date):\n+        if self._run_offset == 0:\n+            return run_date\n+        # we will need to apply offset to determine run date\n+        partition_date = timezone.coerce_datetime(run_date)\n+        log.info(\n+            \"applying offset to partition date\", partition_date=partition_date, run_offset=self._run_offset\n+        )\n+        iter_func = self._get_next if self._run_offset > 0 else self._get_prev\n+        for _ in range(abs(self._run_offset)):\n+            partition_date = iter_func(partition_date)\n+        log.info(\"new partition date\", partition_date=partition_date)\n+        return partition_date\n+\n+    def next_dagrun_info_v2(\n+        self,\n+        *,\n+        last_dagrun_info: DagRunInfo | None,\n+        restriction: TimeRestriction,\n+    ) -> DagRunInfo | None:\n+        # todo: AIP-76 add test for this logic\n+        # todo: AIP-76 we will have to ensure that the start / end times apply to the partition date ideally,\n+        #  rather than just the run after\n+\n+        if restriction.catchup:\n+            if last_dagrun_info is not None:\n+                next_start_time = self._get_next(last_dagrun_info.run_after)\n+            elif restriction.earliest is None:\n+                next_start_time = self._calc_first_run()\n+            else:\n+                next_start_time = self._align_to_next(restriction.earliest)\n+        else:\n+            prev_candidate = self._align_to_prev(coerce_datetime(utcnow()))\n+            start_time_candidates = [prev_candidate]\n+            if last_dagrun_info is not None:\n+                next_candidate = self._get_next(last_dagrun_info.run_after)\n+                start_time_candidates.append(next_candidate)\n+            elif restriction.earliest is None:\n+                # Run immediately has no effect if there is restriction on earliest\n+                first_run = self._calc_first_run()\n+                start_time_candidates.append(first_run)\n+            if restriction.earliest is not None:\n+                earliest = self._align_to_next(restriction.earliest)\n+                start_time_candidates.append(earliest)\n+            next_start_time = max(start_time_candidates)\n+        if restriction.latest is not None and restriction.latest < next_start_time:\n+            return None\n+\n+        partition_date, partition_key = self.get_partition_info(run_date=next_start_time)\n+        return DagRunInfo(\n+            run_after=next_start_time,\n+            partition_date=partition_date,\n+            partition_key=partition_key,\n+            data_interval=None,\n+        )\n+\n+    def get_partition_info(self, run_date):\n+        partition_date = self.get_partition_date(run_date=run_date)\n+        partition_key = self._format_key(partition_date)\n+        return partition_date, partition_key\n+\n+    def _format_key(self, partition_date: DateTime):",
      "comment": "```suggestion\n    def _format_key(self, partition_date: DateTime) -> str:\n```",
      "comment_id": 2697783906,
      "user": "Lee-W",
      "created_at": "2026-01-16T09:54:07Z",
      "url": "https://github.com/apache/airflow/pull/59115#discussion_r2697783906"
    },
    {
      "repo": "apache/airflow",
      "pr_number": 59115,
      "file_path": "airflow-core/src/airflow/timetables/trigger.py",
      "line": 520,
      "side": "RIGHT",
      "diff_hunk": "@@ -338,8 +347,175 @@ def _dagrun_info_sort_key_no_catchup(info: DagRunInfo | None, *, now: float) ->\n         order values by ``-logical_date`` if they are earlier than or at current\n         time, but ``+logical_date`` if later.\n         \"\"\"\n-        if info is None:\n+        if info is None or info.logical_date is None:\n             return math.inf\n         if (ts := info.logical_date.timestamp()) <= now:\n             return -ts\n         return ts\n+\n+\n+class CronPartitionTimetable(CronTriggerTimetable):\n+    \"\"\"\n+    Timetable that triggers DAG runs according to a cron expression.\n+\n+    Creates runs for partition keys.\n+\n+    The cron expression determines the sequence of run dates. And\n+    the partition dates are derived from those according to the ``run_offset``.\n+    The partition key is then formatted using the partition date.\n+\n+    A ``run_offset`` of 1 means the partition_date will be one cron interval\n+    after the run date; negative means the partition date will be one cron\n+    interval prior to the run date.\n+\n+    :param cron: cron string that defines when to run\n+    :param timezone: Which timezone to use to interpret the cron string\n+    :param run_offset: Integer offset that determines which partition date to run for.\n+        The partition key will be derived from the partition date.\n+    :param key_format: How to translate the partition date into a string partition key.\n+\n+    *run_immediately* controls, if no *start_time* is given to the DAG, when\n+    the first run of the DAG should be scheduled. It has no effect if there\n+    already exist runs for this DAG.\n+\n+    * If *True*, always run immediately the most recent possible DAG run.\n+    * If *False*, wait to run until the next scheduled time in the future.\n+    * If passed a ``timedelta``, will run the most recent possible DAG run\n+      if that run's ``data_interval_end`` is within timedelta of now.\n+    * If *None*, the timedelta is calculated as 10% of the time between the\n+      most recent past scheduled time and the next scheduled time. E.g. if\n+      running every hour, this would run the previous time if less than 6\n+      minutes had past since the previous run time, otherwise it would wait\n+      until the next hour.\n+\n+    # todo: AIP-76 talk about how we can have auto-reprocessing of partitions\n+    # todo: AIP-76 we could allow a tuple of integer + time-based\n+\n+    \"\"\"\n+\n+    def __init__(\n+        self,\n+        cron: str,\n+        *,\n+        timezone: str | Timezone | FixedTimezone,\n+        run_offset: int | datetime.timedelta | relativedelta | None = None,\n+        run_immediately: bool | datetime.timedelta = False,\n+        key_format: str = \"%Y-%m-%dT%H:%M:%S\",  # todo: AIP-76 we can't infer partition date from this, so we need to store it separately\n+    ) -> None:\n+        super().__init__(cron, timezone=timezone, run_immediately=run_immediately)\n+        if not isinstance(run_offset, (int, NoneType)):\n+            # todo: AIP-76 implement timedelta / relative delta?\n+            raise ValueError(\"Run offset other than integer not supported yet.\")\n+        self._run_offset = run_offset or 0\n+        self._key_format = key_format\n+\n+    @classmethod\n+    def deserialize(cls, data: dict[str, Any]) -> Timetable:\n+        from airflow.serialization.decoders import decode_run_immediately\n+\n+        offset = data[\"run_offset\"]\n+        if not isinstance(offset, (int, NoneType)):\n+            offset = None\n+            log.warning(\n+                \"Unexpected offset type on deserialization. Only int supported in this version.\",\n+                run_offset=offset,\n+            )\n+\n+        return cls(\n+            cron=data[\"expression\"],\n+            timezone=parse_timezone(data[\"timezone\"]),\n+            run_offset=offset,\n+            run_immediately=decode_run_immediately(data.get(\"run_immediately\", False)),\n+            key_format=data[\"key_format\"],\n+        )\n+\n+    def serialize(self) -> dict[str, Any]:\n+        from airflow.serialization.encoders import encode_run_immediately, encode_timezone\n+\n+        return {\n+            \"expression\": self._expression,\n+            \"timezone\": encode_timezone(self._timezone),\n+            \"run_immediately\": encode_run_immediately(self._run_immediately),\n+            \"run_offset\": self._run_offset,\n+            \"key_format\": self._key_format,\n+        }\n+\n+    def get_partition_date(self, *, run_date):\n+        if self._run_offset == 0:\n+            return run_date\n+        # we will need to apply offset to determine run date\n+        partition_date = timezone.coerce_datetime(run_date)\n+        log.info(\n+            \"applying offset to partition date\", partition_date=partition_date, run_offset=self._run_offset\n+        )\n+        iter_func = self._get_next if self._run_offset > 0 else self._get_prev\n+        for _ in range(abs(self._run_offset)):\n+            partition_date = iter_func(partition_date)\n+        log.info(\"new partition date\", partition_date=partition_date)\n+        return partition_date\n+\n+    def next_dagrun_info_v2(\n+        self,\n+        *,\n+        last_dagrun_info: DagRunInfo | None,\n+        restriction: TimeRestriction,\n+    ) -> DagRunInfo | None:\n+        # todo: AIP-76 add test for this logic\n+        # todo: AIP-76 we will have to ensure that the start / end times apply to the partition date ideally,\n+        #  rather than just the run after\n+\n+        if restriction.catchup:\n+            if last_dagrun_info is not None:\n+                next_start_time = self._get_next(last_dagrun_info.run_after)\n+            elif restriction.earliest is None:\n+                next_start_time = self._calc_first_run()\n+            else:\n+                next_start_time = self._align_to_next(restriction.earliest)\n+        else:\n+            prev_candidate = self._align_to_prev(coerce_datetime(utcnow()))\n+            start_time_candidates = [prev_candidate]\n+            if last_dagrun_info is not None:\n+                next_candidate = self._get_next(last_dagrun_info.run_after)\n+                start_time_candidates.append(next_candidate)\n+            elif restriction.earliest is None:\n+                # Run immediately has no effect if there is restriction on earliest\n+                first_run = self._calc_first_run()\n+                start_time_candidates.append(first_run)\n+            if restriction.earliest is not None:\n+                earliest = self._align_to_next(restriction.earliest)\n+                start_time_candidates.append(earliest)\n+            next_start_time = max(start_time_candidates)\n+        if restriction.latest is not None and restriction.latest < next_start_time:\n+            return None\n+\n+        partition_date, partition_key = self.get_partition_info(run_date=next_start_time)\n+        return DagRunInfo(\n+            run_after=next_start_time,\n+            partition_date=partition_date,\n+            partition_key=partition_key,\n+            data_interval=None,\n+        )\n+\n+    def get_partition_info(self, run_date):\n+        partition_date = self.get_partition_date(run_date=run_date)\n+        partition_key = self._format_key(partition_date)\n+        return partition_date, partition_key\n+\n+    def _format_key(self, partition_date: DateTime):\n+        return partition_date.strftime(self._key_format)\n+\n+    def generate_run_id(\n+        self,\n+        *,\n+        run_type: DagRunType,\n+        run_after: DateTime,\n+        data_interval: DataInterval | None,\n+        **extra,\n+    ) -> str:\n+        partition_key = extra.get(\"partition_key\")\n+        components = [\n+            run_after.isoformat(),\n+            partition_key,\n+            get_random_string(),\n+        ]",
      "comment": "```suggestion\n        components = [\n            run_after.isoformat(),\n            extra.get(\"partition_key\"),\n            get_random_string(),\n        ]\n```",
      "comment_id": 2697786882,
      "user": "Lee-W",
      "created_at": "2026-01-16T09:54:49Z",
      "url": "https://github.com/apache/airflow/pull/59115#discussion_r2697786882"
    },
    {
      "repo": "apache/airflow",
      "pr_number": 59115,
      "file_path": "airflow-core/src/airflow/timetables/trigger.py",
      "line": 499,
      "side": "RIGHT",
      "diff_hunk": "@@ -338,8 +347,175 @@ def _dagrun_info_sort_key_no_catchup(info: DagRunInfo | None, *, now: float) ->\n         order values by ``-logical_date`` if they are earlier than or at current\n         time, but ``+logical_date`` if later.\n         \"\"\"\n-        if info is None:\n+        if info is None or info.logical_date is None:\n             return math.inf\n         if (ts := info.logical_date.timestamp()) <= now:\n             return -ts\n         return ts\n+\n+\n+class CronPartitionTimetable(CronTriggerTimetable):\n+    \"\"\"\n+    Timetable that triggers DAG runs according to a cron expression.\n+\n+    Creates runs for partition keys.\n+\n+    The cron expression determines the sequence of run dates. And\n+    the partition dates are derived from those according to the ``run_offset``.\n+    The partition key is then formatted using the partition date.\n+\n+    A ``run_offset`` of 1 means the partition_date will be one cron interval\n+    after the run date; negative means the partition date will be one cron\n+    interval prior to the run date.\n+\n+    :param cron: cron string that defines when to run\n+    :param timezone: Which timezone to use to interpret the cron string\n+    :param run_offset: Integer offset that determines which partition date to run for.\n+        The partition key will be derived from the partition date.\n+    :param key_format: How to translate the partition date into a string partition key.\n+\n+    *run_immediately* controls, if no *start_time* is given to the DAG, when\n+    the first run of the DAG should be scheduled. It has no effect if there\n+    already exist runs for this DAG.\n+\n+    * If *True*, always run immediately the most recent possible DAG run.\n+    * If *False*, wait to run until the next scheduled time in the future.\n+    * If passed a ``timedelta``, will run the most recent possible DAG run\n+      if that run's ``data_interval_end`` is within timedelta of now.\n+    * If *None*, the timedelta is calculated as 10% of the time between the\n+      most recent past scheduled time and the next scheduled time. E.g. if\n+      running every hour, this would run the previous time if less than 6\n+      minutes had past since the previous run time, otherwise it would wait\n+      until the next hour.\n+\n+    # todo: AIP-76 talk about how we can have auto-reprocessing of partitions\n+    # todo: AIP-76 we could allow a tuple of integer + time-based\n+\n+    \"\"\"\n+\n+    def __init__(\n+        self,\n+        cron: str,\n+        *,\n+        timezone: str | Timezone | FixedTimezone,\n+        run_offset: int | datetime.timedelta | relativedelta | None = None,\n+        run_immediately: bool | datetime.timedelta = False,\n+        key_format: str = \"%Y-%m-%dT%H:%M:%S\",  # todo: AIP-76 we can't infer partition date from this, so we need to store it separately\n+    ) -> None:\n+        super().__init__(cron, timezone=timezone, run_immediately=run_immediately)\n+        if not isinstance(run_offset, (int, NoneType)):\n+            # todo: AIP-76 implement timedelta / relative delta?\n+            raise ValueError(\"Run offset other than integer not supported yet.\")\n+        self._run_offset = run_offset or 0\n+        self._key_format = key_format\n+\n+    @classmethod\n+    def deserialize(cls, data: dict[str, Any]) -> Timetable:\n+        from airflow.serialization.decoders import decode_run_immediately\n+\n+        offset = data[\"run_offset\"]\n+        if not isinstance(offset, (int, NoneType)):\n+            offset = None\n+            log.warning(\n+                \"Unexpected offset type on deserialization. Only int supported in this version.\",\n+                run_offset=offset,\n+            )\n+\n+        return cls(\n+            cron=data[\"expression\"],\n+            timezone=parse_timezone(data[\"timezone\"]),\n+            run_offset=offset,\n+            run_immediately=decode_run_immediately(data.get(\"run_immediately\", False)),\n+            key_format=data[\"key_format\"],\n+        )\n+\n+    def serialize(self) -> dict[str, Any]:\n+        from airflow.serialization.encoders import encode_run_immediately, encode_timezone\n+\n+        return {\n+            \"expression\": self._expression,\n+            \"timezone\": encode_timezone(self._timezone),\n+            \"run_immediately\": encode_run_immediately(self._run_immediately),\n+            \"run_offset\": self._run_offset,\n+            \"key_format\": self._key_format,\n+        }\n+\n+    def get_partition_date(self, *, run_date):\n+        if self._run_offset == 0:\n+            return run_date\n+        # we will need to apply offset to determine run date\n+        partition_date = timezone.coerce_datetime(run_date)\n+        log.info(\n+            \"applying offset to partition date\", partition_date=partition_date, run_offset=self._run_offset\n+        )\n+        iter_func = self._get_next if self._run_offset > 0 else self._get_prev\n+        for _ in range(abs(self._run_offset)):\n+            partition_date = iter_func(partition_date)\n+        log.info(\"new partition date\", partition_date=partition_date)\n+        return partition_date\n+\n+    def next_dagrun_info_v2(\n+        self,\n+        *,\n+        last_dagrun_info: DagRunInfo | None,\n+        restriction: TimeRestriction,\n+    ) -> DagRunInfo | None:\n+        # todo: AIP-76 add test for this logic\n+        # todo: AIP-76 we will have to ensure that the start / end times apply to the partition date ideally,\n+        #  rather than just the run after\n+\n+        if restriction.catchup:\n+            if last_dagrun_info is not None:\n+                next_start_time = self._get_next(last_dagrun_info.run_after)\n+            elif restriction.earliest is None:\n+                next_start_time = self._calc_first_run()\n+            else:\n+                next_start_time = self._align_to_next(restriction.earliest)\n+        else:\n+            prev_candidate = self._align_to_prev(coerce_datetime(utcnow()))\n+            start_time_candidates = [prev_candidate]\n+            if last_dagrun_info is not None:\n+                next_candidate = self._get_next(last_dagrun_info.run_after)\n+                start_time_candidates.append(next_candidate)\n+            elif restriction.earliest is None:\n+                # Run immediately has no effect if there is restriction on earliest\n+                first_run = self._calc_first_run()\n+                start_time_candidates.append(first_run)\n+            if restriction.earliest is not None:\n+                earliest = self._align_to_next(restriction.earliest)\n+                start_time_candidates.append(earliest)\n+            next_start_time = max(start_time_candidates)\n+        if restriction.latest is not None and restriction.latest < next_start_time:\n+            return None\n+\n+        partition_date, partition_key = self.get_partition_info(run_date=next_start_time)\n+        return DagRunInfo(\n+            run_after=next_start_time,\n+            partition_date=partition_date,\n+            partition_key=partition_key,\n+            data_interval=None,\n+        )\n+\n+    def get_partition_info(self, run_date):",
      "comment": "```suggestion\n    def get_partition_info(self, run_date: datetime) -> tuple[datetime, str]:\n```",
      "comment_id": 2697791518,
      "user": "Lee-W",
      "created_at": "2026-01-16T09:55:56Z",
      "url": "https://github.com/apache/airflow/pull/59115#discussion_r2697791518"
    },
    {
      "repo": "apache/airflow",
      "pr_number": 59115,
      "file_path": "airflow-core/src/airflow/dag_processing/collection.py",
      "line": 148,
      "side": "RIGHT",
      "diff_hunk": "@@ -129,6 +130,39 @@ def _get_latest_runs_stmt(dag_id: str) -> Select:\n     )\n \n \n+def _get_latest_runs_stmt_partitioned(dag_id: str) -> Select:\n+    \"\"\"Build a select statement to retrieve the last automated run for each dag.\"\"\"\n+    # todo: AIP-76 we should add a partition date field\n+    latest_run_id = (\n+        select(DagRun.id)\n+        .where(\n+            DagRun.dag_id == dag_id,\n+            DagRun.run_type.in_(\n+                (\n+                    DagRunType.BACKFILL_JOB,\n+                    DagRunType.SCHEDULED,\n+                )\n+            ),\n+            DagRun.partition_key.is_not(None),\n+        )\n+        .order_by(DagRun.id.desc())",
      "comment": "yeah, i think we probably need to add partition date and sort by it here. but for now, this is about as good as we can do. i have added a todo",
      "comment_id": 2698738603,
      "user": "dstandish",
      "created_at": "2026-01-16T14:32:09Z",
      "url": "https://github.com/apache/airflow/pull/59115#discussion_r2698738603"
    },
    {
      "repo": "apache/airflow",
      "pr_number": 59115,
      "file_path": "airflow-core/src/airflow/jobs/scheduler_job_runner.py",
      "line": 1816,
      "side": "RIGHT",
      "diff_hunk": "@@ -1765,24 +1767,48 @@ def _create_dag_runs(self, dag_models: Collection[DagModel], session: Session) -\n         # as DagModel.dag_id and DagModel.next_dagrun\n         # This list is used to verify if the DagRun already exist so that we don't attempt to create\n         # duplicate DagRuns\n-        existing_dagruns = (\n-            session.execute(\n-                select(DagRun.dag_id, DagRun.logical_date).where(\n+        existing_dagrun_objects = (\n+            session.scalars(\n+                select(DagRun)\n+                .where(\n                     tuple_(DagRun.dag_id, DagRun.logical_date).in_(\n                         (dm.dag_id, dm.next_dagrun) for dm in dag_models\n-                    ),\n+                    )\n                 )\n+                .options(load_only(DagRun.dag_id, DagRun.logical_date))\n             )\n             .unique()\n             .all()\n         )\n+        existing_dagruns = {(x.dag_id, x.logical_date): x for x in existing_dagrun_objects}",
      "comment": "what do we need ... what?  this is a dictionary that is later used to find the dr for existing run\r\n\r\nit's basically for when something went wrong, scheduler trying to create not-latest run, and we need to advance next_dagrun on DagModel",
      "comment_id": 2698745380,
      "user": "dstandish",
      "created_at": "2026-01-16T14:33:57Z",
      "url": "https://github.com/apache/airflow/pull/59115#discussion_r2698745380"
    },
    {
      "repo": "apache/airflow",
      "pr_number": 59115,
      "file_path": "airflow-core/src/airflow/dag_processing/collection.py",
      "line": 133,
      "side": "RIGHT",
      "diff_hunk": "@@ -129,6 +130,39 @@ def _get_latest_runs_stmt(dag_id: str) -> Select:\n     )\n \n \n+def _get_latest_runs_stmt_partitioned(dag_id: str) -> Select:",
      "comment": "my approach here was \r\n`_get_latest_runs_stmt`\r\nand\r\n`_get_latest_runs_stmt_partitioned` \r\n",
      "comment_id": 2700219623,
      "user": "dstandish",
      "created_at": "2026-01-16T22:41:46Z",
      "url": "https://github.com/apache/airflow/pull/59115#discussion_r2700219623"
    },
    {
      "repo": "apache/airflow",
      "pr_number": 59115,
      "file_path": "airflow-core/src/airflow/dag_processing/collection.py",
      "line": 133,
      "side": "RIGHT",
      "diff_hunk": "@@ -129,6 +130,39 @@ def _get_latest_runs_stmt(dag_id: str) -> Select:\n     )\n \n \n+def _get_latest_runs_stmt_partitioned(dag_id: str) -> Select:",
      "comment": "It doesn't really make sense in my taste, but I'm ok with it. ",
      "comment_id": 2700710679,
      "user": "Lee-W",
      "created_at": "2026-01-17T07:00:14Z",
      "url": "https://github.com/apache/airflow/pull/59115#discussion_r2700710679"
    },
    {
      "repo": "apache/airflow",
      "pr_number": 59115,
      "file_path": "airflow-core/src/airflow/jobs/scheduler_job_runner.py",
      "line": 1810,
      "side": "RIGHT",
      "diff_hunk": "@@ -1765,24 +1767,48 @@ def _create_dag_runs(self, dag_models: Collection[DagModel], session: Session) -\n         # as DagModel.dag_id and DagModel.next_dagrun\n         # This list is used to verify if the DagRun already exist so that we don't attempt to create\n         # duplicate DagRuns\n-        existing_dagruns = (\n-            session.execute(\n-                select(DagRun.dag_id, DagRun.logical_date).where(\n+        existing_dagrun_objects = (\n+            session.scalars(\n+                select(DagRun)\n+                .where(\n                     tuple_(DagRun.dag_id, DagRun.logical_date).in_(\n                         (dm.dag_id, dm.next_dagrun) for dm in dag_models\n-                    ),\n+                    )\n                 )\n+                .options(load_only(DagRun.dag_id, DagRun.logical_date))\n             )\n             .unique()\n             .all()\n         )\n+        existing_dagruns = {(x.dag_id, x.logical_date): x for x in existing_dagrun_objects}\n+\n+        # todo: AIP-76 we may want to update check existing to also check partitioned dag runs,\n+        #  but the thing is, there is not actually a restriction that\n+        #  we don't create new runs with the same partition key\n+        #  so it's unclear whether we should / need to.\n+\n+        partitioned_dags = set()\n+        non_partitioned_dags: list[DagModel] = []\n+        missing_dags = set()\n+        serdags: dict[str, SerializedDAG] = {}\n+        for dag in dag_models:\n+            serdag = _get_current_dag(dag_id=dag.dag_id, session=session)\n+            if serdag:\n+                serdags[serdag.dag_id] = serdag\n+                if isinstance(serdag.timetable, CronPartitionTimetable):\n+                    # todo: AIP-76 there may be a better way to identify this!\n+                    #  should we use an attribute on BaseTimetable instead?",
      "comment": "Yep, I also remember that. Either way works, I think. No strong opinion",
      "comment_id": 2700711040,
      "user": "Lee-W",
      "created_at": "2026-01-17T07:01:01Z",
      "url": "https://github.com/apache/airflow/pull/59115#discussion_r2700711040"
    },
    {
      "repo": "apache/airflow",
      "pr_number": 59115,
      "file_path": "airflow-core/src/airflow/api/common/mark_tasks.py",
      "line": 75,
      "side": "RIGHT",
      "diff_hunk": "@@ -70,6 +70,9 @@ def set_state(\n     :param commit: Commit tasks to be altered to the database\n     :param session: database session\n     :return: list of tasks that have been created and updated\n+\n+    TODO: \"past\" and \"future\" params currently depend on logical date, which is not always populated.\n+      we might want to just deprecate these options.  Or alter them to do *something* in that case.",
      "comment": "Do it based on the partition date for a time-based partition could also be an option",
      "comment_id": 2708341430,
      "user": "Lee-W",
      "created_at": "2026-01-20T13:23:01Z",
      "url": "https://github.com/apache/airflow/pull/59115#discussion_r2708341430"
    },
    {
      "repo": "apache/airflow",
      "pr_number": 59115,
      "file_path": "airflow-core/src/airflow/jobs/scheduler_job_runner.py",
      "line": 1810,
      "side": "RIGHT",
      "diff_hunk": "@@ -1765,24 +1767,48 @@ def _create_dag_runs(self, dag_models: Collection[DagModel], session: Session) -\n         # as DagModel.dag_id and DagModel.next_dagrun\n         # This list is used to verify if the DagRun already exist so that we don't attempt to create\n         # duplicate DagRuns\n-        existing_dagruns = (\n-            session.execute(\n-                select(DagRun.dag_id, DagRun.logical_date).where(\n+        existing_dagrun_objects = (\n+            session.scalars(\n+                select(DagRun)\n+                .where(\n                     tuple_(DagRun.dag_id, DagRun.logical_date).in_(\n                         (dm.dag_id, dm.next_dagrun) for dm in dag_models\n-                    ),\n+                    )\n                 )\n+                .options(load_only(DagRun.dag_id, DagRun.logical_date))\n             )\n             .unique()\n             .all()\n         )\n+        existing_dagruns = {(x.dag_id, x.logical_date): x for x in existing_dagrun_objects}\n+\n+        # todo: AIP-76 we may want to update check existing to also check partitioned dag runs,\n+        #  but the thing is, there is not actually a restriction that\n+        #  we don't create new runs with the same partition key\n+        #  so it's unclear whether we should / need to.\n+\n+        partitioned_dags = set()\n+        non_partitioned_dags: list[DagModel] = []\n+        missing_dags = set()\n+        serdags: dict[str, SerializedDAG] = {}\n+        for dag in dag_models:\n+            serdag = _get_current_dag(dag_id=dag.dag_id, session=session)\n+            if serdag:\n+                serdags[serdag.dag_id] = serdag\n+                if isinstance(serdag.timetable, CronPartitionTimetable):\n+                    # todo: AIP-76 there may be a better way to identify this!\n+                    #  should we use an attribute on BaseTimetable instead?",
      "comment": "i will do attribute. then i think this should be ready to go.",
      "comment_id": 2709113120,
      "user": "dstandish",
      "created_at": "2026-01-20T16:25:04Z",
      "url": "https://github.com/apache/airflow/pull/59115#discussion_r2709113120"
    },
    {
      "repo": "apache/airflow",
      "pr_number": 59115,
      "file_path": "airflow-core/src/airflow/dag_processing/collection.py",
      "line": 181,
      "side": "RIGHT",
      "diff_hunk": "@@ -144,7 +178,23 @@ def calculate(cls, dag: LazyDeserializedDAG, *, session: Session) -> Self:\n         if not dag.timetable.can_be_scheduled:\n             return cls(None, 0)\n \n-        latest_run = session.scalar(_get_latest_runs_stmt(dag_id=dag.dag_id))\n+        if isinstance(  # todo: AIP-76 what's a more general way to detect?",
      "comment": "i actually figured out, i think, a way where we don't need an attribute",
      "comment_id": 2710419442,
      "user": "dstandish",
      "created_at": "2026-01-20T23:25:35Z",
      "url": "https://github.com/apache/airflow/pull/59115#discussion_r2710419442"
    },
    {
      "repo": "apache/airflow",
      "pr_number": 59115,
      "file_path": "airflow-core/src/airflow/api/common/mark_tasks.py",
      "line": 75,
      "side": "RIGHT",
      "diff_hunk": "@@ -70,6 +70,9 @@ def set_state(\n     :param commit: Commit tasks to be altered to the database\n     :param session: database session\n     :return: list of tasks that have been created and updated\n+\n+    TODO: \"past\" and \"future\" params currently depend on logical date, which is not always populated.\n+      we might want to just deprecate these options.  Or alter them to do *something* in that case.",
      "comment": "yes, i think we need to add partition date as a field on dag run -- i'm avoiding adding that in this pr though just cus it's already huge\r\n",
      "comment_id": 2713368474,
      "user": "dstandish",
      "created_at": "2026-01-21T16:30:23Z",
      "url": "https://github.com/apache/airflow/pull/59115#discussion_r2713368474"
    },
    {
      "repo": "apache/airflow",
      "pr_number": 59115,
      "file_path": "task-sdk/src/airflow/sdk/bases/timetable.py",
      "line": 50,
      "side": "RIGHT",
      "diff_hunk": "@@ -47,6 +47,8 @@ class BaseTimetable:\n \n     asset_condition: BaseAsset | None = None\n \n+    # TODO: AIP-76 just add partition-driven field here to differentiate the behavior",
      "comment": "i think we may not need a field or a base class at this time, as i demonstrated last night",
      "comment_id": 2713409548,
      "user": "dstandish",
      "created_at": "2026-01-21T16:40:14Z",
      "url": "https://github.com/apache/airflow/pull/59115#discussion_r2713409548"
    },
    {
      "repo": "apache/airflow",
      "pr_number": 60022,
      "file_path": "airflow-core/tests/unit/listeners/test_asset_listener.py",
      "line": 63,
      "side": "RIGHT",
      "diff_hunk": "@@ -57,7 +57,7 @@ def test_asset_listener_on_asset_changed_gets_calls(\n     )\n     ti.run()\n \n-    assert len(asset_listener.changed) == 1\n-    assert asset_listener.changed[0].uri == asset_uri\n-    assert asset_listener.changed[0].name == asset_name\n-    assert asset_listener.changed[0].group == asset_group\n+    assert len(asset_listener.changed) == 2\n+    assert asset_listener.changed[-1].uri == asset_uri\n+    assert asset_listener.changed[-1].name == asset_name\n+    assert asset_listener.changed[-1].group == asset_group",
      "comment": "This fails the test and doesn't seem to look right to me. Thus, I reverted this part. @Jkhall81 Let me know if I missed anything. Thanks!",
      "comment_id": 2726939608,
      "user": "Lee-W",
      "created_at": "2026-01-26T09:45:23Z",
      "url": "https://github.com/apache/airflow/pull/60022#discussion_r2726939608"
    },
    {
      "repo": "apache/airflow",
      "pr_number": 61118,
      "file_path": "airflow-core/tests/unit/models/test_deadline_alert.py",
      "line": 178,
      "side": "RIGHT",
      "diff_hunk": "@@ -175,7 +175,7 @@ def test_deadline_alert_hash(self, session, deadline_reference):\n         assert hash(alert1) == hash(alert2)\n \n     def test_deadline_alert_reference_class_property(self, deadline_alert_orm):\n-        assert deadline_alert_orm.reference_class == ReferenceModels.DagRunQueuedAtDeadline\n+        assert deadline_alert_orm.reference_class == SerializedReferenceModels.DagRunQueuedAtDeadline",
      "comment": "Now reference_class returns a `SerializedReferenceModels`",
      "comment_id": 2732266217,
      "user": "amoghrajesh",
      "created_at": "2026-01-27T14:25:07Z",
      "url": "https://github.com/apache/airflow/pull/61118#discussion_r2732266217"
    },
    {
      "repo": "apache/airflow",
      "pr_number": 61118,
      "file_path": "airflow-core/src/airflow/serialization/decoders.py",
      "line": 147,
      "side": "RIGHT",
      "diff_hunk": "@@ -131,6 +135,32 @@ def decode_asset_like(var: dict[str, Any]) -> SerializedAssetBase:\n             raise ValueError(f\"deserialization not implemented for DAT {data_type!r}\")\n \n \n+def decode_deadline_alert(encoded_data: dict):\n+    \"\"\"\n+    Decode a previously serialized deadline alert.\n+\n+    :meta private:\n+    \"\"\"\n+    from datetime import timedelta\n+\n+    from airflow.sdk.serde import deserialize\n+    from airflow.serialization.definitions.deadline import SerializedDeadlineAlert",
      "comment": "Here and elsewhere:  Why are we introducing local imports all over the place?  Isn't the project standard to use top-level imports unless we have a reason not to (circular imports, etc)?",
      "comment_id": 2734113801,
      "user": "ferruzzi",
      "created_at": "2026-01-27T22:44:42Z",
      "url": "https://github.com/apache/airflow/pull/61118#discussion_r2734113801"
    },
    {
      "repo": "apache/airflow",
      "pr_number": 61118,
      "file_path": "airflow-core/tests/unit/serialization/test_serialized_objects.py",
      "line": 496,
      "side": "RIGHT",
      "diff_hunk": "@@ -485,14 +485,16 @@ def test_serialize_deserialize_deadline_alert(reference):\n         callback=AsyncCallback(empty_callback_for_deadline, kwargs=TEST_CALLBACK_KWARGS),\n     )\n \n-    serialized = original.serialize_deadline_alert()\n+    # Use BaseSerialization like assets do\n+    serialized = BaseSerialization.serialize(original)\n     assert serialized[Encoding.TYPE] == DAT.DEADLINE_ALERT\n     assert set(serialized[Encoding.VAR].keys()) == public_deadline_alert_fields\n \n-    deserialized = DeadlineAlert.deserialize_deadline_alert(serialized)\n+    deserialized = BaseSerialization.deserialize(serialized)\n     assert deserialized.reference.serialize_reference() == reference.serialize_reference()\n     assert deserialized.interval == original.interval\n-    assert deserialized.callback == original.callback\n+    # Callback is deserialized as SerializedDeadlineAlert, which may have different callback representation",
      "comment": "Shouldn't serializing then deserializing return the original?  Or at least \"a new object containing equal values\", not the literal same object.",
      "comment_id": 2734123937,
      "user": "ferruzzi",
      "created_at": "2026-01-27T22:48:57Z",
      "url": "https://github.com/apache/airflow/pull/61118#discussion_r2734123937"
    },
    {
      "repo": "apache/airflow",
      "pr_number": 61118,
      "file_path": "airflow-core/src/airflow/serialization/serialized_objects.py",
      "line": 516,
      "side": "RIGHT",
      "diff_hunk": "@@ -512,8 +513,10 @@ def serialize(\n             )\n         elif isinstance(var, DAG):\n             return cls._encode(DagSerialization.serialize_dag(var), type_=DAT.DAG)\n-        elif isinstance(var, DeadlineAlert):\n-            return cls._encode(DeadlineAlert.serialize_deadline_alert(var), type_=DAT.DEADLINE_ALERT)\n+        elif isinstance(var, (DeadlineAlert, SerializedDeadlineAlert)):",
      "comment": "I'm not sure I follow why it can be either one.  If you are attempting to serialize then shouldn't it be  the unserialized version coming in?  Or is this just defensive in case we try to re-serialize?  I don't see this pattern in the other elif clauses so it seems a odd enough to ask.",
      "comment_id": 2734161160,
      "user": "ferruzzi",
      "created_at": "2026-01-27T23:00:51Z",
      "url": "https://github.com/apache/airflow/pull/61118#discussion_r2734161160"
    },
    {
      "repo": "apache/airflow",
      "pr_number": 61118,
      "file_path": "airflow-core/src/airflow/serialization/definitions/deadline.py",
      "line": 50,
      "side": "RIGHT",
      "diff_hunk": "@@ -28,3 +46,235 @@ class DeadlineAlertFields:\n     REFERENCE = \"reference\"\n     INTERVAL = \"interval\"\n     CALLBACK = \"callback\"\n+\n+",
      "comment": "For the most part this is all copypasta from the old ReferenceModels, other than renaming some of the the classes and type hints?  Just double checking, let me know if there are specific changes I should take a closer look at closer in this file.",
      "comment_id": 2734174393,
      "user": "ferruzzi",
      "created_at": "2026-01-27T23:03:40Z",
      "url": "https://github.com/apache/airflow/pull/61118#discussion_r2734174393"
    },
    {
      "repo": "apache/airflow",
      "pr_number": 61118,
      "file_path": "airflow-core/src/airflow/serialization/decoders.py",
      "line": 147,
      "side": "RIGHT",
      "diff_hunk": "@@ -131,6 +135,32 @@ def decode_asset_like(var: dict[str, Any]) -> SerializedAssetBase:\n             raise ValueError(f\"deserialization not implemented for DAT {data_type!r}\")\n \n \n+def decode_deadline_alert(encoded_data: dict):\n+    \"\"\"\n+    Decode a previously serialized deadline alert.\n+\n+    :meta private:\n+    \"\"\"\n+    from datetime import timedelta\n+\n+    from airflow.sdk.serde import deserialize\n+    from airflow.serialization.definitions.deadline import SerializedDeadlineAlert",
      "comment": "There is no reason that was done, let me make the change to make it proper",
      "comment_id": 2734968924,
      "user": "amoghrajesh",
      "created_at": "2026-01-28T05:50:58Z",
      "url": "https://github.com/apache/airflow/pull/61118#discussion_r2734968924"
    },
    {
      "repo": "apache/airflow",
      "pr_number": 61118,
      "file_path": "airflow-core/src/airflow/serialization/serialized_objects.py",
      "line": 516,
      "side": "RIGHT",
      "diff_hunk": "@@ -512,8 +513,10 @@ def serialize(\n             )\n         elif isinstance(var, DAG):\n             return cls._encode(DagSerialization.serialize_dag(var), type_=DAT.DAG)\n-        elif isinstance(var, DeadlineAlert):\n-            return cls._encode(DeadlineAlert.serialize_deadline_alert(var), type_=DAT.DEADLINE_ALERT)\n+        elif isinstance(var, (DeadlineAlert, SerializedDeadlineAlert)):",
      "comment": "On normal days, `DeadlineAlert` should be the one coming in, but I followed this pattern just defensively similar to how assets does it: https://github.com/apache/airflow/pull/58993/changes#diff-2f03f28d3201c630dfbae758caf95ada61ab10328de789fc464f6e27c4afb2d0R700-R701\n\nThere is a very rare case when a serialized version can come in, like for example reserializing. If someone loads a DAG from db and tries to modify the in memory dag object. Rare case, so maybe I can remove it as well if you like.",
      "comment_id": 2735003392,
      "user": "amoghrajesh",
      "created_at": "2026-01-28T06:07:23Z",
      "url": "https://github.com/apache/airflow/pull/61118#discussion_r2735003392"
    },
    {
      "repo": "apache/airflow",
      "pr_number": 61118,
      "file_path": "airflow-core/tests/unit/serialization/test_serialized_objects.py",
      "line": 496,
      "side": "RIGHT",
      "diff_hunk": "@@ -485,14 +485,16 @@ def test_serialize_deserialize_deadline_alert(reference):\n         callback=AsyncCallback(empty_callback_for_deadline, kwargs=TEST_CALLBACK_KWARGS),\n     )\n \n-    serialized = original.serialize_deadline_alert()\n+    # Use BaseSerialization like assets do\n+    serialized = BaseSerialization.serialize(original)\n     assert serialized[Encoding.TYPE] == DAT.DEADLINE_ALERT\n     assert set(serialized[Encoding.VAR].keys()) == public_deadline_alert_fields\n \n-    deserialized = DeadlineAlert.deserialize_deadline_alert(serialized)\n+    deserialized = BaseSerialization.deserialize(serialized)\n     assert deserialized.reference.serialize_reference() == reference.serialize_reference()\n     assert deserialized.interval == original.interval\n-    assert deserialized.callback == original.callback\n+    # Callback is deserialized as SerializedDeadlineAlert, which may have different callback representation",
      "comment": "It's actually supposed to be the same, this was when I was exploring some other option to support callback serialisation for callbacks. Now I am just using serde like earlier. ",
      "comment_id": 2735017854,
      "user": "amoghrajesh",
      "created_at": "2026-01-28T06:13:42Z",
      "url": "https://github.com/apache/airflow/pull/61118#discussion_r2735017854"
    },
    {
      "repo": "apache/airflow",
      "pr_number": 61118,
      "file_path": "airflow-core/src/airflow/serialization/definitions/deadline.py",
      "line": 50,
      "side": "RIGHT",
      "diff_hunk": "@@ -28,3 +46,235 @@ class DeadlineAlertFields:\n     REFERENCE = \"reference\"\n     INTERVAL = \"interval\"\n     CALLBACK = \"callback\"\n+\n+",
      "comment": "That's that yes, its mostly copypasta from the older models but with some renaming. You can just skim this one through, no need to check in great detail",
      "comment_id": 2735024339,
      "user": "amoghrajesh",
      "created_at": "2026-01-28T06:16:38Z",
      "url": "https://github.com/apache/airflow/pull/61118#discussion_r2735024339"
    },
    {
      "repo": "apache/airflow",
      "pr_number": 61021,
      "file_path": "airflow-ctl/src/airflowctl/api/operations.py",
      "line": 826,
      "side": "RIGHT",
      "diff_hunk": "@@ -697,3 +702,125 @@ def get(self) -> VersionInfo | ServerResponseError:\n             return VersionInfo.model_validate_json(self.response.content)\n         except ServerResponseError as e:\n             raise e\n+\n+\n+class XComOperations(BaseOperations):\n+    \"\"\"XCom operations.\"\"\"\n+\n+    def get(\n+        self,\n+        dag_id: str,\n+        dag_run_id: str,\n+        task_id: str,\n+        key: str,\n+        map_index: int = None,  # type: ignore\n+    ) -> XComResponseNative | ServerResponseError:\n+        \"\"\"Get an XCom entry.\"\"\"\n+        try:\n+            params: dict[str, Any] = {}\n+            if map_index is not None:\n+                params[\"map_index\"] = map_index\n+            self.response = self.client.get(\n+                f\"dags/{dag_id}/dagRuns/{dag_run_id}/taskInstances/{task_id}/xcomEntries/{key}\",\n+                params=params,\n+            )\n+            return XComResponseNative.model_validate_json(self.response.content)\n+        except ServerResponseError as e:\n+            raise e\n+\n+    def list(\n+        self,\n+        dag_id: str,\n+        dag_run_id: str,\n+        task_id: str,\n+        map_index: int = None,  # type: ignore\n+        key: str = None,  # type: ignore\n+    ) -> XComCollectionResponse | ServerResponseError:\n+        \"\"\"List XCom entries.\"\"\"\n+        params: dict[str, Any] = {}\n+        if map_index is not None:\n+            params[\"map_index\"] = map_index\n+        if key is not None:\n+            params[\"xcom_key\"] = key\n+        return super().execute_list(\n+            path=f\"dags/{dag_id}/dagRuns/{dag_run_id}/taskInstances/{task_id}/xcomEntries\",\n+            data_model=XComCollectionResponse,\n+            params=params,\n+        )\n+\n+    def add(\n+        self,\n+        dag_id: str,\n+        dag_run_id: str,\n+        task_id: str,\n+        key: str,\n+        value: str,\n+        map_index: int = None,  # type: ignore\n+    ) -> XComResponseNative | ServerResponseError:\n+        \"\"\"Add an XCom entry.\"\"\"\n+        try:\n+            parsed_value = json.loads(value)\n+        except (ValueError, TypeError):\n+            parsed_value = value\n+\n+        body_dict: dict[str, Any] = {\"key\": key, \"value\": parsed_value}\n+        if map_index is not None:\n+            body_dict[\"map_index\"] = map_index\n+        body = XComCreateBody(**body_dict)\n+        try:\n+            self.response = self.client.post(\n+                f\"dags/{dag_id}/dagRuns/{dag_run_id}/taskInstances/{task_id}/xcomEntries\",\n+                json=body.model_dump(mode=\"json\", exclude_unset=True),\n+            )\n+            return XComResponseNative.model_validate_json(self.response.content)\n+        except ServerResponseError as e:\n+            raise e\n+\n+    def edit(\n+        self,\n+        dag_id: str,\n+        dag_run_id: str,\n+        task_id: str,\n+        key: str,\n+        value: str,\n+        map_index: int = None,  # type: ignore\n+    ) -> XComResponseNative | ServerResponseError:\n+        \"\"\"Edit an XCom entry.\"\"\"\n+        try:\n+            parsed_value = json.loads(value)\n+        except (ValueError, TypeError):\n+            parsed_value = value\n+\n+        body_dict: dict[str, Any] = {\"value\": parsed_value}\n+        if map_index is not None:\n+            body_dict[\"map_index\"] = map_index\n+        body = XComUpdateBody(**body_dict)\n+        try:\n+            self.response = self.client.patch(\n+                f\"dags/{dag_id}/dagRuns/{dag_run_id}/taskInstances/{task_id}/xcomEntries/{key}\",\n+                json=body.model_dump(mode=\"json\", exclude_unset=True),\n+            )\n+            return XComResponseNative.model_validate_json(self.response.content)\n+        except ServerResponseError as e:\n+            raise e\n+\n+    def delete(\n+        self,\n+        dag_id: str,\n+        dag_run_id: str,\n+        task_id: str,\n+        key: str,\n+        map_index: int = None,  # type: ignore\n+    ) -> str | ServerResponseError:\n+        \"\"\"Delete an XCom entry.\"\"\"\n+        try:\n+            params: dict[str, Any] = {}\n+            if map_index is not None:\n+                params[\"map_index\"] = map_index\n+            self.client.delete(\n+                f\"dags/{dag_id}/dagRuns/{dag_run_id}/taskInstances/{task_id}/xcomEntries/{key}\",\n+                params=params,\n+            )\n+            return key\n+        except ServerResponseError as e:\n+            raise e",
      "comment": "What's the use case for these? I could understand why we need read / list but just trying to understand what the use case is for manipulating xcoms outside task execution context",
      "comment_id": 2730378812,
      "user": "amoghrajesh",
      "created_at": "2026-01-27T05:53:34Z",
      "url": "https://github.com/apache/airflow/pull/61021#discussion_r2730378812"
    },
    {
      "repo": "apache/airflow",
      "pr_number": 61021,
      "file_path": "airflow-ctl/src/airflowctl/api/operations.py",
      "line": 826,
      "side": "RIGHT",
      "diff_hunk": "@@ -697,3 +702,125 @@ def get(self) -> VersionInfo | ServerResponseError:\n             return VersionInfo.model_validate_json(self.response.content)\n         except ServerResponseError as e:\n             raise e\n+\n+\n+class XComOperations(BaseOperations):\n+    \"\"\"XCom operations.\"\"\"\n+\n+    def get(\n+        self,\n+        dag_id: str,\n+        dag_run_id: str,\n+        task_id: str,\n+        key: str,\n+        map_index: int = None,  # type: ignore\n+    ) -> XComResponseNative | ServerResponseError:\n+        \"\"\"Get an XCom entry.\"\"\"\n+        try:\n+            params: dict[str, Any] = {}\n+            if map_index is not None:\n+                params[\"map_index\"] = map_index\n+            self.response = self.client.get(\n+                f\"dags/{dag_id}/dagRuns/{dag_run_id}/taskInstances/{task_id}/xcomEntries/{key}\",\n+                params=params,\n+            )\n+            return XComResponseNative.model_validate_json(self.response.content)\n+        except ServerResponseError as e:\n+            raise e\n+\n+    def list(\n+        self,\n+        dag_id: str,\n+        dag_run_id: str,\n+        task_id: str,\n+        map_index: int = None,  # type: ignore\n+        key: str = None,  # type: ignore\n+    ) -> XComCollectionResponse | ServerResponseError:\n+        \"\"\"List XCom entries.\"\"\"\n+        params: dict[str, Any] = {}\n+        if map_index is not None:\n+            params[\"map_index\"] = map_index\n+        if key is not None:\n+            params[\"xcom_key\"] = key\n+        return super().execute_list(\n+            path=f\"dags/{dag_id}/dagRuns/{dag_run_id}/taskInstances/{task_id}/xcomEntries\",\n+            data_model=XComCollectionResponse,\n+            params=params,\n+        )\n+\n+    def add(\n+        self,\n+        dag_id: str,\n+        dag_run_id: str,\n+        task_id: str,\n+        key: str,\n+        value: str,\n+        map_index: int = None,  # type: ignore\n+    ) -> XComResponseNative | ServerResponseError:\n+        \"\"\"Add an XCom entry.\"\"\"\n+        try:\n+            parsed_value = json.loads(value)\n+        except (ValueError, TypeError):\n+            parsed_value = value\n+\n+        body_dict: dict[str, Any] = {\"key\": key, \"value\": parsed_value}\n+        if map_index is not None:\n+            body_dict[\"map_index\"] = map_index\n+        body = XComCreateBody(**body_dict)\n+        try:\n+            self.response = self.client.post(\n+                f\"dags/{dag_id}/dagRuns/{dag_run_id}/taskInstances/{task_id}/xcomEntries\",\n+                json=body.model_dump(mode=\"json\", exclude_unset=True),\n+            )\n+            return XComResponseNative.model_validate_json(self.response.content)\n+        except ServerResponseError as e:\n+            raise e\n+\n+    def edit(\n+        self,\n+        dag_id: str,\n+        dag_run_id: str,\n+        task_id: str,\n+        key: str,\n+        value: str,\n+        map_index: int = None,  # type: ignore\n+    ) -> XComResponseNative | ServerResponseError:\n+        \"\"\"Edit an XCom entry.\"\"\"\n+        try:\n+            parsed_value = json.loads(value)\n+        except (ValueError, TypeError):\n+            parsed_value = value\n+\n+        body_dict: dict[str, Any] = {\"value\": parsed_value}\n+        if map_index is not None:\n+            body_dict[\"map_index\"] = map_index\n+        body = XComUpdateBody(**body_dict)\n+        try:\n+            self.response = self.client.patch(\n+                f\"dags/{dag_id}/dagRuns/{dag_run_id}/taskInstances/{task_id}/xcomEntries/{key}\",\n+                json=body.model_dump(mode=\"json\", exclude_unset=True),\n+            )\n+            return XComResponseNative.model_validate_json(self.response.content)\n+        except ServerResponseError as e:\n+            raise e\n+\n+    def delete(\n+        self,\n+        dag_id: str,\n+        dag_run_id: str,\n+        task_id: str,\n+        key: str,\n+        map_index: int = None,  # type: ignore\n+    ) -> str | ServerResponseError:\n+        \"\"\"Delete an XCom entry.\"\"\"\n+        try:\n+            params: dict[str, Any] = {}\n+            if map_index is not None:\n+                params[\"map_index\"] = map_index\n+            self.client.delete(\n+                f\"dags/{dag_id}/dagRuns/{dag_run_id}/taskInstances/{task_id}/xcomEntries/{key}\",\n+                params=params,\n+            )\n+            return key\n+        except ServerResponseError as e:\n+            raise e",
      "comment": "There are many scenarios. For example you can mark a task as \"Success\" and want to run downstream pipeline, however downstream tasks may depend on an xcom that parent task would have provided if it passed. ",
      "comment_id": 2733200722,
      "user": "dheerajturaga",
      "created_at": "2026-01-27T17:57:25Z",
      "url": "https://github.com/apache/airflow/pull/61021#discussion_r2733200722"
    },
    {
      "repo": "apache/airflow",
      "pr_number": 61021,
      "file_path": "airflow-ctl/src/airflowctl/api/operations.py",
      "line": 826,
      "side": "RIGHT",
      "diff_hunk": "@@ -697,3 +702,125 @@ def get(self) -> VersionInfo | ServerResponseError:\n             return VersionInfo.model_validate_json(self.response.content)\n         except ServerResponseError as e:\n             raise e\n+\n+\n+class XComOperations(BaseOperations):\n+    \"\"\"XCom operations.\"\"\"\n+\n+    def get(\n+        self,\n+        dag_id: str,\n+        dag_run_id: str,\n+        task_id: str,\n+        key: str,\n+        map_index: int = None,  # type: ignore\n+    ) -> XComResponseNative | ServerResponseError:\n+        \"\"\"Get an XCom entry.\"\"\"\n+        try:\n+            params: dict[str, Any] = {}\n+            if map_index is not None:\n+                params[\"map_index\"] = map_index\n+            self.response = self.client.get(\n+                f\"dags/{dag_id}/dagRuns/{dag_run_id}/taskInstances/{task_id}/xcomEntries/{key}\",\n+                params=params,\n+            )\n+            return XComResponseNative.model_validate_json(self.response.content)\n+        except ServerResponseError as e:\n+            raise e\n+\n+    def list(\n+        self,\n+        dag_id: str,\n+        dag_run_id: str,\n+        task_id: str,\n+        map_index: int = None,  # type: ignore\n+        key: str = None,  # type: ignore\n+    ) -> XComCollectionResponse | ServerResponseError:\n+        \"\"\"List XCom entries.\"\"\"\n+        params: dict[str, Any] = {}\n+        if map_index is not None:\n+            params[\"map_index\"] = map_index\n+        if key is not None:\n+            params[\"xcom_key\"] = key\n+        return super().execute_list(\n+            path=f\"dags/{dag_id}/dagRuns/{dag_run_id}/taskInstances/{task_id}/xcomEntries\",\n+            data_model=XComCollectionResponse,\n+            params=params,\n+        )\n+\n+    def add(\n+        self,\n+        dag_id: str,\n+        dag_run_id: str,\n+        task_id: str,\n+        key: str,\n+        value: str,\n+        map_index: int = None,  # type: ignore\n+    ) -> XComResponseNative | ServerResponseError:\n+        \"\"\"Add an XCom entry.\"\"\"\n+        try:\n+            parsed_value = json.loads(value)\n+        except (ValueError, TypeError):\n+            parsed_value = value\n+\n+        body_dict: dict[str, Any] = {\"key\": key, \"value\": parsed_value}\n+        if map_index is not None:\n+            body_dict[\"map_index\"] = map_index\n+        body = XComCreateBody(**body_dict)\n+        try:\n+            self.response = self.client.post(\n+                f\"dags/{dag_id}/dagRuns/{dag_run_id}/taskInstances/{task_id}/xcomEntries\",\n+                json=body.model_dump(mode=\"json\", exclude_unset=True),\n+            )\n+            return XComResponseNative.model_validate_json(self.response.content)\n+        except ServerResponseError as e:\n+            raise e\n+\n+    def edit(\n+        self,\n+        dag_id: str,\n+        dag_run_id: str,\n+        task_id: str,\n+        key: str,\n+        value: str,\n+        map_index: int = None,  # type: ignore\n+    ) -> XComResponseNative | ServerResponseError:\n+        \"\"\"Edit an XCom entry.\"\"\"\n+        try:\n+            parsed_value = json.loads(value)\n+        except (ValueError, TypeError):\n+            parsed_value = value\n+\n+        body_dict: dict[str, Any] = {\"value\": parsed_value}\n+        if map_index is not None:\n+            body_dict[\"map_index\"] = map_index\n+        body = XComUpdateBody(**body_dict)\n+        try:\n+            self.response = self.client.patch(\n+                f\"dags/{dag_id}/dagRuns/{dag_run_id}/taskInstances/{task_id}/xcomEntries/{key}\",\n+                json=body.model_dump(mode=\"json\", exclude_unset=True),\n+            )\n+            return XComResponseNative.model_validate_json(self.response.content)\n+        except ServerResponseError as e:\n+            raise e\n+\n+    def delete(\n+        self,\n+        dag_id: str,\n+        dag_run_id: str,\n+        task_id: str,\n+        key: str,\n+        map_index: int = None,  # type: ignore\n+    ) -> str | ServerResponseError:\n+        \"\"\"Delete an XCom entry.\"\"\"\n+        try:\n+            params: dict[str, Any] = {}\n+            if map_index is not None:\n+                params[\"map_index\"] = map_index\n+            self.client.delete(\n+                f\"dags/{dag_id}/dagRuns/{dag_run_id}/taskInstances/{task_id}/xcomEntries/{key}\",\n+                params=params,\n+            )\n+            return key\n+        except ServerResponseError as e:\n+            raise e",
      "comment": "Anything we can do from the Public API context should be doable on ctl too. One day ctl could replace the Airflow Python Client package :pray:, too, which would be my main reason to have all possible API endpoints we can provide :) \r\nI understand your concern Amogh. Thanks for raising it! Do you think we shouldn't have it on the Public API and make it special for the Execution API/TaskSDK side only :thinking: ",
      "comment_id": 2743206057,
      "user": "bugraoz93",
      "created_at": "2026-01-29T19:38:36Z",
      "url": "https://github.com/apache/airflow/pull/61021#discussion_r2743206057"
    },
    {
      "repo": "apache/airflow",
      "pr_number": 61021,
      "file_path": "airflow-ctl/src/airflowctl/api/operations.py",
      "line": 826,
      "side": "RIGHT",
      "diff_hunk": "@@ -697,3 +702,125 @@ def get(self) -> VersionInfo | ServerResponseError:\n             return VersionInfo.model_validate_json(self.response.content)\n         except ServerResponseError as e:\n             raise e\n+\n+\n+class XComOperations(BaseOperations):\n+    \"\"\"XCom operations.\"\"\"\n+\n+    def get(\n+        self,\n+        dag_id: str,\n+        dag_run_id: str,\n+        task_id: str,\n+        key: str,\n+        map_index: int = None,  # type: ignore\n+    ) -> XComResponseNative | ServerResponseError:\n+        \"\"\"Get an XCom entry.\"\"\"\n+        try:\n+            params: dict[str, Any] = {}\n+            if map_index is not None:\n+                params[\"map_index\"] = map_index\n+            self.response = self.client.get(\n+                f\"dags/{dag_id}/dagRuns/{dag_run_id}/taskInstances/{task_id}/xcomEntries/{key}\",\n+                params=params,\n+            )\n+            return XComResponseNative.model_validate_json(self.response.content)\n+        except ServerResponseError as e:\n+            raise e\n+\n+    def list(\n+        self,\n+        dag_id: str,\n+        dag_run_id: str,\n+        task_id: str,\n+        map_index: int = None,  # type: ignore\n+        key: str = None,  # type: ignore\n+    ) -> XComCollectionResponse | ServerResponseError:\n+        \"\"\"List XCom entries.\"\"\"\n+        params: dict[str, Any] = {}\n+        if map_index is not None:\n+            params[\"map_index\"] = map_index\n+        if key is not None:\n+            params[\"xcom_key\"] = key\n+        return super().execute_list(\n+            path=f\"dags/{dag_id}/dagRuns/{dag_run_id}/taskInstances/{task_id}/xcomEntries\",\n+            data_model=XComCollectionResponse,\n+            params=params,\n+        )\n+\n+    def add(\n+        self,\n+        dag_id: str,\n+        dag_run_id: str,\n+        task_id: str,\n+        key: str,\n+        value: str,\n+        map_index: int = None,  # type: ignore\n+    ) -> XComResponseNative | ServerResponseError:\n+        \"\"\"Add an XCom entry.\"\"\"\n+        try:\n+            parsed_value = json.loads(value)\n+        except (ValueError, TypeError):\n+            parsed_value = value\n+\n+        body_dict: dict[str, Any] = {\"key\": key, \"value\": parsed_value}\n+        if map_index is not None:\n+            body_dict[\"map_index\"] = map_index\n+        body = XComCreateBody(**body_dict)\n+        try:\n+            self.response = self.client.post(\n+                f\"dags/{dag_id}/dagRuns/{dag_run_id}/taskInstances/{task_id}/xcomEntries\",\n+                json=body.model_dump(mode=\"json\", exclude_unset=True),\n+            )\n+            return XComResponseNative.model_validate_json(self.response.content)\n+        except ServerResponseError as e:\n+            raise e\n+\n+    def edit(\n+        self,\n+        dag_id: str,\n+        dag_run_id: str,\n+        task_id: str,\n+        key: str,\n+        value: str,\n+        map_index: int = None,  # type: ignore\n+    ) -> XComResponseNative | ServerResponseError:\n+        \"\"\"Edit an XCom entry.\"\"\"\n+        try:\n+            parsed_value = json.loads(value)\n+        except (ValueError, TypeError):\n+            parsed_value = value\n+\n+        body_dict: dict[str, Any] = {\"value\": parsed_value}\n+        if map_index is not None:\n+            body_dict[\"map_index\"] = map_index\n+        body = XComUpdateBody(**body_dict)\n+        try:\n+            self.response = self.client.patch(\n+                f\"dags/{dag_id}/dagRuns/{dag_run_id}/taskInstances/{task_id}/xcomEntries/{key}\",\n+                json=body.model_dump(mode=\"json\", exclude_unset=True),\n+            )\n+            return XComResponseNative.model_validate_json(self.response.content)\n+        except ServerResponseError as e:\n+            raise e\n+\n+    def delete(\n+        self,\n+        dag_id: str,\n+        dag_run_id: str,\n+        task_id: str,\n+        key: str,\n+        map_index: int = None,  # type: ignore\n+    ) -> str | ServerResponseError:\n+        \"\"\"Delete an XCom entry.\"\"\"\n+        try:\n+            params: dict[str, Any] = {}\n+            if map_index is not None:\n+                params[\"map_index\"] = map_index\n+            self.client.delete(\n+                f\"dags/{dag_id}/dagRuns/{dag_run_id}/taskInstances/{task_id}/xcomEntries/{key}\",\n+                params=params,\n+            )\n+            return key\n+        except ServerResponseError as e:\n+            raise e",
      "comment": "These operations exist on the UI side already and are POR for 3.2 . So this enhancement is in alignment with the UI. \r\nI would like to merge this and have a discussion on it in the sidelines. IMO these are very useful in some workflows (especially for me :-) )\r\n\r\n<img width=\"2608\" height=\"1056\" alt=\"image\" src=\"https://github.com/user-attachments/assets/a723a74b-79b7-44a6-9d86-57d4b62400bf\" />\r\n",
      "comment_id": 2743258521,
      "user": "dheerajturaga",
      "created_at": "2026-01-29T19:52:08Z",
      "url": "https://github.com/apache/airflow/pull/61021#discussion_r2743258521"
    },
    {
      "repo": "apache/airflow",
      "pr_number": 61021,
      "file_path": "airflow-ctl/src/airflowctl/api/operations.py",
      "line": 826,
      "side": "RIGHT",
      "diff_hunk": "@@ -697,3 +702,125 @@ def get(self) -> VersionInfo | ServerResponseError:\n             return VersionInfo.model_validate_json(self.response.content)\n         except ServerResponseError as e:\n             raise e\n+\n+\n+class XComOperations(BaseOperations):\n+    \"\"\"XCom operations.\"\"\"\n+\n+    def get(\n+        self,\n+        dag_id: str,\n+        dag_run_id: str,\n+        task_id: str,\n+        key: str,\n+        map_index: int = None,  # type: ignore\n+    ) -> XComResponseNative | ServerResponseError:\n+        \"\"\"Get an XCom entry.\"\"\"\n+        try:\n+            params: dict[str, Any] = {}\n+            if map_index is not None:\n+                params[\"map_index\"] = map_index\n+            self.response = self.client.get(\n+                f\"dags/{dag_id}/dagRuns/{dag_run_id}/taskInstances/{task_id}/xcomEntries/{key}\",\n+                params=params,\n+            )\n+            return XComResponseNative.model_validate_json(self.response.content)\n+        except ServerResponseError as e:\n+            raise e\n+\n+    def list(\n+        self,\n+        dag_id: str,\n+        dag_run_id: str,\n+        task_id: str,\n+        map_index: int = None,  # type: ignore\n+        key: str = None,  # type: ignore\n+    ) -> XComCollectionResponse | ServerResponseError:\n+        \"\"\"List XCom entries.\"\"\"\n+        params: dict[str, Any] = {}\n+        if map_index is not None:\n+            params[\"map_index\"] = map_index\n+        if key is not None:\n+            params[\"xcom_key\"] = key\n+        return super().execute_list(\n+            path=f\"dags/{dag_id}/dagRuns/{dag_run_id}/taskInstances/{task_id}/xcomEntries\",\n+            data_model=XComCollectionResponse,\n+            params=params,\n+        )\n+\n+    def add(\n+        self,\n+        dag_id: str,\n+        dag_run_id: str,\n+        task_id: str,\n+        key: str,\n+        value: str,\n+        map_index: int = None,  # type: ignore\n+    ) -> XComResponseNative | ServerResponseError:\n+        \"\"\"Add an XCom entry.\"\"\"\n+        try:\n+            parsed_value = json.loads(value)\n+        except (ValueError, TypeError):\n+            parsed_value = value\n+\n+        body_dict: dict[str, Any] = {\"key\": key, \"value\": parsed_value}\n+        if map_index is not None:\n+            body_dict[\"map_index\"] = map_index\n+        body = XComCreateBody(**body_dict)\n+        try:\n+            self.response = self.client.post(\n+                f\"dags/{dag_id}/dagRuns/{dag_run_id}/taskInstances/{task_id}/xcomEntries\",\n+                json=body.model_dump(mode=\"json\", exclude_unset=True),\n+            )\n+            return XComResponseNative.model_validate_json(self.response.content)\n+        except ServerResponseError as e:\n+            raise e\n+\n+    def edit(\n+        self,\n+        dag_id: str,\n+        dag_run_id: str,\n+        task_id: str,\n+        key: str,\n+        value: str,\n+        map_index: int = None,  # type: ignore\n+    ) -> XComResponseNative | ServerResponseError:\n+        \"\"\"Edit an XCom entry.\"\"\"\n+        try:\n+            parsed_value = json.loads(value)\n+        except (ValueError, TypeError):\n+            parsed_value = value\n+\n+        body_dict: dict[str, Any] = {\"value\": parsed_value}\n+        if map_index is not None:\n+            body_dict[\"map_index\"] = map_index\n+        body = XComUpdateBody(**body_dict)\n+        try:\n+            self.response = self.client.patch(\n+                f\"dags/{dag_id}/dagRuns/{dag_run_id}/taskInstances/{task_id}/xcomEntries/{key}\",\n+                json=body.model_dump(mode=\"json\", exclude_unset=True),\n+            )\n+            return XComResponseNative.model_validate_json(self.response.content)\n+        except ServerResponseError as e:\n+            raise e\n+\n+    def delete(\n+        self,\n+        dag_id: str,\n+        dag_run_id: str,\n+        task_id: str,\n+        key: str,\n+        map_index: int = None,  # type: ignore\n+    ) -> str | ServerResponseError:\n+        \"\"\"Delete an XCom entry.\"\"\"\n+        try:\n+            params: dict[str, Any] = {}\n+            if map_index is not None:\n+                params[\"map_index\"] = map_index\n+            self.client.delete(\n+                f\"dags/{dag_id}/dagRuns/{dag_run_id}/taskInstances/{task_id}/xcomEntries/{key}\",\n+                params=params,\n+            )\n+            return key\n+        except ServerResponseError as e:\n+            raise e",
      "comment": "@amoghrajesh , The Python Client also provides mechanism to modify xcom outside the Task Execution context as advertised in https://github.com/apache/airflow-client-python/blob/main/docs/XComApi.md#create_xcom_entry",
      "comment_id": 2743272605,
      "user": "dheerajturaga",
      "created_at": "2026-01-29T19:55:12Z",
      "url": "https://github.com/apache/airflow/pull/61021#discussion_r2743272605"
    },
    {
      "repo": "apache/airflow",
      "pr_number": 55712,
      "file_path": "airflow-core/src/airflow/settings.py",
      "line": 647,
      "side": "RIGHT",
      "diff_hunk": "@@ -633,6 +633,21 @@ def prepare_syspath_for_config_and_plugins():\n         sys.path.append(PLUGINS_FOLDER)\n \n \n+def __getattr__(name: str):\n+    \"\"\"Handle deprecated module attributes.\"\"\"\n+    if name == \"MASK_SECRETS_IN_LOGS\":\n+        import warnings\n+\n+        warnings.warn(\n+            \"settings.MASK_SECRETS_IN_LOGS has been removed. \"\n+            \"Use SecretsMasker.enable_log_masking(), disable_log_masking(), or is_log_masking_enabled() instead.\",\n+            DeprecationWarning,\n+            stacklevel=2,\n+        )\n+        return",
      "comment": "Returning None is intentional here? Won't that like cause equally weird things? Or make things think secrets masking is disabled?",
      "comment_id": 2351571742,
      "user": "ashb",
      "created_at": "2025-09-16T08:59:19Z",
      "url": "https://github.com/apache/airflow/pull/55712#discussion_r2351571742"
    },
    {
      "repo": "apache/airflow",
      "pr_number": 55712,
      "file_path": "airflow-core/src/airflow/settings.py",
      "line": 647,
      "side": "RIGHT",
      "diff_hunk": "@@ -633,6 +633,21 @@ def prepare_syspath_for_config_and_plugins():\n         sys.path.append(PLUGINS_FOLDER)\n \n \n+def __getattr__(name: str):\n+    \"\"\"Handle deprecated module attributes.\"\"\"\n+    if name == \"MASK_SECRETS_IN_LOGS\":\n+        import warnings\n+\n+        warnings.warn(\n+            \"settings.MASK_SECRETS_IN_LOGS has been removed. \"\n+            \"Use SecretsMasker.enable_log_masking(), disable_log_masking(), or is_log_masking_enabled() instead.\",\n+            DeprecationWarning,\n+            stacklevel=2,\n+        )\n+        return",
      "comment": "Oh my bad, wanted to commit with `return False` instead.",
      "comment_id": 2351586422,
      "user": "amoghrajesh",
      "created_at": "2025-09-16T09:03:29Z",
      "url": "https://github.com/apache/airflow/pull/55712#discussion_r2351586422"
    },
    {
      "repo": "apache/airflow",
      "pr_number": 55712,
      "file_path": "airflow-core/src/airflow/settings.py",
      "line": 647,
      "side": "RIGHT",
      "diff_hunk": "@@ -633,6 +633,21 @@ def prepare_syspath_for_config_and_plugins():\n         sys.path.append(PLUGINS_FOLDER)\n \n \n+def __getattr__(name: str):\n+    \"\"\"Handle deprecated module attributes.\"\"\"\n+    if name == \"MASK_SECRETS_IN_LOGS\":\n+        import warnings\n+\n+        warnings.warn(\n+            \"settings.MASK_SECRETS_IN_LOGS has been removed. \"\n+            \"Use SecretsMasker.enable_log_masking(), disable_log_masking(), or is_log_masking_enabled() instead.\",\n+            DeprecationWarning,\n+            stacklevel=2,\n+        )\n+        return",
      "comment": "Was heading in this direction: \r\n```\r\nPython 3.10.18 (main, Sep  8 2025, 22:04:00) [GCC 12.2.0] on linux\r\nType \"help\", \"copyright\", \"credits\" or \"license\" for more information.\r\n>>> import airflow.settings\r\n>>> airflow.settings.MASK_SECRETS_IN_LOGS\r\n<stdin>:1 DeprecationWarning: settings.MASK_SECRETS_IN_LOGS has been removed. This shim returns default value of False. Use SecretsMasker.enable_log_masking(), disable_log_masking(), or is_log_masking_enabled() instead.\r\nFalse\r\n```\r\n\r\nI'm not sure if thats the best way ahead :/",
      "comment_id": 2351592977,
      "user": "amoghrajesh",
      "created_at": "2025-09-16T09:05:21Z",
      "url": "https://github.com/apache/airflow/pull/55712#discussion_r2351592977"
    },
    {
      "repo": "apache/airflow",
      "pr_number": 55712,
      "file_path": "airflow-core/src/airflow/settings.py",
      "line": 647,
      "side": "RIGHT",
      "diff_hunk": "@@ -633,6 +633,21 @@ def prepare_syspath_for_config_and_plugins():\n         sys.path.append(PLUGINS_FOLDER)\n \n \n+def __getattr__(name: str):\n+    \"\"\"Handle deprecated module attributes.\"\"\"\n+    if name == \"MASK_SECRETS_IN_LOGS\":\n+        import warnings\n+\n+        warnings.warn(\n+            \"settings.MASK_SECRETS_IN_LOGS has been removed. \"\n+            \"Use SecretsMasker.enable_log_masking(), disable_log_masking(), or is_log_masking_enabled() instead.\",\n+            DeprecationWarning,\n+            stacklevel=2,\n+        )\n+        return",
      "comment": "Pushed in https://github.com/apache/airflow/pull/55712/commits/821b6e9b594bec85001d035f1dd25c5a01ffbb60",
      "comment_id": 2351609089,
      "user": "amoghrajesh",
      "created_at": "2025-09-16T09:10:16Z",
      "url": "https://github.com/apache/airflow/pull/55712#discussion_r2351609089"
    },
    {
      "repo": "apache/airflow",
      "pr_number": 60734,
      "file_path": "airflow-core/src/airflow/dag_processing/processor.py",
      "line": 294,
      "side": "RIGHT",
      "diff_hunk": "@@ -287,12 +288,16 @@ def _execute_callbacks(\n ) -> None:\n     for request in callback_requests:\n         log.debug(\"Processing Callback Request\", request=request.to_json())\n-        if isinstance(request, TaskCallbackRequest):\n-            _execute_task_callbacks(dagbag, request, log)\n-        elif isinstance(request, DagCallbackRequest):\n-            _execute_dag_callbacks(dagbag, request, log)\n-        elif isinstance(request, EmailRequest):\n-            _execute_email_callbacks(dagbag, request, log)\n+        with BundleVersionLock(\n+            bundle_name=request.bundle_name,\n+            bundle_version=request.bundle_version,\n+        ):",
      "comment": "The `BundleVersionLock` context manager is applied to all callback requests, but the lock is only necessary for versioned bundles. For non-versioned bundles, `request.bundle_version` may be None, and acquiring this lock unnecessarily could impact performance. Consider conditionally applying the lock only when `request.bundle_version` is not None.\n```suggestion\n        if request.bundle_version is not None:\n            with BundleVersionLock(\n                bundle_name=request.bundle_name,\n                bundle_version=request.bundle_version,\n            ):\n                if isinstance(request, TaskCallbackRequest):\n                    _execute_task_callbacks(dagbag, request, log)\n                elif isinstance(request, DagCallbackRequest):\n                    _execute_dag_callbacks(dagbag, request, log)\n                elif isinstance(request, EmailRequest):\n                    _execute_email_callbacks(dagbag, request, log)\n        else:\n```",
      "comment_id": 2739600702,
      "user": "Copilot",
      "created_at": "2026-01-29T02:57:11Z",
      "url": "https://github.com/apache/airflow/pull/60734#discussion_r2739600702"
    },
    {
      "repo": "apache/airflow",
      "pr_number": 60734,
      "file_path": "airflow-core/tests/unit/dag_processing/test_manager.py",
      "line": 597,
      "side": "RIGHT",
      "diff_hunk": "@@ -593,6 +593,20 @@ def test_scan_stale_dags(self, session):\n         # SerializedDagModel gives history about Dags\n         assert serialized_dag_count == 1\n \n+    @mock.patch(\"airflow.dag_processing.manager.BundleUsageTrackingManager\")\n+    def test_cleanup_stale_bundle_versions_interval(self, mock_bundle_manager):",
      "comment": "The test verifies that `remove_stale_bundle_versions` is called based on the cleanup interval, but it doesn't verify what happens when `stale_bundle_cleanup_interval` is set to 0 or a negative value. According to the implementation in `_cleanup_stale_bundle_versions`, the method should return early without calling `remove_stale_bundle_versions` in such cases. Add a test case to cover this behavior.",
      "comment_id": 2739600724,
      "user": "Copilot",
      "created_at": "2026-01-29T02:57:12Z",
      "url": "https://github.com/apache/airflow/pull/60734#discussion_r2739600724"
    },
    {
      "repo": "apache/airflow",
      "pr_number": 60734,
      "file_path": "airflow-core/tests/unit/dag_processing/test_manager.py",
      "line": 1156,
      "side": "RIGHT",
      "diff_hunk": "@@ -1138,6 +1152,28 @@ def test_callback_queue(self, mock_get_logger, configure_testing_dag_bundle):\n             assert dag1_path not in manager._callback_to_execute\n             assert dag2_path not in manager._callback_to_execute\n \n+    @mock.patch(\"airflow.dag_processing.manager.DagBundlesManager\")\n+    def test_add_callback_initializes_versioned_bundle(self, mock_bundle_manager):",
      "comment": "This test verifies that `bundle.initialize()` is called for versioned bundles, but it doesn't cover the exception handling path where initialization fails. The implementation logs the exception and skips the callback. Add a test case where `bundle.initialize()` raises an exception to verify that the error is logged and the callback is not queued.",
      "comment_id": 2739600737,
      "user": "Copilot",
      "created_at": "2026-01-29T02:57:12Z",
      "url": "https://github.com/apache/airflow/pull/60734#discussion_r2739600737"
    },
    {
      "repo": "apache/airflow",
      "pr_number": 60734,
      "file_path": "airflow-core/tests/unit/dag_processing/test_manager.py",
      "line": 597,
      "side": "RIGHT",
      "diff_hunk": "@@ -593,6 +593,20 @@ def test_scan_stale_dags(self, session):\n         # SerializedDagModel gives history about Dags\n         assert serialized_dag_count == 1\n \n+    @mock.patch(\"airflow.dag_processing.manager.BundleUsageTrackingManager\")\n+    def test_cleanup_stale_bundle_versions_interval(self, mock_bundle_manager):",
      "comment": "I don't think its needed as we cover whats important, which is the cleanup of a stale bundle",
      "comment_id": 2740240371,
      "user": "amoghrajesh",
      "created_at": "2026-01-29T07:01:52Z",
      "url": "https://github.com/apache/airflow/pull/60734#discussion_r2740240371"
    },
    {
      "repo": "apache/airflow",
      "pr_number": 60734,
      "file_path": "airflow-core/tests/unit/dag_processing/test_processor.py",
      "line": 672,
      "side": "RIGHT",
      "diff_hunk": "@@ -666,6 +667,32 @@ def test_import_error_updates_timestamps(session):\n     assert stat.import_errors == 1\n \n \n+class TestExecuteCallbacks:\n+    def test_execute_callbacks_locks_bundle_version(self):\n+        request = DagCallbackRequest(",
      "comment": "```suggestion\n        callbacks = [DagCallbackRequest(\n```",
      "comment_id": 2740246164,
      "user": "amoghrajesh",
      "created_at": "2026-01-29T07:04:11Z",
      "url": "https://github.com/apache/airflow/pull/60734#discussion_r2740246164"
    },
    {
      "repo": "apache/airflow",
      "pr_number": 60734,
      "file_path": "airflow-core/tests/unit/dag_processing/test_processor.py",
      "line": 688,
      "side": "RIGHT",
      "diff_hunk": "@@ -666,6 +667,32 @@ def test_import_error_updates_timestamps(session):\n     assert stat.import_errors == 1\n \n \n+class TestExecuteCallbacks:\n+    def test_execute_callbacks_locks_bundle_version(self):\n+        request = DagCallbackRequest(\n+            filepath=\"test.py\",\n+            dag_id=\"test_dag\",\n+            run_id=\"test_run\",\n+            bundle_name=\"testing\",\n+            bundle_version=\"some_commit_hash\",\n+            is_failure_callback=False,\n+            msg=None,\n+        )\n+        log = structlog.get_logger()\n+        dagbag = MagicMock()\n+\n+        with (\n+            patch(\"airflow.dag_processing.processor.BundleVersionLock\") as mock_lock,\n+            patch(\"airflow.dag_processing.processor._execute_dag_callbacks\") as mock_execute,\n+        ):\n+            _execute_callbacks(dagbag, [request], log)",
      "comment": "```suggestion\n            _execute_callbacks(dagbag, callbacks, log)\n```",
      "comment_id": 2740247662,
      "user": "amoghrajesh",
      "created_at": "2026-01-29T07:04:47Z",
      "url": "https://github.com/apache/airflow/pull/60734#discussion_r2740247662"
    },
    {
      "repo": "apache/airflow",
      "pr_number": 60734,
      "file_path": "airflow-core/tests/unit/dag_processing/test_processor.py",
      "line": 688,
      "side": "RIGHT",
      "diff_hunk": "@@ -666,6 +667,32 @@ def test_import_error_updates_timestamps(session):\n     assert stat.import_errors == 1\n \n \n+class TestExecuteCallbacks:\n+    def test_execute_callbacks_locks_bundle_version(self):\n+        request = DagCallbackRequest(\n+            filepath=\"test.py\",\n+            dag_id=\"test_dag\",\n+            run_id=\"test_run\",\n+            bundle_name=\"testing\",\n+            bundle_version=\"some_commit_hash\",\n+            is_failure_callback=False,\n+            msg=None,\n+        )\n+        log = structlog.get_logger()\n+        dagbag = MagicMock()\n+\n+        with (\n+            patch(\"airflow.dag_processing.processor.BundleVersionLock\") as mock_lock,\n+            patch(\"airflow.dag_processing.processor._execute_dag_callbacks\") as mock_execute,\n+        ):\n+            _execute_callbacks(dagbag, [request], log)",
      "comment": "Thanks, I'll apply this change and update `mock_execute.assert_called_once_with(...)` accordingly (use `callbacks[0]` instead of `request`).",
      "comment_id": 2742748756,
      "user": "nailo2c",
      "created_at": "2026-01-29T17:28:54Z",
      "url": "https://github.com/apache/airflow/pull/60734#discussion_r2742748756"
    },
    {
      "repo": "apache/airflow",
      "pr_number": 60734,
      "file_path": "airflow-core/src/airflow/dag_processing/manager.py",
      "line": 317,
      "side": "RIGHT",
      "diff_hunk": "@@ -299,6 +304,20 @@ def _scan_stale_dags(self):\n             self.deactivate_stale_dags(last_parsed=last_parsed)\n             self._last_deactivate_stale_dags_time = time.monotonic()\n \n+    def _cleanup_stale_bundle_versions(self):\n+        if self.stale_bundle_cleanup_interval <= 0:\n+            return\n+        now = time.monotonic()\n+        elapsed_time_since_cleanup = now - self._last_stale_bundle_cleanup_time\n+        if elapsed_time_since_cleanup < self.stale_bundle_cleanup_interval:\n+            return\n+        try:\n+            BundleUsageTrackingManager().remove_stale_bundle_versions()\n+        except Exception:\n+            self.log.exception(\"Error removing stale bundle versions\")",
      "comment": "No worries, logging exception will also print out the exception message too :)\n\n```console\n>>> import logging\n>>> logger = logging.getLogger(\"demo\")\n>>> \n>>> try:\n...     1 / 0\n... except Exception:\n...     logger.exception(\"A) logger.exception(...) output\")\n... \nA) logger.exception(...) output\nTraceback (most recent call last):\n  File \"<stdin>\", line 2, in <module>\nZeroDivisionError: division by zero\n>>> \n>>> \n>>> try:\n...     1 / 0\n... except Exception:\n...     logger.error(\"B) logger.error(...) output\")\n... \nB) logger.error(...) output\n>>>\n```",
      "comment_id": 2742803405,
      "user": "nailo2c",
      "created_at": "2026-01-29T17:44:17Z",
      "url": "https://github.com/apache/airflow/pull/60734#discussion_r2742803405"
    },
    {
      "repo": "apache/airflow",
      "pr_number": 60734,
      "file_path": "airflow-core/tests/unit/dag_processing/test_manager.py",
      "line": 1156,
      "side": "RIGHT",
      "diff_hunk": "@@ -1138,6 +1152,28 @@ def test_callback_queue(self, mock_get_logger, configure_testing_dag_bundle):\n             assert dag1_path not in manager._callback_to_execute\n             assert dag2_path not in manager._callback_to_execute\n \n+    @mock.patch(\"airflow.dag_processing.manager.DagBundlesManager\")\n+    def test_add_callback_initializes_versioned_bundle(self, mock_bundle_manager):",
      "comment": "Nice catch! Added `test_add_callback_skips_when_bundle_init_fails` to cover the exception path",
      "comment_id": 2742945531,
      "user": "nailo2c",
      "created_at": "2026-01-29T18:21:32Z",
      "url": "https://github.com/apache/airflow/pull/60734#discussion_r2742945531"
    },
    {
      "repo": "apache/airflow",
      "pr_number": 61047,
      "file_path": "airflow-ctl/src/airflowctl/ctl/cli_config.py",
      "line": 626,
      "side": "RIGHT",
      "diff_hunk": "@@ -621,6 +621,16 @@ def _get_func(args: Namespace, api_operation: dict, api_client: Client = NEW_API\n \n             if datamodel:\n                 if datamodel_param_name:\n+                    # Special handling for TriggerDAGRunPostBody: default logical_date to now\n+                    # This matches the Airflow UI behavior where the form pre-fills with current time\n+                    if (",
      "comment": "Small nit, maybe would be great to move this into a method to have clear updates on which datamodels from a single place rather than this method, which already has a lot of cyclomatic complexity :) ",
      "comment_id": 2743181635,
      "user": "bugraoz93",
      "created_at": "2026-01-29T19:31:48Z",
      "url": "https://github.com/apache/airflow/pull/61047#discussion_r2743181635"
    },
    {
      "repo": "apache/airflow",
      "pr_number": 61047,
      "file_path": "airflow-ctl/src/airflowctl/ctl/cli_config.py",
      "line": 626,
      "side": "RIGHT",
      "diff_hunk": "@@ -621,6 +621,16 @@ def _get_func(args: Namespace, api_operation: dict, api_client: Client = NEW_API\n \n             if datamodel:\n                 if datamodel_param_name:\n+                    # Special handling for TriggerDAGRunPostBody: default logical_date to now\n+                    # This matches the Airflow UI behavior where the form pre-fills with current time\n+                    if (",
      "comment": "Sure! that's a good idea. I would like to address this in a follow up :) \r\nWill need to re-think and probably put some unit tests in aswell",
      "comment_id": 2744529891,
      "user": "dheerajturaga",
      "created_at": "2026-01-30T04:12:27Z",
      "url": "https://github.com/apache/airflow/pull/61047#discussion_r2744529891"
    },
    {
      "repo": "apache/airflow",
      "pr_number": 60519,
      "file_path": "task-sdk/src/airflow/sdk/io/path.py",
      "line": 202,
      "side": "RIGHT",
      "diff_hunk": "@@ -199,16 +199,12 @@ def replace(self, target) -> ObjectStoragePath:\n         return self.rename(target)\n \n     @classmethod\n-    def cwd(cls):\n-        if cls is ObjectStoragePath:\n-            return get_upath_class(\"\").cwd()\n-        raise NotImplementedError\n+    def cwd(cls) -> Self:  # type: ignore[override]",
      "comment": "Let's not add type ignore -- figure out how to fix those",
      "comment_id": 2690344793,
      "user": "kaxil",
      "created_at": "2026-01-14T13:02:25Z",
      "url": "https://github.com/apache/airflow/pull/60519#discussion_r2690344793"
    },
    {
      "repo": "apache/airflow",
      "pr_number": 61103,
      "file_path": "providers/microsoft/azure/src/airflow/providers/microsoft/azure/hooks/msgraph.py",
      "line": 163,
      "side": "RIGHT",
      "diff_hunk": "@@ -160,13 +160,26 @@ def __init__(\n         self.conn_id = conn_id\n         self.timeout = timeout\n         self.proxies = proxies\n-        self.host = host\n+        self.host = self._ensure_protocol(host) if host else None",
      "comment": "Since _ensure_protocol already checks for if not url, can we remove the if host else None check here to keep it DRY?",
      "comment_id": 2730308223,
      "user": "henry3260",
      "created_at": "2026-01-27T05:26:12Z",
      "url": "https://github.com/apache/airflow/pull/61103#discussion_r2730308223"
    },
    {
      "repo": "apache/airflow",
      "pr_number": 61103,
      "file_path": "providers/microsoft/azure/src/airflow/providers/microsoft/azure/hooks/msgraph.py",
      "line": 181,
      "side": "RIGHT",
      "diff_hunk": "@@ -160,13 +160,26 @@ def __init__(\n         self.conn_id = conn_id\n         self.timeout = timeout\n         self.proxies = proxies\n-        self.host = host\n+        self.host = self._ensure_protocol(host) if host else None\n         if isinstance(scopes, str):\n             self.scopes = [scopes]\n         else:\n             self.scopes = scopes or [self.DEFAULT_SCOPE]\n         self.api_version = self.resolve_api_version_from_value(api_version)\n \n+    def _ensure_protocol(self, url: str) -> str:\n+        if not url:\n+            return url\n+        if url.startswith((\"http://\", \"https://\")):\n+            return url\n+\n+        self.log.warning(\n+            \"URL '%s' is missing protocol prefix. Automatically adding 'https://'. \"\n+            \"Please update your connection configuration to include the full URL with protocol.\",\n+            url,\n+        )\n+        return f\"https://{url}\"",
      "comment": "Here I would add scheme like it was originally:\r\n\r\n```\r\nschema = connection.schema or \"https\"\r\nreturn f\"{schema}://{host}\"\r\n```",
      "comment_id": 2730519871,
      "user": "dabla",
      "created_at": "2026-01-27T06:52:10Z",
      "url": "https://github.com/apache/airflow/pull/61103#discussion_r2730519871"
    },
    {
      "repo": "apache/airflow",
      "pr_number": 61103,
      "file_path": "providers/microsoft/azure/src/airflow/providers/microsoft/azure/hooks/msgraph.py",
      "line": 163,
      "side": "RIGHT",
      "diff_hunk": "@@ -160,13 +160,26 @@ def __init__(\n         self.conn_id = conn_id\n         self.timeout = timeout\n         self.proxies = proxies\n-        self.host = host\n+        self.host = self._ensure_protocol(host) if host else None",
      "comment": "Good catch, indeed no need to check if host is None or not, just call the method as this is checked inside the method.",
      "comment_id": 2730526327,
      "user": "dabla",
      "created_at": "2026-01-27T06:54:22Z",
      "url": "https://github.com/apache/airflow/pull/61103#discussion_r2730526327"
    },
    {
      "repo": "apache/airflow",
      "pr_number": 61103,
      "file_path": "providers/microsoft/azure/src/airflow/providers/microsoft/azure/hooks/msgraph.py",
      "line": 249,
      "side": "RIGHT",
      "diff_hunk": "@@ -232,8 +245,11 @@ def get_host(self, connection: Connection) -> str:\n             if connection.schema and connection.host:\n                 return f\"{connection.schema}://{connection.host}\"\n             return NationalClouds.Global.value\n-        if not self.host.startswith(\"http://\") or not self.host.startswith(\"https://\"):\n-            return f\"{connection.schema}://{self.host}\"\n+\n+        if not self.host.startswith((\"http://\", \"https://\")):",
      "comment": "Why not call _ensure_protocol method here also to keep it DRY?",
      "comment_id": 2730528512,
      "user": "dabla",
      "created_at": "2026-01-27T06:55:14Z",
      "url": "https://github.com/apache/airflow/pull/61103#discussion_r2730528512"
    },
    {
      "repo": "apache/airflow",
      "pr_number": 61103,
      "file_path": "providers/microsoft/azure/src/airflow/providers/microsoft/azure/hooks/msgraph.py",
      "line": 170,
      "side": "RIGHT",
      "diff_hunk": "@@ -160,13 +160,29 @@ def __init__(\n         self.conn_id = conn_id\n         self.timeout = timeout\n         self.proxies = proxies\n-        self.host = host\n+        self.host = self._ensure_protocol(host)\n         if isinstance(scopes, str):\n             self.scopes = [scopes]\n         else:\n             self.scopes = scopes or [self.DEFAULT_SCOPE]\n         self.api_version = self.resolve_api_version_from_value(api_version)\n \n+    def _ensure_protocol(self, host: str, schema: str = \"https\") -> str:",
      "comment": "```suggestion\n    def _ensure_protocol(self, host: str, schema: str = \"https\") -> str | None:\n```",
      "comment_id": 2730671261,
      "user": "henry3260",
      "created_at": "2026-01-27T07:43:42Z",
      "url": "https://github.com/apache/airflow/pull/61103#discussion_r2730671261"
    },
    {
      "repo": "apache/airflow",
      "pr_number": 61103,
      "file_path": "providers/microsoft/azure/src/airflow/providers/microsoft/azure/hooks/msgraph.py",
      "line": 249,
      "side": "RIGHT",
      "diff_hunk": "@@ -232,8 +245,11 @@ def get_host(self, connection: Connection) -> str:\n             if connection.schema and connection.host:\n                 return f\"{connection.schema}://{connection.host}\"\n             return NationalClouds.Global.value\n-        if not self.host.startswith(\"http://\") or not self.host.startswith(\"https://\"):\n-            return f\"{connection.schema}://{self.host}\"\n+\n+        if not self.host.startswith((\"http://\", \"https://\")):",
      "comment": "There is still code duplication I think? Just calling _ensure_protocol should be enough, no need to check if.condition again as this already done in the method.",
      "comment_id": 2738871592,
      "user": "dabla",
      "created_at": "2026-01-28T22:24:39Z",
      "url": "https://github.com/apache/airflow/pull/61103#discussion_r2738871592"
    },
    {
      "repo": "apache/airflow",
      "pr_number": 54103,
      "file_path": "airflow-core/tests/unit/jobs/test_scheduler_job.py",
      "line": 210,
      "side": "RIGHT",
      "diff_hunk": "@@ -180,6 +180,39 @@ def _create_dagrun(\n     return _create_dagrun\n \n \n+def task_maker(dag_maker, session, dag_id: str, task_num: int, max_active_tasks: int):\n+    dag_tasks = {}\n+\n+    with dag_maker(dag_id=dag_id):\n+        for i in range(task_num):\n+            # Assign priority weight to certain tasks.\n+            if (i % 10) == 0:  # 10, 20, 30, 40, 50, ...\n+                weight = int(i / 2)\n+                dag_tasks[f\"op{i}\"] = EmptyOperator(task_id=f\"dummy{i}\", priority_weight=weight)\n+            else:\n+                # No executor specified, runs on default executor\n+                dag_tasks[f\"op{i}\"] = EmptyOperator(task_id=f\"dummy{i}\")\n+\n+    # 'logical_date' is used to create the 'run_id'. Set it to 'now', in order to get distinct run ids.\n+    dag_run = dag_maker.create_dagrun(run_type=DagRunType.SCHEDULED, logical_date=timezone.utcnow())\n+\n+    task_tis = {}\n+\n+    tis_list = []\n+    for i in range(task_num):\n+        task_tis[f\"ti{i}\"] = dag_run.get_task_instance(dag_tasks[f\"op{i}\"].task_id, session)\n+        # Add to the list.\n+        tis_list.append(task_tis[f\"ti{i}\"])\n+\n+    for ti in tis_list:\n+        ti.state = State.SCHEDULED\n+        ti.dag_model.max_active_tasks = max_active_tasks\n+\n+    session.flush()\n+\n+    return tis_list",
      "comment": "It's similar to the `dag_maker` but for creating tasks. Apart from the creation, it also sets them all to `SCHEDULED` and assigns a higher priority to every 10th task.\r\n\r\nI used the priority weights to verify that higher priority tasks get examined and queued first.",
      "comment_id": 2284001691,
      "user": "xBis7",
      "created_at": "2025-08-19T04:01:41Z",
      "url": "https://github.com/apache/airflow/pull/54103#discussion_r2284001691"
    },
    {
      "repo": "apache/airflow",
      "pr_number": 54103,
      "file_path": "airflow-core/tests/unit/jobs/test_scheduler_job.py",
      "line": 210,
      "side": "RIGHT",
      "diff_hunk": "@@ -180,6 +180,39 @@ def _create_dagrun(\n     return _create_dagrun\n \n \n+def task_maker(dag_maker, session, dag_id: str, task_num: int, max_active_tasks: int):\n+    dag_tasks = {}\n+\n+    with dag_maker(dag_id=dag_id):\n+        for i in range(task_num):\n+            # Assign priority weight to certain tasks.\n+            if (i % 10) == 0:  # 10, 20, 30, 40, 50, ...\n+                weight = int(i / 2)\n+                dag_tasks[f\"op{i}\"] = EmptyOperator(task_id=f\"dummy{i}\", priority_weight=weight)\n+            else:\n+                # No executor specified, runs on default executor\n+                dag_tasks[f\"op{i}\"] = EmptyOperator(task_id=f\"dummy{i}\")\n+\n+    # 'logical_date' is used to create the 'run_id'. Set it to 'now', in order to get distinct run ids.\n+    dag_run = dag_maker.create_dagrun(run_type=DagRunType.SCHEDULED, logical_date=timezone.utcnow())\n+\n+    task_tis = {}\n+\n+    tis_list = []\n+    for i in range(task_num):\n+        task_tis[f\"ti{i}\"] = dag_run.get_task_instance(dag_tasks[f\"op{i}\"].task_id, session)\n+        # Add to the list.\n+        tis_list.append(task_tis[f\"ti{i}\"])\n+\n+    for ti in tis_list:\n+        ti.state = State.SCHEDULED\n+        ti.dag_model.max_active_tasks = max_active_tasks\n+\n+    session.flush()\n+\n+    return tis_list",
      "comment": "Yeah that makes sense. I first read it as a test that wasn't testing much and was confused.",
      "comment_id": 2285132956,
      "user": "ashb",
      "created_at": "2025-08-19T12:41:51Z",
      "url": "https://github.com/apache/airflow/pull/54103#discussion_r2285132956"
    },
    {
      "repo": "apache/airflow",
      "pr_number": 54103,
      "file_path": "airflow-core/src/airflow/jobs/scheduler_job_runner.py",
      "line": 172,
      "side": "RIGHT",
      "diff_hunk": "@@ -152,6 +164,16 @@ def _is_parent_process() -> bool:\n     return multiprocessing.current_process().name == \"MainProcess\"\n \n \n+def _get_current_dr_task_concurrency(states: Iterable[TaskInstanceState]) -> Query:",
      "comment": "I _think_ this return value is a Subquery, not a Query (honestly the return type annotation is pretty useless anyway due to the lack of SQLAlchemy support)",
      "comment_id": 2341843237,
      "user": "uranusjr",
      "created_at": "2025-09-11T17:16:17Z",
      "url": "https://github.com/apache/airflow/pull/54103#discussion_r2341843237"
    },
    {
      "repo": "apache/airflow",
      "pr_number": 54103,
      "file_path": "airflow-core/src/airflow/jobs/scheduler_job_runner.py",
      "line": 525,
      "side": "RIGHT",
      "diff_hunk": "@@ -408,10 +433,63 @@ def _executable_task_instances_to_queued(self, max_tis: int, session: Session) -\n                 .where(~DM.is_paused)\n                 .where(TI.state == TaskInstanceState.SCHEDULED)\n                 .where(DM.bundle_name.is_not(None))\n+                .join(\n+                    dr_task_concurrency_subquery,\n+                    TI.run_id == dr_task_concurrency_subquery.c.run_id,\n+                    isouter=True,\n+                )\n+                .where(func.coalesce(dr_task_concurrency_subquery.c.dr_count, 0) < DM.max_active_tasks)",
      "comment": "Hmm, `run_id` is only unique per DAG, but this subquery groups by `run_id` alone and the join uses just `TI.run_id`. When one DAG reaches `max_active_tasks`, every other DAG that happens to share the same `run_id` string (common for scheduled runs) now fails the `< DM.max_active_tasks` check and never gets considered. \n\nBetter to group by `(dag_id, run_id)` and join on both columns instead?\n\nhttps://github.com/apache/airflow/blob/085b0edfe7c7151517cd727020c13a2834409210/airflow-core/src/airflow/models/dagrun.py#L233",
      "comment_id": 2479689911,
      "user": "kaxil",
      "created_at": "2025-10-30T22:39:55Z",
      "url": "https://github.com/apache/airflow/pull/54103#discussion_r2479689911"
    },
    {
      "repo": "apache/airflow",
      "pr_number": 54103,
      "file_path": "airflow-core/src/airflow/jobs/scheduler_job_runner.py",
      "line": 525,
      "side": "RIGHT",
      "diff_hunk": "@@ -408,10 +433,63 @@ def _executable_task_instances_to_queued(self, max_tis: int, session: Session) -\n                 .where(~DM.is_paused)\n                 .where(TI.state == TaskInstanceState.SCHEDULED)\n                 .where(DM.bundle_name.is_not(None))\n+                .join(\n+                    dr_task_concurrency_subquery,\n+                    TI.run_id == dr_task_concurrency_subquery.c.run_id,\n+                    isouter=True,\n+                )\n+                .where(func.coalesce(dr_task_concurrency_subquery.c.dr_count, 0) < DM.max_active_tasks)",
      "comment": "<img width=\"856\" height=\"528\" alt=\"Image\" src=\"https://github.com/user-attachments/assets/80293a36-7909-40c9-95e2-21a2fb9ba81a\" />",
      "comment_id": 2479691474,
      "user": "kaxil",
      "created_at": "2025-10-30T22:40:43Z",
      "url": "https://github.com/apache/airflow/pull/54103#discussion_r2479691474"
    },
    {
      "repo": "apache/airflow",
      "pr_number": 54103,
      "file_path": "airflow-core/src/airflow/jobs/scheduler_job_runner.py",
      "line": 599,
      "side": "RIGHT",
      "diff_hunk": "@@ -408,10 +433,63 @@ def _executable_task_instances_to_queued(self, max_tis: int, session: Session) -\n                 .where(~DM.is_paused)\n                 .where(TI.state == TaskInstanceState.SCHEDULED)\n                 .where(DM.bundle_name.is_not(None))\n+                .join(\n+                    dr_task_concurrency_subquery,\n+                    TI.run_id == dr_task_concurrency_subquery.c.run_id,\n+                    isouter=True,\n+                )\n+                .where(func.coalesce(dr_task_concurrency_subquery.c.dr_count, 0) < DM.max_active_tasks)\n                 .options(selectinload(TI.dag_model))\n                 .order_by(-TI.priority_weight, DR.logical_date, TI.map_index)\n             )\n \n+            # Create a subquery with row numbers partitioned by run_id.\n+            #\n+            # run_id    | task_id | priority_weight | row_num\n+            # ----------|---------|-----------------|--------\n+            # dag1_dr1  | task1   | 100             | 1\n+            # dag1_dr1  | task22  | 90              | 2\n+            # dag1_dr1  | task5   | 80              | 3\n+            # dag1_dr1  | task13  | 70              | 4\n+            # dag2_dr1  | task3   | 95              | 1\n+            # dag2_dr1  | task1   | 85              | 2\n+            # dag2_dr1  | task5   | 75              | 3\n+            ranked_query = (\n+                query.add_columns(\n+                    func.row_number()\n+                    .over(\n+                        partition_by=TI.run_id,\n+                        order_by=[-TI.priority_weight, DR.logical_date, TI.map_index],\n+                    )\n+                    .label(\"row_num\"),\n+                    DM.max_active_tasks.label(\"dr_max_active_tasks\"),\n+                    # Create columns for the order_by checks here for sqlite.\n+                    TI.priority_weight.label(\"priority_weight_for_ordering\"),\n+                    DR.logical_date.label(\"logical_date_for_ordering\"),\n+                    TI.map_index.label(\"map_index_for_ordering\"),\n+                )\n+            ).subquery()\n+\n+            # Select only rows where row_number <= max_active_tasks.\n+            query = (\n+                select(TI)\n+                .select_from(ranked_query)\n+                .join(\n+                    TI,\n+                    (TI.dag_id == ranked_query.c.dag_id)\n+                    & (TI.task_id == ranked_query.c.task_id)\n+                    & (TI.run_id == ranked_query.c.run_id)\n+                    & (TI.map_index == ranked_query.c.map_index),\n+                )\n+                .where(ranked_query.c.row_num <= ranked_query.c.dr_max_active_tasks)\n+                # Add the order_by columns from the ranked query for sqlite.\n+                .order_by(\n+                    -ranked_query.c.priority_weight_for_ordering,\n+                    ranked_query.c.logical_date_for_ordering,\n+                    ranked_query.c.map_index_for_ordering,\n+                )\n+            )\n+",
      "comment": "Similar thing here: The window only partitions on `run_id`, which collides across DAGs. Once one DAG consumes its `max_active_tasks`, every other DAG with the same `run_id` is filtered out by `row_num <= dr_max_active_tasks`, even if they have zero active tasks. \n\nBetter would be to partition by both `TI.dag_id` and `TI.run_id` (or the dag run PK) before applying the limit so each DAG run keeps its own quota.\n",
      "comment_id": 2479694425,
      "user": "kaxil",
      "created_at": "2025-10-30T22:42:51Z",
      "url": "https://github.com/apache/airflow/pull/54103#discussion_r2479694425"
    },
    {
      "repo": "apache/airflow",
      "pr_number": 54103,
      "file_path": "airflow-core/src/airflow/jobs/scheduler_job_runner.py",
      "line": 525,
      "side": "RIGHT",
      "diff_hunk": "@@ -408,10 +433,63 @@ def _executable_task_instances_to_queued(self, max_tis: int, session: Session) -\n                 .where(~DM.is_paused)\n                 .where(TI.state == TaskInstanceState.SCHEDULED)\n                 .where(DM.bundle_name.is_not(None))\n+                .join(\n+                    dr_task_concurrency_subquery,\n+                    TI.run_id == dr_task_concurrency_subquery.c.run_id,\n+                    isouter=True,\n+                )\n+                .where(func.coalesce(dr_task_concurrency_subquery.c.dr_count, 0) < DM.max_active_tasks)",
      "comment": "Yup, you are likely right.\r\n\r\nI'm testing now with\r\n\r\n```\r\nfor dag in dag_45_tasks dag_250_tasks dag_470_tasks dag_10_tasks dag_1000_tasks ;do airflowctl dagrun trigger --dag-id $dag --dag-run-id run1; done\r\nfor dag in dag_45_tasks dag_250_tasks dag_470_tasks dag_10_tasks dag_1000_tasks ;do airflowctl dagrun trigger --dag-id $dag --dag-run-id run2; done\r\n```",
      "comment_id": 2480697365,
      "user": "ashb",
      "created_at": "2025-10-31T09:26:42Z",
      "url": "https://github.com/apache/airflow/pull/54103#discussion_r2480697365"
    },
    {
      "repo": "apache/airflow",
      "pr_number": 54103,
      "file_path": "airflow-core/src/airflow/jobs/scheduler_job_runner.py",
      "line": 525,
      "side": "RIGHT",
      "diff_hunk": "@@ -408,10 +433,63 @@ def _executable_task_instances_to_queued(self, max_tis: int, session: Session) -\n                 .where(~DM.is_paused)\n                 .where(TI.state == TaskInstanceState.SCHEDULED)\n                 .where(DM.bundle_name.is_not(None))\n+                .join(\n+                    dr_task_concurrency_subquery,\n+                    TI.run_id == dr_task_concurrency_subquery.c.run_id,\n+                    isouter=True,\n+                )\n+                .where(func.coalesce(dr_task_concurrency_subquery.c.dr_count, 0) < DM.max_active_tasks)",
      "comment": "You are right. I overlooked that the `run_id` isn't unique across all DAGs. Initially, the query used the `dag_id` until I realized that the behavior for the `max_active_tasks` has been changed and the limit is applied on a per dag_run base and not per dag. I'll do some testing.",
      "comment_id": 2480724286,
      "user": "xBis7",
      "created_at": "2025-10-31T09:33:52Z",
      "url": "https://github.com/apache/airflow/pull/54103#discussion_r2480724286"
    },
    {
      "repo": "apache/airflow",
      "pr_number": 54103,
      "file_path": "airflow-core/src/airflow/jobs/scheduler_job_runner.py",
      "line": 525,
      "side": "RIGHT",
      "diff_hunk": "@@ -408,10 +433,63 @@ def _executable_task_instances_to_queued(self, max_tis: int, session: Session) -\n                 .where(~DM.is_paused)\n                 .where(TI.state == TaskInstanceState.SCHEDULED)\n                 .where(DM.bundle_name.is_not(None))\n+                .join(\n+                    dr_task_concurrency_subquery,\n+                    TI.run_id == dr_task_concurrency_subquery.c.run_id,\n+                    isouter=True,\n+                )\n+                .where(func.coalesce(dr_task_concurrency_subquery.c.dr_count, 0) < DM.max_active_tasks)",
      "comment": "I did some testing and here is what I found.\r\n\r\nLet's assume that we have 3 dags with the same `run_id` and all the checks use only the `run_id`.\r\n\r\n* the query will return `max_active_tasks` from the 1st dag and ignore the other two because they have the same `run_id`\r\n* every consecutive iteration until the tasks from the 1st dag finish, won't pick any new tasks for examining and queueing\r\n* once the tasks finish, then it will pick `max_active_tasks` but it will again concentrate on 1 dag\r\n\r\nIt would group all tasks from all dags as if they all belonged to the same dag_run. But the `dag_id, run_id` pair is unique and now the tasks are properly separated.\r\n\r\nThis was a serious logical bug. I don't know how common it will be for multiple `dag_runs` to have the same `run_id` but it's good to have already accounted for that edge case. Thanks @kaxil, great catch! With the suggested changes it works as it should.",
      "comment_id": 2483790152,
      "user": "xBis7",
      "created_at": "2025-11-01T16:38:59Z",
      "url": "https://github.com/apache/airflow/pull/54103#discussion_r2483790152"
    },
    {
      "repo": "apache/airflow",
      "pr_number": 54103,
      "file_path": "airflow-core/src/airflow/jobs/scheduler_job_runner.py",
      "line": 589,
      "side": "RIGHT",
      "diff_hunk": "@@ -515,6 +588,12 @@ def _executable_task_instances_to_queued(self, max_tis: int, session: Session) -\n                 locked_query = with_row_locks(query, of=TI, session=session, skip_locked=True)\n                 task_instances_to_examine: list[TI] = list(session.scalars(locked_query).all())",
      "comment": "```suggestion\n                task_instances_to_examine = session.scalars(locked_query).all()\n```\n\nNot really related, but let\u2019s fix this potentially wasteful line",
      "comment_id": 2555010941,
      "user": "uranusjr",
      "created_at": "2025-11-24T08:03:44Z",
      "url": "https://github.com/apache/airflow/pull/54103#discussion_r2555010941"
    },
    {
      "repo": "apache/airflow",
      "pr_number": 54103,
      "file_path": "airflow-core/tests/unit/jobs/test_scheduler_job.py",
      "line": 1481,
      "side": "RIGHT",
      "diff_hunk": "@@ -1178,6 +1224,97 @@ def test_find_executable_task_instances_executor_with_teams(self, dag_maker, moc\n         ]\n         assert len(b_tis_in_wrong_executor) == 0\n \n+    def task_helper(self, dag_maker, session, dag_id: str, task_num: int):\n+        dag_tasks = {}\n+\n+        with dag_maker(dag_id=dag_id):\n+            for i in range(task_num):\n+                # Assign priority weight to certain tasks.\n+                if (i % 10) == 0:  # 10, 20, 30, 40, 50, ...\n+                    weight = int(i / 2)\n+                    dag_tasks[f\"op{i}\"] = EmptyOperator(task_id=f\"dummy{i}\", priority_weight=weight)\n+                else:\n+                    # No executor specified, runs on default executor\n+                    dag_tasks[f\"op{i}\"] = EmptyOperator(task_id=f\"dummy{i}\")\n+\n+        dag_run = dag_maker.create_dagrun(run_type=DagRunType.SCHEDULED)\n+\n+        task_tis = {}\n+\n+        tis_list = []\n+        for i in range(task_num):\n+            task_tis[f\"ti{i}\"] = dag_run.get_task_instance(dag_tasks[f\"op{i}\"].task_id, session)\n+            # add\n+            tis_list.append(task_tis[f\"ti{i}\"])\n+\n+        for ti in tis_list:\n+            ti.state = State.SCHEDULED\n+            ti.dag_model.max_active_tasks = 4\n+\n+        session.flush()\n+\n+        return tis_list\n+\n+    @conf_vars(\n+        {\n+            (\"scheduler\", \"max_tis_per_query\"): \"100\",\n+            (\"scheduler\", \"max_dagruns_to_create_per_loop\"): \"10\",\n+            (\"scheduler\", \"max_dagruns_per_loop_to_schedule\"): \"20\",\n+            (\"core\", \"parallelism\"): \"100\",\n+            (\"core\", \"max_active_tasks_per_dag\"): \"4\",\n+            (\"core\", \"max_active_runs_per_dag\"): \"10\",\n+            (\"core\", \"default_pool_task_slot_count\"): \"64\",\n+        }\n+    )\n+    def test_per_dr_limit_applied_in_task_query(self, dag_maker, mock_executors):\n+        scheduler_job = Job()\n+        scheduler_job.executor.parallelism = 100\n+        scheduler_job.executor.slots_available = 70\n+        scheduler_job.max_tis_per_query = 100\n+        self.job_runner = SchedulerJobRunner(job=scheduler_job)\n+        session = settings.Session()\n+\n+        # Use the same run_id.\n+        task_maker(dag_maker, session, \"dag_1300_tasks\", 1300, 4, \"run1\")\n+        task_maker(dag_maker, session, \"dag_1200_tasks\", 1200, 4, \"run1\")\n+        task_maker(dag_maker, session, \"dag_1100_tasks\", 1100, 4, \"run1\")\n+        task_maker(dag_maker, session, \"dag_100_tasks\", 100, 4, \"run1\")\n+        task_maker(dag_maker, session, \"dag_90_tasks\", 90, 4, \"run1\")\n+        task_maker(dag_maker, session, \"dag_80_tasks\", 80, 4, \"run1\")\n+\n+        count = 0\n+        iterations = 0\n+\n+        from airflow.configuration import conf\n+\n+        task_num = conf.getint(\"core\", \"max_active_tasks_per_dag\") * 6\n+\n+        # 6 dags * 4 = 24.\n+        assert task_num == 24\n+\n+        queued_tis = None\n+        while count < task_num:\n+            # Use `_executable_task_instances_to_queued` because it returns a list of TIs\n+            # while `_critical_section_enqueue_task_instances` just returns the number of the TIs.\n+            queued_tis = self.job_runner._executable_task_instances_to_queued(\n+                max_tis=scheduler_job.executor.slots_available, session=session\n+            )\n+            count += len(queued_tis)\n+            iterations += 1\n+\n+        assert iterations == 1\n+        assert count == task_num\n+\n+        assert queued_tis is not None\n+\n+        dag_counts = Counter(ti.dag_id for ti in queued_tis)\n+\n+        # Tasks from all 6 dags should have been queued.\n+        assert len(dag_counts) == 6\n+        assert all(count == 4 for count in dag_counts.values()), (\n+            \"Count for each dag_id should be 4 but it isn't\"\n+        )",
      "comment": "It\u2019d probably be easier for debugging if this just do\n\n```python\nassert dag_counts == {\n    \"dag_1300_tasks\": 4,\n    \"dag_1200_tasks\": 4,\n    ...\n}\n```",
      "comment_id": 2555020477,
      "user": "uranusjr",
      "created_at": "2025-11-24T08:07:09Z",
      "url": "https://github.com/apache/airflow/pull/54103#discussion_r2555020477"
    },
    {
      "repo": "apache/airflow",
      "pr_number": 54103,
      "file_path": "airflow-core/src/airflow/jobs/scheduler_job_runner.py",
      "line": 590,
      "side": "RIGHT",
      "diff_hunk": "@@ -488,10 +513,58 @@ def _executable_task_instances_to_queued(self, max_tis: int, session: Session) -\n                 .where(~DM.is_paused)\n                 .where(TI.state == TaskInstanceState.SCHEDULED)\n                 .where(DM.bundle_name.is_not(None))\n+                .join(\n+                    dr_task_concurrency_subquery,\n+                    and_(\n+                        TI.dag_id == dr_task_concurrency_subquery.c.dag_id,\n+                        TI.run_id == dr_task_concurrency_subquery.c.run_id,\n+                    ),\n+                    isouter=True,\n+                )\n+                .where(func.coalesce(dr_task_concurrency_subquery.c.dr_count, 0) < DM.max_active_tasks)\n                 .options(selectinload(TI.dag_model))\n                 .order_by(-TI.priority_weight, DR.logical_date, TI.map_index)\n             )\n \n+            # Create a subquery with row numbers partitioned by dag_id and run_id.\n+            # Different dags can have the same run_id but\n+            # the dag_id combined with the run_id uniquely identify a run.\n+            ranked_query = (\n+                query.add_columns(\n+                    func.row_number()\n+                    .over(\n+                        partition_by=[TI.dag_id, TI.run_id],\n+                        order_by=[-TI.priority_weight, DR.logical_date, TI.map_index],\n+                    )\n+                    .label(\"row_num\"),\n+                    DM.max_active_tasks.label(\"dr_max_active_tasks\"),\n+                    # Create columns for the order_by checks here for sqlite.\n+                    TI.priority_weight.label(\"priority_weight_for_ordering\"),\n+                    DR.logical_date.label(\"logical_date_for_ordering\"),\n+                    TI.map_index.label(\"map_index_for_ordering\"),\n+                )\n+            ).subquery()\n+\n+            # Select only rows where row_number <= max_active_tasks.\n+            query = (\n+                select(TI)\n+                .select_from(ranked_query)\n+                .join(\n+                    TI,\n+                    (TI.dag_id == ranked_query.c.dag_id)\n+                    & (TI.task_id == ranked_query.c.task_id)\n+                    & (TI.run_id == ranked_query.c.run_id)\n+                    & (TI.map_index == ranked_query.c.map_index),\n+                )\n+                .where(ranked_query.c.row_num <= ranked_query.c.dr_max_active_tasks)",
      "comment": "The window function limits selection to `max_active_tasks` per dag_run without considering currently executing tasks. For example, if a dag_run has 3 tasks already executing and `max_active_tasks=4`, this query would select 4 scheduled tasks (since `row_num` goes 1-4), but only 1 can actually be queued. This means up to 3 extra tasks are retrieved and then rejected at line 701.\n\nConsider incorporating the current task count (`dr_count` from line 505) into the row number filter to improve efficiency:\n1. Add `dr_task_concurrency_subquery.c.dr_count` to the columns at line 533\n2. Change line 559 to: `where(ranked_query.c.row_num <= (ranked_query.c.dr_max_active_tasks - func.coalesce(ranked_query.c.dr_count, 0)))`\n\nThis would reduce unnecessary database retrievals and subsequent filtering in Python code.",
      "comment_id": 2594698570,
      "user": "Copilot",
      "created_at": "2025-12-06T10:07:39Z",
      "url": "https://github.com/apache/airflow/pull/54103#discussion_r2594698570"
    },
    {
      "repo": "apache/airflow",
      "pr_number": 54103,
      "file_path": "airflow-core/tests/unit/jobs/test_scheduler_job.py",
      "line": 1286,
      "side": "RIGHT",
      "diff_hunk": "@@ -1180,6 +1226,102 @@ def test_find_executable_task_instances_executor_with_teams(self, dag_maker, moc\n         ]\n         assert len(b_tis_in_wrong_executor) == 0\n \n+    def task_helper(self, dag_maker, session, dag_id: str, task_num: int):\n+        dag_tasks = {}\n+\n+        with dag_maker(dag_id=dag_id):\n+            for i in range(task_num):\n+                # Assign priority weight to certain tasks.\n+                if (i % 10) == 0:  # 10, 20, 30, 40, 50, ...\n+                    weight = int(i / 2)\n+                    dag_tasks[f\"op{i}\"] = EmptyOperator(task_id=f\"dummy{i}\", priority_weight=weight)\n+                else:\n+                    # No executor specified, runs on default executor\n+                    dag_tasks[f\"op{i}\"] = EmptyOperator(task_id=f\"dummy{i}\")\n+\n+        dag_run = dag_maker.create_dagrun(run_type=DagRunType.SCHEDULED)\n+\n+        task_tis = {}\n+\n+        tis_list = []\n+        for i in range(task_num):\n+            task_tis[f\"ti{i}\"] = dag_run.get_task_instance(dag_tasks[f\"op{i}\"].task_id, session)\n+            # add\n+            tis_list.append(task_tis[f\"ti{i}\"])\n+\n+        for ti in tis_list:\n+            ti.state = State.SCHEDULED\n+            ti.dag_model.max_active_tasks = 4\n+\n+        session.flush()\n+\n+        return tis_list",
      "comment": "The `task_helper` method (lines 1229-1258) is nearly identical to the module-level `task_maker` function (lines 184-227). The only significant differences are:\n1. `task_helper` has a hardcoded `max_active_tasks = 4` (line 1254) instead of accepting it as a parameter\n2. `task_helper` doesn't support custom `run_id` parameter\n\nConsider removing this duplicate method and using the `task_maker` function instead, or refactor to reduce code duplication. For example, the test at line 1271 could use `task_maker` directly.",
      "comment_id": 2594698573,
      "user": "Copilot",
      "created_at": "2025-12-06T10:07:40Z",
      "url": "https://github.com/apache/airflow/pull/54103#discussion_r2594698573"
    },
    {
      "repo": "apache/airflow",
      "pr_number": 54103,
      "file_path": "airflow-core/tests/unit/jobs/test_scheduler_job.py",
      "line": 1277,
      "side": "RIGHT",
      "diff_hunk": "@@ -1180,6 +1226,102 @@ def test_find_executable_task_instances_executor_with_teams(self, dag_maker, moc\n         ]\n         assert len(b_tis_in_wrong_executor) == 0\n \n+    def task_helper(self, dag_maker, session, dag_id: str, task_num: int):\n+        dag_tasks = {}\n+\n+        with dag_maker(dag_id=dag_id):\n+            for i in range(task_num):\n+                # Assign priority weight to certain tasks.\n+                if (i % 10) == 0:  # 10, 20, 30, 40, 50, ...\n+                    weight = int(i / 2)\n+                    dag_tasks[f\"op{i}\"] = EmptyOperator(task_id=f\"dummy{i}\", priority_weight=weight)\n+                else:\n+                    # No executor specified, runs on default executor\n+                    dag_tasks[f\"op{i}\"] = EmptyOperator(task_id=f\"dummy{i}\")\n+\n+        dag_run = dag_maker.create_dagrun(run_type=DagRunType.SCHEDULED)\n+\n+        task_tis = {}\n+\n+        tis_list = []\n+        for i in range(task_num):\n+            task_tis[f\"ti{i}\"] = dag_run.get_task_instance(dag_tasks[f\"op{i}\"].task_id, session)\n+            # add",
      "comment": "[nitpick] The comment \"# add\" is too vague and doesn't add meaningful information. Consider either removing it or making it more descriptive, such as \"# Add task instance to list for state updates\".\n```suggestion\n            # Add task instance to list for state updates\n```",
      "comment_id": 2594698575,
      "user": "Copilot",
      "created_at": "2025-12-06T10:07:40Z",
      "url": "https://github.com/apache/airflow/pull/54103#discussion_r2594698575"
    },
    {
      "repo": "apache/airflow",
      "pr_number": 54103,
      "file_path": "airflow-core/tests/unit/jobs/test_scheduler_job.py",
      "line": 200,
      "side": "RIGHT",
      "diff_hunk": "@@ -181,6 +181,52 @@ def _create_dagrun(\n     return _create_dagrun\n \n \n+def task_maker(\n+    dag_maker, session, dag_id: str, task_num: int, max_active_tasks: int, run_id: str | None = None\n+):\n+    dag_tasks = {}\n+\n+    with dag_maker(dag_id=dag_id):\n+        for i in range(task_num):\n+            # Assign priority weight to certain tasks.\n+            if (i % 10) == 0:  # 10, 20, 30, 40, 50, ...",
      "comment": "The comment suggests the condition matches tasks at indices 10, 20, 30, etc., but the condition `(i % 10) == 0` actually matches indices 0, 10, 20, 30, etc. The comment should be updated to \"# 0, 10, 20, 30, 40, ...\" to accurately reflect when the condition is true.\n```suggestion\n            if (i % 10) == 0:  # 0, 10, 20, 30, 40, ...\n```",
      "comment_id": 2594698576,
      "user": "Copilot",
      "created_at": "2025-12-06T10:07:41Z",
      "url": "https://github.com/apache/airflow/pull/54103#discussion_r2594698576"
    },
    {
      "repo": "apache/airflow",
      "pr_number": 54103,
      "file_path": "airflow-core/tests/unit/jobs/test_scheduler_job.py",
      "line": 1263,
      "side": "RIGHT",
      "diff_hunk": "@@ -1180,6 +1226,102 @@ def test_find_executable_task_instances_executor_with_teams(self, dag_maker, moc\n         ]\n         assert len(b_tis_in_wrong_executor) == 0\n \n+    def task_helper(self, dag_maker, session, dag_id: str, task_num: int):\n+        dag_tasks = {}\n+\n+        with dag_maker(dag_id=dag_id):\n+            for i in range(task_num):\n+                # Assign priority weight to certain tasks.\n+                if (i % 10) == 0:  # 10, 20, 30, 40, 50, ...",
      "comment": "The comment suggests the condition matches tasks at indices 10, 20, 30, etc., but the condition `(i % 10) == 0` actually matches indices 0, 10, 20, 30, etc. The comment should be updated to \"# 0, 10, 20, 30, 40, ...\" to accurately reflect when the condition is true.\n```suggestion\n                if (i % 10) == 0:  # 0, 10, 20, 30, 40, 50, ...\n```",
      "comment_id": 2594698578,
      "user": "Copilot",
      "created_at": "2025-12-06T10:07:41Z",
      "url": "https://github.com/apache/airflow/pull/54103#discussion_r2594698578"
    },
    {
      "repo": "apache/airflow",
      "pr_number": 54103,
      "file_path": "airflow-core/src/airflow/jobs/scheduler_job_runner.py",
      "line": 590,
      "side": "RIGHT",
      "diff_hunk": "@@ -488,10 +513,58 @@ def _executable_task_instances_to_queued(self, max_tis: int, session: Session) -\n                 .where(~DM.is_paused)\n                 .where(TI.state == TaskInstanceState.SCHEDULED)\n                 .where(DM.bundle_name.is_not(None))\n+                .join(\n+                    dr_task_concurrency_subquery,\n+                    and_(\n+                        TI.dag_id == dr_task_concurrency_subquery.c.dag_id,\n+                        TI.run_id == dr_task_concurrency_subquery.c.run_id,\n+                    ),\n+                    isouter=True,\n+                )\n+                .where(func.coalesce(dr_task_concurrency_subquery.c.dr_count, 0) < DM.max_active_tasks)\n                 .options(selectinload(TI.dag_model))\n                 .order_by(-TI.priority_weight, DR.logical_date, TI.map_index)\n             )\n \n+            # Create a subquery with row numbers partitioned by dag_id and run_id.\n+            # Different dags can have the same run_id but\n+            # the dag_id combined with the run_id uniquely identify a run.\n+            ranked_query = (\n+                query.add_columns(\n+                    func.row_number()\n+                    .over(\n+                        partition_by=[TI.dag_id, TI.run_id],\n+                        order_by=[-TI.priority_weight, DR.logical_date, TI.map_index],\n+                    )\n+                    .label(\"row_num\"),\n+                    DM.max_active_tasks.label(\"dr_max_active_tasks\"),\n+                    # Create columns for the order_by checks here for sqlite.\n+                    TI.priority_weight.label(\"priority_weight_for_ordering\"),\n+                    DR.logical_date.label(\"logical_date_for_ordering\"),\n+                    TI.map_index.label(\"map_index_for_ordering\"),\n+                )\n+            ).subquery()\n+\n+            # Select only rows where row_number <= max_active_tasks.\n+            query = (\n+                select(TI)\n+                .select_from(ranked_query)\n+                .join(\n+                    TI,\n+                    (TI.dag_id == ranked_query.c.dag_id)\n+                    & (TI.task_id == ranked_query.c.task_id)\n+                    & (TI.run_id == ranked_query.c.run_id)\n+                    & (TI.map_index == ranked_query.c.map_index),\n+                )\n+                .where(ranked_query.c.row_num <= ranked_query.c.dr_max_active_tasks)",
      "comment": "I'm going to give this a try and run some tests. If it alters the scheduler behavior too much then it might not be worth it for now.\r\n\r\nThe current patch doesn't fix everything but provides certain performance improvements and it has been very thoroughly tested.",
      "comment_id": 2640505174,
      "user": "xBis7",
      "created_at": "2025-12-22T16:45:35Z",
      "url": "https://github.com/apache/airflow/pull/54103#discussion_r2640505174"
    },
    {
      "repo": "apache/airflow",
      "pr_number": 54103,
      "file_path": "airflow-core/src/airflow/jobs/scheduler_job_runner.py",
      "line": 590,
      "side": "RIGHT",
      "diff_hunk": "@@ -488,10 +513,58 @@ def _executable_task_instances_to_queued(self, max_tis: int, session: Session) -\n                 .where(~DM.is_paused)\n                 .where(TI.state == TaskInstanceState.SCHEDULED)\n                 .where(DM.bundle_name.is_not(None))\n+                .join(\n+                    dr_task_concurrency_subquery,\n+                    and_(\n+                        TI.dag_id == dr_task_concurrency_subquery.c.dag_id,\n+                        TI.run_id == dr_task_concurrency_subquery.c.run_id,\n+                    ),\n+                    isouter=True,\n+                )\n+                .where(func.coalesce(dr_task_concurrency_subquery.c.dr_count, 0) < DM.max_active_tasks)\n                 .options(selectinload(TI.dag_model))\n                 .order_by(-TI.priority_weight, DR.logical_date, TI.map_index)\n             )\n \n+            # Create a subquery with row numbers partitioned by dag_id and run_id.\n+            # Different dags can have the same run_id but\n+            # the dag_id combined with the run_id uniquely identify a run.\n+            ranked_query = (\n+                query.add_columns(\n+                    func.row_number()\n+                    .over(\n+                        partition_by=[TI.dag_id, TI.run_id],\n+                        order_by=[-TI.priority_weight, DR.logical_date, TI.map_index],\n+                    )\n+                    .label(\"row_num\"),\n+                    DM.max_active_tasks.label(\"dr_max_active_tasks\"),\n+                    # Create columns for the order_by checks here for sqlite.\n+                    TI.priority_weight.label(\"priority_weight_for_ordering\"),\n+                    DR.logical_date.label(\"logical_date_for_ordering\"),\n+                    TI.map_index.label(\"map_index_for_ordering\"),\n+                )\n+            ).subquery()\n+\n+            # Select only rows where row_number <= max_active_tasks.\n+            query = (\n+                select(TI)\n+                .select_from(ranked_query)\n+                .join(\n+                    TI,\n+                    (TI.dag_id == ranked_query.c.dag_id)\n+                    & (TI.task_id == ranked_query.c.task_id)\n+                    & (TI.run_id == ranked_query.c.run_id)\n+                    & (TI.map_index == ranked_query.c.map_index),\n+                )\n+                .where(ranked_query.c.row_num <= ranked_query.c.dr_max_active_tasks)",
      "comment": "I've run tests and this change doesn't seem to make any difference so far.",
      "comment_id": 2644030886,
      "user": "xBis7",
      "created_at": "2025-12-23T18:56:55Z",
      "url": "https://github.com/apache/airflow/pull/54103#discussion_r2644030886"
    },
    {
      "repo": "apache/airflow",
      "pr_number": 54103,
      "file_path": "airflow-core/src/airflow/jobs/scheduler_job_runner.py",
      "line": 598,
      "side": "RIGHT",
      "diff_hunk": "@@ -490,10 +515,60 @@ def _executable_task_instances_to_queued(self, max_tis: int, session: Session) -\n                 .where(~DM.is_paused)\n                 .where(TI.state == TaskInstanceState.SCHEDULED)\n                 .where(DM.bundle_name.is_not(None))\n+                .join(\n+                    dr_task_concurrency_subquery,\n+                    and_(\n+                        TI.dag_id == dr_task_concurrency_subquery.c.dag_id,\n+                        TI.run_id == dr_task_concurrency_subquery.c.run_id,\n+                    ),\n+                    isouter=True,\n+                )\n+                .where(\n+                    func.coalesce(dr_task_concurrency_subquery.c.task_per_dr_count, 0) < DM.max_active_tasks\n+                )\n                 .options(selectinload(TI.dag_model))\n                 .order_by(-TI.priority_weight, DR.logical_date, TI.map_index)\n             )\n \n+            # Create a subquery with row numbers partitioned by dag_id and run_id.\n+            # Different dags can have the same run_id but\n+            # the dag_id combined with the run_id uniquely identify a run.\n+            ranked_query = (\n+                query.add_columns(\n+                    func.row_number()\n+                    .over(\n+                        partition_by=[TI.dag_id, TI.run_id],\n+                        order_by=[-TI.priority_weight, DR.logical_date, TI.map_index],\n+                    )\n+                    .label(\"row_num\"),\n+                    DM.max_active_tasks.label(\"dr_max_active_tasks\"),\n+                    # Create columns for the order_by checks here for sqlite.\n+                    TI.priority_weight.label(\"priority_weight_for_ordering\"),\n+                    DR.logical_date.label(\"logical_date_for_ordering\"),\n+                    TI.map_index.label(\"map_index_for_ordering\"),\n+                )\n+            ).subquery()\n+\n+            # Select only rows where row_number <= max_active_tasks.\n+            query = (\n+                select(TI)\n+                .select_from(ranked_query)\n+                .join(\n+                    TI,\n+                    (TI.dag_id == ranked_query.c.dag_id)\n+                    & (TI.task_id == ranked_query.c.task_id)\n+                    & (TI.run_id == ranked_query.c.run_id)\n+                    & (TI.map_index == ranked_query.c.map_index),\n+                )\n+                .where(ranked_query.c.row_num <= ranked_query.c.dr_max_active_tasks)\n+                # Add the order_by columns from the ranked query for sqlite.\n+                .order_by(\n+                    -ranked_query.c.priority_weight_for_ordering,\n+                    ranked_query.c.logical_date_for_ordering,\n+                    ranked_query.c.map_index_for_ordering,\n+                )\n+            )",
      "comment": "So, probably\r\n```py\r\nquery = (\r\n    select(TI)\r\n    .select_from(ranked_query)\r\n    .join(\r\n        TI,\r\n        (TI.dag_id == ranked_query.c.dag_id)\r\n        & (TI.task_id == ranked_query.c.task_id)\r\n        & (TI.run_id == ranked_query.c.run_id)\r\n        & (TI.map_index == ranked_query.c.map_index),\r\n    )\r\n    .where(ranked_query.c.row_num <= ranked_query.c.dr_max_active_tasks)\r\n    .order_by(\r\n        -ranked_query.c.priority_weight_for_ordering,\r\n        ranked_query.c.logical_date_for_ordering,\r\n        ranked_query.c.map_index_for_ordering,\r\n    )\r\n    .options(selectinload(TI.dag_model))\r\n)\r\n```",
      "comment_id": 2705256990,
      "user": "kaxil",
      "created_at": "2026-01-19T15:40:23Z",
      "url": "https://github.com/apache/airflow/pull/54103#discussion_r2705256990"
    },
    {
      "repo": "apache/airflow",
      "pr_number": 54103,
      "file_path": "airflow-core/src/airflow/jobs/scheduler_job_runner.py",
      "line": 598,
      "side": "RIGHT",
      "diff_hunk": "@@ -490,10 +515,60 @@ def _executable_task_instances_to_queued(self, max_tis: int, session: Session) -\n                 .where(~DM.is_paused)\n                 .where(TI.state == TaskInstanceState.SCHEDULED)\n                 .where(DM.bundle_name.is_not(None))\n+                .join(\n+                    dr_task_concurrency_subquery,\n+                    and_(\n+                        TI.dag_id == dr_task_concurrency_subquery.c.dag_id,\n+                        TI.run_id == dr_task_concurrency_subquery.c.run_id,\n+                    ),\n+                    isouter=True,\n+                )\n+                .where(\n+                    func.coalesce(dr_task_concurrency_subquery.c.task_per_dr_count, 0) < DM.max_active_tasks\n+                )\n                 .options(selectinload(TI.dag_model))\n                 .order_by(-TI.priority_weight, DR.logical_date, TI.map_index)\n             )\n \n+            # Create a subquery with row numbers partitioned by dag_id and run_id.\n+            # Different dags can have the same run_id but\n+            # the dag_id combined with the run_id uniquely identify a run.\n+            ranked_query = (\n+                query.add_columns(\n+                    func.row_number()\n+                    .over(\n+                        partition_by=[TI.dag_id, TI.run_id],\n+                        order_by=[-TI.priority_weight, DR.logical_date, TI.map_index],\n+                    )\n+                    .label(\"row_num\"),\n+                    DM.max_active_tasks.label(\"dr_max_active_tasks\"),\n+                    # Create columns for the order_by checks here for sqlite.\n+                    TI.priority_weight.label(\"priority_weight_for_ordering\"),\n+                    DR.logical_date.label(\"logical_date_for_ordering\"),\n+                    TI.map_index.label(\"map_index_for_ordering\"),\n+                )\n+            ).subquery()\n+\n+            # Select only rows where row_number <= max_active_tasks.\n+            query = (\n+                select(TI)\n+                .select_from(ranked_query)\n+                .join(\n+                    TI,\n+                    (TI.dag_id == ranked_query.c.dag_id)\n+                    & (TI.task_id == ranked_query.c.task_id)\n+                    & (TI.run_id == ranked_query.c.run_id)\n+                    & (TI.map_index == ranked_query.c.map_index),\n+                )\n+                .where(ranked_query.c.row_num <= ranked_query.c.dr_max_active_tasks)\n+                # Add the order_by columns from the ranked query for sqlite.\n+                .order_by(\n+                    -ranked_query.c.priority_weight_for_ordering,\n+                    ranked_query.c.logical_date_for_ordering,\n+                    ranked_query.c.map_index_for_ordering,\n+                )\n+            )",
      "comment": "Not sure what happened to my earlier comment so re-adding: This new query is missing `.options(selectinload(TI.dag_model))` and `.with_hint(TI, \"USE INDEX (ti_state)\", dialect_name=\"mysql\")` which were on the original query. Every `ti.dag_model` access later will trigger a separate query - with 50 TIs that's 50+ extra queries per loop.",
      "comment_id": 2705400293,
      "user": "kaxil",
      "created_at": "2026-01-19T16:23:27Z",
      "url": "https://github.com/apache/airflow/pull/54103#discussion_r2705400293"
    },
    {
      "repo": "apache/airflow",
      "pr_number": 54103,
      "file_path": "airflow-core/src/airflow/jobs/scheduler_job_runner.py",
      "line": 576,
      "side": "RIGHT",
      "diff_hunk": "@@ -490,10 +515,60 @@ def _executable_task_instances_to_queued(self, max_tis: int, session: Session) -\n                 .where(~DM.is_paused)\n                 .where(TI.state == TaskInstanceState.SCHEDULED)\n                 .where(DM.bundle_name.is_not(None))\n+                .join(\n+                    dr_task_concurrency_subquery,\n+                    and_(\n+                        TI.dag_id == dr_task_concurrency_subquery.c.dag_id,\n+                        TI.run_id == dr_task_concurrency_subquery.c.run_id,\n+                    ),\n+                    isouter=True,\n+                )\n+                .where(\n+                    func.coalesce(dr_task_concurrency_subquery.c.task_per_dr_count, 0) < DM.max_active_tasks\n+                )\n                 .options(selectinload(TI.dag_model))\n                 .order_by(-TI.priority_weight, DR.logical_date, TI.map_index)\n             )\n \n+            # Create a subquery with row numbers partitioned by dag_id and run_id.\n+            # Different dags can have the same run_id but\n+            # the dag_id combined with the run_id uniquely identify a run.\n+            ranked_query = (\n+                query.add_columns(\n+                    func.row_number()\n+                    .over(\n+                        partition_by=[TI.dag_id, TI.run_id],\n+                        order_by=[-TI.priority_weight, DR.logical_date, TI.map_index],\n+                    )\n+                    .label(\"row_num\"),\n+                    DM.max_active_tasks.label(\"dr_max_active_tasks\"),\n+                    # Create columns for the order_by checks here for sqlite.\n+                    TI.priority_weight.label(\"priority_weight_for_ordering\"),\n+                    DR.logical_date.label(\"logical_date_for_ordering\"),\n+                    TI.map_index.label(\"map_index_for_ordering\"),\n+                )\n+            ).subquery()",
      "comment": "Row numbers are assigned here before starvation filters (starved_pools, starved_dags, etc) are applied below. In the original code, those filters were applied BEFORE the limit. Tasks in starved pools will now consume row_number slots and then get filtered out, potentially excluding schedulable tasks from the same dag run.",
      "comment_id": 2705400296,
      "user": "kaxil",
      "created_at": "2026-01-19T16:23:27Z",
      "url": "https://github.com/apache/airflow/pull/54103#discussion_r2705400296"
    },
    {
      "repo": "apache/airflow",
      "pr_number": 54103,
      "file_path": "airflow-core/src/airflow/jobs/scheduler_job_runner.py",
      "line": 216,
      "side": "RIGHT",
      "diff_hunk": "@@ -194,6 +207,16 @@ def _is_parent_process() -> bool:\n     return multiprocessing.current_process().name == \"MainProcess\"\n \n \n+def _get_current_dr_task_concurrency(states: Iterable[TaskInstanceState]) -> Subquery:\n+    \"\"\"Get the dag_run IDs and how many tasks are in the provided states for each one.\"\"\"",
      "comment": "This queries the same data as `ConcurrencyMap.load()` which is still called and used for the check at lines ~680-695. Worth adding a comment explaining why we keep both? (race condition protection between query time and check time?)",
      "comment_id": 2705400298,
      "user": "kaxil",
      "created_at": "2026-01-19T16:23:27Z",
      "url": "https://github.com/apache/airflow/pull/54103#discussion_r2705400298"
    },
    {
      "repo": "apache/airflow",
      "pr_number": 54103,
      "file_path": "airflow-core/tests/unit/jobs/test_scheduler_job.py",
      "line": 203,
      "side": "RIGHT",
      "diff_hunk": "@@ -194,6 +194,52 @@ def _create_dagrun(\n     return _create_dagrun\n \n \n+def task_maker(",
      "comment": "Couple test cases worth adding:\n\n1. **Starvation filter ordering**: dag run with tasks in mixed pools (some starved, some not). Verify non-starved pool tasks aren't excluded because starved-pool tasks consumed row_number slots.\n\n2. **Partial capacity**: dag run with `max_active_tasks=4` where 2 are already RUNNING + 10 SCHEDULED. Verify query returns only 2 (not 4) for that run.",
      "comment_id": 2705400299,
      "user": "kaxil",
      "created_at": "2026-01-19T16:23:27Z",
      "url": "https://github.com/apache/airflow/pull/54103#discussion_r2705400299"
    },
    {
      "repo": "apache/airflow",
      "pr_number": 54103,
      "file_path": "airflow-core/src/airflow/jobs/scheduler_job_runner.py",
      "line": 576,
      "side": "RIGHT",
      "diff_hunk": "@@ -490,10 +515,60 @@ def _executable_task_instances_to_queued(self, max_tis: int, session: Session) -\n                 .where(~DM.is_paused)\n                 .where(TI.state == TaskInstanceState.SCHEDULED)\n                 .where(DM.bundle_name.is_not(None))\n+                .join(\n+                    dr_task_concurrency_subquery,\n+                    and_(\n+                        TI.dag_id == dr_task_concurrency_subquery.c.dag_id,\n+                        TI.run_id == dr_task_concurrency_subquery.c.run_id,\n+                    ),\n+                    isouter=True,\n+                )\n+                .where(\n+                    func.coalesce(dr_task_concurrency_subquery.c.task_per_dr_count, 0) < DM.max_active_tasks\n+                )\n                 .options(selectinload(TI.dag_model))\n                 .order_by(-TI.priority_weight, DR.logical_date, TI.map_index)\n             )\n \n+            # Create a subquery with row numbers partitioned by dag_id and run_id.\n+            # Different dags can have the same run_id but\n+            # the dag_id combined with the run_id uniquely identify a run.\n+            ranked_query = (\n+                query.add_columns(\n+                    func.row_number()\n+                    .over(\n+                        partition_by=[TI.dag_id, TI.run_id],\n+                        order_by=[-TI.priority_weight, DR.logical_date, TI.map_index],\n+                    )\n+                    .label(\"row_num\"),\n+                    DM.max_active_tasks.label(\"dr_max_active_tasks\"),\n+                    # Create columns for the order_by checks here for sqlite.\n+                    TI.priority_weight.label(\"priority_weight_for_ordering\"),\n+                    DR.logical_date.label(\"logical_date_for_ordering\"),\n+                    TI.map_index.label(\"map_index_for_ordering\"),\n+                )\n+            ).subquery()",
      "comment": "I think it's inherent to this solution as it's impossible to check both simultaneously. This PR does prevent starvation, but only for `max_active_tasks` limit. Bumped into this too when trying to consider all the concurrency limits.",
      "comment_id": 2705612502,
      "user": "Asquator",
      "created_at": "2026-01-19T17:24:52Z",
      "url": "https://github.com/apache/airflow/pull/54103#discussion_r2705612502"
    },
    {
      "repo": "apache/airflow",
      "pr_number": 54103,
      "file_path": "airflow-core/src/airflow/jobs/scheduler_job_runner.py",
      "line": 216,
      "side": "RIGHT",
      "diff_hunk": "@@ -194,6 +207,16 @@ def _is_parent_process() -> bool:\n     return multiprocessing.current_process().name == \"MainProcess\"\n \n \n+def _get_current_dr_task_concurrency(states: Iterable[TaskInstanceState]) -> Subquery:\n+    \"\"\"Get the dag_run IDs and how many tasks are in the provided states for each one.\"\"\"",
      "comment": "I think you are referring to this part on lines 488-490\r\n\r\n```python\r\n# dag_id to # of running tasks and (dag_id, task_id) to # of running tasks.\r\nconcurrency_map = ConcurrencyMap()\r\nconcurrency_map.load(session=session)\r\n```\r\n\r\nIt immediately executes the query and gets the results while `_get_current_dr_task_concurrency` creates a subquery that gets included in the main query. The subquery will be executed in a later point which could be immediate but it could also be after a while. The results could be different even after 3 seconds.\r\n\r\nIs that what you mean? And what I should explain in a comment?",
      "comment_id": 2708414793,
      "user": "xBis7",
      "created_at": "2026-01-20T13:42:39Z",
      "url": "https://github.com/apache/airflow/pull/54103#discussion_r2708414793"
    },
    {
      "repo": "apache/airflow",
      "pr_number": 54103,
      "file_path": "airflow-core/src/airflow/jobs/scheduler_job_runner.py",
      "line": 598,
      "side": "RIGHT",
      "diff_hunk": "@@ -490,10 +515,60 @@ def _executable_task_instances_to_queued(self, max_tis: int, session: Session) -\n                 .where(~DM.is_paused)\n                 .where(TI.state == TaskInstanceState.SCHEDULED)\n                 .where(DM.bundle_name.is_not(None))\n+                .join(\n+                    dr_task_concurrency_subquery,\n+                    and_(\n+                        TI.dag_id == dr_task_concurrency_subquery.c.dag_id,\n+                        TI.run_id == dr_task_concurrency_subquery.c.run_id,\n+                    ),\n+                    isouter=True,\n+                )\n+                .where(\n+                    func.coalesce(dr_task_concurrency_subquery.c.task_per_dr_count, 0) < DM.max_active_tasks\n+                )\n                 .options(selectinload(TI.dag_model))\n                 .order_by(-TI.priority_weight, DR.logical_date, TI.map_index)\n             )\n \n+            # Create a subquery with row numbers partitioned by dag_id and run_id.\n+            # Different dags can have the same run_id but\n+            # the dag_id combined with the run_id uniquely identify a run.\n+            ranked_query = (\n+                query.add_columns(\n+                    func.row_number()\n+                    .over(\n+                        partition_by=[TI.dag_id, TI.run_id],\n+                        order_by=[-TI.priority_weight, DR.logical_date, TI.map_index],\n+                    )\n+                    .label(\"row_num\"),\n+                    DM.max_active_tasks.label(\"dr_max_active_tasks\"),\n+                    # Create columns for the order_by checks here for sqlite.\n+                    TI.priority_weight.label(\"priority_weight_for_ordering\"),\n+                    DR.logical_date.label(\"logical_date_for_ordering\"),\n+                    TI.map_index.label(\"map_index_for_ordering\"),\n+                )\n+            ).subquery()\n+\n+            # Select only rows where row_number <= max_active_tasks.\n+            query = (\n+                select(TI)\n+                .select_from(ranked_query)\n+                .join(\n+                    TI,\n+                    (TI.dag_id == ranked_query.c.dag_id)\n+                    & (TI.task_id == ranked_query.c.task_id)\n+                    & (TI.run_id == ranked_query.c.run_id)\n+                    & (TI.map_index == ranked_query.c.map_index),\n+                )\n+                .where(ranked_query.c.row_num <= ranked_query.c.dr_max_active_tasks)\n+                # Add the order_by columns from the ranked query for sqlite.\n+                .order_by(\n+                    -ranked_query.c.priority_weight_for_ordering,\n+                    ranked_query.c.logical_date_for_ordering,\n+                    ranked_query.c.map_index_for_ordering,\n+                )\n+            )",
      "comment": "That's a valid point and an oversight on my behalf. Both of these options exist on the inner query but need to be applied on the outer one.\r\n\r\n```\r\n.options(selectinload(TI.dag_model))\r\n```\r\n\r\ndoesn't have any effect unless applied on the outer query.\r\n\r\nAbout \r\n\r\n```\r\n.with_hint(TI, \"USE INDEX (ti_state)\", dialect_name=\"mysql\")\r\n```\r\n\r\nI'll leave it in the inner and add to the outer as well.",
      "comment_id": 2708777179,
      "user": "xBis7",
      "created_at": "2026-01-20T15:09:37Z",
      "url": "https://github.com/apache/airflow/pull/54103#discussion_r2708777179"
    },
    {
      "repo": "apache/airflow",
      "pr_number": 54103,
      "file_path": "airflow-core/src/airflow/jobs/scheduler_job_runner.py",
      "line": 576,
      "side": "RIGHT",
      "diff_hunk": "@@ -490,10 +515,60 @@ def _executable_task_instances_to_queued(self, max_tis: int, session: Session) -\n                 .where(~DM.is_paused)\n                 .where(TI.state == TaskInstanceState.SCHEDULED)\n                 .where(DM.bundle_name.is_not(None))\n+                .join(\n+                    dr_task_concurrency_subquery,\n+                    and_(\n+                        TI.dag_id == dr_task_concurrency_subquery.c.dag_id,\n+                        TI.run_id == dr_task_concurrency_subquery.c.run_id,\n+                    ),\n+                    isouter=True,\n+                )\n+                .where(\n+                    func.coalesce(dr_task_concurrency_subquery.c.task_per_dr_count, 0) < DM.max_active_tasks\n+                )\n                 .options(selectinload(TI.dag_model))\n                 .order_by(-TI.priority_weight, DR.logical_date, TI.map_index)\n             )\n \n+            # Create a subquery with row numbers partitioned by dag_id and run_id.\n+            # Different dags can have the same run_id but\n+            # the dag_id combined with the run_id uniquely identify a run.\n+            ranked_query = (\n+                query.add_columns(\n+                    func.row_number()\n+                    .over(\n+                        partition_by=[TI.dag_id, TI.run_id],\n+                        order_by=[-TI.priority_weight, DR.logical_date, TI.map_index],\n+                    )\n+                    .label(\"row_num\"),\n+                    DM.max_active_tasks.label(\"dr_max_active_tasks\"),\n+                    # Create columns for the order_by checks here for sqlite.\n+                    TI.priority_weight.label(\"priority_weight_for_ordering\"),\n+                    DR.logical_date.label(\"logical_date_for_ordering\"),\n+                    TI.map_index.label(\"map_index_for_ordering\"),\n+                )\n+            ).subquery()",
      "comment": "You don't have to do it concurrently. If we run the starvation checks first and them apply the `max_active_tasks` limit, that gives us the desired behavior.",
      "comment_id": 2718328310,
      "user": "xBis7",
      "created_at": "2026-01-22T19:33:07Z",
      "url": "https://github.com/apache/airflow/pull/54103#discussion_r2718328310"
    },
    {
      "repo": "apache/airflow",
      "pr_number": 55080,
      "file_path": "airflow-core/src/airflow/api_fastapi/execution_api/versions/__init__.py",
      "line": 35,
      "side": "RIGHT",
      "diff_hunk": "@@ -25,11 +25,14 @@\n     AddDagRunStateFieldAndPreviousEndpoint,\n     AddIncludePriorDatesToGetXComSlice,\n )\n-from airflow.api_fastapi.execution_api.versions.v2025_09_23 import AddDagVersionIdField\n+from airflow.api_fastapi.execution_api.versions.v2025_09_23 import (\n+    AcceptNullXComSetValue,\n+    AddDagVersionIdField,\n+)\n \n bundle = VersionBundle(\n     HeadVersion(),\n-    Version(\"2025-09-23\", AddDagVersionIdField),\n+    Version(\"2025-09-23\", AddDagVersionIdField, AcceptNullXComSetValue),",
      "comment": "We are ok without the migration since technically this was a bug in FastAPI.\r\n\r\nCode:\r\n\r\n```py\r\nfrom fastapi import FastAPI, Body\r\nfrom fastapi.testclient import TestClient\r\nfrom pydantic import JsonValue\r\nfrom typing import Annotated\r\n\r\n\r\napp = FastAPI()\r\n\r\n@app.post('/echo')\r\nasync def echo(body: Annotated[JsonValue, Body()]):\r\n    return {'received': body, 'type': str(type(body))}\r\n\r\nclient = TestClient(app)\r\n\r\nprint('1. Testing json=None (empty body):')\r\ntry:\r\n    response = client.post('/echo', json=None)\r\n    print('  Status:', response.status_code)\r\n    if response.status_code == 200:\r\n        print('  Response:', response.json())\r\n    else:\r\n        print('  Error:', response.text)\r\nexcept Exception as e:\r\n    print('  Exception:', e)\r\n\r\nprint()\r\nprint('2. Testing content=\\\"null\\\" (actual JSON null):')\r\ntry:\r\n    response = client.post('/echo', content='null', headers={'Content-Type': 'application/json'})\r\n    print('  Status:', response.status_code)\r\n    if response.status_code == 200:\r\n        print('  Response:', response.json())\r\n    else:\r\n        print('  Error:', response.text)\r\nexcept Exception as e:\r\n    print('  Exception:', e)\r\n\r\n```\r\n\r\n```\r\n1. Testing json=None (empty body):\r\n  Status: 422\r\n  Error: {\"detail\":[{\"type\":\"missing\",\"loc\":[\"body\"],\"msg\":\"Field required\",\"input\":null}]}\r\n\r\n2. Testing content=\"null\" (actual JSON null):\r\n  Status: 422\r\n  Error: {\"detail\":[{\"type\":\"missing\",\"loc\":[\"body\"],\"msg\":\"Field required\",\"input\":null}]}\r\n\r\n```",
      "comment_id": 2311679326,
      "user": "kaxil",
      "created_at": "2025-08-29T23:49:52Z",
      "url": "https://github.com/apache/airflow/pull/55080#discussion_r2311679326"
    },
    {
      "repo": "apache/airflow",
      "pr_number": 55080,
      "file_path": "airflow-core/src/airflow/api_fastapi/execution_api/versions/v2025_09_23.py",
      "line": 39,
      "side": "RIGHT",
      "diff_hunk": "@@ -28,3 +28,12 @@ class AddDagVersionIdField(VersionChange):\n     description = __doc__\n \n     instructions_to_migrate_to_previous_version = (schema(TaskInstance).field(\"dag_version_id\").didnt_exist,)\n+\n+\n+class AcceptNullXComSetValue(VersionChange):\n+    \"\"\"Allow POST /xcoms/... value body to be JSON null in addition to JSON strings/objects/arrays.\"\"\"\n+\n+    description = __doc__\n+    # This is a backward-compatible relaxation of input validation; older clients are unaffected.\n+    # No response transformation is needed when downgrading.\n+    instructions_to_migrate_to_previous_version = ()",
      "comment": "We can remove this since technically `pydanticJsonValue` supports `None`",
      "comment_id": 2311679666,
      "user": "kaxil",
      "created_at": "2025-08-29T23:50:37Z",
      "url": "https://github.com/apache/airflow/pull/55080#discussion_r2311679666"
    },
    {
      "repo": "apache/airflow",
      "pr_number": 60799,
      "file_path": "airflow-core/src/airflow/serialization/serialized_objects.py",
      "line": 1069,
      "side": "RIGHT",
      "diff_hunk": "@@ -1060,11 +1062,11 @@ def _serialize_node(cls, op: SdkOperator) -> dict[str, Any]:\n                 if attr in serialize_op:\n                     del serialize_op[attr]\n \n-        # Detect if there's a change in python callable name\n+        # Store python_callable_name for change detection.\n+        # exclude_module=True ensures stable names across bundle version changes.\n         python_callable = getattr(op, \"python_callable\", None)\n         if python_callable:\n-            callable_name = qualname(python_callable)\n-            serialize_op[\"python_callable_name\"] = callable_name\n+            serialize_op[\"python_callable_name\"] = qualname(python_callable, exclude_module=True)",
      "comment": "Was just reviewing in consideration to collision between tasks but since its scoped deep in the nested structure, we are good",
      "comment_id": 2706821087,
      "user": "amoghrajesh",
      "created_at": "2026-01-20T05:33:26Z",
      "url": "https://github.com/apache/airflow/pull/60799#discussion_r2706821087"
    },
    {
      "repo": "apache/airflow",
      "pr_number": 60278,
      "file_path": "task-sdk/src/airflow/sdk/execution_time/task_runner.py",
      "line": 783,
      "side": "RIGHT",
      "diff_hunk": "@@ -755,6 +755,46 @@ def parse(what: StartupDetails, log: Logger) -> RuntimeTaskInstance:\n # 3. Shutdown and report status\n \n \n+def _check_bundle_permissions_for_impersonation(\n+    bundle_instance: BaseDagBundle, run_as_user: str, log: structlog.stdlib.BoundLogger\n+) -> None:\n+    \"\"\"\n+    Check if bundle directories have appropriate permissions for user impersonation.\n+\n+    When tasks run as a different user via run_as_user, the bundle directories and\n+    files need to be accessible by that user. This function warns if the permissions\n+    don't appear to allow group access, which is typically needed for impersonation.\n+\n+    :param bundle_instance: The bundle instance to check\n+    :param run_as_user: The user that the task will run as\n+    :param log: Logger instance for warnings\n+    \"\"\"\n+    import stat\n+\n+    try:\n+        bundle_path = bundle_instance.path\n+        if not bundle_path.exists():\n+            return\n+\n+        st = bundle_path.stat()\n+        mode = st.st_mode\n+\n+        # Check if group-readable and group-executable (for directories)\n+        if not (mode & stat.S_IRGRP) or (bundle_path.is_dir() and not (mode & stat.S_IXGRP)):",
      "comment": "Should we just check if we have permissions there? Wile there are some guidelines on how group/ permissions shouldl look like, there are other ways it can be achieved to give those permissions - so I think what we should check here is whether we simply have access and error out if we don't rather than raise warning. In some cases, it might not be desirable to follow those guidelines even if impersonation is used. And in this case users will not be able to get rid of this warning. Instead if we can simply check if we \"actually\" have acess to those dirs with `os.access()` we can produce a nice error message if we don't.",
      "comment_id": 2674397652,
      "user": "potiuk",
      "created_at": "2026-01-09T00:46:41Z",
      "url": "https://github.com/apache/airflow/pull/60278#discussion_r2674397652"
    },
    {
      "repo": "apache/airflow",
      "pr_number": 60052,
      "file_path": "providers/standard/src/airflow/providers/standard/operators/trigger_dagrun.py",
      "line": 197,
      "side": "RIGHT",
      "diff_hunk": "@@ -193,7 +193,8 @@ def __init__(\n         self.skip_when_already_exists = skip_when_already_exists\n         self.fail_when_dag_is_paused = fail_when_dag_is_paused\n         self.openlineage_inject_parent_info = openlineage_inject_parent_info\n-        self.deferrable = deferrable\n+        # deferrable only makes sense when wait_for_completion=True\n+        self.deferrable = deferrable and wait_for_completion",
      "comment": "If it only makes sense when `wait_for_completion = True`:\r\n1. It should raise an exception when it's not (inc. reasoning + suggestion for fixing actions) \r\n2. The exception should be tested\r\n3. It should be documented in the docstring (for both parameters)",
      "comment_id": 2658852992,
      "user": "shahar1",
      "created_at": "2026-01-03T10:36:12Z",
      "url": "https://github.com/apache/airflow/pull/60052#discussion_r2658852992"
    },
    {
      "repo": "apache/airflow",
      "pr_number": 60052,
      "file_path": "providers/standard/src/airflow/providers/standard/operators/trigger_dagrun.py",
      "line": 197,
      "side": "RIGHT",
      "diff_hunk": "@@ -193,7 +193,8 @@ def __init__(\n         self.skip_when_already_exists = skip_when_already_exists\n         self.fail_when_dag_is_paused = fail_when_dag_is_paused\n         self.openlineage_inject_parent_info = openlineage_inject_parent_info\n-        self.deferrable = deferrable\n+        # deferrable only makes sense when wait_for_completion=True\n+        self.deferrable = deferrable and wait_for_completion",
      "comment": "@shahar1 Thanks for your feedback but I'm not sure exactly what you mean in your first point. \n\nCould you elaborate?",
      "comment_id": 2659750267,
      "user": "nathadfield",
      "created_at": "2026-01-04T15:43:26Z",
      "url": "https://github.com/apache/airflow/pull/60052#discussion_r2659750267"
    },
    {
      "repo": "apache/airflow",
      "pr_number": 60052,
      "file_path": "providers/standard/src/airflow/providers/standard/operators/trigger_dagrun.py",
      "line": 197,
      "side": "RIGHT",
      "diff_hunk": "@@ -193,7 +193,8 @@ def __init__(\n         self.skip_when_already_exists = skip_when_already_exists\n         self.fail_when_dag_is_paused = fail_when_dag_is_paused\n         self.openlineage_inject_parent_info = openlineage_inject_parent_info\n-        self.deferrable = deferrable\n+        # deferrable only makes sense when wait_for_completion=True\n+        self.deferrable = deferrable and wait_for_completion",
      "comment": "@shahar1 The problem is that users can have existing DAGs with `deferrable=True` and `wait_for_completion=False` (often due to these options being set by `default_args` or cluster policies). These tasks now get stuck in `DEFERRED` state - this is the bug I was attempting to fix.\r\n\r\nRaising an exception would prevent future misconfigurations (good), but it would break existing DAGs that have this invalid configuration. For users who set `deferrable=True` at a DAG/cluster policy level in their config, every TriggerDagRunOperator instance would need explicit `deferrable=False` (since `wait_for_completion` defaults to `False`). Since these DAGs are already broken (tasks stuck), we're choosing to fix them rather than fail them.\r\n\r\nThe Trade-off:\r\n  - Your approach: Explicit validation, but breaking change requiring explicit `deferrable=False` \r\n  - My approach: Silent fix, non-breaking, but less explicit\r\n\r\nWould a deprecation warning (now) \u2192 exception (next major version) be acceptable? This fixes existing broken DAGs while still moving toward explicit validation.",
      "comment_id": 2660786075,
      "user": "nathadfield",
      "created_at": "2026-01-05T09:14:32Z",
      "url": "https://github.com/apache/airflow/pull/60052#discussion_r2660786075"
    },
    {
      "repo": "apache/airflow",
      "pr_number": 60052,
      "file_path": "providers/standard/src/airflow/providers/standard/operators/trigger_dagrun.py",
      "line": 197,
      "side": "RIGHT",
      "diff_hunk": "@@ -193,7 +193,8 @@ def __init__(\n         self.skip_when_already_exists = skip_when_already_exists\n         self.fail_when_dag_is_paused = fail_when_dag_is_paused\n         self.openlineage_inject_parent_info = openlineage_inject_parent_info\n-        self.deferrable = deferrable\n+        # deferrable only makes sense when wait_for_completion=True\n+        self.deferrable = deferrable and wait_for_completion",
      "comment": "Looking again, I think the actual issue is in `task_runner.py` as it seems to [check](https://github.com/apache/airflow/blob/main/task-sdk/src/airflow/sdk/execution_time/task_runner.py#L1292-L1310) `deferrable` BEFORE checking `wait_for_completion`.  I'll fix that instead.",
      "comment_id": 2660871387,
      "user": "nathadfield",
      "created_at": "2026-01-05T09:39:48Z",
      "url": "https://github.com/apache/airflow/pull/60052#discussion_r2660871387"
    },
    {
      "repo": "apache/airflow",
      "pr_number": 60937,
      "file_path": "airflow-core/src/airflow/models/serialized_dag.py",
      "line": 530,
      "side": "RIGHT",
      "diff_hunk": "@@ -520,7 +520,16 @@ def write_dag(\n             log.debug(\"Serialized DAG (%s) is unchanged. Skipping writing to DB\", dag.dag_id)\n             return False\n \n-        if dag_version and not dag_version.task_instances:\n+        has_task_instances = False\n+        if dag_version:\n+            has_task_instances = (\n+                session.scalar(\n+                    select(literal(True)).where(exists().where(TaskInstance.dag_version_id == dag_version.id))\n+                )\n+                or False\n+            )",
      "comment": "```suggestion\n            has_task_instances = session.scalar(\n                select(exists().where(TaskInstance.dag_version_id == dag_version.id))\n            )\n```",
      "comment_id": 2716789923,
      "user": "ephraimbuddy",
      "created_at": "2026-01-22T12:52:05Z",
      "url": "https://github.com/apache/airflow/pull/60937#discussion_r2716789923"
    },
    {
      "repo": "apache/airflow",
      "pr_number": 60937,
      "file_path": "airflow-core/src/airflow/models/serialized_dag.py",
      "line": 526,
      "side": "RIGHT",
      "diff_hunk": "@@ -520,7 +520,13 @@ def write_dag(\n             log.debug(\"Serialized DAG (%s) is unchanged. Skipping writing to DB\", dag.dag_id)\n             return False\n \n-        if dag_version and not dag_version.task_instances:\n+        has_task_instances: bool = False\n+        if dag_version:\n+            has_task_instances = bool(\n+                session.scalar(select(exists().where(TaskInstance.dag_version_id == dag_version.id)))",
      "comment": "The `bool()` wrapper is unnecessary here. `session.scalar(select(exists()...))` already returns a boolean value directly from the database, making the explicit conversion redundant.\n```suggestion\n            has_task_instances = session.scalar(\n                select(exists().where(TaskInstance.dag_version_id == dag_version.id))\n```",
      "comment_id": 2718558755,
      "user": "Copilot",
      "created_at": "2026-01-22T20:40:35Z",
      "url": "https://github.com/apache/airflow/pull/60937#discussion_r2718558755"
    },
    {
      "repo": "apache/airflow",
      "pr_number": 56422,
      "file_path": "airflow-core/src/airflow/models/serialized_dag.py",
      "line": 431,
      "side": "RIGHT",
      "diff_hunk": "@@ -427,22 +427,24 @@ def write_dag(\n             # the serialized dag, the dag_version and the dag_code instead of a new version\n             # if the dag_version is not associated with any task instances\n             latest_ser_dag = cls.get(dag.dag_id, session=session)\n-            if TYPE_CHECKING:\n-                assert latest_ser_dag is not None\n-            # Update the serialized DAG with the new_serialized_dag\n-            latest_ser_dag._data = new_serialized_dag._data\n-            latest_ser_dag._data_compressed = new_serialized_dag._data_compressed\n-            latest_ser_dag.dag_hash = new_serialized_dag.dag_hash\n-            session.merge(latest_ser_dag)\n-            # The dag_version and dag_code may not have changed, still we should\n-            # do the below actions:\n-            # Update the latest dag version\n-            dag_version.bundle_name = bundle_name\n-            dag_version.bundle_version = bundle_version\n-            session.merge(dag_version)\n-            # Update the latest DagCode\n-            DagCode.update_source_code(dag_id=dag.dag_id, fileloc=dag.fileloc, session=session)\n-            return True\n+            \n+            if latest_ser_dag:  ",
      "comment": "If there's a dag_version then we should have serdag. Can you check if dag_version.serialized_dag would work? Should work, or we can improve the DagVersion.get_latest_version to load the serdag when getting the latest version.\r\nSomething like this:\r\n`latest_ser_dag = dag_version.serialized_dag`",
      "comment_id": 2417391159,
      "user": "ephraimbuddy",
      "created_at": "2025-10-09T16:56:36Z",
      "url": "https://github.com/apache/airflow/pull/56422#discussion_r2417391159"
    },
    {
      "repo": "apache/airflow",
      "pr_number": 56422,
      "file_path": "airflow-core/src/airflow/models/serialized_dag.py",
      "line": 431,
      "side": "RIGHT",
      "diff_hunk": "@@ -427,22 +427,24 @@ def write_dag(\n             # the serialized dag, the dag_version and the dag_code instead of a new version\n             # if the dag_version is not associated with any task instances\n             latest_ser_dag = cls.get(dag.dag_id, session=session)\n-            if TYPE_CHECKING:\n-                assert latest_ser_dag is not None\n-            # Update the serialized DAG with the new_serialized_dag\n-            latest_ser_dag._data = new_serialized_dag._data\n-            latest_ser_dag._data_compressed = new_serialized_dag._data_compressed\n-            latest_ser_dag.dag_hash = new_serialized_dag.dag_hash\n-            session.merge(latest_ser_dag)\n-            # The dag_version and dag_code may not have changed, still we should\n-            # do the below actions:\n-            # Update the latest dag version\n-            dag_version.bundle_name = bundle_name\n-            dag_version.bundle_version = bundle_version\n-            session.merge(dag_version)\n-            # Update the latest DagCode\n-            DagCode.update_source_code(dag_id=dag.dag_id, fileloc=dag.fileloc, session=session)\n-            return True\n+            \n+            if latest_ser_dag:  ",
      "comment": "Hi @ephraimbuddy,\r\n\r\nThanks for the suggestion!  I updated the code to use latest_ser_dag = dag_version.serialized_dag instead of cls.get(...).\r\nNull checks are still in place to ensure safety, and dynamic DAG updates now work reliably using the dag_version approach.\r\n\r\nThe PR has been updated with this change.",
      "comment_id": 2417669798,
      "user": "anshuksi282-ksolves",
      "created_at": "2025-10-09T18:42:12Z",
      "url": "https://github.com/apache/airflow/pull/56422#discussion_r2417669798"
    },
    {
      "repo": "apache/airflow",
      "pr_number": 56422,
      "file_path": "airflow-core/src/airflow/models/serialized_dag.py",
      "line": 443,
      "side": "RIGHT",
      "diff_hunk": "@@ -423,26 +423,29 @@ def write_dag(\n             return False\n \n         if dag_version and not dag_version.task_instances:\n-            # This is for dynamic DAGs that the hashes changes often. We should update\n-            # the serialized dag, the dag_version and the dag_code instead of a new version\n-            # if the dag_version is not associated with any task instances\n-            latest_ser_dag = cls.get(dag.dag_id, session=session)\n-            if TYPE_CHECKING:\n-                assert latest_ser_dag is not None\n-            # Update the serialized DAG with the new_serialized_dag\n-            latest_ser_dag._data = new_serialized_dag._data\n-            latest_ser_dag._data_compressed = new_serialized_dag._data_compressed\n-            latest_ser_dag.dag_hash = new_serialized_dag.dag_hash\n-            session.merge(latest_ser_dag)\n-            # The dag_version and dag_code may not have changed, still we should\n-            # do the below actions:\n-            # Update the latest dag version\n-            dag_version.bundle_name = bundle_name\n-            dag_version.bundle_version = bundle_version\n-            session.merge(dag_version)\n-            # Update the latest DagCode\n-            DagCode.update_source_code(dag_id=dag.dag_id, fileloc=dag.fileloc, session=session)\n-            return True\n+            # This is for dynamic DAGs whose hashes change often. We should update\n+            # the serialized DAG, the dag_version, and the dag_code instead of creating\n+            # a new version if the dag_version has no associated task instances.\n+\n+            latest_ser_dag = dag_version.serialized_dag  # Use serialized_dag directly from dag_version\n+\n+            if latest_ser_dag:",
      "comment": "So what happens if not latest_ser_dag? We continue and right new versions?",
      "comment_id": 2431756052,
      "user": "ephraimbuddy",
      "created_at": "2025-10-15T09:08:04Z",
      "url": "https://github.com/apache/airflow/pull/56422#discussion_r2431756052"
    },
    {
      "repo": "apache/airflow",
      "pr_number": 56422,
      "file_path": "airflow-core/src/airflow/models/serialized_dag.py",
      "line": 443,
      "side": "RIGHT",
      "diff_hunk": "@@ -423,26 +423,29 @@ def write_dag(\n             return False\n \n         if dag_version and not dag_version.task_instances:\n-            # This is for dynamic DAGs that the hashes changes often. We should update\n-            # the serialized dag, the dag_version and the dag_code instead of a new version\n-            # if the dag_version is not associated with any task instances\n-            latest_ser_dag = cls.get(dag.dag_id, session=session)\n-            if TYPE_CHECKING:\n-                assert latest_ser_dag is not None\n-            # Update the serialized DAG with the new_serialized_dag\n-            latest_ser_dag._data = new_serialized_dag._data\n-            latest_ser_dag._data_compressed = new_serialized_dag._data_compressed\n-            latest_ser_dag.dag_hash = new_serialized_dag.dag_hash\n-            session.merge(latest_ser_dag)\n-            # The dag_version and dag_code may not have changed, still we should\n-            # do the below actions:\n-            # Update the latest dag version\n-            dag_version.bundle_name = bundle_name\n-            dag_version.bundle_version = bundle_version\n-            session.merge(dag_version)\n-            # Update the latest DagCode\n-            DagCode.update_source_code(dag_id=dag.dag_id, fileloc=dag.fileloc, session=session)\n-            return True\n+            # This is for dynamic DAGs whose hashes change often. We should update\n+            # the serialized DAG, the dag_version, and the dag_code instead of creating\n+            # a new version if the dag_version has no associated task instances.\n+\n+            latest_ser_dag = dag_version.serialized_dag  # Use serialized_dag directly from dag_version\n+\n+            if latest_ser_dag:",
      "comment": "Yes, if latest_ser_dag is None, we skip the update and a new SerializedDagModel will be created below. No AttributeError occurs, and the DAG serialization remains safe for dynamic DAGs.",
      "comment_id": 2431837379,
      "user": "anshuksi282-ksolves",
      "created_at": "2025-10-15T09:29:47Z",
      "url": "https://github.com/apache/airflow/pull/56422#discussion_r2431837379"
    },
    {
      "repo": "apache/airflow",
      "pr_number": 56422,
      "file_path": "airflow-core/src/airflow/models/serialized_dag.py",
      "line": 443,
      "side": "RIGHT",
      "diff_hunk": "@@ -423,26 +423,29 @@ def write_dag(\n             return False\n \n         if dag_version and not dag_version.task_instances:\n-            # This is for dynamic DAGs that the hashes changes often. We should update\n-            # the serialized dag, the dag_version and the dag_code instead of a new version\n-            # if the dag_version is not associated with any task instances\n-            latest_ser_dag = cls.get(dag.dag_id, session=session)\n-            if TYPE_CHECKING:\n-                assert latest_ser_dag is not None\n-            # Update the serialized DAG with the new_serialized_dag\n-            latest_ser_dag._data = new_serialized_dag._data\n-            latest_ser_dag._data_compressed = new_serialized_dag._data_compressed\n-            latest_ser_dag.dag_hash = new_serialized_dag.dag_hash\n-            session.merge(latest_ser_dag)\n-            # The dag_version and dag_code may not have changed, still we should\n-            # do the below actions:\n-            # Update the latest dag version\n-            dag_version.bundle_name = bundle_name\n-            dag_version.bundle_version = bundle_version\n-            session.merge(dag_version)\n-            # Update the latest DagCode\n-            DagCode.update_source_code(dag_id=dag.dag_id, fileloc=dag.fileloc, session=session)\n-            return True\n+            # This is for dynamic DAGs whose hashes change often. We should update\n+            # the serialized DAG, the dag_version, and the dag_code instead of creating\n+            # a new version if the dag_version has no associated task instances.\n+\n+            latest_ser_dag = dag_version.serialized_dag  # Use serialized_dag directly from dag_version\n+\n+            if latest_ser_dag:",
      "comment": "If we have `dag_version`, then there must be a serialized_dag. We need to make sure that latest_ser_dag is never none. You should make sure that `serialized_dag` is loaded when `DagVersion.get_latest_version` is called. So also update that method",
      "comment_id": 2432334084,
      "user": "ephraimbuddy",
      "created_at": "2025-10-15T12:15:50Z",
      "url": "https://github.com/apache/airflow/pull/56422#discussion_r2432334084"
    },
    {
      "repo": "apache/airflow",
      "pr_number": 56422,
      "file_path": "airflow-core/src/airflow/models/serialized_dag.py",
      "line": 443,
      "side": "RIGHT",
      "diff_hunk": "@@ -423,26 +423,29 @@ def write_dag(\n             return False\n \n         if dag_version and not dag_version.task_instances:\n-            # This is for dynamic DAGs that the hashes changes often. We should update\n-            # the serialized dag, the dag_version and the dag_code instead of a new version\n-            # if the dag_version is not associated with any task instances\n-            latest_ser_dag = cls.get(dag.dag_id, session=session)\n-            if TYPE_CHECKING:\n-                assert latest_ser_dag is not None\n-            # Update the serialized DAG with the new_serialized_dag\n-            latest_ser_dag._data = new_serialized_dag._data\n-            latest_ser_dag._data_compressed = new_serialized_dag._data_compressed\n-            latest_ser_dag.dag_hash = new_serialized_dag.dag_hash\n-            session.merge(latest_ser_dag)\n-            # The dag_version and dag_code may not have changed, still we should\n-            # do the below actions:\n-            # Update the latest dag version\n-            dag_version.bundle_name = bundle_name\n-            dag_version.bundle_version = bundle_version\n-            session.merge(dag_version)\n-            # Update the latest DagCode\n-            DagCode.update_source_code(dag_id=dag.dag_id, fileloc=dag.fileloc, session=session)\n-            return True\n+            # This is for dynamic DAGs whose hashes change often. We should update\n+            # the serialized DAG, the dag_version, and the dag_code instead of creating\n+            # a new version if the dag_version has no associated task instances.\n+\n+            latest_ser_dag = dag_version.serialized_dag  # Use serialized_dag directly from dag_version\n+\n+            if latest_ser_dag:",
      "comment": "Thanks \u2014 I made `get_latest_version` load the serialized DAG when requested and updated `write_dag` to use `dag_version.serialized_dag `directly. I kept the `TYPE_CHECKING` assert and a runtime `if latest_ser_dag: `guard. This fixes the NoneType race and avoids extra DB joins.",
      "comment_id": 2432776317,
      "user": "anshuksi282-ksolves",
      "created_at": "2025-10-15T14:24:16Z",
      "url": "https://github.com/apache/airflow/pull/56422#discussion_r2432776317"
    },
    {
      "repo": "apache/airflow",
      "pr_number": 56422,
      "file_path": "airflow-core/src/airflow/models/serialized_dag.py",
      "line": 415,
      "side": "RIGHT",
      "diff_hunk": "@@ -412,7 +412,7 @@ def write_dag(\n         serialized_dag_hash = session.scalars(\n             select(cls.dag_hash).where(cls.dag_id == dag.dag_id).order_by(cls.created_at.desc())\n         ).first()\n-        dag_version = DagVersion.get_latest_version(dag.dag_id, session=session)\n+        dag_version = DagVersion.get_latest_version(dag.dag_id, session=session, load_dag_model=True)",
      "comment": "We could have a different arg like `load_serialized_dag` instead of using `load_dag_model`",
      "comment_id": 2433021751,
      "user": "ephraimbuddy",
      "created_at": "2025-10-15T15:26:38Z",
      "url": "https://github.com/apache/airflow/pull/56422#discussion_r2433021751"
    },
    {
      "repo": "apache/airflow",
      "pr_number": 56422,
      "file_path": "airflow-core/src/airflow/models/serialized_dag.py",
      "line": 415,
      "side": "RIGHT",
      "diff_hunk": "@@ -412,7 +412,7 @@ def write_dag(\n         serialized_dag_hash = session.scalars(\n             select(cls.dag_hash).where(cls.dag_id == dag.dag_id).order_by(cls.created_at.desc())\n         ).first()\n-        dag_version = DagVersion.get_latest_version(dag.dag_id, session=session)\n+        dag_version = DagVersion.get_latest_version(dag.dag_id, session=session, load_dag_model=True)",
      "comment": "Thanks, that makes sense. For now, I reused the existing load_dag_model flag since it already covers eager-loading of serialized_dag.\r\nIf you prefer, I can rename it to load_serialized_dag for better clarity \u2014 let me know what you think.",
      "comment_id": 2433094186,
      "user": "anshuksi282-ksolves",
      "created_at": "2025-10-15T15:45:07Z",
      "url": "https://github.com/apache/airflow/pull/56422#discussion_r2433094186"
    },
    {
      "repo": "apache/airflow",
      "pr_number": 56422,
      "file_path": "airflow-core/src/airflow/models/serialized_dag.py",
      "line": 415,
      "side": "RIGHT",
      "diff_hunk": "@@ -412,7 +412,7 @@ def write_dag(\n         serialized_dag_hash = session.scalars(\n             select(cls.dag_hash).where(cls.dag_id == dag.dag_id).order_by(cls.created_at.desc())\n         ).first()\n-        dag_version = DagVersion.get_latest_version(dag.dag_id, session=session)\n+        dag_version = DagVersion.get_latest_version(dag.dag_id, session=session, load_dag_model=True)",
      "comment": "We have to use a different arg. `load_dag_model` is used in other places where we don't want to load serialized dag. With with you have, we will now load serialized dag whenever load_dag_model is set whereas what we want is to only load dag model and never serialized dag. So introduce another arg for loading only the serialized dag",
      "comment_id": 2434943034,
      "user": "ephraimbuddy",
      "created_at": "2025-10-16T07:56:58Z",
      "url": "https://github.com/apache/airflow/pull/56422#discussion_r2434943034"
    },
    {
      "repo": "apache/airflow",
      "pr_number": 56422,
      "file_path": "airflow-core/src/airflow/models/serialized_dag.py",
      "line": 415,
      "side": "RIGHT",
      "diff_hunk": "@@ -412,7 +412,7 @@ def write_dag(\n         serialized_dag_hash = session.scalars(\n             select(cls.dag_hash).where(cls.dag_id == dag.dag_id).order_by(cls.created_at.desc())\n         ).first()\n-        dag_version = DagVersion.get_latest_version(dag.dag_id, session=session)\n+        dag_version = DagVersion.get_latest_version(dag.dag_id, session=session, load_dag_model=True)",
      "comment": "Yes, exactly \u2014 that\u2019s why I introduced a separate argument `load_serialized_dag`. This way, `load_dag_model `continues to only load the `DagModel`, and we can explicitly load `SerializedDagModel` when needed without affecting other places where `load_dag_model `is used. This avoids accidentally eager-loading the serialized DAG in places where it\u2019s not required.",
      "comment_id": 2435186865,
      "user": "anshuksi282-ksolves",
      "created_at": "2025-10-16T09:19:11Z",
      "url": "https://github.com/apache/airflow/pull/56422#discussion_r2435186865"
    },
    {
      "repo": "apache/airflow",
      "pr_number": 56422,
      "file_path": "airflow-core/src/airflow/models/serialized_dag.py",
      "line": 415,
      "side": "RIGHT",
      "diff_hunk": "@@ -412,7 +412,7 @@ def write_dag(\n         serialized_dag_hash = session.scalars(\n             select(cls.dag_hash).where(cls.dag_id == dag.dag_id).order_by(cls.created_at.desc())\n         ).first()\n-        dag_version = DagVersion.get_latest_version(dag.dag_id, session=session, load_dag_model=True)\n+        dag_version = DagVersion.get_latest_version(dag.dag_id, session=session, load_serialized_dag=True)",
      "comment": "I thought about this for a while but can't help thinking the query is not enough. So, I think we should go with a direct query here like this:\r\n```python\r\nsession.query(DagVersion).where(DagVersion.dag_id == dag.dag_id,\r\nDagVersion.bundle_version == bundle_version, DagVersion.bundle_name==bundle_name).\r\noptions(joinedload(DagVersion.task_instances)).options(joinedload(DagVersion.serialized_dag).\r\norder_by(DagVersion.created_at.desc()).limit(1)\r\n```\r\nand remove line 420 below where we do `and dag_version.bundle_name == bundle_name`\r\n\r\nI think this is better as this is a special need that we don't do elsewhere. Apologies for not thinking it through all these while",
      "comment_id": 2435676801,
      "user": "ephraimbuddy",
      "created_at": "2025-10-16T12:12:59Z",
      "url": "https://github.com/apache/airflow/pull/56422#discussion_r2435676801"
    },
    {
      "repo": "apache/airflow",
      "pr_number": 56422,
      "file_path": "airflow-core/src/airflow/models/serialized_dag.py",
      "line": 415,
      "side": "RIGHT",
      "diff_hunk": "@@ -412,7 +412,7 @@ def write_dag(\n         serialized_dag_hash = session.scalars(\n             select(cls.dag_hash).where(cls.dag_id == dag.dag_id).order_by(cls.created_at.desc())\n         ).first()\n-        dag_version = DagVersion.get_latest_version(dag.dag_id, session=session, load_dag_model=True)\n+        dag_version = DagVersion.get_latest_version(dag.dag_id, session=session, load_serialized_dag=True)",
      "comment": "Thanks for sharing your thoughts! I see where you\u2019re coming from. Just to clarify, using `session.query(...).limit(1)` is actually the legacy `SQLAlchemy 1.x style`. In `Airflow 3.x / SQLAlchemy 2.x,` the recommended and more consistent approach is:\r\n\r\n```python\r\ndag_version = session.scalars(\r\n    select(DagVersion)\r\n    .where(\r\n        DagVersion.dag_id == dag.dag_id,\r\n        DagVersion.bundle_version == bundle_version,\r\n        DagVersion.bundle_name == bundle_name,\r\n    )\r\n    .options(joinedload(DagVersion.task_instances))\r\n    .options(joinedload(DagVersion.serialized_dag))\r\n    .order_by(DagVersion.created_at.desc())\r\n).first()\r\n\r\n```\r\n\r\nIt\u2019s fully compatible with the modern 2.x style and avoids potential CI/check failures that come from using legacy `query()` calls.\r\n\r\nI understand this is a special case, but I\u2019d recommend keeping the 2.x style for consistency across the codebase. If needed, we can tweak the `where` conditions to cover your use case without switching to the legacy API.",
      "comment_id": 2436023111,
      "user": "anshuksi282-ksolves",
      "created_at": "2025-10-16T13:55:42Z",
      "url": "https://github.com/apache/airflow/pull/56422#discussion_r2436023111"
    },
    {
      "repo": "apache/airflow",
      "pr_number": 56422,
      "file_path": "airflow-core/src/airflow/models/serialized_dag.py",
      "line": 427,
      "side": "RIGHT",
      "diff_hunk": "@@ -412,13 +412,19 @@ def write_dag(\n         serialized_dag_hash = session.scalars(\n             select(cls.dag_hash).where(cls.dag_id == dag.dag_id).order_by(cls.created_at.desc())\n         ).first()\n-        dag_version = DagVersion.get_latest_version(dag.dag_id, session=session, load_serialized_dag=True)\n+        dag_version = session.scalars(\n+            select(DagVersion)\n+            .where(\n+                DagVersion.dag_id == dag.dag_id,\n+                DagVersion.bundle_version == bundle_version,\n+                DagVersion.bundle_name == bundle_name,\n+            )\n+            .options(joinedload(DagVersion.task_instances))\n+            .options(joinedload(DagVersion.serialized_dag))\n+            .order_by(DagVersion.created_at.desc())\n+        ).first()",
      "comment": "```suggestion\r\n        ).limit(1)\r\n```\r\nlimit is actually faster",
      "comment_id": 2436053248,
      "user": "ephraimbuddy",
      "created_at": "2025-10-16T14:03:05Z",
      "url": "https://github.com/apache/airflow/pull/56422#discussion_r2436053248"
    },
    {
      "repo": "apache/airflow",
      "pr_number": 56422,
      "file_path": "airflow-core/src/airflow/models/serialized_dag.py",
      "line": 427,
      "side": "RIGHT",
      "diff_hunk": "@@ -412,13 +412,19 @@ def write_dag(\n         serialized_dag_hash = session.scalars(\n             select(cls.dag_hash).where(cls.dag_id == dag.dag_id).order_by(cls.created_at.desc())\n         ).first()\n-        dag_version = DagVersion.get_latest_version(dag.dag_id, session=session, load_serialized_dag=True)\n+        dag_version = session.scalars(\n+            select(DagVersion)\n+            .where(\n+                DagVersion.dag_id == dag.dag_id,\n+                DagVersion.bundle_version == bundle_version,\n+                DagVersion.bundle_name == bundle_name,\n+            )\n+            .options(joinedload(DagVersion.task_instances))\n+            .options(joinedload(DagVersion.serialized_dag))\n+            .order_by(DagVersion.created_at.desc())\n+        ).first()",
      "comment": "Thanks for the suggestion! I\u2019ll rebase my branch onto origin/main and resolve the conflicts, then update the query as you recommended.",
      "comment_id": 2436148185,
      "user": "anshuksi282-ksolves",
      "created_at": "2025-10-16T14:19:30Z",
      "url": "https://github.com/apache/airflow/pull/56422#discussion_r2436148185"
    },
    {
      "repo": "apache/airflow",
      "pr_number": 56422,
      "file_path": "airflow-core/src/airflow/models/serialized_dag.py",
      "line": 421,
      "side": "RIGHT",
      "diff_hunk": "@@ -414,7 +414,14 @@ def write_dag(\n         serialized_dag_hash = session.scalars(\n             select(cls.dag_hash).where(cls.dag_id == dag.dag_id).order_by(cls.created_at.desc())\n         ).first()\n-        dag_version = DagVersion.get_latest_version(dag.dag_id, session=session)\n+        dag_version = session.scalar(\n+            select(DagVersion)\n+            .where(DagVersion.dag_id == dag.dag_id)\n+            .options(joinedload(DagVersion.task_instances))\n+            .options(joinedload(DagVersion.serialized_dag))",
      "comment": "This is wrong -- why are we loading the entire serialized dag again before checking if the hash has changed or not.\n\ncc @ephraimbuddy ",
      "comment_id": 2476088258,
      "user": "kaxil",
      "created_at": "2025-10-30T00:39:33Z",
      "url": "https://github.com/apache/airflow/pull/56422#discussion_r2476088258"
    },
    {
      "repo": "apache/airflow",
      "pr_number": 56422,
      "file_path": "airflow-core/src/airflow/models/serialized_dag.py",
      "line": 421,
      "side": "RIGHT",
      "diff_hunk": "@@ -414,7 +414,14 @@ def write_dag(\n         serialized_dag_hash = session.scalars(\n             select(cls.dag_hash).where(cls.dag_id == dag.dag_id).order_by(cls.created_at.desc())\n         ).first()\n-        dag_version = DagVersion.get_latest_version(dag.dag_id, session=session)\n+        dag_version = session.scalar(\n+            select(DagVersion)\n+            .where(DagVersion.dag_id == dag.dag_id)\n+            .options(joinedload(DagVersion.task_instances))\n+            .options(joinedload(DagVersion.serialized_dag))",
      "comment": "Yeah, though not fully wrong. Line 438 was supposed to use the serdag.\n\n`latest_ser_dag = dag_version.serialized_dag`\n\nbut omitted. I will open a PR to address it",
      "comment_id": 2476728037,
      "user": "ephraimbuddy",
      "created_at": "2025-10-30T07:48:02Z",
      "url": "https://github.com/apache/airflow/pull/56422#discussion_r2476728037"
    },
    {
      "repo": "apache/airflow",
      "pr_number": 60124,
      "file_path": "airflow-core/src/airflow/dag_processing/manager.py",
      "line": 979,
      "side": "RIGHT",
      "diff_hunk": "@@ -963,13 +961,22 @@ def _start_new_processes(self):\n             self._processors[file] = processor\n             Stats.gauge(\"dag_processing.file_path_queue_size\", len(self._file_queue))\n \n-    def add_files_to_queue(self, known_files: dict[str, set[DagFileInfo]]):\n+    def _add_new_files_to_queue(self, known_files: dict[str, set[DagFileInfo]]):\n+        \"\"\"\n+        Add new files to the front of the queue.\n+\n+        A \"new\" file is a file that has not been processed yet and is not currently being processed.\n+        \"\"\"\n+        new_files = []\n         for files in known_files.values():\n             for file in files:\n-                if file not in self._file_stats:  # todo: store stats by bundle also?\n-                    # We found new file after refreshing dir. add to parsing queue at start\n-                    self.log.info(\"Adding new file %s to parsing queue\", file)\n-                    self._file_queue.appendleft(file)\n+                # todo: store stats by bundle also?\n+                if file not in self._file_stats and file not in self._processors:\n+                    new_files.append(file)\n+\n+        if new_files:\n+            self.log.info(\"Adding %d new files to the front of the queue\", len(new_files))\n+            self._add_files_to_queue(new_files, True)",
      "comment": "Should we emit metrics even when no new files are found, to track that the check happened?",
      "comment_id": 2665045804,
      "user": "kaxil",
      "created_at": "2026-01-06T14:07:45Z",
      "url": "https://github.com/apache/airflow/pull/60124#discussion_r2665045804"
    },
    {
      "repo": "apache/airflow",
      "pr_number": 60124,
      "file_path": "airflow-core/src/airflow/dag_processing/manager.py",
      "line": 979,
      "side": "RIGHT",
      "diff_hunk": "@@ -963,13 +961,22 @@ def _start_new_processes(self):\n             self._processors[file] = processor\n             Stats.gauge(\"dag_processing.file_path_queue_size\", len(self._file_queue))\n \n-    def add_files_to_queue(self, known_files: dict[str, set[DagFileInfo]]):\n+    def _add_new_files_to_queue(self, known_files: dict[str, set[DagFileInfo]]):\n+        \"\"\"\n+        Add new files to the front of the queue.\n+\n+        A \"new\" file is a file that has not been processed yet and is not currently being processed.\n+        \"\"\"\n+        new_files = []\n         for files in known_files.values():\n             for file in files:\n-                if file not in self._file_stats:  # todo: store stats by bundle also?\n-                    # We found new file after refreshing dir. add to parsing queue at start\n-                    self.log.info(\"Adding new file %s to parsing queue\", file)\n-                    self._file_queue.appendleft(file)\n+                # todo: store stats by bundle also?\n+                if file not in self._file_stats and file not in self._processors:\n+                    new_files.append(file)\n+\n+        if new_files:\n+            self.log.info(\"Adding %d new files to the front of the queue\", len(new_files))\n+            self._add_files_to_queue(new_files, True)",
      "comment": "I don't think we need to, as [we emit it as we start processes](https://github.com/apache/airflow/blob/5995696051833ac9e0ec37c0c185aa582ed3c393/airflow-core/src/airflow/dag_processing/manager.py#L964) already, so it should already be up to date.",
      "comment_id": 2665139202,
      "user": "jedcunningham",
      "created_at": "2026-01-06T14:36:42Z",
      "url": "https://github.com/apache/airflow/pull/60124#discussion_r2665139202"
    },
    {
      "repo": "apache/airflow",
      "pr_number": 60968,
      "file_path": "task-sdk/tests/task_sdk/test_lineage.py",
      "line": 25,
      "side": "RIGHT",
      "diff_hunk": "@@ -21,18 +21,16 @@\n \n import pytest\n \n-from airflow import plugins_manager\n-from airflow.lineage import hook\n-from airflow.lineage.hook import (\n+from airflow.sdk import BaseHook, plugins_manager\n+from airflow.sdk.definitions.asset import Asset",
      "comment": "```suggestion\nfrom airflow.sdk import Asset, BaseHook, plugins_manager\n```",
      "comment_id": 2721063080,
      "user": "uranusjr",
      "created_at": "2026-01-23T12:46:44Z",
      "url": "https://github.com/apache/airflow/pull/60968#discussion_r2721063080"
    },
    {
      "repo": "apache/airflow",
      "pr_number": 60968,
      "file_path": "providers/openlineage/src/airflow/providers/openlineage/plugins/openlineage.py",
      "line": 24,
      "side": "RIGHT",
      "diff_hunk": "@@ -21,7 +21,7 @@\n \n # Conditional imports - only load expensive dependencies when plugin is enabled\n if not conf.is_disabled():\n-    from airflow.lineage.hook import HookLineageReader\n+    from airflow.providers.common.compat.sdk import HookLineageReader",
      "comment": "We should have `# use next version` for common-compat provider in pyproject.toml",
      "comment_id": 2727421911,
      "user": "potiuk",
      "created_at": "2026-01-26T12:29:24Z",
      "url": "https://github.com/apache/airflow/pull/60968#discussion_r2727421911"
    },
    {
      "repo": "apache/airflow",
      "pr_number": 60968,
      "file_path": "providers/openlineage/src/airflow/providers/openlineage/plugins/openlineage.py",
      "line": 24,
      "side": "RIGHT",
      "diff_hunk": "@@ -21,7 +21,7 @@\n \n # Conditional imports - only load expensive dependencies when plugin is enabled\n if not conf.is_disabled():\n-    from airflow.lineage.hook import HookLineageReader\n+    from airflow.providers.common.compat.sdk import HookLineageReader",
      "comment": "We should yes, but in this case not added because it is already there: https://github.com/apache/airflow/blob/main/providers/openlineage/pyproject.toml#L63\n",
      "comment_id": 2730859416,
      "user": "amoghrajesh",
      "created_at": "2026-01-27T08:35:14Z",
      "url": "https://github.com/apache/airflow/pull/60968#discussion_r2730859416"
    },
    {
      "repo": "apache/airflow",
      "pr_number": 60978,
      "file_path": "providers/amazon/src/airflow/providers/amazon/aws/operators/ssm.py",
      "line": 121,
      "side": "RIGHT",
      "diff_hunk": "@@ -106,6 +106,20 @@ def __init__(\n     def execute_complete(self, context: Context, event: dict[str, Any] | None = None) -> str:\n         event = validate_execute_complete_event(event)\n \n+        if event[\"status\"] == \"failed\":\n+            # Command failed - raise an exception with detailed information\n+            command_status = event.get(\"command_status\", \"Unknown\")\n+            exit_code = event.get(\"exit_code\", -1)\n+            instance_id = event.get(\"instance_id\", \"Unknown\")\n+            message = event.get(\"message\", \"Command failed\")\n+\n+            error_msg = (\n+                f\"SSM run command {event['command_id']} failed on instance {instance_id}. \"\n+                f\"Status: {command_status}, Exit code: {exit_code}. {message}\"\n+            )\n+            self.log.error(error_msg)\n+            raise RuntimeError(error_msg)",
      "comment": "Why double log the message? For example the below just includes it in the exception message in the RuntimeError",
      "comment_id": 2733232293,
      "user": "o-nikolas",
      "created_at": "2026-01-27T18:06:56Z",
      "url": "https://github.com/apache/airflow/pull/60978#discussion_r2733232293"
    },
    {
      "repo": "apache/airflow",
      "pr_number": 60957,
      "file_path": "airflow-core/tests/unit/models/test_dag.py",
      "line": 2025,
      "side": "RIGHT",
      "diff_hunk": "@@ -1998,6 +1998,34 @@ def test_dags_needing_dagruns_assets(self, dag_maker, session):\n         dag_models = query.all()\n         assert dag_models == [dag_model]\n \n+    def test_dags_needing_dagruns_query_count(self, dag_maker, session):\n+        \"\"\"Test that dags_needing_dagruns avoids N+1 on adrq.asset access.\"\"\"\n+        num_assets = 10\n+        assets = [Asset(uri=f\"test://asset{i}\", group=\"test-group\") for i in range(num_assets)]\n+\n+        with dag_maker(\n+            session=session,\n+            dag_id=\"my_dag\",\n+            max_active_runs=10,\n+            schedule=assets,\n+            start_date=pendulum.now().add(days=-2),\n+        ):\n+            EmptyOperator(task_id=\"dummy\")\n+\n+        dag_model = dag_maker.dag_model\n+        asset_models = dag_model.schedule_assets\n+        assert len(asset_models) == num_assets\n+        for asset_model in asset_models:\n+            session.add(AssetDagRunQueue(asset_id=asset_model.id, target_dag_id=dag_model.dag_id))\n+        session.flush()\n+\n+        # Clear identity map so N+1 on adrq.asset is exposed\n+        session.expire_all()\n+\n+        with assert_queries_count(6):",
      "comment": "The expected query count of 6 doesn't match the PR description which states 'After: 4 queries'. Either the assertion should be updated to 4, or the PR description should be updated to explain why 6 queries are expected.\n```suggestion\n        with assert_queries_count(4):\n```",
      "comment_id": 2718888332,
      "user": "Copilot",
      "created_at": "2026-01-22T22:38:43Z",
      "url": "https://github.com/apache/airflow/pull/60957#discussion_r2718888332"
    },
    {
      "repo": "apache/airflow",
      "pr_number": 60754,
      "file_path": "airflow-core/tests/unit/jobs/test_triggerer_job.py",
      "line": 267,
      "side": "RIGHT",
      "diff_hunk": "@@ -264,8 +264,8 @@ def send_msg_spy(self, msg, *args, **kwargs):\n         # Re-load the triggers\n         trigger_runner_supervisor.load_triggers()\n \n-        # Wait for up to 3 seconds for it to vanish from the TriggerRunner's storage\n-        for _ in range(30):\n+        # Wait for up to 100 seconds for it to vanish from the TriggerRunner's storage",
      "comment": "In your description, you said 10s. Do we need 100s here instead?",
      "comment_id": 2708335341,
      "user": "Lee-W",
      "created_at": "2026-01-20T13:21:28Z",
      "url": "https://github.com/apache/airflow/pull/60754#discussion_r2708335341"
    },
    {
      "repo": "apache/airflow",
      "pr_number": 60754,
      "file_path": "airflow-core/tests/unit/jobs/test_triggerer_job.py",
      "line": 267,
      "side": "RIGHT",
      "diff_hunk": "@@ -264,8 +264,8 @@ def send_msg_spy(self, msg, *args, **kwargs):\n         # Re-load the triggers\n         trigger_runner_supervisor.load_triggers()\n \n-        # Wait for up to 3 seconds for it to vanish from the TriggerRunner's storage\n-        for _ in range(30):\n+        # Wait for up to 100 seconds for it to vanish from the TriggerRunner's storage",
      "comment": "> In your description, you said 10s. Do we need 100s here instead?\n\nOops, I'm bad at math. Yes, 100 * 0.1 is 10 seconds. I think we should only need 10s",
      "comment_id": 2708410951,
      "user": "henry3260",
      "created_at": "2026-01-20T13:41:35Z",
      "url": "https://github.com/apache/airflow/pull/60754#discussion_r2708410951"
    },
    {
      "repo": "apache/airflow",
      "pr_number": 60754,
      "file_path": "airflow-core/tests/unit/jobs/test_triggerer_job.py",
      "line": 267,
      "side": "RIGHT",
      "diff_hunk": "@@ -264,8 +264,8 @@ def send_msg_spy(self, msg, *args, **kwargs):\n         # Re-load the triggers\n         trigger_runner_supervisor.load_triggers()\n \n-        # Wait for up to 3 seconds for it to vanish from the TriggerRunner's storage\n-        for _ in range(30):\n+        # Wait for up to 100 seconds for it to vanish from the TriggerRunner's storage",
      "comment": "We all are since we stopped calculating by hand :) ",
      "comment_id": 2731618470,
      "user": "potiuk",
      "created_at": "2026-01-27T11:45:55Z",
      "url": "https://github.com/apache/airflow/pull/60754#discussion_r2731618470"
    },
    {
      "repo": "apache/airflow",
      "pr_number": 60152,
      "file_path": "airflow-core/src/airflow/jobs/triggerer_job_runner.py",
      "line": 1081,
      "side": "RIGHT",
      "diff_hunk": "@@ -1059,46 +1059,62 @@ async def cleanup_finished_triggers(self) -> list[int]:\n             await asyncio.sleep(0)\n         return finished_ids\n \n-    async def sync_state_to_supervisor(self, finished_ids: list[int]):\n+    def validate_state_changes(self, finished_ids: list[int]) -> messages.TriggerStateChanges:\n         # Copy out of our dequeues in threadsafe manner to sync state with parent\n-        events_to_send = []\n+\n+        req_encoder = _new_encoder()\n+        events_to_send: list[tuple[int, DiscrimatedTriggerEvent]] = []\n+        failures_to_send: list[tuple[int, list[str] | None]] = []\n+\n         while self.events:\n-            data = self.events.popleft()\n-            events_to_send.append(data)\n+            trigger_id, trigger_event = self.events.popleft()\n+\n+            try:\n+                req_encoder.encode(trigger_event)\n+                events_to_send.append((trigger_id, trigger_event))\n+            except NotImplementedError as e:\n+                logger.error(\n+                    \"Trigger %s returned non-serializable result %r. Cancelling trigger.\",\n+                    trigger_id,\n+                    trigger_event,\n+                )\n+                self.failed_triggers.append((trigger_id, e))",
      "comment": "Probably best to catch any error.\r\n\r\nThough I don't love the fact that this encodes things twice, throwing the result away once.\r\n\r\n```suggestion\r\n            try:\r\n                req_encoder.encode(trigger_event)\r\n            except Exception as e:\r\n                logger.error(\r\n                    \"Trigger %s returned non-serializable result %r. Cancelling trigger.\",\r\n                    trigger_id,\r\n                    trigger_event,\r\n                )\r\n                self.failed_triggers.append((trigger_id, e))\r\n            else:\r\n                events_to_send.append((trigger_id, trigger_event))\r\n\r\n```",
      "comment_id": 2687511128,
      "user": "ashb",
      "created_at": "2026-01-13T18:05:26Z",
      "url": "https://github.com/apache/airflow/pull/60152#discussion_r2687511128"
    },
    {
      "repo": "apache/airflow",
      "pr_number": 60152,
      "file_path": "airflow-core/src/airflow/jobs/triggerer_job_runner.py",
      "line": 1062,
      "side": "RIGHT",
      "diff_hunk": "@@ -1059,46 +1059,62 @@ async def cleanup_finished_triggers(self) -> list[int]:\n             await asyncio.sleep(0)\n         return finished_ids\n \n-    async def sync_state_to_supervisor(self, finished_ids: list[int]):\n+    def validate_state_changes(self, finished_ids: list[int]) -> messages.TriggerStateChanges:",
      "comment": "This method name is a bit off -- given it returns the state changes, I'd suggest calling it something like process_ or serialize_ etc.",
      "comment_id": 2687516055,
      "user": "ashb",
      "created_at": "2026-01-13T18:07:11Z",
      "url": "https://github.com/apache/airflow/pull/60152#discussion_r2687516055"
    },
    {
      "repo": "apache/airflow",
      "pr_number": 60152,
      "file_path": "airflow-core/tests/unit/jobs/test_triggerer_job.py",
      "line": 454,
      "side": "RIGHT",
      "diff_hunk": "@@ -436,6 +436,23 @@ async def test_trigger_kwargs_serialization_cleanup(self, session):\n         trigger_instance.cancel()\n         await runner.cleanup_finished_triggers()\n \n+    @pytest.mark.asyncio\n+    @patch(\"airflow.sdk.execution_time.task_runner.SUPERVISOR_COMMS\", create=True)\n+    async def test_sync_state_to_supervisor(self, supervisor_builder):\n+        trigger_runner = TriggerRunner()\n+        trigger_runner.comms_decoder = AsyncMock(spec=TriggerCommsDecoder)\n+        trigger_runner.comms_decoder.asend.side_effect = [\n+            messages.TriggerStateSync(to_create=[], to_cancel=set()),\n+        ]\n+        trigger_runner.events.append((1, TriggerEvent(payload={\"status\": \"SUCCESS\"})))\n+        trigger_runner.events.append((2, TriggerEvent(payload={\"status\": \"FAILED\"})))\n+        trigger_runner.events.append((3, TriggerEvent(payload={\"status\": \"SUCCESS\", \"data\": object()})))\n+\n+        await trigger_runner.sync_state_to_supervisor(finished_ids=[])\n+\n+        assert trigger_runner.comms_decoder.asend.call_count == 1\n+        assert len(trigger_runner.comms_decoder.asend.call_args_list[0].args[0].events) == 2",
      "comment": "Only 2 events? Shouldn't this be 3 as we have two success and one failure to report?",
      "comment_id": 2687522295,
      "user": "ashb",
      "created_at": "2026-01-13T18:09:19Z",
      "url": "https://github.com/apache/airflow/pull/60152#discussion_r2687522295"
    },
    {
      "repo": "apache/airflow",
      "pr_number": 60152,
      "file_path": "airflow-core/tests/unit/jobs/test_triggerer_job.py",
      "line": 454,
      "side": "RIGHT",
      "diff_hunk": "@@ -436,6 +436,23 @@ async def test_trigger_kwargs_serialization_cleanup(self, session):\n         trigger_instance.cancel()\n         await runner.cleanup_finished_triggers()\n \n+    @pytest.mark.asyncio\n+    @patch(\"airflow.sdk.execution_time.task_runner.SUPERVISOR_COMMS\", create=True)\n+    async def test_sync_state_to_supervisor(self, supervisor_builder):\n+        trigger_runner = TriggerRunner()\n+        trigger_runner.comms_decoder = AsyncMock(spec=TriggerCommsDecoder)\n+        trigger_runner.comms_decoder.asend.side_effect = [\n+            messages.TriggerStateSync(to_create=[], to_cancel=set()),\n+        ]\n+        trigger_runner.events.append((1, TriggerEvent(payload={\"status\": \"SUCCESS\"})))\n+        trigger_runner.events.append((2, TriggerEvent(payload={\"status\": \"FAILED\"})))\n+        trigger_runner.events.append((3, TriggerEvent(payload={\"status\": \"SUCCESS\", \"data\": object()})))\n+\n+        await trigger_runner.sync_state_to_supervisor(finished_ids=[])\n+\n+        assert trigger_runner.comms_decoder.asend.call_count == 1\n+        assert len(trigger_runner.comms_decoder.asend.call_args_list[0].args[0].events) == 2",
      "comment": "This is fixed now in the unit test, now it will check 3 events first and only 2 after sanitize function",
      "comment_id": 2705901725,
      "user": "dabla",
      "created_at": "2026-01-19T19:41:45Z",
      "url": "https://github.com/apache/airflow/pull/60152#discussion_r2705901725"
    },
    {
      "repo": "apache/airflow",
      "pr_number": 60152,
      "file_path": "airflow-core/src/airflow/jobs/triggerer_job_runner.py",
      "line": 1118,
      "side": "RIGHT",
      "diff_hunk": "@@ -1066,46 +1066,78 @@ async def cleanup_finished_triggers(self) -> list[int]:\n             await asyncio.sleep(0)\n         return finished_ids\n \n-    async def sync_state_to_supervisor(self, finished_ids: list[int]):\n+    def process_trigger_events(self, finished_ids: list[int]) -> messages.TriggerStateChanges:\n         # Copy out of our dequeues in threadsafe manner to sync state with parent\n-        events_to_send = []\n+        events_to_send: list[tuple[int, DiscrimatedTriggerEvent]] = []\n+        failures_to_send: list[tuple[int, list[str] | None]] = []\n+\n         while self.events:\n-            data = self.events.popleft()\n-            events_to_send.append(data)\n+            trigger_id, trigger_event = self.events.popleft()\n+            events_to_send.append((trigger_id, trigger_event))\n \n-        failures_to_send = []\n         while self.failed_triggers:\n-            id, exc = self.failed_triggers.popleft()\n+            trigger_id, exc = self.failed_triggers.popleft()\n             tb = format_exception(type(exc), exc, exc.__traceback__) if exc else None\n-            failures_to_send.append((id, tb))\n+            failures_to_send.append((trigger_id, tb))\n \n-        msg = messages.TriggerStateChanges(\n-            events=events_to_send, finished=finished_ids, failures=failures_to_send\n+        return messages.TriggerStateChanges(\n+            events=events_to_send if events_to_send else None,\n+            finished=finished_ids if finished_ids else None,\n+            failures=failures_to_send if failures_to_send else None,\n         )\n \n-        if not events_to_send:\n-            msg.events = None\n+    def sanitize_trigger_events(self, msg: messages.TriggerStateChanges) -> messages.TriggerStateChanges:\n+        req_encoder = _new_encoder()\n+        events_to_send: list[tuple[int, DiscrimatedTriggerEvent]] = []\n+\n+        if msg.events:\n+            for trigger_id, trigger_event in msg.events:\n+                try:\n+                    req_encoder.encode(trigger_event)\n+                except Exception as e:\n+                    logger.error(\n+                        \"Trigger %s returned non-serializable result %r. Cancelling trigger.\",\n+                        trigger_id,\n+                        trigger_event,\n+                    )\n+                    self.failed_triggers.append((trigger_id, e))\n+                else:\n+                    events_to_send.append((trigger_id, trigger_event))\n \n-        if not failures_to_send:\n-            msg.failures = None\n+        return messages.TriggerStateChanges(\n+            events=events_to_send if events_to_send else None,\n+            finished=msg.finished,\n+            failures=msg.failures,\n+        )\n \n-        if not finished_ids:\n-            msg.finished = None\n+    async def sync_state_to_supervisor(self, finished_ids: list[int]) -> None:\n+        msg = self.process_trigger_events(finished_ids=finished_ids)\n \n         # Tell the monitor that we've finished triggers so it can update things\n         try:\n-            resp = await self.comms_decoder.asend(msg)\n+            resp = await self.asend(msg)",
      "comment": "I refactored it as agreed with @ashb , so I think we can merge it right?",
      "comment_id": 2712646874,
      "user": "dabla",
      "created_at": "2026-01-21T13:45:33Z",
      "url": "https://github.com/apache/airflow/pull/60152#discussion_r2712646874"
    },
    {
      "repo": "apache/airflow",
      "pr_number": 49942,
      "file_path": "providers/fab/src/airflow/providers/fab/www/extensions/init_wsgi_middlewares.py",
      "line": 34,
      "side": "RIGHT",
      "diff_hunk": "@@ -0,0 +1,42 @@\n+# Licensed to the Apache Software Foundation (ASF) under one\n+# or more contributor license agreements.  See the NOTICE file\n+# distributed with this work for additional information\n+# regarding copyright ownership.  The ASF licenses this file\n+# to you under the Apache License, Version 2.0 (the\n+# \"License\"); you may not use this file except in compliance\n+# with the License.  You may obtain a copy of the License at\n+#\n+#   http://www.apache.org/licenses/LICENSE-2.0\n+#\n+# Unless required by applicable law or agreed to in writing,\n+# software distributed under the License is distributed on an\n+# \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+# KIND, either express or implied.  See the License for the\n+# specific language governing permissions and limitations\n+# under the License.\n+\n+from __future__ import annotations\n+\n+from typing import TYPE_CHECKING\n+\n+from airflow.configuration import conf\n+from airflow.exceptions import AirflowConfigException\n+from werkzeug.middleware.proxy_fix import ProxyFix\n+\n+if TYPE_CHECKING:\n+    from flask import Flask\n+\n+\n+def init_wsgi_middleware(flask_app: Flask) -> None:\n+    \"\"\"Handle X-Forwarded-* headers and base_url support.\"\"\"\n+\n+    # Apply ProxyFix middleware\n+    if conf.getboolean(\"webserver\", \"ENABLE_PROXY_FIX\"):",
      "comment": "We removed this config because it was no longer used. Please update `airflow-core/src/airflow/cli/commands/config_command.py` as well to no longer mark this config as removed.",
      "comment_id": 2065920671,
      "user": "vincbeck",
      "created_at": "2025-04-29T09:31:13Z",
      "url": "https://github.com/apache/airflow/pull/49942#discussion_r2065920671"
    },
    {
      "repo": "apache/airflow",
      "pr_number": 49942,
      "file_path": "providers/fab/src/airflow/providers/fab/www/extensions/init_wsgi_middlewares.py",
      "line": 34,
      "side": "RIGHT",
      "diff_hunk": "@@ -0,0 +1,42 @@\n+# Licensed to the Apache Software Foundation (ASF) under one\n+# or more contributor license agreements.  See the NOTICE file\n+# distributed with this work for additional information\n+# regarding copyright ownership.  The ASF licenses this file\n+# to you under the Apache License, Version 2.0 (the\n+# \"License\"); you may not use this file except in compliance\n+# with the License.  You may obtain a copy of the License at\n+#\n+#   http://www.apache.org/licenses/LICENSE-2.0\n+#\n+# Unless required by applicable law or agreed to in writing,\n+# software distributed under the License is distributed on an\n+# \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+# KIND, either express or implied.  See the License for the\n+# specific language governing permissions and limitations\n+# under the License.\n+\n+from __future__ import annotations\n+\n+from typing import TYPE_CHECKING\n+\n+from airflow.configuration import conf\n+from airflow.exceptions import AirflowConfigException\n+from werkzeug.middleware.proxy_fix import ProxyFix\n+\n+if TYPE_CHECKING:\n+    from flask import Flask\n+\n+\n+def init_wsgi_middleware(flask_app: Flask) -> None:\n+    \"\"\"Handle X-Forwarded-* headers and base_url support.\"\"\"\n+\n+    # Apply ProxyFix middleware\n+    if conf.getboolean(\"webserver\", \"ENABLE_PROXY_FIX\"):",
      "comment": "I think it would be better to move this config to `fab` instead of keeping it in `webserver` but I think it is too late since we already cut 3.0.0. Unless we consider it a bug fix and put it in 3.0.X branch, then we could still rename this config? Maybe @potiuk knows better on that question",
      "comment_id": 2065925296,
      "user": "vincbeck",
      "created_at": "2025-04-29T09:34:04Z",
      "url": "https://github.com/apache/airflow/pull/49942#discussion_r2065925296"
    },
    {
      "repo": "apache/airflow",
      "pr_number": 49942,
      "file_path": "providers/fab/src/airflow/providers/fab/www/extensions/init_wsgi_middlewares.py",
      "line": 34,
      "side": "RIGHT",
      "diff_hunk": "@@ -0,0 +1,42 @@\n+# Licensed to the Apache Software Foundation (ASF) under one\n+# or more contributor license agreements.  See the NOTICE file\n+# distributed with this work for additional information\n+# regarding copyright ownership.  The ASF licenses this file\n+# to you under the Apache License, Version 2.0 (the\n+# \"License\"); you may not use this file except in compliance\n+# with the License.  You may obtain a copy of the License at\n+#\n+#   http://www.apache.org/licenses/LICENSE-2.0\n+#\n+# Unless required by applicable law or agreed to in writing,\n+# software distributed under the License is distributed on an\n+# \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+# KIND, either express or implied.  See the License for the\n+# specific language governing permissions and limitations\n+# under the License.\n+\n+from __future__ import annotations\n+\n+from typing import TYPE_CHECKING\n+\n+from airflow.configuration import conf\n+from airflow.exceptions import AirflowConfigException\n+from werkzeug.middleware.proxy_fix import ProxyFix\n+\n+if TYPE_CHECKING:\n+    from flask import Flask\n+\n+\n+def init_wsgi_middleware(flask_app: Flask) -> None:\n+    \"\"\"Handle X-Forwarded-* headers and base_url support.\"\"\"\n+\n+    # Apply ProxyFix middleware\n+    if conf.getboolean(\"webserver\", \"ENABLE_PROXY_FIX\"):",
      "comment": "Completly agree, I moved the configuration from webserver to fab and added the documentation in the provider docs.",
      "comment_id": 2066196949,
      "user": "gschuurman",
      "created_at": "2025-04-29T12:16:31Z",
      "url": "https://github.com/apache/airflow/pull/49942#discussion_r2066196949"
    },
    {
      "repo": "apache/airflow",
      "pr_number": 60650,
      "file_path": "providers/microsoft/azure/src/airflow/providers/microsoft/azure/triggers/data_factory.py",
      "line": 77,
      "side": "RIGHT",
      "diff_hunk": "@@ -74,39 +74,40 @@ async def run(self) -> AsyncIterator[TriggerEvent]:\n         hook = AzureDataFactoryAsyncHook(azure_data_factory_conn_id=self.azure_data_factory_conn_id)\n         executed_after_token_refresh = False\n         try:\n-            while True:\n-                try:\n-                    pipeline_status = await hook.get_adf_pipeline_run_status(\n-                        run_id=self.run_id,\n-                        resource_group_name=self.resource_group_name,\n-                        factory_name=self.factory_name,\n-                    )\n-                    executed_after_token_refresh = False\n-                    if pipeline_status == AzureDataFactoryPipelineRunStatus.FAILED:\n-                        yield TriggerEvent(\n-                            {\"status\": \"error\", \"message\": f\"Pipeline run {self.run_id} has Failed.\"}\n+            async with hook:",
      "comment": "wouldn't it be nicer to write this like:\r\n\r\n`with AzureDataFactoryAsyncHook(azure_data_factory_conn_id=self.azure_data_factory_conn_id) as hook:`",
      "comment_id": 2704763111,
      "user": "dabla",
      "created_at": "2026-01-19T13:23:42Z",
      "url": "https://github.com/apache/airflow/pull/60650#discussion_r2704763111"
    },
    {
      "repo": "apache/airflow",
      "pr_number": 60650,
      "file_path": "providers/microsoft/azure/src/airflow/providers/microsoft/azure/triggers/data_factory.py",
      "line": 86,
      "side": "RIGHT",
      "diff_hunk": "@@ -74,39 +74,40 @@ async def run(self) -> AsyncIterator[TriggerEvent]:\n         hook = AzureDataFactoryAsyncHook(azure_data_factory_conn_id=self.azure_data_factory_conn_id)\n         executed_after_token_refresh = False\n         try:\n-            while True:\n-                try:\n-                    pipeline_status = await hook.get_adf_pipeline_run_status(\n-                        run_id=self.run_id,\n-                        resource_group_name=self.resource_group_name,\n-                        factory_name=self.factory_name,\n-                    )\n-                    executed_after_token_refresh = False\n-                    if pipeline_status == AzureDataFactoryPipelineRunStatus.FAILED:\n-                        yield TriggerEvent(\n-                            {\"status\": \"error\", \"message\": f\"Pipeline run {self.run_id} has Failed.\"}\n+            async with hook:\n+                while True:\n+                    try:\n+                        pipeline_status = await hook.get_adf_pipeline_run_status(\n+                            run_id=self.run_id,\n+                            resource_group_name=self.resource_group_name,\n+                            factory_name=self.factory_name,\n                         )\n-                        return\n-                    elif pipeline_status == AzureDataFactoryPipelineRunStatus.CANCELLED:\n-                        msg = f\"Pipeline run {self.run_id} has been Cancelled.\"\n-                        yield TriggerEvent({\"status\": \"error\", \"message\": msg})\n-                        return\n-                    elif pipeline_status == AzureDataFactoryPipelineRunStatus.SUCCEEDED:\n-                        msg = f\"Pipeline run {self.run_id} has been Succeeded.\"\n-                        yield TriggerEvent({\"status\": \"success\", \"message\": msg})\n-                        return\n-                    await asyncio.sleep(self.poke_interval)\n-                except ServiceRequestError:\n-                    # conn might expire during long running pipeline.\n-                    # If exception is caught, it tries to refresh connection once.\n-                    # If it still doesn't fix the issue,\n-                    # than the execute_after_token_refresh would still be False\n-                    # and an exception will be raised\n-                    if executed_after_token_refresh:\n-                        await hook.refresh_conn()\n                         executed_after_token_refresh = False\n-                    else:\n-                        raise\n+                        if pipeline_status == AzureDataFactoryPipelineRunStatus.FAILED:",
      "comment": "Maybe write a helper method which constructs the TriggerEvent base on the pipeline_status so then you could yield the resulting event from it and encapsulating the if/else in a dedicated method.\r\n\r\n```\r\ndef trigger_event_from_pipline_status(self, pipeline_status: AzureDataFactoryPipelineRunStatus) -> TriggerEvent:\r\n    if pipeline_status == AzureDataFactoryPipelineRunStatus.FAILED:\r\n        return TriggerEvent(\r\n            {\"status\": \"error\", \"message\": f\"Pipeline run {self.run_id} has Failed.\"}\r\n        )\r\n    if pipeline_status == AzureDataFactoryPipelineRunStatus.CANCELLED:\r\n        msg = f\"Pipeline run {self.run_id} has been Cancelled.\"\r\n        return TriggerEvent({\"status\": \"error\", \"message\": msg})\r\n    if pipeline_status == AzureDataFactoryPipelineRunStatus.SUCCEEDED:\r\n        msg = f\"Pipeline run {self.run_id} has been Succeeded.\"\r\n        return TriggerEvent({\"status\": \"success\", \"message\": msg})\r\n        \r\n...\r\n\r\n        event = self.trigger_event_from_pipline_status(pipeline_status)\r\n        yield event\r\n```",
      "comment_id": 2704780853,
      "user": "dabla",
      "created_at": "2026-01-19T13:28:37Z",
      "url": "https://github.com/apache/airflow/pull/60650#discussion_r2704780853"
    },
    {
      "repo": "apache/airflow",
      "pr_number": 60650,
      "file_path": "providers/microsoft/azure/src/airflow/providers/microsoft/azure/triggers/data_factory.py",
      "line": 168,
      "side": "RIGHT",
      "diff_hunk": "@@ -164,70 +165,73 @@ async def run(self) -> AsyncIterator[TriggerEvent]:\n         \"\"\"Make async connection to Azure Data Factory, polls for the pipeline run status.\"\"\"\n         hook = AzureDataFactoryAsyncHook(azure_data_factory_conn_id=self.azure_data_factory_conn_id)\n         try:\n-            pipeline_status = await hook.get_adf_pipeline_run_status(\n-                run_id=self.run_id,\n-                resource_group_name=self.resource_group_name,\n-                factory_name=self.factory_name,\n-            )\n-            executed_after_token_refresh = True\n-            if self.wait_for_termination:\n-                while self.end_time > time.time():\n-                    try:\n-                        pipeline_status = await hook.get_adf_pipeline_run_status(\n-                            run_id=self.run_id,\n-                            resource_group_name=self.resource_group_name,\n-                            factory_name=self.factory_name,\n-                        )\n-                        executed_after_token_refresh = True\n-                        if pipeline_status in AzureDataFactoryPipelineRunStatus.FAILURE_STATES:\n-                            yield TriggerEvent(\n-                                {\n-                                    \"status\": \"error\",\n-                                    \"message\": f\"The pipeline run {self.run_id} has {pipeline_status}.\",\n-                                    \"run_id\": self.run_id,\n-                                }\n+            async with hook:",
      "comment": "Same here:\r\n\r\n`with AzureDataFactoryAsyncHook(azure_data_factory_conn_id=self.azure_data_factory_conn_id) as hook:`",
      "comment_id": 2704783604,
      "user": "dabla",
      "created_at": "2026-01-19T13:29:24Z",
      "url": "https://github.com/apache/airflow/pull/60650#discussion_r2704783604"
    },
    {
      "repo": "apache/airflow",
      "pr_number": 60650,
      "file_path": "providers/microsoft/azure/src/airflow/providers/microsoft/azure/triggers/data_factory.py",
      "line": 248,
      "side": "RIGHT",
      "diff_hunk": "@@ -240,4 +244,6 @@ async def run(self) -> AsyncIterator[TriggerEvent]:\n                     )\n                 except Exception:\n                     self.log.exception(\"Failed to cancel pipeline run %s\", self.run_id)\n+                finally:\n+                    await hook.close()",
      "comment": "Do we still need to close when we use the async context manager?  I would expect this now the handled by the context manager?",
      "comment_id": 2704791798,
      "user": "dabla",
      "created_at": "2026-01-19T13:31:54Z",
      "url": "https://github.com/apache/airflow/pull/60650#discussion_r2704791798"
    },
    {
      "repo": "apache/airflow",
      "pr_number": 60650,
      "file_path": "providers/microsoft/azure/src/airflow/providers/microsoft/azure/triggers/data_factory.py",
      "line": 248,
      "side": "RIGHT",
      "diff_hunk": "@@ -240,4 +244,6 @@ async def run(self) -> AsyncIterator[TriggerEvent]:\n                     )\n                 except Exception:\n                     self.log.exception(\"Failed to cancel pipeline run %s\", self.run_id)\n+                finally:\n+                    await hook.close()",
      "comment": "yes, removing it as it is redundant with context manager.",
      "comment_id": 2706620476,
      "user": "cruseakshay",
      "created_at": "2026-01-20T03:23:53Z",
      "url": "https://github.com/apache/airflow/pull/60650#discussion_r2706620476"
    },
    {
      "repo": "apache/airflow",
      "pr_number": 60650,
      "file_path": "providers/microsoft/azure/src/airflow/providers/microsoft/azure/triggers/data_factory.py",
      "line": 112,
      "side": "RIGHT",
      "diff_hunk": "@@ -69,44 +69,51 @@ def serialize(self) -> tuple[str, dict[str, Any]]:\n             },\n         )\n \n+    def _build_trigger_event(self, pipeline_status: str) -> TriggerEvent | None:\n+        \"\"\"Build TriggerEvent based on pipeline status. Returns None if status is not terminal.\"\"\"\n+        if pipeline_status == AzureDataFactoryPipelineRunStatus.FAILED:\n+            return TriggerEvent({\"status\": \"error\", \"message\": f\"Pipeline run {self.run_id} has Failed.\"})\n+        if pipeline_status == AzureDataFactoryPipelineRunStatus.CANCELLED:\n+            return TriggerEvent(\n+                {\"status\": \"error\", \"message\": f\"Pipeline run {self.run_id} has been Cancelled.\"}\n+            )\n+        if pipeline_status == AzureDataFactoryPipelineRunStatus.SUCCEEDED:\n+            return TriggerEvent(\n+                {\"status\": \"success\", \"message\": f\"Pipeline run {self.run_id} has been Succeeded.\"}\n+            )\n+        return None\n+\n     async def run(self) -> AsyncIterator[TriggerEvent]:\n         \"\"\"Make async connection to Azure Data Factory, polls for the pipeline run status.\"\"\"\n-        hook = AzureDataFactoryAsyncHook(azure_data_factory_conn_id=self.azure_data_factory_conn_id)\n         executed_after_token_refresh = False\n         try:\n-            while True:\n-                try:\n-                    pipeline_status = await hook.get_adf_pipeline_run_status(\n-                        run_id=self.run_id,\n-                        resource_group_name=self.resource_group_name,\n-                        factory_name=self.factory_name,\n-                    )\n-                    executed_after_token_refresh = False\n-                    if pipeline_status == AzureDataFactoryPipelineRunStatus.FAILED:\n-                        yield TriggerEvent(\n-                            {\"status\": \"error\", \"message\": f\"Pipeline run {self.run_id} has Failed.\"}\n+            async with AzureDataFactoryAsyncHook(\n+                azure_data_factory_conn_id=self.azure_data_factory_conn_id\n+            ) as hook:\n+                while True:\n+                    try:\n+                        pipeline_status = await hook.get_adf_pipeline_run_status(\n+                            run_id=self.run_id,\n+                            resource_group_name=self.resource_group_name,\n+                            factory_name=self.factory_name,\n                         )\n-                        return\n-                    elif pipeline_status == AzureDataFactoryPipelineRunStatus.CANCELLED:\n-                        msg = f\"Pipeline run {self.run_id} has been Cancelled.\"\n-                        yield TriggerEvent({\"status\": \"error\", \"message\": msg})\n-                        return\n-                    elif pipeline_status == AzureDataFactoryPipelineRunStatus.SUCCEEDED:\n-                        msg = f\"Pipeline run {self.run_id} has been Succeeded.\"\n-                        yield TriggerEvent({\"status\": \"success\", \"message\": msg})\n-                        return\n-                    await asyncio.sleep(self.poke_interval)\n-                except ServiceRequestError:\n-                    # conn might expire during long running pipeline.\n-                    # If exception is caught, it tries to refresh connection once.\n-                    # If it still doesn't fix the issue,\n-                    # than the execute_after_token_refresh would still be False\n-                    # and an exception will be raised\n-                    if executed_after_token_refresh:\n-                        await hook.refresh_conn()\n                         executed_after_token_refresh = False\n-                    else:\n-                        raise\n+                        event = self._build_trigger_event(pipeline_status)\n+                        if event:\n+                            yield event\n+                            return\n+                        await asyncio.sleep(self.poke_interval)\n+                    except ServiceRequestError:\n+                        # conn might expire during long running pipeline.\n+                        # If exception is caught, it tries to refresh connection once.\n+                        # If it still doesn't fix the issue,\n+                        # than the execute_after_token_refresh would still be False\n+                        # and an exception will be raised\n+                        if executed_after_token_refresh:",
      "comment": "Nit, but I would write it like this:\r\n\r\n```\r\nif not executed_after_token_refresh:\r\n     raise\r\nawait hook.refresh_conn()\r\nexecuted_after_token_refresh = False                            \r\n```\r\n\r\n",
      "comment_id": 2709518476,
      "user": "dabla",
      "created_at": "2026-01-20T18:08:33Z",
      "url": "https://github.com/apache/airflow/pull/60650#discussion_r2709518476"
    },
    {
      "repo": "apache/airflow",
      "pr_number": 60650,
      "file_path": "providers/microsoft/azure/src/airflow/providers/microsoft/azure/triggers/data_factory.py",
      "line": 227,
      "side": "RIGHT",
      "diff_hunk": "@@ -160,84 +167,94 @@ def serialize(self) -> tuple[str, dict[str, Any]]:\n             },\n         )\n \n+    def _build_trigger_event(self, pipeline_status: str) -> TriggerEvent | None:\n+        \"\"\"Build TriggerEvent based on pipeline status. Returns None if status is not terminal.\"\"\"\n+        if pipeline_status in AzureDataFactoryPipelineRunStatus.FAILURE_STATES:\n+            return TriggerEvent(\n+                {\n+                    \"status\": \"error\",\n+                    \"message\": f\"The pipeline run {self.run_id} has {pipeline_status}.\",\n+                    \"run_id\": self.run_id,\n+                }\n+            )\n+        if pipeline_status == AzureDataFactoryPipelineRunStatus.SUCCEEDED:\n+            return TriggerEvent(\n+                {\n+                    \"status\": \"success\",\n+                    \"message\": f\"The pipeline run {self.run_id} has {pipeline_status}.\",\n+                    \"run_id\": self.run_id,\n+                }\n+            )\n+        return None\n+\n     async def run(self) -> AsyncIterator[TriggerEvent]:\n         \"\"\"Make async connection to Azure Data Factory, polls for the pipeline run status.\"\"\"\n-        hook = AzureDataFactoryAsyncHook(azure_data_factory_conn_id=self.azure_data_factory_conn_id)\n-        try:\n-            pipeline_status = await hook.get_adf_pipeline_run_status(\n-                run_id=self.run_id,\n-                resource_group_name=self.resource_group_name,\n-                factory_name=self.factory_name,\n-            )\n-            executed_after_token_refresh = True\n-            if self.wait_for_termination:\n-                while self.end_time > time.time():\n+        async with AzureDataFactoryAsyncHook(\n+            azure_data_factory_conn_id=self.azure_data_factory_conn_id\n+        ) as hook:\n+            try:\n+                pipeline_status = await hook.get_adf_pipeline_run_status(\n+                    run_id=self.run_id,\n+                    resource_group_name=self.resource_group_name,\n+                    factory_name=self.factory_name,\n+                )\n+                executed_after_token_refresh = True\n+                if self.wait_for_termination:\n+                    while self.end_time > time.time():\n+                        try:\n+                            pipeline_status = await hook.get_adf_pipeline_run_status(\n+                                run_id=self.run_id,\n+                                resource_group_name=self.resource_group_name,\n+                                factory_name=self.factory_name,\n+                            )\n+                            executed_after_token_refresh = True\n+                            event = self._build_trigger_event(pipeline_status)\n+                            if event:\n+                                yield event\n+                                return\n+                            self.log.info(\n+                                \"Sleeping for %s. The pipeline state is %s.\",\n+                                self.check_interval,\n+                                pipeline_status,\n+                            )\n+                            await asyncio.sleep(self.check_interval)\n+                        except ServiceRequestError:\n+                            # conn might expire during long running pipeline.\n+                            # If exception is caught, it tries to refresh connection once.\n+                            # If it still doesn't fix the issue,\n+                            # than the execute_after_token_refresh would still be False\n+                            # and an exception will be raised\n+                            if executed_after_token_refresh:",
      "comment": "Same here:\r\n\r\n```\r\nif not executed_after_token_refresh:\r\n     raise\r\nawait hook.refresh_conn()\r\nexecuted_after_token_refresh = False                            \r\n```",
      "comment_id": 2709520322,
      "user": "dabla",
      "created_at": "2026-01-20T18:09:05Z",
      "url": "https://github.com/apache/airflow/pull/60650#discussion_r2709520322"
    },
    {
      "repo": "apache/airflow",
      "pr_number": 60932,
      "file_path": "scripts/ci/prek/compile_ui_assets_dev.py",
      "line": 83,
      "side": "RIGHT",
      "diff_hunk": "@@ -79,10 +80,9 @@\n             stderr=subprocess.STDOUT,\n         )\n \n-    subprocess.run(\n+    subprocess.Popen(",
      "comment": "One small issue. When I run in this PR  on a fresh installation I keep on getting prek output of compiling asseets in dev mode contirunously in the terminal, actually overriding everything:\n\n<img width=\"1200\" height=\"932\" alt=\"Image\" src=\"https://github.com/user-attachments/assets/d4f76675-95af-4e93-a7c2-c79603fc7a28\" />\n\nI guess it's a question of redirecting prek properly ",
      "comment_id": 2717065152,
      "user": "potiuk",
      "created_at": "2026-01-22T14:05:47Z",
      "url": "https://github.com/apache/airflow/pull/60932#discussion_r2717065152"
    },
    {
      "repo": "apache/airflow",
      "pr_number": 60932,
      "file_path": "scripts/ci/prek/compile_ui_assets_dev.py",
      "line": 83,
      "side": "RIGHT",
      "diff_hunk": "@@ -79,10 +80,9 @@\n             stderr=subprocess.STDOUT,\n         )\n \n-    subprocess.run(\n+    subprocess.Popen(",
      "comment": "```\n breeze start-airflow --auth-manager FabAuthManager --dev-mode\n```",
      "comment_id": 2717067854,
      "user": "potiuk",
      "created_at": "2026-01-22T14:06:34Z",
      "url": "https://github.com/apache/airflow/pull/60932#discussion_r2717067854"
    },
    {
      "repo": "apache/airflow",
      "pr_number": 60932,
      "file_path": "scripts/ci/prek/compile_ui_assets_dev.py",
      "line": 83,
      "side": "RIGHT",
      "diff_hunk": "@@ -79,10 +80,9 @@\n             stderr=subprocess.STDOUT,\n         )\n \n-    subprocess.run(\n+    subprocess.Popen(",
      "comment": "I was able to reproduce the issue after upgrading prek to version 0.3.0.\r\nIt does not occur when using version 0.2.22.\r\nI'll take a look and see if I can find a proper fix.",
      "comment_id": 2717913350,
      "user": "choo121600",
      "created_at": "2026-01-22T17:30:27Z",
      "url": "https://github.com/apache/airflow/pull/60932#discussion_r2717913350"
    },
    {
      "repo": "apache/airflow",
      "pr_number": 60394,
      "file_path": "providers/google/src/airflow/providers/google/cloud/triggers/cloud_run.py",
      "line": 77,
      "side": "RIGHT",
      "diff_hunk": "@@ -71,6 +74,7 @@ def __init__(\n         impersonation_chain: str | Sequence[str] | None = None,\n         polling_period_seconds: float = 10,\n         timeout: float | None = None,\n+        transport: str | None = None,",
      "comment": "If this defaults to \"grpc\", why not just do `transport: str = \"grpc\"`?\n\nAlso it might be a good idea to use Literal here? I\u2019m not sure if the transports supported by these operators a static or not.",
      "comment_id": 2681036663,
      "user": "uranusjr",
      "created_at": "2026-01-12T06:43:32Z",
      "url": "https://github.com/apache/airflow/pull/60394#discussion_r2681036663"
    },
    {
      "repo": "apache/airflow",
      "pr_number": 60394,
      "file_path": "providers/google/src/airflow/providers/google/cloud/triggers/cloud_run.py",
      "line": 77,
      "side": "RIGHT",
      "diff_hunk": "@@ -71,6 +74,7 @@ def __init__(\n         impersonation_chain: str | Sequence[str] | None = None,\n         polling_period_seconds: float = 10,\n         timeout: float | None = None,\n+        transport: str | None = None,",
      "comment": "Yes, the transport options are static. Using Literal[\"rest\", \"grpc\"] is appropriate.\r\nmy bad, I didnt notice is properly",
      "comment_id": 2681288551,
      "user": "arjav1528",
      "created_at": "2026-01-12T08:37:27Z",
      "url": "https://github.com/apache/airflow/pull/60394#discussion_r2681288551"
    },
    {
      "repo": "apache/airflow",
      "pr_number": 60394,
      "file_path": "providers/google/src/airflow/providers/google/cloud/hooks/cloud_run.py",
      "line": 70,
      "side": "RIGHT",
      "diff_hunk": "@@ -67,16 +67,21 @@ class CloudRunHook(GoogleBaseHook):\n         If set as a sequence, the identities from the list must grant\n         Service Account Token Creator IAM role to the directly preceding identity, with first\n         account from the list granting this role to the originating account.\n+    :param transport: Optional. The transport to use for API requests. Can be 'rest' or 'grpc'.",
      "comment": "In the [docs](https://docs.cloud.google.com/python/docs/reference/run/latest/google.cloud.run_v2.services.jobs.JobsClient#google_cloud_run_v2_services_jobs_JobsClient) it is referenced as: \r\n\r\n> \"Optional[Union[str,JobsTransport,Callable[..., JobsTransport]]]\r\n> The transport to use, or a Callable that constructs and returns a new transport. If a Callable is given, it will be called with the same set of initialization arguments as used in the JobsTransport constructor. If set to None, a transport is chosen automatically.\r\n\r\nI think it makes sense to replicate similar hook behavior, at least to some extent, like `transport: Literal['rest', 'grpc'] | None = None)` ",
      "comment_id": 2686367899,
      "user": "olegkachur-e",
      "created_at": "2026-01-13T13:11:40Z",
      "url": "https://github.com/apache/airflow/pull/60394#discussion_r2686367899"
    },
    {
      "repo": "apache/airflow",
      "pr_number": 60394,
      "file_path": "providers/google/tests/unit/google/cloud/hooks/test_cloud_run.py",
      "line": 290,
      "side": "RIGHT",
      "diff_hunk": "@@ -259,6 +259,36 @@ def test_delete_job(self, mock_batch_service_client, cloud_run_hook):\n         cloud_run_hook.delete_job(job_name=JOB_NAME, region=REGION, project_id=PROJECT_ID)\n         cloud_run_hook._client.delete_job.assert_called_once_with(delete_request)\n \n+    @mock.patch(\n+        \"airflow.providers.google.common.hooks.base_google.GoogleBaseHook.__init__\",\n+        new=mock_base_gcp_hook_default_project_id,\n+    )\n+    @mock.patch(\"airflow.providers.google.cloud.hooks.cloud_run.JobsClient\")\n+    def test_get_conn_with_transport(self, mock_jobs_client):\n+        \"\"\"Test that transport parameter is passed to JobsClient.\"\"\"\n+        hook = CloudRunHook(transport=\"rest\")\n+        hook.get_credentials = self.dummy_get_credentials\n+        hook.get_conn()\n+\n+        mock_jobs_client.assert_called_once()\n+        call_kwargs = mock_jobs_client.call_args[1]\n+        assert call_kwargs[\"transport\"] == \"rest\"\n+\n+    @mock.patch(\n+        \"airflow.providers.google.common.hooks.base_google.GoogleBaseHook.__init__\",\n+        new=mock_base_gcp_hook_default_project_id,\n+    )\n+    @mock.patch(\"airflow.providers.google.cloud.hooks.cloud_run.JobsClient\")\n+    def test_get_conn_without_transport(self, mock_jobs_client):\n+        \"\"\"Test that JobsClient is created with default 'grpc' transport when not specified.\"\"\"\n+        hook = CloudRunHook()\n+        hook.get_credentials = self.dummy_get_credentials\n+        hook.get_conn()\n+\n+        mock_jobs_client.assert_called_once()\n+        call_kwargs = mock_jobs_client.call_args[1]\n+        assert call_kwargs[\"transport\"] == \"grpc\"",
      "comment": "Both `test_get_conn_with_transport` and `test_get_conn_without_transport` looks pretty similar, is there a chance to combine them with `@pytest.mark.parametrize` ? ",
      "comment_id": 2686403870,
      "user": "olegkachur-e",
      "created_at": "2026-01-13T13:19:16Z",
      "url": "https://github.com/apache/airflow/pull/60394#discussion_r2686403870"
    },
    {
      "repo": "apache/airflow",
      "pr_number": 60394,
      "file_path": "providers/google/tests/unit/google/cloud/hooks/test_cloud_run.py",
      "line": 290,
      "side": "RIGHT",
      "diff_hunk": "@@ -259,6 +259,36 @@ def test_delete_job(self, mock_batch_service_client, cloud_run_hook):\n         cloud_run_hook.delete_job(job_name=JOB_NAME, region=REGION, project_id=PROJECT_ID)\n         cloud_run_hook._client.delete_job.assert_called_once_with(delete_request)\n \n+    @mock.patch(\n+        \"airflow.providers.google.common.hooks.base_google.GoogleBaseHook.__init__\",\n+        new=mock_base_gcp_hook_default_project_id,\n+    )\n+    @mock.patch(\"airflow.providers.google.cloud.hooks.cloud_run.JobsClient\")\n+    def test_get_conn_with_transport(self, mock_jobs_client):\n+        \"\"\"Test that transport parameter is passed to JobsClient.\"\"\"\n+        hook = CloudRunHook(transport=\"rest\")\n+        hook.get_credentials = self.dummy_get_credentials\n+        hook.get_conn()\n+\n+        mock_jobs_client.assert_called_once()\n+        call_kwargs = mock_jobs_client.call_args[1]\n+        assert call_kwargs[\"transport\"] == \"rest\"\n+\n+    @mock.patch(\n+        \"airflow.providers.google.common.hooks.base_google.GoogleBaseHook.__init__\",\n+        new=mock_base_gcp_hook_default_project_id,\n+    )\n+    @mock.patch(\"airflow.providers.google.cloud.hooks.cloud_run.JobsClient\")\n+    def test_get_conn_without_transport(self, mock_jobs_client):\n+        \"\"\"Test that JobsClient is created with default 'grpc' transport when not specified.\"\"\"\n+        hook = CloudRunHook()\n+        hook.get_credentials = self.dummy_get_credentials\n+        hook.get_conn()\n+\n+        mock_jobs_client.assert_called_once()\n+        call_kwargs = mock_jobs_client.call_args[1]\n+        assert call_kwargs[\"transport\"] == \"grpc\"",
      "comment": "I. have applied all the suggested changes, do review the PR at your availability",
      "comment_id": 2706043769,
      "user": "arjav1528",
      "created_at": "2026-01-19T20:50:50Z",
      "url": "https://github.com/apache/airflow/pull/60394#discussion_r2706043769"
    },
    {
      "repo": "apache/airflow",
      "pr_number": 60394,
      "file_path": "providers/google/src/airflow/providers/google/cloud/triggers/cloud_run.py",
      "line": 77,
      "side": "RIGHT",
      "diff_hunk": "@@ -71,6 +74,7 @@ def __init__(\n         impersonation_chain: str | Sequence[str] | None = None,\n         polling_period_seconds: float = 10,\n         timeout: float | None = None,\n+        transport: str | None = None,",
      "comment": "@uranusjr could you review the changes and merge if good to go",
      "comment_id": 2722957407,
      "user": "arjav1528",
      "created_at": "2026-01-23T21:47:51Z",
      "url": "https://github.com/apache/airflow/pull/60394#discussion_r2722957407"
    },
    {
      "repo": "apache/airflow",
      "pr_number": 60394,
      "file_path": "providers/google/src/airflow/providers/google/cloud/triggers/cloud_run.py",
      "line": 77,
      "side": "RIGHT",
      "diff_hunk": "@@ -71,6 +74,7 @@ def __init__(\n         impersonation_chain: str | Sequence[str] | None = None,\n         polling_period_seconds: float = 10,\n         timeout: float | None = None,\n+        transport: Literal[\"rest\", \"grpc\"] | None = \"grpc\",",
      "comment": "Shouldn't this be `None` like the previous one for consistent behavior?",
      "comment_id": 2724260370,
      "user": "shahar1",
      "created_at": "2026-01-24T15:20:57Z",
      "url": "https://github.com/apache/airflow/pull/60394#discussion_r2724260370"
    },
    {
      "repo": "apache/airflow",
      "pr_number": 60394,
      "file_path": "providers/google/src/airflow/providers/google/cloud/triggers/cloud_run.py",
      "line": 77,
      "side": "RIGHT",
      "diff_hunk": "@@ -71,6 +74,7 @@ def __init__(\n         impersonation_chain: str | Sequence[str] | None = None,\n         polling_period_seconds: float = 10,\n         timeout: float | None = None,\n+        transport: Literal[\"rest\", \"grpc\"] | None = \"grpc\",",
      "comment": "You're right. The default should be None to match CloudRunHook, CloudRunAsyncHook, and CloudRunExecuteJobOperator, which all default to None. This allows the Google client library to auto-select the transport consistently in both sync and deferrable modes.\r\n\r\nI'll change line 77 to transport: Literal[\"rest\", \"grpc\"] | None = None and simplify _get_async_hook() to just pass self.transport directly without the None-to-grpc conversion.",
      "comment_id": 2724462588,
      "user": "arjav1528",
      "created_at": "2026-01-24T18:17:22Z",
      "url": "https://github.com/apache/airflow/pull/60394#discussion_r2724462588"
    },
    {
      "repo": "apache/airflow",
      "pr_number": 61049,
      "file_path": "helm-tests/tests/helm_tests/other/test_hpa.py",
      "line": 110,
      "side": "LEFT",
      "diff_hunk": "@@ -106,10 +106,8 @@ def test_hpa_behavior(self, executor):\n         [\n             ({\"celery\": {\"persistence\": {\"enabled\": True}}}, \"StatefulSet\"),\n             ({\"celery\": {\"persistence\": {\"enabled\": False}}}, \"Deployment\"),\n-            ({\"persistence\": {\"enabled\": True}, \"celery\": {\"persistence\": {\"enabled\": None}}}, \"StatefulSet\"),\n-            ({\"persistence\": {\"enabled\": False}, \"celery\": {\"persistence\": {\"enabled\": None}}}, \"Deployment\"),",
      "comment": "Why are you removing these tests? Are they broken or not meaningful?\nIf disabled because of fix complexity this should keep a note at least.",
      "comment_id": 2726012043,
      "user": "jscheffl",
      "created_at": "2026-01-25T23:19:38Z",
      "url": "https://github.com/apache/airflow/pull/61049#discussion_r2726012043"
    },
    {
      "repo": "apache/airflow",
      "pr_number": 61049,
      "file_path": "helm-tests/tests/helm_tests/other/test_keda.py",
      "line": 183,
      "side": "RIGHT",
      "diff_hunk": "@@ -179,10 +179,8 @@ def test_keda_query_kubernetes_queue(self, executor, queue):\n         [\n             ({\"celery\": {\"persistence\": {\"enabled\": True}}}, \"StatefulSet\"),\n             ({\"celery\": {\"persistence\": {\"enabled\": False}}}, \"Deployment\"),\n-            ({\"persistence\": {\"enabled\": True}, \"celery\": {\"persistence\": {\"enabled\": None}}}, \"StatefulSet\"),\n-            ({\"persistence\": {\"enabled\": False}, \"celery\": {\"persistence\": {\"enabled\": None}}}, \"Deployment\"),\n             ({\"persistence\": {\"enabled\": True}}, \"StatefulSet\"),\n-            ({\"persistence\": {\"enabled\": False}}, \"StatefulSet\"),\n+            ({\"persistence\": {\"enabled\": False}}, \"Deployment\"),",
      "comment": "I see (similar like in my PR) you are switching some storage definitions - just similar like in my parallel PR - was the test wrong and you needed to correct to Helm Chart fixes or did you need to bend test to mask a problem?",
      "comment_id": 2726012726,
      "user": "jscheffl",
      "created_at": "2026-01-25T23:20:41Z",
      "url": "https://github.com/apache/airflow/pull/61049#discussion_r2726012726"
    },
    {
      "repo": "apache/airflow",
      "pr_number": 61049,
      "file_path": "helm-tests/tests/helm_tests/airflow_core/test_scheduler.py",
      "line": 61,
      "side": "LEFT",
      "diff_hunk": "@@ -47,68 +47,17 @@ class TestScheduler:\n                 \"StatefulSet\",\n             ),\n             (\"LocalExecutor\", {\"celery\": {\"persistence\": {\"enabled\": False}}}, \"Deployment\"),\n-            # Test workers.persistence.enabled flag when celery one is default (expected no impact on kind)\n+            # Test workers.persistence.enabled flag when celery one is default\n             (\"CeleryExecutor\", {\"persistence\": {\"enabled\": False}}, \"Deployment\"),\n             (\"CeleryExecutor\", {\"persistence\": {\"enabled\": True}}, \"Deployment\"),\n             (\"CeleryKubernetesExecutor\", {\"persistence\": {\"enabled\": True}}, \"Deployment\"),\n             (\"CeleryExecutor,KubernetesExecutor\", {\"persistence\": {\"enabled\": True}}, \"Deployment\"),\n             (\"KubernetesExecutor\", {\"persistence\": {\"enabled\": True}}, \"Deployment\"),\n-            (\"LocalKubernetesExecutor\", {\"persistence\": {\"enabled\": False}}, \"StatefulSet\"),\n+            (\"LocalKubernetesExecutor\", {\"persistence\": {\"enabled\": False}}, \"Deployment\"),\n             (\"LocalKubernetesExecutor\", {\"persistence\": {\"enabled\": True}}, \"StatefulSet\"),\n             (\"LocalExecutor\", {\"persistence\": {\"enabled\": True}}, \"StatefulSet\"),\n             (\"LocalExecutor,KubernetesExecutor\", {\"persistence\": {\"enabled\": True}}, \"StatefulSet\"),\n-            (\"LocalExecutor\", {\"persistence\": {\"enabled\": False}}, \"StatefulSet\"),\n-            # Test workers.persistence.enabled flag when celery one is unset",
      "comment": "Oh, you delete a couple of tests. Can you add a comment why?",
      "comment_id": 2726012992,
      "user": "jscheffl",
      "created_at": "2026-01-25T23:21:07Z",
      "url": "https://github.com/apache/airflow/pull/61049#discussion_r2726012992"
    },
    {
      "repo": "apache/airflow",
      "pr_number": 61049,
      "file_path": "helm-tests/tests/helm_tests/other/test_hpa.py",
      "line": 110,
      "side": "LEFT",
      "diff_hunk": "@@ -106,10 +106,8 @@ def test_hpa_behavior(self, executor):\n         [\n             ({\"celery\": {\"persistence\": {\"enabled\": True}}}, \"StatefulSet\"),\n             ({\"celery\": {\"persistence\": {\"enabled\": False}}}, \"Deployment\"),\n-            ({\"persistence\": {\"enabled\": True}, \"celery\": {\"persistence\": {\"enabled\": None}}}, \"StatefulSet\"),\n-            ({\"persistence\": {\"enabled\": False}, \"celery\": {\"persistence\": {\"enabled\": None}}}, \"Deployment\"),",
      "comment": "Not meaningful. These tests were testing if the unset behaviour of `workers.celery` will bring back the previous behaviour of the chart (not breaking change behaviour), so if we are removing it, they are not needed",
      "comment_id": 2726019088,
      "user": "Miretpl",
      "created_at": "2026-01-25T23:30:34Z",
      "url": "https://github.com/apache/airflow/pull/61049#discussion_r2726019088"
    },
    {
      "repo": "apache/airflow",
      "pr_number": 61049,
      "file_path": "helm-tests/tests/helm_tests/other/test_keda.py",
      "line": 183,
      "side": "RIGHT",
      "diff_hunk": "@@ -179,10 +179,8 @@ def test_keda_query_kubernetes_queue(self, executor, queue):\n         [\n             ({\"celery\": {\"persistence\": {\"enabled\": True}}}, \"StatefulSet\"),\n             ({\"celery\": {\"persistence\": {\"enabled\": False}}}, \"Deployment\"),\n-            ({\"persistence\": {\"enabled\": True}, \"celery\": {\"persistence\": {\"enabled\": None}}}, \"StatefulSet\"),\n-            ({\"persistence\": {\"enabled\": False}, \"celery\": {\"persistence\": {\"enabled\": None}}}, \"Deployment\"),\n             ({\"persistence\": {\"enabled\": True}}, \"StatefulSet\"),\n-            ({\"persistence\": {\"enabled\": False}}, \"StatefulSet\"),\n+            ({\"persistence\": {\"enabled\": False}}, \"Deployment\"),",
      "comment": "The test was correct for the previous implementation. As the change of `workers.persistence.enabled` should not have any effect if `workers.celery.persistence.enabled` is specified. Now, when we are removing that behaviour (by making `workers.celery` values null), we expect that change of `workers.persistence.enabled` will have some effect",
      "comment_id": 2726020692,
      "user": "Miretpl",
      "created_at": "2026-01-25T23:33:09Z",
      "url": "https://github.com/apache/airflow/pull/61049#discussion_r2726020692"
    },
    {
      "repo": "apache/airflow",
      "pr_number": 61049,
      "file_path": "helm-tests/tests/helm_tests/airflow_core/test_scheduler.py",
      "line": 61,
      "side": "LEFT",
      "diff_hunk": "@@ -47,68 +47,17 @@ class TestScheduler:\n                 \"StatefulSet\",\n             ),\n             (\"LocalExecutor\", {\"celery\": {\"persistence\": {\"enabled\": False}}}, \"Deployment\"),\n-            # Test workers.persistence.enabled flag when celery one is default (expected no impact on kind)\n+            # Test workers.persistence.enabled flag when celery one is default\n             (\"CeleryExecutor\", {\"persistence\": {\"enabled\": False}}, \"Deployment\"),\n             (\"CeleryExecutor\", {\"persistence\": {\"enabled\": True}}, \"Deployment\"),\n             (\"CeleryKubernetesExecutor\", {\"persistence\": {\"enabled\": True}}, \"Deployment\"),\n             (\"CeleryExecutor,KubernetesExecutor\", {\"persistence\": {\"enabled\": True}}, \"Deployment\"),\n             (\"KubernetesExecutor\", {\"persistence\": {\"enabled\": True}}, \"Deployment\"),\n-            (\"LocalKubernetesExecutor\", {\"persistence\": {\"enabled\": False}}, \"StatefulSet\"),\n+            (\"LocalKubernetesExecutor\", {\"persistence\": {\"enabled\": False}}, \"Deployment\"),\n             (\"LocalKubernetesExecutor\", {\"persistence\": {\"enabled\": True}}, \"StatefulSet\"),\n             (\"LocalExecutor\", {\"persistence\": {\"enabled\": True}}, \"StatefulSet\"),\n             (\"LocalExecutor,KubernetesExecutor\", {\"persistence\": {\"enabled\": True}}, \"StatefulSet\"),\n-            (\"LocalExecutor\", {\"persistence\": {\"enabled\": False}}, \"StatefulSet\"),\n-            # Test workers.persistence.enabled flag when celery one is unset",
      "comment": "Tests were testing if the unset behaviour of `workers.celery` will bring back the previous behaviour of the chart (not breaking change behaviour), so if we are removing it, they are not needed",
      "comment_id": 2726021484,
      "user": "Miretpl",
      "created_at": "2026-01-25T23:34:20Z",
      "url": "https://github.com/apache/airflow/pull/61049#discussion_r2726021484"
    },
    {
      "repo": "apache/airflow",
      "pr_number": 55894,
      "file_path": "airflow-core/tests/unit/models/test_dagbag.py",
      "line": 950,
      "side": "RIGHT",
      "diff_hunk": "@@ -866,6 +866,98 @@ def mytask():\n             DagBag(dag_folder=os.fspath(tmp_path), include_examples=False)\n             assert \"SIGSEGV signal handler registration failed. Not in the main thread\" in caplog.text\n \n+    def test_bundle_path_is_in_syspath_during_parse(self, tmp_path):\n+        \"\"\"\n+        Test that bundle_path is correctly added to and removed from sys.path during DAG import.\n+        \"\"\"\n+        util_file = tmp_path / \"bundle_util.py\"\n+        util_file.write_text('def get_message(): return \"Hello from bundle!\"')\n+\n+        dag_file = tmp_path / \"test_dag.py\"\n+        dag_file.write_text(\n+            textwrap.dedent(\n+                \"\"\"\\\n+                from airflow import DAG\n+                from airflow.decorators import task\n+                import sys\n+                import bundle_util\n+\n+                with DAG('test_import', description=f\"DAG with sys.path: {sys.path}\"):\n+                    @task\n+                    def mytask():\n+                        print(util.get_message())\n+                    mytask()\n+                \"\"\"\n+            )\n+        )\n+        syspath_before = deepcopy(sys.path)\n+        assert str(tmp_path) not in sys.path  # bundle path is not in sys.path before bundle parse\n+        dagbag = DagBag(dag_folder=str(dag_file), bundle_path=tmp_path, include_examples=False)\n+\n+        # Check import was successful\n+        assert len(dagbag.dags) == 1\n+        assert not dagbag.import_errors\n+\n+        dag = dagbag.get_dag(\"test_import\")\n+        assert dag is not None\n+        assert str(tmp_path) in dag.description  # sys.path is enhanced during parse\n+\n+        assert str(tmp_path) not in sys.path  # bundle path is not preserved in sys.path\n+        assert sys.path == syspath_before  # sys.path doesn't change\n+\n+    def test_bundle_path_syspath_is_cleanup_on_failure(self, tmp_path):\n+        \"\"\"\n+        Test that bundle_path is correctly added to and removed from sys.path during DAG import.\n+        \"\"\"\n+        util_file = tmp_path / \"bundle_util.py\"\n+        util_file.write_text('def get_message(): return \"Hello from bundle!\"')\n+\n+        dag_file = tmp_path / \"test_dag.py\"\n+        dag_file.write_text(\n+            textwrap.dedent(\n+                \"\"\"\\\n+                from airflow import DAG\n+                from airflow.decorators import task\n+                import bundle_utils # typo\n+\n+                with DAG('test_import'):\n+                    @task\n+                    def mytask():\n+                        print(util.get_message())\n+                    mytask()\n+                \"\"\"\n+            )\n+        )\n+        syspath_before = deepcopy(sys.path)\n+        dagbag = DagBag(dag_folder=str(dag_file), bundle_path=tmp_path, include_examples=False)\n+\n+        assert dagbag.import_errors  # Check import failed\n+        assert sys.path == syspath_before  # sys.path doesn't change\n+\n+    def test_bundle_path_none_no_syspath_manipulation(self, tmp_path, caplog):\n+        \"\"\"\n+        Test that no sys.path manipulation occurs when bundle_path is None.\n+        \"\"\"\n+        dag_file = tmp_path / \"simple_dag.py\"\n+        dag_file.write_text(\n+            textwrap.dedent(\n+                \"\"\"\\\n+            from datetime import datetime\n+            from airflow.sdk import DAG, BaseOperator\n+            import sys\n+\n+            dag = DAG(\"simple_dag\", start_date=datetime(2021, 1, 1), schedule=None, description=f\"DAG with sys.path: {sys.path}\")\n+            t1 = BaseOperator(task_id=\"test_task\", dag=dag)",
      "comment": "```suggestion\n            with DAG(\"simple_dag\", description=f\"DAG with sys.path: {sys.path}\"):\n                ...\n```",
      "comment_id": 2365619747,
      "user": "jedcunningham",
      "created_at": "2025-09-20T12:50:26Z",
      "url": "https://github.com/apache/airflow/pull/55894#discussion_r2365619747"
    },
    {
      "repo": "apache/airflow",
      "pr_number": 55894,
      "file_path": "airflow-core/tests/unit/models/test_dagbag.py",
      "line": 881,
      "side": "RIGHT",
      "diff_hunk": "@@ -866,6 +866,98 @@ def mytask():\n             DagBag(dag_folder=os.fspath(tmp_path), include_examples=False)\n             assert \"SIGSEGV signal handler registration failed. Not in the main thread\" in caplog.text\n \n+    def test_bundle_path_is_in_syspath_during_parse(self, tmp_path):\n+        \"\"\"\n+        Test that bundle_path is correctly added to and removed from sys.path during DAG import.\n+        \"\"\"\n+        util_file = tmp_path / \"bundle_util.py\"\n+        util_file.write_text('def get_message(): return \"Hello from bundle!\"')\n+\n+        dag_file = tmp_path / \"test_dag.py\"\n+        dag_file.write_text(\n+            textwrap.dedent(\n+                \"\"\"\\\n+                from airflow import DAG\n+                from airflow.decorators import task",
      "comment": "```suggestion\n                from airflow.sdk import DAG\n```",
      "comment_id": 2365619889,
      "user": "jedcunningham",
      "created_at": "2025-09-20T12:50:50Z",
      "url": "https://github.com/apache/airflow/pull/55894#discussion_r2365619889"
    },
    {
      "repo": "apache/airflow",
      "pr_number": 55894,
      "file_path": "airflow-core/tests/unit/models/test_dagbag.py",
      "line": 919,
      "side": "RIGHT",
      "diff_hunk": "@@ -866,6 +866,98 @@ def mytask():\n             DagBag(dag_folder=os.fspath(tmp_path), include_examples=False)\n             assert \"SIGSEGV signal handler registration failed. Not in the main thread\" in caplog.text\n \n+    def test_bundle_path_is_in_syspath_during_parse(self, tmp_path):\n+        \"\"\"\n+        Test that bundle_path is correctly added to and removed from sys.path during DAG import.\n+        \"\"\"\n+        util_file = tmp_path / \"bundle_util.py\"\n+        util_file.write_text('def get_message(): return \"Hello from bundle!\"')\n+\n+        dag_file = tmp_path / \"test_dag.py\"\n+        dag_file.write_text(\n+            textwrap.dedent(\n+                \"\"\"\\\n+                from airflow import DAG\n+                from airflow.decorators import task\n+                import sys\n+                import bundle_util\n+\n+                with DAG('test_import', description=f\"DAG with sys.path: {sys.path}\"):\n+                    @task\n+                    def mytask():\n+                        print(util.get_message())\n+                    mytask()\n+                \"\"\"\n+            )\n+        )\n+        syspath_before = deepcopy(sys.path)\n+        assert str(tmp_path) not in sys.path  # bundle path is not in sys.path before bundle parse\n+        dagbag = DagBag(dag_folder=str(dag_file), bundle_path=tmp_path, include_examples=False)\n+\n+        # Check import was successful\n+        assert len(dagbag.dags) == 1\n+        assert not dagbag.import_errors\n+\n+        dag = dagbag.get_dag(\"test_import\")\n+        assert dag is not None\n+        assert str(tmp_path) in dag.description  # sys.path is enhanced during parse\n+\n+        assert str(tmp_path) not in sys.path  # bundle path is not preserved in sys.path\n+        assert sys.path == syspath_before  # sys.path doesn't change\n+\n+    def test_bundle_path_syspath_is_cleanup_on_failure(self, tmp_path):\n+        \"\"\"\n+        Test that bundle_path is correctly added to and removed from sys.path during DAG import.\n+        \"\"\"\n+        util_file = tmp_path / \"bundle_util.py\"\n+        util_file.write_text('def get_message(): return \"Hello from bundle!\"')\n+\n+        dag_file = tmp_path / \"test_dag.py\"\n+        dag_file.write_text(\n+            textwrap.dedent(\n+                \"\"\"\\\n+                from airflow import DAG\n+                from airflow.decorators import task",
      "comment": "```suggestion\n                from airflow.sdk import DAG\n```",
      "comment_id": 2365620029,
      "user": "jedcunningham",
      "created_at": "2025-09-20T12:51:14Z",
      "url": "https://github.com/apache/airflow/pull/55894#discussion_r2365620029"
    },
    {
      "repo": "apache/airflow",
      "pr_number": 55894,
      "file_path": "airflow-core/tests/unit/models/test_dagbag.py",
      "line": 945,
      "side": "RIGHT",
      "diff_hunk": "@@ -866,6 +866,98 @@ def mytask():\n             DagBag(dag_folder=os.fspath(tmp_path), include_examples=False)\n             assert \"SIGSEGV signal handler registration failed. Not in the main thread\" in caplog.text\n \n+    def test_bundle_path_is_in_syspath_during_parse(self, tmp_path):\n+        \"\"\"\n+        Test that bundle_path is correctly added to and removed from sys.path during DAG import.\n+        \"\"\"\n+        util_file = tmp_path / \"bundle_util.py\"\n+        util_file.write_text('def get_message(): return \"Hello from bundle!\"')\n+\n+        dag_file = tmp_path / \"test_dag.py\"\n+        dag_file.write_text(\n+            textwrap.dedent(\n+                \"\"\"\\\n+                from airflow import DAG\n+                from airflow.decorators import task\n+                import sys\n+                import bundle_util\n+\n+                with DAG('test_import', description=f\"DAG with sys.path: {sys.path}\"):\n+                    @task\n+                    def mytask():\n+                        print(util.get_message())\n+                    mytask()\n+                \"\"\"\n+            )\n+        )\n+        syspath_before = deepcopy(sys.path)\n+        assert str(tmp_path) not in sys.path  # bundle path is not in sys.path before bundle parse\n+        dagbag = DagBag(dag_folder=str(dag_file), bundle_path=tmp_path, include_examples=False)\n+\n+        # Check import was successful\n+        assert len(dagbag.dags) == 1\n+        assert not dagbag.import_errors\n+\n+        dag = dagbag.get_dag(\"test_import\")\n+        assert dag is not None\n+        assert str(tmp_path) in dag.description  # sys.path is enhanced during parse\n+\n+        assert str(tmp_path) not in sys.path  # bundle path is not preserved in sys.path\n+        assert sys.path == syspath_before  # sys.path doesn't change\n+\n+    def test_bundle_path_syspath_is_cleanup_on_failure(self, tmp_path):\n+        \"\"\"\n+        Test that bundle_path is correctly added to and removed from sys.path during DAG import.\n+        \"\"\"\n+        util_file = tmp_path / \"bundle_util.py\"\n+        util_file.write_text('def get_message(): return \"Hello from bundle!\"')\n+\n+        dag_file = tmp_path / \"test_dag.py\"\n+        dag_file.write_text(\n+            textwrap.dedent(\n+                \"\"\"\\\n+                from airflow import DAG\n+                from airflow.decorators import task\n+                import bundle_utils # typo\n+\n+                with DAG('test_import'):\n+                    @task\n+                    def mytask():\n+                        print(util.get_message())\n+                    mytask()\n+                \"\"\"\n+            )\n+        )\n+        syspath_before = deepcopy(sys.path)\n+        dagbag = DagBag(dag_folder=str(dag_file), bundle_path=tmp_path, include_examples=False)\n+\n+        assert dagbag.import_errors  # Check import failed\n+        assert sys.path == syspath_before  # sys.path doesn't change\n+\n+    def test_bundle_path_none_no_syspath_manipulation(self, tmp_path, caplog):\n+        \"\"\"\n+        Test that no sys.path manipulation occurs when bundle_path is None.\n+        \"\"\"\n+        dag_file = tmp_path / \"simple_dag.py\"\n+        dag_file.write_text(\n+            textwrap.dedent(\n+                \"\"\"\\\n+            from datetime import datetime\n+            from airflow.sdk import DAG, BaseOperator",
      "comment": "```suggestion\n            from airflow.sdk import DAG\n```",
      "comment_id": 2365621292,
      "user": "jedcunningham",
      "created_at": "2025-09-20T12:55:52Z",
      "url": "https://github.com/apache/airflow/pull/55894#discussion_r2365621292"
    },
    {
      "repo": "apache/airflow",
      "pr_number": 55894,
      "file_path": "airflow-core/src/airflow/models/dagbag.py",
      "line": 404,
      "side": "RIGHT",
      "diff_hunk": "@@ -398,12 +398,23 @@ def handler(signum, frame):\n \n         def parse(mod_name, filepath):\n             try:\n-                loader = importlib.machinery.SourceFileLoader(mod_name, filepath)\n-                spec = importlib.util.spec_from_loader(mod_name, loader)\n-                new_module = importlib.util.module_from_spec(spec)\n-                sys.modules[spec.name] = new_module\n-                loader.exec_module(new_module)\n-                return [new_module]\n+                # Add bundle path to sys.path if we have one\n+                bundle_path_added = False\n+                if self.bundle_path and str(self.bundle_path) not in sys.path:\n+                    sys.path.insert(0, str(self.bundle_path))",
      "comment": "Just looking at the diff, we were tossing it on the end previously. I think that makes sense too, lower priority than everything else.",
      "comment_id": 2365624011,
      "user": "jedcunningham",
      "created_at": "2025-09-20T13:06:23Z",
      "url": "https://github.com/apache/airflow/pull/55894#discussion_r2365624011"
    },
    {
      "repo": "apache/airflow",
      "pr_number": 55894,
      "file_path": "airflow-core/src/airflow/models/dagbag.py",
      "line": 404,
      "side": "RIGHT",
      "diff_hunk": "@@ -398,12 +398,23 @@ def handler(signum, frame):\n \n         def parse(mod_name, filepath):\n             try:\n-                loader = importlib.machinery.SourceFileLoader(mod_name, filepath)\n-                spec = importlib.util.spec_from_loader(mod_name, loader)\n-                new_module = importlib.util.module_from_spec(spec)\n-                sys.modules[spec.name] = new_module\n-                loader.exec_module(new_module)\n-                return [new_module]\n+                # Add bundle path to sys.path if we have one\n+                bundle_path_added = False\n+                if self.bundle_path and str(self.bundle_path) not in sys.path:\n+                    sys.path.insert(0, str(self.bundle_path))",
      "comment": "I would go with append, since it was used previously.",
      "comment_id": 2365724096,
      "user": "simi",
      "created_at": "2025-09-20T17:22:19Z",
      "url": "https://github.com/apache/airflow/pull/55894#discussion_r2365724096"
    },
    {
      "repo": "apache/airflow",
      "pr_number": 55894,
      "file_path": "airflow-core/tests/unit/models/test_dagbag.py",
      "line": 888,
      "side": "RIGHT",
      "diff_hunk": "@@ -866,6 +866,98 @@ def mytask():\n             DagBag(dag_folder=os.fspath(tmp_path), include_examples=False)\n             assert \"SIGSEGV signal handler registration failed. Not in the main thread\" in caplog.text\n \n+    def test_bundle_path_is_in_syspath_during_parse(self, tmp_path):\n+        \"\"\"\n+        Test that bundle_path is correctly added to and removed from sys.path during DAG import.\n+        \"\"\"\n+        util_file = tmp_path / \"bundle_util.py\"\n+        util_file.write_text('def get_message(): return \"Hello from bundle!\"')\n+\n+        dag_file = tmp_path / \"test_dag.py\"\n+        dag_file.write_text(\n+            textwrap.dedent(\n+                \"\"\"\\\n+                from airflow import DAG\n+                from airflow.decorators import task\n+                import sys\n+                import bundle_util\n+\n+                with DAG('test_import', description=f\"DAG with sys.path: {sys.path}\"):\n+                    @task\n+                    def mytask():\n+                        print(util.get_message())\n+                    mytask()",
      "comment": "Stylistic ultimately, but I'd remove them or use EmptyOperator.",
      "comment_id": 2373450473,
      "user": "jedcunningham",
      "created_at": "2025-09-23T21:05:35Z",
      "url": "https://github.com/apache/airflow/pull/55894#discussion_r2373450473"
    },
    {
      "repo": "apache/airflow",
      "pr_number": 55894,
      "file_path": "airflow-core/tests/unit/models/test_dagbag.py",
      "line": 919,
      "side": "RIGHT",
      "diff_hunk": "@@ -866,6 +866,98 @@ def mytask():\n             DagBag(dag_folder=os.fspath(tmp_path), include_examples=False)\n             assert \"SIGSEGV signal handler registration failed. Not in the main thread\" in caplog.text\n \n+    def test_bundle_path_is_in_syspath_during_parse(self, tmp_path):\n+        \"\"\"\n+        Test that bundle_path is correctly added to and removed from sys.path during DAG import.\n+        \"\"\"\n+        util_file = tmp_path / \"bundle_util.py\"\n+        util_file.write_text('def get_message(): return \"Hello from bundle!\"')\n+\n+        dag_file = tmp_path / \"test_dag.py\"\n+        dag_file.write_text(\n+            textwrap.dedent(\n+                \"\"\"\\\n+                from airflow import DAG\n+                from airflow.decorators import task\n+                import sys\n+                import bundle_util\n+\n+                with DAG('test_import', description=f\"DAG with sys.path: {sys.path}\"):\n+                    @task\n+                    def mytask():\n+                        print(util.get_message())\n+                    mytask()\n+                \"\"\"\n+            )\n+        )\n+        syspath_before = deepcopy(sys.path)\n+        assert str(tmp_path) not in sys.path  # bundle path is not in sys.path before bundle parse\n+        dagbag = DagBag(dag_folder=str(dag_file), bundle_path=tmp_path, include_examples=False)\n+\n+        # Check import was successful\n+        assert len(dagbag.dags) == 1\n+        assert not dagbag.import_errors\n+\n+        dag = dagbag.get_dag(\"test_import\")\n+        assert dag is not None\n+        assert str(tmp_path) in dag.description  # sys.path is enhanced during parse\n+\n+        assert str(tmp_path) not in sys.path  # bundle path is not preserved in sys.path\n+        assert sys.path == syspath_before  # sys.path doesn't change\n+\n+    def test_bundle_path_syspath_is_cleanup_on_failure(self, tmp_path):\n+        \"\"\"\n+        Test that bundle_path is correctly added to and removed from sys.path during DAG import.\n+        \"\"\"\n+        util_file = tmp_path / \"bundle_util.py\"\n+        util_file.write_text('def get_message(): return \"Hello from bundle!\"')\n+\n+        dag_file = tmp_path / \"test_dag.py\"\n+        dag_file.write_text(\n+            textwrap.dedent(\n+                \"\"\"\\\n+                from airflow import DAG\n+                from airflow.decorators import task",
      "comment": "These are more important though, import everything from sdk not the old locations.",
      "comment_id": 2373452126,
      "user": "jedcunningham",
      "created_at": "2025-09-23T21:06:32Z",
      "url": "https://github.com/apache/airflow/pull/55894#discussion_r2373452126"
    },
    {
      "repo": "apache/airflow",
      "pr_number": 55894,
      "file_path": "airflow-core/tests/unit/models/test_dagbag.py",
      "line": 881,
      "side": "RIGHT",
      "diff_hunk": "@@ -866,6 +866,95 @@ def mytask():\n             DagBag(dag_folder=os.fspath(tmp_path), include_examples=False)\n             assert \"SIGSEGV signal handler registration failed. Not in the main thread\" in caplog.text\n \n+    def test_bundle_path_is_in_syspath_during_parse(self, tmp_path):\n+        \"\"\"\n+        Test that bundle_path is correctly added to and removed from sys.path during DAG import.\n+        \"\"\"\n+        util_file = tmp_path / \"bundle_util.py\"\n+        util_file.write_text('def get_message(): return \"Hello from bundle!\"')\n+\n+        dag_file = tmp_path / \"test_dag.py\"\n+        dag_file.write_text(\n+            textwrap.dedent(\n+                \"\"\"\\\n+                from airflow.sdk import DAG\n+                from airflow.operators.empty import EmptyOperator",
      "comment": "```suggestion\n                from airflow.providers.standard.operators.empty import EmptyOperator\n```",
      "comment_id": 2376038497,
      "user": "jedcunningham",
      "created_at": "2025-09-24T14:39:31Z",
      "url": "https://github.com/apache/airflow/pull/55894#discussion_r2376038497"
    },
    {
      "repo": "apache/airflow",
      "pr_number": 55894,
      "file_path": "airflow-core/tests/unit/models/test_dagbag.py",
      "line": 918,
      "side": "RIGHT",
      "diff_hunk": "@@ -866,6 +866,95 @@ def mytask():\n             DagBag(dag_folder=os.fspath(tmp_path), include_examples=False)\n             assert \"SIGSEGV signal handler registration failed. Not in the main thread\" in caplog.text\n \n+    def test_bundle_path_is_in_syspath_during_parse(self, tmp_path):\n+        \"\"\"\n+        Test that bundle_path is correctly added to and removed from sys.path during DAG import.\n+        \"\"\"\n+        util_file = tmp_path / \"bundle_util.py\"\n+        util_file.write_text('def get_message(): return \"Hello from bundle!\"')\n+\n+        dag_file = tmp_path / \"test_dag.py\"\n+        dag_file.write_text(\n+            textwrap.dedent(\n+                \"\"\"\\\n+                from airflow.sdk import DAG\n+                from airflow.operators.empty import EmptyOperator\n+\n+                import sys\n+                import bundle_util\n+\n+                with DAG('test_import', description=f\"DAG with sys.path: {sys.path}\"):\n+                    EmptyOperator(task_id=\"mytask\")\n+                \"\"\"\n+            )\n+        )\n+        syspath_before = deepcopy(sys.path)\n+        assert str(tmp_path) not in sys.path  # bundle path is not in sys.path before bundle parse\n+        dagbag = DagBag(dag_folder=str(dag_file), bundle_path=tmp_path, include_examples=False)\n+\n+        # Check import was successful\n+        assert len(dagbag.dags) == 1\n+        assert not dagbag.import_errors\n+\n+        dag = dagbag.get_dag(\"test_import\")\n+        assert dag is not None\n+        assert str(tmp_path) in dag.description  # sys.path is enhanced during parse\n+\n+        assert str(tmp_path) not in sys.path  # bundle path is not preserved in sys.path\n+        assert sys.path == syspath_before  # sys.path doesn't change\n+\n+    def test_bundle_path_syspath_is_cleanup_on_failure(self, tmp_path):\n+        \"\"\"\n+        Test that bundle_path is correctly added to and removed from sys.path during DAG import.\n+        \"\"\"\n+        util_file = tmp_path / \"bundle_util.py\"\n+        util_file.write_text('def get_message(): return \"Hello from bundle!\"')\n+\n+        dag_file = tmp_path / \"test_dag.py\"\n+        dag_file.write_text(\n+            textwrap.dedent(\n+                \"\"\"\\\n+                from airflow.sdk import DAG\n+                from airflow.operators.empty import EmptyOperator",
      "comment": "```suggestion\n                from airflow.providers.standard.operators.empty import EmptyOperator\n```",
      "comment_id": 2376039076,
      "user": "jedcunningham",
      "created_at": "2025-09-24T14:39:44Z",
      "url": "https://github.com/apache/airflow/pull/55894#discussion_r2376039076"
    },
    {
      "repo": "apache/airflow",
      "pr_number": 55894,
      "file_path": "airflow-core/tests/unit/models/test_dagbag.py",
      "line": 942,
      "side": "RIGHT",
      "diff_hunk": "@@ -866,6 +866,95 @@ def mytask():\n             DagBag(dag_folder=os.fspath(tmp_path), include_examples=False)\n             assert \"SIGSEGV signal handler registration failed. Not in the main thread\" in caplog.text\n \n+    def test_bundle_path_is_in_syspath_during_parse(self, tmp_path):\n+        \"\"\"\n+        Test that bundle_path is correctly added to and removed from sys.path during DAG import.\n+        \"\"\"\n+        util_file = tmp_path / \"bundle_util.py\"\n+        util_file.write_text('def get_message(): return \"Hello from bundle!\"')\n+\n+        dag_file = tmp_path / \"test_dag.py\"\n+        dag_file.write_text(\n+            textwrap.dedent(\n+                \"\"\"\\\n+                from airflow.sdk import DAG\n+                from airflow.operators.empty import EmptyOperator\n+\n+                import sys\n+                import bundle_util\n+\n+                with DAG('test_import', description=f\"DAG with sys.path: {sys.path}\"):\n+                    EmptyOperator(task_id=\"mytask\")\n+                \"\"\"\n+            )\n+        )\n+        syspath_before = deepcopy(sys.path)\n+        assert str(tmp_path) not in sys.path  # bundle path is not in sys.path before bundle parse\n+        dagbag = DagBag(dag_folder=str(dag_file), bundle_path=tmp_path, include_examples=False)\n+\n+        # Check import was successful\n+        assert len(dagbag.dags) == 1\n+        assert not dagbag.import_errors\n+\n+        dag = dagbag.get_dag(\"test_import\")\n+        assert dag is not None\n+        assert str(tmp_path) in dag.description  # sys.path is enhanced during parse\n+\n+        assert str(tmp_path) not in sys.path  # bundle path is not preserved in sys.path\n+        assert sys.path == syspath_before  # sys.path doesn't change\n+\n+    def test_bundle_path_syspath_is_cleanup_on_failure(self, tmp_path):\n+        \"\"\"\n+        Test that bundle_path is correctly added to and removed from sys.path during DAG import.\n+        \"\"\"\n+        util_file = tmp_path / \"bundle_util.py\"\n+        util_file.write_text('def get_message(): return \"Hello from bundle!\"')\n+\n+        dag_file = tmp_path / \"test_dag.py\"\n+        dag_file.write_text(\n+            textwrap.dedent(\n+                \"\"\"\\\n+                from airflow.sdk import DAG\n+                from airflow.operators.empty import EmptyOperator\n+\n+                import bundle_utils # typo\n+\n+                with DAG('test_import'):\n+                    EmptyOperator(task_id=\"mytask\")\n+                \"\"\"\n+            )\n+        )\n+        syspath_before = deepcopy(sys.path)\n+        dagbag = DagBag(dag_folder=str(dag_file), bundle_path=tmp_path, include_examples=False)\n+\n+        assert dagbag.import_errors  # Check import failed\n+        assert sys.path == syspath_before  # sys.path doesn't change\n+\n+    def test_bundle_path_none_no_syspath_manipulation(self, tmp_path, caplog):\n+        \"\"\"\n+        Test that no sys.path manipulation occurs when bundle_path is None.\n+        \"\"\"\n+        dag_file = tmp_path / \"simple_dag.py\"\n+        dag_file.write_text(\n+            textwrap.dedent(\n+                \"\"\"\\\n+                from airflow.sdk import DAG\n+                from airflow.operators.empty import EmptyOperator",
      "comment": "```suggestion\n                from airflow.providers.standard.operators.empty import EmptyOperator\n```",
      "comment_id": 2376039741,
      "user": "jedcunningham",
      "created_at": "2025-09-24T14:39:56Z",
      "url": "https://github.com/apache/airflow/pull/55894#discussion_r2376039741"
    },
    {
      "repo": "apache/airflow",
      "pr_number": 55894,
      "file_path": "airflow-core/src/airflow/dag_processing/dagbag.py",
      "line": 243,
      "side": "RIGHT",
      "diff_hunk": "@@ -235,6 +235,13 @@ def __init__(\n         self.bundle_path = bundle_path\n         self.bundle_name = bundle_name\n \n+        # Add bundle path to sys.path if provided.\n+        # This allows DAG files to import modules from their bundle directory.\n+        # No cleanup is performed - this is intentional for ephemeral processes\n+        # (dag processor, task runner, CLI) where the process exits after use.\n+        if bundle_path and str(bundle_path) not in sys.path:\n+            sys.path.append(str(bundle_path))",
      "comment": "It is extremely counter-intuitive that creating a DagBag object has a system-wide side effect. I would argue this is worse than the previous approach.",
      "comment_id": 2664707910,
      "user": "uranusjr",
      "created_at": "2026-01-06T12:04:38Z",
      "url": "https://github.com/apache/airflow/pull/55894#discussion_r2664707910"
    },
    {
      "repo": "apache/airflow",
      "pr_number": 55894,
      "file_path": "airflow-core/src/airflow/dag_processing/dagbag.py",
      "line": 243,
      "side": "RIGHT",
      "diff_hunk": "@@ -235,6 +235,13 @@ def __init__(\n         self.bundle_path = bundle_path\n         self.bundle_name = bundle_name\n \n+        # Add bundle path to sys.path if provided.\n+        # This allows DAG files to import modules from their bundle directory.\n+        # No cleanup is performed - this is intentional for ephemeral processes\n+        # (dag processor, task runner, CLI) where the process exits after use.\n+        if bundle_path and str(bundle_path) not in sys.path:\n+            sys.path.append(str(bundle_path))",
      "comment": "Yes, I have moved this into draft. I'm working on better sollution.",
      "comment_id": 2664725541,
      "user": "simi",
      "created_at": "2026-01-06T12:11:32Z",
      "url": "https://github.com/apache/airflow/pull/55894#discussion_r2664725541"
    },
    {
      "repo": "apache/airflow",
      "pr_number": 55894,
      "file_path": "airflow-core/src/airflow/cli/commands/dag_command.py",
      "line": 534,
      "side": "RIGHT",
      "diff_hunk": "@@ -526,7 +530,9 @@ def dag_report(args) -> None:\n         if bundle.name not in bundles_to_reserialize:\n             continue\n         bundle.initialize()\n-        dagbag = DagBag(bundle.path, bundle_name=bundle.name, include_examples=False)\n+        dagbag = BundleDagBag(\n+            bundle.path, bundle_path=bundle.path, bundle_name=bundle.name, include_examples=False",
      "comment": "`include_examples` should always be False when loading from a bundle (because example dags are not in the bundle\u2026 obviously), so this should be handled in BundleDagBag\u2019s `__init__` instead of repeated in every instantiation.",
      "comment_id": 2671391877,
      "user": "uranusjr",
      "created_at": "2026-01-08T08:26:30Z",
      "url": "https://github.com/apache/airflow/pull/55894#discussion_r2671391877"
    },
    {
      "repo": "apache/airflow",
      "pr_number": 60532,
      "file_path": "providers/cncf/kubernetes/src/airflow/providers/cncf/kubernetes/hooks/kubernetes.py",
      "line": 824,
      "side": "RIGHT",
      "diff_hunk": "@@ -816,48 +816,54 @@ def __init__(\n         self.config_dict = config_dict\n         self._extras: dict | None = connection_extras\n         self._event_polling_fallback = False\n+        self._config_loaded = False\n \n     async def _load_config(self):\n-        \"\"\"Return Kubernetes API session for use with requests.\"\"\"\n+        \"\"\"Load Kubernetes configuration once per hook instance.\"\"\"\n+        if self._config_loaded:\n+            return",
      "comment": "Instead of an internal flag, would it be easier to use the `@cache` decorator?",
      "comment_id": 2723071788,
      "user": "jscheffl",
      "created_at": "2026-01-23T22:29:03Z",
      "url": "https://github.com/apache/airflow/pull/60532#discussion_r2723071788"
    },
    {
      "repo": "apache/airflow",
      "pr_number": 60532,
      "file_path": "providers/cncf/kubernetes/src/airflow/providers/cncf/kubernetes/hooks/kubernetes.py",
      "line": 845,
      "side": "RIGHT",
      "diff_hunk": "@@ -816,48 +816,54 @@ def __init__(\n         self.config_dict = config_dict\n         self._extras: dict | None = connection_extras\n         self._event_polling_fallback = False\n+        self._config_loaded = False\n \n     async def _load_config(self):\n-        \"\"\"Return Kubernetes API session for use with requests.\"\"\"\n+        \"\"\"Load Kubernetes configuration once per hook instance.\"\"\"\n+        if self._config_loaded:\n+            return\n+\n         in_cluster = self._coalesce_param(self.in_cluster, await self._get_field(\"in_cluster\"))\n         cluster_context = self._coalesce_param(self.cluster_context, await self._get_field(\"cluster_context\"))\n         kubeconfig_path = await self._get_field(\"kube_config_path\")\n         kubeconfig = await self._get_field(\"kube_config\")\n+\n         num_selected_configuration = sum(\n             1 for o in [in_cluster, kubeconfig, kubeconfig_path, self.config_dict] if o\n         )\n \n-        async def api_client_from_kubeconfig_file(_kubeconfig_path: str | None):\n-            await async_config.load_kube_config(\n-                config_file=_kubeconfig_path,\n-                client_configuration=self.client_configuration,\n-                context=cluster_context,\n-            )\n-            return _TimeoutAsyncK8sApiClient()\n-\n         if num_selected_configuration > 1:\n             raise AirflowException(\n                 \"Invalid connection configuration. Options kube_config_path, \"\n-                \"kube_config, in_cluster are mutually exclusive. \"\n+                \"kube_config, in_cluster, and config_dict are mutually exclusive. \"\n                 \"You can only use one option at a time.\"\n             )\n \n         if in_cluster:\n             self.log.debug(LOADING_KUBE_CONFIG_FILE_RESOURCE.format(\"within a pod\"))\n-            self._is_in_cluster = True\n             async_config.load_incluster_config()\n-            return _TimeoutAsyncK8sApiClient()\n+            self._is_in_cluster = True",
      "comment": "Why do you add another flag if `in_cluster` is existing as well?",
      "comment_id": 2723075408,
      "user": "jscheffl",
      "created_at": "2026-01-23T22:31:07Z",
      "url": "https://github.com/apache/airflow/pull/60532#discussion_r2723075408"
    },
    {
      "repo": "apache/airflow",
      "pr_number": 60532,
      "file_path": "providers/cncf/kubernetes/src/airflow/providers/cncf/kubernetes/hooks/kubernetes.py",
      "line": 824,
      "side": "RIGHT",
      "diff_hunk": "@@ -816,48 +816,54 @@ def __init__(\n         self.config_dict = config_dict\n         self._extras: dict | None = connection_extras\n         self._event_polling_fallback = False\n+        self._config_loaded = False\n \n     async def _load_config(self):\n-        \"\"\"Return Kubernetes API session for use with requests.\"\"\"\n+        \"\"\"Load Kubernetes configuration once per hook instance.\"\"\"\n+        if self._config_loaded:\n+            return",
      "comment": "I considered that but the `@cache` decorator caches the coroutine and not awaited result. After the first invocation, you will run into the following error:\r\n\r\n`RuntimeError: cannot reuse already awaited coroutine` \r\n\r\nThat\u2019s why I went with an explicit instance-level flag and guard here. Happy to clarify further if you had a different pattern in mind.",
      "comment_id": 2724050485,
      "user": "SameerMesiah97",
      "created_at": "2026-01-24T11:13:33Z",
      "url": "https://github.com/apache/airflow/pull/60532#discussion_r2724050485"
    },
    {
      "repo": "apache/airflow",
      "pr_number": 60532,
      "file_path": "providers/cncf/kubernetes/src/airflow/providers/cncf/kubernetes/hooks/kubernetes.py",
      "line": 845,
      "side": "RIGHT",
      "diff_hunk": "@@ -816,48 +816,54 @@ def __init__(\n         self.config_dict = config_dict\n         self._extras: dict | None = connection_extras\n         self._event_polling_fallback = False\n+        self._config_loaded = False\n \n     async def _load_config(self):\n-        \"\"\"Return Kubernetes API session for use with requests.\"\"\"\n+        \"\"\"Load Kubernetes configuration once per hook instance.\"\"\"\n+        if self._config_loaded:\n+            return\n+\n         in_cluster = self._coalesce_param(self.in_cluster, await self._get_field(\"in_cluster\"))\n         cluster_context = self._coalesce_param(self.cluster_context, await self._get_field(\"cluster_context\"))\n         kubeconfig_path = await self._get_field(\"kube_config_path\")\n         kubeconfig = await self._get_field(\"kube_config\")\n+\n         num_selected_configuration = sum(\n             1 for o in [in_cluster, kubeconfig, kubeconfig_path, self.config_dict] if o\n         )\n \n-        async def api_client_from_kubeconfig_file(_kubeconfig_path: str | None):\n-            await async_config.load_kube_config(\n-                config_file=_kubeconfig_path,\n-                client_configuration=self.client_configuration,\n-                context=cluster_context,\n-            )\n-            return _TimeoutAsyncK8sApiClient()\n-\n         if num_selected_configuration > 1:\n             raise AirflowException(\n                 \"Invalid connection configuration. Options kube_config_path, \"\n-                \"kube_config, in_cluster are mutually exclusive. \"\n+                \"kube_config, in_cluster, and config_dict are mutually exclusive. \"\n                 \"You can only use one option at a time.\"\n             )\n \n         if in_cluster:\n             self.log.debug(LOADING_KUBE_CONFIG_FILE_RESOURCE.format(\"within a pod\"))\n-            self._is_in_cluster = True\n             async_config.load_incluster_config()\n-            return _TimeoutAsyncK8sApiClient()\n+            self._is_in_cluster = True",
      "comment": "`self._is_in_cluster` is already present in the existing code. I just moved it after `async_config.load_incluster_config()` and git is interpreting that as a new line being removed and added. ",
      "comment_id": 2724052606,
      "user": "SameerMesiah97",
      "created_at": "2026-01-24T11:17:59Z",
      "url": "https://github.com/apache/airflow/pull/60532#discussion_r2724052606"
    },
    {
      "repo": "apache/airflow",
      "pr_number": 60532,
      "file_path": "providers/cncf/kubernetes/src/airflow/providers/cncf/kubernetes/hooks/kubernetes.py",
      "line": 824,
      "side": "RIGHT",
      "diff_hunk": "@@ -816,48 +816,54 @@ def __init__(\n         self.config_dict = config_dict\n         self._extras: dict | None = connection_extras\n         self._event_polling_fallback = False\n+        self._config_loaded = False\n \n     async def _load_config(self):\n-        \"\"\"Return Kubernetes API session for use with requests.\"\"\"\n+        \"\"\"Load Kubernetes configuration once per hook instance.\"\"\"\n+        if self._config_loaded:\n+            return",
      "comment": "Ah, that is a good reason. Did not consider the `async`dependency. Yes and before adding the complexity of `aiocache` I assume another attribute is reasonable.",
      "comment_id": 2724162642,
      "user": "jscheffl",
      "created_at": "2026-01-24T13:35:24Z",
      "url": "https://github.com/apache/airflow/pull/60532#discussion_r2724162642"
    },
    {
      "repo": "apache/airflow",
      "pr_number": 60973,
      "file_path": "providers/imap/src/airflow/providers/imap/hooks/imap.py",
      "line": 28,
      "side": "RIGHT",
      "diff_hunk": "@@ -25,6 +25,7 @@\n \n import email\n import imaplib\n+import itertools",
      "comment": "This seems unrelated to this PR. Please remove any changes from the provider `imap` from this PR",
      "comment_id": 2721767835,
      "user": "vincbeck",
      "created_at": "2026-01-23T15:44:58Z",
      "url": "https://github.com/apache/airflow/pull/60973#discussion_r2721767835"
    },
    {
      "repo": "apache/airflow",
      "pr_number": 60973,
      "file_path": "providers/imap/src/airflow/providers/imap/hooks/imap.py",
      "line": 28,
      "side": "RIGHT",
      "diff_hunk": "@@ -25,6 +25,7 @@\n \n import email\n import imaplib\n+import itertools",
      "comment": "Sorry about that! I was working on another issue and accidentally included these changes. Removed now.",
      "comment_id": 2721848580,
      "user": "Fury0508",
      "created_at": "2026-01-23T16:06:09Z",
      "url": "https://github.com/apache/airflow/pull/60973#discussion_r2721848580"
    },
    {
      "repo": "apache/airflow",
      "pr_number": 60973,
      "file_path": "providers/fab/src/airflow/providers/fab/auth_manager/api_fastapi/routes/users.py",
      "line": 133,
      "side": "RIGHT",
      "diff_hunk": "@@ -45,3 +51,83 @@\n def create_user(body: UserBody) -> UserResponse:\n     with get_application_builder():\n         return FABAuthManagerUsers.create_user(body=body)\n+\n+\n+@users_router.get(\n+    \"/users\",\n+    response_model=UserCollectionResponse,\n+    responses=create_openapi_http_exception_doc(\n+        [\n+            status.HTTP_400_BAD_REQUEST,\n+            status.HTTP_401_UNAUTHORIZED,\n+            status.HTTP_403_FORBIDDEN,\n+        ]\n+    ),\n+    dependencies=[Depends(requires_fab_custom_view(\"GET\", permissions.RESOURCE_USER))],\n+)\n+def get_users(\n+    order_by: str = Query(\"id\", description=\"Field to order by. Prefix with '-' for descending.\"),\n+    limit: int = Depends(get_effective_limit()),\n+    offset: int = Query(0, ge=0, description=\"Number of items to skip before starting to collect results.\"),\n+) -> UserCollectionResponse:\n+    \"\"\"List users with pagination and ordering.\"\"\"\n+    with get_application_builder():\n+        return FABAuthManagerUsers.get_users(order_by=order_by, limit=limit, offset=offset)\n+\n+\n+@users_router.get(\n+    \"/users/{username}\",\n+    responses=create_openapi_http_exception_doc(\n+        [\n+            status.HTTP_401_UNAUTHORIZED,\n+            status.HTTP_403_FORBIDDEN,\n+            status.HTTP_404_NOT_FOUND,\n+        ]\n+    ),\n+    dependencies=[Depends(requires_fab_custom_view(\"GET\", permissions.RESOURCE_USER))],\n+)\n+def get_user(username: str = Path(..., min_length=1)) -> UserResponse:\n+    \"\"\"Get a user by username.\"\"\"\n+    with get_application_builder():\n+        return FABAuthManagerUsers.get_user(username=username)\n+\n+\n+@users_router.patch(\n+    \"/users/{username}\",\n+    responses=create_openapi_http_exception_doc(\n+        [\n+            status.HTTP_400_BAD_REQUEST,\n+            status.HTTP_401_UNAUTHORIZED,\n+            status.HTTP_403_FORBIDDEN,\n+            status.HTTP_404_NOT_FOUND,\n+            status.HTTP_409_CONFLICT,\n+        ]\n+    ),\n+    dependencies=[Depends(requires_fab_custom_view(\"PUT\", permissions.RESOURCE_USER))],\n+)\n+def update_user(\n+    body: UserPatchBody,\n+    username: str = Path(..., min_length=1),\n+    update_mask: str | None = Query(None, description=\"Comma-separated list of fields to update\"),\n+) -> UserResponse:\n+    \"\"\"Update an existing user.\"\"\"\n+    with get_application_builder():\n+        return FABAuthManagerUsers.update_user(username=username, body=body, update_mask=update_mask)\n+\n+\n+@users_router.delete(\n+    \"/users/{username}\",\n+    status_code=status.HTTP_204_NO_CONTENT,\n+    responses=create_openapi_http_exception_doc(\n+        [\n+            status.HTTP_401_UNAUTHORIZED,\n+            status.HTTP_403_FORBIDDEN,\n+            status.HTTP_404_NOT_FOUND,\n+        ]\n+    ),\n+    dependencies=[Depends(requires_fab_custom_view(\"DELETE\", permissions.RESOURCE_USER))],\n+)\n+def delete_user(username: str = Path(..., min_length=1)) -> None:\n+    \"\"\"Delete a user by username.\"\"\"\n+    with get_application_builder():\n+        FABAuthManagerUsers.delete_user(username=username)",
      "comment": "I think it should be \n```\ndef delete_user(username: str = Path(..., min_length=1)):\n    with get_application_builder():\n        FABAuthManagerUsers.delete_user(username=username)\n\n    return Response(status_code=status.HTTP_204_NO_CONTENT)\n```\n",
      "comment_id": 2722821291,
      "user": "henry3260",
      "created_at": "2026-01-23T20:59:08Z",
      "url": "https://github.com/apache/airflow/pull/60973#discussion_r2722821291"
    },
    {
      "repo": "apache/airflow",
      "pr_number": 60973,
      "file_path": "providers/fab/src/airflow/providers/fab/auth_manager/api_fastapi/routes/users.py",
      "line": 133,
      "side": "RIGHT",
      "diff_hunk": "@@ -45,3 +51,83 @@\n def create_user(body: UserBody) -> UserResponse:\n     with get_application_builder():\n         return FABAuthManagerUsers.create_user(body=body)\n+\n+\n+@users_router.get(\n+    \"/users\",\n+    response_model=UserCollectionResponse,\n+    responses=create_openapi_http_exception_doc(\n+        [\n+            status.HTTP_400_BAD_REQUEST,\n+            status.HTTP_401_UNAUTHORIZED,\n+            status.HTTP_403_FORBIDDEN,\n+        ]\n+    ),\n+    dependencies=[Depends(requires_fab_custom_view(\"GET\", permissions.RESOURCE_USER))],\n+)\n+def get_users(\n+    order_by: str = Query(\"id\", description=\"Field to order by. Prefix with '-' for descending.\"),\n+    limit: int = Depends(get_effective_limit()),\n+    offset: int = Query(0, ge=0, description=\"Number of items to skip before starting to collect results.\"),\n+) -> UserCollectionResponse:\n+    \"\"\"List users with pagination and ordering.\"\"\"\n+    with get_application_builder():\n+        return FABAuthManagerUsers.get_users(order_by=order_by, limit=limit, offset=offset)\n+\n+\n+@users_router.get(\n+    \"/users/{username}\",\n+    responses=create_openapi_http_exception_doc(\n+        [\n+            status.HTTP_401_UNAUTHORIZED,\n+            status.HTTP_403_FORBIDDEN,\n+            status.HTTP_404_NOT_FOUND,\n+        ]\n+    ),\n+    dependencies=[Depends(requires_fab_custom_view(\"GET\", permissions.RESOURCE_USER))],\n+)\n+def get_user(username: str = Path(..., min_length=1)) -> UserResponse:\n+    \"\"\"Get a user by username.\"\"\"\n+    with get_application_builder():\n+        return FABAuthManagerUsers.get_user(username=username)\n+\n+\n+@users_router.patch(\n+    \"/users/{username}\",\n+    responses=create_openapi_http_exception_doc(\n+        [\n+            status.HTTP_400_BAD_REQUEST,\n+            status.HTTP_401_UNAUTHORIZED,\n+            status.HTTP_403_FORBIDDEN,\n+            status.HTTP_404_NOT_FOUND,\n+            status.HTTP_409_CONFLICT,\n+        ]\n+    ),\n+    dependencies=[Depends(requires_fab_custom_view(\"PUT\", permissions.RESOURCE_USER))],\n+)\n+def update_user(\n+    body: UserPatchBody,\n+    username: str = Path(..., min_length=1),\n+    update_mask: str | None = Query(None, description=\"Comma-separated list of fields to update\"),\n+) -> UserResponse:\n+    \"\"\"Update an existing user.\"\"\"\n+    with get_application_builder():\n+        return FABAuthManagerUsers.update_user(username=username, body=body, update_mask=update_mask)\n+\n+\n+@users_router.delete(\n+    \"/users/{username}\",\n+    status_code=status.HTTP_204_NO_CONTENT,\n+    responses=create_openapi_http_exception_doc(\n+        [\n+            status.HTTP_401_UNAUTHORIZED,\n+            status.HTTP_403_FORBIDDEN,\n+            status.HTTP_404_NOT_FOUND,\n+        ]\n+    ),\n+    dependencies=[Depends(requires_fab_custom_view(\"DELETE\", permissions.RESOURCE_USER))],\n+)\n+def delete_user(username: str = Path(..., min_length=1)) -> None:\n+    \"\"\"Delete a user by username.\"\"\"\n+    with get_application_builder():\n+        FABAuthManagerUsers.delete_user(username=username)",
      "comment": "We usually do not do that. Can you try with removing the type annotation `-> None`? And see what the CI says",
      "comment_id": 2722918856,
      "user": "vincbeck",
      "created_at": "2026-01-23T21:33:43Z",
      "url": "https://github.com/apache/airflow/pull/60973#discussion_r2722918856"
    },
    {
      "repo": "apache/airflow",
      "pr_number": 60973,
      "file_path": "providers/fab/src/airflow/providers/fab/auth_manager/api_fastapi/routes/users.py",
      "line": 133,
      "side": "RIGHT",
      "diff_hunk": "@@ -45,3 +51,83 @@\n def create_user(body: UserBody) -> UserResponse:\n     with get_application_builder():\n         return FABAuthManagerUsers.create_user(body=body)\n+\n+\n+@users_router.get(\n+    \"/users\",\n+    response_model=UserCollectionResponse,\n+    responses=create_openapi_http_exception_doc(\n+        [\n+            status.HTTP_400_BAD_REQUEST,\n+            status.HTTP_401_UNAUTHORIZED,\n+            status.HTTP_403_FORBIDDEN,\n+        ]\n+    ),\n+    dependencies=[Depends(requires_fab_custom_view(\"GET\", permissions.RESOURCE_USER))],\n+)\n+def get_users(\n+    order_by: str = Query(\"id\", description=\"Field to order by. Prefix with '-' for descending.\"),\n+    limit: int = Depends(get_effective_limit()),\n+    offset: int = Query(0, ge=0, description=\"Number of items to skip before starting to collect results.\"),\n+) -> UserCollectionResponse:\n+    \"\"\"List users with pagination and ordering.\"\"\"\n+    with get_application_builder():\n+        return FABAuthManagerUsers.get_users(order_by=order_by, limit=limit, offset=offset)\n+\n+\n+@users_router.get(\n+    \"/users/{username}\",\n+    responses=create_openapi_http_exception_doc(\n+        [\n+            status.HTTP_401_UNAUTHORIZED,\n+            status.HTTP_403_FORBIDDEN,\n+            status.HTTP_404_NOT_FOUND,\n+        ]\n+    ),\n+    dependencies=[Depends(requires_fab_custom_view(\"GET\", permissions.RESOURCE_USER))],\n+)\n+def get_user(username: str = Path(..., min_length=1)) -> UserResponse:\n+    \"\"\"Get a user by username.\"\"\"\n+    with get_application_builder():\n+        return FABAuthManagerUsers.get_user(username=username)\n+\n+\n+@users_router.patch(\n+    \"/users/{username}\",\n+    responses=create_openapi_http_exception_doc(\n+        [\n+            status.HTTP_400_BAD_REQUEST,\n+            status.HTTP_401_UNAUTHORIZED,\n+            status.HTTP_403_FORBIDDEN,\n+            status.HTTP_404_NOT_FOUND,\n+            status.HTTP_409_CONFLICT,\n+        ]\n+    ),\n+    dependencies=[Depends(requires_fab_custom_view(\"PUT\", permissions.RESOURCE_USER))],\n+)\n+def update_user(\n+    body: UserPatchBody,\n+    username: str = Path(..., min_length=1),\n+    update_mask: str | None = Query(None, description=\"Comma-separated list of fields to update\"),\n+) -> UserResponse:\n+    \"\"\"Update an existing user.\"\"\"\n+    with get_application_builder():\n+        return FABAuthManagerUsers.update_user(username=username, body=body, update_mask=update_mask)\n+\n+\n+@users_router.delete(\n+    \"/users/{username}\",\n+    status_code=status.HTTP_204_NO_CONTENT,\n+    responses=create_openapi_http_exception_doc(\n+        [\n+            status.HTTP_401_UNAUTHORIZED,\n+            status.HTTP_403_FORBIDDEN,\n+            status.HTTP_404_NOT_FOUND,\n+        ]\n+    ),\n+    dependencies=[Depends(requires_fab_custom_view(\"DELETE\", permissions.RESOURCE_USER))],\n+)\n+def delete_user(username: str = Path(..., min_length=1)) -> None:\n+    \"\"\"Delete a user by username.\"\"\"\n+    with get_application_builder():\n+        FABAuthManagerUsers.delete_user(username=username)",
      "comment": "Sounds good \u2014 I\u2019ll remove the -> None return annotation first and re-run CI. If it still fails, I\u2019ll follow up with the results.",
      "comment_id": 2722964593,
      "user": "Fury0508",
      "created_at": "2026-01-23T21:50:08Z",
      "url": "https://github.com/apache/airflow/pull/60973#discussion_r2722964593"
    },
    {
      "repo": "apache/airflow",
      "pr_number": 60615,
      "file_path": "helm-tests/tests/helm_tests/airflow_core/test_pdb_api_server.py",
      "line": 57,
      "side": "RIGHT",
      "diff_hunk": "@@ -0,0 +1,57 @@\n+# Licensed to the Apache Software Foundation (ASF) under one\n+# or more contributor license agreements.  See the NOTICE file\n+# distributed with this work for additional information\n+# regarding copyright ownership.  The ASF licenses this file\n+# to you under the Apache License, Version 2.0 (the\n+# \"License\"); you may not use this file except in compliance\n+# with the License.  You may obtain a copy of the License at\n+#\n+#   http://www.apache.org/licenses/LICENSE-2.0\n+#\n+# Unless required by applicable law or agreed to in writing,\n+# software distributed under the License is distributed on an\n+# \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+# KIND, either express or implied.  See the License for the\n+# specific language governing permissions and limitations\n+# under the License.\n+from __future__ import annotations\n+\n+import jmespath\n+from chart_utils.helm_template_generator import render_chart\n+\n+\n+class TestApiServerPdb:\n+    \"\"\"Tests API Server PDB.\"\"\"\n+\n+    def test_should_pass_validation_with_just_pdb_enabled(self):\n+        render_chart(\n+            values={\"apiServer\": {\"podDisruptionBudget\": {\"enabled\": True}}},\n+            show_only=[\"templates/api-server/api-server-poddisruptionbudget.yaml\"],\n+        )\n+\n+    def test_should_add_component_specific_labels(self):\n+        docs = render_chart(\n+            values={\n+                \"apiServer\": {\n+                    \"podDisruptionBudget\": {\"enabled\": True},\n+                    \"labels\": {\"test_label\": \"test_label_value\"},\n+                },\n+            },\n+            show_only=[\"templates/api-server/api-server-poddisruptionbudget.yaml\"],\n+        )\n+\n+        assert \"test_label\" in jmespath.search(\"metadata.labels\", docs[0])\n+        assert jmespath.search(\"metadata.labels\", docs[0])[\"test_label\"] == \"test_label_value\"\n+\n+    def test_should_pass_validation_with_pdb_enabled_and_min_available_param(self):\n+        render_chart(\n+            values={\n+                \"apiServer\": {\n+                    \"podDisruptionBudget\": {\n+                        \"enabled\": True,\n+                        \"config\": {\"maxUnavailable\": None, \"minAvailable\": 1},\n+                    }\n+                }\n+            },\n+            show_only=[\"templates/api-server/api-server-poddisruptionbudget.yaml\"],\n+        )  # checks that no validation exception is raised",
      "comment": "We could check if the parameters are properly set in the rendered object",
      "comment_id": 2706041083,
      "user": "Miretpl",
      "created_at": "2026-01-19T20:49:14Z",
      "url": "https://github.com/apache/airflow/pull/60615#discussion_r2706041083"
    },
    {
      "repo": "apache/airflow",
      "pr_number": 60960,
      "file_path": "providers/google/src/airflow/providers/google/cloud/operators/kubernetes_engine.py",
      "line": 619,
      "side": "RIGHT",
      "diff_hunk": "@@ -616,7 +616,7 @@ class GKEStartPodOperator(GKEOperatorMixin, KubernetesPodOperator):\n     :param on_finish_action: What to do when the pod reaches its final state, or the execution is interrupted.\n         If \"delete_pod\", the pod will be deleted regardless its state; if \"delete_succeeded_pod\",\n         only succeeded pod will be deleted. You can set to \"keep_pod\" to keep the pod.\n-        Current default is `delete_pod`, but this will be changed in the next major release of this provider.\n+        Default is `delete_pod`. ",
      "comment": "```suggestion\n        Default is `delete_pod`.\n```",
      "comment_id": 2724276874,
      "user": "shahar1",
      "created_at": "2026-01-24T15:46:03Z",
      "url": "https://github.com/apache/airflow/pull/60960#discussion_r2724276874"
    },
    {
      "repo": "apache/airflow",
      "pr_number": 60776,
      "file_path": "task-sdk/src/airflow/sdk/types.py",
      "line": 42,
      "side": "RIGHT",
      "diff_hunk": "@@ -39,6 +39,39 @@\n     Operator: TypeAlias = BaseOperator | MappedOperator\n \n \n+class TaskInstanceKey(NamedTuple):",
      "comment": "> Add this shim layer to compat/sdk.py and have providers consume from that\n\nWhy wait, add then shim layer in this PR itself",
      "comment_id": 2705332517,
      "user": "kaxil",
      "created_at": "2026-01-19T16:01:53Z",
      "url": "https://github.com/apache/airflow/pull/60776#discussion_r2705332517"
    },
    {
      "repo": "apache/airflow",
      "pr_number": 60776,
      "file_path": "task-sdk/src/airflow/sdk/bases/operatorlink.py",
      "line": 27,
      "side": "RIGHT",
      "diff_hunk": "@@ -23,8 +23,8 @@\n import attrs\n \n if TYPE_CHECKING:\n-    from airflow.models.taskinstancekey import TaskInstanceKey\n     from airflow.sdk import BaseOperator\n+    from airflow.sdk.types import TaskInstanceKey",
      "comment": "Is this ever used here or in Provider in Runtime? Do we need the actual class or just a protocol?",
      "comment_id": 2705334385,
      "user": "kaxil",
      "created_at": "2026-01-19T16:02:27Z",
      "url": "https://github.com/apache/airflow/pull/60776#discussion_r2705334385"
    },
    {
      "repo": "apache/airflow",
      "pr_number": 60776,
      "file_path": "task-sdk/src/airflow/sdk/types.py",
      "line": 42,
      "side": "RIGHT",
      "diff_hunk": "@@ -39,6 +39,39 @@\n     Operator: TypeAlias = BaseOperator | MappedOperator\n \n \n+class TaskInstanceKey(NamedTuple):",
      "comment": "The intent was to keep provider PR separate for ease of classification for RM, but seems like I will have to handle it here itself",
      "comment_id": 2705356688,
      "user": "amoghrajesh",
      "created_at": "2026-01-19T16:09:39Z",
      "url": "https://github.com/apache/airflow/pull/60776#discussion_r2705356688"
    },
    {
      "repo": "apache/airflow",
      "pr_number": 60776,
      "file_path": "task-sdk/src/airflow/sdk/bases/operatorlink.py",
      "line": 27,
      "side": "RIGHT",
      "diff_hunk": "@@ -23,8 +23,8 @@\n import attrs\n \n if TYPE_CHECKING:\n-    from airflow.models.taskinstancekey import TaskInstanceKey\n     from airflow.sdk import BaseOperator\n+    from airflow.sdk.types import TaskInstanceKey",
      "comment": "Good comment, I went through the list and mostly executors use it for non typing along with these exceptions:\r\n\r\n1. https://github.com/apache/airflow/blob/728079af9b0e0fe60b44b27e34debfce10e249c6/providers/edge3/src/airflow/providers/edge3/worker_api/routes/logs.py#L18\r\n2. https://github.com/apache/airflow/blob/728079af9b0e0fe60b44b27e34debfce10e249c6/providers/edge3/src/airflow/providers/edge3/models/edge_job.py#L30\r\n3. ES task handler: https://github.com/apache/airflow/blob/728079af9b0e0fe60b44b27e34debfce10e249c6/providers/elasticsearch/src/airflow/providers/elasticsearch/log/es_task_handler.py#L92-L113\r\n4. OS task handler: https://github.com/apache/airflow/blob/728079af9b0e0fe60b44b27e34debfce10e249c6/providers/opensearch/src/airflow/providers/opensearch/log/os_task_handler.py#L79-L100\r\n5. Edge provider datamodels: https://github.com/apache/airflow/blob/728079af9b0e0fe60b44b27e34debfce10e249c6/providers/edge3/src/airflow/providers/edge3/worker_api/datamodels.py#L29\r\n6. Databricks workflow: https://github.com/apache/airflow/blob/728079af9b0e0fe60b44b27e34debfce10e249c6/providers/databricks/src/airflow/providers/databricks/plugins/databricks_workflow.py#L25\r\n\r\nSo we will have to unfortunately have it be a real class",
      "comment_id": 2707003429,
      "user": "amoghrajesh",
      "created_at": "2026-01-20T06:53:06Z",
      "url": "https://github.com/apache/airflow/pull/60776#discussion_r2707003429"
    },
    {
      "repo": "apache/airflow",
      "pr_number": 60776,
      "file_path": "providers/cncf/kubernetes/src/airflow/providers/cncf/kubernetes/kubernetes_helper_functions.py",
      "line": 170,
      "side": "RIGHT",
      "diff_hunk": "@@ -166,7 +166,8 @@ def annotations_to_key(annotations: dict[str, str]) -> TaskInstanceKey:\n \n     # Compat: Look up the run_id from the TI table!\n     from airflow.models.dagrun import DagRun\n-    from airflow.models.taskinstance import TaskInstance, TaskInstanceKey\n+    from airflow.models.taskinstance import TaskInstance\n+    from airflow.models.taskinstancekey import TaskInstanceKey",
      "comment": "Unrelated change? or did you intend to change this to common.compat too?",
      "comment_id": 2716966818,
      "user": "kaxil",
      "created_at": "2026-01-22T13:40:19Z",
      "url": "https://github.com/apache/airflow/pull/60776#discussion_r2716966818"
    },
    {
      "repo": "apache/airflow",
      "pr_number": 60776,
      "file_path": "providers/databricks/src/airflow/providers/databricks/plugins/databricks_workflow.py",
      "line": 301,
      "side": "RIGHT",
      "diff_hunk": "@@ -298,7 +298,7 @@ def xcom_key(self) -> str:\n         \"\"\"XCom key where the link is stored during task execution.\"\"\"\n         return \"databricks_job_run_link\"\n \n-    def get_link(\n+    def get_link(  # type: ignore[override]  # Signature intentionally kept this way for Airflow 2.x compatibility",
      "comment": "Hmm, why though -- Mypy only runs on main / AF 3.x",
      "comment_id": 2716971067,
      "user": "kaxil",
      "created_at": "2026-01-22T13:41:34Z",
      "url": "https://github.com/apache/airflow/pull/60776#discussion_r2716971067"
    },
    {
      "repo": "apache/airflow",
      "pr_number": 60776,
      "file_path": "providers/standard/src/airflow/providers/standard/operators/trigger_dagrun.py",
      "line": 99,
      "side": "RIGHT",
      "diff_hunk": "@@ -89,8 +88,17 @@ def get_link(self, operator: BaseOperator, *, ti_key: TaskInstanceKey) -> str:\n         trigger_dag_id = operator.trigger_dag_id\n         if not AIRFLOW_V_3_0_PLUS:\n             from airflow.models.renderedtifields import RenderedTaskInstanceFields\n+            from airflow.models.taskinstancekey import TaskInstanceKey as CoreTaskInstanceKey\n+\n+            core_ti_key = CoreTaskInstanceKey(\n+                dag_id=ti_key.dag_id,\n+                task_id=ti_key.task_id,\n+                run_id=ti_key.run_id,\n+                try_number=ti_key.try_number,\n+                map_index=ti_key.map_index,\n+            )",
      "comment": "Why do we need to do this, isn't technically those are same attribs?",
      "comment_id": 2716976751,
      "user": "kaxil",
      "created_at": "2026-01-22T13:43:01Z",
      "url": "https://github.com/apache/airflow/pull/60776#discussion_r2716976751"
    },
    {
      "repo": "apache/airflow",
      "pr_number": 60776,
      "file_path": "providers/cncf/kubernetes/src/airflow/providers/cncf/kubernetes/kubernetes_helper_functions.py",
      "line": 170,
      "side": "RIGHT",
      "diff_hunk": "@@ -166,7 +166,8 @@ def annotations_to_key(annotations: dict[str, str]) -> TaskInstanceKey:\n \n     # Compat: Look up the run_id from the TI table!\n     from airflow.models.dagrun import DagRun\n-    from airflow.models.taskinstance import TaskInstance, TaskInstanceKey\n+    from airflow.models.taskinstance import TaskInstance\n+    from airflow.models.taskinstancekey import TaskInstanceKey",
      "comment": "I wanted to change this to common.compat too but unfortunately it is eventually going to go through the KE. Since baseexecutor is typed with `from airflow.models.taskinstancekey import TaskInstanceKey`, we won't be able to use `airflow.sdk.types.TaskInstanceKey ` for typing for _any_ executor related functions which somewhat makes sense too because executor is not supposed to consume from sdk i think",
      "comment_id": 2719617821,
      "user": "amoghrajesh",
      "created_at": "2026-01-23T05:03:56Z",
      "url": "https://github.com/apache/airflow/pull/60776#discussion_r2719617821"
    },
    {
      "repo": "apache/airflow",
      "pr_number": 60776,
      "file_path": "providers/cncf/kubernetes/src/airflow/providers/cncf/kubernetes/kubernetes_helper_functions.py",
      "line": 170,
      "side": "RIGHT",
      "diff_hunk": "@@ -166,7 +166,8 @@ def annotations_to_key(annotations: dict[str, str]) -> TaskInstanceKey:\n \n     # Compat: Look up the run_id from the TI table!\n     from airflow.models.dagrun import DagRun\n-    from airflow.models.taskinstance import TaskInstance, TaskInstanceKey\n+    from airflow.models.taskinstance import TaskInstance\n+    from airflow.models.taskinstancekey import TaskInstanceKey",
      "comment": "So I just went ahead and consumed from the canonical path: `airflow.models.taskinstancekey` instead of some re-export",
      "comment_id": 2719618903,
      "user": "amoghrajesh",
      "created_at": "2026-01-23T05:04:29Z",
      "url": "https://github.com/apache/airflow/pull/60776#discussion_r2719618903"
    },
    {
      "repo": "apache/airflow",
      "pr_number": 60776,
      "file_path": "providers/databricks/src/airflow/providers/databricks/plugins/databricks_workflow.py",
      "line": 301,
      "side": "RIGHT",
      "diff_hunk": "@@ -298,7 +298,7 @@ def xcom_key(self) -> str:\n         \"\"\"XCom key where the link is stored during task execution.\"\"\"\n         return \"databricks_job_run_link\"\n \n-    def get_link(\n+    def get_link(  # type: ignore[override]  # Signature intentionally kept this way for Airflow 2.x compatibility",
      "comment": "Guess this is what's happening.\n\nEarlier, baseoperatorlink.py was getting typing this way:\n\n```python\nif TYPE_CHECKING:\n    from airflow.models.taskinstancekey import TaskInstanceKey\n\ndef get_link(self, operator: BaseOperator, *, ti_key: TaskInstanceKey) -> str:\n```\n\nNow it is:\n```python\nif TYPE_CHECKING:\n    from airflow.sdk.types import TaskInstanceKey\n\ndef get_link(self, operator: BaseOperator, *, ti_key: TaskInstanceKey) -> str:\n```\n\nEarlier it didn't catch it because the types matched i presume, now since the types do not match, it cascades into more issues. My changes somehow made mypy stricter ",
      "comment_id": 2719682166,
      "user": "amoghrajesh",
      "created_at": "2026-01-23T05:37:24Z",
      "url": "https://github.com/apache/airflow/pull/60776#discussion_r2719682166"
    },
    {
      "repo": "apache/airflow",
      "pr_number": 60776,
      "file_path": "providers/standard/src/airflow/providers/standard/operators/trigger_dagrun.py",
      "line": 99,
      "side": "RIGHT",
      "diff_hunk": "@@ -89,8 +88,17 @@ def get_link(self, operator: BaseOperator, *, ti_key: TaskInstanceKey) -> str:\n         trigger_dag_id = operator.trigger_dag_id\n         if not AIRFLOW_V_3_0_PLUS:\n             from airflow.models.renderedtifields import RenderedTaskInstanceFields\n+            from airflow.models.taskinstancekey import TaskInstanceKey as CoreTaskInstanceKey\n+\n+            core_ti_key = CoreTaskInstanceKey(\n+                dag_id=ti_key.dag_id,\n+                task_id=ti_key.task_id,\n+                run_id=ti_key.run_id,\n+                try_number=ti_key.try_number,\n+                map_index=ti_key.map_index,\n+            )",
      "comment": "I looked it up a bit and mypy by default seems to do nominal typing unless there is a protocol in play, hence with a simple example:\n\n```python\nfrom typing import NamedTuple\n\n\nclass SDKKey(NamedTuple):\n    dag_id: str\n    task_id: str\n\n\nclass CoreKey(NamedTuple):\n    dag_id: str\n    task_id: str\n\n\ndef core_function(key: CoreKey) -> str:\n    return f\"{key.dag_id}/{key.task_id}\"\n\n\nsdk_key = SDKKey(\"my_dag\", \"my_task\")\ncore_key = CoreKey(\"my_dag\", \"my_task\")\n\ncore_function(sdk_key)\ncore_function(core_key) \n```\n\n```shell\n(apache-airflow) \u279c  airflow git:(ti-key-to-sdk) \u2717 mypy minimal.py\nminimal.py:21: error: Argument 1 to \"core_function\" has incompatible type \"SDKKey\"; expected\n\"CoreKey\"  [arg-type]\n    core_function(sdk_key)\n                  ^~~~~~~\nFound 1 error in 1 file (checked 1 source file)\n```\n\nBut on the other hand if I do this:\n```python\nfrom typing import NamedTuple, Protocol\n\n\nclass KeyProtocol(Protocol):\n    @property\n    def dag_id(self) -> str: ...\n    \n    @property\n    def task_id(self) -> str: ...\n\n\nclass SDKKey(NamedTuple):\n    dag_id: str\n    task_id: str\n\n\nclass CoreKey(NamedTuple):\n    dag_id: str\n    task_id: str\n\n\ndef protocol_function(key: KeyProtocol) -> str:\n    return f\"{key.dag_id}/{key.task_id}\"\n\n\ndef nominal_function(key: CoreKey) -> str:\n    return f\"{key.dag_id}/{key.task_id}\"\n\n\nsdk_key = SDKKey(\"my_dag\", \"my_task\")\ncore_key = CoreKey(\"my_dag\", \"my_task\")\n\nprotocol_function(sdk_key)\nprotocol_function(core_key)\n\nnominal_function(sdk_key)\nnominal_function(core_key)\n```\n\n```shell\n(apache-airflow) \u279c  airflow git:(ti-key-to-sdk) \u2717 mypy minimal.py\nminimal.py:36: error: Argument 1 to \"nominal_function\" has incompatible type \"SDKKey\";\nexpected \"CoreKey\"  [arg-type]\n    nominal_function(sdk_key)\n                     ^~~~~~~\nFound 1 error in 1 file (checked 1 source file)\n```",
      "comment_id": 2719712214,
      "user": "amoghrajesh",
      "created_at": "2026-01-23T05:51:56Z",
      "url": "https://github.com/apache/airflow/pull/60776#discussion_r2719712214"
    },
    {
      "repo": "apache/airflow",
      "pr_number": 60776,
      "file_path": "providers/databricks/src/airflow/providers/databricks/plugins/databricks_workflow.py",
      "line": 301,
      "side": "RIGHT",
      "diff_hunk": "@@ -298,7 +298,7 @@ def xcom_key(self) -> str:\n         \"\"\"XCom key where the link is stored during task execution.\"\"\"\n         return \"databricks_job_run_link\"\n \n-    def get_link(\n+    def get_link(  # type: ignore[override]  # Signature intentionally kept this way for Airflow 2.x compatibility",
      "comment": "Resolving this for now, if you aren't convinced, we can follow up",
      "comment_id": 2724225900,
      "user": "amoghrajesh",
      "created_at": "2026-01-24T14:33:36Z",
      "url": "https://github.com/apache/airflow/pull/60776#discussion_r2724225900"
    },
    {
      "repo": "apache/airflow",
      "pr_number": 60776,
      "file_path": "providers/standard/src/airflow/providers/standard/operators/trigger_dagrun.py",
      "line": 99,
      "side": "RIGHT",
      "diff_hunk": "@@ -89,8 +88,17 @@ def get_link(self, operator: BaseOperator, *, ti_key: TaskInstanceKey) -> str:\n         trigger_dag_id = operator.trigger_dag_id\n         if not AIRFLOW_V_3_0_PLUS:\n             from airflow.models.renderedtifields import RenderedTaskInstanceFields\n+            from airflow.models.taskinstancekey import TaskInstanceKey as CoreTaskInstanceKey\n+\n+            core_ti_key = CoreTaskInstanceKey(\n+                dag_id=ti_key.dag_id,\n+                task_id=ti_key.task_id,\n+                run_id=ti_key.run_id,\n+                try_number=ti_key.try_number,\n+                map_index=ti_key.map_index,\n+            )",
      "comment": "Resolving this for now, if you aren't convinced, we can follow up",
      "comment_id": 2724226036,
      "user": "amoghrajesh",
      "created_at": "2026-01-24T14:33:43Z",
      "url": "https://github.com/apache/airflow/pull/60776#discussion_r2724226036"
    },
    {
      "repo": "apache/airflow",
      "pr_number": 60776,
      "file_path": "providers/cncf/kubernetes/src/airflow/providers/cncf/kubernetes/kubernetes_helper_functions.py",
      "line": 170,
      "side": "RIGHT",
      "diff_hunk": "@@ -166,7 +166,8 @@ def annotations_to_key(annotations: dict[str, str]) -> TaskInstanceKey:\n \n     # Compat: Look up the run_id from the TI table!\n     from airflow.models.dagrun import DagRun\n-    from airflow.models.taskinstance import TaskInstance, TaskInstanceKey\n+    from airflow.models.taskinstance import TaskInstance\n+    from airflow.models.taskinstancekey import TaskInstanceKey",
      "comment": "Resolving this for now, if you aren't convinced, we can follow up",
      "comment_id": 2724226305,
      "user": "amoghrajesh",
      "created_at": "2026-01-24T14:33:59Z",
      "url": "https://github.com/apache/airflow/pull/60776#discussion_r2724226305"
    },
    {
      "repo": "apache/airflow",
      "pr_number": 60952,
      "file_path": "airflow-core/tests/unit/api_fastapi/core_api/routes/public/test_pools.py",
      "line": 56,
      "side": "RIGHT",
      "diff_hunk": "@@ -48,7 +49,11 @@\n \n @provide_session\n def _create_pools(session) -> None:\n-    pool1 = Pool(pool=POOL1_NAME, slots=POOL1_SLOT, include_deferred=POOL1_INCLUDE_DEFERRED)\n+    team = session.scalars(select(Team).where(Team.name == \"test\")).one()\n+\n+    pool1 = Pool(\n+        pool=POOL1_NAME, slots=POOL1_SLOT, include_deferred=POOL1_INCLUDE_DEFERRED, team_name=team.name\n+    )",
      "comment": "It\u2019s not necessary to change this, but it seems we don\u2019t need to select the team before creating a pool.\u2060\r\n\r\n```suggestion\r\n    pool1 = Pool(\r\n        pool=POOL1_NAME, slots=POOL1_SLOT, include_deferred=POOL1_INCLUDE_DEFERRED, team_name=\"test\"\r\n    )\r\n```",
      "comment_id": 2719641679,
      "user": "jason810496",
      "created_at": "2026-01-23T05:15:39Z",
      "url": "https://github.com/apache/airflow/pull/60952#discussion_r2719641679"
    },
    {
      "repo": "apache/airflow",
      "pr_number": 60784,
      "file_path": "shared/logging/src/airflow_shared/logging/structlog.py",
      "line": 557,
      "side": "RIGHT",
      "diff_hunk": "@@ -554,7 +554,7 @@ def is_atty():\n     )\n     config[\"root\"] = {\n         \"handlers\": [\"default\"],\n-        \"level\": \"INFO\",\n+        \"level\": log_level.upper(),",
      "comment": "Can we add some test coverage for this one please?",
      "comment_id": 2715371715,
      "user": "amoghrajesh",
      "created_at": "2026-01-22T05:36:22Z",
      "url": "https://github.com/apache/airflow/pull/60784#discussion_r2715371715"
    },
    {
      "repo": "apache/airflow",
      "pr_number": 60826,
      "file_path": "shared/logging/src/airflow_shared/logging/remote.py",
      "line": 31,
      "side": "RIGHT",
      "diff_hunk": "@@ -0,0 +1,95 @@\n+# Licensed to the Apache Software Foundation (ASF) under one\n+# or more contributor license agreements.  See the NOTICE file\n+# distributed with this work for additional information\n+# regarding copyright ownership.  The ASF licenses this file\n+# to you under the Apache License, Version 2.0 (the\n+# \"License\"); you may not use this file except in compliance\n+# with the License.  You may obtain a copy of the License at\n+#\n+#   http://www.apache.org/licenses/LICENSE-2.0\n+#\n+# Unless required by applicable law or agreed to in writing,\n+# software distributed under the License is distributed on an\n+# \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+# KIND, either express or implied.  See the License for the\n+# specific language governing permissions and limitations\n+# under the License.\n+\n+from __future__ import annotations\n+\n+import os\n+from collections.abc import Callable\n+from importlib import import_module\n+from typing import TYPE_CHECKING, Any, Protocol, runtime_checkable\n+\n+import structlog\n+\n+if TYPE_CHECKING:\n+    # Use Any for forward references to avoid importing concrete types\n+    RuntimeTI = Any  # Type alias for RuntimeTaskInstance protocol\n+    LogResponse = tuple[Any, Any]  # Type alias for (messages, logs)\n+    StreamingLogResponse = tuple[Any, Any]  # Type alias for streaming response",
      "comment": "We could directly copy from \r\n\r\nhttps://github.com/apache/airflow/blob/cd0cb083a191967e788388ab4faddbd0cbcfe14d/airflow-core/src/airflow/utils/log/file_task_handler.py#L69-L84",
      "comment_id": 2708775000,
      "user": "jason810496",
      "created_at": "2026-01-20T15:09:06Z",
      "url": "https://github.com/apache/airflow/pull/60826#discussion_r2708775000"
    },
    {
      "repo": "apache/airflow",
      "pr_number": 60826,
      "file_path": "shared/logging/src/airflow_shared/logging/remote.py",
      "line": 44,
      "side": "RIGHT",
      "diff_hunk": "@@ -0,0 +1,95 @@\n+# Licensed to the Apache Software Foundation (ASF) under one\n+# or more contributor license agreements.  See the NOTICE file\n+# distributed with this work for additional information\n+# regarding copyright ownership.  The ASF licenses this file\n+# to you under the Apache License, Version 2.0 (the\n+# \"License\"); you may not use this file except in compliance\n+# with the License.  You may obtain a copy of the License at\n+#\n+#   http://www.apache.org/licenses/LICENSE-2.0\n+#\n+# Unless required by applicable law or agreed to in writing,\n+# software distributed under the License is distributed on an\n+# \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+# KIND, either express or implied.  See the License for the\n+# specific language governing permissions and limitations\n+# under the License.\n+\n+from __future__ import annotations\n+\n+import os\n+from collections.abc import Callable\n+from importlib import import_module\n+from typing import TYPE_CHECKING, Any, Protocol, runtime_checkable\n+\n+import structlog\n+\n+if TYPE_CHECKING:\n+    # Use Any for forward references to avoid importing concrete types\n+    RuntimeTI = Any  # Type alias for RuntimeTaskInstance protocol\n+    LogResponse = tuple[Any, Any]  # Type alias for (messages, logs)\n+    StreamingLogResponse = tuple[Any, Any]  # Type alias for streaming response\n+\n+log = structlog.getLogger(__name__)\n+\n+",
      "comment": "How about moving `class _ActiveLoggingConfig` and `def get_remote_task_log` to shared module as well?",
      "comment_id": 2708807033,
      "user": "jason810496",
      "created_at": "2026-01-20T15:15:41Z",
      "url": "https://github.com/apache/airflow/pull/60826#discussion_r2708807033"
    },
    {
      "repo": "apache/airflow",
      "pr_number": 60826,
      "file_path": "task-sdk/src/airflow/sdk/log.py",
      "line": 49,
      "side": "RIGHT",
      "diff_hunk": "@@ -33,13 +33,21 @@\n if TYPE_CHECKING:\n     from structlog.typing import EventDict, FilteringBoundLogger, Processor\n \n-    from airflow.logging_config import RemoteLogIO\n+    from airflow.sdk._shared.logging.remote import RemoteLogIO\n     from airflow.sdk.types import Logger, RuntimeTaskInstanceProtocol as RuntimeTI\n \n \n from airflow.sdk._shared.secrets_masker import redact\n \n \n+class _ActiveLoggingConfig:\n+    \"\"\"Internal class to track active logging configuration.\"\"\"\n+\n+    logging_config_loaded = False\n+    remote_task_log: RemoteLogIO | None = None\n+    default_remote_conn_id: str | None = None\n+",
      "comment": "It\u2019s not necessary, but we could add a setter method for this class.",
      "comment_id": 2708825489,
      "user": "jason810496",
      "created_at": "2026-01-20T15:19:34Z",
      "url": "https://github.com/apache/airflow/pull/60826#discussion_r2708825489"
    },
    {
      "repo": "apache/airflow",
      "pr_number": 60826,
      "file_path": "shared/logging/src/airflow_shared/logging/remote.py",
      "line": 31,
      "side": "RIGHT",
      "diff_hunk": "@@ -0,0 +1,95 @@\n+# Licensed to the Apache Software Foundation (ASF) under one\n+# or more contributor license agreements.  See the NOTICE file\n+# distributed with this work for additional information\n+# regarding copyright ownership.  The ASF licenses this file\n+# to you under the Apache License, Version 2.0 (the\n+# \"License\"); you may not use this file except in compliance\n+# with the License.  You may obtain a copy of the License at\n+#\n+#   http://www.apache.org/licenses/LICENSE-2.0\n+#\n+# Unless required by applicable law or agreed to in writing,\n+# software distributed under the License is distributed on an\n+# \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+# KIND, either express or implied.  See the License for the\n+# specific language governing permissions and limitations\n+# under the License.\n+\n+from __future__ import annotations\n+\n+import os\n+from collections.abc import Callable\n+from importlib import import_module\n+from typing import TYPE_CHECKING, Any, Protocol, runtime_checkable\n+\n+import structlog\n+\n+if TYPE_CHECKING:\n+    # Use Any for forward references to avoid importing concrete types\n+    RuntimeTI = Any  # Type alias for RuntimeTaskInstance protocol\n+    LogResponse = tuple[Any, Any]  # Type alias for (messages, logs)\n+    StreamingLogResponse = tuple[Any, Any]  # Type alias for streaming response",
      "comment": "Good point, I hadn't gotten so far yet!\r\n\r\nAnyways, I defined these in shared and then imported them in core.",
      "comment_id": 2711094530,
      "user": "amoghrajesh",
      "created_at": "2026-01-21T06:03:54Z",
      "url": "https://github.com/apache/airflow/pull/60826#discussion_r2711094530"
    },
    {
      "repo": "apache/airflow",
      "pr_number": 60826,
      "file_path": "shared/logging/src/airflow_shared/logging/remote.py",
      "line": 31,
      "side": "RIGHT",
      "diff_hunk": "@@ -0,0 +1,95 @@\n+# Licensed to the Apache Software Foundation (ASF) under one\n+# or more contributor license agreements.  See the NOTICE file\n+# distributed with this work for additional information\n+# regarding copyright ownership.  The ASF licenses this file\n+# to you under the Apache License, Version 2.0 (the\n+# \"License\"); you may not use this file except in compliance\n+# with the License.  You may obtain a copy of the License at\n+#\n+#   http://www.apache.org/licenses/LICENSE-2.0\n+#\n+# Unless required by applicable law or agreed to in writing,\n+# software distributed under the License is distributed on an\n+# \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+# KIND, either express or implied.  See the License for the\n+# specific language governing permissions and limitations\n+# under the License.\n+\n+from __future__ import annotations\n+\n+import os\n+from collections.abc import Callable\n+from importlib import import_module\n+from typing import TYPE_CHECKING, Any, Protocol, runtime_checkable\n+\n+import structlog\n+\n+if TYPE_CHECKING:\n+    # Use Any for forward references to avoid importing concrete types\n+    RuntimeTI = Any  # Type alias for RuntimeTaskInstance protocol\n+    LogResponse = tuple[Any, Any]  # Type alias for (messages, logs)\n+    StreamingLogResponse = tuple[Any, Any]  # Type alias for streaming response",
      "comment": "> Anyways, I defined these in shared and then imported them in core.\r\n\r\nSure! That's an even cleaner approach.",
      "comment_id": 2711105431,
      "user": "jason810496",
      "created_at": "2026-01-21T06:09:23Z",
      "url": "https://github.com/apache/airflow/pull/60826#discussion_r2711105431"
    },
    {
      "repo": "apache/airflow",
      "pr_number": 60826,
      "file_path": "shared/logging/src/airflow_shared/logging/remote.py",
      "line": 44,
      "side": "RIGHT",
      "diff_hunk": "@@ -0,0 +1,95 @@\n+# Licensed to the Apache Software Foundation (ASF) under one\n+# or more contributor license agreements.  See the NOTICE file\n+# distributed with this work for additional information\n+# regarding copyright ownership.  The ASF licenses this file\n+# to you under the Apache License, Version 2.0 (the\n+# \"License\"); you may not use this file except in compliance\n+# with the License.  You may obtain a copy of the License at\n+#\n+#   http://www.apache.org/licenses/LICENSE-2.0\n+#\n+# Unless required by applicable law or agreed to in writing,\n+# software distributed under the License is distributed on an\n+# \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+# KIND, either express or implied.  See the License for the\n+# specific language governing permissions and limitations\n+# under the License.\n+\n+from __future__ import annotations\n+\n+import os\n+from collections.abc import Callable\n+from importlib import import_module\n+from typing import TYPE_CHECKING, Any, Protocol, runtime_checkable\n+\n+import structlog\n+\n+if TYPE_CHECKING:\n+    # Use Any for forward references to avoid importing concrete types\n+    RuntimeTI = Any  # Type alias for RuntimeTaskInstance protocol\n+    LogResponse = tuple[Any, Any]  # Type alias for (messages, logs)\n+    StreamingLogResponse = tuple[Any, Any]  # Type alias for streaming response\n+\n+log = structlog.getLogger(__name__)\n+\n+",
      "comment": "\nI thought about it briefly yday and I think keeping it separate is a better approach. Let me explain:\n\nRIght now, core and sdk each have their own _ActiveLoggingConfig which both need cos:\n\nTask sdk needs to write remote logs\nAPI server needs it to that it can read and display logs on UI\nBoth have their own config, defaults, and no confusion. They are both inited during their respective bootups and are cached during the process lifecycle separately.\n\nBy moving it to shared, what I am worried about is that _ActiveLoggingConfig is a stateful cache so it we would be modifying the shared state when it shouldn't be shared and should have a separate instance per process since its a singleton. Does it make sense?",
      "comment_id": 2711145666,
      "user": "amoghrajesh",
      "created_at": "2026-01-21T06:26:45Z",
      "url": "https://github.com/apache/airflow/pull/60826#discussion_r2711145666"
    },
    {
      "repo": "apache/airflow",
      "pr_number": 60826,
      "file_path": "task-sdk/src/airflow/sdk/log.py",
      "line": 49,
      "side": "RIGHT",
      "diff_hunk": "@@ -33,13 +33,21 @@\n if TYPE_CHECKING:\n     from structlog.typing import EventDict, FilteringBoundLogger, Processor\n \n-    from airflow.logging_config import RemoteLogIO\n+    from airflow.sdk._shared.logging.remote import RemoteLogIO\n     from airflow.sdk.types import Logger, RuntimeTaskInstanceProtocol as RuntimeTI\n \n \n from airflow.sdk._shared.secrets_masker import redact\n \n \n+class _ActiveLoggingConfig:\n+    \"\"\"Internal class to track active logging configuration.\"\"\"\n+\n+    logging_config_loaded = False\n+    remote_task_log: RemoteLogIO | None = None\n+    default_remote_conn_id: str | None = None\n+",
      "comment": "dataclass might require it to have an instance(likely global, like supervisor_comms?)\n\n",
      "comment_id": 2711151509,
      "user": "amoghrajesh",
      "created_at": "2026-01-21T06:29:22Z",
      "url": "https://github.com/apache/airflow/pull/60826#discussion_r2711151509"
    },
    {
      "repo": "apache/airflow",
      "pr_number": 60826,
      "file_path": "task-sdk/src/airflow/sdk/log.py",
      "line": 49,
      "side": "RIGHT",
      "diff_hunk": "@@ -33,13 +33,21 @@\n if TYPE_CHECKING:\n     from structlog.typing import EventDict, FilteringBoundLogger, Processor\n \n-    from airflow.logging_config import RemoteLogIO\n+    from airflow.sdk._shared.logging.remote import RemoteLogIO\n     from airflow.sdk.types import Logger, RuntimeTaskInstanceProtocol as RuntimeTI\n \n \n from airflow.sdk._shared.secrets_masker import redact\n \n \n+class _ActiveLoggingConfig:\n+    \"\"\"Internal class to track active logging configuration.\"\"\"\n+\n+    logging_config_loaded = False\n+    remote_task_log: RemoteLogIO | None = None\n+    default_remote_conn_id: str | None = None\n+",
      "comment": "setter seems to be a good idea, let me take a stab at it",
      "comment_id": 2711155329,
      "user": "amoghrajesh",
      "created_at": "2026-01-21T06:31:11Z",
      "url": "https://github.com/apache/airflow/pull/60826#discussion_r2711155329"
    },
    {
      "repo": "apache/airflow",
      "pr_number": 60826,
      "file_path": "task-sdk/src/airflow/sdk/log.py",
      "line": 49,
      "side": "RIGHT",
      "diff_hunk": "@@ -33,13 +33,21 @@\n if TYPE_CHECKING:\n     from structlog.typing import EventDict, FilteringBoundLogger, Processor\n \n-    from airflow.logging_config import RemoteLogIO\n+    from airflow.sdk._shared.logging.remote import RemoteLogIO\n     from airflow.sdk.types import Logger, RuntimeTaskInstanceProtocol as RuntimeTI\n \n \n from airflow.sdk._shared.secrets_masker import redact\n \n \n+class _ActiveLoggingConfig:\n+    \"\"\"Internal class to track active logging configuration.\"\"\"\n+\n+    logging_config_loaded = False\n+    remote_task_log: RemoteLogIO | None = None\n+    default_remote_conn_id: str | None = None\n+",
      "comment": "Handled in [adding a setter for logging class](https://github.com/apache/airflow/pull/60826/commits/566f00aece71b07e02468681f4d3edcc3df255c1)",
      "comment_id": 2711186306,
      "user": "amoghrajesh",
      "created_at": "2026-01-21T06:43:43Z",
      "url": "https://github.com/apache/airflow/pull/60826#discussion_r2711186306"
    },
    {
      "repo": "apache/airflow",
      "pr_number": 60826,
      "file_path": "shared/logging/src/airflow_shared/logging/remote.py",
      "line": 31,
      "side": "RIGHT",
      "diff_hunk": "@@ -0,0 +1,95 @@\n+# Licensed to the Apache Software Foundation (ASF) under one\n+# or more contributor license agreements.  See the NOTICE file\n+# distributed with this work for additional information\n+# regarding copyright ownership.  The ASF licenses this file\n+# to you under the Apache License, Version 2.0 (the\n+# \"License\"); you may not use this file except in compliance\n+# with the License.  You may obtain a copy of the License at\n+#\n+#   http://www.apache.org/licenses/LICENSE-2.0\n+#\n+# Unless required by applicable law or agreed to in writing,\n+# software distributed under the License is distributed on an\n+# \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+# KIND, either express or implied.  See the License for the\n+# specific language governing permissions and limitations\n+# under the License.\n+\n+from __future__ import annotations\n+\n+import os\n+from collections.abc import Callable\n+from importlib import import_module\n+from typing import TYPE_CHECKING, Any, Protocol, runtime_checkable\n+\n+import structlog\n+\n+if TYPE_CHECKING:\n+    # Use Any for forward references to avoid importing concrete types\n+    RuntimeTI = Any  # Type alias for RuntimeTaskInstance protocol\n+    LogResponse = tuple[Any, Any]  # Type alias for (messages, logs)\n+    StreamingLogResponse = tuple[Any, Any]  # Type alias for streaming response",
      "comment": "Handled in 254f7d3fcc684651ad5f4104eabe71b093ec3108",
      "comment_id": 2711186635,
      "user": "amoghrajesh",
      "created_at": "2026-01-21T06:43:51Z",
      "url": "https://github.com/apache/airflow/pull/60826#discussion_r2711186635"
    },
    {
      "repo": "apache/airflow",
      "pr_number": 60826,
      "file_path": "shared/logging/src/airflow_shared/logging/remote.py",
      "line": 44,
      "side": "RIGHT",
      "diff_hunk": "@@ -0,0 +1,95 @@\n+# Licensed to the Apache Software Foundation (ASF) under one\n+# or more contributor license agreements.  See the NOTICE file\n+# distributed with this work for additional information\n+# regarding copyright ownership.  The ASF licenses this file\n+# to you under the Apache License, Version 2.0 (the\n+# \"License\"); you may not use this file except in compliance\n+# with the License.  You may obtain a copy of the License at\n+#\n+#   http://www.apache.org/licenses/LICENSE-2.0\n+#\n+# Unless required by applicable law or agreed to in writing,\n+# software distributed under the License is distributed on an\n+# \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+# KIND, either express or implied.  See the License for the\n+# specific language governing permissions and limitations\n+# under the License.\n+\n+from __future__ import annotations\n+\n+import os\n+from collections.abc import Callable\n+from importlib import import_module\n+from typing import TYPE_CHECKING, Any, Protocol, runtime_checkable\n+\n+import structlog\n+\n+if TYPE_CHECKING:\n+    # Use Any for forward references to avoid importing concrete types\n+    RuntimeTI = Any  # Type alias for RuntimeTaskInstance protocol\n+    LogResponse = tuple[Any, Any]  # Type alias for (messages, logs)\n+    StreamingLogResponse = tuple[Any, Any]  # Type alias for streaming response\n+\n+log = structlog.getLogger(__name__)\n+\n+",
      "comment": "> what I am worried about is that _ActiveLoggingConfig is a stateful cache so it we would be modifying the shared state when it shouldn't be shared\r\n\r\nThere shouldn\u2019t be a case where both Task SDK and the Core API Server start within the same process if I remember correctly.\r\n\r\n> should have a separate instance per process since its a singleton.\r\n\r\nFrom my perspective, even if we defined _ActiveLoggingConfig in a shared module, there are still be separate instance per process but using the same code. As long as the TaskSDK and Core API Server do not start within the same process.\r\n",
      "comment_id": 2711272208,
      "user": "jason810496",
      "created_at": "2026-01-21T07:17:07Z",
      "url": "https://github.com/apache/airflow/pull/60826#discussion_r2711272208"
    },
    {
      "repo": "apache/airflow",
      "pr_number": 60826,
      "file_path": "shared/logging/src/airflow_shared/logging/remote.py",
      "line": 44,
      "side": "RIGHT",
      "diff_hunk": "@@ -0,0 +1,95 @@\n+# Licensed to the Apache Software Foundation (ASF) under one\n+# or more contributor license agreements.  See the NOTICE file\n+# distributed with this work for additional information\n+# regarding copyright ownership.  The ASF licenses this file\n+# to you under the Apache License, Version 2.0 (the\n+# \"License\"); you may not use this file except in compliance\n+# with the License.  You may obtain a copy of the License at\n+#\n+#   http://www.apache.org/licenses/LICENSE-2.0\n+#\n+# Unless required by applicable law or agreed to in writing,\n+# software distributed under the License is distributed on an\n+# \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+# KIND, either express or implied.  See the License for the\n+# specific language governing permissions and limitations\n+# under the License.\n+\n+from __future__ import annotations\n+\n+import os\n+from collections.abc import Callable\n+from importlib import import_module\n+from typing import TYPE_CHECKING, Any, Protocol, runtime_checkable\n+\n+import structlog\n+\n+if TYPE_CHECKING:\n+    # Use Any for forward references to avoid importing concrete types\n+    RuntimeTI = Any  # Type alias for RuntimeTaskInstance protocol\n+    LogResponse = tuple[Any, Any]  # Type alias for (messages, logs)\n+    StreamingLogResponse = tuple[Any, Any]  # Type alias for streaming response\n+\n+log = structlog.getLogger(__name__)\n+\n+",
      "comment": "It shouldn't yes, but think `dag.test` and `task.test` -> they run both in same process and I see a potential impact there. I could move it and test it out but I see little benefit in it, wdyt?",
      "comment_id": 2711354907,
      "user": "amoghrajesh",
      "created_at": "2026-01-21T07:47:56Z",
      "url": "https://github.com/apache/airflow/pull/60826#discussion_r2711354907"
    },
    {
      "repo": "apache/airflow",
      "pr_number": 60826,
      "file_path": "shared/logging/src/airflow_shared/logging/remote.py",
      "line": 44,
      "side": "RIGHT",
      "diff_hunk": "@@ -0,0 +1,95 @@\n+# Licensed to the Apache Software Foundation (ASF) under one\n+# or more contributor license agreements.  See the NOTICE file\n+# distributed with this work for additional information\n+# regarding copyright ownership.  The ASF licenses this file\n+# to you under the Apache License, Version 2.0 (the\n+# \"License\"); you may not use this file except in compliance\n+# with the License.  You may obtain a copy of the License at\n+#\n+#   http://www.apache.org/licenses/LICENSE-2.0\n+#\n+# Unless required by applicable law or agreed to in writing,\n+# software distributed under the License is distributed on an\n+# \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+# KIND, either express or implied.  See the License for the\n+# specific language governing permissions and limitations\n+# under the License.\n+\n+from __future__ import annotations\n+\n+import os\n+from collections.abc import Callable\n+from importlib import import_module\n+from typing import TYPE_CHECKING, Any, Protocol, runtime_checkable\n+\n+import structlog\n+\n+if TYPE_CHECKING:\n+    # Use Any for forward references to avoid importing concrete types\n+    RuntimeTI = Any  # Type alias for RuntimeTaskInstance protocol\n+    LogResponse = tuple[Any, Any]  # Type alias for (messages, logs)\n+    StreamingLogResponse = tuple[Any, Any]  # Type alias for streaming response\n+\n+log = structlog.getLogger(__name__)\n+\n+",
      "comment": ">  I could move it and test it out but I see little benefit in it, wdyt?\r\n\r\nSure! We can define it in a different module to avoid side effects in the scenarios above. Thanks! ",
      "comment_id": 2711366106,
      "user": "jason810496",
      "created_at": "2026-01-21T07:51:56Z",
      "url": "https://github.com/apache/airflow/pull/60826#discussion_r2711366106"
    },
    {
      "repo": "apache/airflow",
      "pr_number": 60826,
      "file_path": "task-sdk/tests/task_sdk/execution_time/test_supervisor.py",
      "line": 3010,
      "side": "RIGHT",
      "diff_hunk": "@@ -2994,25 +2999,31 @@ def get_connection(self, conn_id: str):\n \n     backend = ExampleBackend()\n     monkeypatch.setattr(supervisor, \"ensure_secrets_backend_loaded\", lambda: [backend])\n-    monkeypatch.setattr(sdk_log, \"load_remote_log_handler\", lambda: object())\n-    monkeypatch.setattr(sdk_log, \"load_remote_conn_id\", lambda: \"test_conn\")\n     monkeypatch.delenv(\"AIRFLOW_CONN_TEST_CONN\", raising=False)\n \n-    def noop_request(request: httpx.Request) -> httpx.Response:\n-        return httpx.Response(200)\n-\n-    clients = []\n-    for _ in range(3):\n-        client = make_client(transport=httpx.MockTransport(noop_request))\n-        clients.append(weakref.ref(client))\n-        with _remote_logging_conn(client):\n-            pass\n-        client.close()\n-        del client\n-\n-    gc.collect()\n-    assert backend.calls == 1, \"Connection should be cached, not fetched multiple times\"\n-    assert all(ref() is None for ref in clients), \"Client instances should be garbage collected\"\n+    with conf_vars(\n+        {\n+            (\"logging\", \"remote_logging\"): \"True\",\n+            (\"logging\", \"remote_base_log_folder\"): \"s3://bucket/logs\",\n+            (\"logging\", \"remote_log_conn_id\"): \"test_conn\",\n+        }\n+    ):",
      "comment": "Instead of patching `load_remote_log_handler` and `load_remote_conn_id`, we can just populate the right env's and rest will be handled by the code called when `_remote_logging_conn` is called.",
      "comment_id": 2719525953,
      "user": "amoghrajesh",
      "created_at": "2026-01-23T04:17:26Z",
      "url": "https://github.com/apache/airflow/pull/60826#discussion_r2719525953"
    },
    {
      "repo": "apache/airflow",
      "pr_number": 60844,
      "file_path": "dev/breeze/src/airflow_breeze/commands/common_options.py",
      "line": 398,
      "side": "RIGHT",
      "diff_hunk": "@@ -392,13 +393,13 @@ def _set_default_from_parent(ctx: click.core.Context, option: click.core.Option,\n     help=\"Run standalone dag processor for start-airflow (required for Airflow 3).\",\n     envvar=\"STANDALONE_DAG_PROCESSOR\",\n )\n-option_use_mprocs = click.option(\n-    \"--use-mprocs/--use-tmux\",\n-    is_flag=True,\n-    default=False,\n+option_terminal_multiplexer = click.option(\n+    \"--terminal-multiplexer\",",
      "comment": "can we have a short cli option like `-t` as well or is there no letter leftover?",
      "comment_id": 2713896011,
      "user": "jscheffl",
      "created_at": "2026-01-21T18:47:00Z",
      "url": "https://github.com/apache/airflow/pull/60844#discussion_r2713896011"
    },
    {
      "repo": "apache/airflow",
      "pr_number": 60956,
      "file_path": "airflow-core/src/airflow/jobs/scheduler_job_runner.py",
      "line": 2289,
      "side": "RIGHT",
      "diff_hunk": "@@ -2275,10 +2275,20 @@ def _verify_integrity_if_dag_changed(self, dag_run: DagRun, session: Session) ->\n         dag_run.dag = self.scheduler_dag_bag.get_dag_for_run(dag_run=dag_run, session=session)\n         if not dag_run.dag:\n             return False\n-        # Select all TIs in State.unfinished and update the dag_version_id\n-        for ti in dag_run.task_instances:\n-            if ti.state in State.unfinished:\n-                ti.dag_version = latest_dag_version\n+        # Bulk update dag_version_id for unfinished TIs instead of loading all TIs into memory.\n+        # Use synchronize_session=False since we handle cache coherence via session.expire() below.\n+        session.execute(\n+            update(TI)\n+            .where(\n+                TI.dag_id == dag_run.dag_id,\n+                TI.run_id == dag_run.run_id,\n+                TI.state.in_(State.unfinished),\n+            )\n+            .values(dag_version_id=latest_dag_version.id),\n+            execution_options={\"synchronize_session\": False},\n+        )",
      "comment": "The bulk UPDATE statement references `TI` and `update()` without visible imports in this diff. Ensure these are imported at the top of the file (likely `from airflow.models.taskinstance import TaskInstance as TI` and `from sqlalchemy import update`).",
      "comment_id": 2718849787,
      "user": "Copilot",
      "created_at": "2026-01-22T22:21:44Z",
      "url": "https://github.com/apache/airflow/pull/60956#discussion_r2718849787"
    },
    {
      "repo": "apache/airflow",
      "pr_number": 60562,
      "file_path": "task-sdk/src/airflow/sdk/definitions/asset/__init__.py",
      "line": 382,
      "side": "RIGHT",
      "diff_hunk": "@@ -378,7 +379,7 @@ def __eq__(self, other: Any) -> bool:\n \n     def __hash__(self):\n         f = attrs.filters.include(*attrs.fields_dict(Asset))\n-        return hash(attrs.asdict(self, filter=f))\n+        return hash(json.dumps(attrs.asdict(self, filter=f), sort_keys=True))",
      "comment": "The `attrs.asdict()` call will recursively convert all nested attrs objects (including `AssetWatcher` instances with their `trigger` field) to dictionaries. However, the `BaseEventTrigger` objects in the `watchers` field may not be JSON serializable by default, which could cause a `TypeError` when `json.dumps()` is called. Consider adding `recurse=False` to `attrs.asdict()` or implementing a custom value serializer that handles non-JSON-serializable objects, or document that Assets with watchers cannot be hashed.\n```suggestion\n        data = attrs.asdict(self, filter=f)\n        try:\n            serialized = json.dumps(data, sort_keys=True)\n        except TypeError:\n            # Fallback for non-JSON-serializable values (e.g. BaseEventTrigger instances).\n            # This preserves hashing capability instead of raising at runtime.\n            serialized = repr(data)\n        return hash(serialized)\n```",
      "comment_id": 2692951549,
      "user": "Copilot",
      "created_at": "2026-01-15T04:24:31Z",
      "url": "https://github.com/apache/airflow/pull/60562#discussion_r2692951549"
    },
    {
      "repo": "apache/airflow",
      "pr_number": 60562,
      "file_path": "task-sdk/tests/task_sdk/definitions/test_asset.py",
      "line": 199,
      "side": "RIGHT",
      "diff_hunk": "@@ -192,6 +192,19 @@ def test_not_equal_when_different_uri():\n     assert asset1 != asset2\n \n \n+def test_hash_for_same_uri():\n+    asset1 = Asset(uri=\"s3://example/asset\")\n+    asset2 = Asset(uri=\"s3://example/asset\")\n+\n+    assert hash(asset1) == hash(asset2)",
      "comment": "The test cases only verify hash behavior with basic Assets that have default values for `extra` and `watchers`. Add test cases that verify hash behavior when Assets have non-empty `extra` dictionaries and when Assets have identical/different `extra` values to ensure the JSON serialization handles these fields correctly.",
      "comment_id": 2692951557,
      "user": "Copilot",
      "created_at": "2026-01-15T04:24:32Z",
      "url": "https://github.com/apache/airflow/pull/60562#discussion_r2692951557"
    },
    {
      "repo": "apache/airflow",
      "pr_number": 60712,
      "file_path": "providers/google/src/airflow/providers/google/cloud/hooks/bigtable.py",
      "line": 254,
      "side": "RIGHT",
      "diff_hunk": "@@ -251,9 +251,11 @@ def delete_table(self, instance_id: str, table_id: str, project_id: str) -> None\n         \"\"\"\n         instance = self.get_instance(instance_id=instance_id, project_id=project_id)\n         if instance is None:\n-            raise RuntimeError(f\"Instance {instance_id} did not exist; unable to delete table {table_id}\")\n-        table = instance.table(table_id=table_id)\n-        table.delete()\n+            self.log.warning(\"Instance '%s' does not exist in project '%s'. Exiting\", instance_id, project_id)",
      "comment": "Here it actually makes sense to raise a `RuntimeError`, because the instance needs to exists so we could actually delete the table. After we ensure that it exists, then we could actually use `try..except` to supress the table if it doesn't exist - which apparently we already do in the operator.",
      "comment_id": 2702728664,
      "user": "shahar1",
      "created_at": "2026-01-18T21:11:42Z",
      "url": "https://github.com/apache/airflow/pull/60712#discussion_r2702728664"
    },
    {
      "repo": "apache/airflow",
      "pr_number": 59604,
      "file_path": "task-sdk/src/airflow/sdk/execution_time/task_runner.py",
      "line": 1691,
      "side": "RIGHT",
      "diff_hunk": "@@ -1648,7 +1678,17 @@ def main():\n     SUPERVISOR_COMMS = CommsDecoder[ToTask, ToSupervisor](log=log)\n \n     try:\n-        ti, context, log = startup()\n+        try:\n+            ti, context, log = startup()\n+        except AirflowRescheduleException as reschedule:\n+            log.info(\"Rescheduling task during startup, marking task as UP_FOR_RESCHEDULE\")\n+            SUPERVISOR_COMMS.send(\n+                msg=RescheduleTask(\n+                    reschedule_date=reschedule.reschedule_date,\n+                    end_date=datetime.now(tz=timezone.utc),\n+                )\n+            )\n+            exit(0)",
      "comment": "yep, if we change it here, should we also change the ones below?\n\nhttps://github.com/apache/airflow/pull/59604/changes#diff-5bef10ab2956abf7360dbf9b509b6e1113407874d24abcc1b276475051f13abfR1701",
      "comment_id": 2667416787,
      "user": "Lee-W",
      "created_at": "2026-01-07T07:54:17Z",
      "url": "https://github.com/apache/airflow/pull/59604#discussion_r2667416787"
    },
    {
      "repo": "apache/airflow",
      "pr_number": 59604,
      "file_path": "task-sdk/tests/task_sdk/execution_time/test_task_runner.py",
      "line": 38,
      "side": "RIGHT",
      "diff_hunk": "@@ -35,6 +35,7 @@\n from task_sdk import FAKE_BUNDLE\n from uuid6 import uuid7\n \n+from airflow.exceptions import AirflowRescheduleException",
      "comment": "This should import from `airflow.sdk.exceptions` instead.",
      "comment_id": 2667416975,
      "user": "uranusjr",
      "created_at": "2026-01-07T07:54:22Z",
      "url": "https://github.com/apache/airflow/pull/59604#discussion_r2667416975"
    },
    {
      "repo": "apache/airflow",
      "pr_number": 59604,
      "file_path": "airflow-core/src/airflow/models/dagrun.py",
      "line": 1564,
      "side": "RIGHT",
      "diff_hunk": "@@ -1556,7 +1574,14 @@ def _expand_mapped_task_if_needed(ti: TI) -> Iterable[TI] | None:\n             if TYPE_CHECKING:\n                 assert isinstance(schedulable.task, Operator)\n             old_state = schedulable.state\n-            if not schedulable.are_dependencies_met(session=session, dep_context=dep_context):\n+            if not schedulable.are_dependencies_met(\n+                session=session,\n+                dep_context=(\n+                    dep_context\n+                    if old_state != TaskInstanceState.UP_FOR_RESCHEDULE\n+                    else dep_context_with_reschedule",
      "comment": "I wonder if this conditional logic can be built into `are_dependencies_met` since that function knows the old state.\n\nWe can have a dep class similar to `ReadyToRescheduleDep` to contain this logic. The dep class knows about the ti when it evaluates and can handle `ti.state` in `_get_dep_statuses`.",
      "comment_id": 2667654783,
      "user": "uranusjr",
      "created_at": "2026-01-07T09:19:59Z",
      "url": "https://github.com/apache/airflow/pull/59604#discussion_r2667654783"
    },
    {
      "repo": "apache/airflow",
      "pr_number": 59604,
      "file_path": "task-sdk/src/airflow/sdk/execution_time/task_runner.py",
      "line": 1684,
      "side": "RIGHT",
      "diff_hunk": "@@ -1648,7 +1678,17 @@ def main():\n     SUPERVISOR_COMMS = CommsDecoder[ToTask, ToSupervisor](log=log)\n \n     try:\n-        ti, context, log = startup()\n+        try:\n+            ti, context, log = startup()\n+        except AirflowRescheduleException as reschedule:\n+            log.info(\"Rescheduling task during startup, marking task as UP_FOR_RESCHEDULE\")",
      "comment": "```suggestion\n            log.warning(\"Rescheduling task during startup, marking task as UP_FOR_RESCHEDULE\")\n```",
      "comment_id": 2670642374,
      "user": "Lee-W",
      "created_at": "2026-01-08T02:23:30Z",
      "url": "https://github.com/apache/airflow/pull/59604#discussion_r2670642374"
    },
    {
      "repo": "apache/airflow",
      "pr_number": 59604,
      "file_path": "airflow-core/src/airflow/models/dagrun.py",
      "line": 1562,
      "side": "RIGHT",
      "diff_hunk": "@@ -1556,7 +1556,10 @@ def _expand_mapped_task_if_needed(ti: TI) -> Iterable[TI] | None:\n             if TYPE_CHECKING:\n                 assert isinstance(schedulable.task, Operator)\n             old_state = schedulable.state\n-            if not schedulable.are_dependencies_met(session=session, dep_context=dep_context):\n+            if not schedulable.are_dependencies_met(\n+                session=session,\n+                dep_context=dep_context,\n+            ):",
      "comment": "This is (now) just a formatting change, so lets undo it\r\n\r\n```suggestion\r\n            if not schedulable.are_dependencies_met(session=session, dep_context=dep_context):\r\n```",
      "comment_id": 2671767577,
      "user": "ashb",
      "created_at": "2026-01-08T10:20:17Z",
      "url": "https://github.com/apache/airflow/pull/59604#discussion_r2671767577"
    },
    {
      "repo": "apache/airflow",
      "pr_number": 59604,
      "file_path": "airflow-core/src/airflow/ti_deps/deps/ready_to_reschedule.py",
      "line": 52,
      "side": "RIGHT",
      "diff_hunk": "@@ -43,9 +43,18 @@ def _get_dep_statuses(self, ti, session, dep_context):\n         in the future.\n         \"\"\"\n         if (\n+            # Exclude infrastructure-triggered reschedules.\n+            # When a task is rescheduled due to a startup failure (e.g. the task runner\n+            # cannot load the Dag or task), the task instance will be set\n+            # in UP_FOR_RESCHEDULE state. In this case, we'll ignore the task's\n+            # \"reschedule\" attribute check, since the reschedule was not initiated by the\n+            # operator itself.\n+            ti.state is None",
      "comment": "I don't quite see how this comment ties up with checking if ti.state is None?",
      "comment_id": 2671775117,
      "user": "ashb",
      "created_at": "2026-01-08T10:22:33Z",
      "url": "https://github.com/apache/airflow/pull/59604#discussion_r2671775117"
    },
    {
      "repo": "apache/airflow",
      "pr_number": 59604,
      "file_path": "airflow-core/src/airflow/ti_deps/deps/ready_to_reschedule.py",
      "line": 52,
      "side": "RIGHT",
      "diff_hunk": "@@ -43,9 +43,18 @@ def _get_dep_statuses(self, ti, session, dep_context):\n         in the future.\n         \"\"\"\n         if (\n+            # Exclude infrastructure-triggered reschedules.\n+            # When a task is rescheduled due to a startup failure (e.g. the task runner\n+            # cannot load the Dag or task), the task instance will be set\n+            # in UP_FOR_RESCHEDULE state. In this case, we'll ignore the task's\n+            # \"reschedule\" attribute check, since the reschedule was not initiated by the\n+            # operator itself.\n+            ti.state is None",
      "comment": "The original logic skipped all non-mapped tasks without a `.reschedule` property. I updated it to check `ti.state != TaskInstanceState.UP_FOR_RESCHEDULE` so that the behavior remains the same, except for the case where the state is explicitly set to `UP_FOR_RESCHEDULE`, which is expected in the new task_runner logic we added in this PR.",
      "comment_id": 2671910791,
      "user": "Lee-W",
      "created_at": "2026-01-08T11:03:53Z",
      "url": "https://github.com/apache/airflow/pull/59604#discussion_r2671910791"
    },
    {
      "repo": "apache/airflow",
      "pr_number": 59604,
      "file_path": "airflow-core/src/airflow/models/dagrun.py",
      "line": 1564,
      "side": "RIGHT",
      "diff_hunk": "@@ -1556,7 +1574,14 @@ def _expand_mapped_task_if_needed(ti: TI) -> Iterable[TI] | None:\n             if TYPE_CHECKING:\n                 assert isinstance(schedulable.task, Operator)\n             old_state = schedulable.state\n-            if not schedulable.are_dependencies_met(session=session, dep_context=dep_context):\n+            if not schedulable.are_dependencies_met(\n+                session=session,\n+                dep_context=(\n+                    dep_context\n+                    if old_state != TaskInstanceState.UP_FOR_RESCHEDULE\n+                    else dep_context_with_reschedule",
      "comment": "I moved this thing into `are_dependencies_met` for better readability. If we're to do a new dep class, it would probably be better if we just add `ReadyToRescheduleDep` to every task",
      "comment_id": 2671994785,
      "user": "Lee-W",
      "created_at": "2026-01-08T11:31:33Z",
      "url": "https://github.com/apache/airflow/pull/59604#discussion_r2671994785"
    },
    {
      "repo": "apache/airflow",
      "pr_number": 59604,
      "file_path": "airflow-core/src/airflow/ti_deps/deps/ready_to_reschedule.py",
      "line": 49,
      "side": "RIGHT",
      "diff_hunk": "@@ -43,9 +43,18 @@ def _get_dep_statuses(self, ti, session, dep_context):\n         in the future.\n         \"\"\"\n         if (\n+            # Exclude infrastructure-triggered reschedules.\n+            # When a task is rescheduled due to a startup failure (e.g. the task runner\n+            # cannot load the Dag or task), the task instance will be set\n+            # in UP_FOR_RESCHEDULE state. In this case, we'll ignore the task's",
      "comment": "This is not the case for `reschedule=True` reschedules?",
      "comment_id": 2674621761,
      "user": "uranusjr",
      "created_at": "2026-01-09T02:53:33Z",
      "url": "https://github.com/apache/airflow/pull/59604#discussion_r2674621761"
    },
    {
      "repo": "apache/airflow",
      "pr_number": 59604,
      "file_path": "airflow-core/src/airflow/models/taskinstance.py",
      "line": 906,
      "side": "RIGHT",
      "diff_hunk": "@@ -887,6 +888,22 @@ def are_dependencies_met(\n         :param verbose: whether log details on failed dependencies on info or debug log level\n         \"\"\"\n         dep_context = dep_context or DepContext()\n+        if self.state == TaskInstanceState.UP_FOR_RESCHEDULE:\n+            # This DepContext is used when a task instance is in UP_FOR_RESCHEDULE state.\n+            #\n+            # Tasks can be put into UP_FOR_RESCHEDULE by the task runner itself (e.g. when\n+            # the worker cannot load the Dag or task). In this case, the scheduler must respect\n+            # the task instance's reschedule_date before scheduling it again.\n+            #\n+            # ReadyToRescheduleDep is the only dependency that enforces this time-based gating.\n+            # We therefore extend the normal scheduling dependency set with it, instead of\n+            # modifying the global scheduler dependencies.\n+            dep_context = DepContext(\n+                deps=dep_context.deps | {ReadyToRescheduleDep()},\n+                flag_upstream_failed=dep_context.flag_upstream_failed,\n+                ignore_unmapped_tasks=dep_context.ignore_unmapped_tasks,\n+                finished_tis=dep_context.finished_tis,\n+            )",
      "comment": "Can this not modify `dep_context` in-place?\n\n```python\ndep_context.deps.add(ReadyToRescheduleDep())\n```",
      "comment_id": 2674623994,
      "user": "uranusjr",
      "created_at": "2026-01-09T02:54:54Z",
      "url": "https://github.com/apache/airflow/pull/59604#discussion_r2674623994"
    },
    {
      "repo": "apache/airflow",
      "pr_number": 59604,
      "file_path": "airflow-core/src/airflow/ti_deps/deps/ready_to_reschedule.py",
      "line": 49,
      "side": "RIGHT",
      "diff_hunk": "@@ -43,9 +43,18 @@ def _get_dep_statuses(self, ti, session, dep_context):\n         in the future.\n         \"\"\"\n         if (\n+            # Exclude infrastructure-triggered reschedules.\n+            # When a task is rescheduled due to a startup failure (e.g. the task runner\n+            # cannot load the Dag or task), the task instance will be set\n+            # in UP_FOR_RESCHEDULE state. In this case, we'll ignore the task's",
      "comment": "The TaskInstanceState can be None.\r\n\r\nI'm now considering removing this whole block, adding this Dep to all tasks and seeing how it works. Since we're working on adding this capability to all tasks, it might actually make sense to do it",
      "comment_id": 2674999419,
      "user": "Lee-W",
      "created_at": "2026-01-09T06:22:08Z",
      "url": "https://github.com/apache/airflow/pull/59604#discussion_r2674999419"
    },
    {
      "repo": "apache/airflow",
      "pr_number": 59604,
      "file_path": "airflow-core/src/airflow/models/taskinstance.py",
      "line": 906,
      "side": "RIGHT",
      "diff_hunk": "@@ -887,6 +888,22 @@ def are_dependencies_met(\n         :param verbose: whether log details on failed dependencies on info or debug log level\n         \"\"\"\n         dep_context = dep_context or DepContext()\n+        if self.state == TaskInstanceState.UP_FOR_RESCHEDULE:\n+            # This DepContext is used when a task instance is in UP_FOR_RESCHEDULE state.\n+            #\n+            # Tasks can be put into UP_FOR_RESCHEDULE by the task runner itself (e.g. when\n+            # the worker cannot load the Dag or task). In this case, the scheduler must respect\n+            # the task instance's reschedule_date before scheduling it again.\n+            #\n+            # ReadyToRescheduleDep is the only dependency that enforces this time-based gating.\n+            # We therefore extend the normal scheduling dependency set with it, instead of\n+            # modifying the global scheduler dependencies.\n+            dep_context = DepContext(\n+                deps=dep_context.deps | {ReadyToRescheduleDep()},\n+                flag_upstream_failed=dep_context.flag_upstream_failed,\n+                ignore_unmapped_tasks=dep_context.ignore_unmapped_tasks,\n+                finished_tis=dep_context.finished_tis,\n+            )",
      "comment": "Yes, this works fine. I tried to do it another way and failed... just updated it!",
      "comment_id": 2675034154,
      "user": "Lee-W",
      "created_at": "2026-01-09T06:39:28Z",
      "url": "https://github.com/apache/airflow/pull/59604#discussion_r2675034154"
    },
    {
      "repo": "apache/airflow",
      "pr_number": 59604,
      "file_path": "airflow-core/src/airflow/ti_deps/deps/ready_to_reschedule.py",
      "line": 49,
      "side": "RIGHT",
      "diff_hunk": "@@ -43,9 +43,18 @@ def _get_dep_statuses(self, ti, session, dep_context):\n         in the future.\n         \"\"\"\n         if (\n+            # Exclude infrastructure-triggered reschedules.\n+            # When a task is rescheduled due to a startup failure (e.g. the task runner\n+            # cannot load the Dag or task), the task instance will be set\n+            # in UP_FOR_RESCHEDULE state. In this case, we'll ignore the task's",
      "comment": "Since we're supporting reschedule on non-sensor tasks, I remove the original check here",
      "comment_id": 2679616030,
      "user": "Lee-W",
      "created_at": "2026-01-11T14:27:22Z",
      "url": "https://github.com/apache/airflow/pull/59604#discussion_r2679616030"
    },
    {
      "repo": "apache/airflow",
      "pr_number": 60204,
      "file_path": "airflow-core/src/airflow/serialization/encoders.py",
      "line": 380,
      "side": "RIGHT",
      "diff_hunk": "@@ -347,3 +364,41 @@ def ensure_serialized_asset(obj: BaseAsset | SerializedAssetBase) -> SerializedA\n     from airflow.serialization.decoders import decode_asset_like\n \n     return decode_asset_like(encode_asset_like(obj))\n+\n+\n+class _PartitionMapperSerializer:\n+    BUILTIN_PARTITION_MAPPERS: dict[type, str] = {\n+        IdentityMapper: \"airflow.timetables.simple.IdentityMapper\",\n+    }\n+\n+    @functools.singledispatchmethod\n+    def serialize(self, partition_mapper: PartitionMapper) -> dict[str, Any]:\n+        raise NotImplementedError\n+\n+    @serialize.register\n+    def _(self, partition_mapper: IdentityMapper) -> dict[str, Any]:\n+        return {}",
      "comment": "The serializer-singledispatch pattern is only needed for timetables because we don\u2019t want to put serialization logic on SDK classes. Since the partition mapper logic is only in core, we can put serialization logic there.",
      "comment_id": 2689847305,
      "user": "uranusjr",
      "created_at": "2026-01-14T10:23:18Z",
      "url": "https://github.com/apache/airflow/pull/60204#discussion_r2689847305"
    },
    {
      "repo": "apache/airflow",
      "pr_number": 60204,
      "file_path": "airflow-core/src/airflow/serialization/encoders.py",
      "line": 380,
      "side": "RIGHT",
      "diff_hunk": "@@ -347,3 +364,41 @@ def ensure_serialized_asset(obj: BaseAsset | SerializedAssetBase) -> SerializedA\n     from airflow.serialization.decoders import decode_asset_like\n \n     return decode_asset_like(encode_asset_like(obj))\n+\n+\n+class _PartitionMapperSerializer:\n+    BUILTIN_PARTITION_MAPPERS: dict[type, str] = {\n+        IdentityMapper: \"airflow.timetables.simple.IdentityMapper\",\n+    }\n+\n+    @functools.singledispatchmethod\n+    def serialize(self, partition_mapper: PartitionMapper) -> dict[str, Any]:\n+        raise NotImplementedError\n+\n+    @serialize.register\n+    def _(self, partition_mapper: IdentityMapper) -> dict[str, Any]:\n+        return {}",
      "comment": "If we want to build this for future-proof when custom partition mapper classes, maybe _TimetableSerializer can be renamed to also handle this? These singledispatchmethods are all independent; they can live on the same class.",
      "comment_id": 2689853782,
      "user": "uranusjr",
      "created_at": "2026-01-14T10:25:26Z",
      "url": "https://github.com/apache/airflow/pull/60204#discussion_r2689853782"
    },
    {
      "repo": "apache/airflow",
      "pr_number": 60204,
      "file_path": "airflow-core/src/airflow/serialization/helpers.py",
      "line": 155,
      "side": "RIGHT",
      "diff_hunk": "@@ -133,3 +134,29 @@ def find_registered_custom_timetable(importable_string: str) -> type[CoreTimetab\n def is_core_timetable_import_path(importable_string: str) -> bool:\n     \"\"\"Whether an importable string points to a core timetable class.\"\"\"\n     return importable_string.startswith(\"airflow.timetables.\")\n+\n+\n+class PartitionMapperNotFound(ValueError):\n+    \"\"\"Raise when a PartitionMapper cannot be found.\"\"\"\n+\n+    def __init__(self, type_string: str) -> None:\n+        self.type_string = type_string\n+\n+    def __str__(self) -> str:\n+        return (\n+            f\"PartitionMapper class {self.type_string!r} could not be imported or \"\n+            \"you have a top level database access that disrupted the session. \"\n+            \"Please check the airflow best practices documentation.\"\n+        )\n+\n+\n+def is_core_partition_mapper_import_path(importable_string: str) -> bool:\n+    \"\"\"Whether an importable string points to a core partition mapper class.\"\"\"\n+    return importable_string.startswith(\"airflow.timetables.\")",
      "comment": "Maybe we should move the partition mapper to a separate package.",
      "comment_id": 2689856065,
      "user": "uranusjr",
      "created_at": "2026-01-14T10:26:14Z",
      "url": "https://github.com/apache/airflow/pull/60204#discussion_r2689856065"
    },
    {
      "repo": "apache/airflow",
      "pr_number": 60204,
      "file_path": "task-sdk/src/airflow/sdk/definitions/timetables/assets.py",
      "line": 47,
      "side": "RIGHT",
      "diff_hunk": "@@ -43,6 +44,26 @@ class AssetTriggeredTimetable(BaseTimetable):\n     asset_condition: BaseAsset = attrs.field(alias=\"assets\")\n \n \n+class PartitionMapper(ABC):",
      "comment": "Probably don\u2019t need the ABC here since the class is completely empty anyway.",
      "comment_id": 2689860907,
      "user": "uranusjr",
      "created_at": "2026-01-14T10:27:50Z",
      "url": "https://github.com/apache/airflow/pull/60204#discussion_r2689860907"
    },
    {
      "repo": "apache/airflow",
      "pr_number": 60204,
      "file_path": "airflow-core/src/airflow/serialization/encoders.py",
      "line": 380,
      "side": "RIGHT",
      "diff_hunk": "@@ -347,3 +364,41 @@ def ensure_serialized_asset(obj: BaseAsset | SerializedAssetBase) -> SerializedA\n     from airflow.serialization.decoders import decode_asset_like\n \n     return decode_asset_like(encode_asset_like(obj))\n+\n+\n+class _PartitionMapperSerializer:\n+    BUILTIN_PARTITION_MAPPERS: dict[type, str] = {\n+        IdentityMapper: \"airflow.timetables.simple.IdentityMapper\",\n+    }\n+\n+    @functools.singledispatchmethod\n+    def serialize(self, partition_mapper: PartitionMapper) -> dict[str, Any]:\n+        raise NotImplementedError\n+\n+    @serialize.register\n+    def _(self, partition_mapper: IdentityMapper) -> dict[str, Any]:\n+        return {}",
      "comment": "Yep rename `_TimetableSerializer` might be better. Maybe just rename it as `_Serializer`?",
      "comment_id": 2690753971,
      "user": "Lee-W",
      "created_at": "2026-01-14T14:46:45Z",
      "url": "https://github.com/apache/airflow/pull/60204#discussion_r2690753971"
    },
    {
      "repo": "apache/airflow",
      "pr_number": 60204,
      "file_path": "airflow-core/src/airflow/serialization/helpers.py",
      "line": 155,
      "side": "RIGHT",
      "diff_hunk": "@@ -133,3 +134,29 @@ def find_registered_custom_timetable(importable_string: str) -> type[CoreTimetab\n def is_core_timetable_import_path(importable_string: str) -> bool:\n     \"\"\"Whether an importable string points to a core timetable class.\"\"\"\n     return importable_string.startswith(\"airflow.timetables.\")\n+\n+\n+class PartitionMapperNotFound(ValueError):\n+    \"\"\"Raise when a PartitionMapper cannot be found.\"\"\"\n+\n+    def __init__(self, type_string: str) -> None:\n+        self.type_string = type_string\n+\n+    def __str__(self) -> str:\n+        return (\n+            f\"PartitionMapper class {self.type_string!r} could not be imported or \"\n+            \"you have a top level database access that disrupted the session. \"\n+            \"Please check the airflow best practices documentation.\"\n+        )\n+\n+\n+def is_core_partition_mapper_import_path(importable_string: str) -> bool:\n+    \"\"\"Whether an importable string points to a core partition mapper class.\"\"\"\n+    return importable_string.startswith(\"airflow.timetables.\")",
      "comment": "I also feel it's better this way. `airflow.partition_mapper` maybe?",
      "comment_id": 2690757833,
      "user": "Lee-W",
      "created_at": "2026-01-14T14:47:44Z",
      "url": "https://github.com/apache/airflow/pull/60204#discussion_r2690757833"
    },
    {
      "repo": "apache/airflow",
      "pr_number": 60204,
      "file_path": "airflow-core/src/airflow/serialization/encoders.py",
      "line": 380,
      "side": "RIGHT",
      "diff_hunk": "@@ -347,3 +364,41 @@ def ensure_serialized_asset(obj: BaseAsset | SerializedAssetBase) -> SerializedA\n     from airflow.serialization.decoders import decode_asset_like\n \n     return decode_asset_like(encode_asset_like(obj))\n+\n+\n+class _PartitionMapperSerializer:\n+    BUILTIN_PARTITION_MAPPERS: dict[type, str] = {\n+        IdentityMapper: \"airflow.timetables.simple.IdentityMapper\",\n+    }\n+\n+    @functools.singledispatchmethod\n+    def serialize(self, partition_mapper: PartitionMapper) -> dict[str, Any]:\n+        raise NotImplementedError\n+\n+    @serialize.register\n+    def _(self, partition_mapper: IdentityMapper) -> dict[str, Any]:\n+        return {}",
      "comment": "I renamed it as `_Serializer` and split `serialize` into `serialize_timetable` and `serialize_partition_mapper`. I think it would be easier to maintain this way",
      "comment_id": 2693857035,
      "user": "Lee-W",
      "created_at": "2026-01-15T10:37:13Z",
      "url": "https://github.com/apache/airflow/pull/60204#discussion_r2693857035"
    },
    {
      "repo": "apache/airflow",
      "pr_number": 60204,
      "file_path": "airflow-core/src/airflow/serialization/helpers.py",
      "line": 155,
      "side": "RIGHT",
      "diff_hunk": "@@ -133,3 +134,29 @@ def find_registered_custom_timetable(importable_string: str) -> type[CoreTimetab\n def is_core_timetable_import_path(importable_string: str) -> bool:\n     \"\"\"Whether an importable string points to a core timetable class.\"\"\"\n     return importable_string.startswith(\"airflow.timetables.\")\n+\n+\n+class PartitionMapperNotFound(ValueError):\n+    \"\"\"Raise when a PartitionMapper cannot be found.\"\"\"\n+\n+    def __init__(self, type_string: str) -> None:\n+        self.type_string = type_string\n+\n+    def __str__(self) -> str:\n+        return (\n+            f\"PartitionMapper class {self.type_string!r} could not be imported or \"\n+            \"you have a top level database access that disrupted the session. \"\n+            \"Please check the airflow best practices documentation.\"\n+        )\n+\n+\n+def is_core_partition_mapper_import_path(importable_string: str) -> bool:\n+    \"\"\"Whether an importable string points to a core partition mapper class.\"\"\"\n+    return importable_string.startswith(\"airflow.timetables.\")",
      "comment": "yep, moved. Same as the sdk side. Even though modules with little content might be overkill, I decided to do that for consistency ",
      "comment_id": 2693859588,
      "user": "Lee-W",
      "created_at": "2026-01-15T10:38:07Z",
      "url": "https://github.com/apache/airflow/pull/60204#discussion_r2693859588"
    },
    {
      "repo": "apache/airflow",
      "pr_number": 59857,
      "file_path": "airflow-core/src/airflow/callbacks/callback_requests.py",
      "line": 112,
      "side": "RIGHT",
      "diff_hunk": "@@ -95,6 +103,39 @@ class DagRunContext(BaseModel):\n     dag_run: ti_datamodel.DagRun | None = None\n     last_ti: ti_datamodel.TaskInstance | None = None\n \n+    @model_validator(mode=\"before\")\n+    @classmethod\n+    def _sanitize_consumed_asset_events(cls, values: Mapping[str, Any]) -> Mapping[str, Any]:\n+        dag_run = values.get(\"dag_run\")\n+\n+        if dag_run is None:\n+            return values",
      "comment": "```suggestion\n        if (dag_run := values.get(\"dag_run\")) is None:\n            return values\n```",
      "comment_id": 2660876483,
      "user": "Lee-W",
      "created_at": "2026-01-05T09:40:56Z",
      "url": "https://github.com/apache/airflow/pull/59857#discussion_r2660876483"
    },
    {
      "repo": "apache/airflow",
      "pr_number": 59857,
      "file_path": "airflow-core/src/airflow/callbacks/callback_requests.py",
      "line": 128,
      "side": "RIGHT",
      "diff_hunk": "@@ -95,6 +103,39 @@ class DagRunContext(BaseModel):\n     dag_run: ti_datamodel.DagRun | None = None\n     last_ti: ti_datamodel.TaskInstance | None = None\n \n+    @model_validator(mode=\"before\")\n+    @classmethod\n+    def _sanitize_consumed_asset_events(cls, values: Mapping[str, Any]) -> Mapping[str, Any]:\n+        dag_run = values.get(\"dag_run\")\n+\n+        if dag_run is None:\n+            return values\n+\n+        # DagRunContext may receive non-ORM dag_run objects (e.g. datamodels).\n+        # Only apply this validator to ORM-mapped instances.\n+        try:\n+            _ = sa_inspect(dag_run)\n+        except NoInspectionAvailable:\n+            return values\n+\n+        # Relationship access may raise DetachedInstanceError; fall back to empty list to\n+        # avoid crashing the scheduler.\n+        try:\n+            events = dag_run.consumed_asset_events\n+            set_committed_value(\n+                dag_run,\n+                \"consumed_asset_events\",\n+                list(events) if events is not None else [],\n+            )\n+        except DetachedInstanceError:",
      "comment": "Should we try to load the whole DagRun with session instead of return an empty list instead?",
      "comment_id": 2660881143,
      "user": "Lee-W",
      "created_at": "2026-01-05T09:42:18Z",
      "url": "https://github.com/apache/airflow/pull/59857#discussion_r2660881143"
    },
    {
      "repo": "apache/airflow",
      "pr_number": 59857,
      "file_path": "airflow-core/src/airflow/callbacks/callback_requests.py",
      "line": 128,
      "side": "RIGHT",
      "diff_hunk": "@@ -95,6 +103,39 @@ class DagRunContext(BaseModel):\n     dag_run: ti_datamodel.DagRun | None = None\n     last_ti: ti_datamodel.TaskInstance | None = None\n \n+    @model_validator(mode=\"before\")\n+    @classmethod\n+    def _sanitize_consumed_asset_events(cls, values: Mapping[str, Any]) -> Mapping[str, Any]:\n+        dag_run = values.get(\"dag_run\")\n+\n+        if dag_run is None:\n+            return values\n+\n+        # DagRunContext may receive non-ORM dag_run objects (e.g. datamodels).\n+        # Only apply this validator to ORM-mapped instances.\n+        try:\n+            _ = sa_inspect(dag_run)\n+        except NoInspectionAvailable:\n+            return values\n+\n+        # Relationship access may raise DetachedInstanceError; fall back to empty list to\n+        # avoid crashing the scheduler.\n+        try:\n+            events = dag_run.consumed_asset_events\n+            set_committed_value(\n+                dag_run,\n+                \"consumed_asset_events\",\n+                list(events) if events is not None else [],\n+            )\n+        except DetachedInstanceError:",
      "comment": "@Lee-W @uranusjr \r\n\r\nI agree in principle that reloading would be more correct in cases where consumed_asset_events isn\u2019t loaded. My hesitation is about doing that in the validator. consumed_asset_events isn\u2019t eagerly loaded in all contexts, but in the scheduler it\u2019s explicitly populated at DagRun creation time. Hitting a DetachedInstanceError here usually reflects an ORM lifecycle issue (detachment), not missing data.\r\n\r\nSince this validator doesn\u2019t know which context it\u2019s running in and has no session guarantees, reloading here would require implicit DB I/O, which feels risky given validators may run frequently. I see this validator as a last-resort guardrail: log loudly and fail safe rather than reattaching or reloading state at this boundary. If we want to tighten correctness, I think the right place is ensuring reattachment or eager loading happens before DagRunContext is constructed, in a session-aware layer. I believe PR #56916 and #59714 already handle this to a great degree but we could do the same for other places where DagRunContext is called. ",
      "comment_id": 2664613088,
      "user": "SameerMesiah97",
      "created_at": "2026-01-06T11:26:42Z",
      "url": "https://github.com/apache/airflow/pull/59857#discussion_r2664613088"
    },
    {
      "repo": "apache/airflow",
      "pr_number": 59857,
      "file_path": "airflow-core/src/airflow/callbacks/callback_requests.py",
      "line": 128,
      "side": "RIGHT",
      "diff_hunk": "@@ -95,6 +103,39 @@ class DagRunContext(BaseModel):\n     dag_run: ti_datamodel.DagRun | None = None\n     last_ti: ti_datamodel.TaskInstance | None = None\n \n+    @model_validator(mode=\"before\")\n+    @classmethod\n+    def _sanitize_consumed_asset_events(cls, values: Mapping[str, Any]) -> Mapping[str, Any]:\n+        dag_run = values.get(\"dag_run\")\n+\n+        if dag_run is None:\n+            return values\n+\n+        # DagRunContext may receive non-ORM dag_run objects (e.g. datamodels).\n+        # Only apply this validator to ORM-mapped instances.\n+        try:\n+            _ = sa_inspect(dag_run)\n+        except NoInspectionAvailable:\n+            return values\n+\n+        # Relationship access may raise DetachedInstanceError; fall back to empty list to\n+        # avoid crashing the scheduler.\n+        try:\n+            events = dag_run.consumed_asset_events\n+            set_committed_value(\n+                dag_run,\n+                \"consumed_asset_events\",\n+                list(events) if events is not None else [],\n+            )\n+        except DetachedInstanceError:",
      "comment": "Even though the validator itself is frequently called, the DetachedInstanceError is not often encountered. Thus, doing some DB call here should be acceptable. Making it an empty list could be misleading.",
      "comment_id": 2667359353,
      "user": "Lee-W",
      "created_at": "2026-01-07T07:31:26Z",
      "url": "https://github.com/apache/airflow/pull/59857#discussion_r2667359353"
    },
    {
      "repo": "apache/airflow",
      "pr_number": 59857,
      "file_path": "airflow-core/src/airflow/callbacks/callback_requests.py",
      "line": 128,
      "side": "RIGHT",
      "diff_hunk": "@@ -95,6 +103,39 @@ class DagRunContext(BaseModel):\n     dag_run: ti_datamodel.DagRun | None = None\n     last_ti: ti_datamodel.TaskInstance | None = None\n \n+    @model_validator(mode=\"before\")\n+    @classmethod\n+    def _sanitize_consumed_asset_events(cls, values: Mapping[str, Any]) -> Mapping[str, Any]:\n+        dag_run = values.get(\"dag_run\")\n+\n+        if dag_run is None:\n+            return values\n+\n+        # DagRunContext may receive non-ORM dag_run objects (e.g. datamodels).\n+        # Only apply this validator to ORM-mapped instances.\n+        try:\n+            _ = sa_inspect(dag_run)\n+        except NoInspectionAvailable:\n+            return values\n+\n+        # Relationship access may raise DetachedInstanceError; fall back to empty list to\n+        # avoid crashing the scheduler.\n+        try:\n+            events = dag_run.consumed_asset_events\n+            set_committed_value(\n+                dag_run,\n+                \"consumed_asset_events\",\n+                list(events) if events is not None else [],\n+            )\n+        except DetachedInstanceError:",
      "comment": "@Lee-W that addresses my concern. I will reload the DagRun with a session like you requested. Thank you for clarifying that. ",
      "comment_id": 2668395546,
      "user": "SameerMesiah97",
      "created_at": "2026-01-07T13:13:12Z",
      "url": "https://github.com/apache/airflow/pull/59857#discussion_r2668395546"
    },
    {
      "repo": "apache/airflow",
      "pr_number": 59857,
      "file_path": "airflow-core/src/airflow/callbacks/callback_requests.py",
      "line": 128,
      "side": "RIGHT",
      "diff_hunk": "@@ -95,6 +103,39 @@ class DagRunContext(BaseModel):\n     dag_run: ti_datamodel.DagRun | None = None\n     last_ti: ti_datamodel.TaskInstance | None = None\n \n+    @model_validator(mode=\"before\")\n+    @classmethod\n+    def _sanitize_consumed_asset_events(cls, values: Mapping[str, Any]) -> Mapping[str, Any]:\n+        dag_run = values.get(\"dag_run\")\n+\n+        if dag_run is None:\n+            return values\n+\n+        # DagRunContext may receive non-ORM dag_run objects (e.g. datamodels).\n+        # Only apply this validator to ORM-mapped instances.\n+        try:\n+            _ = sa_inspect(dag_run)\n+        except NoInspectionAvailable:\n+            return values\n+\n+        # Relationship access may raise DetachedInstanceError; fall back to empty list to\n+        # avoid crashing the scheduler.\n+        try:\n+            events = dag_run.consumed_asset_events\n+            set_committed_value(\n+                dag_run,\n+                \"consumed_asset_events\",\n+                list(events) if events is not None else [],\n+            )\n+        except DetachedInstanceError:",
      "comment": "@Lee-W \r\n\r\nI have modified the validator to reload the DagRun object with consumed_asset_events. Tests have been updated as well as the PR description. ",
      "comment_id": 2670350527,
      "user": "SameerMesiah97",
      "created_at": "2026-01-07T23:06:18Z",
      "url": "https://github.com/apache/airflow/pull/59857#discussion_r2670350527"
    },
    {
      "repo": "apache/airflow",
      "pr_number": 56445,
      "file_path": "providers/google/src/airflow/providers/google/event_scheduling/events/pubsub.py",
      "line": 29,
      "side": "RIGHT",
      "diff_hunk": "@@ -0,0 +1,68 @@\n+# Licensed to the Apache Software Foundation (ASF) under one\n+# or more contributor license agreements.  See the NOTICE file\n+# distributed with this work for additional information\n+# regarding copyright ownership.  The ASF licenses this file\n+# to you under the Apache License, Version 2.0 (the\n+# \"License\"); you may not use this file except in compliance\n+# with the License.  You may obtain a copy of the License at\n+#\n+#   http://www.apache.org/licenses/LICENSE-2.0\n+#\n+# Unless required by applicable law or agreed to in writing,\n+# software distributed under the License is distributed on an\n+# \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+# KIND, either express or implied.  See the License for the\n+# specific language governing permissions and limitations\n+# under the License.\n+from __future__ import annotations\n+\n+from typing import TYPE_CHECKING\n+\n+from airflow.exceptions import AirflowOptionalProviderFeatureException\n+from airflow.providers.google.cloud.triggers.pubsub import PubsubPullTrigger\n+\n+try:\n+    from airflow.providers.common.messaging.providers.base_provider import BaseMessageQueueProvider\n+except ImportError:\n+    raise AirflowOptionalProviderFeatureException(\n+        \"This feature requires the 'common.messaging' provider to be installed in version >= 1.0.1.\"\n+    )",
      "comment": "Then we don't need the compatibility check when importing.\r\n\r\n```suggestion\r\nfrom airflow.providers.common.messaging.providers.base_provider import BaseMessageQueueProvider\r\n```",
      "comment_id": 2693614606,
      "user": "jason810496",
      "created_at": "2026-01-15T09:25:37Z",
      "url": "https://github.com/apache/airflow/pull/56445#discussion_r2693614606"
    },
    {
      "repo": "apache/airflow",
      "pr_number": 59245,
      "file_path": "providers/fab/src/airflow/providers/fab/auth_manager/fab_auth_manager.py",
      "line": 327,
      "side": "RIGHT",
      "diff_hunk": "@@ -299,6 +300,32 @@ def is_logged_in(self) -> bool:\n             or (not user.is_anonymous and user.is_active)\n         )\n \n+    def create_token(self, headers: dict[str, str], body: dict[str, Any]) -> User:\n+        \"\"\"\n+        Create a new token from a payload.\n+\n+        By default, it uses basic authentication (username and password).\n+        Override this method to use a different authentication method (e.g. oauth).\n+\n+        :param headers: request headers\n+        :param body: request body\n+        \"\"\"\n+        if not body.get(\"username\") or not body.get(\"password\"):\n+            raise ValueError(\"Username and password must be provided\")\n+\n+        user: User | None = None\n+\n+        if self.security_manager.auth_type == AUTH_LDAP:\n+            user = self.security_manager.auth_user_ldap(\n+                body[\"username\"], body[\"password\"], rotate_session_id=False\n+            )\n+        if user is None:\n+            user = self.security_manager.auth_user_db(\n+                body[\"username\"], body[\"password\"], rotate_session_id=False\n+            )\n+\n+        return user",
      "comment": "@vincbeck I was stumbling aver this today, I assume the type definition is not correct in the signature? I would assume the function returns `User | None` if user is not found as it then does not raise an exception?",
      "comment_id": 2714245315,
      "user": "jscheffl",
      "created_at": "2026-01-21T20:33:31Z",
      "url": "https://github.com/apache/airflow/pull/59245#discussion_r2714245315"
    },
    {
      "repo": "apache/airflow",
      "pr_number": 60801,
      "file_path": "airflow-core/src/airflow/api_fastapi/core_api/routes/public/import_error.py",
      "line": 85,
      "side": "LEFT",
      "diff_hunk": "@@ -79,11 +79,6 @@ def get_import_error(\n     session.expunge(error)\n \n     auth_manager = get_auth_manager()\n-    can_read_all_dags = auth_manager.is_authorized_dag(method=\"GET\", user=user)\n-    if can_read_all_dags:\n-        # Early return if the user has access to all DAGs\n-        return error",
      "comment": "Does this risk performance issues for admins by forcing `get_authorized_dag_ids` to return a massive list of IDs instead of short-circuiting?",
      "comment_id": 2706162288,
      "user": "dheerajturaga",
      "created_at": "2026-01-19T21:44:59Z",
      "url": "https://github.com/apache/airflow/pull/60801#discussion_r2706162288"
    },
    {
      "repo": "apache/airflow",
      "pr_number": 60801,
      "file_path": "airflow-core/src/airflow/api_fastapi/core_api/routes/public/import_error.py",
      "line": 85,
      "side": "LEFT",
      "diff_hunk": "@@ -79,11 +79,6 @@ def get_import_error(\n     session.expunge(error)\n \n     auth_manager = get_auth_manager()\n-    can_read_all_dags = auth_manager.is_authorized_dag(method=\"GET\", user=user)\n-    if can_read_all_dags:\n-        # Early return if the user has access to all DAGs\n-        return error",
      "comment": "Yeah I also liked the early returns for massive dag ids list. But I don't think we have the equivalent for 'read all dags'.\n\nThe `batch_is_authorized_dag` shouldn't be too costly.",
      "comment_id": 2707667921,
      "user": "pierrejeambrun",
      "created_at": "2026-01-20T10:11:39Z",
      "url": "https://github.com/apache/airflow/pull/60801#discussion_r2707667921"
    },
    {
      "repo": "apache/airflow",
      "pr_number": 60801,
      "file_path": "airflow-core/src/airflow/api_fastapi/core_api/routes/public/import_error.py",
      "line": 82,
      "side": "RIGHT",
      "diff_hunk": "@@ -79,11 +79,6 @@ def get_import_error(\n     session.expunge(error)\n \n     auth_manager = get_auth_manager()\n-    can_read_all_dags = auth_manager.is_authorized_dag(method=\"GET\", user=user)\n-    if can_read_all_dags:\n-        # Early return if the user has access to all DAGs\n-        return error\n-\n     readable_dag_ids = auth_manager.get_authorized_dag_ids(user=user)",
      "comment": "Don't we have the same problem here? We will create a CTE with ids that correspond to dag we can 'list' but not to dags we can 'read' details from.",
      "comment_id": 2707702316,
      "user": "pierrejeambrun",
      "created_at": "2026-01-20T10:20:21Z",
      "url": "https://github.com/apache/airflow/pull/60801#discussion_r2707702316"
    },
    {
      "repo": "apache/airflow",
      "pr_number": 60801,
      "file_path": "airflow-core/src/airflow/api_fastapi/core_api/routes/public/import_error.py",
      "line": 85,
      "side": "LEFT",
      "diff_hunk": "@@ -79,11 +79,6 @@ def get_import_error(\n     session.expunge(error)\n \n     auth_manager = get_auth_manager()\n-    can_read_all_dags = auth_manager.is_authorized_dag(method=\"GET\", user=user)\n-    if can_read_all_dags:\n-        # Early return if the user has access to all DAGs\n-        return error",
      "comment": "Exactly what Pierre said, we have no way of knowing whether the user has access to all dags",
      "comment_id": 2708827386,
      "user": "vincbeck",
      "created_at": "2026-01-20T15:20:02Z",
      "url": "https://github.com/apache/airflow/pull/60801#discussion_r2708827386"
    },
    {
      "repo": "apache/airflow",
      "pr_number": 60801,
      "file_path": "airflow-core/src/airflow/api_fastapi/core_api/routes/public/import_error.py",
      "line": 82,
      "side": "RIGHT",
      "diff_hunk": "@@ -79,11 +79,6 @@ def get_import_error(\n     session.expunge(error)\n \n     auth_manager = get_auth_manager()\n-    can_read_all_dags = auth_manager.is_authorized_dag(method=\"GET\", user=user)\n-    if can_read_all_dags:\n-        # Early return if the user has access to all DAGs\n-        return error\n-\n     readable_dag_ids = auth_manager.get_authorized_dag_ids(user=user)",
      "comment": "No, `get_authorized_dag_ids` return the list of Dags the user can read",
      "comment_id": 2708832492,
      "user": "vincbeck",
      "created_at": "2026-01-20T15:21:19Z",
      "url": "https://github.com/apache/airflow/pull/60801#discussion_r2708832492"
    },
    {
      "repo": "apache/airflow",
      "pr_number": 59643,
      "file_path": "airflow-core/src/airflow/api_fastapi/core_api/routes/public/connections.py",
      "line": 241,
      "side": "RIGHT",
      "diff_hunk": "@@ -234,6 +237,21 @@ def test_connection(\n     try:\n         data = test_body.model_dump(by_alias=True)\n         data[\"conn_id\"] = transient_conn_id\n+\n+        existing_conn = session.scalar(",
      "comment": "Should not we use `Connection.get_connection_from_secrets` ? -> this is the \"canonical\" (even if badly named) way of retrieving connection. We should not read the connections directly from the database, because the connections might be defined in secrets?\n\nSurely you won't be able to test those \"secret backends only\" connections via UI, but since this is an API call, it should still handle running \"/test\" API with the conn_id that is defined in secrets.",
      "comment_id": 2637124431,
      "user": "potiuk",
      "created_at": "2025-12-20T13:47:44Z",
      "url": "https://github.com/apache/airflow/pull/59643#discussion_r2637124431"
    },
    {
      "repo": "apache/airflow",
      "pr_number": 59643,
      "file_path": "airflow-core/src/airflow/api_fastapi/core_api/routes/public/connections.py",
      "line": 241,
      "side": "RIGHT",
      "diff_hunk": "@@ -234,6 +237,21 @@ def test_connection(\n     try:\n         data = test_body.model_dump(by_alias=True)\n         data[\"conn_id\"] = transient_conn_id\n+\n+        existing_conn = session.scalar(",
      "comment": "Thanks for catching this, I missed it.\nThis approach seems more appropriate than reading the connection directly from the database.",
      "comment_id": 2637192836,
      "user": "choo121600",
      "created_at": "2025-12-20T16:05:07Z",
      "url": "https://github.com/apache/airflow/pull/59643#discussion_r2637192836"
    },
    {
      "repo": "apache/airflow",
      "pr_number": 59643,
      "file_path": "airflow-core/src/airflow/api_fastapi/core_api/routes/public/connections.py",
      "line": 244,
      "side": "RIGHT",
      "diff_hunk": "@@ -234,6 +237,22 @@ def test_connection(\n     try:\n         data = test_body.model_dump(by_alias=True)\n         data[\"conn_id\"] = transient_conn_id\n+\n+        try:\n+            existing_conn = Connection.get_connection_from_secrets(test_body.connection_id)\n+            if data.get(\"password\") is not None and existing_conn.password is not None:\n+                data[\"password\"] = merge(data[\"password\"], existing_conn.password, \"password\")",
      "comment": "Not sure would it be better to introduce a new query parameter to distinguish whether to use credentials from  the existed connection?\n\nOr maybe we could change the Frontend that only passing `connection_id` and `conn_type`, and the Backend will only fill-up the credentials if `password` and `extra` are unset?\n\nSince there might be user directly call public API with the existed `connection_id`, but they want to test the credentials provided by API instead of existed credentials in the DB / Secret.",
      "comment_id": 2637616197,
      "user": "jason810496",
      "created_at": "2025-12-21T06:27:39Z",
      "url": "https://github.com/apache/airflow/pull/59643#discussion_r2637616197"
    },
    {
      "repo": "apache/airflow",
      "pr_number": 59643,
      "file_path": "airflow-core/src/airflow/api_fastapi/core_api/routes/public/connections.py",
      "line": 244,
      "side": "RIGHT",
      "diff_hunk": "@@ -234,6 +237,22 @@ def test_connection(\n     try:\n         data = test_body.model_dump(by_alias=True)\n         data[\"conn_id\"] = transient_conn_id\n+\n+        try:\n+            existing_conn = Connection.get_connection_from_secrets(test_body.connection_id)\n+            if data.get(\"password\") is not None and existing_conn.password is not None:\n+                data[\"password\"] = merge(data[\"password\"], existing_conn.password, \"password\")",
      "comment": "I agree that if an API user provides both `connection_id` and `password`, the current behavior may not match what the user expects. Thanks for find this!\r\nI\u2019m currently thinking about how to resolve this, but it\u2019s starting to feel a bit complex as more conditions are added\ud83d\ude22\r\n\r\nI think I\u2019ll need to take a closer look later this evening. Understanding the secrets backend also feels somewhat complex, so it may take a bit more time.",
      "comment_id": 2637698743,
      "user": "choo121600",
      "created_at": "2025-12-21T09:16:04Z",
      "url": "https://github.com/apache/airflow/pull/59643#discussion_r2637698743"
    },
    {
      "repo": "apache/airflow",
      "pr_number": 59643,
      "file_path": "airflow-core/src/airflow/api_fastapi/core_api/routes/public/connections.py",
      "line": 249,
      "side": "RIGHT",
      "diff_hunk": "@@ -234,6 +243,23 @@ def test_connection(\n     try:\n         data = test_body.model_dump(by_alias=True)\n         data[\"conn_id\"] = transient_conn_id\n+\n+        if use_existing_credentials:\n+            try:\n+                existing_conn = Connection.get_connection_from_secrets(test_body.connection_id)",
      "comment": "The API operates for now only on DB connections (delete, patch, etc...). I would keep it consistent and only do a 'db' call there to keep things simple. \n\nThen if we want to be able to do  a secret backend lookup, I would do that in a follow up PR if needed. ",
      "comment_id": 2675609645,
      "user": "pierrejeambrun",
      "created_at": "2026-01-09T10:13:44Z",
      "url": "https://github.com/apache/airflow/pull/59643#discussion_r2675609645"
    },
    {
      "repo": "apache/airflow",
      "pr_number": 59643,
      "file_path": "airflow-core/src/airflow/api_fastapi/core_api/routes/public/connections.py",
      "line": 249,
      "side": "RIGHT",
      "diff_hunk": "@@ -234,6 +243,23 @@ def test_connection(\n     try:\n         data = test_body.model_dump(by_alias=True)\n         data[\"conn_id\"] = transient_conn_id\n+\n+        if use_existing_credentials:\n+            try:\n+                existing_conn = Connection.get_connection_from_secrets(test_body.connection_id)",
      "comment": "As I understand it, for now it would be better to keep the API limited to DB connections only to maintain consistency.\r\nIn that case, would it make more sense to change it to a direct DB lookup like below, as I tried previously?\r\n```py\r\nexisting_orm_conn = session.scalar(\r\n    select(Connection).where(Connection.conn_id == test_body.connection_id).limit(1)\r\n)\r\n```",
      "comment_id": 2678313282,
      "user": "choo121600",
      "created_at": "2026-01-10T04:35:07Z",
      "url": "https://github.com/apache/airflow/pull/59643#discussion_r2678313282"
    },
    {
      "repo": "apache/airflow",
      "pr_number": 59643,
      "file_path": "airflow-core/src/airflow/api_fastapi/core_api/routes/public/connections.py",
      "line": 249,
      "side": "RIGHT",
      "diff_hunk": "@@ -234,6 +243,23 @@ def test_connection(\n     try:\n         data = test_body.model_dump(by_alias=True)\n         data[\"conn_id\"] = transient_conn_id\n+\n+        if use_existing_credentials:\n+            try:\n+                existing_conn = Connection.get_connection_from_secrets(test_body.connection_id)",
      "comment": "I was suggesting that in my previous comment, but I realized that `get_connection_from_secrets` already returns an orm instance, so it will not be a big effort to support private backend connection too. We can keep the `get_connection_from_secrets` to allow testing all connections, just get rid of `use_existing_credentials`, use the utility method to merge the object, test the connection, and discard the merged orm object before returning.",
      "comment_id": 2686753255,
      "user": "pierrejeambrun",
      "created_at": "2026-01-13T14:47:37Z",
      "url": "https://github.com/apache/airflow/pull/59643#discussion_r2686753255"
    },
    {
      "repo": "apache/airflow",
      "pr_number": 59643,
      "file_path": "airflow-core/tests/unit/api_fastapi/core_api/routes/public/test_connections.py",
      "line": 997,
      "side": "RIGHT",
      "diff_hunk": "@@ -992,14 +992,85 @@ def test_connection_env_is_cleaned_after_run(self, test_client, body):\n             {\"connection_id\": TEST_CONN_ID, \"conn_type\": \"ftp\"},\n         ],\n     )\n-    def test_should_respond_403_by_default(self, test_client, body):\n+    @mock.patch(\"airflow.api_fastapi.core_api.routes.public.connections.conf.get\")\n+    def test_should_respond_403_by_default(self, mock_conf_get, test_client, body):\n+        mock_conf_get.return_value = \"Disabled\"",
      "comment": "Why is that needed. By default this is \"Disabled\", you shouldn't need that.\n\nProbably a local conf or something interfering with the tests, your change doesn't seem to impact this.",
      "comment_id": 2694477413,
      "user": "pierrejeambrun",
      "created_at": "2026-01-15T13:51:54Z",
      "url": "https://github.com/apache/airflow/pull/59643#discussion_r2694477413"
    },
    {
      "repo": "apache/airflow",
      "pr_number": 59643,
      "file_path": "airflow-core/tests/unit/api_fastapi/core_api/routes/public/test_connections.py",
      "line": 1027,
      "side": "RIGHT",
      "diff_hunk": "@@ -992,14 +992,85 @@ def test_connection_env_is_cleaned_after_run(self, test_client, body):\n             {\"connection_id\": TEST_CONN_ID, \"conn_type\": \"ftp\"},\n         ],\n     )\n-    def test_should_respond_403_by_default(self, test_client, body):\n+    @mock.patch(\"airflow.api_fastapi.core_api.routes.public.connections.conf.get\")\n+    def test_should_respond_403_by_default(self, mock_conf_get, test_client, body):\n+        mock_conf_get.return_value = \"Disabled\"\n         response = test_client.post(\"/connections/test\", json=body)\n         assert response.status_code == 403\n         assert response.json() == {\n             \"detail\": \"Testing connections is disabled in Airflow configuration. \"\n             \"Contact your deployment admin to enable it.\"\n         }\n \n+    @mock.patch.dict(os.environ, {\"AIRFLOW__CORE__TEST_CONNECTION\": \"Enabled\"})\n+    def test_should_merge_password_with_existing_connection(self, test_client, session):\n+        connection = Connection(\n+            conn_id=TEST_CONN_ID,\n+            conn_type=\"sqlite\",\n+            password=\"existing_password\",\n+        )\n+        session.add(connection)\n+        session.commit()\n+\n+        body = {\n+            \"connection_id\": TEST_CONN_ID,\n+            \"conn_type\": \"sqlite\",\n+            \"password\": \"***\",\n+        }",
      "comment": "How does this test that the password used is actually \"existing_password\" and not \"***\" when performing the `conn.test_connection` ?",
      "comment_id": 2694500280,
      "user": "pierrejeambrun",
      "created_at": "2026-01-15T13:58:11Z",
      "url": "https://github.com/apache/airflow/pull/59643#discussion_r2694500280"
    },
    {
      "repo": "apache/airflow",
      "pr_number": 59643,
      "file_path": "airflow-core/tests/unit/api_fastapi/core_api/routes/public/test_connections.py",
      "line": 1066,
      "side": "RIGHT",
      "diff_hunk": "@@ -992,14 +992,85 @@ def test_connection_env_is_cleaned_after_run(self, test_client, body):\n             {\"connection_id\": TEST_CONN_ID, \"conn_type\": \"ftp\"},\n         ],\n     )\n-    def test_should_respond_403_by_default(self, test_client, body):\n+    @mock.patch(\"airflow.api_fastapi.core_api.routes.public.connections.conf.get\")\n+    def test_should_respond_403_by_default(self, mock_conf_get, test_client, body):\n+        mock_conf_get.return_value = \"Disabled\"\n         response = test_client.post(\"/connections/test\", json=body)\n         assert response.status_code == 403\n         assert response.json() == {\n             \"detail\": \"Testing connections is disabled in Airflow configuration. \"\n             \"Contact your deployment admin to enable it.\"\n         }\n \n+    @mock.patch.dict(os.environ, {\"AIRFLOW__CORE__TEST_CONNECTION\": \"Enabled\"})\n+    def test_should_merge_password_with_existing_connection(self, test_client, session):\n+        connection = Connection(\n+            conn_id=TEST_CONN_ID,\n+            conn_type=\"sqlite\",\n+            password=\"existing_password\",\n+        )\n+        session.add(connection)\n+        session.commit()\n+\n+        body = {\n+            \"connection_id\": TEST_CONN_ID,\n+            \"conn_type\": \"sqlite\",\n+            \"password\": \"***\",\n+        }\n+        response = test_client.post(\"/connections/test\", json=body)\n+        assert response.status_code == 200\n+        assert response.json()[\"status\"] is True\n+\n+    @mock.patch.dict(os.environ, {\"AIRFLOW__CORE__TEST_CONNECTION\": \"Enabled\"})\n+    def test_should_merge_extra_with_existing_connection(self, test_client, session):\n+        connection = Connection(\n+            conn_id=TEST_CONN_ID,\n+            conn_type=\"fs\",\n+            extra='{\"path\": \"/\", \"existing_key\": \"existing_value\"}',\n+        )\n+        session.add(connection)\n+        session.commit()\n+\n+        body = {\n+            \"connection_id\": TEST_CONN_ID,\n+            \"conn_type\": \"fs\",\n+            \"extra\": '{\"path\": \"/\", \"new_key\": \"new_value\"}',\n+        }",
      "comment": "Same here, how do we now the \"new_key\" is taken into account?",
      "comment_id": 2694502543,
      "user": "pierrejeambrun",
      "created_at": "2026-01-15T13:58:48Z",
      "url": "https://github.com/apache/airflow/pull/59643#discussion_r2694502543"
    },
    {
      "repo": "apache/airflow",
      "pr_number": 59643,
      "file_path": "airflow-core/tests/unit/api_fastapi/core_api/routes/public/test_connections.py",
      "line": 1033,
      "side": "RIGHT",
      "diff_hunk": "@@ -992,14 +992,85 @@ def test_connection_env_is_cleaned_after_run(self, test_client, body):\n             {\"connection_id\": TEST_CONN_ID, \"conn_type\": \"ftp\"},\n         ],\n     )\n-    def test_should_respond_403_by_default(self, test_client, body):\n+    @mock.patch(\"airflow.api_fastapi.core_api.routes.public.connections.conf.get\")\n+    def test_should_respond_403_by_default(self, mock_conf_get, test_client, body):\n+        mock_conf_get.return_value = \"Disabled\"\n         response = test_client.post(\"/connections/test\", json=body)\n         assert response.status_code == 403\n         assert response.json() == {\n             \"detail\": \"Testing connections is disabled in Airflow configuration. \"\n             \"Contact your deployment admin to enable it.\"\n         }\n \n+    @mock.patch.dict(os.environ, {\"AIRFLOW__CORE__TEST_CONNECTION\": \"Enabled\"})\n+    def test_should_merge_password_with_existing_connection(self, test_client, session):\n+        connection = Connection(\n+            conn_id=TEST_CONN_ID,\n+            conn_type=\"sqlite\",\n+            password=\"existing_password\",\n+        )\n+        session.add(connection)\n+        session.commit()\n+\n+        body = {\n+            \"connection_id\": TEST_CONN_ID,\n+            \"conn_type\": \"sqlite\",\n+            \"password\": \"***\",\n+        }\n+        response = test_client.post(\"/connections/test\", json=body)\n+        assert response.status_code == 200\n+        assert response.json()[\"status\"] is True",
      "comment": "I would also add an assertion to check that hte `TEST_CONN_ID` wasn't mutated into db, and that no other connection record was created. (I.e the merged connection is not persisted anywhere)",
      "comment_id": 2694510409,
      "user": "pierrejeambrun",
      "created_at": "2026-01-15T14:00:52Z",
      "url": "https://github.com/apache/airflow/pull/59643#discussion_r2694510409"
    },
    {
      "repo": "apache/airflow",
      "pr_number": 59643,
      "file_path": "airflow-core/tests/unit/api_fastapi/core_api/routes/public/test_connections.py",
      "line": 997,
      "side": "RIGHT",
      "diff_hunk": "@@ -992,14 +992,85 @@ def test_connection_env_is_cleaned_after_run(self, test_client, body):\n             {\"connection_id\": TEST_CONN_ID, \"conn_type\": \"ftp\"},\n         ],\n     )\n-    def test_should_respond_403_by_default(self, test_client, body):\n+    @mock.patch(\"airflow.api_fastapi.core_api.routes.public.connections.conf.get\")\n+    def test_should_respond_403_by_default(self, mock_conf_get, test_client, body):\n+        mock_conf_get.return_value = \"Disabled\"",
      "comment": "I removed the unnecessary mock since the default value is already \"Disabled\" :)",
      "comment_id": 2702174365,
      "user": "choo121600",
      "created_at": "2026-01-18T06:58:53Z",
      "url": "https://github.com/apache/airflow/pull/59643#discussion_r2702174365"
    },
    {
      "repo": "apache/airflow",
      "pr_number": 59643,
      "file_path": "airflow-core/tests/unit/api_fastapi/core_api/routes/public/test_connections.py",
      "line": 1027,
      "side": "RIGHT",
      "diff_hunk": "@@ -992,14 +992,85 @@ def test_connection_env_is_cleaned_after_run(self, test_client, body):\n             {\"connection_id\": TEST_CONN_ID, \"conn_type\": \"ftp\"},\n         ],\n     )\n-    def test_should_respond_403_by_default(self, test_client, body):\n+    @mock.patch(\"airflow.api_fastapi.core_api.routes.public.connections.conf.get\")\n+    def test_should_respond_403_by_default(self, mock_conf_get, test_client, body):\n+        mock_conf_get.return_value = \"Disabled\"\n         response = test_client.post(\"/connections/test\", json=body)\n         assert response.status_code == 403\n         assert response.json() == {\n             \"detail\": \"Testing connections is disabled in Airflow configuration. \"\n             \"Contact your deployment admin to enable it.\"\n         }\n \n+    @mock.patch.dict(os.environ, {\"AIRFLOW__CORE__TEST_CONNECTION\": \"Enabled\"})\n+    def test_should_merge_password_with_existing_connection(self, test_client, session):\n+        connection = Connection(\n+            conn_id=TEST_CONN_ID,\n+            conn_type=\"sqlite\",\n+            password=\"existing_password\",\n+        )\n+        session.add(connection)\n+        session.commit()\n+\n+        body = {\n+            \"connection_id\": TEST_CONN_ID,\n+            \"conn_type\": \"sqlite\",\n+            \"password\": \"***\",\n+        }",
      "comment": "I added a mock_test_connection function that captures the actual password used during the test.\r\nwe assert that captured_password[\"value\"] == \"existing_password\" to verify the existing password is used instead of \"***\"",
      "comment_id": 2702174714,
      "user": "choo121600",
      "created_at": "2026-01-18T06:59:49Z",
      "url": "https://github.com/apache/airflow/pull/59643#discussion_r2702174714"
    },
    {
      "repo": "apache/airflow",
      "pr_number": 59643,
      "file_path": "airflow-core/tests/unit/api_fastapi/core_api/routes/public/test_connections.py",
      "line": 1033,
      "side": "RIGHT",
      "diff_hunk": "@@ -992,14 +992,85 @@ def test_connection_env_is_cleaned_after_run(self, test_client, body):\n             {\"connection_id\": TEST_CONN_ID, \"conn_type\": \"ftp\"},\n         ],\n     )\n-    def test_should_respond_403_by_default(self, test_client, body):\n+    @mock.patch(\"airflow.api_fastapi.core_api.routes.public.connections.conf.get\")\n+    def test_should_respond_403_by_default(self, mock_conf_get, test_client, body):\n+        mock_conf_get.return_value = \"Disabled\"\n         response = test_client.post(\"/connections/test\", json=body)\n         assert response.status_code == 403\n         assert response.json() == {\n             \"detail\": \"Testing connections is disabled in Airflow configuration. \"\n             \"Contact your deployment admin to enable it.\"\n         }\n \n+    @mock.patch.dict(os.environ, {\"AIRFLOW__CORE__TEST_CONNECTION\": \"Enabled\"})\n+    def test_should_merge_password_with_existing_connection(self, test_client, session):\n+        connection = Connection(\n+            conn_id=TEST_CONN_ID,\n+            conn_type=\"sqlite\",\n+            password=\"existing_password\",\n+        )\n+        session.add(connection)\n+        session.commit()\n+\n+        body = {\n+            \"connection_id\": TEST_CONN_ID,\n+            \"conn_type\": \"sqlite\",\n+            \"password\": \"***\",\n+        }\n+        response = test_client.post(\"/connections/test\", json=body)\n+        assert response.status_code == 200\n+        assert response.json()[\"status\"] is True",
      "comment": "I would also add an assertion to check wasn't mutated into db, and that no other connection record was created",
      "comment_id": 2702177199,
      "user": "choo121600",
      "created_at": "2026-01-18T07:04:55Z",
      "url": "https://github.com/apache/airflow/pull/59643#discussion_r2702177199"
    },
    {
      "repo": "apache/airflow",
      "pr_number": 58295,
      "file_path": "airflow-core/tests/unit/dag_processing/bundles/test_base.py",
      "line": 227,
      "side": "RIGHT",
      "diff_hunk": "@@ -202,6 +202,30 @@ def test_that_no_version_is_noop(self):\n         assert b.lock_file_path is None\n         assert b.lock_file is None\n \n+    def test_log_exc_formats_message_correctly(self):\n+        \"\"\"Test that _log_exc correctly formats the log message with all parameters.\"\"\"\n+        from airflow.dag_processing.bundles.base import log as bundle_log\n+\n+        bundle_name = \"test_bundle\"\n+        bundle_version = \"v1.0.0\"\n+        lock = BundleVersionLock(\n+            bundle_name=bundle_name,\n+            bundle_version=bundle_version,\n+        )\n+\n+        test_msg = \"error when attempting to acquire lock\"\n+\n+        with patch.object(bundle_log, \"exception\") as mock_exception:\n+            lock._log_exc(test_msg)\n+\n+            mock_exception.assert_called_once()\n+            call_args = mock_exception.call_args\n+            assert call_args[0][0] == \"%s name=%s version=%s lock_file=%s\"\n+            assert call_args[0][1] == test_msg\n+            assert call_args[0][2] == bundle_name\n+            assert call_args[0][3] == bundle_version\n+            assert call_args[0][4] == lock.lock_file_path",
      "comment": "```suggestion\n            assert mock_exception.mock_calls == [\n                call(\n                    \"%s name=%s version=%s lock_file=%s\",\n                    test_msg,\n                    bundle_name,\n                    bundle_version,\n                    lock.ock_file_paht\n                )\n            ]\n```",
      "comment_id": 2706890160,
      "user": "Lee-W",
      "created_at": "2026-01-20T06:07:54Z",
      "url": "https://github.com/apache/airflow/pull/58295#discussion_r2706890160"
    },
    {
      "repo": "apache/airflow",
      "pr_number": 60689,
      "file_path": "providers/snowflake/src/airflow/providers/snowflake/hooks/snowflake_sql_api.py",
      "line": 82,
      "side": "RIGHT",
      "diff_hunk": "@@ -78,6 +79,7 @@ class SnowflakeSqlApiHook(SnowflakeHook):\n     :param token_renewal_delta: Renewal time of the JWT Token in timedelta\n     :param deferrable: Run operator in the deferrable mode.\n     :param api_retry_args: An optional dictionary with arguments passed to ``tenacity.Retrying`` & ``tenacity.AsyncRetrying`` classes.\n+    :param http_timeout_seconds: Optional timeout for http requests.",
      "comment": "I think we should avoid it.\r\nThis is just 1 parameter out of so many that can be passed to request.\r\nI rather have `request_kwargs` then each user can pass any parameter accepted by requests.\r\nI think that is how we do it in other http related operators?",
      "comment_id": 2700868724,
      "user": "eladkal",
      "created_at": "2026-01-17T10:19:09Z",
      "url": "https://github.com/apache/airflow/pull/60689#discussion_r2700868724"
    },
    {
      "repo": "apache/airflow",
      "pr_number": 60689,
      "file_path": "providers/snowflake/src/airflow/providers/snowflake/hooks/snowflake_sql_api.py",
      "line": 82,
      "side": "RIGHT",
      "diff_hunk": "@@ -78,6 +79,7 @@ class SnowflakeSqlApiHook(SnowflakeHook):\n     :param token_renewal_delta: Renewal time of the JWT Token in timedelta\n     :param deferrable: Run operator in the deferrable mode.\n     :param api_retry_args: An optional dictionary with arguments passed to ``tenacity.Retrying`` & ``tenacity.AsyncRetrying`` classes.\n+    :param http_timeout_seconds: Optional timeout for http requests.",
      "comment": "@eladkal Thank you for the suggestion \ud83d\ude42\r\n\r\nI agree that passing request parameters as kwargs can make the interface more flexible, and this is a pattern we use in other HTTP-related hooks.\r\n\r\nThat said, this hook supports both sync (requests) and async (aiohttp) execution. Their request interfaces and timeout behavior are different, so using a single generic kwargs dict would either add extra complexity or work well for only one of the two paths.\r\n\r\nGiven the nature of this workload, I didn\u2019t see strong value in splitting the timeout into multiple phases. The SQL API call is essentially a single request, so I chose to keep a single total timeout and keep the logic simple.\r\n\r\nFor this reason, I kept the change focused on a single, explicit timeout parameter and added a comment to clarify the scope:\r\n`# For simplicity, we only configure the total timeout (no per-phase tuning).`\r\n\r\nIf I misunderstood anything, please let me know. I\u2019m happy to adjust.",
      "comment_id": 2700939344,
      "user": "HyunWooZZ",
      "created_at": "2026-01-17T11:00:10Z",
      "url": "https://github.com/apache/airflow/pull/60689#discussion_r2700939344"
    },
    {
      "repo": "apache/airflow",
      "pr_number": 60689,
      "file_path": "providers/snowflake/src/airflow/providers/snowflake/hooks/snowflake_sql_api.py",
      "line": 82,
      "side": "RIGHT",
      "diff_hunk": "@@ -78,6 +79,7 @@ class SnowflakeSqlApiHook(SnowflakeHook):\n     :param token_renewal_delta: Renewal time of the JWT Token in timedelta\n     :param deferrable: Run operator in the deferrable mode.\n     :param api_retry_args: An optional dictionary with arguments passed to ``tenacity.Retrying`` & ``tenacity.AsyncRetrying`` classes.\n+    :param http_timeout_seconds: Optional timeout for http requests.",
      "comment": "> so using a single generic kwargs dict would either add extra complexity or work well for only one of the two paths.\r\n\r\ncan you explain the complexity?\r\nThe way I see it you get a dict from user and you just pass it as parameter to the underlying library (whatever that may be). What am I missing?",
      "comment_id": 2700972737,
      "user": "eladkal",
      "created_at": "2026-01-17T11:22:51Z",
      "url": "https://github.com/apache/airflow/pull/60689#discussion_r2700972737"
    },
    {
      "repo": "apache/airflow",
      "pr_number": 60689,
      "file_path": "providers/snowflake/src/airflow/providers/snowflake/hooks/snowflake_sql_api.py",
      "line": 480,
      "side": "RIGHT",
      "diff_hunk": "@@ -472,9 +477,10 @@ def _make_api_call_with_retries(\n             for attempt in Retrying(**self.retry_config):  # type: ignore\n                 with attempt:\n                     if method.upper() in (\"GET\", \"POST\"):\n-                        response = session.request(\n-                            method=method.lower(), url=url, headers=headers, params=params, json=json\n-                        )\n+                        request_kwargs = dict(method=method.lower(), url=url, headers=headers, params=params, json=json)",
      "comment": "I'll make this change with the below review is complete.\r\nhttps://github.com/apache/airflow/pull/60689/files#r2700868724\r\n```python\r\nrequest_kwargs: dict[str, Any] = {\r\n    \"method\": method.lower(),\r\n    \"url\": url,\r\n    \"headers\": headers,\r\n    \"params\": params,\r\n    \"json\": json,\r\n}\r\n```",
      "comment_id": 2700975176,
      "user": "HyunWooZZ",
      "created_at": "2026-01-17T11:24:33Z",
      "url": "https://github.com/apache/airflow/pull/60689#discussion_r2700975176"
    },
    {
      "repo": "apache/airflow",
      "pr_number": 60689,
      "file_path": "providers/snowflake/src/airflow/providers/snowflake/hooks/snowflake_sql_api.py",
      "line": 82,
      "side": "RIGHT",
      "diff_hunk": "@@ -78,6 +79,7 @@ class SnowflakeSqlApiHook(SnowflakeHook):\n     :param token_renewal_delta: Renewal time of the JWT Token in timedelta\n     :param deferrable: Run operator in the deferrable mode.\n     :param api_retry_args: An optional dictionary with arguments passed to ``tenacity.Retrying`` & ``tenacity.AsyncRetrying`` classes.\n+    :param http_timeout_seconds: Optional timeout for http requests.",
      "comment": "Sorry, I misunderstood your comment.\r\nCurrently, the invocation flow for a query in the hook is:\r\nexecute_query -> _make_api_call_with_retries -> request\r\n~~So we need to change execute_query signature also async method also.~~\r\n~~e.g pseudo code like this.~~\r\n```python\r\ndef execute_query(some_args, http_args=default_args):\r\n    _make_api_call_with_retries(some_args, http_args)\r\n\r\n\r\ndef _make_api_call_with_retries(origin_param, http_args):\r\n    request(http_args)\r\n```\r\nIn short, I understand this as a suggestion to shift the responsibility to the calling side.\r\nIs that right?\r\n\r\nYou can find this change in another commit.\r\nPlz view in another commit. :)\r\n",
      "comment_id": 2700998206,
      "user": "HyunWooZZ",
      "created_at": "2026-01-17T11:41:47Z",
      "url": "https://github.com/apache/airflow/pull/60689#discussion_r2700998206"
    },
    {
      "repo": "apache/airflow",
      "pr_number": 60689,
      "file_path": "providers/snowflake/src/airflow/providers/snowflake/hooks/snowflake_sql_api.py",
      "line": 82,
      "side": "RIGHT",
      "diff_hunk": "@@ -78,6 +79,7 @@ class SnowflakeSqlApiHook(SnowflakeHook):\n     :param token_renewal_delta: Renewal time of the JWT Token in timedelta\n     :param deferrable: Run operator in the deferrable mode.\n     :param api_retry_args: An optional dictionary with arguments passed to ``tenacity.Retrying`` & ``tenacity.AsyncRetrying`` classes.\n+    :param http_timeout_seconds: Optional timeout for http requests.",
      "comment": "> think we should avoid it.\r\nThis is just 1 parameter out of so many that can be passed to request.\r\nI rather have request_kwargs then each user can pass any parameter accepted by requests.\r\n\r\nFirst i understood change :param http_timeout_seconds: -> :param request_kwargs:.\r\nThe main issue with a single request_kwargs is that we have two different underlying clients (requests for sync and aiohttp for async) with non-identical kwargs and timeout semantics.\r\n\r\nFor example, sync requests accepts timeout as a number or (connect, read) tuple, while aiohttp uses ClientTimeout(...) (and the keys/types could be differ).\r\nBecause above reason, I just wanted to hide complexity, and focuse on how to use hook not struggling with other options.\r\n\r\nAlso we need to guard against users overriding hook-controlled fields (like: method/url/headers/params), so we can\u2019t blindly forward everything without validation.\r\n\r\nThat\u2019s why I initially kept an explicit http_timeout_seconds to provide consistent behavior across sync and async both with minimal surface area. \r\nIf the project prefers a kwargs-based passing, I\u2019m happy to refactor into separate kwargs (e.g., http_request_kwargs, aiohttp_session_kwargs, aiohttp_request_kwargs) or another pattern you recommend.\r\n\r\n>I think that is how we do it in other http related operators?\r\n\r\nI reference dbt hook :)\r\nhttps://airflow.apache.org/docs/apache-airflow-providers-dbt-cloud/stable/_modules/airflow/providers/dbt/cloud/hooks/dbt.html",
      "comment_id": 2701014921,
      "user": "HyunWooZZ",
      "created_at": "2026-01-17T11:55:07Z",
      "url": "https://github.com/apache/airflow/pull/60689#discussion_r2701014921"
    },
    {
      "repo": "apache/airflow",
      "pr_number": 60689,
      "file_path": "providers/snowflake/src/airflow/providers/snowflake/hooks/snowflake_sql_api.py",
      "line": 82,
      "side": "RIGHT",
      "diff_hunk": "@@ -78,6 +79,7 @@ class SnowflakeSqlApiHook(SnowflakeHook):\n     :param token_renewal_delta: Renewal time of the JWT Token in timedelta\n     :param deferrable: Run operator in the deferrable mode.\n     :param api_retry_args: An optional dictionary with arguments passed to ``tenacity.Retrying`` & ``tenacity.AsyncRetrying`` classes.\n+    :param http_timeout_seconds: Optional timeout for http requests.",
      "comment": "This looks good now. I like the pattern. Having it as unified interface would be possibly easier from the UX point of view but indeed this is more flexible and gives more control. ",
      "comment_id": 2710365923,
      "user": "potiuk",
      "created_at": "2026-01-20T22:58:38Z",
      "url": "https://github.com/apache/airflow/pull/60689#discussion_r2710365923"
    },
    {
      "repo": "apache/airflow",
      "pr_number": 58476,
      "file_path": "providers/google/tests/unit/google/cloud/links/test_cloud_storage_transfer.py",
      "line": 126,
      "side": "RIGHT",
      "diff_hunk": "@@ -0,0 +1,462 @@\n+#\n+# Licensed to the Apache Software Foundation (ASF) under one\n+# or more contributor license agreements.  See the NOTICE file\n+# distributed with this work for additional information\n+# regarding copyright ownership.  The ASF licenses this file\n+# to you under the Apache License, Version 2.0 (the\n+# \"License\"); you may not use this file except in compliance\n+# with the License.  You may obtain a copy of the License at\n+#\n+#   http://www.apache.org/licenses/LICENSE-2.0\n+#\n+# Unless required by applicable law or agreed to in writing,\n+# software distributed under the License is distributed on an\n+# \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+# KIND, either express or implied.  See the License for the\n+# specific language governing permissions and limitations\n+# under the License.\n+\n+\"\"\"Real tests for Google Cloud Storage Transfer Service links.\"\"\"\n+\n+from __future__ import annotations\n+\n+import pytest\n+\n+from airflow.providers.google.cloud.links.cloud_storage_transfer import (\n+    CloudStorageTransferDetailsLink,\n+    CloudStorageTransferJobLink,\n+    CloudStorageTransferLinkHelper,\n+    CloudStorageTransferListLink,\n+)\n+\n+REAL_PROJECT_ID = \"my-gcp-project-123456\"\n+REAL_TRANSFER_JOB = \"transferJobs-1234567890123456789\"\n+REAL_TRANSFER_OPERATION = \"transferOperations/9876543210987654321\"\n+REAL_OPERATION_NAME = f\"{REAL_TRANSFER_OPERATION}-{REAL_TRANSFER_JOB}\"\n+\n+EXPECTED_LIST_URL = f\"https://console.cloud.google.com/transfer/jobs?project={REAL_PROJECT_ID}\"\n+EXPECTED_JOB_URL = f\"https://console.cloud.google.com/transfer/jobs/transferJobs%2F{REAL_TRANSFER_JOB}/runs?project={REAL_PROJECT_ID}\"\n+EXPECTED_DETAILS_URL = (\n+    f\"https://console.cloud.google.com/transfer/jobs/transferJobs%2FtransferJobs\"\n+    f\"/runs/transferOperations%2F9876543210987654321-transferJobs-1234567890123456789?project={REAL_PROJECT_ID}\"\n+)\n+\n+\n+class TestCloudStorageTransferLinkHelper:\n+    \"\"\"Test the CloudStorageTransferLinkHelper with real operation names.\"\"\"\n+\n+    def test_extract_parts_with_real_operation_name(self):\n+        \"\"\"Test extract_parts with a real Google Cloud Storage Transfer operation name.\"\"\"\n+        transfer_operation, transfer_job = CloudStorageTransferLinkHelper.extract_parts(REAL_OPERATION_NAME)\n+\n+        assert transfer_operation == \"9876543210987654321-transferJobs-1234567890123456789\"\n+        assert transfer_job == \"transferJobs\"\n+\n+    def test_extract_parts_with_various_real_formats(self):\n+        \"\"\"Test extract_parts with various real operation name formats.\"\"\"\n+        test_cases = [\n+            (\"transferOperations/12345-transferJobs-67890\", \"12345-transferJobs-67890\", \"transferJobs\"),\n+            (\"transferOperations/op123-transferJobs-job456\", \"op123-transferJobs-job456\", \"transferJobs\"),\n+            (\n+                \"transferOperations/99999999999999999999-transferJobs-11111111111111111111\",\n+                \"99999999999999999999-transferJobs-11111111111111111111\",\n+                \"transferJobs\",\n+            ),\n+        ]\n+\n+        for operation_name, expected_operation, expected_job in test_cases:\n+            transfer_operation, transfer_job = CloudStorageTransferLinkHelper.extract_parts(operation_name)\n+            assert transfer_operation == expected_operation\n+            assert transfer_job == expected_job\n+\n+    def test_extract_parts_with_none_operation_name(self):\n+        \"\"\"Test extract_parts with None operation name.\"\"\"\n+        transfer_operation, transfer_job = CloudStorageTransferLinkHelper.extract_parts(None)\n+\n+        assert transfer_operation == \"\"\n+        assert transfer_job == \"\"\n+\n+    def test_extract_parts_with_empty_operation_name(self):\n+        \"\"\"Test extract_parts with empty operation name.\"\"\"\n+        transfer_operation, transfer_job = CloudStorageTransferLinkHelper.extract_parts(\"\")\n+\n+        assert transfer_operation == \"\"\n+        assert transfer_job == \"\"\n+\n+    def test_extract_parts_with_malformed_operation_names(self):\n+        \"\"\"Test extract_parts with malformed operation names that might occur in real scenarios.\"\"\"\n+        test_cases = [\n+            (\"invalid-format\", IndexError),\n+            (\"transferOperations/\", IndexError),\n+            (\"transferOperations/123\", IndexError),\n+            (\"transferOperations/123-\", (\"123-\", \"\")),\n+            (\"-transferJobs-job456\", IndexError),\n+            (\"transferOperations/123-transferJobs\", (\"123-transferJobs\", \"transferJobs\")),\n+        ]\n+\n+        for operation_name, expected in test_cases:\n+            if expected is IndexError:\n+                with pytest.raises(IndexError):\n+                    CloudStorageTransferLinkHelper.extract_parts(operation_name)\n+            else:\n+                transfer_operation, transfer_job = CloudStorageTransferLinkHelper.extract_parts(\n+                    operation_name\n+                )\n+                assert transfer_operation == expected[0]\n+                assert transfer_job == expected[1]\n+\n+\n+class TestCloudStorageTransferListLink:\n+    \"\"\"Test the CloudStorageTransferListLink with real scenarios.\"\"\"\n+\n+    def test_link_properties(self):\n+        \"\"\"Test that link properties are set correctly for real usage.\"\"\"\n+        link = CloudStorageTransferListLink()\n+\n+        assert link.name == \"Cloud Storage Transfer\"\n+        assert link.key == \"cloud_storage_transfer\"\n+        assert \"{project_id}\" in link.format_str\n+\n+    def test_format_str_with_real_project_id(self):\n+        \"\"\"Test format_str generates correct URL for real project ID.\"\"\"\n+        link = CloudStorageTransferListLink()\n+        formatted_url = link.format_str.format(project_id=REAL_PROJECT_ID)\n+\n+        assert formatted_url == EXPECTED_LIST_URL\n+        assert \"console.cloud.google.com\" in formatted_url",
      "comment": "## Incomplete URL substring sanitization\n\nThe string [console.cloud.google.com](1) may be at an arbitrary position in the sanitized URL.\n\n[Show more details](https://github.com/apache/airflow/security/code-scanning/553)",
      "comment_id": 2540449736,
      "user": "github-advanced-security[bot]",
      "created_at": "2025-11-19T04:08:07Z",
      "url": "https://github.com/apache/airflow/pull/58476#discussion_r2540449736"
    },
    {
      "repo": "apache/airflow",
      "pr_number": 58476,
      "file_path": "providers/google/tests/unit/google/cloud/links/test_cloud_storage_transfer.py",
      "line": 163,
      "side": "RIGHT",
      "diff_hunk": "@@ -0,0 +1,462 @@\n+#\n+# Licensed to the Apache Software Foundation (ASF) under one\n+# or more contributor license agreements.  See the NOTICE file\n+# distributed with this work for additional information\n+# regarding copyright ownership.  The ASF licenses this file\n+# to you under the Apache License, Version 2.0 (the\n+# \"License\"); you may not use this file except in compliance\n+# with the License.  You may obtain a copy of the License at\n+#\n+#   http://www.apache.org/licenses/LICENSE-2.0\n+#\n+# Unless required by applicable law or agreed to in writing,\n+# software distributed under the License is distributed on an\n+# \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+# KIND, either express or implied.  See the License for the\n+# specific language governing permissions and limitations\n+# under the License.\n+\n+\"\"\"Real tests for Google Cloud Storage Transfer Service links.\"\"\"\n+\n+from __future__ import annotations\n+\n+import pytest\n+\n+from airflow.providers.google.cloud.links.cloud_storage_transfer import (\n+    CloudStorageTransferDetailsLink,\n+    CloudStorageTransferJobLink,\n+    CloudStorageTransferLinkHelper,\n+    CloudStorageTransferListLink,\n+)\n+\n+REAL_PROJECT_ID = \"my-gcp-project-123456\"\n+REAL_TRANSFER_JOB = \"transferJobs-1234567890123456789\"\n+REAL_TRANSFER_OPERATION = \"transferOperations/9876543210987654321\"\n+REAL_OPERATION_NAME = f\"{REAL_TRANSFER_OPERATION}-{REAL_TRANSFER_JOB}\"\n+\n+EXPECTED_LIST_URL = f\"https://console.cloud.google.com/transfer/jobs?project={REAL_PROJECT_ID}\"\n+EXPECTED_JOB_URL = f\"https://console.cloud.google.com/transfer/jobs/transferJobs%2F{REAL_TRANSFER_JOB}/runs?project={REAL_PROJECT_ID}\"\n+EXPECTED_DETAILS_URL = (\n+    f\"https://console.cloud.google.com/transfer/jobs/transferJobs%2FtransferJobs\"\n+    f\"/runs/transferOperations%2F9876543210987654321-transferJobs-1234567890123456789?project={REAL_PROJECT_ID}\"\n+)\n+\n+\n+class TestCloudStorageTransferLinkHelper:\n+    \"\"\"Test the CloudStorageTransferLinkHelper with real operation names.\"\"\"\n+\n+    def test_extract_parts_with_real_operation_name(self):\n+        \"\"\"Test extract_parts with a real Google Cloud Storage Transfer operation name.\"\"\"\n+        transfer_operation, transfer_job = CloudStorageTransferLinkHelper.extract_parts(REAL_OPERATION_NAME)\n+\n+        assert transfer_operation == \"9876543210987654321-transferJobs-1234567890123456789\"\n+        assert transfer_job == \"transferJobs\"\n+\n+    def test_extract_parts_with_various_real_formats(self):\n+        \"\"\"Test extract_parts with various real operation name formats.\"\"\"\n+        test_cases = [\n+            (\"transferOperations/12345-transferJobs-67890\", \"12345-transferJobs-67890\", \"transferJobs\"),\n+            (\"transferOperations/op123-transferJobs-job456\", \"op123-transferJobs-job456\", \"transferJobs\"),\n+            (\n+                \"transferOperations/99999999999999999999-transferJobs-11111111111111111111\",\n+                \"99999999999999999999-transferJobs-11111111111111111111\",\n+                \"transferJobs\",\n+            ),\n+        ]\n+\n+        for operation_name, expected_operation, expected_job in test_cases:\n+            transfer_operation, transfer_job = CloudStorageTransferLinkHelper.extract_parts(operation_name)\n+            assert transfer_operation == expected_operation\n+            assert transfer_job == expected_job\n+\n+    def test_extract_parts_with_none_operation_name(self):\n+        \"\"\"Test extract_parts with None operation name.\"\"\"\n+        transfer_operation, transfer_job = CloudStorageTransferLinkHelper.extract_parts(None)\n+\n+        assert transfer_operation == \"\"\n+        assert transfer_job == \"\"\n+\n+    def test_extract_parts_with_empty_operation_name(self):\n+        \"\"\"Test extract_parts with empty operation name.\"\"\"\n+        transfer_operation, transfer_job = CloudStorageTransferLinkHelper.extract_parts(\"\")\n+\n+        assert transfer_operation == \"\"\n+        assert transfer_job == \"\"\n+\n+    def test_extract_parts_with_malformed_operation_names(self):\n+        \"\"\"Test extract_parts with malformed operation names that might occur in real scenarios.\"\"\"\n+        test_cases = [\n+            (\"invalid-format\", IndexError),\n+            (\"transferOperations/\", IndexError),\n+            (\"transferOperations/123\", IndexError),\n+            (\"transferOperations/123-\", (\"123-\", \"\")),\n+            (\"-transferJobs-job456\", IndexError),\n+            (\"transferOperations/123-transferJobs\", (\"123-transferJobs\", \"transferJobs\")),\n+        ]\n+\n+        for operation_name, expected in test_cases:\n+            if expected is IndexError:\n+                with pytest.raises(IndexError):\n+                    CloudStorageTransferLinkHelper.extract_parts(operation_name)\n+            else:\n+                transfer_operation, transfer_job = CloudStorageTransferLinkHelper.extract_parts(\n+                    operation_name\n+                )\n+                assert transfer_operation == expected[0]\n+                assert transfer_job == expected[1]\n+\n+\n+class TestCloudStorageTransferListLink:\n+    \"\"\"Test the CloudStorageTransferListLink with real scenarios.\"\"\"\n+\n+    def test_link_properties(self):\n+        \"\"\"Test that link properties are set correctly for real usage.\"\"\"\n+        link = CloudStorageTransferListLink()\n+\n+        assert link.name == \"Cloud Storage Transfer\"\n+        assert link.key == \"cloud_storage_transfer\"\n+        assert \"{project_id}\" in link.format_str\n+\n+    def test_format_str_with_real_project_id(self):\n+        \"\"\"Test format_str generates correct URL for real project ID.\"\"\"\n+        link = CloudStorageTransferListLink()\n+        formatted_url = link.format_str.format(project_id=REAL_PROJECT_ID)\n+\n+        assert formatted_url == EXPECTED_LIST_URL\n+        assert \"console.cloud.google.com\" in formatted_url\n+        assert REAL_PROJECT_ID in formatted_url\n+\n+    def test_format_str_with_various_project_ids(self):\n+        \"\"\"Test format_str with various real project ID formats.\"\"\"\n+        project_ids = [\n+            \"my-project\",\n+            \"project-123456\",\n+            \"my-gcp-project-123\",\n+            \"a\" * 30,\n+        ]\n+\n+        link = CloudStorageTransferListLink()\n+        for project_id in project_ids:\n+            formatted_url = link.format_str.format(project_id=project_id)\n+            assert project_id in formatted_url\n+            assert formatted_url.startswith(\"https://console.cloud.google.com/transfer/jobs?\")\n+\n+\n+class TestCloudStorageTransferJobLink:\n+    \"\"\"Test the CloudStorageTransferJobLink with real scenarios.\"\"\"\n+\n+    def test_link_properties(self):\n+        \"\"\"Test that link properties are set correctly for real usage.\"\"\"\n+        link = CloudStorageTransferJobLink()\n+\n+        assert link.name == \"Cloud Storage Transfer Job\"\n+        assert link.key == \"cloud_storage_transfer_job\"\n+        assert \"{project_id}\" in link.format_str\n+        assert \"{transfer_job}\" in link.format_str\n+\n+    def test_format_str_with_real_parameters(self):\n+        \"\"\"Test format_str generates correct URL for real transfer job.\"\"\"\n+        link = CloudStorageTransferJobLink()\n+        formatted_url = link.format_str.format(project_id=REAL_PROJECT_ID, transfer_job=REAL_TRANSFER_JOB)\n+\n+        assert formatted_url == EXPECTED_JOB_URL\n+        assert \"console.cloud.google.com\" in formatted_url",
      "comment": "## Incomplete URL substring sanitization\n\nThe string [console.cloud.google.com](1) may be at an arbitrary position in the sanitized URL.\n\n[Show more details](https://github.com/apache/airflow/security/code-scanning/554)",
      "comment_id": 2540449741,
      "user": "github-advanced-security[bot]",
      "created_at": "2025-11-19T04:08:07Z",
      "url": "https://github.com/apache/airflow/pull/58476#discussion_r2540449741"
    },
    {
      "repo": "apache/airflow",
      "pr_number": 58476,
      "file_path": "providers/google/tests/unit/google/cloud/links/test_cloud_storage_transfer.py",
      "line": 200,
      "side": "RIGHT",
      "diff_hunk": "@@ -0,0 +1,462 @@\n+#\n+# Licensed to the Apache Software Foundation (ASF) under one\n+# or more contributor license agreements.  See the NOTICE file\n+# distributed with this work for additional information\n+# regarding copyright ownership.  The ASF licenses this file\n+# to you under the Apache License, Version 2.0 (the\n+# \"License\"); you may not use this file except in compliance\n+# with the License.  You may obtain a copy of the License at\n+#\n+#   http://www.apache.org/licenses/LICENSE-2.0\n+#\n+# Unless required by applicable law or agreed to in writing,\n+# software distributed under the License is distributed on an\n+# \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+# KIND, either express or implied.  See the License for the\n+# specific language governing permissions and limitations\n+# under the License.\n+\n+\"\"\"Real tests for Google Cloud Storage Transfer Service links.\"\"\"\n+\n+from __future__ import annotations\n+\n+import pytest\n+\n+from airflow.providers.google.cloud.links.cloud_storage_transfer import (\n+    CloudStorageTransferDetailsLink,\n+    CloudStorageTransferJobLink,\n+    CloudStorageTransferLinkHelper,\n+    CloudStorageTransferListLink,\n+)\n+\n+REAL_PROJECT_ID = \"my-gcp-project-123456\"\n+REAL_TRANSFER_JOB = \"transferJobs-1234567890123456789\"\n+REAL_TRANSFER_OPERATION = \"transferOperations/9876543210987654321\"\n+REAL_OPERATION_NAME = f\"{REAL_TRANSFER_OPERATION}-{REAL_TRANSFER_JOB}\"\n+\n+EXPECTED_LIST_URL = f\"https://console.cloud.google.com/transfer/jobs?project={REAL_PROJECT_ID}\"\n+EXPECTED_JOB_URL = f\"https://console.cloud.google.com/transfer/jobs/transferJobs%2F{REAL_TRANSFER_JOB}/runs?project={REAL_PROJECT_ID}\"\n+EXPECTED_DETAILS_URL = (\n+    f\"https://console.cloud.google.com/transfer/jobs/transferJobs%2FtransferJobs\"\n+    f\"/runs/transferOperations%2F9876543210987654321-transferJobs-1234567890123456789?project={REAL_PROJECT_ID}\"\n+)\n+\n+\n+class TestCloudStorageTransferLinkHelper:\n+    \"\"\"Test the CloudStorageTransferLinkHelper with real operation names.\"\"\"\n+\n+    def test_extract_parts_with_real_operation_name(self):\n+        \"\"\"Test extract_parts with a real Google Cloud Storage Transfer operation name.\"\"\"\n+        transfer_operation, transfer_job = CloudStorageTransferLinkHelper.extract_parts(REAL_OPERATION_NAME)\n+\n+        assert transfer_operation == \"9876543210987654321-transferJobs-1234567890123456789\"\n+        assert transfer_job == \"transferJobs\"\n+\n+    def test_extract_parts_with_various_real_formats(self):\n+        \"\"\"Test extract_parts with various real operation name formats.\"\"\"\n+        test_cases = [\n+            (\"transferOperations/12345-transferJobs-67890\", \"12345-transferJobs-67890\", \"transferJobs\"),\n+            (\"transferOperations/op123-transferJobs-job456\", \"op123-transferJobs-job456\", \"transferJobs\"),\n+            (\n+                \"transferOperations/99999999999999999999-transferJobs-11111111111111111111\",\n+                \"99999999999999999999-transferJobs-11111111111111111111\",\n+                \"transferJobs\",\n+            ),\n+        ]\n+\n+        for operation_name, expected_operation, expected_job in test_cases:\n+            transfer_operation, transfer_job = CloudStorageTransferLinkHelper.extract_parts(operation_name)\n+            assert transfer_operation == expected_operation\n+            assert transfer_job == expected_job\n+\n+    def test_extract_parts_with_none_operation_name(self):\n+        \"\"\"Test extract_parts with None operation name.\"\"\"\n+        transfer_operation, transfer_job = CloudStorageTransferLinkHelper.extract_parts(None)\n+\n+        assert transfer_operation == \"\"\n+        assert transfer_job == \"\"\n+\n+    def test_extract_parts_with_empty_operation_name(self):\n+        \"\"\"Test extract_parts with empty operation name.\"\"\"\n+        transfer_operation, transfer_job = CloudStorageTransferLinkHelper.extract_parts(\"\")\n+\n+        assert transfer_operation == \"\"\n+        assert transfer_job == \"\"\n+\n+    def test_extract_parts_with_malformed_operation_names(self):\n+        \"\"\"Test extract_parts with malformed operation names that might occur in real scenarios.\"\"\"\n+        test_cases = [\n+            (\"invalid-format\", IndexError),\n+            (\"transferOperations/\", IndexError),\n+            (\"transferOperations/123\", IndexError),\n+            (\"transferOperations/123-\", (\"123-\", \"\")),\n+            (\"-transferJobs-job456\", IndexError),\n+            (\"transferOperations/123-transferJobs\", (\"123-transferJobs\", \"transferJobs\")),\n+        ]\n+\n+        for operation_name, expected in test_cases:\n+            if expected is IndexError:\n+                with pytest.raises(IndexError):\n+                    CloudStorageTransferLinkHelper.extract_parts(operation_name)\n+            else:\n+                transfer_operation, transfer_job = CloudStorageTransferLinkHelper.extract_parts(\n+                    operation_name\n+                )\n+                assert transfer_operation == expected[0]\n+                assert transfer_job == expected[1]\n+\n+\n+class TestCloudStorageTransferListLink:\n+    \"\"\"Test the CloudStorageTransferListLink with real scenarios.\"\"\"\n+\n+    def test_link_properties(self):\n+        \"\"\"Test that link properties are set correctly for real usage.\"\"\"\n+        link = CloudStorageTransferListLink()\n+\n+        assert link.name == \"Cloud Storage Transfer\"\n+        assert link.key == \"cloud_storage_transfer\"\n+        assert \"{project_id}\" in link.format_str\n+\n+    def test_format_str_with_real_project_id(self):\n+        \"\"\"Test format_str generates correct URL for real project ID.\"\"\"\n+        link = CloudStorageTransferListLink()\n+        formatted_url = link.format_str.format(project_id=REAL_PROJECT_ID)\n+\n+        assert formatted_url == EXPECTED_LIST_URL\n+        assert \"console.cloud.google.com\" in formatted_url\n+        assert REAL_PROJECT_ID in formatted_url\n+\n+    def test_format_str_with_various_project_ids(self):\n+        \"\"\"Test format_str with various real project ID formats.\"\"\"\n+        project_ids = [\n+            \"my-project\",\n+            \"project-123456\",\n+            \"my-gcp-project-123\",\n+            \"a\" * 30,\n+        ]\n+\n+        link = CloudStorageTransferListLink()\n+        for project_id in project_ids:\n+            formatted_url = link.format_str.format(project_id=project_id)\n+            assert project_id in formatted_url\n+            assert formatted_url.startswith(\"https://console.cloud.google.com/transfer/jobs?\")\n+\n+\n+class TestCloudStorageTransferJobLink:\n+    \"\"\"Test the CloudStorageTransferJobLink with real scenarios.\"\"\"\n+\n+    def test_link_properties(self):\n+        \"\"\"Test that link properties are set correctly for real usage.\"\"\"\n+        link = CloudStorageTransferJobLink()\n+\n+        assert link.name == \"Cloud Storage Transfer Job\"\n+        assert link.key == \"cloud_storage_transfer_job\"\n+        assert \"{project_id}\" in link.format_str\n+        assert \"{transfer_job}\" in link.format_str\n+\n+    def test_format_str_with_real_parameters(self):\n+        \"\"\"Test format_str generates correct URL for real transfer job.\"\"\"\n+        link = CloudStorageTransferJobLink()\n+        formatted_url = link.format_str.format(project_id=REAL_PROJECT_ID, transfer_job=REAL_TRANSFER_JOB)\n+\n+        assert formatted_url == EXPECTED_JOB_URL\n+        assert \"console.cloud.google.com\" in formatted_url\n+        assert REAL_PROJECT_ID in formatted_url\n+        assert REAL_TRANSFER_JOB in formatted_url\n+\n+    def test_format_str_url_encoding(self):\n+        \"\"\"Test that transfer job ID is properly URL encoded.\"\"\"\n+        link = CloudStorageTransferJobLink()\n+        formatted_url = link.format_str.format(project_id=REAL_PROJECT_ID, transfer_job=REAL_TRANSFER_JOB)\n+\n+        assert \"transferJobs%2F\" in formatted_url\n+        assert \"transferJobs/\" not in formatted_url\n+\n+\n+class TestCloudStorageTransferDetailsLink:\n+    \"\"\"Test the CloudStorageTransferDetailsLink with real scenarios.\"\"\"\n+\n+    def test_link_properties(self):\n+        \"\"\"Test that link properties are set correctly for real usage.\"\"\"\n+        link = CloudStorageTransferDetailsLink()\n+\n+        assert link.name == \"Cloud Storage Transfer Details\"\n+        assert link.key == \"cloud_storage_transfer_details\"\n+        assert \"{project_id}\" in link.format_str\n+        assert \"{transfer_job}\" in link.format_str\n+        assert \"{transfer_operation}\" in link.format_str\n+\n+    def test_format_str_with_real_parameters(self):\n+        \"\"\"Test format_str generates correct URL for real transfer operation.\"\"\"\n+        link = CloudStorageTransferDetailsLink()\n+\n+        formatted_url = link.format_str.format(\n+            project_id=REAL_PROJECT_ID,\n+            transfer_job=\"transferJobs\",\n+            transfer_operation=\"9876543210987654321-transferJobs-1234567890123456789\",\n+        )\n+\n+        assert formatted_url == EXPECTED_DETAILS_URL\n+        assert \"console.cloud.google.com\" in formatted_url",
      "comment": "## Incomplete URL substring sanitization\n\nThe string [console.cloud.google.com](1) may be at an arbitrary position in the sanitized URL.\n\n[Show more details](https://github.com/apache/airflow/security/code-scanning/555)",
      "comment_id": 2540449744,
      "user": "github-advanced-security[bot]",
      "created_at": "2025-11-19T04:08:07Z",
      "url": "https://github.com/apache/airflow/pull/58476#discussion_r2540449744"
    },
    {
      "repo": "apache/airflow",
      "pr_number": 58476,
      "file_path": "airflow-core/tests/unit/always/test_project_structure.py",
      "line": 146,
      "side": "LEFT",
      "diff_hunk": "@@ -143,7 +143,6 @@ def test_providers_modules_should_have_tests(self):\n             \"providers/google/tests/unit/google/cloud/links/test_cloud_functions.py\",\n             \"providers/google/tests/unit/google/cloud/links/test_cloud_memorystore.py\",\n             \"providers/google/tests/unit/google/cloud/links/test_cloud_sql.py\",\n-            \"providers/google/tests/unit/google/cloud/links/test_cloud_storage_transfer.py\",",
      "comment": "Do you think we should add this instead of removing?",
      "comment_id": 2540654805,
      "user": "KoviAnusha",
      "created_at": "2025-11-19T06:02:53Z",
      "url": "https://github.com/apache/airflow/pull/58476#discussion_r2540654805"
    },
    {
      "repo": "apache/airflow",
      "pr_number": 58476,
      "file_path": "airflow-core/tests/unit/always/test_project_structure.py",
      "line": 146,
      "side": "LEFT",
      "diff_hunk": "@@ -143,7 +143,6 @@ def test_providers_modules_should_have_tests(self):\n             \"providers/google/tests/unit/google/cloud/links/test_cloud_functions.py\",\n             \"providers/google/tests/unit/google/cloud/links/test_cloud_memorystore.py\",\n             \"providers/google/tests/unit/google/cloud/links/test_cloud_sql.py\",\n-            \"providers/google/tests/unit/google/cloud/links/test_cloud_storage_transfer.py\",",
      "comment": "I added a test file for cloud_storage_transfer, this line should be deleted.",
      "comment_id": 2540671302,
      "user": "ZZKangKZZ",
      "created_at": "2025-11-19T06:10:55Z",
      "url": "https://github.com/apache/airflow/pull/58476#discussion_r2540671302"
    },
    {
      "repo": "apache/airflow",
      "pr_number": 58476,
      "file_path": "providers/google/tests/unit/google/cloud/links/test_cloud_storage_transfer.py",
      "line": 19,
      "side": "RIGHT",
      "diff_hunk": "@@ -0,0 +1,464 @@\n+#\n+# Licensed to the Apache Software Foundation (ASF) under one\n+# or more contributor license agreements.  See the NOTICE file\n+# distributed with this work for additional information\n+# regarding copyright ownership.  The ASF licenses this file\n+# to you under the Apache License, Version 2.0 (the\n+# \"License\"); you may not use this file except in compliance\n+# with the License.  You may obtain a copy of the License at\n+#\n+#   http://www.apache.org/licenses/LICENSE-2.0\n+#\n+# Unless required by applicable law or agreed to in writing,\n+# software distributed under the License is distributed on an\n+# \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+# KIND, either express or implied.  See the License for the\n+# specific language governing permissions and limitations\n+# under the License.\n+\n+\"\"\"Real tests for Google Cloud Storage Transfer Service links.\"\"\"",
      "comment": "What does \"real\" tests mean? There are unreal tests?",
      "comment_id": 2674410745,
      "user": "uranusjr",
      "created_at": "2026-01-09T00:55:16Z",
      "url": "https://github.com/apache/airflow/pull/58476#discussion_r2674410745"
    },
    {
      "repo": "apache/airflow",
      "pr_number": 60808,
      "file_path": "task-sdk/src/airflow/sdk/__init__.py",
      "line": 188,
      "side": "RIGHT",
      "diff_hunk": "@@ -176,7 +179,13 @@ def __getattr__(name: str):\n         import importlib\n \n         mod = importlib.import_module(module_path, __name__)\n-        val = getattr(mod, name)\n+\n+        # try and get the attribute from the module\n+        # if it doesn't exist (for modules like macros), return module itself\n+        try:\n+            val = getattr(mod, name)\n+        except AttributeError:\n+            val = mod",
      "comment": "I'm a bit concerned of this workaround, as it might backfire in potential future namespace-naming conflicts. I'd maybe limit it only to the modules that require this:\n\n```suggestion\n        # try and get the attribute from the module\n        # if it doesn't exist (for modules like macros), return module itself\n        try:\n            val = getattr(mod, name)\n        except AttributeError:\n            if name == \"macros\":\n                val = mod\n            else:\n                raise\n```",
      "comment_id": 2707031705,
      "user": "shahar1",
      "created_at": "2026-01-20T07:04:31Z",
      "url": "https://github.com/apache/airflow/pull/60808#discussion_r2707031705"
    },
    {
      "repo": "apache/airflow",
      "pr_number": 60808,
      "file_path": "task-sdk/src/airflow/sdk/__init__.py",
      "line": 188,
      "side": "RIGHT",
      "diff_hunk": "@@ -176,7 +179,13 @@ def __getattr__(name: str):\n         import importlib\n \n         mod = importlib.import_module(module_path, __name__)\n-        val = getattr(mod, name)\n+\n+        # try and get the attribute from the module\n+        # if it doesn't exist (for modules like macros), return module itself\n+        try:\n+            val = getattr(mod, name)\n+        except AttributeError:\n+            val = mod",
      "comment": "Hmm, I could do that yes, but I do not see why it will backfire, we already use similar patterns for `from airflow import version` or similar",
      "comment_id": 2707617133,
      "user": "amoghrajesh",
      "created_at": "2026-01-20T09:58:37Z",
      "url": "https://github.com/apache/airflow/pull/60808#discussion_r2707617133"
    },
    {
      "repo": "apache/airflow",
      "pr_number": 60808,
      "file_path": "task-sdk/src/airflow/sdk/__init__.py",
      "line": 188,
      "side": "RIGHT",
      "diff_hunk": "@@ -176,7 +179,13 @@ def __getattr__(name: str):\n         import importlib\n \n         mod = importlib.import_module(module_path, __name__)\n-        val = getattr(mod, name)\n+\n+        # try and get the attribute from the module\n+        # if it doesn't exist (for modules like macros), return module itself\n+        try:\n+            val = getattr(mod, name)\n+        except AttributeError:\n+            val = mod",
      "comment": "> Hmm, I could do that yes, but I do not see why it will backfire, we already use similar patterns for `from airflow import version` or similar\n\nNot a strong objection (maybe I'm extra cautious) - as long as we are aware what's going on in the init files I guess that we should be fine.\nFix the failing test and I'll approve. ",
      "comment_id": 2709760595,
      "user": "shahar1",
      "created_at": "2026-01-20T19:20:44Z",
      "url": "https://github.com/apache/airflow/pull/60808#discussion_r2709760595"
    },
    {
      "repo": "apache/airflow",
      "pr_number": 60808,
      "file_path": "task-sdk/src/airflow/sdk/__init__.py",
      "line": 188,
      "side": "RIGHT",
      "diff_hunk": "@@ -176,7 +179,13 @@ def __getattr__(name: str):\n         import importlib\n \n         mod = importlib.import_module(module_path, __name__)\n-        val = getattr(mod, name)\n+\n+        # try and get the attribute from the module\n+        # if it doesn't exist (for modules like macros), return module itself\n+        try:\n+            val = getattr(mod, name)\n+        except AttributeError:\n+            val = mod",
      "comment": "I am with @shahar1 on this. This could mask any typos in `__lazy_imports` which is very likely:\n\n```py\n# Hypothetical typo in __lazy_imports:\n\"DAG_typo\": \".definitions.dag\",\n\n# Before this PR:\nfrom airflow.sdk import DAG_typo\n# AttributeError: module 'airflow.sdk.definitions.dag' has no attribute 'DAG_typo'\n# Clear error pointing to the problem\n\n# After this PR:\nfrom airflow.sdk import DAG_typo\n# No error - silently returns the module object\n\nDAG_typo(dag_id=\"test\")\n# TypeError: 'module' object is not callable\n# Confusing error that doesn't point to the real issue\n```\n\nA rather simpler solution would be instead of modifying `__getattr__`, just expose macros in `execution_time/__init__.py`:\n\n```py\n# task-sdk/src/airflow/sdk/execution_time/__init__.py\nfrom airflow.sdk.execution_time import macros\n```\n\nThen change the lazy import to:\n```py\n\"macros\": \".execution_time\",\n```",
      "comment_id": 2710449965,
      "user": "kaxil",
      "created_at": "2026-01-20T23:42:47Z",
      "url": "https://github.com/apache/airflow/pull/60808#discussion_r2710449965"
    },
    {
      "repo": "apache/airflow",
      "pr_number": 60808,
      "file_path": "task-sdk/src/airflow/sdk/__init__.py",
      "line": 188,
      "side": "RIGHT",
      "diff_hunk": "@@ -176,7 +179,13 @@ def __getattr__(name: str):\n         import importlib\n \n         mod = importlib.import_module(module_path, __name__)\n-        val = getattr(mod, name)\n+\n+        # try and get the attribute from the module\n+        # if it doesn't exist (for modules like macros), return module itself\n+        try:\n+            val = getattr(mod, name)\n+        except AttributeError:\n+            val = mod",
      "comment": "The airflow-core version (`airflow-core/src/airflow/__init__.py`) is different - it uses a tuple `(module_path, attr_name, deprecated)` where an empty `attr_name` explicitly signals \"return the module itself\":\r\n\r\n```py\r\n\"version\": (\".version\", \"\", False),  # Empty string = return module\r\n\"metrics\": (\".observability.metrics\", \"\", True),  # Empty string = return module\r\n```\r\n\r\nThe check is explicit:\r\nhttps://github.com/apache/airflow/blob/7267294e622cd897d6585ca55dedde32672acaef/airflow-core/src/airflow/__init__.py#L119-L123\r\n\r\nwhereas this PR uses a `try/except` fallback which is implicit - it catches `AttributeError` for any reason and assumes \"return the module\". The airflow-core pattern is intentional, yours is a fallback that could hide bugs.\r\n",
      "comment_id": 2710456214,
      "user": "kaxil",
      "created_at": "2026-01-20T23:46:23Z",
      "url": "https://github.com/apache/airflow/pull/60808#discussion_r2710456214"
    },
    {
      "repo": "apache/airflow",
      "pr_number": 60808,
      "file_path": "task-sdk/src/airflow/sdk/__init__.py",
      "line": 188,
      "side": "RIGHT",
      "diff_hunk": "@@ -176,7 +179,13 @@ def __getattr__(name: str):\n         import importlib\n \n         mod = importlib.import_module(module_path, __name__)\n-        val = getattr(mod, name)\n+\n+        # try and get the attribute from the module\n+        # if it doesn't exist (for modules like macros), return module itself\n+        try:\n+            val = getattr(mod, name)\n+        except AttributeError:\n+            val = mod",
      "comment": "Ah ok! Thanks for the clarification @kaxil. Adding to `execution_time/__init__.py` seems to be a better solution",
      "comment_id": 2710932890,
      "user": "amoghrajesh",
      "created_at": "2026-01-21T04:35:59Z",
      "url": "https://github.com/apache/airflow/pull/60808#discussion_r2710932890"
    },
    {
      "repo": "apache/airflow",
      "pr_number": 59430,
      "file_path": "airflow-core/src/airflow/dag_processing/manager.py",
      "line": 1194,
      "side": "RIGHT",
      "diff_hunk": "@@ -1190,13 +1190,17 @@ def process_parse_results(\n             files_parsed = {(bundle_name, relative_fileloc)}\n             files_parsed.update(import_errors.keys())\n \n+        warning = parsing_result.warnings\n+        if parsing_result.warnings and isinstance(parsing_result.warnings[0], dict):",
      "comment": "```suggestion\n        \n        if (warnings := parsing_result.warnings) and isinstance(warnings[0], dict):\n```",
      "comment_id": 2626223279,
      "user": "Lee-W",
      "created_at": "2025-12-17T09:16:16Z",
      "url": "https://github.com/apache/airflow/pull/59430#discussion_r2626223279"
    },
    {
      "repo": "apache/airflow",
      "pr_number": 59430,
      "file_path": "airflow-core/src/airflow/dag_processing/manager.py",
      "line": 1195,
      "side": "RIGHT",
      "diff_hunk": "@@ -1190,13 +1190,17 @@ def process_parse_results(\n             files_parsed = {(bundle_name, relative_fileloc)}\n             files_parsed.update(import_errors.keys())\n \n+        warning = parsing_result.warnings\n+        if parsing_result.warnings and isinstance(parsing_result.warnings[0], dict):\n+            warning = [DagWarning(**warn) for warn in parsing_result.warnings]",
      "comment": "```suggestion\n            warning = [DagWarning(**warn) for warn in warnings]\n```",
      "comment_id": 2626224049,
      "user": "Lee-W",
      "created_at": "2025-12-17T09:16:24Z",
      "url": "https://github.com/apache/airflow/pull/59430#discussion_r2626224049"
    },
    {
      "repo": "apache/airflow",
      "pr_number": 59430,
      "file_path": "airflow-core/src/airflow/utils/static_checker.py",
      "line": 39,
      "side": "RIGHT",
      "diff_hunk": "@@ -0,0 +1,468 @@\n+# Licensed to the Apache Software Foundation (ASF) under one\n+# or more contributor license agreements.  See the NOTICE file\n+# distributed with this work for additional information\n+# regarding copyright ownership.  The ASF licenses this file\n+# to you under the Apache License, Version 2.0 (the\n+# \"License\"); you may not use this file except in compliance\n+# with the License.  You may obtain a copy of the License at\n+#\n+#   http://www.apache.org/licenses/LICENSE-2.0\n+#\n+# Unless required by applicable law or agreed to in writing,\n+# software distributed under the License is distributed on an\n+# \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+# KIND, either express or implied.  See the License for the\n+# specific language governing permissions and limitations\n+# under the License.\n+from __future__ import annotations\n+\n+import ast\n+from dataclasses import dataclass\n+from enum import Enum\n+from pathlib import Path\n+\n+\n+@dataclass\n+class RuntimeVaryingValueWarning:\n+    \"\"\"Warning information for runtime-varying value detection.\"\"\"\n+\n+    line: int\n+    col: int\n+    code: str\n+    message: str\n+\n+\n+class WarningContext(str, Enum):\n+    \"\"\"Context types for warnings.\"\"\"\n+\n+    TASK_CONSTRUCTOR = \"TASK constructor\"\n+    DAG_CONSTRUCTOR = \"DAG constructor\"",
      "comment": "```suggestion\n    TASK_CONSTRUCTOR = \"Task constructor\"\n    DAG_CONSTRUCTOR = \"Dag constructor\"\n```\n\nIs there a reason we use upper case?",
      "comment_id": 2626231777,
      "user": "Lee-W",
      "created_at": "2025-12-17T09:18:22Z",
      "url": "https://github.com/apache/airflow/pull/59430#discussion_r2626231777"
    },
    {
      "repo": "apache/airflow",
      "pr_number": 59430,
      "file_path": "airflow-core/src/airflow/utils/dag_stability_checker.py",
      "line": 352,
      "side": "RIGHT",
      "diff_hunk": "@@ -0,0 +1,468 @@\n+# Licensed to the Apache Software Foundation (ASF) under one\n+# or more contributor license agreements.  See the NOTICE file\n+# distributed with this work for additional information\n+# regarding copyright ownership.  The ASF licenses this file\n+# to you under the Apache License, Version 2.0 (the\n+# \"License\"); you may not use this file except in compliance\n+# with the License.  You may obtain a copy of the License at\n+#\n+#   http://www.apache.org/licenses/LICENSE-2.0\n+#\n+# Unless required by applicable law or agreed to in writing,\n+# software distributed under the License is distributed on an\n+# \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+# KIND, either express or implied.  See the License for the\n+# specific language governing permissions and limitations\n+# under the License.\n+from __future__ import annotations\n+\n+import ast\n+from dataclasses import dataclass\n+from enum import Enum\n+from pathlib import Path\n+\n+\n+@dataclass\n+class RuntimeVaryingValueWarning:\n+    \"\"\"Warning information for runtime-varying value detection.\"\"\"\n+\n+    line: int\n+    col: int\n+    code: str\n+    message: str\n+\n+\n+class WarningContext(str, Enum):\n+    \"\"\"Context types for warnings.\"\"\"\n+\n+    TASK_CONSTRUCTOR = \"TASK constructor\"\n+    DAG_CONSTRUCTOR = \"DAG constructor\"\n+\n+\n+RUNTIME_VARYING_CALLS = [\n+    (\"datetime\", \"now\"),\n+    (\"datetime\", \"today\"),\n+    (\"datetime\", \"utcnow\"),\n+    (\"date\", \"today\"),\n+    (\"time\", \"time\"),\n+    (\"time\", \"localtime\"),\n+    (\"random\", \"random\"),\n+    (\"random\", \"randint\"),\n+    (\"random\", \"choice\"),\n+    (\"random\", \"uniform\"),\n+    (\"uuid\", \"uuid4\"),\n+    (\"uuid\", \"uuid1\"),\n+]\n+\n+\n+class RuntimeVaryingValueAnalyzer:\n+    \"\"\"\n+    Analyzer dedicated to tracking and detecting runtime-varying values.\n+\n+    This analyzer is responsible for identifying if a given AST node\n+    contains values that change on every execution (datetime.now(), random(), etc.).\n+    \"\"\"\n+\n+    def __init__(self, varying_vars: dict, imports: dict, from_imports: dict):\n+        self.varying_vars = varying_vars\n+        self.imports = imports\n+        self.from_imports = from_imports\n+\n+    def get_varying_source(self, node: ast.expr) -> str | None:\n+        \"\"\"\n+        Check if an AST node contains runtime-varying values and return the source.\n+\n+        Checks:\n+        - Runtime-varying function calls (datetime.now(), etc.)\n+        - Runtime-varying variable references\n+        - Runtime-varying values in f-strings\n+        - Runtime-varying values in expressions/collections\n+        \"\"\"\n+        # 1. Direct runtime-varying call\n+        if isinstance(node, ast.Call) and self._is_runtime_varying_call(node):\n+            return ast.unparse(node)\n+\n+        # 2. Runtime-varying variable reference\n+        if isinstance(node, ast.Name) and node.id in self.varying_vars:\n+            _, source = self.varying_vars[node.id]\n+            return source\n+\n+        # 3. f-string\n+        if isinstance(node, ast.JoinedStr):\n+            return self._check_fstring_varying(node)\n+\n+        # 4. Binary operation\n+        if isinstance(node, ast.BinOp):\n+            return self.get_varying_source(node.left) or self.get_varying_source(node.right)\n+\n+        # 5. Collections (list/tuple/set)\n+        if isinstance(node, (ast.List, ast.Tuple, ast.Set)):\n+            return self._check_collection_varying(node.elts)\n+\n+        # 6. List comprehension\n+        if isinstance(node, ast.ListComp):\n+            return self.get_varying_source(node.elt)\n+\n+        # 7. Dictionary\n+        if isinstance(node, ast.Dict):\n+            return self._check_dict_varying(node)\n+\n+        # 8. Method call chain\n+        if isinstance(node, ast.Call) and isinstance(node.func, ast.Attribute):\n+            return self.get_varying_source(node.func.value)\n+\n+        return None\n+\n+    def _check_fstring_varying(self, node: ast.JoinedStr) -> str | None:\n+        \"\"\"Check for runtime-varying values inside f-strings.\"\"\"\n+        for value in node.values:\n+            if isinstance(value, ast.FormattedValue):\n+                source = self.get_varying_source(value.value)\n+                if source:\n+                    return source\n+        return None\n+\n+    def _check_collection_varying(self, elements: list) -> str | None:\n+        \"\"\"Check for runtime-varying values in collection elements.\"\"\"\n+        for elt in elements:\n+            source = self.get_varying_source(elt)\n+            if source:\n+                return source\n+        return None\n+\n+    def _check_dict_varying(self, node: ast.Dict) -> str | None:\n+        \"\"\"Check for runtime-varying values in dictionary keys/values.\"\"\"\n+        for key, value in zip(node.keys, node.values):\n+            if key:\n+                source = self.get_varying_source(key)\n+                if source:\n+                    return source\n+            if value:\n+                source = self.get_varying_source(value)\n+                if source:\n+                    return source\n+        return None\n+\n+    def _is_runtime_varying_call(self, node: ast.Call) -> bool:\n+        \"\"\"\n+        Check if a call is runtime-varying.\n+\n+        1. Is the function itself runtime-varying?\n+        2. Do the arguments contain runtime-varying values?\n+        \"\"\"\n+        # Check if the function itself is runtime-varying\n+        if isinstance(node.func, ast.Attribute):\n+            if self._is_runtime_varying_attribute_call(node.func):\n+                return True\n+        elif isinstance(node.func, ast.Name):\n+            if self._is_runtime_varying_name_call(node.func):\n+                return True\n+\n+        # Check if arguments contain runtime-varying values\n+        return self._has_varying_arguments(node)\n+\n+    def _has_varying_arguments(self, node: ast.Call) -> bool:\n+        \"\"\"Check if function arguments contain runtime-varying values.\"\"\"\n+        for arg in node.args:\n+            if self.get_varying_source(arg):\n+                return True\n+\n+        for kw in node.keywords:\n+            if self.get_varying_source(kw.value):\n+                return True\n+\n+        return False\n+\n+    def _is_runtime_varying_attribute_call(self, attr: ast.Attribute) -> bool:\n+        \"\"\"Check for runtime-varying calls like datetime.now().\"\"\"\n+        method_name = attr.attr\n+\n+        if isinstance(attr.value, ast.Name):\n+            module_or_alias = attr.value.id\n+            actual_module = self.imports.get(module_or_alias, module_or_alias)\n+\n+            # If imported via \"from import\"\n+            if module_or_alias in self.from_imports:\n+                _, original_name = self.from_imports[module_or_alias]\n+                actual_module = original_name\n+\n+            return (actual_module, method_name) in RUNTIME_VARYING_CALLS\n+\n+        # Nested attribute (e.g., datetime.datetime.now)\n+        if isinstance(attr.value, ast.Attribute):\n+            inner_attr = attr.value\n+            if isinstance(inner_attr.value, ast.Name):\n+                return (inner_attr.attr, method_name) in RUNTIME_VARYING_CALLS\n+\n+        return False\n+\n+    def _is_runtime_varying_name_call(self, func: ast.Name) -> bool:\n+        \"\"\"Check for runtime-varying calls like now() (when imported via 'from import').\"\"\"\n+        func_name = func.id\n+\n+        if func_name in self.from_imports:\n+            module, original_name = self.from_imports[func_name]\n+            module_parts = module.split(\".\")\n+\n+            for part in module_parts:\n+                if (part, original_name) in RUNTIME_VARYING_CALLS:\n+                    return True\n+\n+        return False\n+\n+\n+class DAGTaskDetector:\n+    \"\"\"\n+    Detector dedicated to identifying DAG and Task constructors.\n+\n+    This detector identifies when code is creating DAG or Task objects\n+    in Airflow. It needs to handle both traditional class instantiation and decorator styles.\n+    \"\"\"\n+\n+    def __init__(self, from_imports: dict):\n+        self.from_imports = from_imports\n+        self.dag_instances: set[str] = set()\n+        self.is_in_dag_context: bool = False\n+\n+    def is_dag_constructor(self, node: ast.Call) -> bool:\n+        \"\"\"Check if a call is a DAG constructor.\"\"\"\n+        if not isinstance(node.func, ast.Name):\n+            return False\n+\n+        func_name = node.func.id\n+\n+        # \"from airflow import DAG\" form or \"from airflow.decorator import dag\"\n+        if func_name in self.from_imports:\n+            module, original = self.from_imports[func_name]\n+            if (module == \"airflow\" or module.startswith(\"airflow.\")) and original in (\"DAG\", \"dag\"):\n+                return True\n+\n+        return False\n+\n+    def is_task_constructor(self, node: ast.Call) -> bool:\n+        \"\"\"\n+        Check if a call is a Task constructor.\n+\n+        Criteria:\n+        1. All calls within a DAG with block\n+        2. Calls that receive a DAG instance as an argument (dag=...)\n+        \"\"\"\n+        # Inside DAG with block\n+        if self.is_in_dag_context:\n+            return True\n+\n+        # Passing DAG instance as argument\n+        for arg in node.args:\n+            if isinstance(arg, ast.Name) and arg.id in self.dag_instances:\n+                return True\n+\n+        for keyword in node.keywords:\n+            if keyword.value and isinstance(keyword.value, ast.Name):\n+                if keyword.value.id in self.dag_instances:\n+                    return True\n+\n+        return False\n+\n+    def register_dag_instance(self, var_name: str):\n+        \"\"\"Register a DAG instance variable name.\"\"\"\n+        self.dag_instances.add(var_name)\n+\n+    def enter_dag_context(self):\n+        \"\"\"Enter a DAG with block.\"\"\"\n+        self.is_in_dag_context = True\n+\n+    def exit_dag_context(self):\n+        \"\"\"Exit a DAG with block.\"\"\"\n+        self.is_in_dag_context = False\n+\n+\n+class AirflowRuntimeVaryingValueChecker(ast.NodeVisitor):\n+    \"\"\"\n+    Main visitor class to detect runtime-varying value usage in Airflow DAG/Task.\n+\n+    Main responsibilities:\n+    - Traverse AST and visit nodes\n+    - Detect DAG/Task creation\n+    - Track runtime-varying values and generate warnings",
      "comment": "```suggestion\n    Main visitor class to detect runtime-varying value usage in Airflow Dag/Task.\n\n    Main responsibilities:\n    - Traverse AST and visit nodes\n    - Detect Dag/Task creation\n    - Track runtime-varying values and generate warnings\n```",
      "comment_id": 2626248574,
      "user": "Lee-W",
      "created_at": "2025-12-17T09:23:21Z",
      "url": "https://github.com/apache/airflow/pull/59430#discussion_r2626248574"
    },
    {
      "repo": "apache/airflow",
      "pr_number": 59430,
      "file_path": "airflow-core/src/airflow/utils/dag_stability_checker.py",
      "line": 527,
      "side": "RIGHT",
      "diff_hunk": "@@ -0,0 +1,468 @@\n+# Licensed to the Apache Software Foundation (ASF) under one\n+# or more contributor license agreements.  See the NOTICE file\n+# distributed with this work for additional information\n+# regarding copyright ownership.  The ASF licenses this file\n+# to you under the Apache License, Version 2.0 (the\n+# \"License\"); you may not use this file except in compliance\n+# with the License.  You may obtain a copy of the License at\n+#\n+#   http://www.apache.org/licenses/LICENSE-2.0\n+#\n+# Unless required by applicable law or agreed to in writing,\n+# software distributed under the License is distributed on an\n+# \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+# KIND, either express or implied.  See the License for the\n+# specific language governing permissions and limitations\n+# under the License.\n+from __future__ import annotations\n+\n+import ast\n+from dataclasses import dataclass\n+from enum import Enum\n+from pathlib import Path\n+\n+\n+@dataclass\n+class RuntimeVaryingValueWarning:\n+    \"\"\"Warning information for runtime-varying value detection.\"\"\"\n+\n+    line: int\n+    col: int\n+    code: str\n+    message: str\n+\n+\n+class WarningContext(str, Enum):\n+    \"\"\"Context types for warnings.\"\"\"\n+\n+    TASK_CONSTRUCTOR = \"TASK constructor\"\n+    DAG_CONSTRUCTOR = \"DAG constructor\"\n+\n+\n+RUNTIME_VARYING_CALLS = [\n+    (\"datetime\", \"now\"),\n+    (\"datetime\", \"today\"),\n+    (\"datetime\", \"utcnow\"),\n+    (\"date\", \"today\"),\n+    (\"time\", \"time\"),\n+    (\"time\", \"localtime\"),\n+    (\"random\", \"random\"),\n+    (\"random\", \"randint\"),\n+    (\"random\", \"choice\"),\n+    (\"random\", \"uniform\"),\n+    (\"uuid\", \"uuid4\"),\n+    (\"uuid\", \"uuid1\"),\n+]\n+\n+\n+class RuntimeVaryingValueAnalyzer:\n+    \"\"\"\n+    Analyzer dedicated to tracking and detecting runtime-varying values.\n+\n+    This analyzer is responsible for identifying if a given AST node\n+    contains values that change on every execution (datetime.now(), random(), etc.).\n+    \"\"\"\n+\n+    def __init__(self, varying_vars: dict, imports: dict, from_imports: dict):\n+        self.varying_vars = varying_vars\n+        self.imports = imports\n+        self.from_imports = from_imports\n+\n+    def get_varying_source(self, node: ast.expr) -> str | None:\n+        \"\"\"\n+        Check if an AST node contains runtime-varying values and return the source.\n+\n+        Checks:\n+        - Runtime-varying function calls (datetime.now(), etc.)\n+        - Runtime-varying variable references\n+        - Runtime-varying values in f-strings\n+        - Runtime-varying values in expressions/collections\n+        \"\"\"\n+        # 1. Direct runtime-varying call\n+        if isinstance(node, ast.Call) and self._is_runtime_varying_call(node):\n+            return ast.unparse(node)\n+\n+        # 2. Runtime-varying variable reference\n+        if isinstance(node, ast.Name) and node.id in self.varying_vars:\n+            _, source = self.varying_vars[node.id]\n+            return source\n+\n+        # 3. f-string\n+        if isinstance(node, ast.JoinedStr):\n+            return self._check_fstring_varying(node)\n+\n+        # 4. Binary operation\n+        if isinstance(node, ast.BinOp):\n+            return self.get_varying_source(node.left) or self.get_varying_source(node.right)\n+\n+        # 5. Collections (list/tuple/set)\n+        if isinstance(node, (ast.List, ast.Tuple, ast.Set)):\n+            return self._check_collection_varying(node.elts)\n+\n+        # 6. List comprehension\n+        if isinstance(node, ast.ListComp):\n+            return self.get_varying_source(node.elt)\n+\n+        # 7. Dictionary\n+        if isinstance(node, ast.Dict):\n+            return self._check_dict_varying(node)\n+\n+        # 8. Method call chain\n+        if isinstance(node, ast.Call) and isinstance(node.func, ast.Attribute):\n+            return self.get_varying_source(node.func.value)\n+\n+        return None\n+\n+    def _check_fstring_varying(self, node: ast.JoinedStr) -> str | None:\n+        \"\"\"Check for runtime-varying values inside f-strings.\"\"\"\n+        for value in node.values:\n+            if isinstance(value, ast.FormattedValue):\n+                source = self.get_varying_source(value.value)\n+                if source:\n+                    return source\n+        return None\n+\n+    def _check_collection_varying(self, elements: list) -> str | None:\n+        \"\"\"Check for runtime-varying values in collection elements.\"\"\"\n+        for elt in elements:\n+            source = self.get_varying_source(elt)\n+            if source:\n+                return source\n+        return None\n+\n+    def _check_dict_varying(self, node: ast.Dict) -> str | None:\n+        \"\"\"Check for runtime-varying values in dictionary keys/values.\"\"\"\n+        for key, value in zip(node.keys, node.values):\n+            if key:\n+                source = self.get_varying_source(key)\n+                if source:\n+                    return source\n+            if value:\n+                source = self.get_varying_source(value)\n+                if source:\n+                    return source\n+        return None\n+\n+    def _is_runtime_varying_call(self, node: ast.Call) -> bool:\n+        \"\"\"\n+        Check if a call is runtime-varying.\n+\n+        1. Is the function itself runtime-varying?\n+        2. Do the arguments contain runtime-varying values?\n+        \"\"\"\n+        # Check if the function itself is runtime-varying\n+        if isinstance(node.func, ast.Attribute):\n+            if self._is_runtime_varying_attribute_call(node.func):\n+                return True\n+        elif isinstance(node.func, ast.Name):\n+            if self._is_runtime_varying_name_call(node.func):\n+                return True\n+\n+        # Check if arguments contain runtime-varying values\n+        return self._has_varying_arguments(node)\n+\n+    def _has_varying_arguments(self, node: ast.Call) -> bool:\n+        \"\"\"Check if function arguments contain runtime-varying values.\"\"\"\n+        for arg in node.args:\n+            if self.get_varying_source(arg):\n+                return True\n+\n+        for kw in node.keywords:\n+            if self.get_varying_source(kw.value):\n+                return True\n+\n+        return False\n+\n+    def _is_runtime_varying_attribute_call(self, attr: ast.Attribute) -> bool:\n+        \"\"\"Check for runtime-varying calls like datetime.now().\"\"\"\n+        method_name = attr.attr\n+\n+        if isinstance(attr.value, ast.Name):\n+            module_or_alias = attr.value.id\n+            actual_module = self.imports.get(module_or_alias, module_or_alias)\n+\n+            # If imported via \"from import\"\n+            if module_or_alias in self.from_imports:\n+                _, original_name = self.from_imports[module_or_alias]\n+                actual_module = original_name\n+\n+            return (actual_module, method_name) in RUNTIME_VARYING_CALLS\n+\n+        # Nested attribute (e.g., datetime.datetime.now)\n+        if isinstance(attr.value, ast.Attribute):\n+            inner_attr = attr.value\n+            if isinstance(inner_attr.value, ast.Name):\n+                return (inner_attr.attr, method_name) in RUNTIME_VARYING_CALLS\n+\n+        return False\n+\n+    def _is_runtime_varying_name_call(self, func: ast.Name) -> bool:\n+        \"\"\"Check for runtime-varying calls like now() (when imported via 'from import').\"\"\"\n+        func_name = func.id\n+\n+        if func_name in self.from_imports:\n+            module, original_name = self.from_imports[func_name]\n+            module_parts = module.split(\".\")\n+\n+            for part in module_parts:\n+                if (part, original_name) in RUNTIME_VARYING_CALLS:\n+                    return True\n+\n+        return False\n+\n+\n+class DAGTaskDetector:\n+    \"\"\"\n+    Detector dedicated to identifying DAG and Task constructors.\n+\n+    This detector identifies when code is creating DAG or Task objects\n+    in Airflow. It needs to handle both traditional class instantiation and decorator styles.\n+    \"\"\"\n+\n+    def __init__(self, from_imports: dict):\n+        self.from_imports = from_imports\n+        self.dag_instances: set[str] = set()\n+        self.is_in_dag_context: bool = False\n+\n+    def is_dag_constructor(self, node: ast.Call) -> bool:\n+        \"\"\"Check if a call is a DAG constructor.\"\"\"\n+        if not isinstance(node.func, ast.Name):\n+            return False\n+\n+        func_name = node.func.id\n+\n+        # \"from airflow import DAG\" form or \"from airflow.decorator import dag\"\n+        if func_name in self.from_imports:\n+            module, original = self.from_imports[func_name]\n+            if (module == \"airflow\" or module.startswith(\"airflow.\")) and original in (\"DAG\", \"dag\"):\n+                return True\n+\n+        return False\n+\n+    def is_task_constructor(self, node: ast.Call) -> bool:\n+        \"\"\"\n+        Check if a call is a Task constructor.\n+\n+        Criteria:\n+        1. All calls within a DAG with block\n+        2. Calls that receive a DAG instance as an argument (dag=...)\n+        \"\"\"\n+        # Inside DAG with block\n+        if self.is_in_dag_context:\n+            return True\n+\n+        # Passing DAG instance as argument\n+        for arg in node.args:\n+            if isinstance(arg, ast.Name) and arg.id in self.dag_instances:\n+                return True\n+\n+        for keyword in node.keywords:\n+            if keyword.value and isinstance(keyword.value, ast.Name):\n+                if keyword.value.id in self.dag_instances:\n+                    return True\n+\n+        return False\n+\n+    def register_dag_instance(self, var_name: str):\n+        \"\"\"Register a DAG instance variable name.\"\"\"\n+        self.dag_instances.add(var_name)\n+\n+    def enter_dag_context(self):\n+        \"\"\"Enter a DAG with block.\"\"\"\n+        self.is_in_dag_context = True\n+\n+    def exit_dag_context(self):\n+        \"\"\"Exit a DAG with block.\"\"\"\n+        self.is_in_dag_context = False\n+\n+\n+class AirflowRuntimeVaryingValueChecker(ast.NodeVisitor):\n+    \"\"\"\n+    Main visitor class to detect runtime-varying value usage in Airflow DAG/Task.\n+\n+    Main responsibilities:\n+    - Traverse AST and visit nodes\n+    - Detect DAG/Task creation\n+    - Track runtime-varying values and generate warnings\n+    \"\"\"\n+\n+    def __init__(self):\n+        self.warnings: list[RuntimeVaryingValueWarning] = []\n+        self.imports: dict[str, str] = {}\n+        self.from_imports: dict[str, tuple[str, str]] = {}\n+        self.varying_vars: dict[str, tuple[int, str]] = {}\n+\n+        # Helper objects\n+        self.value_analyzer = RuntimeVaryingValueAnalyzer(self.varying_vars, self.imports, self.from_imports)\n+        self.dag_detector = DAGTaskDetector(self.from_imports)\n+\n+    def visit_Import(self, node: ast.Import):\n+        \"\"\"Process import statements.\"\"\"\n+        for alias in node.names:\n+            name = alias.asname or alias.name\n+            self.imports[name] = alias.name\n+\n+    def visit_ImportFrom(self, node: ast.ImportFrom):\n+        \"\"\"Process from ... import statements.\"\"\"\n+        if node.module:\n+            for alias in node.names:\n+                name = alias.asname or alias.name\n+                self.from_imports[name] = (node.module, alias.name)\n+\n+    def visit_Assign(self, node: ast.Assign):\n+        \"\"\"\n+        Process variable assignments.\n+\n+        Checks:\n+        1. DAG instance assignment\n+        2. Task instance assignment\n+        3. Runtime-varying value assignment\n+        \"\"\"\n+        value = node.value\n+\n+        # DAG constructor\n+        if isinstance(value, ast.Call) and self.dag_detector.is_dag_constructor(value):\n+            self._register_dag_instances(node.targets)\n+            self._check_and_warn(value, WarningContext.DAG_CONSTRUCTOR)\n+\n+        # Task constructor\n+        elif isinstance(value, ast.Call) and self.dag_detector.is_task_constructor(value):\n+            self._check_and_warn(value, WarningContext.TASK_CONSTRUCTOR)\n+\n+        # Track runtime-varying values\n+        else:\n+            self._track_varying_assignment(node)\n+\n+    def visit_Call(self, node: ast.Call):\n+        \"\"\"\n+        Process function calls.\n+\n+        Check not assign but just call the function or dag definition via decorator.\n+        \"\"\"\n+        if self.dag_detector.is_dag_constructor(node):\n+            self._check_and_warn(node, WarningContext.DAG_CONSTRUCTOR)\n+\n+        elif self.dag_detector.is_task_constructor(node):\n+            self._check_and_warn(node, WarningContext.TASK_CONSTRUCTOR)\n+\n+    def visit_For(self, node: ast.For):\n+        \"\"\"\n+        Process for statements.\n+\n+        Check if iteration target contains runtime-varying values.\n+        \"\"\"\n+        # check the iterator value is runtime-varying\n+        # iter is runtime-varying : for iter in [datetime.now(), 3]\n+        varying_source = self.value_analyzer.get_varying_source(node.iter)\n+        if varying_source:\n+            if isinstance(node.target, ast.Name):\n+                self.varying_vars[node.target.id] = (node.lineno, varying_source)\n+\n+        for body in node.body:\n+            self.visit(body)\n+\n+        if varying_source:\n+            if isinstance(node.target, ast.Name):\n+                self.varying_vars.pop(node.target.id)\n+\n+    def visit_With(self, node: ast.With):\n+        \"\"\"\n+        Process with statements.\n+\n+        Detect DAG context manager.\n+        \"\"\"\n+        is_with_dag_context = False\n+        for item in node.items:\n+            # check if the dag instance exists in with context\n+            self.visit(item)\n+            if isinstance(item.context_expr, ast.Call):\n+                if self.dag_detector.is_dag_constructor(item.context_expr):\n+                    # check the value defined in with statement to detect entering DAG with block\n+                    is_with_dag_context = True\n+\n+        if is_with_dag_context:\n+            self.dag_detector.enter_dag_context()\n+\n+        for body in node.body:\n+            self.visit(body)\n+\n+        # Exit DAG with block\n+        self.dag_detector.exit_dag_context()\n+\n+    def _register_dag_instances(self, targets: list):\n+        \"\"\"Register DAG instance variable names.\"\"\"\n+        for target in targets:\n+            if isinstance(target, ast.Name):\n+                self.dag_detector.register_dag_instance(target.id)\n+\n+    def _track_varying_assignment(self, node: ast.Assign):\n+        \"\"\"Track variable assignments with runtime-varying values.\"\"\"\n+        varying_source = self.value_analyzer.get_varying_source(node.value)\n+        if varying_source:\n+            for target in node.targets:\n+                if isinstance(target, ast.Name):\n+                    self.varying_vars[target.id] = (node.lineno, varying_source)\n+\n+    def _check_and_warn(self, call: ast.Call, context: WarningContext):\n+        \"\"\"Check function call arguments and generate warnings.\"\"\"\n+        varying_source = self.value_analyzer.get_varying_source(call)\n+        if varying_source:\n+            self.warnings.append(\n+                RuntimeVaryingValueWarning(\n+                    line=call.lineno,\n+                    col=call.col_offset,\n+                    code=ast.unparse(call),\n+                    message=self._get_warning_message(context),\n+                )\n+            )\n+\n+    def _get_warning_message(self, context: WarningContext):\n+        \"\"\"Get appropriate warning message based on context.\"\"\"\n+        if self.dag_detector.is_in_dag_context and context == WarningContext.TASK_CONSTRUCTOR:\n+            return \"Don't use runtime-varying values as function arguments within with DAG block\"\n+        return f\"Don't use runtime-varying value as argument in {context.value}\"\n+\n+    def format_warnings(self) -> str | None:\n+        \"\"\"Return formatted string of warning list.\"\"\"\n+        if not self.warnings:\n+            return None\n+\n+        lines = [\n+            \"\u26a0\ufe0f This DAG uses runtime-variable values in DAG construction.\",\n+            \"\u26a0\ufe0f It causes the DAG version to increase as values change on every DAG parse.\",\n+            \"\",\n+        ]\n+        for w in self.warnings:\n+            lines.append(f\"Line {w.line}, Col {w.col}\")\n+            lines.append(f\"Code: {w.code}\")\n+            lines.append(f\"Issue: {w.message}\")\n+            lines.append(\"\")\n+\n+        return \"\\n\".join(lines)\n+\n+\n+def check_dag_file_static(file_path):\n+    try:\n+        parsed = ast.parse(Path(file_path).read_bytes())\n+    except Exception:",
      "comment": "Is it possible to catch a more specific exception here?",
      "comment_id": 2626256840,
      "user": "Lee-W",
      "created_at": "2025-12-17T09:25:48Z",
      "url": "https://github.com/apache/airflow/pull/59430#discussion_r2626256840"
    },
    {
      "repo": "apache/airflow",
      "pr_number": 59430,
      "file_path": "airflow-core/src/airflow/utils/static_checker.py",
      "line": 444,
      "side": "RIGHT",
      "diff_hunk": "@@ -0,0 +1,468 @@\n+# Licensed to the Apache Software Foundation (ASF) under one\n+# or more contributor license agreements.  See the NOTICE file\n+# distributed with this work for additional information\n+# regarding copyright ownership.  The ASF licenses this file\n+# to you under the Apache License, Version 2.0 (the\n+# \"License\"); you may not use this file except in compliance\n+# with the License.  You may obtain a copy of the License at\n+#\n+#   http://www.apache.org/licenses/LICENSE-2.0\n+#\n+# Unless required by applicable law or agreed to in writing,\n+# software distributed under the License is distributed on an\n+# \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+# KIND, either express or implied.  See the License for the\n+# specific language governing permissions and limitations\n+# under the License.\n+from __future__ import annotations\n+\n+import ast\n+from dataclasses import dataclass\n+from enum import Enum\n+from pathlib import Path\n+\n+\n+@dataclass\n+class RuntimeVaryingValueWarning:\n+    \"\"\"Warning information for runtime-varying value detection.\"\"\"\n+\n+    line: int\n+    col: int\n+    code: str\n+    message: str\n+\n+\n+class WarningContext(str, Enum):\n+    \"\"\"Context types for warnings.\"\"\"\n+\n+    TASK_CONSTRUCTOR = \"TASK constructor\"\n+    DAG_CONSTRUCTOR = \"DAG constructor\"\n+\n+\n+RUNTIME_VARYING_CALLS = [\n+    (\"datetime\", \"now\"),\n+    (\"datetime\", \"today\"),\n+    (\"datetime\", \"utcnow\"),\n+    (\"date\", \"today\"),\n+    (\"time\", \"time\"),\n+    (\"time\", \"localtime\"),\n+    (\"random\", \"random\"),\n+    (\"random\", \"randint\"),\n+    (\"random\", \"choice\"),\n+    (\"random\", \"uniform\"),\n+    (\"uuid\", \"uuid4\"),\n+    (\"uuid\", \"uuid1\"),\n+]\n+\n+\n+class RuntimeVaryingValueAnalyzer:\n+    \"\"\"\n+    Analyzer dedicated to tracking and detecting runtime-varying values.\n+\n+    This analyzer is responsible for identifying if a given AST node\n+    contains values that change on every execution (datetime.now(), random(), etc.).\n+    \"\"\"\n+\n+    def __init__(self, varying_vars: dict, imports: dict, from_imports: dict):\n+        self.varying_vars = varying_vars\n+        self.imports = imports\n+        self.from_imports = from_imports\n+\n+    def get_varying_source(self, node: ast.expr) -> str | None:\n+        \"\"\"\n+        Check if an AST node contains runtime-varying values and return the source.\n+\n+        Checks:\n+        - Runtime-varying function calls (datetime.now(), etc.)\n+        - Runtime-varying variable references\n+        - Runtime-varying values in f-strings\n+        - Runtime-varying values in expressions/collections\n+        \"\"\"\n+        # 1. Direct runtime-varying call\n+        if isinstance(node, ast.Call) and self._is_runtime_varying_call(node):\n+            return ast.unparse(node)\n+\n+        # 2. Runtime-varying variable reference\n+        if isinstance(node, ast.Name) and node.id in self.varying_vars:\n+            _, source = self.varying_vars[node.id]\n+            return source\n+\n+        # 3. f-string\n+        if isinstance(node, ast.JoinedStr):\n+            return self._check_fstring_varying(node)\n+\n+        # 4. Binary operation\n+        if isinstance(node, ast.BinOp):\n+            return self.get_varying_source(node.left) or self.get_varying_source(node.right)\n+\n+        # 5. Collections (list/tuple/set)\n+        if isinstance(node, (ast.List, ast.Tuple, ast.Set)):\n+            return self._check_collection_varying(node.elts)\n+\n+        # 6. List comprehension\n+        if isinstance(node, ast.ListComp):\n+            return self.get_varying_source(node.elt)\n+\n+        # 7. Dictionary\n+        if isinstance(node, ast.Dict):\n+            return self._check_dict_varying(node)\n+\n+        # 8. Method call chain\n+        if isinstance(node, ast.Call) and isinstance(node.func, ast.Attribute):\n+            return self.get_varying_source(node.func.value)\n+\n+        return None\n+\n+    def _check_fstring_varying(self, node: ast.JoinedStr) -> str | None:\n+        \"\"\"Check for runtime-varying values inside f-strings.\"\"\"\n+        for value in node.values:\n+            if isinstance(value, ast.FormattedValue):\n+                source = self.get_varying_source(value.value)\n+                if source:\n+                    return source\n+        return None\n+\n+    def _check_collection_varying(self, elements: list) -> str | None:\n+        \"\"\"Check for runtime-varying values in collection elements.\"\"\"\n+        for elt in elements:\n+            source = self.get_varying_source(elt)\n+            if source:\n+                return source\n+        return None\n+\n+    def _check_dict_varying(self, node: ast.Dict) -> str | None:\n+        \"\"\"Check for runtime-varying values in dictionary keys/values.\"\"\"\n+        for key, value in zip(node.keys, node.values):\n+            if key:\n+                source = self.get_varying_source(key)\n+                if source:\n+                    return source\n+            if value:\n+                source = self.get_varying_source(value)\n+                if source:\n+                    return source\n+        return None\n+\n+    def _is_runtime_varying_call(self, node: ast.Call) -> bool:\n+        \"\"\"\n+        Check if a call is runtime-varying.\n+\n+        1. Is the function itself runtime-varying?\n+        2. Do the arguments contain runtime-varying values?\n+        \"\"\"\n+        # Check if the function itself is runtime-varying\n+        if isinstance(node.func, ast.Attribute):\n+            if self._is_runtime_varying_attribute_call(node.func):\n+                return True\n+        elif isinstance(node.func, ast.Name):\n+            if self._is_runtime_varying_name_call(node.func):\n+                return True\n+\n+        # Check if arguments contain runtime-varying values\n+        return self._has_varying_arguments(node)\n+\n+    def _has_varying_arguments(self, node: ast.Call) -> bool:\n+        \"\"\"Check if function arguments contain runtime-varying values.\"\"\"\n+        for arg in node.args:\n+            if self.get_varying_source(arg):\n+                return True\n+\n+        for kw in node.keywords:\n+            if self.get_varying_source(kw.value):\n+                return True\n+\n+        return False\n+\n+    def _is_runtime_varying_attribute_call(self, attr: ast.Attribute) -> bool:\n+        \"\"\"Check for runtime-varying calls like datetime.now().\"\"\"\n+        method_name = attr.attr\n+\n+        if isinstance(attr.value, ast.Name):\n+            module_or_alias = attr.value.id\n+            actual_module = self.imports.get(module_or_alias, module_or_alias)\n+\n+            # If imported via \"from import\"\n+            if module_or_alias in self.from_imports:\n+                _, original_name = self.from_imports[module_or_alias]\n+                actual_module = original_name\n+\n+            return (actual_module, method_name) in RUNTIME_VARYING_CALLS\n+\n+        # Nested attribute (e.g., datetime.datetime.now)\n+        if isinstance(attr.value, ast.Attribute):\n+            inner_attr = attr.value\n+            if isinstance(inner_attr.value, ast.Name):\n+                return (inner_attr.attr, method_name) in RUNTIME_VARYING_CALLS\n+\n+        return False\n+\n+    def _is_runtime_varying_name_call(self, func: ast.Name) -> bool:\n+        \"\"\"Check for runtime-varying calls like now() (when imported via 'from import').\"\"\"\n+        func_name = func.id\n+\n+        if func_name in self.from_imports:\n+            module, original_name = self.from_imports[func_name]\n+            module_parts = module.split(\".\")\n+\n+            for part in module_parts:\n+                if (part, original_name) in RUNTIME_VARYING_CALLS:\n+                    return True\n+\n+        return False\n+\n+\n+class DAGTaskDetector:\n+    \"\"\"\n+    Detector dedicated to identifying DAG and Task constructors.\n+\n+    This detector identifies when code is creating DAG or Task objects\n+    in Airflow. It needs to handle both traditional class instantiation and decorator styles.\n+    \"\"\"\n+\n+    def __init__(self, from_imports: dict):\n+        self.from_imports = from_imports\n+        self.dag_instances: set[str] = set()\n+        self.is_in_dag_context: bool = False\n+\n+    def is_dag_constructor(self, node: ast.Call) -> bool:\n+        \"\"\"Check if a call is a DAG constructor.\"\"\"\n+        if not isinstance(node.func, ast.Name):\n+            return False\n+\n+        func_name = node.func.id\n+\n+        # \"from airflow import DAG\" form or \"from airflow.decorator import dag\"\n+        if func_name in self.from_imports:\n+            module, original = self.from_imports[func_name]\n+            if (module == \"airflow\" or module.startswith(\"airflow.\")) and original in (\"DAG\", \"dag\"):\n+                return True\n+\n+        return False\n+\n+    def is_task_constructor(self, node: ast.Call) -> bool:\n+        \"\"\"\n+        Check if a call is a Task constructor.\n+\n+        Criteria:\n+        1. All calls within a DAG with block\n+        2. Calls that receive a DAG instance as an argument (dag=...)\n+        \"\"\"\n+        # Inside DAG with block\n+        if self.is_in_dag_context:\n+            return True\n+\n+        # Passing DAG instance as argument\n+        for arg in node.args:\n+            if isinstance(arg, ast.Name) and arg.id in self.dag_instances:\n+                return True\n+\n+        for keyword in node.keywords:\n+            if keyword.value and isinstance(keyword.value, ast.Name):\n+                if keyword.value.id in self.dag_instances:\n+                    return True\n+\n+        return False\n+\n+    def register_dag_instance(self, var_name: str):\n+        \"\"\"Register a DAG instance variable name.\"\"\"\n+        self.dag_instances.add(var_name)\n+\n+    def enter_dag_context(self):\n+        \"\"\"Enter a DAG with block.\"\"\"\n+        self.is_in_dag_context = True\n+\n+    def exit_dag_context(self):\n+        \"\"\"Exit a DAG with block.\"\"\"\n+        self.is_in_dag_context = False\n+\n+\n+class AirflowRuntimeVaryingValueChecker(ast.NodeVisitor):\n+    \"\"\"\n+    Main visitor class to detect runtime-varying value usage in Airflow DAG/Task.\n+\n+    Main responsibilities:\n+    - Traverse AST and visit nodes\n+    - Detect DAG/Task creation\n+    - Track runtime-varying values and generate warnings\n+    \"\"\"\n+\n+    def __init__(self):\n+        self.warnings: list[RuntimeVaryingValueWarning] = []\n+        self.imports: dict[str, str] = {}\n+        self.from_imports: dict[str, tuple[str, str]] = {}\n+        self.varying_vars: dict[str, tuple[int, str]] = {}\n+\n+        # Helper objects\n+        self.value_analyzer = RuntimeVaryingValueAnalyzer(self.varying_vars, self.imports, self.from_imports)\n+        self.dag_detector = DAGTaskDetector(self.from_imports)\n+\n+    def visit_Import(self, node: ast.Import):\n+        \"\"\"Process import statements.\"\"\"\n+        for alias in node.names:\n+            name = alias.asname or alias.name\n+            self.imports[name] = alias.name\n+\n+    def visit_ImportFrom(self, node: ast.ImportFrom):\n+        \"\"\"Process from ... import statements.\"\"\"\n+        if node.module:\n+            for alias in node.names:\n+                name = alias.asname or alias.name\n+                self.from_imports[name] = (node.module, alias.name)\n+\n+    def visit_Assign(self, node: ast.Assign):\n+        \"\"\"\n+        Process variable assignments.\n+\n+        Checks:\n+        1. DAG instance assignment\n+        2. Task instance assignment\n+        3. Runtime-varying value assignment\n+        \"\"\"\n+        value = node.value\n+\n+        # DAG constructor\n+        if isinstance(value, ast.Call) and self.dag_detector.is_dag_constructor(value):\n+            self._register_dag_instances(node.targets)\n+            self._check_and_warn(value, WarningContext.DAG_CONSTRUCTOR)\n+\n+        # Task constructor\n+        elif isinstance(value, ast.Call) and self.dag_detector.is_task_constructor(value):\n+            self._check_and_warn(value, WarningContext.TASK_CONSTRUCTOR)\n+\n+        # Track runtime-varying values\n+        else:\n+            self._track_varying_assignment(node)\n+\n+    def visit_Call(self, node: ast.Call):\n+        \"\"\"\n+        Process function calls.\n+\n+        Check not assign but just call the function or dag definition via decorator.\n+        \"\"\"\n+        if self.dag_detector.is_dag_constructor(node):\n+            self._check_and_warn(node, WarningContext.DAG_CONSTRUCTOR)\n+\n+        elif self.dag_detector.is_task_constructor(node):\n+            self._check_and_warn(node, WarningContext.TASK_CONSTRUCTOR)\n+\n+    def visit_For(self, node: ast.For):\n+        \"\"\"\n+        Process for statements.\n+\n+        Check if iteration target contains runtime-varying values.\n+        \"\"\"\n+        # check the iterator value is runtime-varying\n+        # iter is runtime-varying : for iter in [datetime.now(), 3]\n+        varying_source = self.value_analyzer.get_varying_source(node.iter)\n+        if varying_source:\n+            if isinstance(node.target, ast.Name):\n+                self.varying_vars[node.target.id] = (node.lineno, varying_source)\n+\n+        for body in node.body:\n+            self.visit(body)\n+\n+        if varying_source:\n+            if isinstance(node.target, ast.Name):\n+                self.varying_vars.pop(node.target.id)\n+\n+    def visit_With(self, node: ast.With):\n+        \"\"\"\n+        Process with statements.\n+\n+        Detect DAG context manager.\n+        \"\"\"\n+        is_with_dag_context = False\n+        for item in node.items:\n+            # check if the dag instance exists in with context\n+            self.visit(item)\n+            if isinstance(item.context_expr, ast.Call):\n+                if self.dag_detector.is_dag_constructor(item.context_expr):\n+                    # check the value defined in with statement to detect entering DAG with block\n+                    is_with_dag_context = True\n+\n+        if is_with_dag_context:\n+            self.dag_detector.enter_dag_context()\n+\n+        for body in node.body:\n+            self.visit(body)\n+\n+        # Exit DAG with block\n+        self.dag_detector.exit_dag_context()\n+\n+    def _register_dag_instances(self, targets: list):\n+        \"\"\"Register DAG instance variable names.\"\"\"\n+        for target in targets:\n+            if isinstance(target, ast.Name):\n+                self.dag_detector.register_dag_instance(target.id)\n+\n+    def _track_varying_assignment(self, node: ast.Assign):\n+        \"\"\"Track variable assignments with runtime-varying values.\"\"\"\n+        varying_source = self.value_analyzer.get_varying_source(node.value)\n+        if varying_source:\n+            for target in node.targets:\n+                if isinstance(target, ast.Name):\n+                    self.varying_vars[target.id] = (node.lineno, varying_source)\n+\n+    def _check_and_warn(self, call: ast.Call, context: WarningContext):\n+        \"\"\"Check function call arguments and generate warnings.\"\"\"\n+        varying_source = self.value_analyzer.get_varying_source(call)\n+        if varying_source:\n+            self.warnings.append(\n+                RuntimeVaryingValueWarning(\n+                    line=call.lineno,\n+                    col=call.col_offset,\n+                    code=ast.unparse(call),\n+                    message=self._get_warning_message(context),\n+                )\n+            )\n+\n+    def _get_warning_message(self, context: WarningContext):\n+        \"\"\"Get appropriate warning message based on context.\"\"\"\n+        if self.dag_detector.is_in_dag_context and context == WarningContext.TASK_CONSTRUCTOR:\n+            return \"Don't use runtime-varying values as function arguments within with DAG block\"\n+        return f\"Don't use runtime-varying value as argument in {context.value}\"\n+\n+    def format_warnings(self) -> str | None:\n+        \"\"\"Return formatted string of warning list.\"\"\"\n+        if not self.warnings:\n+            return None\n+\n+        lines = [\n+            \"\u26a0\ufe0f This DAG uses runtime-variable values in DAG construction.\",\n+            \"\u26a0\ufe0f It causes the DAG version to increase as values change on every DAG parse.\",\n+            \"\",\n+        ]\n+        for w in self.warnings:\n+            lines.append(f\"Line {w.line}, Col {w.col}\")\n+            lines.append(f\"Code: {w.code}\")\n+            lines.append(f\"Issue: {w.message}\")\n+            lines.append(\"\")\n+\n+        return \"\\n\".join(lines)\n+\n+\n+def check_dag_file_static(file_path):",
      "comment": "```suggestion\ndef check_dag_file_static(file_path) -> str | None:\n```",
      "comment_id": 2626264516,
      "user": "Lee-W",
      "created_at": "2025-12-17T09:27:59Z",
      "url": "https://github.com/apache/airflow/pull/59430#discussion_r2626264516"
    },
    {
      "repo": "apache/airflow",
      "pr_number": 59430,
      "file_path": "airflow-core/src/airflow/dag_processing/collection.py",
      "line": 377,
      "side": "RIGHT",
      "diff_hunk": "@@ -371,7 +374,10 @@ def update_dag_parsing_results_in_db(\n     warnings: set[DagWarning],\n     session: Session,\n     *,\n-    warning_types: tuple[DagWarningType] = (DagWarningType.NONEXISTENT_POOL,),\n+    warning_types: tuple[DagWarningType, DagWarningType] = (",
      "comment": "```suggestion\r\n    warning_types: tuple[DagWarningType, ...] = (\r\n```\r\nwe should use this everywhere for warning_types so we can avoid signature change in the future",
      "comment_id": 2626462173,
      "user": "ephraimbuddy",
      "created_at": "2025-12-17T10:24:02Z",
      "url": "https://github.com/apache/airflow/pull/59430#discussion_r2626462173"
    },
    {
      "repo": "apache/airflow",
      "pr_number": 59430,
      "file_path": "airflow-core/src/airflow/dag_processing/processor.py",
      "line": 212,
      "side": "RIGHT",
      "diff_hunk": "@@ -200,20 +201,24 @@ def _parse_file_entrypoint():\n         sys.path.append(bundle_root)\n \n     result = _parse_file(msg, log)\n+\n     if result is not None:\n         comms_decoder.send(result)\n \n \n def _parse_file(msg: DagFileParseRequest, log: FilteringBoundLogger) -> DagFileParsingResult | None:\n     # TODO: Set known_pool names on DagBag!\n \n+    warning_statement = check_dag_file_static(os.fspath(msg.file))",
      "comment": "We should have a catch all exceptions here to ensure this doesn't break the parsing. We should manually test this implementation with very large dag file. ",
      "comment_id": 2626496409,
      "user": "ephraimbuddy",
      "created_at": "2025-12-17T10:32:46Z",
      "url": "https://github.com/apache/airflow/pull/59430#discussion_r2626496409"
    },
    {
      "repo": "apache/airflow",
      "pr_number": 59430,
      "file_path": "airflow-core/src/airflow/dag_processing/processor.py",
      "line": 212,
      "side": "RIGHT",
      "diff_hunk": "@@ -200,22 +201,34 @@ def _parse_file_entrypoint():\n         sys.path.append(bundle_root)\n \n     result = _parse_file(msg, log)\n+\n     if result is not None:\n         comms_decoder.send(result)\n \n \n def _parse_file(msg: DagFileParseRequest, log: FilteringBoundLogger) -> DagFileParsingResult | None:\n     # TODO: Set known_pool names on DagBag!\n \n+    static_check_result = check_dag_file_static(os.fspath(msg.file))",
      "comment": "same here ->  names should be updated  - > I think we should make it clear that this is a \"dag stability\" check - not \"static check\" in general.",
      "comment_id": 2644086300,
      "user": "potiuk",
      "created_at": "2025-12-23T19:25:27Z",
      "url": "https://github.com/apache/airflow/pull/59430#discussion_r2644086300"
    },
    {
      "repo": "apache/airflow",
      "pr_number": 59430,
      "file_path": "airflow-core/src/airflow/utils/static_checker.py",
      "line": 25,
      "side": "RIGHT",
      "diff_hunk": "@@ -0,0 +1,508 @@\n+# Licensed to the Apache Software Foundation (ASF) under one\n+# or more contributor license agreements.  See the NOTICE file\n+# distributed with this work for additional information\n+# regarding copyright ownership.  The ASF licenses this file\n+# to you under the Apache License, Version 2.0 (the\n+# \"License\"); you may not use this file except in compliance\n+# with the License.  You may obtain a copy of the License at\n+#\n+#   http://www.apache.org/licenses/LICENSE-2.0\n+#\n+# Unless required by applicable law or agreed to in writing,\n+# software distributed under the License is distributed on an\n+# \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+# KIND, either express or implied.  See the License for the\n+# specific language governing permissions and limitations\n+# under the License.\n+from __future__ import annotations\n+\n+import ast\n+from dataclasses import dataclass\n+from enum import Enum\n+from pathlib import Path\n+\n+\n+class StaticCheckerResult:",
      "comment": "Even here and module name -> I would say it's better if that whole PR focuses on \"dag stability\" or similar checks - rather than generic \"static checks\" -> yes it is done via static anaylysis of the AST, but there are so many different static checks that could even likely be done in different moments, with different switches and different \"off/error/warning\" values for the switches, that generically naming it \"static checks\" now is too early. \n\nI would say when we see the need for **third** such check we should see if we can implement some generic framework for static checks execution and error raising - but at this stage it's purely about \"Dag stability\".",
      "comment_id": 2644095699,
      "user": "potiuk",
      "created_at": "2025-12-23T19:29:21Z",
      "url": "https://github.com/apache/airflow/pull/59430#discussion_r2644095699"
    },
    {
      "repo": "apache/airflow",
      "pr_number": 59430,
      "file_path": "airflow-core/src/airflow/dag_processing/processor.py",
      "line": 245,
      "side": "RIGHT",
      "diff_hunk": "@@ -229,8 +242,7 @@ def _parse_file(msg: DagFileParseRequest, log: FilteringBoundLogger) -> DagFileP\n         fileloc=msg.file,\n         serialized_dags=serialized_dags,\n         import_errors=bag.import_errors,\n-        # TODO: Make `bag.dag_warnings` not return SQLA model objects\n-        warnings=[],\n+        warnings=stability_check_result.get_warning_dag_format_dict(bag.dag_ids),",
      "comment": "Since we update them separately by DagWarningType, there shouldn't be any case where one warning overrides another\r\nhttps://github.com/apache/airflow/blob/main/airflow-core/src/airflow/dag_processing/collection.py#L268",
      "comment_id": 2656770971,
      "user": "wjddn279",
      "created_at": "2026-01-02T03:10:09Z",
      "url": "https://github.com/apache/airflow/pull/59430#discussion_r2656770971"
    },
    {
      "repo": "apache/airflow",
      "pr_number": 59430,
      "file_path": "airflow-core/src/airflow/utils/dag_stability_checker.py",
      "line": 27,
      "side": "RIGHT",
      "diff_hunk": "@@ -0,0 +1,510 @@\n+# Licensed to the Apache Software Foundation (ASF) under one\n+# or more contributor license agreements.  See the NOTICE file\n+# distributed with this work for additional information\n+# regarding copyright ownership.  The ASF licenses this file\n+# to you under the Apache License, Version 2.0 (the\n+# \"License\"); you may not use this file except in compliance\n+# with the License.  You may obtain a copy of the License at\n+#\n+#   http://www.apache.org/licenses/LICENSE-2.0\n+#\n+# Unless required by applicable law or agreed to in writing,\n+# software distributed under the License is distributed on an\n+# \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+# KIND, either express or implied.  See the License for the\n+# specific language governing permissions and limitations\n+# under the License.\n+from __future__ import annotations\n+\n+import ast\n+from dataclasses import dataclass\n+from enum import Enum\n+from pathlib import Path\n+\n+\n+class DagStabilityCheckerResult:\n+    \"\"\"\n+    Represents the result of stability analysis on a DAG file.",
      "comment": "```suggestion\n    Represents the result of stability analysis on a Dag file.\n```",
      "comment_id": 2660907949,
      "user": "Lee-W",
      "created_at": "2026-01-05T09:51:35Z",
      "url": "https://github.com/apache/airflow/pull/59430#discussion_r2660907949"
    },
    {
      "repo": "apache/airflow",
      "pr_number": 59430,
      "file_path": "airflow-core/src/airflow/utils/dag_stability_checker.py",
      "line": 33,
      "side": "RIGHT",
      "diff_hunk": "@@ -0,0 +1,510 @@\n+# Licensed to the Apache Software Foundation (ASF) under one\n+# or more contributor license agreements.  See the NOTICE file\n+# distributed with this work for additional information\n+# regarding copyright ownership.  The ASF licenses this file\n+# to you under the Apache License, Version 2.0 (the\n+# \"License\"); you may not use this file except in compliance\n+# with the License.  You may obtain a copy of the License at\n+#\n+#   http://www.apache.org/licenses/LICENSE-2.0\n+#\n+# Unless required by applicable law or agreed to in writing,\n+# software distributed under the License is distributed on an\n+# \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+# KIND, either express or implied.  See the License for the\n+# specific language governing permissions and limitations\n+# under the License.\n+from __future__ import annotations\n+\n+import ast\n+from dataclasses import dataclass\n+from enum import Enum\n+from pathlib import Path\n+\n+\n+class DagStabilityCheckerResult:\n+    \"\"\"\n+    Represents the result of stability analysis on a DAG file.\n+\n+    Stores detected warnings and formats them appropriately based on the configured check level\n+    (warning or error).\n+    \"\"\"\n+\n+    def __init__(self, check_level):",
      "comment": "```suggestion\n    def __init__(self, check_level: Literal[\"warning\", \"error\"]):\n```",
      "comment_id": 2660908546,
      "user": "Lee-W",
      "created_at": "2026-01-05T09:51:47Z",
      "url": "https://github.com/apache/airflow/pull/59430#discussion_r2660908546"
    },
    {
      "repo": "apache/airflow",
      "pr_number": 59430,
      "file_path": "airflow-core/src/airflow/utils/dag_stability_checker.py",
      "line": 52,
      "side": "RIGHT",
      "diff_hunk": "@@ -0,0 +1,510 @@\n+# Licensed to the Apache Software Foundation (ASF) under one\n+# or more contributor license agreements.  See the NOTICE file\n+# distributed with this work for additional information\n+# regarding copyright ownership.  The ASF licenses this file\n+# to you under the Apache License, Version 2.0 (the\n+# \"License\"); you may not use this file except in compliance\n+# with the License.  You may obtain a copy of the License at\n+#\n+#   http://www.apache.org/licenses/LICENSE-2.0\n+#\n+# Unless required by applicable law or agreed to in writing,\n+# software distributed under the License is distributed on an\n+# \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+# KIND, either express or implied.  See the License for the\n+# specific language governing permissions and limitations\n+# under the License.\n+from __future__ import annotations\n+\n+import ast\n+from dataclasses import dataclass\n+from enum import Enum\n+from pathlib import Path\n+\n+\n+class DagStabilityCheckerResult:\n+    \"\"\"\n+    Represents the result of stability analysis on a DAG file.\n+\n+    Stores detected warnings and formats them appropriately based on the configured check level\n+    (warning or error).\n+    \"\"\"\n+\n+    def __init__(self, check_level):\n+        self.check_level: str = check_level\n+        self.warnings: list[RuntimeVaryingValueWarning] = []\n+        self.runtime_varying_values: dict = {}\n+\n+    def format_warnings(self) -> str | None:\n+        \"\"\"Return formatted string of warning list.\"\"\"\n+        if not self.warnings:\n+            return None\n+\n+        lines = [\n+            \"\u26a0\ufe0f This Dag uses runtime-variable values in Dag construction.\",\n+            \"\u26a0\ufe0f It causes the Dag version to increase as values change on every Dag parse.\",\n+            \"\",\n+        ]\n+        for w in self.warnings:\n+            lines.append(f\"Line {w.line}, Col {w.col}\")\n+            lines.append(f\"Code: {w.code}\")\n+            lines.append(f\"Issue: {w.message}\")\n+            lines.append(\"\")",
      "comment": "```suggestion\n            lines.extend(\n                [\n                    f\"Line {w.line}, Col {w.col}\",\n                    f\"Code: {w.code}\",\n                    f\"Issue: {w.message}\",\n                    \"\",\n                ]\n            )\n```",
      "comment_id": 2660915380,
      "user": "Lee-W",
      "created_at": "2026-01-05T09:54:07Z",
      "url": "https://github.com/apache/airflow/pull/59430#discussion_r2660915380"
    },
    {
      "repo": "apache/airflow",
      "pr_number": 59430,
      "file_path": "airflow-core/src/airflow/utils/dag_stability_checker.py",
      "line": 60,
      "side": "RIGHT",
      "diff_hunk": "@@ -0,0 +1,510 @@\n+# Licensed to the Apache Software Foundation (ASF) under one\n+# or more contributor license agreements.  See the NOTICE file\n+# distributed with this work for additional information\n+# regarding copyright ownership.  The ASF licenses this file\n+# to you under the Apache License, Version 2.0 (the\n+# \"License\"); you may not use this file except in compliance\n+# with the License.  You may obtain a copy of the License at\n+#\n+#   http://www.apache.org/licenses/LICENSE-2.0\n+#\n+# Unless required by applicable law or agreed to in writing,\n+# software distributed under the License is distributed on an\n+# \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+# KIND, either express or implied.  See the License for the\n+# specific language governing permissions and limitations\n+# under the License.\n+from __future__ import annotations\n+\n+import ast\n+from dataclasses import dataclass\n+from enum import Enum\n+from pathlib import Path\n+\n+\n+class DagStabilityCheckerResult:\n+    \"\"\"\n+    Represents the result of stability analysis on a DAG file.\n+\n+    Stores detected warnings and formats them appropriately based on the configured check level\n+    (warning or error).\n+    \"\"\"\n+\n+    def __init__(self, check_level):\n+        self.check_level: str = check_level\n+        self.warnings: list[RuntimeVaryingValueWarning] = []\n+        self.runtime_varying_values: dict = {}\n+\n+    def format_warnings(self) -> str | None:\n+        \"\"\"Return formatted string of warning list.\"\"\"\n+        if not self.warnings:\n+            return None\n+\n+        lines = [\n+            \"\u26a0\ufe0f This Dag uses runtime-variable values in Dag construction.\",\n+            \"\u26a0\ufe0f It causes the Dag version to increase as values change on every Dag parse.\",\n+            \"\",\n+        ]\n+        for w in self.warnings:\n+            lines.append(f\"Line {w.line}, Col {w.col}\")\n+            lines.append(f\"Code: {w.code}\")\n+            lines.append(f\"Issue: {w.message}\")\n+            lines.append(\"\")\n+\n+        if self.runtime_varying_values:\n+            lines.append(\"\ufe0f\u26a0\ufe0f Don't use the variables as arguments in DAG/Task constructors:\")\n+            # Sort by line number\n+            sorted_vars = sorted(self.runtime_varying_values.items(), key=lambda x: x[1][0])\n+            for var_name, (line, source) in sorted_vars:\n+                lines.append(f\"  Line {line}: '{var_name}' related '{source}'\")\n+            lines.append(\"\")",
      "comment": "```suggestion\n            lines.extend(\n                [\n                    \"\ufe0f\u26a0\ufe0f Don't use the variables as arguments in DAG/Task constructors:\",\n                    *(\n                        f\"  Line {line}: '{var_name}' related '{source}'\"\n                        for var_name, (line, source) in sorted(\n                            self.runtime_varying_values.items(),\n                            key=lambda x: x[1][0],\n                        )\n                    ),\n                    \"\",\n                ]\n            )\n```",
      "comment_id": 2660923594,
      "user": "Lee-W",
      "created_at": "2026-01-05T09:57:02Z",
      "url": "https://github.com/apache/airflow/pull/59430#discussion_r2660923594"
    },
    {
      "repo": "apache/airflow",
      "pr_number": 59430,
      "file_path": "airflow-core/src/airflow/utils/dag_stability_checker.py",
      "line": 64,
      "side": "RIGHT",
      "diff_hunk": "@@ -0,0 +1,510 @@\n+# Licensed to the Apache Software Foundation (ASF) under one\n+# or more contributor license agreements.  See the NOTICE file\n+# distributed with this work for additional information\n+# regarding copyright ownership.  The ASF licenses this file\n+# to you under the Apache License, Version 2.0 (the\n+# \"License\"); you may not use this file except in compliance\n+# with the License.  You may obtain a copy of the License at\n+#\n+#   http://www.apache.org/licenses/LICENSE-2.0\n+#\n+# Unless required by applicable law or agreed to in writing,\n+# software distributed under the License is distributed on an\n+# \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+# KIND, either express or implied.  See the License for the\n+# specific language governing permissions and limitations\n+# under the License.\n+from __future__ import annotations\n+\n+import ast\n+from dataclasses import dataclass\n+from enum import Enum\n+from pathlib import Path\n+\n+\n+class DagStabilityCheckerResult:\n+    \"\"\"\n+    Represents the result of stability analysis on a DAG file.\n+\n+    Stores detected warnings and formats them appropriately based on the configured check level\n+    (warning or error).\n+    \"\"\"\n+\n+    def __init__(self, check_level):\n+        self.check_level: str = check_level\n+        self.warnings: list[RuntimeVaryingValueWarning] = []\n+        self.runtime_varying_values: dict = {}\n+\n+    def format_warnings(self) -> str | None:\n+        \"\"\"Return formatted string of warning list.\"\"\"\n+        if not self.warnings:\n+            return None\n+\n+        lines = [\n+            \"\u26a0\ufe0f This Dag uses runtime-variable values in Dag construction.\",\n+            \"\u26a0\ufe0f It causes the Dag version to increase as values change on every Dag parse.\",\n+            \"\",\n+        ]\n+        for w in self.warnings:\n+            lines.append(f\"Line {w.line}, Col {w.col}\")\n+            lines.append(f\"Code: {w.code}\")\n+            lines.append(f\"Issue: {w.message}\")\n+            lines.append(\"\")\n+\n+        if self.runtime_varying_values:\n+            lines.append(\"\ufe0f\u26a0\ufe0f Don't use the variables as arguments in DAG/Task constructors:\")\n+            # Sort by line number\n+            sorted_vars = sorted(self.runtime_varying_values.items(), key=lambda x: x[1][0])\n+            for var_name, (line, source) in sorted_vars:\n+                lines.append(f\"  Line {line}: '{var_name}' related '{source}'\")\n+            lines.append(\"\")\n+\n+        return \"\\n\".join(lines)\n+\n+    def get_warning_dag_format_dict(self, dag_ids):",
      "comment": "```suggestion\n    def get_warning_dag_format_dict(self, dag_ids: list[str]) -> list[dict[str, Any]]:\n```\n\nor make the dict part a typed dict",
      "comment_id": 2660928124,
      "user": "Lee-W",
      "created_at": "2026-01-05T09:58:20Z",
      "url": "https://github.com/apache/airflow/pull/59430#discussion_r2660928124"
    },
    {
      "repo": "apache/airflow",
      "pr_number": 59430,
      "file_path": "airflow-core/src/airflow/utils/dag_stability_checker.py",
      "line": 104,
      "side": "RIGHT",
      "diff_hunk": "@@ -0,0 +1,468 @@\n+# Licensed to the Apache Software Foundation (ASF) under one\n+# or more contributor license agreements.  See the NOTICE file\n+# distributed with this work for additional information\n+# regarding copyright ownership.  The ASF licenses this file\n+# to you under the Apache License, Version 2.0 (the\n+# \"License\"); you may not use this file except in compliance\n+# with the License.  You may obtain a copy of the License at\n+#\n+#   http://www.apache.org/licenses/LICENSE-2.0\n+#\n+# Unless required by applicable law or agreed to in writing,\n+# software distributed under the License is distributed on an\n+# \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+# KIND, either express or implied.  See the License for the\n+# specific language governing permissions and limitations\n+# under the License.\n+from __future__ import annotations\n+\n+import ast\n+from dataclasses import dataclass\n+from enum import Enum\n+from pathlib import Path\n+\n+\n+@dataclass\n+class RuntimeVaryingValueWarning:\n+    \"\"\"Warning information for runtime-varying value detection.\"\"\"\n+\n+    line: int\n+    col: int\n+    code: str\n+    message: str\n+\n+\n+class WarningContext(str, Enum):\n+    \"\"\"Context types for warnings.\"\"\"\n+\n+    TASK_CONSTRUCTOR = \"Task constructor\"\n+    DAG_CONSTRUCTOR = \"Dag constructor\"\n+\n+\n+RUNTIME_VARYING_CALLS = [",
      "comment": "We can move this list to the top so that we can easily find where to extend",
      "comment_id": 2660935240,
      "user": "Lee-W",
      "created_at": "2026-01-05T10:00:11Z",
      "url": "https://github.com/apache/airflow/pull/59430#discussion_r2660935240"
    },
    {
      "repo": "apache/airflow",
      "pr_number": 59430,
      "file_path": "airflow-core/src/airflow/utils/dag_stability_checker.py",
      "line": 212,
      "side": "RIGHT",
      "diff_hunk": "@@ -0,0 +1,510 @@\n+# Licensed to the Apache Software Foundation (ASF) under one\n+# or more contributor license agreements.  See the NOTICE file\n+# distributed with this work for additional information\n+# regarding copyright ownership.  The ASF licenses this file\n+# to you under the Apache License, Version 2.0 (the\n+# \"License\"); you may not use this file except in compliance\n+# with the License.  You may obtain a copy of the License at\n+#\n+#   http://www.apache.org/licenses/LICENSE-2.0\n+#\n+# Unless required by applicable law or agreed to in writing,\n+# software distributed under the License is distributed on an\n+# \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+# KIND, either express or implied.  See the License for the\n+# specific language governing permissions and limitations\n+# under the License.\n+from __future__ import annotations\n+\n+import ast\n+from dataclasses import dataclass\n+from enum import Enum\n+from pathlib import Path\n+\n+\n+class DagStabilityCheckerResult:\n+    \"\"\"\n+    Represents the result of stability analysis on a DAG file.\n+\n+    Stores detected warnings and formats them appropriately based on the configured check level\n+    (warning or error).\n+    \"\"\"\n+\n+    def __init__(self, check_level):\n+        self.check_level: str = check_level\n+        self.warnings: list[RuntimeVaryingValueWarning] = []\n+        self.runtime_varying_values: dict = {}\n+\n+    def format_warnings(self) -> str | None:\n+        \"\"\"Return formatted string of warning list.\"\"\"\n+        if not self.warnings:\n+            return None\n+\n+        lines = [\n+            \"\u26a0\ufe0f This Dag uses runtime-variable values in Dag construction.\",\n+            \"\u26a0\ufe0f It causes the Dag version to increase as values change on every Dag parse.\",\n+            \"\",\n+        ]\n+        for w in self.warnings:\n+            lines.append(f\"Line {w.line}, Col {w.col}\")\n+            lines.append(f\"Code: {w.code}\")\n+            lines.append(f\"Issue: {w.message}\")\n+            lines.append(\"\")\n+\n+        if self.runtime_varying_values:\n+            lines.append(\"\ufe0f\u26a0\ufe0f Don't use the variables as arguments in DAG/Task constructors:\")\n+            # Sort by line number\n+            sorted_vars = sorted(self.runtime_varying_values.items(), key=lambda x: x[1][0])\n+            for var_name, (line, source) in sorted_vars:\n+                lines.append(f\"  Line {line}: '{var_name}' related '{source}'\")\n+            lines.append(\"\")\n+\n+        return \"\\n\".join(lines)\n+\n+    def get_warning_dag_format_dict(self, dag_ids):\n+        \"\"\"Convert warning statement to Dag warning format.\"\"\"\n+        from airflow.models.dagwarning import DagWarningType\n+\n+        if not self.warnings or self.check_level != \"warning\":\n+            return []\n+        return [\n+            {\n+                \"dag_id\": dag_id,\n+                \"warning_type\": DagWarningType.RUNTIME_VARYING_VALUE.value,\n+                \"message\": self.format_warnings(),\n+            }\n+            for dag_id in dag_ids\n+        ]\n+\n+    def get_error_format_dict(self, file_path, bundle_path):\n+        if not self.warnings or self.check_level != \"error\":\n+            return None\n+\n+        relative_file_path = str(Path(file_path).relative_to(bundle_path)) if bundle_path else file_path\n+        return {relative_file_path: self.format_warnings()}\n+\n+\n+@dataclass\n+class RuntimeVaryingValueWarning:\n+    \"\"\"Warning information for runtime-varying value detection.\"\"\"\n+\n+    line: int\n+    col: int\n+    code: str\n+    message: str\n+\n+\n+class WarningContext(str, Enum):\n+    \"\"\"Context types for warnings.\"\"\"\n+\n+    TASK_CONSTRUCTOR = \"Task constructor\"\n+    DAG_CONSTRUCTOR = \"Dag constructor\"\n+\n+\n+RUNTIME_VARYING_CALLS = [\n+    (\"datetime\", \"now\"),\n+    (\"datetime\", \"today\"),\n+    (\"datetime\", \"utcnow\"),\n+    (\"date\", \"today\"),\n+    (\"time\", \"time\"),\n+    (\"time\", \"localtime\"),\n+    (\"random\", \"random\"),\n+    (\"random\", \"randint\"),\n+    (\"random\", \"choice\"),\n+    (\"random\", \"uniform\"),\n+    (\"uuid\", \"uuid4\"),\n+    (\"uuid\", \"uuid1\"),\n+    (\"pendulum\", \"now\"),\n+    (\"pendulum\", \"today\"),\n+    (\"pendulum\", \"yesterday\"),\n+    (\"pendulum\", \"tomorrow\"),\n+]\n+\n+\n+class RuntimeVaryingValueAnalyzer:\n+    \"\"\"\n+    Analyzer dedicated to tracking and detecting runtime-varying values.\n+\n+    This analyzer is responsible for identifying if a given AST node\n+    contains values that change on every execution (datetime.now(), random(), etc.).\n+    \"\"\"\n+\n+    def __init__(self, varying_vars: dict, imports: dict, from_imports: dict):\n+        self.varying_vars = varying_vars\n+        self.imports = imports\n+        self.from_imports = from_imports\n+\n+    def get_varying_source(self, node: ast.expr) -> str | None:\n+        \"\"\"\n+        Check if an AST node contains runtime-varying values and return the source.\n+\n+        Checks:\n+        - Runtime-varying function calls (datetime.now(), etc.)\n+        - Runtime-varying variable references\n+        - Runtime-varying values in f-strings\n+        - Runtime-varying values in expressions/collections\n+        \"\"\"\n+        # 1. Direct runtime-varying call\n+        if isinstance(node, ast.Call) and self._is_runtime_varying_call(node):\n+            return ast.unparse(node)\n+\n+        # 2. Runtime-varying variable reference\n+        if isinstance(node, ast.Name) and node.id in self.varying_vars:\n+            _, source = self.varying_vars[node.id]\n+            return source\n+\n+        # 3. f-string\n+        if isinstance(node, ast.JoinedStr):\n+            return self._check_fstring_varying(node)\n+\n+        # 4. Binary operation\n+        if isinstance(node, ast.BinOp):\n+            return self.get_varying_source(node.left) or self.get_varying_source(node.right)\n+\n+        # 5. Collections (list/tuple/set)\n+        if isinstance(node, (ast.List, ast.Tuple, ast.Set)):\n+            return self._check_collection_varying(node.elts)\n+\n+        # 6. List comprehension\n+        if isinstance(node, ast.ListComp):\n+            return self.get_varying_source(node.elt)\n+\n+        # 7. Dictionary\n+        if isinstance(node, ast.Dict):\n+            return self._check_dict_varying(node)\n+\n+        # 8. Method call chain\n+        if isinstance(node, ast.Call) and isinstance(node.func, ast.Attribute):\n+            return self.get_varying_source(node.func.value)\n+\n+        return None\n+\n+    def _check_fstring_varying(self, node: ast.JoinedStr) -> str | None:\n+        \"\"\"Check for runtime-varying values inside f-strings.\"\"\"\n+        for value in node.values:\n+            if isinstance(value, ast.FormattedValue):\n+                source = self.get_varying_source(value.value)\n+                if source:\n+                    return source\n+        return None\n+\n+    def _check_collection_varying(self, elements: list) -> str | None:\n+        \"\"\"Check for runtime-varying values in collection elements.\"\"\"\n+        for elt in elements:\n+            source = self.get_varying_source(elt)\n+            if source:\n+                return source\n+        return None\n+\n+    def _check_dict_varying(self, node: ast.Dict) -> str | None:\n+        \"\"\"Check for runtime-varying values in dictionary keys/values.\"\"\"\n+        for key, value in zip(node.keys, node.values):\n+            if key:\n+                source = self.get_varying_source(key)\n+                if source:\n+                    return source\n+            if value:\n+                source = self.get_varying_source(value)\n+                if source:\n+                    return source\n+        return None\n+\n+    def _is_runtime_varying_call(self, node: ast.Call) -> bool:",
      "comment": "```suggestion\n    def is_runtime_varying_call(self, node: ast.Call) -> bool:\n```\n\nWhy do we need to make these methods private?",
      "comment_id": 2660947033,
      "user": "Lee-W",
      "created_at": "2026-01-05T10:03:34Z",
      "url": "https://github.com/apache/airflow/pull/59430#discussion_r2660947033"
    },
    {
      "repo": "apache/airflow",
      "pr_number": 59430,
      "file_path": "airflow-core/src/airflow/utils/dag_stability_checker.py",
      "line": 182,
      "side": "RIGHT",
      "diff_hunk": "@@ -0,0 +1,510 @@\n+# Licensed to the Apache Software Foundation (ASF) under one\n+# or more contributor license agreements.  See the NOTICE file\n+# distributed with this work for additional information\n+# regarding copyright ownership.  The ASF licenses this file\n+# to you under the Apache License, Version 2.0 (the\n+# \"License\"); you may not use this file except in compliance\n+# with the License.  You may obtain a copy of the License at\n+#\n+#   http://www.apache.org/licenses/LICENSE-2.0\n+#\n+# Unless required by applicable law or agreed to in writing,\n+# software distributed under the License is distributed on an\n+# \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+# KIND, either express or implied.  See the License for the\n+# specific language governing permissions and limitations\n+# under the License.\n+from __future__ import annotations\n+\n+import ast\n+from dataclasses import dataclass\n+from enum import Enum\n+from pathlib import Path\n+\n+\n+class DagStabilityCheckerResult:\n+    \"\"\"\n+    Represents the result of stability analysis on a DAG file.\n+\n+    Stores detected warnings and formats them appropriately based on the configured check level\n+    (warning or error).\n+    \"\"\"\n+\n+    def __init__(self, check_level):\n+        self.check_level: str = check_level\n+        self.warnings: list[RuntimeVaryingValueWarning] = []\n+        self.runtime_varying_values: dict = {}\n+\n+    def format_warnings(self) -> str | None:\n+        \"\"\"Return formatted string of warning list.\"\"\"\n+        if not self.warnings:\n+            return None\n+\n+        lines = [\n+            \"\u26a0\ufe0f This Dag uses runtime-variable values in Dag construction.\",\n+            \"\u26a0\ufe0f It causes the Dag version to increase as values change on every Dag parse.\",\n+            \"\",\n+        ]\n+        for w in self.warnings:\n+            lines.append(f\"Line {w.line}, Col {w.col}\")\n+            lines.append(f\"Code: {w.code}\")\n+            lines.append(f\"Issue: {w.message}\")\n+            lines.append(\"\")\n+\n+        if self.runtime_varying_values:\n+            lines.append(\"\ufe0f\u26a0\ufe0f Don't use the variables as arguments in DAG/Task constructors:\")\n+            # Sort by line number\n+            sorted_vars = sorted(self.runtime_varying_values.items(), key=lambda x: x[1][0])\n+            for var_name, (line, source) in sorted_vars:\n+                lines.append(f\"  Line {line}: '{var_name}' related '{source}'\")\n+            lines.append(\"\")\n+\n+        return \"\\n\".join(lines)\n+\n+    def get_warning_dag_format_dict(self, dag_ids):\n+        \"\"\"Convert warning statement to Dag warning format.\"\"\"\n+        from airflow.models.dagwarning import DagWarningType\n+\n+        if not self.warnings or self.check_level != \"warning\":\n+            return []\n+        return [\n+            {\n+                \"dag_id\": dag_id,\n+                \"warning_type\": DagWarningType.RUNTIME_VARYING_VALUE.value,\n+                \"message\": self.format_warnings(),\n+            }\n+            for dag_id in dag_ids\n+        ]\n+\n+    def get_error_format_dict(self, file_path, bundle_path):\n+        if not self.warnings or self.check_level != \"error\":\n+            return None\n+\n+        relative_file_path = str(Path(file_path).relative_to(bundle_path)) if bundle_path else file_path\n+        return {relative_file_path: self.format_warnings()}\n+\n+\n+@dataclass\n+class RuntimeVaryingValueWarning:\n+    \"\"\"Warning information for runtime-varying value detection.\"\"\"\n+\n+    line: int\n+    col: int\n+    code: str\n+    message: str\n+\n+\n+class WarningContext(str, Enum):\n+    \"\"\"Context types for warnings.\"\"\"\n+\n+    TASK_CONSTRUCTOR = \"Task constructor\"\n+    DAG_CONSTRUCTOR = \"Dag constructor\"\n+\n+\n+RUNTIME_VARYING_CALLS = [\n+    (\"datetime\", \"now\"),\n+    (\"datetime\", \"today\"),\n+    (\"datetime\", \"utcnow\"),\n+    (\"date\", \"today\"),\n+    (\"time\", \"time\"),\n+    (\"time\", \"localtime\"),\n+    (\"random\", \"random\"),\n+    (\"random\", \"randint\"),\n+    (\"random\", \"choice\"),\n+    (\"random\", \"uniform\"),\n+    (\"uuid\", \"uuid4\"),\n+    (\"uuid\", \"uuid1\"),\n+    (\"pendulum\", \"now\"),\n+    (\"pendulum\", \"today\"),\n+    (\"pendulum\", \"yesterday\"),\n+    (\"pendulum\", \"tomorrow\"),\n+]\n+\n+\n+class RuntimeVaryingValueAnalyzer:\n+    \"\"\"\n+    Analyzer dedicated to tracking and detecting runtime-varying values.\n+\n+    This analyzer is responsible for identifying if a given AST node\n+    contains values that change on every execution (datetime.now(), random(), etc.).\n+    \"\"\"\n+\n+    def __init__(self, varying_vars: dict, imports: dict, from_imports: dict):\n+        self.varying_vars = varying_vars\n+        self.imports = imports\n+        self.from_imports = from_imports\n+\n+    def get_varying_source(self, node: ast.expr) -> str | None:\n+        \"\"\"\n+        Check if an AST node contains runtime-varying values and return the source.\n+\n+        Checks:\n+        - Runtime-varying function calls (datetime.now(), etc.)\n+        - Runtime-varying variable references\n+        - Runtime-varying values in f-strings\n+        - Runtime-varying values in expressions/collections\n+        \"\"\"\n+        # 1. Direct runtime-varying call\n+        if isinstance(node, ast.Call) and self._is_runtime_varying_call(node):\n+            return ast.unparse(node)\n+\n+        # 2. Runtime-varying variable reference\n+        if isinstance(node, ast.Name) and node.id in self.varying_vars:\n+            _, source = self.varying_vars[node.id]\n+            return source\n+\n+        # 3. f-string\n+        if isinstance(node, ast.JoinedStr):\n+            return self._check_fstring_varying(node)\n+\n+        # 4. Binary operation\n+        if isinstance(node, ast.BinOp):\n+            return self.get_varying_source(node.left) or self.get_varying_source(node.right)\n+\n+        # 5. Collections (list/tuple/set)\n+        if isinstance(node, (ast.List, ast.Tuple, ast.Set)):\n+            return self._check_collection_varying(node.elts)\n+\n+        # 6. List comprehension\n+        if isinstance(node, ast.ListComp):\n+            return self.get_varying_source(node.elt)\n+\n+        # 7. Dictionary\n+        if isinstance(node, ast.Dict):\n+            return self._check_dict_varying(node)\n+\n+        # 8. Method call chain\n+        if isinstance(node, ast.Call) and isinstance(node.func, ast.Attribute):\n+            return self.get_varying_source(node.func.value)\n+\n+        return None\n+\n+    def _check_fstring_varying(self, node: ast.JoinedStr) -> str | None:",
      "comment": "If we name the first method as `get_varing_source`, should this be named as something like `get_varing_fstring` instead?",
      "comment_id": 2660955079,
      "user": "Lee-W",
      "created_at": "2026-01-05T10:06:31Z",
      "url": "https://github.com/apache/airflow/pull/59430#discussion_r2660955079"
    },
    {
      "repo": "apache/airflow",
      "pr_number": 59430,
      "file_path": "airflow-core/src/airflow/utils/dag_stability_checker.py",
      "line": 187,
      "side": "RIGHT",
      "diff_hunk": "@@ -0,0 +1,510 @@\n+# Licensed to the Apache Software Foundation (ASF) under one\n+# or more contributor license agreements.  See the NOTICE file\n+# distributed with this work for additional information\n+# regarding copyright ownership.  The ASF licenses this file\n+# to you under the Apache License, Version 2.0 (the\n+# \"License\"); you may not use this file except in compliance\n+# with the License.  You may obtain a copy of the License at\n+#\n+#   http://www.apache.org/licenses/LICENSE-2.0\n+#\n+# Unless required by applicable law or agreed to in writing,\n+# software distributed under the License is distributed on an\n+# \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+# KIND, either express or implied.  See the License for the\n+# specific language governing permissions and limitations\n+# under the License.\n+from __future__ import annotations\n+\n+import ast\n+from dataclasses import dataclass\n+from enum import Enum\n+from pathlib import Path\n+\n+\n+class DagStabilityCheckerResult:\n+    \"\"\"\n+    Represents the result of stability analysis on a DAG file.\n+\n+    Stores detected warnings and formats them appropriately based on the configured check level\n+    (warning or error).\n+    \"\"\"\n+\n+    def __init__(self, check_level):\n+        self.check_level: str = check_level\n+        self.warnings: list[RuntimeVaryingValueWarning] = []\n+        self.runtime_varying_values: dict = {}\n+\n+    def format_warnings(self) -> str | None:\n+        \"\"\"Return formatted string of warning list.\"\"\"\n+        if not self.warnings:\n+            return None\n+\n+        lines = [\n+            \"\u26a0\ufe0f This Dag uses runtime-variable values in Dag construction.\",\n+            \"\u26a0\ufe0f It causes the Dag version to increase as values change on every Dag parse.\",\n+            \"\",\n+        ]\n+        for w in self.warnings:\n+            lines.append(f\"Line {w.line}, Col {w.col}\")\n+            lines.append(f\"Code: {w.code}\")\n+            lines.append(f\"Issue: {w.message}\")\n+            lines.append(\"\")\n+\n+        if self.runtime_varying_values:\n+            lines.append(\"\ufe0f\u26a0\ufe0f Don't use the variables as arguments in DAG/Task constructors:\")\n+            # Sort by line number\n+            sorted_vars = sorted(self.runtime_varying_values.items(), key=lambda x: x[1][0])\n+            for var_name, (line, source) in sorted_vars:\n+                lines.append(f\"  Line {line}: '{var_name}' related '{source}'\")\n+            lines.append(\"\")\n+\n+        return \"\\n\".join(lines)\n+\n+    def get_warning_dag_format_dict(self, dag_ids):\n+        \"\"\"Convert warning statement to Dag warning format.\"\"\"\n+        from airflow.models.dagwarning import DagWarningType\n+\n+        if not self.warnings or self.check_level != \"warning\":\n+            return []\n+        return [\n+            {\n+                \"dag_id\": dag_id,\n+                \"warning_type\": DagWarningType.RUNTIME_VARYING_VALUE.value,\n+                \"message\": self.format_warnings(),\n+            }\n+            for dag_id in dag_ids\n+        ]\n+\n+    def get_error_format_dict(self, file_path, bundle_path):\n+        if not self.warnings or self.check_level != \"error\":\n+            return None\n+\n+        relative_file_path = str(Path(file_path).relative_to(bundle_path)) if bundle_path else file_path\n+        return {relative_file_path: self.format_warnings()}\n+\n+\n+@dataclass\n+class RuntimeVaryingValueWarning:\n+    \"\"\"Warning information for runtime-varying value detection.\"\"\"\n+\n+    line: int\n+    col: int\n+    code: str\n+    message: str\n+\n+\n+class WarningContext(str, Enum):\n+    \"\"\"Context types for warnings.\"\"\"\n+\n+    TASK_CONSTRUCTOR = \"Task constructor\"\n+    DAG_CONSTRUCTOR = \"Dag constructor\"\n+\n+\n+RUNTIME_VARYING_CALLS = [\n+    (\"datetime\", \"now\"),\n+    (\"datetime\", \"today\"),\n+    (\"datetime\", \"utcnow\"),\n+    (\"date\", \"today\"),\n+    (\"time\", \"time\"),\n+    (\"time\", \"localtime\"),\n+    (\"random\", \"random\"),\n+    (\"random\", \"randint\"),\n+    (\"random\", \"choice\"),\n+    (\"random\", \"uniform\"),\n+    (\"uuid\", \"uuid4\"),\n+    (\"uuid\", \"uuid1\"),\n+    (\"pendulum\", \"now\"),\n+    (\"pendulum\", \"today\"),\n+    (\"pendulum\", \"yesterday\"),\n+    (\"pendulum\", \"tomorrow\"),\n+]\n+\n+\n+class RuntimeVaryingValueAnalyzer:\n+    \"\"\"\n+    Analyzer dedicated to tracking and detecting runtime-varying values.\n+\n+    This analyzer is responsible for identifying if a given AST node\n+    contains values that change on every execution (datetime.now(), random(), etc.).\n+    \"\"\"\n+\n+    def __init__(self, varying_vars: dict, imports: dict, from_imports: dict):\n+        self.varying_vars = varying_vars\n+        self.imports = imports\n+        self.from_imports = from_imports\n+\n+    def get_varying_source(self, node: ast.expr) -> str | None:\n+        \"\"\"\n+        Check if an AST node contains runtime-varying values and return the source.\n+\n+        Checks:\n+        - Runtime-varying function calls (datetime.now(), etc.)\n+        - Runtime-varying variable references\n+        - Runtime-varying values in f-strings\n+        - Runtime-varying values in expressions/collections\n+        \"\"\"\n+        # 1. Direct runtime-varying call\n+        if isinstance(node, ast.Call) and self._is_runtime_varying_call(node):\n+            return ast.unparse(node)\n+\n+        # 2. Runtime-varying variable reference\n+        if isinstance(node, ast.Name) and node.id in self.varying_vars:\n+            _, source = self.varying_vars[node.id]\n+            return source\n+\n+        # 3. f-string\n+        if isinstance(node, ast.JoinedStr):\n+            return self._check_fstring_varying(node)\n+\n+        # 4. Binary operation\n+        if isinstance(node, ast.BinOp):\n+            return self.get_varying_source(node.left) or self.get_varying_source(node.right)\n+\n+        # 5. Collections (list/tuple/set)\n+        if isinstance(node, (ast.List, ast.Tuple, ast.Set)):\n+            return self._check_collection_varying(node.elts)\n+\n+        # 6. List comprehension\n+        if isinstance(node, ast.ListComp):\n+            return self.get_varying_source(node.elt)\n+\n+        # 7. Dictionary\n+        if isinstance(node, ast.Dict):\n+            return self._check_dict_varying(node)\n+\n+        # 8. Method call chain\n+        if isinstance(node, ast.Call) and isinstance(node.func, ast.Attribute):\n+            return self.get_varying_source(node.func.value)\n+\n+        return None\n+\n+    def _check_fstring_varying(self, node: ast.JoinedStr) -> str | None:\n+        \"\"\"Check for runtime-varying values inside f-strings.\"\"\"\n+        for value in node.values:\n+            if isinstance(value, ast.FormattedValue):\n+                source = self.get_varying_source(value.value)\n+                if source:",
      "comment": "```suggestion\n                if source := self.get_varying_source(value.value):\n```",
      "comment_id": 2660958851,
      "user": "Lee-W",
      "created_at": "2026-01-05T10:07:48Z",
      "url": "https://github.com/apache/airflow/pull/59430#discussion_r2660958851"
    },
    {
      "repo": "apache/airflow",
      "pr_number": 59430,
      "file_path": "airflow-core/src/airflow/utils/dag_stability_checker.py",
      "line": 342,
      "side": "RIGHT",
      "diff_hunk": "@@ -0,0 +1,510 @@\n+# Licensed to the Apache Software Foundation (ASF) under one\n+# or more contributor license agreements.  See the NOTICE file\n+# distributed with this work for additional information\n+# regarding copyright ownership.  The ASF licenses this file\n+# to you under the Apache License, Version 2.0 (the\n+# \"License\"); you may not use this file except in compliance\n+# with the License.  You may obtain a copy of the License at\n+#\n+#   http://www.apache.org/licenses/LICENSE-2.0\n+#\n+# Unless required by applicable law or agreed to in writing,\n+# software distributed under the License is distributed on an\n+# \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+# KIND, either express or implied.  See the License for the\n+# specific language governing permissions and limitations\n+# under the License.\n+from __future__ import annotations\n+\n+import ast\n+from dataclasses import dataclass\n+from enum import Enum\n+from pathlib import Path\n+\n+\n+class DagStabilityCheckerResult:\n+    \"\"\"\n+    Represents the result of stability analysis on a DAG file.\n+\n+    Stores detected warnings and formats them appropriately based on the configured check level\n+    (warning or error).\n+    \"\"\"\n+\n+    def __init__(self, check_level):\n+        self.check_level: str = check_level\n+        self.warnings: list[RuntimeVaryingValueWarning] = []\n+        self.runtime_varying_values: dict = {}\n+\n+    def format_warnings(self) -> str | None:\n+        \"\"\"Return formatted string of warning list.\"\"\"\n+        if not self.warnings:\n+            return None\n+\n+        lines = [\n+            \"\u26a0\ufe0f This Dag uses runtime-variable values in Dag construction.\",\n+            \"\u26a0\ufe0f It causes the Dag version to increase as values change on every Dag parse.\",\n+            \"\",\n+        ]\n+        for w in self.warnings:\n+            lines.append(f\"Line {w.line}, Col {w.col}\")\n+            lines.append(f\"Code: {w.code}\")\n+            lines.append(f\"Issue: {w.message}\")\n+            lines.append(\"\")\n+\n+        if self.runtime_varying_values:\n+            lines.append(\"\ufe0f\u26a0\ufe0f Don't use the variables as arguments in DAG/Task constructors:\")\n+            # Sort by line number\n+            sorted_vars = sorted(self.runtime_varying_values.items(), key=lambda x: x[1][0])\n+            for var_name, (line, source) in sorted_vars:\n+                lines.append(f\"  Line {line}: '{var_name}' related '{source}'\")\n+            lines.append(\"\")\n+\n+        return \"\\n\".join(lines)\n+\n+    def get_warning_dag_format_dict(self, dag_ids):\n+        \"\"\"Convert warning statement to Dag warning format.\"\"\"\n+        from airflow.models.dagwarning import DagWarningType\n+\n+        if not self.warnings or self.check_level != \"warning\":\n+            return []\n+        return [\n+            {\n+                \"dag_id\": dag_id,\n+                \"warning_type\": DagWarningType.RUNTIME_VARYING_VALUE.value,\n+                \"message\": self.format_warnings(),\n+            }\n+            for dag_id in dag_ids\n+        ]\n+\n+    def get_error_format_dict(self, file_path, bundle_path):\n+        if not self.warnings or self.check_level != \"error\":\n+            return None\n+\n+        relative_file_path = str(Path(file_path).relative_to(bundle_path)) if bundle_path else file_path\n+        return {relative_file_path: self.format_warnings()}\n+\n+\n+@dataclass\n+class RuntimeVaryingValueWarning:\n+    \"\"\"Warning information for runtime-varying value detection.\"\"\"\n+\n+    line: int\n+    col: int\n+    code: str\n+    message: str\n+\n+\n+class WarningContext(str, Enum):\n+    \"\"\"Context types for warnings.\"\"\"\n+\n+    TASK_CONSTRUCTOR = \"Task constructor\"\n+    DAG_CONSTRUCTOR = \"Dag constructor\"\n+\n+\n+RUNTIME_VARYING_CALLS = [\n+    (\"datetime\", \"now\"),\n+    (\"datetime\", \"today\"),\n+    (\"datetime\", \"utcnow\"),\n+    (\"date\", \"today\"),\n+    (\"time\", \"time\"),\n+    (\"time\", \"localtime\"),\n+    (\"random\", \"random\"),\n+    (\"random\", \"randint\"),\n+    (\"random\", \"choice\"),\n+    (\"random\", \"uniform\"),\n+    (\"uuid\", \"uuid4\"),\n+    (\"uuid\", \"uuid1\"),\n+    (\"pendulum\", \"now\"),\n+    (\"pendulum\", \"today\"),\n+    (\"pendulum\", \"yesterday\"),\n+    (\"pendulum\", \"tomorrow\"),\n+]\n+\n+\n+class RuntimeVaryingValueAnalyzer:\n+    \"\"\"\n+    Analyzer dedicated to tracking and detecting runtime-varying values.\n+\n+    This analyzer is responsible for identifying if a given AST node\n+    contains values that change on every execution (datetime.now(), random(), etc.).\n+    \"\"\"\n+\n+    def __init__(self, varying_vars: dict, imports: dict, from_imports: dict):\n+        self.varying_vars = varying_vars\n+        self.imports = imports\n+        self.from_imports = from_imports\n+\n+    def get_varying_source(self, node: ast.expr) -> str | None:\n+        \"\"\"\n+        Check if an AST node contains runtime-varying values and return the source.\n+\n+        Checks:\n+        - Runtime-varying function calls (datetime.now(), etc.)\n+        - Runtime-varying variable references\n+        - Runtime-varying values in f-strings\n+        - Runtime-varying values in expressions/collections\n+        \"\"\"\n+        # 1. Direct runtime-varying call\n+        if isinstance(node, ast.Call) and self._is_runtime_varying_call(node):\n+            return ast.unparse(node)\n+\n+        # 2. Runtime-varying variable reference\n+        if isinstance(node, ast.Name) and node.id in self.varying_vars:\n+            _, source = self.varying_vars[node.id]\n+            return source\n+\n+        # 3. f-string\n+        if isinstance(node, ast.JoinedStr):\n+            return self._check_fstring_varying(node)\n+\n+        # 4. Binary operation\n+        if isinstance(node, ast.BinOp):\n+            return self.get_varying_source(node.left) or self.get_varying_source(node.right)\n+\n+        # 5. Collections (list/tuple/set)\n+        if isinstance(node, (ast.List, ast.Tuple, ast.Set)):\n+            return self._check_collection_varying(node.elts)\n+\n+        # 6. List comprehension\n+        if isinstance(node, ast.ListComp):\n+            return self.get_varying_source(node.elt)\n+\n+        # 7. Dictionary\n+        if isinstance(node, ast.Dict):\n+            return self._check_dict_varying(node)\n+\n+        # 8. Method call chain\n+        if isinstance(node, ast.Call) and isinstance(node.func, ast.Attribute):\n+            return self.get_varying_source(node.func.value)\n+\n+        return None\n+\n+    def _check_fstring_varying(self, node: ast.JoinedStr) -> str | None:\n+        \"\"\"Check for runtime-varying values inside f-strings.\"\"\"\n+        for value in node.values:\n+            if isinstance(value, ast.FormattedValue):\n+                source = self.get_varying_source(value.value)\n+                if source:\n+                    return source\n+        return None\n+\n+    def _check_collection_varying(self, elements: list) -> str | None:\n+        \"\"\"Check for runtime-varying values in collection elements.\"\"\"\n+        for elt in elements:\n+            source = self.get_varying_source(elt)\n+            if source:\n+                return source\n+        return None\n+\n+    def _check_dict_varying(self, node: ast.Dict) -> str | None:\n+        \"\"\"Check for runtime-varying values in dictionary keys/values.\"\"\"\n+        for key, value in zip(node.keys, node.values):\n+            if key:\n+                source = self.get_varying_source(key)\n+                if source:\n+                    return source\n+            if value:\n+                source = self.get_varying_source(value)\n+                if source:\n+                    return source\n+        return None\n+\n+    def _is_runtime_varying_call(self, node: ast.Call) -> bool:\n+        \"\"\"\n+        Check if a call is runtime-varying.\n+\n+        1. Is the function itself runtime-varying?\n+        2. Do the arguments contain runtime-varying values?\n+        \"\"\"\n+        # Check if the function itself is runtime-varying\n+        if isinstance(node.func, ast.Attribute):\n+            if self._is_runtime_varying_attribute_call(node.func):\n+                return True\n+        elif isinstance(node.func, ast.Name):\n+            if self._is_runtime_varying_name_call(node.func):\n+                return True\n+\n+        # Check if arguments contain runtime-varying values\n+        return self._has_varying_arguments(node)\n+\n+    def _has_varying_arguments(self, node: ast.Call) -> bool:\n+        \"\"\"Check if function arguments contain runtime-varying values.\"\"\"\n+        for arg in node.args:\n+            if self.get_varying_source(arg):\n+                return True\n+\n+        for kw in node.keywords:\n+            if self.get_varying_source(kw.value):\n+                return True\n+\n+        return False\n+\n+    def _is_runtime_varying_attribute_call(self, attr: ast.Attribute) -> bool:\n+        \"\"\"Check for runtime-varying calls like datetime.now().\"\"\"\n+        method_name = attr.attr\n+\n+        if isinstance(attr.value, ast.Name):\n+            module_or_alias = attr.value.id\n+            actual_module = self.imports.get(module_or_alias, module_or_alias)\n+\n+            # If imported via \"from import\"\n+            if module_or_alias in self.from_imports:\n+                _, original_name = self.from_imports[module_or_alias]\n+                actual_module = original_name\n+\n+            return (actual_module, method_name) in RUNTIME_VARYING_CALLS\n+\n+        # Nested attribute (e.g., datetime.datetime.now)\n+        if isinstance(attr.value, ast.Attribute):\n+            inner_attr = attr.value\n+            if isinstance(inner_attr.value, ast.Name):\n+                return (inner_attr.attr, method_name) in RUNTIME_VARYING_CALLS\n+\n+        return False\n+\n+    def _is_runtime_varying_name_call(self, func: ast.Name) -> bool:\n+        \"\"\"Check for runtime-varying calls like now() (when imported via 'from import').\"\"\"\n+        func_name = func.id\n+\n+        if func_name in self.from_imports:\n+            module, original_name = self.from_imports[func_name]\n+            module_parts = module.split(\".\")\n+\n+            for part in module_parts:\n+                if (part, original_name) in RUNTIME_VARYING_CALLS:\n+                    return True\n+\n+        return False\n+\n+\n+class DagTaskDetector:\n+    \"\"\"\n+    Detector dedicated to identifying Dag and Task constructors.\n+\n+    This detector identifies when code is creating Dag or Task objects\n+    in Airflow. It needs to handle both traditional class instantiation and decorator styles.\n+    \"\"\"\n+\n+    def __init__(self, from_imports: dict):\n+        self.from_imports = from_imports\n+        self.dag_instances: set[str] = set()\n+        self.is_in_dag_context: bool = False\n+\n+    def is_dag_constructor(self, node: ast.Call) -> bool:\n+        \"\"\"Check if a call is a DAG constructor.\"\"\"\n+        if not isinstance(node.func, ast.Name):\n+            return False\n+\n+        func_name = node.func.id\n+\n+        # \"from airflow import DAG\" form or \"from airflow.decorator import dag\"\n+        if func_name in self.from_imports:\n+            module, original = self.from_imports[func_name]\n+            if (module == \"airflow\" or module.startswith(\"airflow.\")) and original in (\"DAG\", \"dag\"):\n+                return True\n+\n+        return False\n+\n+    def is_task_constructor(self, node: ast.Call) -> bool:\n+        \"\"\"\n+        Check if a call is a Task constructor.\n+\n+        Criteria:\n+        1. All calls within a DAG with block\n+        2. Calls that receive a DAG instance as an argument (dag=...)\n+        \"\"\"\n+        # Inside DAG with block\n+        if self.is_in_dag_context:\n+            return True\n+\n+        # Passing DAG instance as argument\n+        for arg in node.args:\n+            if isinstance(arg, ast.Name) and arg.id in self.dag_instances:\n+                return True\n+\n+        for keyword in node.keywords:\n+            if keyword.value and isinstance(keyword.value, ast.Name):\n+                if keyword.value.id in self.dag_instances:\n+                    return True\n+\n+        return False\n+\n+    def register_dag_instance(self, var_name: str):\n+        \"\"\"Register a DAG instance variable name.\"\"\"\n+        self.dag_instances.add(var_name)\n+\n+    def enter_dag_context(self):\n+        \"\"\"Enter a DAG with block.\"\"\"\n+        self.is_in_dag_context = True\n+\n+    def exit_dag_context(self):\n+        \"\"\"Exit a DAG with block.\"\"\"\n+        self.is_in_dag_context = False",
      "comment": "```suggestion\n        \"\"\"Register a Dag instance variable name.\"\"\"\n        self.dag_instances.add(var_name)\n\n    def enter_dag_context(self):\n        \"\"\"Enter a Dag with block.\"\"\"\n        self.is_in_dag_context = True\n\n    def exit_dag_context(self):\n        \"\"\"Exit a Dag with block.\"\"\"\n        self.is_in_dag_context = False\n```",
      "comment_id": 2660973344,
      "user": "Lee-W",
      "created_at": "2026-01-05T10:12:27Z",
      "url": "https://github.com/apache/airflow/pull/59430#discussion_r2660973344"
    },
    {
      "repo": "apache/airflow",
      "pr_number": 59430,
      "file_path": "airflow-core/src/airflow/utils/dag_stability_checker.py",
      "line": 347,
      "side": "RIGHT",
      "diff_hunk": "@@ -0,0 +1,510 @@\n+# Licensed to the Apache Software Foundation (ASF) under one\n+# or more contributor license agreements.  See the NOTICE file\n+# distributed with this work for additional information\n+# regarding copyright ownership.  The ASF licenses this file\n+# to you under the Apache License, Version 2.0 (the\n+# \"License\"); you may not use this file except in compliance\n+# with the License.  You may obtain a copy of the License at\n+#\n+#   http://www.apache.org/licenses/LICENSE-2.0\n+#\n+# Unless required by applicable law or agreed to in writing,\n+# software distributed under the License is distributed on an\n+# \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+# KIND, either express or implied.  See the License for the\n+# specific language governing permissions and limitations\n+# under the License.\n+from __future__ import annotations\n+\n+import ast\n+from dataclasses import dataclass\n+from enum import Enum\n+from pathlib import Path\n+\n+\n+class DagStabilityCheckerResult:\n+    \"\"\"\n+    Represents the result of stability analysis on a DAG file.\n+\n+    Stores detected warnings and formats them appropriately based on the configured check level\n+    (warning or error).\n+    \"\"\"\n+\n+    def __init__(self, check_level):\n+        self.check_level: str = check_level\n+        self.warnings: list[RuntimeVaryingValueWarning] = []\n+        self.runtime_varying_values: dict = {}\n+\n+    def format_warnings(self) -> str | None:\n+        \"\"\"Return formatted string of warning list.\"\"\"\n+        if not self.warnings:\n+            return None\n+\n+        lines = [\n+            \"\u26a0\ufe0f This Dag uses runtime-variable values in Dag construction.\",\n+            \"\u26a0\ufe0f It causes the Dag version to increase as values change on every Dag parse.\",\n+            \"\",\n+        ]\n+        for w in self.warnings:\n+            lines.append(f\"Line {w.line}, Col {w.col}\")\n+            lines.append(f\"Code: {w.code}\")\n+            lines.append(f\"Issue: {w.message}\")\n+            lines.append(\"\")\n+\n+        if self.runtime_varying_values:\n+            lines.append(\"\ufe0f\u26a0\ufe0f Don't use the variables as arguments in DAG/Task constructors:\")\n+            # Sort by line number\n+            sorted_vars = sorted(self.runtime_varying_values.items(), key=lambda x: x[1][0])\n+            for var_name, (line, source) in sorted_vars:\n+                lines.append(f\"  Line {line}: '{var_name}' related '{source}'\")\n+            lines.append(\"\")\n+\n+        return \"\\n\".join(lines)\n+\n+    def get_warning_dag_format_dict(self, dag_ids):\n+        \"\"\"Convert warning statement to Dag warning format.\"\"\"\n+        from airflow.models.dagwarning import DagWarningType\n+\n+        if not self.warnings or self.check_level != \"warning\":\n+            return []\n+        return [\n+            {\n+                \"dag_id\": dag_id,\n+                \"warning_type\": DagWarningType.RUNTIME_VARYING_VALUE.value,\n+                \"message\": self.format_warnings(),\n+            }\n+            for dag_id in dag_ids\n+        ]\n+\n+    def get_error_format_dict(self, file_path, bundle_path):\n+        if not self.warnings or self.check_level != \"error\":\n+            return None\n+\n+        relative_file_path = str(Path(file_path).relative_to(bundle_path)) if bundle_path else file_path\n+        return {relative_file_path: self.format_warnings()}\n+\n+\n+@dataclass\n+class RuntimeVaryingValueWarning:\n+    \"\"\"Warning information for runtime-varying value detection.\"\"\"\n+\n+    line: int\n+    col: int\n+    code: str\n+    message: str\n+\n+\n+class WarningContext(str, Enum):\n+    \"\"\"Context types for warnings.\"\"\"\n+\n+    TASK_CONSTRUCTOR = \"Task constructor\"\n+    DAG_CONSTRUCTOR = \"Dag constructor\"\n+\n+\n+RUNTIME_VARYING_CALLS = [\n+    (\"datetime\", \"now\"),\n+    (\"datetime\", \"today\"),\n+    (\"datetime\", \"utcnow\"),\n+    (\"date\", \"today\"),\n+    (\"time\", \"time\"),\n+    (\"time\", \"localtime\"),\n+    (\"random\", \"random\"),\n+    (\"random\", \"randint\"),\n+    (\"random\", \"choice\"),\n+    (\"random\", \"uniform\"),\n+    (\"uuid\", \"uuid4\"),\n+    (\"uuid\", \"uuid1\"),\n+    (\"pendulum\", \"now\"),\n+    (\"pendulum\", \"today\"),\n+    (\"pendulum\", \"yesterday\"),\n+    (\"pendulum\", \"tomorrow\"),\n+]\n+\n+\n+class RuntimeVaryingValueAnalyzer:\n+    \"\"\"\n+    Analyzer dedicated to tracking and detecting runtime-varying values.\n+\n+    This analyzer is responsible for identifying if a given AST node\n+    contains values that change on every execution (datetime.now(), random(), etc.).\n+    \"\"\"\n+\n+    def __init__(self, varying_vars: dict, imports: dict, from_imports: dict):\n+        self.varying_vars = varying_vars\n+        self.imports = imports\n+        self.from_imports = from_imports\n+\n+    def get_varying_source(self, node: ast.expr) -> str | None:\n+        \"\"\"\n+        Check if an AST node contains runtime-varying values and return the source.\n+\n+        Checks:\n+        - Runtime-varying function calls (datetime.now(), etc.)\n+        - Runtime-varying variable references\n+        - Runtime-varying values in f-strings\n+        - Runtime-varying values in expressions/collections\n+        \"\"\"\n+        # 1. Direct runtime-varying call\n+        if isinstance(node, ast.Call) and self._is_runtime_varying_call(node):\n+            return ast.unparse(node)\n+\n+        # 2. Runtime-varying variable reference\n+        if isinstance(node, ast.Name) and node.id in self.varying_vars:\n+            _, source = self.varying_vars[node.id]\n+            return source\n+\n+        # 3. f-string\n+        if isinstance(node, ast.JoinedStr):\n+            return self._check_fstring_varying(node)\n+\n+        # 4. Binary operation\n+        if isinstance(node, ast.BinOp):\n+            return self.get_varying_source(node.left) or self.get_varying_source(node.right)\n+\n+        # 5. Collections (list/tuple/set)\n+        if isinstance(node, (ast.List, ast.Tuple, ast.Set)):\n+            return self._check_collection_varying(node.elts)\n+\n+        # 6. List comprehension\n+        if isinstance(node, ast.ListComp):\n+            return self.get_varying_source(node.elt)\n+\n+        # 7. Dictionary\n+        if isinstance(node, ast.Dict):\n+            return self._check_dict_varying(node)\n+\n+        # 8. Method call chain\n+        if isinstance(node, ast.Call) and isinstance(node.func, ast.Attribute):\n+            return self.get_varying_source(node.func.value)\n+\n+        return None\n+\n+    def _check_fstring_varying(self, node: ast.JoinedStr) -> str | None:\n+        \"\"\"Check for runtime-varying values inside f-strings.\"\"\"\n+        for value in node.values:\n+            if isinstance(value, ast.FormattedValue):\n+                source = self.get_varying_source(value.value)\n+                if source:\n+                    return source\n+        return None\n+\n+    def _check_collection_varying(self, elements: list) -> str | None:\n+        \"\"\"Check for runtime-varying values in collection elements.\"\"\"\n+        for elt in elements:\n+            source = self.get_varying_source(elt)\n+            if source:\n+                return source\n+        return None\n+\n+    def _check_dict_varying(self, node: ast.Dict) -> str | None:\n+        \"\"\"Check for runtime-varying values in dictionary keys/values.\"\"\"\n+        for key, value in zip(node.keys, node.values):\n+            if key:\n+                source = self.get_varying_source(key)\n+                if source:\n+                    return source\n+            if value:\n+                source = self.get_varying_source(value)\n+                if source:\n+                    return source\n+        return None\n+\n+    def _is_runtime_varying_call(self, node: ast.Call) -> bool:\n+        \"\"\"\n+        Check if a call is runtime-varying.\n+\n+        1. Is the function itself runtime-varying?\n+        2. Do the arguments contain runtime-varying values?\n+        \"\"\"\n+        # Check if the function itself is runtime-varying\n+        if isinstance(node.func, ast.Attribute):\n+            if self._is_runtime_varying_attribute_call(node.func):\n+                return True\n+        elif isinstance(node.func, ast.Name):\n+            if self._is_runtime_varying_name_call(node.func):\n+                return True\n+\n+        # Check if arguments contain runtime-varying values\n+        return self._has_varying_arguments(node)\n+\n+    def _has_varying_arguments(self, node: ast.Call) -> bool:\n+        \"\"\"Check if function arguments contain runtime-varying values.\"\"\"\n+        for arg in node.args:\n+            if self.get_varying_source(arg):\n+                return True\n+\n+        for kw in node.keywords:\n+            if self.get_varying_source(kw.value):\n+                return True\n+\n+        return False\n+\n+    def _is_runtime_varying_attribute_call(self, attr: ast.Attribute) -> bool:\n+        \"\"\"Check for runtime-varying calls like datetime.now().\"\"\"\n+        method_name = attr.attr\n+\n+        if isinstance(attr.value, ast.Name):\n+            module_or_alias = attr.value.id\n+            actual_module = self.imports.get(module_or_alias, module_or_alias)\n+\n+            # If imported via \"from import\"\n+            if module_or_alias in self.from_imports:\n+                _, original_name = self.from_imports[module_or_alias]\n+                actual_module = original_name\n+\n+            return (actual_module, method_name) in RUNTIME_VARYING_CALLS\n+\n+        # Nested attribute (e.g., datetime.datetime.now)\n+        if isinstance(attr.value, ast.Attribute):\n+            inner_attr = attr.value\n+            if isinstance(inner_attr.value, ast.Name):\n+                return (inner_attr.attr, method_name) in RUNTIME_VARYING_CALLS\n+\n+        return False\n+\n+    def _is_runtime_varying_name_call(self, func: ast.Name) -> bool:\n+        \"\"\"Check for runtime-varying calls like now() (when imported via 'from import').\"\"\"\n+        func_name = func.id\n+\n+        if func_name in self.from_imports:\n+            module, original_name = self.from_imports[func_name]\n+            module_parts = module.split(\".\")\n+\n+            for part in module_parts:\n+                if (part, original_name) in RUNTIME_VARYING_CALLS:\n+                    return True\n+\n+        return False\n+\n+\n+class DagTaskDetector:\n+    \"\"\"\n+    Detector dedicated to identifying Dag and Task constructors.\n+\n+    This detector identifies when code is creating Dag or Task objects\n+    in Airflow. It needs to handle both traditional class instantiation and decorator styles.\n+    \"\"\"\n+\n+    def __init__(self, from_imports: dict):\n+        self.from_imports = from_imports\n+        self.dag_instances: set[str] = set()\n+        self.is_in_dag_context: bool = False\n+\n+    def is_dag_constructor(self, node: ast.Call) -> bool:\n+        \"\"\"Check if a call is a DAG constructor.\"\"\"\n+        if not isinstance(node.func, ast.Name):\n+            return False\n+\n+        func_name = node.func.id\n+\n+        # \"from airflow import DAG\" form or \"from airflow.decorator import dag\"\n+        if func_name in self.from_imports:\n+            module, original = self.from_imports[func_name]\n+            if (module == \"airflow\" or module.startswith(\"airflow.\")) and original in (\"DAG\", \"dag\"):\n+                return True\n+\n+        return False\n+\n+    def is_task_constructor(self, node: ast.Call) -> bool:\n+        \"\"\"\n+        Check if a call is a Task constructor.\n+\n+        Criteria:\n+        1. All calls within a DAG with block\n+        2. Calls that receive a DAG instance as an argument (dag=...)\n+        \"\"\"\n+        # Inside DAG with block\n+        if self.is_in_dag_context:\n+            return True\n+\n+        # Passing DAG instance as argument\n+        for arg in node.args:\n+            if isinstance(arg, ast.Name) and arg.id in self.dag_instances:\n+                return True\n+\n+        for keyword in node.keywords:\n+            if keyword.value and isinstance(keyword.value, ast.Name):\n+                if keyword.value.id in self.dag_instances:\n+                    return True\n+\n+        return False\n+\n+    def register_dag_instance(self, var_name: str):\n+        \"\"\"Register a DAG instance variable name.\"\"\"\n+        self.dag_instances.add(var_name)\n+\n+    def enter_dag_context(self):\n+        \"\"\"Enter a DAG with block.\"\"\"\n+        self.is_in_dag_context = True\n+\n+    def exit_dag_context(self):\n+        \"\"\"Exit a DAG with block.\"\"\"\n+        self.is_in_dag_context = False\n+\n+\n+class AirflowRuntimeVaryingValueChecker(ast.NodeVisitor):\n+    \"\"\"\n+    Main visitor class to detect runtime-varying value usage in Airflow DAG/Task.",
      "comment": "```suggestion\n    Main visitor class to detect runtime-varying value usage in Airflow Dag/Task.\n```",
      "comment_id": 2660973841,
      "user": "Lee-W",
      "created_at": "2026-01-05T10:12:38Z",
      "url": "https://github.com/apache/airflow/pull/59430#discussion_r2660973841"
    },
    {
      "repo": "apache/airflow",
      "pr_number": 59430,
      "file_path": "airflow-core/src/airflow/utils/dag_stability_checker.py",
      "line": 520,
      "side": "RIGHT",
      "diff_hunk": "@@ -0,0 +1,533 @@\n+# Licensed to the Apache Software Foundation (ASF) under one\n+# or more contributor license agreements.  See the NOTICE file\n+# distributed with this work for additional information\n+# regarding copyright ownership.  The ASF licenses this file\n+# to you under the Apache License, Version 2.0 (the\n+# \"License\"); you may not use this file except in compliance\n+# with the License.  You may obtain a copy of the License at\n+#\n+#   http://www.apache.org/licenses/LICENSE-2.0\n+#\n+# Unless required by applicable law or agreed to in writing,\n+# software distributed under the License is distributed on an\n+# \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+# KIND, either express or implied.  See the License for the\n+# specific language governing permissions and limitations\n+# under the License.\n+from __future__ import annotations\n+\n+import ast\n+from dataclasses import dataclass\n+from enum import Enum\n+from pathlib import Path\n+\n+RUNTIME_VARYING_CALLS = [\n+    (\"datetime\", \"now\"),\n+    (\"datetime\", \"today\"),\n+    (\"datetime\", \"utcnow\"),\n+    (\"date\", \"today\"),\n+    (\"time\", \"time\"),\n+    (\"time\", \"localtime\"),\n+    (\"random\", \"random\"),\n+    (\"random\", \"randint\"),\n+    (\"random\", \"choice\"),\n+    (\"random\", \"uniform\"),\n+    (\"uuid\", \"uuid4\"),\n+    (\"uuid\", \"uuid1\"),\n+    (\"pendulum\", \"now\"),\n+    (\"pendulum\", \"today\"),\n+    (\"pendulum\", \"yesterday\"),\n+    (\"pendulum\", \"tomorrow\"),\n+]\n+\n+\n+class DagStabilityCheckLevel(Enum):\n+    \"\"\"enum class for Dag stability check level.\"\"\"\n+\n+    off = \"off\"\n+    warning = \"warning\"\n+    error = \"error\"\n+\n+\n+class DagStabilityCheckerResult:\n+    \"\"\"\n+    Represents the result of stability analysis on a Dag file.\n+\n+    Stores detected warnings and formats them appropriately based on the configured check level\n+    (warning or error).\n+    \"\"\"\n+\n+    def __init__(self, check_level: DagStabilityCheckLevel):\n+        self.check_level: DagStabilityCheckLevel = check_level\n+        self.warnings: list[RuntimeVaryingValueWarning] = []\n+        self.runtime_varying_values: dict = {}\n+\n+    def format_warnings(self) -> str | None:\n+        \"\"\"Return formatted string of warning list.\"\"\"\n+        if not self.warnings:\n+            return None\n+\n+        lines = [\n+            \"This Dag uses runtime-variable values in Dag construction.\",\n+            \"It causes the Dag version to increase as values change on every Dag parse.\",\n+            \"\",\n+        ]\n+        for w in self.warnings:\n+            lines.extend(\n+                [\n+                    f\"Line {w.line}, Col {w.col}\",\n+                    f\"Code: {w.code}\",\n+                    f\"Issue: {w.message}\",\n+                    \"\",\n+                ]\n+            )\n+\n+        if self.runtime_varying_values:\n+            lines.extend(\n+                [\n+                    \"\ufe0fDon't use the variables as arguments in Dag/Task constructors:\",\n+                    *(\n+                        f\"  Line {line}: '{var_name}' related '{source}'\"\n+                        for var_name, (line, source) in sorted(\n+                            self.runtime_varying_values.items(),\n+                            key=lambda x: x[1][0],\n+                        )\n+                    ),\n+                    \"\",\n+                ]\n+            )\n+\n+        return \"\\n\".join(lines)\n+\n+    def get_warning_dag_format_dict(self, dag_ids: list[str]) -> list[dict[str, str | None]]:\n+        \"\"\"Convert warning statement to Dag warning format.\"\"\"\n+        from airflow.models.dagwarning import DagWarningType\n+\n+        if not self.warnings or self.check_level != DagStabilityCheckLevel.warning:\n+            return []\n+        return [\n+            {\n+                \"dag_id\": dag_id,\n+                \"warning_type\": DagWarningType.RUNTIME_VARYING_VALUE.value,\n+                \"message\": self.format_warnings(),\n+            }\n+            for dag_id in dag_ids\n+        ]\n+\n+    def get_error_format_dict(self, file_path, bundle_path):\n+        if not self.warnings or self.check_level != DagStabilityCheckLevel.error:\n+            return None\n+\n+        relative_file_path = str(Path(file_path).relative_to(bundle_path)) if bundle_path else file_path\n+        return {relative_file_path: self.format_warnings()}\n+\n+\n+@dataclass\n+class RuntimeVaryingValueWarning:\n+    \"\"\"Warning information for runtime-varying value detection.\"\"\"\n+\n+    line: int\n+    col: int\n+    code: str\n+    message: str\n+\n+\n+class WarningContext(str, Enum):\n+    \"\"\"Context types for warnings.\"\"\"\n+\n+    TASK_CONSTRUCTOR = \"Task constructor\"\n+    DAG_CONSTRUCTOR = \"Dag constructor\"\n+\n+\n+class RuntimeVaryingValueAnalyzer:\n+    \"\"\"\n+    Analyzer dedicated to tracking and detecting runtime-varying values.\n+\n+    This analyzer is responsible for identifying if a given AST node\n+    contains values that change on every execution (datetime.now(), random(), etc.).\n+    \"\"\"\n+\n+    def __init__(\n+        self,\n+        varying_vars: dict[str, tuple[int, str]],\n+        imports: dict[str, str],\n+        from_imports: dict[str, tuple[str, str]],\n+    ):\n+        self.varying_vars = varying_vars\n+        self.imports = imports\n+        self.from_imports = from_imports\n+\n+    def get_varying_source(self, node: ast.expr) -> str | None:\n+        \"\"\"\n+        Check if an AST node contains runtime-varying values and return the source.\n+\n+        Checks:\n+        - Runtime-varying function calls (datetime.now(), etc.)\n+        - Runtime-varying variable references\n+        - Runtime-varying values in f-strings\n+        - Runtime-varying values in expressions/collections\n+        \"\"\"\n+        # 1. Direct runtime-varying call\n+        if isinstance(node, ast.Call) and self.is_runtime_varying_call(node):\n+            return ast.unparse(node)\n+\n+        # 2. Runtime-varying variable reference\n+        if isinstance(node, ast.Name) and node.id in self.varying_vars:\n+            _, source = self.varying_vars[node.id]\n+            return source\n+\n+        # 3. f-string\n+        if isinstance(node, ast.JoinedStr):\n+            return self.get_varying_fstring(node)\n+\n+        # 4. Binary operation\n+        if isinstance(node, ast.BinOp):\n+            return self.get_varying_source(node.left) or self.get_varying_source(node.right)\n+\n+        # 5. Collections (list/tuple/set)\n+        if isinstance(node, (ast.List, ast.Tuple, ast.Set)):\n+            return self.get_varying_collection(node.elts)\n+\n+        # 6. List comprehension\n+        if isinstance(node, ast.ListComp):\n+            return self.get_varying_source(node.elt)\n+\n+        # 7. Dictionary\n+        if isinstance(node, ast.Dict):\n+            return self.get_varying_dict(node)\n+\n+        # 8. Method call chain\n+        if isinstance(node, ast.Call) and isinstance(node.func, ast.Attribute):\n+            return self.get_varying_source(node.func.value)\n+\n+        return None\n+\n+    def get_varying_fstring(self, node: ast.JoinedStr) -> str | None:\n+        \"\"\"Check for runtime-varying values inside f-strings.\"\"\"\n+        for value in node.values:\n+            if isinstance(value, ast.FormattedValue):\n+                if source := self.get_varying_source(value.value):\n+                    return source\n+        return None\n+\n+    def get_varying_collection(self, elements: list) -> str | None:\n+        \"\"\"Check for runtime-varying values in collection elements.\"\"\"\n+        for elt in elements:\n+            source = self.get_varying_source(elt)\n+            if source:\n+                return source\n+        return None\n+\n+    def get_varying_dict(self, node: ast.Dict) -> str | None:\n+        \"\"\"Check for runtime-varying values in dictionary keys/values.\"\"\"\n+        for key, value in zip(node.keys, node.values):\n+            if key:\n+                source = self.get_varying_source(key)\n+                if source:\n+                    return source\n+            if value:\n+                source = self.get_varying_source(value)\n+                if source:\n+                    return source\n+        return None\n+\n+    def is_runtime_varying_call(self, node: ast.Call) -> bool:\n+        \"\"\"\n+        Check if a call is runtime-varying.\n+\n+        1. Is the function itself runtime-varying?\n+        2. Do the arguments contain runtime-varying values?\n+        \"\"\"\n+        # Check if the function itself is runtime-varying\n+        if isinstance(node.func, ast.Attribute):\n+            if self._is_runtime_varying_attribute_call(node.func):\n+                return True\n+        elif isinstance(node.func, ast.Name):\n+            if self._is_runtime_varying_name_call(node.func):\n+                return True\n+\n+        # Check if arguments contain runtime-varying values\n+        return self._has_varying_arguments(node)\n+\n+    def _has_varying_arguments(self, node: ast.Call) -> bool:\n+        \"\"\"Check if function arguments contain runtime-varying values.\"\"\"\n+        for arg in node.args:\n+            if self.get_varying_source(arg):\n+                return True\n+\n+        for kw in node.keywords:\n+            if self.get_varying_source(kw.value):\n+                return True\n+\n+        return False\n+\n+    def _is_runtime_varying_attribute_call(self, attr: ast.Attribute) -> bool:\n+        \"\"\"Check for runtime-varying calls like datetime.now().\"\"\"\n+        method_name = attr.attr\n+\n+        if isinstance(attr.value, ast.Name):\n+            module_or_alias = attr.value.id\n+            actual_module = self.imports.get(module_or_alias, module_or_alias)\n+\n+            # If imported via \"from import\"\n+            if module_or_alias in self.from_imports:\n+                _, original_name = self.from_imports[module_or_alias]\n+                actual_module = original_name\n+\n+            return (actual_module, method_name) in RUNTIME_VARYING_CALLS\n+\n+        # Nested attribute (e.g., datetime.datetime.now)\n+        if isinstance(attr.value, ast.Attribute):\n+            inner_attr = attr.value\n+            if isinstance(inner_attr.value, ast.Name):\n+                return (inner_attr.attr, method_name) in RUNTIME_VARYING_CALLS\n+\n+        return False\n+\n+    def _is_runtime_varying_name_call(self, func: ast.Name) -> bool:\n+        \"\"\"Check for runtime-varying calls like now() (when imported via 'from import').\"\"\"\n+        func_name = func.id\n+\n+        if func_name in self.from_imports:\n+            module, original_name = self.from_imports[func_name]\n+            module_parts = module.split(\".\")\n+\n+            for part in module_parts:\n+                if (part, original_name) in RUNTIME_VARYING_CALLS:\n+                    return True\n+\n+        return False\n+\n+\n+class DagTaskDetector:\n+    \"\"\"\n+    Detector dedicated to identifying Dag and Task constructors.\n+\n+    This detector identifies when code is creating Dag or Task objects\n+    in Airflow. It needs to handle both traditional class instantiation and decorator styles.\n+    \"\"\"\n+\n+    def __init__(self, from_imports: dict):\n+        self.from_imports = from_imports\n+        self.dag_instances: set[str] = set()\n+        self.is_in_dag_context: bool = False\n+\n+    def is_dag_constructor(self, node: ast.Call) -> bool:\n+        \"\"\"Check if a call is a Dag constructor.\"\"\"\n+        if not isinstance(node.func, ast.Name):\n+            return False\n+\n+        func_name = node.func.id\n+\n+        # \"from airflow import DAG\" form or \"from airflow.decorator import dag\"\n+        if func_name in self.from_imports:\n+            module, original = self.from_imports[func_name]\n+            if (module == \"airflow\" or module.startswith(\"airflow.\")) and original in (\"DAG\", \"dag\"):\n+                return True\n+\n+        return False\n+\n+    def is_task_constructor(self, node: ast.Call) -> bool:\n+        \"\"\"\n+        Check if a call is a Task constructor.\n+\n+        Criteria:\n+        1. All calls within a Dag with block\n+        2. Calls that receive a Dag instance as an argument (dag=...)\n+        \"\"\"\n+        # Inside Dag with block\n+        if self.is_in_dag_context:\n+            return True\n+\n+        # Passing Dag instance as argument\n+        for arg in node.args:\n+            if isinstance(arg, ast.Name) and arg.id in self.dag_instances:\n+                return True\n+\n+        for keyword in node.keywords:\n+            if keyword.value and isinstance(keyword.value, ast.Name):\n+                if keyword.value.id in self.dag_instances:\n+                    return True\n+\n+        return False\n+\n+    def register_dag_instance(self, var_name: str):\n+        \"\"\"Register a Dag instance variable name.\"\"\"\n+        self.dag_instances.add(var_name)\n+\n+    def enter_dag_context(self):\n+        \"\"\"Enter a Dag with block.\"\"\"\n+        self.is_in_dag_context = True\n+\n+    def exit_dag_context(self):\n+        \"\"\"Exit a Dag with block.\"\"\"\n+        self.is_in_dag_context = False\n+\n+\n+class AirflowRuntimeVaryingValueChecker(ast.NodeVisitor):\n+    \"\"\"\n+    Main visitor class to detect runtime-varying value usage in Airflow Dag/Task.\n+\n+    Main responsibilities:\n+    - Traverse AST and visit nodes\n+    - Detect Dag/Task creation\n+    - Track runtime-varying values and generate warnings\n+    \"\"\"\n+\n+    def __init__(self, check_level: DagStabilityCheckLevel = DagStabilityCheckLevel.warning):\n+        self.static_check_result: DagStabilityCheckerResult = DagStabilityCheckerResult(\n+            check_level=check_level\n+        )\n+        self.imports: dict[str, str] = {}\n+        self.from_imports: dict[str, tuple[str, str]] = {}\n+        self.varying_vars: dict[str, tuple[int, str]] = {}\n+        self.check_level = check_level\n+\n+        # Helper objects\n+        self.value_analyzer = RuntimeVaryingValueAnalyzer(self.varying_vars, self.imports, self.from_imports)\n+        self.dag_detector = DagTaskDetector(self.from_imports)\n+\n+    def visit_Import(self, node: ast.Import):\n+        \"\"\"Process import statements.\"\"\"\n+        for alias in node.names:\n+            name = alias.asname or alias.name\n+            self.imports[name] = alias.name\n+\n+    def visit_ImportFrom(self, node: ast.ImportFrom):\n+        \"\"\"Process from ... import statements.\"\"\"\n+        if node.module:\n+            for alias in node.names:\n+                name = alias.asname or alias.name\n+                self.from_imports[name] = (node.module, alias.name)\n+\n+    def visit_Assign(self, node: ast.Assign):\n+        \"\"\"\n+        Process variable assignments.\n+\n+        Checks:\n+        1. Dag instance assignment\n+        2. Task instance assignment\n+        3. Runtime-varying value assignment\n+        \"\"\"\n+        value = node.value\n+\n+        # Dag constructor\n+        if isinstance(value, ast.Call) and self.dag_detector.is_dag_constructor(value):\n+            self._register_dag_instances(node.targets)\n+            self._check_and_warn(value, WarningContext.DAG_CONSTRUCTOR)\n+\n+        # Task constructor\n+        elif isinstance(value, ast.Call) and self.dag_detector.is_task_constructor(value):\n+            self._check_and_warn(value, WarningContext.TASK_CONSTRUCTOR)\n+\n+        # Track runtime-varying values\n+        else:\n+            self._track_varying_assignment(node)\n+\n+    def visit_Call(self, node: ast.Call):\n+        \"\"\"\n+        Process function calls.\n+\n+        Check not assign but just call the function or Dag definition via decorator.\n+        \"\"\"\n+        if self.dag_detector.is_dag_constructor(node):\n+            self._check_and_warn(node, WarningContext.DAG_CONSTRUCTOR)\n+\n+        elif self.dag_detector.is_task_constructor(node):\n+            self._check_and_warn(node, WarningContext.TASK_CONSTRUCTOR)\n+\n+    def visit_For(self, node: ast.For):\n+        \"\"\"\n+        Process for statements.\n+\n+        Check if iteration target contains runtime-varying values.\n+        \"\"\"\n+        # check the iterator value is runtime-varying\n+        # iter is runtime-varying : for iter in [datetime.now(), 3]\n+        varying_source = self.value_analyzer.get_varying_source(node.iter)\n+        if varying_source:\n+            if isinstance(node.target, ast.Name):\n+                self.varying_vars[node.target.id] = (node.lineno, varying_source)\n+\n+        for body in node.body:\n+            self.visit(body)\n+\n+        if varying_source:\n+            if isinstance(node.target, ast.Name):\n+                self.varying_vars.pop(node.target.id)\n+\n+    def visit_With(self, node: ast.With):\n+        \"\"\"\n+        Process with statements.\n+\n+        Detect Dag context manager.\n+        \"\"\"\n+        is_with_dag_context = False\n+        for item in node.items:\n+            # check if the Dag instance exists in with context\n+            self.visit(item)\n+            if isinstance(item.context_expr, ast.Call):\n+                if self.dag_detector.is_dag_constructor(item.context_expr):\n+                    # check the value defined in with statement to detect entering Dag with block\n+                    is_with_dag_context = True\n+\n+        if is_with_dag_context:\n+            self.dag_detector.enter_dag_context()\n+\n+        for body in node.body:\n+            self.visit(body)\n+\n+        # Exit Dag with block\n+        self.dag_detector.exit_dag_context()\n+\n+    def _register_dag_instances(self, targets: list):\n+        \"\"\"Register Dag instance variable names.\"\"\"\n+        for target in targets:\n+            if isinstance(target, ast.Name):\n+                self.dag_detector.register_dag_instance(target.id)\n+\n+    def _track_varying_assignment(self, node: ast.Assign):\n+        \"\"\"Track variable assignments with runtime-varying values.\"\"\"\n+        varying_source = self.value_analyzer.get_varying_source(node.value)\n+        if varying_source:\n+            for target in node.targets:\n+                if isinstance(target, ast.Name):\n+                    self.varying_vars[target.id] = (node.lineno, varying_source)\n+\n+    def _check_and_warn(self, call: ast.Call, context: WarningContext):\n+        \"\"\"Check function call arguments and generate warnings.\"\"\"\n+        varying_source = self.value_analyzer.get_varying_source(call)\n+        if varying_source:\n+            self.static_check_result.warnings.append(\n+                RuntimeVaryingValueWarning(\n+                    line=call.lineno,\n+                    col=call.col_offset,\n+                    code=ast.unparse(call),\n+                    message=self._get_warning_message(context),\n+                )\n+            )\n+\n+    def _get_warning_message(self, context: WarningContext):\n+        \"\"\"Get appropriate warning message based on context.\"\"\"\n+        if self.dag_detector.is_in_dag_context and context == WarningContext.TASK_CONSTRUCTOR:\n+            return \"Don't use runtime-varying values as function arguments within with Dag block\"\n+        return f\"Don't use runtime-varying value as argument in {context.value}\"\n+\n+\n+def check_dag_file_stability(file_path) -> DagStabilityCheckerResult:\n+    from airflow.configuration import conf\n+\n+    check_level = conf.getenum(\"dag_processor\", \"dag_stability_check_level\", DagStabilityCheckLevel)",
      "comment": "There's no conf.getenum. How is this supposed to work?",
      "comment_id": 2664923712,
      "user": "ephraimbuddy",
      "created_at": "2026-01-06T13:26:32Z",
      "url": "https://github.com/apache/airflow/pull/59430#discussion_r2664923712"
    },
    {
      "repo": "apache/airflow",
      "pr_number": 59430,
      "file_path": "airflow-core/src/airflow/utils/dag_stability_checker.py",
      "line": 520,
      "side": "RIGHT",
      "diff_hunk": "@@ -0,0 +1,533 @@\n+# Licensed to the Apache Software Foundation (ASF) under one\n+# or more contributor license agreements.  See the NOTICE file\n+# distributed with this work for additional information\n+# regarding copyright ownership.  The ASF licenses this file\n+# to you under the Apache License, Version 2.0 (the\n+# \"License\"); you may not use this file except in compliance\n+# with the License.  You may obtain a copy of the License at\n+#\n+#   http://www.apache.org/licenses/LICENSE-2.0\n+#\n+# Unless required by applicable law or agreed to in writing,\n+# software distributed under the License is distributed on an\n+# \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+# KIND, either express or implied.  See the License for the\n+# specific language governing permissions and limitations\n+# under the License.\n+from __future__ import annotations\n+\n+import ast\n+from dataclasses import dataclass\n+from enum import Enum\n+from pathlib import Path\n+\n+RUNTIME_VARYING_CALLS = [\n+    (\"datetime\", \"now\"),\n+    (\"datetime\", \"today\"),\n+    (\"datetime\", \"utcnow\"),\n+    (\"date\", \"today\"),\n+    (\"time\", \"time\"),\n+    (\"time\", \"localtime\"),\n+    (\"random\", \"random\"),\n+    (\"random\", \"randint\"),\n+    (\"random\", \"choice\"),\n+    (\"random\", \"uniform\"),\n+    (\"uuid\", \"uuid4\"),\n+    (\"uuid\", \"uuid1\"),\n+    (\"pendulum\", \"now\"),\n+    (\"pendulum\", \"today\"),\n+    (\"pendulum\", \"yesterday\"),\n+    (\"pendulum\", \"tomorrow\"),\n+]\n+\n+\n+class DagStabilityCheckLevel(Enum):\n+    \"\"\"enum class for Dag stability check level.\"\"\"\n+\n+    off = \"off\"\n+    warning = \"warning\"\n+    error = \"error\"\n+\n+\n+class DagStabilityCheckerResult:\n+    \"\"\"\n+    Represents the result of stability analysis on a Dag file.\n+\n+    Stores detected warnings and formats them appropriately based on the configured check level\n+    (warning or error).\n+    \"\"\"\n+\n+    def __init__(self, check_level: DagStabilityCheckLevel):\n+        self.check_level: DagStabilityCheckLevel = check_level\n+        self.warnings: list[RuntimeVaryingValueWarning] = []\n+        self.runtime_varying_values: dict = {}\n+\n+    def format_warnings(self) -> str | None:\n+        \"\"\"Return formatted string of warning list.\"\"\"\n+        if not self.warnings:\n+            return None\n+\n+        lines = [\n+            \"This Dag uses runtime-variable values in Dag construction.\",\n+            \"It causes the Dag version to increase as values change on every Dag parse.\",\n+            \"\",\n+        ]\n+        for w in self.warnings:\n+            lines.extend(\n+                [\n+                    f\"Line {w.line}, Col {w.col}\",\n+                    f\"Code: {w.code}\",\n+                    f\"Issue: {w.message}\",\n+                    \"\",\n+                ]\n+            )\n+\n+        if self.runtime_varying_values:\n+            lines.extend(\n+                [\n+                    \"\ufe0fDon't use the variables as arguments in Dag/Task constructors:\",\n+                    *(\n+                        f\"  Line {line}: '{var_name}' related '{source}'\"\n+                        for var_name, (line, source) in sorted(\n+                            self.runtime_varying_values.items(),\n+                            key=lambda x: x[1][0],\n+                        )\n+                    ),\n+                    \"\",\n+                ]\n+            )\n+\n+        return \"\\n\".join(lines)\n+\n+    def get_warning_dag_format_dict(self, dag_ids: list[str]) -> list[dict[str, str | None]]:\n+        \"\"\"Convert warning statement to Dag warning format.\"\"\"\n+        from airflow.models.dagwarning import DagWarningType\n+\n+        if not self.warnings or self.check_level != DagStabilityCheckLevel.warning:\n+            return []\n+        return [\n+            {\n+                \"dag_id\": dag_id,\n+                \"warning_type\": DagWarningType.RUNTIME_VARYING_VALUE.value,\n+                \"message\": self.format_warnings(),\n+            }\n+            for dag_id in dag_ids\n+        ]\n+\n+    def get_error_format_dict(self, file_path, bundle_path):\n+        if not self.warnings or self.check_level != DagStabilityCheckLevel.error:\n+            return None\n+\n+        relative_file_path = str(Path(file_path).relative_to(bundle_path)) if bundle_path else file_path\n+        return {relative_file_path: self.format_warnings()}\n+\n+\n+@dataclass\n+class RuntimeVaryingValueWarning:\n+    \"\"\"Warning information for runtime-varying value detection.\"\"\"\n+\n+    line: int\n+    col: int\n+    code: str\n+    message: str\n+\n+\n+class WarningContext(str, Enum):\n+    \"\"\"Context types for warnings.\"\"\"\n+\n+    TASK_CONSTRUCTOR = \"Task constructor\"\n+    DAG_CONSTRUCTOR = \"Dag constructor\"\n+\n+\n+class RuntimeVaryingValueAnalyzer:\n+    \"\"\"\n+    Analyzer dedicated to tracking and detecting runtime-varying values.\n+\n+    This analyzer is responsible for identifying if a given AST node\n+    contains values that change on every execution (datetime.now(), random(), etc.).\n+    \"\"\"\n+\n+    def __init__(\n+        self,\n+        varying_vars: dict[str, tuple[int, str]],\n+        imports: dict[str, str],\n+        from_imports: dict[str, tuple[str, str]],\n+    ):\n+        self.varying_vars = varying_vars\n+        self.imports = imports\n+        self.from_imports = from_imports\n+\n+    def get_varying_source(self, node: ast.expr) -> str | None:\n+        \"\"\"\n+        Check if an AST node contains runtime-varying values and return the source.\n+\n+        Checks:\n+        - Runtime-varying function calls (datetime.now(), etc.)\n+        - Runtime-varying variable references\n+        - Runtime-varying values in f-strings\n+        - Runtime-varying values in expressions/collections\n+        \"\"\"\n+        # 1. Direct runtime-varying call\n+        if isinstance(node, ast.Call) and self.is_runtime_varying_call(node):\n+            return ast.unparse(node)\n+\n+        # 2. Runtime-varying variable reference\n+        if isinstance(node, ast.Name) and node.id in self.varying_vars:\n+            _, source = self.varying_vars[node.id]\n+            return source\n+\n+        # 3. f-string\n+        if isinstance(node, ast.JoinedStr):\n+            return self.get_varying_fstring(node)\n+\n+        # 4. Binary operation\n+        if isinstance(node, ast.BinOp):\n+            return self.get_varying_source(node.left) or self.get_varying_source(node.right)\n+\n+        # 5. Collections (list/tuple/set)\n+        if isinstance(node, (ast.List, ast.Tuple, ast.Set)):\n+            return self.get_varying_collection(node.elts)\n+\n+        # 6. List comprehension\n+        if isinstance(node, ast.ListComp):\n+            return self.get_varying_source(node.elt)\n+\n+        # 7. Dictionary\n+        if isinstance(node, ast.Dict):\n+            return self.get_varying_dict(node)\n+\n+        # 8. Method call chain\n+        if isinstance(node, ast.Call) and isinstance(node.func, ast.Attribute):\n+            return self.get_varying_source(node.func.value)\n+\n+        return None\n+\n+    def get_varying_fstring(self, node: ast.JoinedStr) -> str | None:\n+        \"\"\"Check for runtime-varying values inside f-strings.\"\"\"\n+        for value in node.values:\n+            if isinstance(value, ast.FormattedValue):\n+                if source := self.get_varying_source(value.value):\n+                    return source\n+        return None\n+\n+    def get_varying_collection(self, elements: list) -> str | None:\n+        \"\"\"Check for runtime-varying values in collection elements.\"\"\"\n+        for elt in elements:\n+            source = self.get_varying_source(elt)\n+            if source:\n+                return source\n+        return None\n+\n+    def get_varying_dict(self, node: ast.Dict) -> str | None:\n+        \"\"\"Check for runtime-varying values in dictionary keys/values.\"\"\"\n+        for key, value in zip(node.keys, node.values):\n+            if key:\n+                source = self.get_varying_source(key)\n+                if source:\n+                    return source\n+            if value:\n+                source = self.get_varying_source(value)\n+                if source:\n+                    return source\n+        return None\n+\n+    def is_runtime_varying_call(self, node: ast.Call) -> bool:\n+        \"\"\"\n+        Check if a call is runtime-varying.\n+\n+        1. Is the function itself runtime-varying?\n+        2. Do the arguments contain runtime-varying values?\n+        \"\"\"\n+        # Check if the function itself is runtime-varying\n+        if isinstance(node.func, ast.Attribute):\n+            if self._is_runtime_varying_attribute_call(node.func):\n+                return True\n+        elif isinstance(node.func, ast.Name):\n+            if self._is_runtime_varying_name_call(node.func):\n+                return True\n+\n+        # Check if arguments contain runtime-varying values\n+        return self._has_varying_arguments(node)\n+\n+    def _has_varying_arguments(self, node: ast.Call) -> bool:\n+        \"\"\"Check if function arguments contain runtime-varying values.\"\"\"\n+        for arg in node.args:\n+            if self.get_varying_source(arg):\n+                return True\n+\n+        for kw in node.keywords:\n+            if self.get_varying_source(kw.value):\n+                return True\n+\n+        return False\n+\n+    def _is_runtime_varying_attribute_call(self, attr: ast.Attribute) -> bool:\n+        \"\"\"Check for runtime-varying calls like datetime.now().\"\"\"\n+        method_name = attr.attr\n+\n+        if isinstance(attr.value, ast.Name):\n+            module_or_alias = attr.value.id\n+            actual_module = self.imports.get(module_or_alias, module_or_alias)\n+\n+            # If imported via \"from import\"\n+            if module_or_alias in self.from_imports:\n+                _, original_name = self.from_imports[module_or_alias]\n+                actual_module = original_name\n+\n+            return (actual_module, method_name) in RUNTIME_VARYING_CALLS\n+\n+        # Nested attribute (e.g., datetime.datetime.now)\n+        if isinstance(attr.value, ast.Attribute):\n+            inner_attr = attr.value\n+            if isinstance(inner_attr.value, ast.Name):\n+                return (inner_attr.attr, method_name) in RUNTIME_VARYING_CALLS\n+\n+        return False\n+\n+    def _is_runtime_varying_name_call(self, func: ast.Name) -> bool:\n+        \"\"\"Check for runtime-varying calls like now() (when imported via 'from import').\"\"\"\n+        func_name = func.id\n+\n+        if func_name in self.from_imports:\n+            module, original_name = self.from_imports[func_name]\n+            module_parts = module.split(\".\")\n+\n+            for part in module_parts:\n+                if (part, original_name) in RUNTIME_VARYING_CALLS:\n+                    return True\n+\n+        return False\n+\n+\n+class DagTaskDetector:\n+    \"\"\"\n+    Detector dedicated to identifying Dag and Task constructors.\n+\n+    This detector identifies when code is creating Dag or Task objects\n+    in Airflow. It needs to handle both traditional class instantiation and decorator styles.\n+    \"\"\"\n+\n+    def __init__(self, from_imports: dict):\n+        self.from_imports = from_imports\n+        self.dag_instances: set[str] = set()\n+        self.is_in_dag_context: bool = False\n+\n+    def is_dag_constructor(self, node: ast.Call) -> bool:\n+        \"\"\"Check if a call is a Dag constructor.\"\"\"\n+        if not isinstance(node.func, ast.Name):\n+            return False\n+\n+        func_name = node.func.id\n+\n+        # \"from airflow import DAG\" form or \"from airflow.decorator import dag\"\n+        if func_name in self.from_imports:\n+            module, original = self.from_imports[func_name]\n+            if (module == \"airflow\" or module.startswith(\"airflow.\")) and original in (\"DAG\", \"dag\"):\n+                return True\n+\n+        return False\n+\n+    def is_task_constructor(self, node: ast.Call) -> bool:\n+        \"\"\"\n+        Check if a call is a Task constructor.\n+\n+        Criteria:\n+        1. All calls within a Dag with block\n+        2. Calls that receive a Dag instance as an argument (dag=...)\n+        \"\"\"\n+        # Inside Dag with block\n+        if self.is_in_dag_context:\n+            return True\n+\n+        # Passing Dag instance as argument\n+        for arg in node.args:\n+            if isinstance(arg, ast.Name) and arg.id in self.dag_instances:\n+                return True\n+\n+        for keyword in node.keywords:\n+            if keyword.value and isinstance(keyword.value, ast.Name):\n+                if keyword.value.id in self.dag_instances:\n+                    return True\n+\n+        return False\n+\n+    def register_dag_instance(self, var_name: str):\n+        \"\"\"Register a Dag instance variable name.\"\"\"\n+        self.dag_instances.add(var_name)\n+\n+    def enter_dag_context(self):\n+        \"\"\"Enter a Dag with block.\"\"\"\n+        self.is_in_dag_context = True\n+\n+    def exit_dag_context(self):\n+        \"\"\"Exit a Dag with block.\"\"\"\n+        self.is_in_dag_context = False\n+\n+\n+class AirflowRuntimeVaryingValueChecker(ast.NodeVisitor):\n+    \"\"\"\n+    Main visitor class to detect runtime-varying value usage in Airflow Dag/Task.\n+\n+    Main responsibilities:\n+    - Traverse AST and visit nodes\n+    - Detect Dag/Task creation\n+    - Track runtime-varying values and generate warnings\n+    \"\"\"\n+\n+    def __init__(self, check_level: DagStabilityCheckLevel = DagStabilityCheckLevel.warning):\n+        self.static_check_result: DagStabilityCheckerResult = DagStabilityCheckerResult(\n+            check_level=check_level\n+        )\n+        self.imports: dict[str, str] = {}\n+        self.from_imports: dict[str, tuple[str, str]] = {}\n+        self.varying_vars: dict[str, tuple[int, str]] = {}\n+        self.check_level = check_level\n+\n+        # Helper objects\n+        self.value_analyzer = RuntimeVaryingValueAnalyzer(self.varying_vars, self.imports, self.from_imports)\n+        self.dag_detector = DagTaskDetector(self.from_imports)\n+\n+    def visit_Import(self, node: ast.Import):\n+        \"\"\"Process import statements.\"\"\"\n+        for alias in node.names:\n+            name = alias.asname or alias.name\n+            self.imports[name] = alias.name\n+\n+    def visit_ImportFrom(self, node: ast.ImportFrom):\n+        \"\"\"Process from ... import statements.\"\"\"\n+        if node.module:\n+            for alias in node.names:\n+                name = alias.asname or alias.name\n+                self.from_imports[name] = (node.module, alias.name)\n+\n+    def visit_Assign(self, node: ast.Assign):\n+        \"\"\"\n+        Process variable assignments.\n+\n+        Checks:\n+        1. Dag instance assignment\n+        2. Task instance assignment\n+        3. Runtime-varying value assignment\n+        \"\"\"\n+        value = node.value\n+\n+        # Dag constructor\n+        if isinstance(value, ast.Call) and self.dag_detector.is_dag_constructor(value):\n+            self._register_dag_instances(node.targets)\n+            self._check_and_warn(value, WarningContext.DAG_CONSTRUCTOR)\n+\n+        # Task constructor\n+        elif isinstance(value, ast.Call) and self.dag_detector.is_task_constructor(value):\n+            self._check_and_warn(value, WarningContext.TASK_CONSTRUCTOR)\n+\n+        # Track runtime-varying values\n+        else:\n+            self._track_varying_assignment(node)\n+\n+    def visit_Call(self, node: ast.Call):\n+        \"\"\"\n+        Process function calls.\n+\n+        Check not assign but just call the function or Dag definition via decorator.\n+        \"\"\"\n+        if self.dag_detector.is_dag_constructor(node):\n+            self._check_and_warn(node, WarningContext.DAG_CONSTRUCTOR)\n+\n+        elif self.dag_detector.is_task_constructor(node):\n+            self._check_and_warn(node, WarningContext.TASK_CONSTRUCTOR)\n+\n+    def visit_For(self, node: ast.For):\n+        \"\"\"\n+        Process for statements.\n+\n+        Check if iteration target contains runtime-varying values.\n+        \"\"\"\n+        # check the iterator value is runtime-varying\n+        # iter is runtime-varying : for iter in [datetime.now(), 3]\n+        varying_source = self.value_analyzer.get_varying_source(node.iter)\n+        if varying_source:\n+            if isinstance(node.target, ast.Name):\n+                self.varying_vars[node.target.id] = (node.lineno, varying_source)\n+\n+        for body in node.body:\n+            self.visit(body)\n+\n+        if varying_source:\n+            if isinstance(node.target, ast.Name):\n+                self.varying_vars.pop(node.target.id)\n+\n+    def visit_With(self, node: ast.With):\n+        \"\"\"\n+        Process with statements.\n+\n+        Detect Dag context manager.\n+        \"\"\"\n+        is_with_dag_context = False\n+        for item in node.items:\n+            # check if the Dag instance exists in with context\n+            self.visit(item)\n+            if isinstance(item.context_expr, ast.Call):\n+                if self.dag_detector.is_dag_constructor(item.context_expr):\n+                    # check the value defined in with statement to detect entering Dag with block\n+                    is_with_dag_context = True\n+\n+        if is_with_dag_context:\n+            self.dag_detector.enter_dag_context()\n+\n+        for body in node.body:\n+            self.visit(body)\n+\n+        # Exit Dag with block\n+        self.dag_detector.exit_dag_context()\n+\n+    def _register_dag_instances(self, targets: list):\n+        \"\"\"Register Dag instance variable names.\"\"\"\n+        for target in targets:\n+            if isinstance(target, ast.Name):\n+                self.dag_detector.register_dag_instance(target.id)\n+\n+    def _track_varying_assignment(self, node: ast.Assign):\n+        \"\"\"Track variable assignments with runtime-varying values.\"\"\"\n+        varying_source = self.value_analyzer.get_varying_source(node.value)\n+        if varying_source:\n+            for target in node.targets:\n+                if isinstance(target, ast.Name):\n+                    self.varying_vars[target.id] = (node.lineno, varying_source)\n+\n+    def _check_and_warn(self, call: ast.Call, context: WarningContext):\n+        \"\"\"Check function call arguments and generate warnings.\"\"\"\n+        varying_source = self.value_analyzer.get_varying_source(call)\n+        if varying_source:\n+            self.static_check_result.warnings.append(\n+                RuntimeVaryingValueWarning(\n+                    line=call.lineno,\n+                    col=call.col_offset,\n+                    code=ast.unparse(call),\n+                    message=self._get_warning_message(context),\n+                )\n+            )\n+\n+    def _get_warning_message(self, context: WarningContext):\n+        \"\"\"Get appropriate warning message based on context.\"\"\"\n+        if self.dag_detector.is_in_dag_context and context == WarningContext.TASK_CONSTRUCTOR:\n+            return \"Don't use runtime-varying values as function arguments within with Dag block\"\n+        return f\"Don't use runtime-varying value as argument in {context.value}\"\n+\n+\n+def check_dag_file_stability(file_path) -> DagStabilityCheckerResult:\n+    from airflow.configuration import conf\n+\n+    check_level = conf.getenum(\"dag_processor\", \"dag_stability_check_level\", DagStabilityCheckLevel)",
      "comment": "https://github.com/apache/airflow/blob/main/shared/configuration/src/airflow_shared/configuration/parser.py#L1096\r\nIt currently exists in main (it's a method I added in a previous [PR](https://github.com/apache/airflow/pull/56821))",
      "comment_id": 2664977281,
      "user": "wjddn279",
      "created_at": "2026-01-06T13:45:04Z",
      "url": "https://github.com/apache/airflow/pull/59430#discussion_r2664977281"
    },
    {
      "repo": "apache/airflow",
      "pr_number": 59430,
      "file_path": "airflow-core/src/airflow/utils/dag_stability_checker.py",
      "line": 122,
      "side": "RIGHT",
      "diff_hunk": "@@ -0,0 +1,533 @@\n+# Licensed to the Apache Software Foundation (ASF) under one\n+# or more contributor license agreements.  See the NOTICE file\n+# distributed with this work for additional information\n+# regarding copyright ownership.  The ASF licenses this file\n+# to you under the Apache License, Version 2.0 (the\n+# \"License\"); you may not use this file except in compliance\n+# with the License.  You may obtain a copy of the License at\n+#\n+#   http://www.apache.org/licenses/LICENSE-2.0\n+#\n+# Unless required by applicable law or agreed to in writing,\n+# software distributed under the License is distributed on an\n+# \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+# KIND, either express or implied.  See the License for the\n+# specific language governing permissions and limitations\n+# under the License.\n+from __future__ import annotations\n+\n+import ast\n+from dataclasses import dataclass\n+from enum import Enum\n+from pathlib import Path\n+\n+RUNTIME_VARYING_CALLS = [\n+    (\"datetime\", \"now\"),\n+    (\"datetime\", \"today\"),\n+    (\"datetime\", \"utcnow\"),\n+    (\"date\", \"today\"),\n+    (\"time\", \"time\"),\n+    (\"time\", \"localtime\"),\n+    (\"random\", \"random\"),\n+    (\"random\", \"randint\"),\n+    (\"random\", \"choice\"),\n+    (\"random\", \"uniform\"),\n+    (\"uuid\", \"uuid4\"),\n+    (\"uuid\", \"uuid1\"),\n+    (\"pendulum\", \"now\"),\n+    (\"pendulum\", \"today\"),\n+    (\"pendulum\", \"yesterday\"),\n+    (\"pendulum\", \"tomorrow\"),\n+]\n+\n+\n+class DagStabilityCheckLevel(Enum):\n+    \"\"\"enum class for Dag stability check level.\"\"\"\n+\n+    off = \"off\"\n+    warning = \"warning\"\n+    error = \"error\"\n+\n+\n+class DagStabilityCheckerResult:\n+    \"\"\"\n+    Represents the result of stability analysis on a Dag file.\n+\n+    Stores detected warnings and formats them appropriately based on the configured check level\n+    (warning or error).\n+    \"\"\"\n+\n+    def __init__(self, check_level: DagStabilityCheckLevel):\n+        self.check_level: DagStabilityCheckLevel = check_level\n+        self.warnings: list[RuntimeVaryingValueWarning] = []\n+        self.runtime_varying_values: dict = {}\n+\n+    def format_warnings(self) -> str | None:\n+        \"\"\"Return formatted string of warning list.\"\"\"\n+        if not self.warnings:\n+            return None\n+\n+        lines = [\n+            \"This Dag uses runtime-variable values in Dag construction.\",\n+            \"It causes the Dag version to increase as values change on every Dag parse.\",\n+            \"\",\n+        ]\n+        for w in self.warnings:\n+            lines.extend(\n+                [\n+                    f\"Line {w.line}, Col {w.col}\",\n+                    f\"Code: {w.code}\",\n+                    f\"Issue: {w.message}\",\n+                    \"\",\n+                ]\n+            )\n+\n+        if self.runtime_varying_values:\n+            lines.extend(\n+                [\n+                    \"\ufe0fDon't use the variables as arguments in Dag/Task constructors:\",\n+                    *(\n+                        f\"  Line {line}: '{var_name}' related '{source}'\"\n+                        for var_name, (line, source) in sorted(\n+                            self.runtime_varying_values.items(),\n+                            key=lambda x: x[1][0],\n+                        )\n+                    ),\n+                    \"\",\n+                ]\n+            )\n+\n+        return \"\\n\".join(lines)\n+\n+    def get_warning_dag_format_dict(self, dag_ids: list[str]) -> list[dict[str, str | None]]:\n+        \"\"\"Convert warning statement to Dag warning format.\"\"\"\n+        from airflow.models.dagwarning import DagWarningType\n+\n+        if not self.warnings or self.check_level != DagStabilityCheckLevel.warning:\n+            return []\n+        return [\n+            {\n+                \"dag_id\": dag_id,\n+                \"warning_type\": DagWarningType.RUNTIME_VARYING_VALUE.value,\n+                \"message\": self.format_warnings(),\n+            }\n+            for dag_id in dag_ids\n+        ]\n+\n+    def get_error_format_dict(self, file_path, bundle_path):\n+        if not self.warnings or self.check_level != DagStabilityCheckLevel.error:\n+            return None\n+\n+        relative_file_path = str(Path(file_path).relative_to(bundle_path)) if bundle_path else file_path\n+        return {relative_file_path: self.format_warnings()}",
      "comment": "```suggestion\n    def get_formatted_warnings(self, dag_ids: list[str]) -> list[dict[str, str | None]]:\n        \"\"\"Convert warning statement to Dag warning format.\"\"\"\n        from airflow.models.dagwarning import DagWarningType\n\n        if not self.warnings or self.check_level != DagStabilityCheckLevel.warning:\n            return []\n        return [\n            {\n                \"dag_id\": dag_id,\n                \"warning_type\": DagWarningType.RUNTIME_VARYING_VALUE.value,\n                \"message\": self.format_warnings(),\n            }\n            for dag_id in dag_ids\n        ]\n\n    def get_formatted_errors(self, file_path, bundle_path) -> dict[str, str | None] | None:\n        if not self.warnings or self.check_level != DagStabilityCheckLevel.error:\n            return None\n\n        relative_file_path = str(Path(file_path).relative_to(bundle_path)) if bundle_path else file_path\n        return {relative_file_path: self.format_warnings()}\n```\n\nThe first function is not returning a dict but a list. Naming them this way or similar would be easier to understand\n",
      "comment_id": 2667525571,
      "user": "Lee-W",
      "created_at": "2026-01-07T08:36:15Z",
      "url": "https://github.com/apache/airflow/pull/59430#discussion_r2667525571"
    },
    {
      "repo": "apache/airflow",
      "pr_number": 59430,
      "file_path": "airflow-core/src/airflow/utils/dag_stability_checker.py",
      "line": 201,
      "side": "RIGHT",
      "diff_hunk": "@@ -0,0 +1,533 @@\n+# Licensed to the Apache Software Foundation (ASF) under one\n+# or more contributor license agreements.  See the NOTICE file\n+# distributed with this work for additional information\n+# regarding copyright ownership.  The ASF licenses this file\n+# to you under the Apache License, Version 2.0 (the\n+# \"License\"); you may not use this file except in compliance\n+# with the License.  You may obtain a copy of the License at\n+#\n+#   http://www.apache.org/licenses/LICENSE-2.0\n+#\n+# Unless required by applicable law or agreed to in writing,\n+# software distributed under the License is distributed on an\n+# \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+# KIND, either express or implied.  See the License for the\n+# specific language governing permissions and limitations\n+# under the License.\n+from __future__ import annotations\n+\n+import ast\n+from dataclasses import dataclass\n+from enum import Enum\n+from pathlib import Path\n+\n+RUNTIME_VARYING_CALLS = [\n+    (\"datetime\", \"now\"),\n+    (\"datetime\", \"today\"),\n+    (\"datetime\", \"utcnow\"),\n+    (\"date\", \"today\"),\n+    (\"time\", \"time\"),\n+    (\"time\", \"localtime\"),\n+    (\"random\", \"random\"),\n+    (\"random\", \"randint\"),\n+    (\"random\", \"choice\"),\n+    (\"random\", \"uniform\"),\n+    (\"uuid\", \"uuid4\"),\n+    (\"uuid\", \"uuid1\"),\n+    (\"pendulum\", \"now\"),\n+    (\"pendulum\", \"today\"),\n+    (\"pendulum\", \"yesterday\"),\n+    (\"pendulum\", \"tomorrow\"),\n+]\n+\n+\n+class DagStabilityCheckLevel(Enum):\n+    \"\"\"enum class for Dag stability check level.\"\"\"\n+\n+    off = \"off\"\n+    warning = \"warning\"\n+    error = \"error\"\n+\n+\n+class DagStabilityCheckerResult:\n+    \"\"\"\n+    Represents the result of stability analysis on a Dag file.\n+\n+    Stores detected warnings and formats them appropriately based on the configured check level\n+    (warning or error).\n+    \"\"\"\n+\n+    def __init__(self, check_level: DagStabilityCheckLevel):\n+        self.check_level: DagStabilityCheckLevel = check_level\n+        self.warnings: list[RuntimeVaryingValueWarning] = []\n+        self.runtime_varying_values: dict = {}\n+\n+    def format_warnings(self) -> str | None:\n+        \"\"\"Return formatted string of warning list.\"\"\"\n+        if not self.warnings:\n+            return None\n+\n+        lines = [\n+            \"This Dag uses runtime-variable values in Dag construction.\",\n+            \"It causes the Dag version to increase as values change on every Dag parse.\",\n+            \"\",\n+        ]\n+        for w in self.warnings:\n+            lines.extend(\n+                [\n+                    f\"Line {w.line}, Col {w.col}\",\n+                    f\"Code: {w.code}\",\n+                    f\"Issue: {w.message}\",\n+                    \"\",\n+                ]\n+            )\n+\n+        if self.runtime_varying_values:\n+            lines.extend(\n+                [\n+                    \"\ufe0fDon't use the variables as arguments in Dag/Task constructors:\",\n+                    *(\n+                        f\"  Line {line}: '{var_name}' related '{source}'\"\n+                        for var_name, (line, source) in sorted(\n+                            self.runtime_varying_values.items(),\n+                            key=lambda x: x[1][0],\n+                        )\n+                    ),\n+                    \"\",\n+                ]\n+            )\n+\n+        return \"\\n\".join(lines)\n+\n+    def get_warning_dag_format_dict(self, dag_ids: list[str]) -> list[dict[str, str | None]]:\n+        \"\"\"Convert warning statement to Dag warning format.\"\"\"\n+        from airflow.models.dagwarning import DagWarningType\n+\n+        if not self.warnings or self.check_level != DagStabilityCheckLevel.warning:\n+            return []\n+        return [\n+            {\n+                \"dag_id\": dag_id,\n+                \"warning_type\": DagWarningType.RUNTIME_VARYING_VALUE.value,\n+                \"message\": self.format_warnings(),\n+            }\n+            for dag_id in dag_ids\n+        ]\n+\n+    def get_error_format_dict(self, file_path, bundle_path):\n+        if not self.warnings or self.check_level != DagStabilityCheckLevel.error:\n+            return None\n+\n+        relative_file_path = str(Path(file_path).relative_to(bundle_path)) if bundle_path else file_path\n+        return {relative_file_path: self.format_warnings()}\n+\n+\n+@dataclass\n+class RuntimeVaryingValueWarning:\n+    \"\"\"Warning information for runtime-varying value detection.\"\"\"\n+\n+    line: int\n+    col: int\n+    code: str\n+    message: str\n+\n+\n+class WarningContext(str, Enum):\n+    \"\"\"Context types for warnings.\"\"\"\n+\n+    TASK_CONSTRUCTOR = \"Task constructor\"\n+    DAG_CONSTRUCTOR = \"Dag constructor\"\n+\n+\n+class RuntimeVaryingValueAnalyzer:\n+    \"\"\"\n+    Analyzer dedicated to tracking and detecting runtime-varying values.\n+\n+    This analyzer is responsible for identifying if a given AST node\n+    contains values that change on every execution (datetime.now(), random(), etc.).\n+    \"\"\"\n+\n+    def __init__(\n+        self,\n+        varying_vars: dict[str, tuple[int, str]],\n+        imports: dict[str, str],\n+        from_imports: dict[str, tuple[str, str]],\n+    ):\n+        self.varying_vars = varying_vars\n+        self.imports = imports\n+        self.from_imports = from_imports\n+\n+    def get_varying_source(self, node: ast.expr) -> str | None:\n+        \"\"\"\n+        Check if an AST node contains runtime-varying values and return the source.\n+\n+        Checks:\n+        - Runtime-varying function calls (datetime.now(), etc.)\n+        - Runtime-varying variable references\n+        - Runtime-varying values in f-strings\n+        - Runtime-varying values in expressions/collections\n+        \"\"\"\n+        # 1. Direct runtime-varying call\n+        if isinstance(node, ast.Call) and self.is_runtime_varying_call(node):\n+            return ast.unparse(node)\n+\n+        # 2. Runtime-varying variable reference\n+        if isinstance(node, ast.Name) and node.id in self.varying_vars:\n+            _, source = self.varying_vars[node.id]\n+            return source\n+\n+        # 3. f-string\n+        if isinstance(node, ast.JoinedStr):\n+            return self.get_varying_fstring(node)\n+\n+        # 4. Binary operation\n+        if isinstance(node, ast.BinOp):\n+            return self.get_varying_source(node.left) or self.get_varying_source(node.right)\n+\n+        # 5. Collections (list/tuple/set)\n+        if isinstance(node, (ast.List, ast.Tuple, ast.Set)):\n+            return self.get_varying_collection(node.elts)\n+\n+        # 6. List comprehension\n+        if isinstance(node, ast.ListComp):\n+            return self.get_varying_source(node.elt)\n+\n+        # 7. Dictionary\n+        if isinstance(node, ast.Dict):\n+            return self.get_varying_dict(node)\n+\n+        # 8. Method call chain\n+        if isinstance(node, ast.Call) and isinstance(node.func, ast.Attribute):\n+            return self.get_varying_source(node.func.value)",
      "comment": "```suggestion\n        \n        if isinstance(node, ast.Call)\n            # 1. Direct runtime-varying call\n            if self.is_runtime_varying_call(node):\n                return ast.unparse(node)\n\n            # 2. Method call chain\n            if isinstance(node.func, ast.Attribute):\n                self.get_varying_source(node.func.value)\n\n\n        # 3. Runtime-varying variable reference\n        if isinstance(node, ast.Name) and node.id in self.varying_vars:\n            _, source = self.varying_vars[node.id]\n            return source\n\n        # 4. f-string\n        if isinstance(node, ast.JoinedStr):\n            return self.get_varying_fstring(node)\n\n        # 5. Binary operation\n        if isinstance(node, ast.BinOp):\n            return self.get_varying_source(node.left) or self.get_varying_source(node.right)\n\n        # 6. Collections (list/tuple/set)\n        if isinstance(node, (ast.List, ast.Tuple, ast.Set)):\n            return self.get_varying_collection(node.elts)\n\n        # 7. List comprehension\n        if isinstance(node, ast.ListComp):\n            return self.get_varying_source(node.elt)\n\n        # 8. Dictionary\n        if isinstance(node, ast.Dict):\n            return self.get_varying_dict(node)\n\n```",
      "comment_id": 2667546137,
      "user": "Lee-W",
      "created_at": "2026-01-07T08:43:36Z",
      "url": "https://github.com/apache/airflow/pull/59430#discussion_r2667546137"
    },
    {
      "repo": "apache/airflow",
      "pr_number": 59430,
      "file_path": "airflow-core/src/airflow/utils/dag_stability_checker.py",
      "line": 218,
      "side": "RIGHT",
      "diff_hunk": "@@ -0,0 +1,533 @@\n+# Licensed to the Apache Software Foundation (ASF) under one\n+# or more contributor license agreements.  See the NOTICE file\n+# distributed with this work for additional information\n+# regarding copyright ownership.  The ASF licenses this file\n+# to you under the Apache License, Version 2.0 (the\n+# \"License\"); you may not use this file except in compliance\n+# with the License.  You may obtain a copy of the License at\n+#\n+#   http://www.apache.org/licenses/LICENSE-2.0\n+#\n+# Unless required by applicable law or agreed to in writing,\n+# software distributed under the License is distributed on an\n+# \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+# KIND, either express or implied.  See the License for the\n+# specific language governing permissions and limitations\n+# under the License.\n+from __future__ import annotations\n+\n+import ast\n+from dataclasses import dataclass\n+from enum import Enum\n+from pathlib import Path\n+\n+RUNTIME_VARYING_CALLS = [\n+    (\"datetime\", \"now\"),\n+    (\"datetime\", \"today\"),\n+    (\"datetime\", \"utcnow\"),\n+    (\"date\", \"today\"),\n+    (\"time\", \"time\"),\n+    (\"time\", \"localtime\"),\n+    (\"random\", \"random\"),\n+    (\"random\", \"randint\"),\n+    (\"random\", \"choice\"),\n+    (\"random\", \"uniform\"),\n+    (\"uuid\", \"uuid4\"),\n+    (\"uuid\", \"uuid1\"),\n+    (\"pendulum\", \"now\"),\n+    (\"pendulum\", \"today\"),\n+    (\"pendulum\", \"yesterday\"),\n+    (\"pendulum\", \"tomorrow\"),\n+]\n+\n+\n+class DagStabilityCheckLevel(Enum):\n+    \"\"\"enum class for Dag stability check level.\"\"\"\n+\n+    off = \"off\"\n+    warning = \"warning\"\n+    error = \"error\"\n+\n+\n+class DagStabilityCheckerResult:\n+    \"\"\"\n+    Represents the result of stability analysis on a Dag file.\n+\n+    Stores detected warnings and formats them appropriately based on the configured check level\n+    (warning or error).\n+    \"\"\"\n+\n+    def __init__(self, check_level: DagStabilityCheckLevel):\n+        self.check_level: DagStabilityCheckLevel = check_level\n+        self.warnings: list[RuntimeVaryingValueWarning] = []\n+        self.runtime_varying_values: dict = {}\n+\n+    def format_warnings(self) -> str | None:\n+        \"\"\"Return formatted string of warning list.\"\"\"\n+        if not self.warnings:\n+            return None\n+\n+        lines = [\n+            \"This Dag uses runtime-variable values in Dag construction.\",\n+            \"It causes the Dag version to increase as values change on every Dag parse.\",\n+            \"\",\n+        ]\n+        for w in self.warnings:\n+            lines.extend(\n+                [\n+                    f\"Line {w.line}, Col {w.col}\",\n+                    f\"Code: {w.code}\",\n+                    f\"Issue: {w.message}\",\n+                    \"\",\n+                ]\n+            )\n+\n+        if self.runtime_varying_values:\n+            lines.extend(\n+                [\n+                    \"\ufe0fDon't use the variables as arguments in Dag/Task constructors:\",\n+                    *(\n+                        f\"  Line {line}: '{var_name}' related '{source}'\"\n+                        for var_name, (line, source) in sorted(\n+                            self.runtime_varying_values.items(),\n+                            key=lambda x: x[1][0],\n+                        )\n+                    ),\n+                    \"\",\n+                ]\n+            )\n+\n+        return \"\\n\".join(lines)\n+\n+    def get_warning_dag_format_dict(self, dag_ids: list[str]) -> list[dict[str, str | None]]:\n+        \"\"\"Convert warning statement to Dag warning format.\"\"\"\n+        from airflow.models.dagwarning import DagWarningType\n+\n+        if not self.warnings or self.check_level != DagStabilityCheckLevel.warning:\n+            return []\n+        return [\n+            {\n+                \"dag_id\": dag_id,\n+                \"warning_type\": DagWarningType.RUNTIME_VARYING_VALUE.value,\n+                \"message\": self.format_warnings(),\n+            }\n+            for dag_id in dag_ids\n+        ]\n+\n+    def get_error_format_dict(self, file_path, bundle_path):\n+        if not self.warnings or self.check_level != DagStabilityCheckLevel.error:\n+            return None\n+\n+        relative_file_path = str(Path(file_path).relative_to(bundle_path)) if bundle_path else file_path\n+        return {relative_file_path: self.format_warnings()}\n+\n+\n+@dataclass\n+class RuntimeVaryingValueWarning:\n+    \"\"\"Warning information for runtime-varying value detection.\"\"\"\n+\n+    line: int\n+    col: int\n+    code: str\n+    message: str\n+\n+\n+class WarningContext(str, Enum):\n+    \"\"\"Context types for warnings.\"\"\"\n+\n+    TASK_CONSTRUCTOR = \"Task constructor\"\n+    DAG_CONSTRUCTOR = \"Dag constructor\"\n+\n+\n+class RuntimeVaryingValueAnalyzer:\n+    \"\"\"\n+    Analyzer dedicated to tracking and detecting runtime-varying values.\n+\n+    This analyzer is responsible for identifying if a given AST node\n+    contains values that change on every execution (datetime.now(), random(), etc.).\n+    \"\"\"\n+\n+    def __init__(\n+        self,\n+        varying_vars: dict[str, tuple[int, str]],\n+        imports: dict[str, str],\n+        from_imports: dict[str, tuple[str, str]],\n+    ):\n+        self.varying_vars = varying_vars\n+        self.imports = imports\n+        self.from_imports = from_imports\n+\n+    def get_varying_source(self, node: ast.expr) -> str | None:\n+        \"\"\"\n+        Check if an AST node contains runtime-varying values and return the source.\n+\n+        Checks:\n+        - Runtime-varying function calls (datetime.now(), etc.)\n+        - Runtime-varying variable references\n+        - Runtime-varying values in f-strings\n+        - Runtime-varying values in expressions/collections\n+        \"\"\"\n+        # 1. Direct runtime-varying call\n+        if isinstance(node, ast.Call) and self.is_runtime_varying_call(node):\n+            return ast.unparse(node)\n+\n+        # 2. Runtime-varying variable reference\n+        if isinstance(node, ast.Name) and node.id in self.varying_vars:\n+            _, source = self.varying_vars[node.id]\n+            return source\n+\n+        # 3. f-string\n+        if isinstance(node, ast.JoinedStr):\n+            return self.get_varying_fstring(node)\n+\n+        # 4. Binary operation\n+        if isinstance(node, ast.BinOp):\n+            return self.get_varying_source(node.left) or self.get_varying_source(node.right)\n+\n+        # 5. Collections (list/tuple/set)\n+        if isinstance(node, (ast.List, ast.Tuple, ast.Set)):\n+            return self.get_varying_collection(node.elts)\n+\n+        # 6. List comprehension\n+        if isinstance(node, ast.ListComp):\n+            return self.get_varying_source(node.elt)\n+\n+        # 7. Dictionary\n+        if isinstance(node, ast.Dict):\n+            return self.get_varying_dict(node)\n+\n+        # 8. Method call chain\n+        if isinstance(node, ast.Call) and isinstance(node.func, ast.Attribute):\n+            return self.get_varying_source(node.func.value)\n+\n+        return None\n+\n+    def get_varying_fstring(self, node: ast.JoinedStr) -> str | None:\n+        \"\"\"Check for runtime-varying values inside f-strings.\"\"\"\n+        for value in node.values:\n+            if isinstance(value, ast.FormattedValue):\n+                if source := self.get_varying_source(value.value):\n+                    return source\n+        return None\n+\n+    def get_varying_collection(self, elements: list) -> str | None:\n+        \"\"\"Check for runtime-varying values in collection elements.\"\"\"\n+        for elt in elements:\n+            source = self.get_varying_source(elt)\n+            if source:\n+                return source",
      "comment": "```suggestion\n            if (source := self.get_varying_source(elt)):\n                return source\n```",
      "comment_id": 2667547473,
      "user": "Lee-W",
      "created_at": "2026-01-07T08:44:05Z",
      "url": "https://github.com/apache/airflow/pull/59430#discussion_r2667547473"
    },
    {
      "repo": "apache/airflow",
      "pr_number": 59430,
      "file_path": "airflow-core/src/airflow/utils/dag_version_inflation_checker.py",
      "line": 229,
      "side": "RIGHT",
      "diff_hunk": "@@ -0,0 +1,533 @@\n+# Licensed to the Apache Software Foundation (ASF) under one\n+# or more contributor license agreements.  See the NOTICE file\n+# distributed with this work for additional information\n+# regarding copyright ownership.  The ASF licenses this file\n+# to you under the Apache License, Version 2.0 (the\n+# \"License\"); you may not use this file except in compliance\n+# with the License.  You may obtain a copy of the License at\n+#\n+#   http://www.apache.org/licenses/LICENSE-2.0\n+#\n+# Unless required by applicable law or agreed to in writing,\n+# software distributed under the License is distributed on an\n+# \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+# KIND, either express or implied.  See the License for the\n+# specific language governing permissions and limitations\n+# under the License.\n+from __future__ import annotations\n+\n+import ast\n+from dataclasses import dataclass\n+from enum import Enum\n+from pathlib import Path\n+\n+RUNTIME_VARYING_CALLS = [\n+    (\"datetime\", \"now\"),\n+    (\"datetime\", \"today\"),\n+    (\"datetime\", \"utcnow\"),\n+    (\"date\", \"today\"),\n+    (\"time\", \"time\"),\n+    (\"time\", \"localtime\"),\n+    (\"random\", \"random\"),\n+    (\"random\", \"randint\"),\n+    (\"random\", \"choice\"),\n+    (\"random\", \"uniform\"),\n+    (\"uuid\", \"uuid4\"),\n+    (\"uuid\", \"uuid1\"),\n+    (\"pendulum\", \"now\"),\n+    (\"pendulum\", \"today\"),\n+    (\"pendulum\", \"yesterday\"),\n+    (\"pendulum\", \"tomorrow\"),\n+]\n+\n+\n+class DagStabilityCheckLevel(Enum):\n+    \"\"\"enum class for Dag stability check level.\"\"\"\n+\n+    off = \"off\"\n+    warning = \"warning\"\n+    error = \"error\"\n+\n+\n+class DagStabilityCheckerResult:\n+    \"\"\"\n+    Represents the result of stability analysis on a Dag file.\n+\n+    Stores detected warnings and formats them appropriately based on the configured check level\n+    (warning or error).\n+    \"\"\"\n+\n+    def __init__(self, check_level: DagStabilityCheckLevel):\n+        self.check_level: DagStabilityCheckLevel = check_level\n+        self.warnings: list[RuntimeVaryingValueWarning] = []\n+        self.runtime_varying_values: dict = {}\n+\n+    def format_warnings(self) -> str | None:\n+        \"\"\"Return formatted string of warning list.\"\"\"\n+        if not self.warnings:\n+            return None\n+\n+        lines = [\n+            \"This Dag uses runtime-variable values in Dag construction.\",\n+            \"It causes the Dag version to increase as values change on every Dag parse.\",\n+            \"\",\n+        ]\n+        for w in self.warnings:\n+            lines.extend(\n+                [\n+                    f\"Line {w.line}, Col {w.col}\",\n+                    f\"Code: {w.code}\",\n+                    f\"Issue: {w.message}\",\n+                    \"\",\n+                ]\n+            )\n+\n+        if self.runtime_varying_values:\n+            lines.extend(\n+                [\n+                    \"\ufe0fDon't use the variables as arguments in Dag/Task constructors:\",\n+                    *(\n+                        f\"  Line {line}: '{var_name}' related '{source}'\"\n+                        for var_name, (line, source) in sorted(\n+                            self.runtime_varying_values.items(),\n+                            key=lambda x: x[1][0],\n+                        )\n+                    ),\n+                    \"\",\n+                ]\n+            )\n+\n+        return \"\\n\".join(lines)\n+\n+    def get_warning_dag_format_dict(self, dag_ids: list[str]) -> list[dict[str, str | None]]:\n+        \"\"\"Convert warning statement to Dag warning format.\"\"\"\n+        from airflow.models.dagwarning import DagWarningType\n+\n+        if not self.warnings or self.check_level != DagStabilityCheckLevel.warning:\n+            return []\n+        return [\n+            {\n+                \"dag_id\": dag_id,\n+                \"warning_type\": DagWarningType.RUNTIME_VARYING_VALUE.value,\n+                \"message\": self.format_warnings(),\n+            }\n+            for dag_id in dag_ids\n+        ]\n+\n+    def get_error_format_dict(self, file_path, bundle_path):\n+        if not self.warnings or self.check_level != DagStabilityCheckLevel.error:\n+            return None\n+\n+        relative_file_path = str(Path(file_path).relative_to(bundle_path)) if bundle_path else file_path\n+        return {relative_file_path: self.format_warnings()}\n+\n+\n+@dataclass\n+class RuntimeVaryingValueWarning:\n+    \"\"\"Warning information for runtime-varying value detection.\"\"\"\n+\n+    line: int\n+    col: int\n+    code: str\n+    message: str\n+\n+\n+class WarningContext(str, Enum):\n+    \"\"\"Context types for warnings.\"\"\"\n+\n+    TASK_CONSTRUCTOR = \"Task constructor\"\n+    DAG_CONSTRUCTOR = \"Dag constructor\"\n+\n+\n+class RuntimeVaryingValueAnalyzer:\n+    \"\"\"\n+    Analyzer dedicated to tracking and detecting runtime-varying values.\n+\n+    This analyzer is responsible for identifying if a given AST node\n+    contains values that change on every execution (datetime.now(), random(), etc.).\n+    \"\"\"\n+\n+    def __init__(\n+        self,\n+        varying_vars: dict[str, tuple[int, str]],\n+        imports: dict[str, str],\n+        from_imports: dict[str, tuple[str, str]],\n+    ):\n+        self.varying_vars = varying_vars\n+        self.imports = imports\n+        self.from_imports = from_imports\n+\n+    def get_varying_source(self, node: ast.expr) -> str | None:\n+        \"\"\"\n+        Check if an AST node contains runtime-varying values and return the source.\n+\n+        Checks:\n+        - Runtime-varying function calls (datetime.now(), etc.)\n+        - Runtime-varying variable references\n+        - Runtime-varying values in f-strings\n+        - Runtime-varying values in expressions/collections\n+        \"\"\"\n+        # 1. Direct runtime-varying call\n+        if isinstance(node, ast.Call) and self.is_runtime_varying_call(node):\n+            return ast.unparse(node)\n+\n+        # 2. Runtime-varying variable reference\n+        if isinstance(node, ast.Name) and node.id in self.varying_vars:\n+            _, source = self.varying_vars[node.id]\n+            return source\n+\n+        # 3. f-string\n+        if isinstance(node, ast.JoinedStr):\n+            return self.get_varying_fstring(node)\n+\n+        # 4. Binary operation\n+        if isinstance(node, ast.BinOp):\n+            return self.get_varying_source(node.left) or self.get_varying_source(node.right)\n+\n+        # 5. Collections (list/tuple/set)\n+        if isinstance(node, (ast.List, ast.Tuple, ast.Set)):\n+            return self.get_varying_collection(node.elts)\n+\n+        # 6. List comprehension\n+        if isinstance(node, ast.ListComp):\n+            return self.get_varying_source(node.elt)\n+\n+        # 7. Dictionary\n+        if isinstance(node, ast.Dict):\n+            return self.get_varying_dict(node)\n+\n+        # 8. Method call chain\n+        if isinstance(node, ast.Call) and isinstance(node.func, ast.Attribute):\n+            return self.get_varying_source(node.func.value)\n+\n+        return None\n+\n+    def get_varying_fstring(self, node: ast.JoinedStr) -> str | None:\n+        \"\"\"Check for runtime-varying values inside f-strings.\"\"\"\n+        for value in node.values:\n+            if isinstance(value, ast.FormattedValue):\n+                if source := self.get_varying_source(value.value):\n+                    return source\n+        return None\n+\n+    def get_varying_collection(self, elements: list) -> str | None:\n+        \"\"\"Check for runtime-varying values in collection elements.\"\"\"\n+        for elt in elements:\n+            source = self.get_varying_source(elt)\n+            if source:\n+                return source\n+        return None\n+\n+    def get_varying_dict(self, node: ast.Dict) -> str | None:\n+        \"\"\"Check for runtime-varying values in dictionary keys/values.\"\"\"\n+        for key, value in zip(node.keys, node.values):\n+            if key:\n+                source = self.get_varying_source(key)\n+                if source:\n+                    return source\n+            if value:\n+                source = self.get_varying_source(value)\n+                if source:\n+                    return source",
      "comment": "```suggestion\n            if key and (source := self.get_varying_source(key)):\n                return source\n                \n            if value and (source := self.get_varing_source(value)): \n                return source\n```",
      "comment_id": 2667552948,
      "user": "Lee-W",
      "created_at": "2026-01-07T08:46:06Z",
      "url": "https://github.com/apache/airflow/pull/59430#discussion_r2667552948"
    },
    {
      "repo": "apache/airflow",
      "pr_number": 59430,
      "file_path": "airflow-core/src/airflow/utils/dag_stability_checker.py",
      "line": 247,
      "side": "RIGHT",
      "diff_hunk": "@@ -0,0 +1,533 @@\n+# Licensed to the Apache Software Foundation (ASF) under one\n+# or more contributor license agreements.  See the NOTICE file\n+# distributed with this work for additional information\n+# regarding copyright ownership.  The ASF licenses this file\n+# to you under the Apache License, Version 2.0 (the\n+# \"License\"); you may not use this file except in compliance\n+# with the License.  You may obtain a copy of the License at\n+#\n+#   http://www.apache.org/licenses/LICENSE-2.0\n+#\n+# Unless required by applicable law or agreed to in writing,\n+# software distributed under the License is distributed on an\n+# \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+# KIND, either express or implied.  See the License for the\n+# specific language governing permissions and limitations\n+# under the License.\n+from __future__ import annotations\n+\n+import ast\n+from dataclasses import dataclass\n+from enum import Enum\n+from pathlib import Path\n+\n+RUNTIME_VARYING_CALLS = [\n+    (\"datetime\", \"now\"),\n+    (\"datetime\", \"today\"),\n+    (\"datetime\", \"utcnow\"),\n+    (\"date\", \"today\"),\n+    (\"time\", \"time\"),\n+    (\"time\", \"localtime\"),\n+    (\"random\", \"random\"),\n+    (\"random\", \"randint\"),\n+    (\"random\", \"choice\"),\n+    (\"random\", \"uniform\"),\n+    (\"uuid\", \"uuid4\"),\n+    (\"uuid\", \"uuid1\"),\n+    (\"pendulum\", \"now\"),\n+    (\"pendulum\", \"today\"),\n+    (\"pendulum\", \"yesterday\"),\n+    (\"pendulum\", \"tomorrow\"),\n+]\n+\n+\n+class DagStabilityCheckLevel(Enum):\n+    \"\"\"enum class for Dag stability check level.\"\"\"\n+\n+    off = \"off\"\n+    warning = \"warning\"\n+    error = \"error\"\n+\n+\n+class DagStabilityCheckerResult:\n+    \"\"\"\n+    Represents the result of stability analysis on a Dag file.\n+\n+    Stores detected warnings and formats them appropriately based on the configured check level\n+    (warning or error).\n+    \"\"\"\n+\n+    def __init__(self, check_level: DagStabilityCheckLevel):\n+        self.check_level: DagStabilityCheckLevel = check_level\n+        self.warnings: list[RuntimeVaryingValueWarning] = []\n+        self.runtime_varying_values: dict = {}\n+\n+    def format_warnings(self) -> str | None:\n+        \"\"\"Return formatted string of warning list.\"\"\"\n+        if not self.warnings:\n+            return None\n+\n+        lines = [\n+            \"This Dag uses runtime-variable values in Dag construction.\",\n+            \"It causes the Dag version to increase as values change on every Dag parse.\",\n+            \"\",\n+        ]\n+        for w in self.warnings:\n+            lines.extend(\n+                [\n+                    f\"Line {w.line}, Col {w.col}\",\n+                    f\"Code: {w.code}\",\n+                    f\"Issue: {w.message}\",\n+                    \"\",\n+                ]\n+            )\n+\n+        if self.runtime_varying_values:\n+            lines.extend(\n+                [\n+                    \"\ufe0fDon't use the variables as arguments in Dag/Task constructors:\",\n+                    *(\n+                        f\"  Line {line}: '{var_name}' related '{source}'\"\n+                        for var_name, (line, source) in sorted(\n+                            self.runtime_varying_values.items(),\n+                            key=lambda x: x[1][0],\n+                        )\n+                    ),\n+                    \"\",\n+                ]\n+            )\n+\n+        return \"\\n\".join(lines)\n+\n+    def get_warning_dag_format_dict(self, dag_ids: list[str]) -> list[dict[str, str | None]]:\n+        \"\"\"Convert warning statement to Dag warning format.\"\"\"\n+        from airflow.models.dagwarning import DagWarningType\n+\n+        if not self.warnings or self.check_level != DagStabilityCheckLevel.warning:\n+            return []\n+        return [\n+            {\n+                \"dag_id\": dag_id,\n+                \"warning_type\": DagWarningType.RUNTIME_VARYING_VALUE.value,\n+                \"message\": self.format_warnings(),\n+            }\n+            for dag_id in dag_ids\n+        ]\n+\n+    def get_error_format_dict(self, file_path, bundle_path):\n+        if not self.warnings or self.check_level != DagStabilityCheckLevel.error:\n+            return None\n+\n+        relative_file_path = str(Path(file_path).relative_to(bundle_path)) if bundle_path else file_path\n+        return {relative_file_path: self.format_warnings()}\n+\n+\n+@dataclass\n+class RuntimeVaryingValueWarning:\n+    \"\"\"Warning information for runtime-varying value detection.\"\"\"\n+\n+    line: int\n+    col: int\n+    code: str\n+    message: str\n+\n+\n+class WarningContext(str, Enum):\n+    \"\"\"Context types for warnings.\"\"\"\n+\n+    TASK_CONSTRUCTOR = \"Task constructor\"\n+    DAG_CONSTRUCTOR = \"Dag constructor\"\n+\n+\n+class RuntimeVaryingValueAnalyzer:\n+    \"\"\"\n+    Analyzer dedicated to tracking and detecting runtime-varying values.\n+\n+    This analyzer is responsible for identifying if a given AST node\n+    contains values that change on every execution (datetime.now(), random(), etc.).\n+    \"\"\"\n+\n+    def __init__(\n+        self,\n+        varying_vars: dict[str, tuple[int, str]],\n+        imports: dict[str, str],\n+        from_imports: dict[str, tuple[str, str]],\n+    ):\n+        self.varying_vars = varying_vars\n+        self.imports = imports\n+        self.from_imports = from_imports\n+\n+    def get_varying_source(self, node: ast.expr) -> str | None:\n+        \"\"\"\n+        Check if an AST node contains runtime-varying values and return the source.\n+\n+        Checks:\n+        - Runtime-varying function calls (datetime.now(), etc.)\n+        - Runtime-varying variable references\n+        - Runtime-varying values in f-strings\n+        - Runtime-varying values in expressions/collections\n+        \"\"\"\n+        # 1. Direct runtime-varying call\n+        if isinstance(node, ast.Call) and self.is_runtime_varying_call(node):\n+            return ast.unparse(node)\n+\n+        # 2. Runtime-varying variable reference\n+        if isinstance(node, ast.Name) and node.id in self.varying_vars:\n+            _, source = self.varying_vars[node.id]\n+            return source\n+\n+        # 3. f-string\n+        if isinstance(node, ast.JoinedStr):\n+            return self.get_varying_fstring(node)\n+\n+        # 4. Binary operation\n+        if isinstance(node, ast.BinOp):\n+            return self.get_varying_source(node.left) or self.get_varying_source(node.right)\n+\n+        # 5. Collections (list/tuple/set)\n+        if isinstance(node, (ast.List, ast.Tuple, ast.Set)):\n+            return self.get_varying_collection(node.elts)\n+\n+        # 6. List comprehension\n+        if isinstance(node, ast.ListComp):\n+            return self.get_varying_source(node.elt)\n+\n+        # 7. Dictionary\n+        if isinstance(node, ast.Dict):\n+            return self.get_varying_dict(node)\n+\n+        # 8. Method call chain\n+        if isinstance(node, ast.Call) and isinstance(node.func, ast.Attribute):\n+            return self.get_varying_source(node.func.value)\n+\n+        return None\n+\n+    def get_varying_fstring(self, node: ast.JoinedStr) -> str | None:\n+        \"\"\"Check for runtime-varying values inside f-strings.\"\"\"\n+        for value in node.values:\n+            if isinstance(value, ast.FormattedValue):\n+                if source := self.get_varying_source(value.value):\n+                    return source\n+        return None\n+\n+    def get_varying_collection(self, elements: list) -> str | None:\n+        \"\"\"Check for runtime-varying values in collection elements.\"\"\"\n+        for elt in elements:\n+            source = self.get_varying_source(elt)\n+            if source:\n+                return source\n+        return None\n+\n+    def get_varying_dict(self, node: ast.Dict) -> str | None:\n+        \"\"\"Check for runtime-varying values in dictionary keys/values.\"\"\"\n+        for key, value in zip(node.keys, node.values):\n+            if key:\n+                source = self.get_varying_source(key)\n+                if source:\n+                    return source\n+            if value:\n+                source = self.get_varying_source(value)\n+                if source:\n+                    return source\n+        return None\n+\n+    def is_runtime_varying_call(self, node: ast.Call) -> bool:\n+        \"\"\"\n+        Check if a call is runtime-varying.\n+\n+        1. Is the function itself runtime-varying?\n+        2. Do the arguments contain runtime-varying values?\n+        \"\"\"\n+        # Check if the function itself is runtime-varying\n+        if isinstance(node.func, ast.Attribute):\n+            if self._is_runtime_varying_attribute_call(node.func):\n+                return True\n+        elif isinstance(node.func, ast.Name):\n+            if self._is_runtime_varying_name_call(node.func):\n+                return True",
      "comment": "```suggestion\n        if isinstance(node.func, ast.Attribute) and self._is_runtime_varying_attribute_call(node.func):\n            return True\n        elif isinstance(node.func, ast.Name) and self._is_runtime_varying_name_call(node.func):\n            return True\n```",
      "comment_id": 2667554477,
      "user": "Lee-W",
      "created_at": "2026-01-07T08:46:40Z",
      "url": "https://github.com/apache/airflow/pull/59430#discussion_r2667554477"
    },
    {
      "repo": "apache/airflow",
      "pr_number": 59430,
      "file_path": "airflow-core/src/airflow/utils/dag_stability_checker.py",
      "line": 252,
      "side": "RIGHT",
      "diff_hunk": "@@ -0,0 +1,533 @@\n+# Licensed to the Apache Software Foundation (ASF) under one\n+# or more contributor license agreements.  See the NOTICE file\n+# distributed with this work for additional information\n+# regarding copyright ownership.  The ASF licenses this file\n+# to you under the Apache License, Version 2.0 (the\n+# \"License\"); you may not use this file except in compliance\n+# with the License.  You may obtain a copy of the License at\n+#\n+#   http://www.apache.org/licenses/LICENSE-2.0\n+#\n+# Unless required by applicable law or agreed to in writing,\n+# software distributed under the License is distributed on an\n+# \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+# KIND, either express or implied.  See the License for the\n+# specific language governing permissions and limitations\n+# under the License.\n+from __future__ import annotations\n+\n+import ast\n+from dataclasses import dataclass\n+from enum import Enum\n+from pathlib import Path\n+\n+RUNTIME_VARYING_CALLS = [\n+    (\"datetime\", \"now\"),\n+    (\"datetime\", \"today\"),\n+    (\"datetime\", \"utcnow\"),\n+    (\"date\", \"today\"),\n+    (\"time\", \"time\"),\n+    (\"time\", \"localtime\"),\n+    (\"random\", \"random\"),\n+    (\"random\", \"randint\"),\n+    (\"random\", \"choice\"),\n+    (\"random\", \"uniform\"),\n+    (\"uuid\", \"uuid4\"),\n+    (\"uuid\", \"uuid1\"),\n+    (\"pendulum\", \"now\"),\n+    (\"pendulum\", \"today\"),\n+    (\"pendulum\", \"yesterday\"),\n+    (\"pendulum\", \"tomorrow\"),\n+]\n+\n+\n+class DagStabilityCheckLevel(Enum):\n+    \"\"\"enum class for Dag stability check level.\"\"\"\n+\n+    off = \"off\"\n+    warning = \"warning\"\n+    error = \"error\"\n+\n+\n+class DagStabilityCheckerResult:\n+    \"\"\"\n+    Represents the result of stability analysis on a Dag file.\n+\n+    Stores detected warnings and formats them appropriately based on the configured check level\n+    (warning or error).\n+    \"\"\"\n+\n+    def __init__(self, check_level: DagStabilityCheckLevel):\n+        self.check_level: DagStabilityCheckLevel = check_level\n+        self.warnings: list[RuntimeVaryingValueWarning] = []\n+        self.runtime_varying_values: dict = {}\n+\n+    def format_warnings(self) -> str | None:\n+        \"\"\"Return formatted string of warning list.\"\"\"\n+        if not self.warnings:\n+            return None\n+\n+        lines = [\n+            \"This Dag uses runtime-variable values in Dag construction.\",\n+            \"It causes the Dag version to increase as values change on every Dag parse.\",\n+            \"\",\n+        ]\n+        for w in self.warnings:\n+            lines.extend(\n+                [\n+                    f\"Line {w.line}, Col {w.col}\",\n+                    f\"Code: {w.code}\",\n+                    f\"Issue: {w.message}\",\n+                    \"\",\n+                ]\n+            )\n+\n+        if self.runtime_varying_values:\n+            lines.extend(\n+                [\n+                    \"\ufe0fDon't use the variables as arguments in Dag/Task constructors:\",\n+                    *(\n+                        f\"  Line {line}: '{var_name}' related '{source}'\"\n+                        for var_name, (line, source) in sorted(\n+                            self.runtime_varying_values.items(),\n+                            key=lambda x: x[1][0],\n+                        )\n+                    ),\n+                    \"\",\n+                ]\n+            )\n+\n+        return \"\\n\".join(lines)\n+\n+    def get_warning_dag_format_dict(self, dag_ids: list[str]) -> list[dict[str, str | None]]:\n+        \"\"\"Convert warning statement to Dag warning format.\"\"\"\n+        from airflow.models.dagwarning import DagWarningType\n+\n+        if not self.warnings or self.check_level != DagStabilityCheckLevel.warning:\n+            return []\n+        return [\n+            {\n+                \"dag_id\": dag_id,\n+                \"warning_type\": DagWarningType.RUNTIME_VARYING_VALUE.value,\n+                \"message\": self.format_warnings(),\n+            }\n+            for dag_id in dag_ids\n+        ]\n+\n+    def get_error_format_dict(self, file_path, bundle_path):\n+        if not self.warnings or self.check_level != DagStabilityCheckLevel.error:\n+            return None\n+\n+        relative_file_path = str(Path(file_path).relative_to(bundle_path)) if bundle_path else file_path\n+        return {relative_file_path: self.format_warnings()}\n+\n+\n+@dataclass\n+class RuntimeVaryingValueWarning:\n+    \"\"\"Warning information for runtime-varying value detection.\"\"\"\n+\n+    line: int\n+    col: int\n+    code: str\n+    message: str\n+\n+\n+class WarningContext(str, Enum):\n+    \"\"\"Context types for warnings.\"\"\"\n+\n+    TASK_CONSTRUCTOR = \"Task constructor\"\n+    DAG_CONSTRUCTOR = \"Dag constructor\"\n+\n+\n+class RuntimeVaryingValueAnalyzer:\n+    \"\"\"\n+    Analyzer dedicated to tracking and detecting runtime-varying values.\n+\n+    This analyzer is responsible for identifying if a given AST node\n+    contains values that change on every execution (datetime.now(), random(), etc.).\n+    \"\"\"\n+\n+    def __init__(\n+        self,\n+        varying_vars: dict[str, tuple[int, str]],\n+        imports: dict[str, str],\n+        from_imports: dict[str, tuple[str, str]],\n+    ):\n+        self.varying_vars = varying_vars\n+        self.imports = imports\n+        self.from_imports = from_imports\n+\n+    def get_varying_source(self, node: ast.expr) -> str | None:\n+        \"\"\"\n+        Check if an AST node contains runtime-varying values and return the source.\n+\n+        Checks:\n+        - Runtime-varying function calls (datetime.now(), etc.)\n+        - Runtime-varying variable references\n+        - Runtime-varying values in f-strings\n+        - Runtime-varying values in expressions/collections\n+        \"\"\"\n+        # 1. Direct runtime-varying call\n+        if isinstance(node, ast.Call) and self.is_runtime_varying_call(node):\n+            return ast.unparse(node)\n+\n+        # 2. Runtime-varying variable reference\n+        if isinstance(node, ast.Name) and node.id in self.varying_vars:\n+            _, source = self.varying_vars[node.id]\n+            return source\n+\n+        # 3. f-string\n+        if isinstance(node, ast.JoinedStr):\n+            return self.get_varying_fstring(node)\n+\n+        # 4. Binary operation\n+        if isinstance(node, ast.BinOp):\n+            return self.get_varying_source(node.left) or self.get_varying_source(node.right)\n+\n+        # 5. Collections (list/tuple/set)\n+        if isinstance(node, (ast.List, ast.Tuple, ast.Set)):\n+            return self.get_varying_collection(node.elts)\n+\n+        # 6. List comprehension\n+        if isinstance(node, ast.ListComp):\n+            return self.get_varying_source(node.elt)\n+\n+        # 7. Dictionary\n+        if isinstance(node, ast.Dict):\n+            return self.get_varying_dict(node)\n+\n+        # 8. Method call chain\n+        if isinstance(node, ast.Call) and isinstance(node.func, ast.Attribute):\n+            return self.get_varying_source(node.func.value)\n+\n+        return None\n+\n+    def get_varying_fstring(self, node: ast.JoinedStr) -> str | None:\n+        \"\"\"Check for runtime-varying values inside f-strings.\"\"\"\n+        for value in node.values:\n+            if isinstance(value, ast.FormattedValue):\n+                if source := self.get_varying_source(value.value):\n+                    return source\n+        return None\n+\n+    def get_varying_collection(self, elements: list) -> str | None:\n+        \"\"\"Check for runtime-varying values in collection elements.\"\"\"\n+        for elt in elements:\n+            source = self.get_varying_source(elt)\n+            if source:\n+                return source\n+        return None\n+\n+    def get_varying_dict(self, node: ast.Dict) -> str | None:\n+        \"\"\"Check for runtime-varying values in dictionary keys/values.\"\"\"\n+        for key, value in zip(node.keys, node.values):\n+            if key:\n+                source = self.get_varying_source(key)\n+                if source:\n+                    return source\n+            if value:\n+                source = self.get_varying_source(value)\n+                if source:\n+                    return source\n+        return None\n+\n+    def is_runtime_varying_call(self, node: ast.Call) -> bool:\n+        \"\"\"\n+        Check if a call is runtime-varying.\n+\n+        1. Is the function itself runtime-varying?\n+        2. Do the arguments contain runtime-varying values?\n+        \"\"\"\n+        # Check if the function itself is runtime-varying\n+        if isinstance(node.func, ast.Attribute):\n+            if self._is_runtime_varying_attribute_call(node.func):\n+                return True\n+        elif isinstance(node.func, ast.Name):\n+            if self._is_runtime_varying_name_call(node.func):\n+                return True\n+\n+        # Check if arguments contain runtime-varying values\n+        return self._has_varying_arguments(node)\n+\n+    def _has_varying_arguments(self, node: ast.Call) -> bool:",
      "comment": "```suggestion\n    def has_varying_arguments(self, node: ast.Call) -> bool:\n```",
      "comment_id": 2667556412,
      "user": "Lee-W",
      "created_at": "2026-01-07T08:47:24Z",
      "url": "https://github.com/apache/airflow/pull/59430#discussion_r2667556412"
    },
    {
      "repo": "apache/airflow",
      "pr_number": 59430,
      "file_path": "airflow-core/src/airflow/utils/dag_stability_checker.py",
      "line": 264,
      "side": "RIGHT",
      "diff_hunk": "@@ -0,0 +1,533 @@\n+# Licensed to the Apache Software Foundation (ASF) under one\n+# or more contributor license agreements.  See the NOTICE file\n+# distributed with this work for additional information\n+# regarding copyright ownership.  The ASF licenses this file\n+# to you under the Apache License, Version 2.0 (the\n+# \"License\"); you may not use this file except in compliance\n+# with the License.  You may obtain a copy of the License at\n+#\n+#   http://www.apache.org/licenses/LICENSE-2.0\n+#\n+# Unless required by applicable law or agreed to in writing,\n+# software distributed under the License is distributed on an\n+# \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+# KIND, either express or implied.  See the License for the\n+# specific language governing permissions and limitations\n+# under the License.\n+from __future__ import annotations\n+\n+import ast\n+from dataclasses import dataclass\n+from enum import Enum\n+from pathlib import Path\n+\n+RUNTIME_VARYING_CALLS = [\n+    (\"datetime\", \"now\"),\n+    (\"datetime\", \"today\"),\n+    (\"datetime\", \"utcnow\"),\n+    (\"date\", \"today\"),\n+    (\"time\", \"time\"),\n+    (\"time\", \"localtime\"),\n+    (\"random\", \"random\"),\n+    (\"random\", \"randint\"),\n+    (\"random\", \"choice\"),\n+    (\"random\", \"uniform\"),\n+    (\"uuid\", \"uuid4\"),\n+    (\"uuid\", \"uuid1\"),\n+    (\"pendulum\", \"now\"),\n+    (\"pendulum\", \"today\"),\n+    (\"pendulum\", \"yesterday\"),\n+    (\"pendulum\", \"tomorrow\"),\n+]\n+\n+\n+class DagStabilityCheckLevel(Enum):\n+    \"\"\"enum class for Dag stability check level.\"\"\"\n+\n+    off = \"off\"\n+    warning = \"warning\"\n+    error = \"error\"\n+\n+\n+class DagStabilityCheckerResult:\n+    \"\"\"\n+    Represents the result of stability analysis on a Dag file.\n+\n+    Stores detected warnings and formats them appropriately based on the configured check level\n+    (warning or error).\n+    \"\"\"\n+\n+    def __init__(self, check_level: DagStabilityCheckLevel):\n+        self.check_level: DagStabilityCheckLevel = check_level\n+        self.warnings: list[RuntimeVaryingValueWarning] = []\n+        self.runtime_varying_values: dict = {}\n+\n+    def format_warnings(self) -> str | None:\n+        \"\"\"Return formatted string of warning list.\"\"\"\n+        if not self.warnings:\n+            return None\n+\n+        lines = [\n+            \"This Dag uses runtime-variable values in Dag construction.\",\n+            \"It causes the Dag version to increase as values change on every Dag parse.\",\n+            \"\",\n+        ]\n+        for w in self.warnings:\n+            lines.extend(\n+                [\n+                    f\"Line {w.line}, Col {w.col}\",\n+                    f\"Code: {w.code}\",\n+                    f\"Issue: {w.message}\",\n+                    \"\",\n+                ]\n+            )\n+\n+        if self.runtime_varying_values:\n+            lines.extend(\n+                [\n+                    \"\ufe0fDon't use the variables as arguments in Dag/Task constructors:\",\n+                    *(\n+                        f\"  Line {line}: '{var_name}' related '{source}'\"\n+                        for var_name, (line, source) in sorted(\n+                            self.runtime_varying_values.items(),\n+                            key=lambda x: x[1][0],\n+                        )\n+                    ),\n+                    \"\",\n+                ]\n+            )\n+\n+        return \"\\n\".join(lines)\n+\n+    def get_warning_dag_format_dict(self, dag_ids: list[str]) -> list[dict[str, str | None]]:\n+        \"\"\"Convert warning statement to Dag warning format.\"\"\"\n+        from airflow.models.dagwarning import DagWarningType\n+\n+        if not self.warnings or self.check_level != DagStabilityCheckLevel.warning:\n+            return []\n+        return [\n+            {\n+                \"dag_id\": dag_id,\n+                \"warning_type\": DagWarningType.RUNTIME_VARYING_VALUE.value,\n+                \"message\": self.format_warnings(),\n+            }\n+            for dag_id in dag_ids\n+        ]\n+\n+    def get_error_format_dict(self, file_path, bundle_path):\n+        if not self.warnings or self.check_level != DagStabilityCheckLevel.error:\n+            return None\n+\n+        relative_file_path = str(Path(file_path).relative_to(bundle_path)) if bundle_path else file_path\n+        return {relative_file_path: self.format_warnings()}\n+\n+\n+@dataclass\n+class RuntimeVaryingValueWarning:\n+    \"\"\"Warning information for runtime-varying value detection.\"\"\"\n+\n+    line: int\n+    col: int\n+    code: str\n+    message: str\n+\n+\n+class WarningContext(str, Enum):\n+    \"\"\"Context types for warnings.\"\"\"\n+\n+    TASK_CONSTRUCTOR = \"Task constructor\"\n+    DAG_CONSTRUCTOR = \"Dag constructor\"\n+\n+\n+class RuntimeVaryingValueAnalyzer:\n+    \"\"\"\n+    Analyzer dedicated to tracking and detecting runtime-varying values.\n+\n+    This analyzer is responsible for identifying if a given AST node\n+    contains values that change on every execution (datetime.now(), random(), etc.).\n+    \"\"\"\n+\n+    def __init__(\n+        self,\n+        varying_vars: dict[str, tuple[int, str]],\n+        imports: dict[str, str],\n+        from_imports: dict[str, tuple[str, str]],\n+    ):\n+        self.varying_vars = varying_vars\n+        self.imports = imports\n+        self.from_imports = from_imports\n+\n+    def get_varying_source(self, node: ast.expr) -> str | None:\n+        \"\"\"\n+        Check if an AST node contains runtime-varying values and return the source.\n+\n+        Checks:\n+        - Runtime-varying function calls (datetime.now(), etc.)\n+        - Runtime-varying variable references\n+        - Runtime-varying values in f-strings\n+        - Runtime-varying values in expressions/collections\n+        \"\"\"\n+        # 1. Direct runtime-varying call\n+        if isinstance(node, ast.Call) and self.is_runtime_varying_call(node):\n+            return ast.unparse(node)\n+\n+        # 2. Runtime-varying variable reference\n+        if isinstance(node, ast.Name) and node.id in self.varying_vars:\n+            _, source = self.varying_vars[node.id]\n+            return source\n+\n+        # 3. f-string\n+        if isinstance(node, ast.JoinedStr):\n+            return self.get_varying_fstring(node)\n+\n+        # 4. Binary operation\n+        if isinstance(node, ast.BinOp):\n+            return self.get_varying_source(node.left) or self.get_varying_source(node.right)\n+\n+        # 5. Collections (list/tuple/set)\n+        if isinstance(node, (ast.List, ast.Tuple, ast.Set)):\n+            return self.get_varying_collection(node.elts)\n+\n+        # 6. List comprehension\n+        if isinstance(node, ast.ListComp):\n+            return self.get_varying_source(node.elt)\n+\n+        # 7. Dictionary\n+        if isinstance(node, ast.Dict):\n+            return self.get_varying_dict(node)\n+\n+        # 8. Method call chain\n+        if isinstance(node, ast.Call) and isinstance(node.func, ast.Attribute):\n+            return self.get_varying_source(node.func.value)\n+\n+        return None\n+\n+    def get_varying_fstring(self, node: ast.JoinedStr) -> str | None:\n+        \"\"\"Check for runtime-varying values inside f-strings.\"\"\"\n+        for value in node.values:\n+            if isinstance(value, ast.FormattedValue):\n+                if source := self.get_varying_source(value.value):\n+                    return source\n+        return None\n+\n+    def get_varying_collection(self, elements: list) -> str | None:\n+        \"\"\"Check for runtime-varying values in collection elements.\"\"\"\n+        for elt in elements:\n+            source = self.get_varying_source(elt)\n+            if source:\n+                return source\n+        return None\n+\n+    def get_varying_dict(self, node: ast.Dict) -> str | None:\n+        \"\"\"Check for runtime-varying values in dictionary keys/values.\"\"\"\n+        for key, value in zip(node.keys, node.values):\n+            if key:\n+                source = self.get_varying_source(key)\n+                if source:\n+                    return source\n+            if value:\n+                source = self.get_varying_source(value)\n+                if source:\n+                    return source\n+        return None\n+\n+    def is_runtime_varying_call(self, node: ast.Call) -> bool:\n+        \"\"\"\n+        Check if a call is runtime-varying.\n+\n+        1. Is the function itself runtime-varying?\n+        2. Do the arguments contain runtime-varying values?\n+        \"\"\"\n+        # Check if the function itself is runtime-varying\n+        if isinstance(node.func, ast.Attribute):\n+            if self._is_runtime_varying_attribute_call(node.func):\n+                return True\n+        elif isinstance(node.func, ast.Name):\n+            if self._is_runtime_varying_name_call(node.func):\n+                return True\n+\n+        # Check if arguments contain runtime-varying values\n+        return self._has_varying_arguments(node)\n+\n+    def _has_varying_arguments(self, node: ast.Call) -> bool:\n+        \"\"\"Check if function arguments contain runtime-varying values.\"\"\"\n+        for arg in node.args:\n+            if self.get_varying_source(arg):\n+                return True\n+\n+        for kw in node.keywords:\n+            if self.get_varying_source(kw.value):\n+                return True\n+\n+        return False\n+\n+    def _is_runtime_varying_attribute_call(self, attr: ast.Attribute) -> bool:",
      "comment": "```suggestion\n    def is_runtime_varying_attribute_call(self, attr: ast.Attribute) -> bool:\n```",
      "comment_id": 2667556697,
      "user": "Lee-W",
      "created_at": "2026-01-07T08:47:30Z",
      "url": "https://github.com/apache/airflow/pull/59430#discussion_r2667556697"
    },
    {
      "repo": "apache/airflow",
      "pr_number": 59430,
      "file_path": "airflow-core/src/airflow/utils/dag_stability_checker.py",
      "line": 287,
      "side": "RIGHT",
      "diff_hunk": "@@ -0,0 +1,533 @@\n+# Licensed to the Apache Software Foundation (ASF) under one\n+# or more contributor license agreements.  See the NOTICE file\n+# distributed with this work for additional information\n+# regarding copyright ownership.  The ASF licenses this file\n+# to you under the Apache License, Version 2.0 (the\n+# \"License\"); you may not use this file except in compliance\n+# with the License.  You may obtain a copy of the License at\n+#\n+#   http://www.apache.org/licenses/LICENSE-2.0\n+#\n+# Unless required by applicable law or agreed to in writing,\n+# software distributed under the License is distributed on an\n+# \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+# KIND, either express or implied.  See the License for the\n+# specific language governing permissions and limitations\n+# under the License.\n+from __future__ import annotations\n+\n+import ast\n+from dataclasses import dataclass\n+from enum import Enum\n+from pathlib import Path\n+\n+RUNTIME_VARYING_CALLS = [\n+    (\"datetime\", \"now\"),\n+    (\"datetime\", \"today\"),\n+    (\"datetime\", \"utcnow\"),\n+    (\"date\", \"today\"),\n+    (\"time\", \"time\"),\n+    (\"time\", \"localtime\"),\n+    (\"random\", \"random\"),\n+    (\"random\", \"randint\"),\n+    (\"random\", \"choice\"),\n+    (\"random\", \"uniform\"),\n+    (\"uuid\", \"uuid4\"),\n+    (\"uuid\", \"uuid1\"),\n+    (\"pendulum\", \"now\"),\n+    (\"pendulum\", \"today\"),\n+    (\"pendulum\", \"yesterday\"),\n+    (\"pendulum\", \"tomorrow\"),\n+]\n+\n+\n+class DagStabilityCheckLevel(Enum):\n+    \"\"\"enum class for Dag stability check level.\"\"\"\n+\n+    off = \"off\"\n+    warning = \"warning\"\n+    error = \"error\"\n+\n+\n+class DagStabilityCheckerResult:\n+    \"\"\"\n+    Represents the result of stability analysis on a Dag file.\n+\n+    Stores detected warnings and formats them appropriately based on the configured check level\n+    (warning or error).\n+    \"\"\"\n+\n+    def __init__(self, check_level: DagStabilityCheckLevel):\n+        self.check_level: DagStabilityCheckLevel = check_level\n+        self.warnings: list[RuntimeVaryingValueWarning] = []\n+        self.runtime_varying_values: dict = {}\n+\n+    def format_warnings(self) -> str | None:\n+        \"\"\"Return formatted string of warning list.\"\"\"\n+        if not self.warnings:\n+            return None\n+\n+        lines = [\n+            \"This Dag uses runtime-variable values in Dag construction.\",\n+            \"It causes the Dag version to increase as values change on every Dag parse.\",\n+            \"\",\n+        ]\n+        for w in self.warnings:\n+            lines.extend(\n+                [\n+                    f\"Line {w.line}, Col {w.col}\",\n+                    f\"Code: {w.code}\",\n+                    f\"Issue: {w.message}\",\n+                    \"\",\n+                ]\n+            )\n+\n+        if self.runtime_varying_values:\n+            lines.extend(\n+                [\n+                    \"\ufe0fDon't use the variables as arguments in Dag/Task constructors:\",\n+                    *(\n+                        f\"  Line {line}: '{var_name}' related '{source}'\"\n+                        for var_name, (line, source) in sorted(\n+                            self.runtime_varying_values.items(),\n+                            key=lambda x: x[1][0],\n+                        )\n+                    ),\n+                    \"\",\n+                ]\n+            )\n+\n+        return \"\\n\".join(lines)\n+\n+    def get_warning_dag_format_dict(self, dag_ids: list[str]) -> list[dict[str, str | None]]:\n+        \"\"\"Convert warning statement to Dag warning format.\"\"\"\n+        from airflow.models.dagwarning import DagWarningType\n+\n+        if not self.warnings or self.check_level != DagStabilityCheckLevel.warning:\n+            return []\n+        return [\n+            {\n+                \"dag_id\": dag_id,\n+                \"warning_type\": DagWarningType.RUNTIME_VARYING_VALUE.value,\n+                \"message\": self.format_warnings(),\n+            }\n+            for dag_id in dag_ids\n+        ]\n+\n+    def get_error_format_dict(self, file_path, bundle_path):\n+        if not self.warnings or self.check_level != DagStabilityCheckLevel.error:\n+            return None\n+\n+        relative_file_path = str(Path(file_path).relative_to(bundle_path)) if bundle_path else file_path\n+        return {relative_file_path: self.format_warnings()}\n+\n+\n+@dataclass\n+class RuntimeVaryingValueWarning:\n+    \"\"\"Warning information for runtime-varying value detection.\"\"\"\n+\n+    line: int\n+    col: int\n+    code: str\n+    message: str\n+\n+\n+class WarningContext(str, Enum):\n+    \"\"\"Context types for warnings.\"\"\"\n+\n+    TASK_CONSTRUCTOR = \"Task constructor\"\n+    DAG_CONSTRUCTOR = \"Dag constructor\"\n+\n+\n+class RuntimeVaryingValueAnalyzer:\n+    \"\"\"\n+    Analyzer dedicated to tracking and detecting runtime-varying values.\n+\n+    This analyzer is responsible for identifying if a given AST node\n+    contains values that change on every execution (datetime.now(), random(), etc.).\n+    \"\"\"\n+\n+    def __init__(\n+        self,\n+        varying_vars: dict[str, tuple[int, str]],\n+        imports: dict[str, str],\n+        from_imports: dict[str, tuple[str, str]],\n+    ):\n+        self.varying_vars = varying_vars\n+        self.imports = imports\n+        self.from_imports = from_imports\n+\n+    def get_varying_source(self, node: ast.expr) -> str | None:\n+        \"\"\"\n+        Check if an AST node contains runtime-varying values and return the source.\n+\n+        Checks:\n+        - Runtime-varying function calls (datetime.now(), etc.)\n+        - Runtime-varying variable references\n+        - Runtime-varying values in f-strings\n+        - Runtime-varying values in expressions/collections\n+        \"\"\"\n+        # 1. Direct runtime-varying call\n+        if isinstance(node, ast.Call) and self.is_runtime_varying_call(node):\n+            return ast.unparse(node)\n+\n+        # 2. Runtime-varying variable reference\n+        if isinstance(node, ast.Name) and node.id in self.varying_vars:\n+            _, source = self.varying_vars[node.id]\n+            return source\n+\n+        # 3. f-string\n+        if isinstance(node, ast.JoinedStr):\n+            return self.get_varying_fstring(node)\n+\n+        # 4. Binary operation\n+        if isinstance(node, ast.BinOp):\n+            return self.get_varying_source(node.left) or self.get_varying_source(node.right)\n+\n+        # 5. Collections (list/tuple/set)\n+        if isinstance(node, (ast.List, ast.Tuple, ast.Set)):\n+            return self.get_varying_collection(node.elts)\n+\n+        # 6. List comprehension\n+        if isinstance(node, ast.ListComp):\n+            return self.get_varying_source(node.elt)\n+\n+        # 7. Dictionary\n+        if isinstance(node, ast.Dict):\n+            return self.get_varying_dict(node)\n+\n+        # 8. Method call chain\n+        if isinstance(node, ast.Call) and isinstance(node.func, ast.Attribute):\n+            return self.get_varying_source(node.func.value)\n+\n+        return None\n+\n+    def get_varying_fstring(self, node: ast.JoinedStr) -> str | None:\n+        \"\"\"Check for runtime-varying values inside f-strings.\"\"\"\n+        for value in node.values:\n+            if isinstance(value, ast.FormattedValue):\n+                if source := self.get_varying_source(value.value):\n+                    return source\n+        return None\n+\n+    def get_varying_collection(self, elements: list) -> str | None:\n+        \"\"\"Check for runtime-varying values in collection elements.\"\"\"\n+        for elt in elements:\n+            source = self.get_varying_source(elt)\n+            if source:\n+                return source\n+        return None\n+\n+    def get_varying_dict(self, node: ast.Dict) -> str | None:\n+        \"\"\"Check for runtime-varying values in dictionary keys/values.\"\"\"\n+        for key, value in zip(node.keys, node.values):\n+            if key:\n+                source = self.get_varying_source(key)\n+                if source:\n+                    return source\n+            if value:\n+                source = self.get_varying_source(value)\n+                if source:\n+                    return source\n+        return None\n+\n+    def is_runtime_varying_call(self, node: ast.Call) -> bool:\n+        \"\"\"\n+        Check if a call is runtime-varying.\n+\n+        1. Is the function itself runtime-varying?\n+        2. Do the arguments contain runtime-varying values?\n+        \"\"\"\n+        # Check if the function itself is runtime-varying\n+        if isinstance(node.func, ast.Attribute):\n+            if self._is_runtime_varying_attribute_call(node.func):\n+                return True\n+        elif isinstance(node.func, ast.Name):\n+            if self._is_runtime_varying_name_call(node.func):\n+                return True\n+\n+        # Check if arguments contain runtime-varying values\n+        return self._has_varying_arguments(node)\n+\n+    def _has_varying_arguments(self, node: ast.Call) -> bool:\n+        \"\"\"Check if function arguments contain runtime-varying values.\"\"\"\n+        for arg in node.args:\n+            if self.get_varying_source(arg):\n+                return True\n+\n+        for kw in node.keywords:\n+            if self.get_varying_source(kw.value):\n+                return True\n+\n+        return False\n+\n+    def _is_runtime_varying_attribute_call(self, attr: ast.Attribute) -> bool:\n+        \"\"\"Check for runtime-varying calls like datetime.now().\"\"\"\n+        method_name = attr.attr\n+\n+        if isinstance(attr.value, ast.Name):\n+            module_or_alias = attr.value.id\n+            actual_module = self.imports.get(module_or_alias, module_or_alias)\n+\n+            # If imported via \"from import\"\n+            if module_or_alias in self.from_imports:\n+                _, original_name = self.from_imports[module_or_alias]\n+                actual_module = original_name\n+\n+            return (actual_module, method_name) in RUNTIME_VARYING_CALLS\n+\n+        # Nested attribute (e.g., datetime.datetime.now)\n+        if isinstance(attr.value, ast.Attribute):\n+            inner_attr = attr.value\n+            if isinstance(inner_attr.value, ast.Name):\n+                return (inner_attr.attr, method_name) in RUNTIME_VARYING_CALLS\n+\n+        return False\n+\n+    def _is_runtime_varying_name_call(self, func: ast.Name) -> bool:",
      "comment": "```suggestion\n    def is_runtime_varying_name_call(self, func: ast.Name) -> bool:\n```",
      "comment_id": 2667558202,
      "user": "Lee-W",
      "created_at": "2026-01-07T08:48:05Z",
      "url": "https://github.com/apache/airflow/pull/59430#discussion_r2667558202"
    },
    {
      "repo": "apache/airflow",
      "pr_number": 59430,
      "file_path": "airflow-core/src/airflow/utils/dag_stability_checker.py",
      "line": 311,
      "side": "RIGHT",
      "diff_hunk": "@@ -0,0 +1,533 @@\n+# Licensed to the Apache Software Foundation (ASF) under one\n+# or more contributor license agreements.  See the NOTICE file\n+# distributed with this work for additional information\n+# regarding copyright ownership.  The ASF licenses this file\n+# to you under the Apache License, Version 2.0 (the\n+# \"License\"); you may not use this file except in compliance\n+# with the License.  You may obtain a copy of the License at\n+#\n+#   http://www.apache.org/licenses/LICENSE-2.0\n+#\n+# Unless required by applicable law or agreed to in writing,\n+# software distributed under the License is distributed on an\n+# \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+# KIND, either express or implied.  See the License for the\n+# specific language governing permissions and limitations\n+# under the License.\n+from __future__ import annotations\n+\n+import ast\n+from dataclasses import dataclass\n+from enum import Enum\n+from pathlib import Path\n+\n+RUNTIME_VARYING_CALLS = [\n+    (\"datetime\", \"now\"),\n+    (\"datetime\", \"today\"),\n+    (\"datetime\", \"utcnow\"),\n+    (\"date\", \"today\"),\n+    (\"time\", \"time\"),\n+    (\"time\", \"localtime\"),\n+    (\"random\", \"random\"),\n+    (\"random\", \"randint\"),\n+    (\"random\", \"choice\"),\n+    (\"random\", \"uniform\"),\n+    (\"uuid\", \"uuid4\"),\n+    (\"uuid\", \"uuid1\"),\n+    (\"pendulum\", \"now\"),\n+    (\"pendulum\", \"today\"),\n+    (\"pendulum\", \"yesterday\"),\n+    (\"pendulum\", \"tomorrow\"),\n+]\n+\n+\n+class DagStabilityCheckLevel(Enum):\n+    \"\"\"enum class for Dag stability check level.\"\"\"\n+\n+    off = \"off\"\n+    warning = \"warning\"\n+    error = \"error\"\n+\n+\n+class DagStabilityCheckerResult:\n+    \"\"\"\n+    Represents the result of stability analysis on a Dag file.\n+\n+    Stores detected warnings and formats them appropriately based on the configured check level\n+    (warning or error).\n+    \"\"\"\n+\n+    def __init__(self, check_level: DagStabilityCheckLevel):\n+        self.check_level: DagStabilityCheckLevel = check_level\n+        self.warnings: list[RuntimeVaryingValueWarning] = []\n+        self.runtime_varying_values: dict = {}\n+\n+    def format_warnings(self) -> str | None:\n+        \"\"\"Return formatted string of warning list.\"\"\"\n+        if not self.warnings:\n+            return None\n+\n+        lines = [\n+            \"This Dag uses runtime-variable values in Dag construction.\",\n+            \"It causes the Dag version to increase as values change on every Dag parse.\",\n+            \"\",\n+        ]\n+        for w in self.warnings:\n+            lines.extend(\n+                [\n+                    f\"Line {w.line}, Col {w.col}\",\n+                    f\"Code: {w.code}\",\n+                    f\"Issue: {w.message}\",\n+                    \"\",\n+                ]\n+            )\n+\n+        if self.runtime_varying_values:\n+            lines.extend(\n+                [\n+                    \"\ufe0fDon't use the variables as arguments in Dag/Task constructors:\",\n+                    *(\n+                        f\"  Line {line}: '{var_name}' related '{source}'\"\n+                        for var_name, (line, source) in sorted(\n+                            self.runtime_varying_values.items(),\n+                            key=lambda x: x[1][0],\n+                        )\n+                    ),\n+                    \"\",\n+                ]\n+            )\n+\n+        return \"\\n\".join(lines)\n+\n+    def get_warning_dag_format_dict(self, dag_ids: list[str]) -> list[dict[str, str | None]]:\n+        \"\"\"Convert warning statement to Dag warning format.\"\"\"\n+        from airflow.models.dagwarning import DagWarningType\n+\n+        if not self.warnings or self.check_level != DagStabilityCheckLevel.warning:\n+            return []\n+        return [\n+            {\n+                \"dag_id\": dag_id,\n+                \"warning_type\": DagWarningType.RUNTIME_VARYING_VALUE.value,\n+                \"message\": self.format_warnings(),\n+            }\n+            for dag_id in dag_ids\n+        ]\n+\n+    def get_error_format_dict(self, file_path, bundle_path):\n+        if not self.warnings or self.check_level != DagStabilityCheckLevel.error:\n+            return None\n+\n+        relative_file_path = str(Path(file_path).relative_to(bundle_path)) if bundle_path else file_path\n+        return {relative_file_path: self.format_warnings()}\n+\n+\n+@dataclass\n+class RuntimeVaryingValueWarning:\n+    \"\"\"Warning information for runtime-varying value detection.\"\"\"\n+\n+    line: int\n+    col: int\n+    code: str\n+    message: str\n+\n+\n+class WarningContext(str, Enum):\n+    \"\"\"Context types for warnings.\"\"\"\n+\n+    TASK_CONSTRUCTOR = \"Task constructor\"\n+    DAG_CONSTRUCTOR = \"Dag constructor\"\n+\n+\n+class RuntimeVaryingValueAnalyzer:\n+    \"\"\"\n+    Analyzer dedicated to tracking and detecting runtime-varying values.\n+\n+    This analyzer is responsible for identifying if a given AST node\n+    contains values that change on every execution (datetime.now(), random(), etc.).\n+    \"\"\"\n+\n+    def __init__(\n+        self,\n+        varying_vars: dict[str, tuple[int, str]],\n+        imports: dict[str, str],\n+        from_imports: dict[str, tuple[str, str]],\n+    ):\n+        self.varying_vars = varying_vars\n+        self.imports = imports\n+        self.from_imports = from_imports\n+\n+    def get_varying_source(self, node: ast.expr) -> str | None:\n+        \"\"\"\n+        Check if an AST node contains runtime-varying values and return the source.\n+\n+        Checks:\n+        - Runtime-varying function calls (datetime.now(), etc.)\n+        - Runtime-varying variable references\n+        - Runtime-varying values in f-strings\n+        - Runtime-varying values in expressions/collections\n+        \"\"\"\n+        # 1. Direct runtime-varying call\n+        if isinstance(node, ast.Call) and self.is_runtime_varying_call(node):\n+            return ast.unparse(node)\n+\n+        # 2. Runtime-varying variable reference\n+        if isinstance(node, ast.Name) and node.id in self.varying_vars:\n+            _, source = self.varying_vars[node.id]\n+            return source\n+\n+        # 3. f-string\n+        if isinstance(node, ast.JoinedStr):\n+            return self.get_varying_fstring(node)\n+\n+        # 4. Binary operation\n+        if isinstance(node, ast.BinOp):\n+            return self.get_varying_source(node.left) or self.get_varying_source(node.right)\n+\n+        # 5. Collections (list/tuple/set)\n+        if isinstance(node, (ast.List, ast.Tuple, ast.Set)):\n+            return self.get_varying_collection(node.elts)\n+\n+        # 6. List comprehension\n+        if isinstance(node, ast.ListComp):\n+            return self.get_varying_source(node.elt)\n+\n+        # 7. Dictionary\n+        if isinstance(node, ast.Dict):\n+            return self.get_varying_dict(node)\n+\n+        # 8. Method call chain\n+        if isinstance(node, ast.Call) and isinstance(node.func, ast.Attribute):\n+            return self.get_varying_source(node.func.value)\n+\n+        return None\n+\n+    def get_varying_fstring(self, node: ast.JoinedStr) -> str | None:\n+        \"\"\"Check for runtime-varying values inside f-strings.\"\"\"\n+        for value in node.values:\n+            if isinstance(value, ast.FormattedValue):\n+                if source := self.get_varying_source(value.value):\n+                    return source\n+        return None\n+\n+    def get_varying_collection(self, elements: list) -> str | None:\n+        \"\"\"Check for runtime-varying values in collection elements.\"\"\"\n+        for elt in elements:\n+            source = self.get_varying_source(elt)\n+            if source:\n+                return source\n+        return None\n+\n+    def get_varying_dict(self, node: ast.Dict) -> str | None:\n+        \"\"\"Check for runtime-varying values in dictionary keys/values.\"\"\"\n+        for key, value in zip(node.keys, node.values):\n+            if key:\n+                source = self.get_varying_source(key)\n+                if source:\n+                    return source\n+            if value:\n+                source = self.get_varying_source(value)\n+                if source:\n+                    return source\n+        return None\n+\n+    def is_runtime_varying_call(self, node: ast.Call) -> bool:\n+        \"\"\"\n+        Check if a call is runtime-varying.\n+\n+        1. Is the function itself runtime-varying?\n+        2. Do the arguments contain runtime-varying values?\n+        \"\"\"\n+        # Check if the function itself is runtime-varying\n+        if isinstance(node.func, ast.Attribute):\n+            if self._is_runtime_varying_attribute_call(node.func):\n+                return True\n+        elif isinstance(node.func, ast.Name):\n+            if self._is_runtime_varying_name_call(node.func):\n+                return True\n+\n+        # Check if arguments contain runtime-varying values\n+        return self._has_varying_arguments(node)\n+\n+    def _has_varying_arguments(self, node: ast.Call) -> bool:\n+        \"\"\"Check if function arguments contain runtime-varying values.\"\"\"\n+        for arg in node.args:\n+            if self.get_varying_source(arg):\n+                return True\n+\n+        for kw in node.keywords:\n+            if self.get_varying_source(kw.value):\n+                return True\n+\n+        return False\n+\n+    def _is_runtime_varying_attribute_call(self, attr: ast.Attribute) -> bool:\n+        \"\"\"Check for runtime-varying calls like datetime.now().\"\"\"\n+        method_name = attr.attr\n+\n+        if isinstance(attr.value, ast.Name):\n+            module_or_alias = attr.value.id\n+            actual_module = self.imports.get(module_or_alias, module_or_alias)\n+\n+            # If imported via \"from import\"\n+            if module_or_alias in self.from_imports:\n+                _, original_name = self.from_imports[module_or_alias]\n+                actual_module = original_name\n+\n+            return (actual_module, method_name) in RUNTIME_VARYING_CALLS\n+\n+        # Nested attribute (e.g., datetime.datetime.now)\n+        if isinstance(attr.value, ast.Attribute):\n+            inner_attr = attr.value\n+            if isinstance(inner_attr.value, ast.Name):\n+                return (inner_attr.attr, method_name) in RUNTIME_VARYING_CALLS\n+\n+        return False\n+\n+    def _is_runtime_varying_name_call(self, func: ast.Name) -> bool:\n+        \"\"\"Check for runtime-varying calls like now() (when imported via 'from import').\"\"\"\n+        func_name = func.id\n+\n+        if func_name in self.from_imports:\n+            module, original_name = self.from_imports[func_name]\n+            module_parts = module.split(\".\")\n+\n+            for part in module_parts:\n+                if (part, original_name) in RUNTIME_VARYING_CALLS:\n+                    return True\n+\n+        return False\n+\n+\n+class DagTaskDetector:\n+    \"\"\"\n+    Detector dedicated to identifying Dag and Task constructors.\n+\n+    This detector identifies when code is creating Dag or Task objects\n+    in Airflow. It needs to handle both traditional class instantiation and decorator styles.\n+    \"\"\"\n+\n+    def __init__(self, from_imports: dict):\n+        self.from_imports = from_imports",
      "comment": "```suggestion\n        self.from_imports: dict[str, tuple[str, str]] = from_imports\n```",
      "comment_id": 2667560913,
      "user": "Lee-W",
      "created_at": "2026-01-07T08:49:05Z",
      "url": "https://github.com/apache/airflow/pull/59430#discussion_r2667560913"
    },
    {
      "repo": "apache/airflow",
      "pr_number": 59430,
      "file_path": "airflow-core/src/airflow/utils/dag_stability_checker.py",
      "line": 310,
      "side": "RIGHT",
      "diff_hunk": "@@ -0,0 +1,533 @@\n+# Licensed to the Apache Software Foundation (ASF) under one\n+# or more contributor license agreements.  See the NOTICE file\n+# distributed with this work for additional information\n+# regarding copyright ownership.  The ASF licenses this file\n+# to you under the Apache License, Version 2.0 (the\n+# \"License\"); you may not use this file except in compliance\n+# with the License.  You may obtain a copy of the License at\n+#\n+#   http://www.apache.org/licenses/LICENSE-2.0\n+#\n+# Unless required by applicable law or agreed to in writing,\n+# software distributed under the License is distributed on an\n+# \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+# KIND, either express or implied.  See the License for the\n+# specific language governing permissions and limitations\n+# under the License.\n+from __future__ import annotations\n+\n+import ast\n+from dataclasses import dataclass\n+from enum import Enum\n+from pathlib import Path\n+\n+RUNTIME_VARYING_CALLS = [\n+    (\"datetime\", \"now\"),\n+    (\"datetime\", \"today\"),\n+    (\"datetime\", \"utcnow\"),\n+    (\"date\", \"today\"),\n+    (\"time\", \"time\"),\n+    (\"time\", \"localtime\"),\n+    (\"random\", \"random\"),\n+    (\"random\", \"randint\"),\n+    (\"random\", \"choice\"),\n+    (\"random\", \"uniform\"),\n+    (\"uuid\", \"uuid4\"),\n+    (\"uuid\", \"uuid1\"),\n+    (\"pendulum\", \"now\"),\n+    (\"pendulum\", \"today\"),\n+    (\"pendulum\", \"yesterday\"),\n+    (\"pendulum\", \"tomorrow\"),\n+]\n+\n+\n+class DagStabilityCheckLevel(Enum):\n+    \"\"\"enum class for Dag stability check level.\"\"\"\n+\n+    off = \"off\"\n+    warning = \"warning\"\n+    error = \"error\"\n+\n+\n+class DagStabilityCheckerResult:\n+    \"\"\"\n+    Represents the result of stability analysis on a Dag file.\n+\n+    Stores detected warnings and formats them appropriately based on the configured check level\n+    (warning or error).\n+    \"\"\"\n+\n+    def __init__(self, check_level: DagStabilityCheckLevel):\n+        self.check_level: DagStabilityCheckLevel = check_level\n+        self.warnings: list[RuntimeVaryingValueWarning] = []\n+        self.runtime_varying_values: dict = {}\n+\n+    def format_warnings(self) -> str | None:\n+        \"\"\"Return formatted string of warning list.\"\"\"\n+        if not self.warnings:\n+            return None\n+\n+        lines = [\n+            \"This Dag uses runtime-variable values in Dag construction.\",\n+            \"It causes the Dag version to increase as values change on every Dag parse.\",\n+            \"\",\n+        ]\n+        for w in self.warnings:\n+            lines.extend(\n+                [\n+                    f\"Line {w.line}, Col {w.col}\",\n+                    f\"Code: {w.code}\",\n+                    f\"Issue: {w.message}\",\n+                    \"\",\n+                ]\n+            )\n+\n+        if self.runtime_varying_values:\n+            lines.extend(\n+                [\n+                    \"\ufe0fDon't use the variables as arguments in Dag/Task constructors:\",\n+                    *(\n+                        f\"  Line {line}: '{var_name}' related '{source}'\"\n+                        for var_name, (line, source) in sorted(\n+                            self.runtime_varying_values.items(),\n+                            key=lambda x: x[1][0],\n+                        )\n+                    ),\n+                    \"\",\n+                ]\n+            )\n+\n+        return \"\\n\".join(lines)\n+\n+    def get_warning_dag_format_dict(self, dag_ids: list[str]) -> list[dict[str, str | None]]:\n+        \"\"\"Convert warning statement to Dag warning format.\"\"\"\n+        from airflow.models.dagwarning import DagWarningType\n+\n+        if not self.warnings or self.check_level != DagStabilityCheckLevel.warning:\n+            return []\n+        return [\n+            {\n+                \"dag_id\": dag_id,\n+                \"warning_type\": DagWarningType.RUNTIME_VARYING_VALUE.value,\n+                \"message\": self.format_warnings(),\n+            }\n+            for dag_id in dag_ids\n+        ]\n+\n+    def get_error_format_dict(self, file_path, bundle_path):\n+        if not self.warnings or self.check_level != DagStabilityCheckLevel.error:\n+            return None\n+\n+        relative_file_path = str(Path(file_path).relative_to(bundle_path)) if bundle_path else file_path\n+        return {relative_file_path: self.format_warnings()}\n+\n+\n+@dataclass\n+class RuntimeVaryingValueWarning:\n+    \"\"\"Warning information for runtime-varying value detection.\"\"\"\n+\n+    line: int\n+    col: int\n+    code: str\n+    message: str\n+\n+\n+class WarningContext(str, Enum):\n+    \"\"\"Context types for warnings.\"\"\"\n+\n+    TASK_CONSTRUCTOR = \"Task constructor\"\n+    DAG_CONSTRUCTOR = \"Dag constructor\"\n+\n+\n+class RuntimeVaryingValueAnalyzer:\n+    \"\"\"\n+    Analyzer dedicated to tracking and detecting runtime-varying values.\n+\n+    This analyzer is responsible for identifying if a given AST node\n+    contains values that change on every execution (datetime.now(), random(), etc.).\n+    \"\"\"\n+\n+    def __init__(\n+        self,\n+        varying_vars: dict[str, tuple[int, str]],\n+        imports: dict[str, str],\n+        from_imports: dict[str, tuple[str, str]],\n+    ):\n+        self.varying_vars = varying_vars\n+        self.imports = imports\n+        self.from_imports = from_imports\n+\n+    def get_varying_source(self, node: ast.expr) -> str | None:\n+        \"\"\"\n+        Check if an AST node contains runtime-varying values and return the source.\n+\n+        Checks:\n+        - Runtime-varying function calls (datetime.now(), etc.)\n+        - Runtime-varying variable references\n+        - Runtime-varying values in f-strings\n+        - Runtime-varying values in expressions/collections\n+        \"\"\"\n+        # 1. Direct runtime-varying call\n+        if isinstance(node, ast.Call) and self.is_runtime_varying_call(node):\n+            return ast.unparse(node)\n+\n+        # 2. Runtime-varying variable reference\n+        if isinstance(node, ast.Name) and node.id in self.varying_vars:\n+            _, source = self.varying_vars[node.id]\n+            return source\n+\n+        # 3. f-string\n+        if isinstance(node, ast.JoinedStr):\n+            return self.get_varying_fstring(node)\n+\n+        # 4. Binary operation\n+        if isinstance(node, ast.BinOp):\n+            return self.get_varying_source(node.left) or self.get_varying_source(node.right)\n+\n+        # 5. Collections (list/tuple/set)\n+        if isinstance(node, (ast.List, ast.Tuple, ast.Set)):\n+            return self.get_varying_collection(node.elts)\n+\n+        # 6. List comprehension\n+        if isinstance(node, ast.ListComp):\n+            return self.get_varying_source(node.elt)\n+\n+        # 7. Dictionary\n+        if isinstance(node, ast.Dict):\n+            return self.get_varying_dict(node)\n+\n+        # 8. Method call chain\n+        if isinstance(node, ast.Call) and isinstance(node.func, ast.Attribute):\n+            return self.get_varying_source(node.func.value)\n+\n+        return None\n+\n+    def get_varying_fstring(self, node: ast.JoinedStr) -> str | None:\n+        \"\"\"Check for runtime-varying values inside f-strings.\"\"\"\n+        for value in node.values:\n+            if isinstance(value, ast.FormattedValue):\n+                if source := self.get_varying_source(value.value):\n+                    return source\n+        return None\n+\n+    def get_varying_collection(self, elements: list) -> str | None:\n+        \"\"\"Check for runtime-varying values in collection elements.\"\"\"\n+        for elt in elements:\n+            source = self.get_varying_source(elt)\n+            if source:\n+                return source\n+        return None\n+\n+    def get_varying_dict(self, node: ast.Dict) -> str | None:\n+        \"\"\"Check for runtime-varying values in dictionary keys/values.\"\"\"\n+        for key, value in zip(node.keys, node.values):\n+            if key:\n+                source = self.get_varying_source(key)\n+                if source:\n+                    return source\n+            if value:\n+                source = self.get_varying_source(value)\n+                if source:\n+                    return source\n+        return None\n+\n+    def is_runtime_varying_call(self, node: ast.Call) -> bool:\n+        \"\"\"\n+        Check if a call is runtime-varying.\n+\n+        1. Is the function itself runtime-varying?\n+        2. Do the arguments contain runtime-varying values?\n+        \"\"\"\n+        # Check if the function itself is runtime-varying\n+        if isinstance(node.func, ast.Attribute):\n+            if self._is_runtime_varying_attribute_call(node.func):\n+                return True\n+        elif isinstance(node.func, ast.Name):\n+            if self._is_runtime_varying_name_call(node.func):\n+                return True\n+\n+        # Check if arguments contain runtime-varying values\n+        return self._has_varying_arguments(node)\n+\n+    def _has_varying_arguments(self, node: ast.Call) -> bool:\n+        \"\"\"Check if function arguments contain runtime-varying values.\"\"\"\n+        for arg in node.args:\n+            if self.get_varying_source(arg):\n+                return True\n+\n+        for kw in node.keywords:\n+            if self.get_varying_source(kw.value):\n+                return True\n+\n+        return False\n+\n+    def _is_runtime_varying_attribute_call(self, attr: ast.Attribute) -> bool:\n+        \"\"\"Check for runtime-varying calls like datetime.now().\"\"\"\n+        method_name = attr.attr\n+\n+        if isinstance(attr.value, ast.Name):\n+            module_or_alias = attr.value.id\n+            actual_module = self.imports.get(module_or_alias, module_or_alias)\n+\n+            # If imported via \"from import\"\n+            if module_or_alias in self.from_imports:\n+                _, original_name = self.from_imports[module_or_alias]\n+                actual_module = original_name\n+\n+            return (actual_module, method_name) in RUNTIME_VARYING_CALLS\n+\n+        # Nested attribute (e.g., datetime.datetime.now)\n+        if isinstance(attr.value, ast.Attribute):\n+            inner_attr = attr.value\n+            if isinstance(inner_attr.value, ast.Name):\n+                return (inner_attr.attr, method_name) in RUNTIME_VARYING_CALLS\n+\n+        return False\n+\n+    def _is_runtime_varying_name_call(self, func: ast.Name) -> bool:\n+        \"\"\"Check for runtime-varying calls like now() (when imported via 'from import').\"\"\"\n+        func_name = func.id\n+\n+        if func_name in self.from_imports:\n+            module, original_name = self.from_imports[func_name]\n+            module_parts = module.split(\".\")\n+\n+            for part in module_parts:\n+                if (part, original_name) in RUNTIME_VARYING_CALLS:\n+                    return True\n+\n+        return False\n+\n+\n+class DagTaskDetector:\n+    \"\"\"\n+    Detector dedicated to identifying Dag and Task constructors.\n+\n+    This detector identifies when code is creating Dag or Task objects\n+    in Airflow. It needs to handle both traditional class instantiation and decorator styles.\n+    \"\"\"\n+\n+    def __init__(self, from_imports: dict):",
      "comment": "```suggestion\n    def __init__(self, from_imports: dict[str, tuple[str, str]]):\n```",
      "comment_id": 2667561129,
      "user": "Lee-W",
      "created_at": "2026-01-07T08:49:09Z",
      "url": "https://github.com/apache/airflow/pull/59430#discussion_r2667561129"
    },
    {
      "repo": "apache/airflow",
      "pr_number": 59430,
      "file_path": "airflow-core/src/airflow/utils/dag_stability_checker.py",
      "line": 492,
      "side": "RIGHT",
      "diff_hunk": "@@ -0,0 +1,533 @@\n+# Licensed to the Apache Software Foundation (ASF) under one\n+# or more contributor license agreements.  See the NOTICE file\n+# distributed with this work for additional information\n+# regarding copyright ownership.  The ASF licenses this file\n+# to you under the Apache License, Version 2.0 (the\n+# \"License\"); you may not use this file except in compliance\n+# with the License.  You may obtain a copy of the License at\n+#\n+#   http://www.apache.org/licenses/LICENSE-2.0\n+#\n+# Unless required by applicable law or agreed to in writing,\n+# software distributed under the License is distributed on an\n+# \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+# KIND, either express or implied.  See the License for the\n+# specific language governing permissions and limitations\n+# under the License.\n+from __future__ import annotations\n+\n+import ast\n+from dataclasses import dataclass\n+from enum import Enum\n+from pathlib import Path\n+\n+RUNTIME_VARYING_CALLS = [\n+    (\"datetime\", \"now\"),\n+    (\"datetime\", \"today\"),\n+    (\"datetime\", \"utcnow\"),\n+    (\"date\", \"today\"),\n+    (\"time\", \"time\"),\n+    (\"time\", \"localtime\"),\n+    (\"random\", \"random\"),\n+    (\"random\", \"randint\"),\n+    (\"random\", \"choice\"),\n+    (\"random\", \"uniform\"),\n+    (\"uuid\", \"uuid4\"),\n+    (\"uuid\", \"uuid1\"),\n+    (\"pendulum\", \"now\"),\n+    (\"pendulum\", \"today\"),\n+    (\"pendulum\", \"yesterday\"),\n+    (\"pendulum\", \"tomorrow\"),\n+]\n+\n+\n+class DagStabilityCheckLevel(Enum):\n+    \"\"\"enum class for Dag stability check level.\"\"\"\n+\n+    off = \"off\"\n+    warning = \"warning\"\n+    error = \"error\"\n+\n+\n+class DagStabilityCheckerResult:\n+    \"\"\"\n+    Represents the result of stability analysis on a Dag file.\n+\n+    Stores detected warnings and formats them appropriately based on the configured check level\n+    (warning or error).\n+    \"\"\"\n+\n+    def __init__(self, check_level: DagStabilityCheckLevel):\n+        self.check_level: DagStabilityCheckLevel = check_level\n+        self.warnings: list[RuntimeVaryingValueWarning] = []\n+        self.runtime_varying_values: dict = {}\n+\n+    def format_warnings(self) -> str | None:\n+        \"\"\"Return formatted string of warning list.\"\"\"\n+        if not self.warnings:\n+            return None\n+\n+        lines = [\n+            \"This Dag uses runtime-variable values in Dag construction.\",\n+            \"It causes the Dag version to increase as values change on every Dag parse.\",\n+            \"\",\n+        ]\n+        for w in self.warnings:\n+            lines.extend(\n+                [\n+                    f\"Line {w.line}, Col {w.col}\",\n+                    f\"Code: {w.code}\",\n+                    f\"Issue: {w.message}\",\n+                    \"\",\n+                ]\n+            )\n+\n+        if self.runtime_varying_values:\n+            lines.extend(\n+                [\n+                    \"\ufe0fDon't use the variables as arguments in Dag/Task constructors:\",\n+                    *(\n+                        f\"  Line {line}: '{var_name}' related '{source}'\"\n+                        for var_name, (line, source) in sorted(\n+                            self.runtime_varying_values.items(),\n+                            key=lambda x: x[1][0],\n+                        )\n+                    ),\n+                    \"\",\n+                ]\n+            )\n+\n+        return \"\\n\".join(lines)\n+\n+    def get_warning_dag_format_dict(self, dag_ids: list[str]) -> list[dict[str, str | None]]:\n+        \"\"\"Convert warning statement to Dag warning format.\"\"\"\n+        from airflow.models.dagwarning import DagWarningType\n+\n+        if not self.warnings or self.check_level != DagStabilityCheckLevel.warning:\n+            return []\n+        return [\n+            {\n+                \"dag_id\": dag_id,\n+                \"warning_type\": DagWarningType.RUNTIME_VARYING_VALUE.value,\n+                \"message\": self.format_warnings(),\n+            }\n+            for dag_id in dag_ids\n+        ]\n+\n+    def get_error_format_dict(self, file_path, bundle_path):\n+        if not self.warnings or self.check_level != DagStabilityCheckLevel.error:\n+            return None\n+\n+        relative_file_path = str(Path(file_path).relative_to(bundle_path)) if bundle_path else file_path\n+        return {relative_file_path: self.format_warnings()}\n+\n+\n+@dataclass\n+class RuntimeVaryingValueWarning:\n+    \"\"\"Warning information for runtime-varying value detection.\"\"\"\n+\n+    line: int\n+    col: int\n+    code: str\n+    message: str\n+\n+\n+class WarningContext(str, Enum):\n+    \"\"\"Context types for warnings.\"\"\"\n+\n+    TASK_CONSTRUCTOR = \"Task constructor\"\n+    DAG_CONSTRUCTOR = \"Dag constructor\"\n+\n+\n+class RuntimeVaryingValueAnalyzer:\n+    \"\"\"\n+    Analyzer dedicated to tracking and detecting runtime-varying values.\n+\n+    This analyzer is responsible for identifying if a given AST node\n+    contains values that change on every execution (datetime.now(), random(), etc.).\n+    \"\"\"\n+\n+    def __init__(\n+        self,\n+        varying_vars: dict[str, tuple[int, str]],\n+        imports: dict[str, str],\n+        from_imports: dict[str, tuple[str, str]],\n+    ):\n+        self.varying_vars = varying_vars\n+        self.imports = imports\n+        self.from_imports = from_imports\n+\n+    def get_varying_source(self, node: ast.expr) -> str | None:\n+        \"\"\"\n+        Check if an AST node contains runtime-varying values and return the source.\n+\n+        Checks:\n+        - Runtime-varying function calls (datetime.now(), etc.)\n+        - Runtime-varying variable references\n+        - Runtime-varying values in f-strings\n+        - Runtime-varying values in expressions/collections\n+        \"\"\"\n+        # 1. Direct runtime-varying call\n+        if isinstance(node, ast.Call) and self.is_runtime_varying_call(node):\n+            return ast.unparse(node)\n+\n+        # 2. Runtime-varying variable reference\n+        if isinstance(node, ast.Name) and node.id in self.varying_vars:\n+            _, source = self.varying_vars[node.id]\n+            return source\n+\n+        # 3. f-string\n+        if isinstance(node, ast.JoinedStr):\n+            return self.get_varying_fstring(node)\n+\n+        # 4. Binary operation\n+        if isinstance(node, ast.BinOp):\n+            return self.get_varying_source(node.left) or self.get_varying_source(node.right)\n+\n+        # 5. Collections (list/tuple/set)\n+        if isinstance(node, (ast.List, ast.Tuple, ast.Set)):\n+            return self.get_varying_collection(node.elts)\n+\n+        # 6. List comprehension\n+        if isinstance(node, ast.ListComp):\n+            return self.get_varying_source(node.elt)\n+\n+        # 7. Dictionary\n+        if isinstance(node, ast.Dict):\n+            return self.get_varying_dict(node)\n+\n+        # 8. Method call chain\n+        if isinstance(node, ast.Call) and isinstance(node.func, ast.Attribute):\n+            return self.get_varying_source(node.func.value)\n+\n+        return None\n+\n+    def get_varying_fstring(self, node: ast.JoinedStr) -> str | None:\n+        \"\"\"Check for runtime-varying values inside f-strings.\"\"\"\n+        for value in node.values:\n+            if isinstance(value, ast.FormattedValue):\n+                if source := self.get_varying_source(value.value):\n+                    return source\n+        return None\n+\n+    def get_varying_collection(self, elements: list) -> str | None:\n+        \"\"\"Check for runtime-varying values in collection elements.\"\"\"\n+        for elt in elements:\n+            source = self.get_varying_source(elt)\n+            if source:\n+                return source\n+        return None\n+\n+    def get_varying_dict(self, node: ast.Dict) -> str | None:\n+        \"\"\"Check for runtime-varying values in dictionary keys/values.\"\"\"\n+        for key, value in zip(node.keys, node.values):\n+            if key:\n+                source = self.get_varying_source(key)\n+                if source:\n+                    return source\n+            if value:\n+                source = self.get_varying_source(value)\n+                if source:\n+                    return source\n+        return None\n+\n+    def is_runtime_varying_call(self, node: ast.Call) -> bool:\n+        \"\"\"\n+        Check if a call is runtime-varying.\n+\n+        1. Is the function itself runtime-varying?\n+        2. Do the arguments contain runtime-varying values?\n+        \"\"\"\n+        # Check if the function itself is runtime-varying\n+        if isinstance(node.func, ast.Attribute):\n+            if self._is_runtime_varying_attribute_call(node.func):\n+                return True\n+        elif isinstance(node.func, ast.Name):\n+            if self._is_runtime_varying_name_call(node.func):\n+                return True\n+\n+        # Check if arguments contain runtime-varying values\n+        return self._has_varying_arguments(node)\n+\n+    def _has_varying_arguments(self, node: ast.Call) -> bool:\n+        \"\"\"Check if function arguments contain runtime-varying values.\"\"\"\n+        for arg in node.args:\n+            if self.get_varying_source(arg):\n+                return True\n+\n+        for kw in node.keywords:\n+            if self.get_varying_source(kw.value):\n+                return True\n+\n+        return False\n+\n+    def _is_runtime_varying_attribute_call(self, attr: ast.Attribute) -> bool:\n+        \"\"\"Check for runtime-varying calls like datetime.now().\"\"\"\n+        method_name = attr.attr\n+\n+        if isinstance(attr.value, ast.Name):\n+            module_or_alias = attr.value.id\n+            actual_module = self.imports.get(module_or_alias, module_or_alias)\n+\n+            # If imported via \"from import\"\n+            if module_or_alias in self.from_imports:\n+                _, original_name = self.from_imports[module_or_alias]\n+                actual_module = original_name\n+\n+            return (actual_module, method_name) in RUNTIME_VARYING_CALLS\n+\n+        # Nested attribute (e.g., datetime.datetime.now)\n+        if isinstance(attr.value, ast.Attribute):\n+            inner_attr = attr.value\n+            if isinstance(inner_attr.value, ast.Name):\n+                return (inner_attr.attr, method_name) in RUNTIME_VARYING_CALLS\n+\n+        return False\n+\n+    def _is_runtime_varying_name_call(self, func: ast.Name) -> bool:\n+        \"\"\"Check for runtime-varying calls like now() (when imported via 'from import').\"\"\"\n+        func_name = func.id\n+\n+        if func_name in self.from_imports:\n+            module, original_name = self.from_imports[func_name]\n+            module_parts = module.split(\".\")\n+\n+            for part in module_parts:\n+                if (part, original_name) in RUNTIME_VARYING_CALLS:\n+                    return True\n+\n+        return False\n+\n+\n+class DagTaskDetector:\n+    \"\"\"\n+    Detector dedicated to identifying Dag and Task constructors.\n+\n+    This detector identifies when code is creating Dag or Task objects\n+    in Airflow. It needs to handle both traditional class instantiation and decorator styles.\n+    \"\"\"\n+\n+    def __init__(self, from_imports: dict):\n+        self.from_imports = from_imports\n+        self.dag_instances: set[str] = set()\n+        self.is_in_dag_context: bool = False\n+\n+    def is_dag_constructor(self, node: ast.Call) -> bool:\n+        \"\"\"Check if a call is a Dag constructor.\"\"\"\n+        if not isinstance(node.func, ast.Name):\n+            return False\n+\n+        func_name = node.func.id\n+\n+        # \"from airflow import DAG\" form or \"from airflow.decorator import dag\"\n+        if func_name in self.from_imports:\n+            module, original = self.from_imports[func_name]\n+            if (module == \"airflow\" or module.startswith(\"airflow.\")) and original in (\"DAG\", \"dag\"):\n+                return True\n+\n+        return False\n+\n+    def is_task_constructor(self, node: ast.Call) -> bool:\n+        \"\"\"\n+        Check if a call is a Task constructor.\n+\n+        Criteria:\n+        1. All calls within a Dag with block\n+        2. Calls that receive a Dag instance as an argument (dag=...)\n+        \"\"\"\n+        # Inside Dag with block\n+        if self.is_in_dag_context:\n+            return True\n+\n+        # Passing Dag instance as argument\n+        for arg in node.args:\n+            if isinstance(arg, ast.Name) and arg.id in self.dag_instances:\n+                return True\n+\n+        for keyword in node.keywords:\n+            if keyword.value and isinstance(keyword.value, ast.Name):\n+                if keyword.value.id in self.dag_instances:\n+                    return True\n+\n+        return False\n+\n+    def register_dag_instance(self, var_name: str):\n+        \"\"\"Register a Dag instance variable name.\"\"\"\n+        self.dag_instances.add(var_name)\n+\n+    def enter_dag_context(self):\n+        \"\"\"Enter a Dag with block.\"\"\"\n+        self.is_in_dag_context = True\n+\n+    def exit_dag_context(self):\n+        \"\"\"Exit a Dag with block.\"\"\"\n+        self.is_in_dag_context = False\n+\n+\n+class AirflowRuntimeVaryingValueChecker(ast.NodeVisitor):\n+    \"\"\"\n+    Main visitor class to detect runtime-varying value usage in Airflow Dag/Task.\n+\n+    Main responsibilities:\n+    - Traverse AST and visit nodes\n+    - Detect Dag/Task creation\n+    - Track runtime-varying values and generate warnings\n+    \"\"\"\n+\n+    def __init__(self, check_level: DagStabilityCheckLevel = DagStabilityCheckLevel.warning):\n+        self.static_check_result: DagStabilityCheckerResult = DagStabilityCheckerResult(\n+            check_level=check_level\n+        )\n+        self.imports: dict[str, str] = {}\n+        self.from_imports: dict[str, tuple[str, str]] = {}\n+        self.varying_vars: dict[str, tuple[int, str]] = {}\n+        self.check_level = check_level\n+\n+        # Helper objects\n+        self.value_analyzer = RuntimeVaryingValueAnalyzer(self.varying_vars, self.imports, self.from_imports)\n+        self.dag_detector = DagTaskDetector(self.from_imports)\n+\n+    def visit_Import(self, node: ast.Import):\n+        \"\"\"Process import statements.\"\"\"\n+        for alias in node.names:\n+            name = alias.asname or alias.name\n+            self.imports[name] = alias.name\n+\n+    def visit_ImportFrom(self, node: ast.ImportFrom):\n+        \"\"\"Process from ... import statements.\"\"\"\n+        if node.module:\n+            for alias in node.names:\n+                name = alias.asname or alias.name\n+                self.from_imports[name] = (node.module, alias.name)\n+\n+    def visit_Assign(self, node: ast.Assign):\n+        \"\"\"\n+        Process variable assignments.\n+\n+        Checks:\n+        1. Dag instance assignment\n+        2. Task instance assignment\n+        3. Runtime-varying value assignment\n+        \"\"\"\n+        value = node.value\n+\n+        # Dag constructor\n+        if isinstance(value, ast.Call) and self.dag_detector.is_dag_constructor(value):\n+            self._register_dag_instances(node.targets)\n+            self._check_and_warn(value, WarningContext.DAG_CONSTRUCTOR)\n+\n+        # Task constructor\n+        elif isinstance(value, ast.Call) and self.dag_detector.is_task_constructor(value):\n+            self._check_and_warn(value, WarningContext.TASK_CONSTRUCTOR)\n+\n+        # Track runtime-varying values\n+        else:\n+            self._track_varying_assignment(node)\n+\n+    def visit_Call(self, node: ast.Call):\n+        \"\"\"\n+        Process function calls.\n+\n+        Check not assign but just call the function or Dag definition via decorator.\n+        \"\"\"\n+        if self.dag_detector.is_dag_constructor(node):\n+            self._check_and_warn(node, WarningContext.DAG_CONSTRUCTOR)\n+\n+        elif self.dag_detector.is_task_constructor(node):\n+            self._check_and_warn(node, WarningContext.TASK_CONSTRUCTOR)\n+\n+    def visit_For(self, node: ast.For):\n+        \"\"\"\n+        Process for statements.\n+\n+        Check if iteration target contains runtime-varying values.\n+        \"\"\"\n+        # check the iterator value is runtime-varying\n+        # iter is runtime-varying : for iter in [datetime.now(), 3]\n+        varying_source = self.value_analyzer.get_varying_source(node.iter)\n+        if varying_source:\n+            if isinstance(node.target, ast.Name):\n+                self.varying_vars[node.target.id] = (node.lineno, varying_source)\n+\n+        for body in node.body:\n+            self.visit(body)\n+\n+        if varying_source:\n+            if isinstance(node.target, ast.Name):\n+                self.varying_vars.pop(node.target.id)\n+\n+    def visit_With(self, node: ast.With):\n+        \"\"\"\n+        Process with statements.\n+\n+        Detect Dag context manager.\n+        \"\"\"\n+        is_with_dag_context = False\n+        for item in node.items:\n+            # check if the Dag instance exists in with context\n+            self.visit(item)\n+            if isinstance(item.context_expr, ast.Call):\n+                if self.dag_detector.is_dag_constructor(item.context_expr):\n+                    # check the value defined in with statement to detect entering Dag with block\n+                    is_with_dag_context = True\n+\n+        if is_with_dag_context:\n+            self.dag_detector.enter_dag_context()\n+\n+        for body in node.body:\n+            self.visit(body)\n+\n+        # Exit Dag with block\n+        self.dag_detector.exit_dag_context()\n+\n+    def _register_dag_instances(self, targets: list):\n+        \"\"\"Register Dag instance variable names.\"\"\"\n+        for target in targets:\n+            if isinstance(target, ast.Name):\n+                self.dag_detector.register_dag_instance(target.id)\n+\n+    def _track_varying_assignment(self, node: ast.Assign):\n+        \"\"\"Track variable assignments with runtime-varying values.\"\"\"\n+        varying_source = self.value_analyzer.get_varying_source(node.value)\n+        if varying_source:",
      "comment": "```suggestion\n        if (varying_source := self.value_analyzer.get_varying_source(node.value)):\n```",
      "comment_id": 2667573340,
      "user": "Lee-W",
      "created_at": "2026-01-07T08:53:21Z",
      "url": "https://github.com/apache/airflow/pull/59430#discussion_r2667573340"
    },
    {
      "repo": "apache/airflow",
      "pr_number": 59430,
      "file_path": "airflow-core/src/airflow/utils/dag_stability_checker.py",
      "line": 510,
      "side": "RIGHT",
      "diff_hunk": "@@ -0,0 +1,533 @@\n+# Licensed to the Apache Software Foundation (ASF) under one\n+# or more contributor license agreements.  See the NOTICE file\n+# distributed with this work for additional information\n+# regarding copyright ownership.  The ASF licenses this file\n+# to you under the Apache License, Version 2.0 (the\n+# \"License\"); you may not use this file except in compliance\n+# with the License.  You may obtain a copy of the License at\n+#\n+#   http://www.apache.org/licenses/LICENSE-2.0\n+#\n+# Unless required by applicable law or agreed to in writing,\n+# software distributed under the License is distributed on an\n+# \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+# KIND, either express or implied.  See the License for the\n+# specific language governing permissions and limitations\n+# under the License.\n+from __future__ import annotations\n+\n+import ast\n+from dataclasses import dataclass\n+from enum import Enum\n+from pathlib import Path\n+\n+RUNTIME_VARYING_CALLS = [\n+    (\"datetime\", \"now\"),\n+    (\"datetime\", \"today\"),\n+    (\"datetime\", \"utcnow\"),\n+    (\"date\", \"today\"),\n+    (\"time\", \"time\"),\n+    (\"time\", \"localtime\"),\n+    (\"random\", \"random\"),\n+    (\"random\", \"randint\"),\n+    (\"random\", \"choice\"),\n+    (\"random\", \"uniform\"),\n+    (\"uuid\", \"uuid4\"),\n+    (\"uuid\", \"uuid1\"),\n+    (\"pendulum\", \"now\"),\n+    (\"pendulum\", \"today\"),\n+    (\"pendulum\", \"yesterday\"),\n+    (\"pendulum\", \"tomorrow\"),\n+]\n+\n+\n+class DagStabilityCheckLevel(Enum):\n+    \"\"\"enum class for Dag stability check level.\"\"\"\n+\n+    off = \"off\"\n+    warning = \"warning\"\n+    error = \"error\"\n+\n+\n+class DagStabilityCheckerResult:\n+    \"\"\"\n+    Represents the result of stability analysis on a Dag file.\n+\n+    Stores detected warnings and formats them appropriately based on the configured check level\n+    (warning or error).\n+    \"\"\"\n+\n+    def __init__(self, check_level: DagStabilityCheckLevel):\n+        self.check_level: DagStabilityCheckLevel = check_level\n+        self.warnings: list[RuntimeVaryingValueWarning] = []\n+        self.runtime_varying_values: dict = {}\n+\n+    def format_warnings(self) -> str | None:\n+        \"\"\"Return formatted string of warning list.\"\"\"\n+        if not self.warnings:\n+            return None\n+\n+        lines = [\n+            \"This Dag uses runtime-variable values in Dag construction.\",\n+            \"It causes the Dag version to increase as values change on every Dag parse.\",\n+            \"\",\n+        ]\n+        for w in self.warnings:\n+            lines.extend(\n+                [\n+                    f\"Line {w.line}, Col {w.col}\",\n+                    f\"Code: {w.code}\",\n+                    f\"Issue: {w.message}\",\n+                    \"\",\n+                ]\n+            )\n+\n+        if self.runtime_varying_values:\n+            lines.extend(\n+                [\n+                    \"\ufe0fDon't use the variables as arguments in Dag/Task constructors:\",\n+                    *(\n+                        f\"  Line {line}: '{var_name}' related '{source}'\"\n+                        for var_name, (line, source) in sorted(\n+                            self.runtime_varying_values.items(),\n+                            key=lambda x: x[1][0],\n+                        )\n+                    ),\n+                    \"\",\n+                ]\n+            )\n+\n+        return \"\\n\".join(lines)\n+\n+    def get_warning_dag_format_dict(self, dag_ids: list[str]) -> list[dict[str, str | None]]:\n+        \"\"\"Convert warning statement to Dag warning format.\"\"\"\n+        from airflow.models.dagwarning import DagWarningType\n+\n+        if not self.warnings or self.check_level != DagStabilityCheckLevel.warning:\n+            return []\n+        return [\n+            {\n+                \"dag_id\": dag_id,\n+                \"warning_type\": DagWarningType.RUNTIME_VARYING_VALUE.value,\n+                \"message\": self.format_warnings(),\n+            }\n+            for dag_id in dag_ids\n+        ]\n+\n+    def get_error_format_dict(self, file_path, bundle_path):\n+        if not self.warnings or self.check_level != DagStabilityCheckLevel.error:\n+            return None\n+\n+        relative_file_path = str(Path(file_path).relative_to(bundle_path)) if bundle_path else file_path\n+        return {relative_file_path: self.format_warnings()}\n+\n+\n+@dataclass\n+class RuntimeVaryingValueWarning:\n+    \"\"\"Warning information for runtime-varying value detection.\"\"\"\n+\n+    line: int\n+    col: int\n+    code: str\n+    message: str\n+\n+\n+class WarningContext(str, Enum):\n+    \"\"\"Context types for warnings.\"\"\"\n+\n+    TASK_CONSTRUCTOR = \"Task constructor\"\n+    DAG_CONSTRUCTOR = \"Dag constructor\"\n+\n+\n+class RuntimeVaryingValueAnalyzer:\n+    \"\"\"\n+    Analyzer dedicated to tracking and detecting runtime-varying values.\n+\n+    This analyzer is responsible for identifying if a given AST node\n+    contains values that change on every execution (datetime.now(), random(), etc.).\n+    \"\"\"\n+\n+    def __init__(\n+        self,\n+        varying_vars: dict[str, tuple[int, str]],\n+        imports: dict[str, str],\n+        from_imports: dict[str, tuple[str, str]],\n+    ):\n+        self.varying_vars = varying_vars\n+        self.imports = imports\n+        self.from_imports = from_imports\n+\n+    def get_varying_source(self, node: ast.expr) -> str | None:\n+        \"\"\"\n+        Check if an AST node contains runtime-varying values and return the source.\n+\n+        Checks:\n+        - Runtime-varying function calls (datetime.now(), etc.)\n+        - Runtime-varying variable references\n+        - Runtime-varying values in f-strings\n+        - Runtime-varying values in expressions/collections\n+        \"\"\"\n+        # 1. Direct runtime-varying call\n+        if isinstance(node, ast.Call) and self.is_runtime_varying_call(node):\n+            return ast.unparse(node)\n+\n+        # 2. Runtime-varying variable reference\n+        if isinstance(node, ast.Name) and node.id in self.varying_vars:\n+            _, source = self.varying_vars[node.id]\n+            return source\n+\n+        # 3. f-string\n+        if isinstance(node, ast.JoinedStr):\n+            return self.get_varying_fstring(node)\n+\n+        # 4. Binary operation\n+        if isinstance(node, ast.BinOp):\n+            return self.get_varying_source(node.left) or self.get_varying_source(node.right)\n+\n+        # 5. Collections (list/tuple/set)\n+        if isinstance(node, (ast.List, ast.Tuple, ast.Set)):\n+            return self.get_varying_collection(node.elts)\n+\n+        # 6. List comprehension\n+        if isinstance(node, ast.ListComp):\n+            return self.get_varying_source(node.elt)\n+\n+        # 7. Dictionary\n+        if isinstance(node, ast.Dict):\n+            return self.get_varying_dict(node)\n+\n+        # 8. Method call chain\n+        if isinstance(node, ast.Call) and isinstance(node.func, ast.Attribute):\n+            return self.get_varying_source(node.func.value)\n+\n+        return None\n+\n+    def get_varying_fstring(self, node: ast.JoinedStr) -> str | None:\n+        \"\"\"Check for runtime-varying values inside f-strings.\"\"\"\n+        for value in node.values:\n+            if isinstance(value, ast.FormattedValue):\n+                if source := self.get_varying_source(value.value):\n+                    return source\n+        return None\n+\n+    def get_varying_collection(self, elements: list) -> str | None:\n+        \"\"\"Check for runtime-varying values in collection elements.\"\"\"\n+        for elt in elements:\n+            source = self.get_varying_source(elt)\n+            if source:\n+                return source\n+        return None\n+\n+    def get_varying_dict(self, node: ast.Dict) -> str | None:\n+        \"\"\"Check for runtime-varying values in dictionary keys/values.\"\"\"\n+        for key, value in zip(node.keys, node.values):\n+            if key:\n+                source = self.get_varying_source(key)\n+                if source:\n+                    return source\n+            if value:\n+                source = self.get_varying_source(value)\n+                if source:\n+                    return source\n+        return None\n+\n+    def is_runtime_varying_call(self, node: ast.Call) -> bool:\n+        \"\"\"\n+        Check if a call is runtime-varying.\n+\n+        1. Is the function itself runtime-varying?\n+        2. Do the arguments contain runtime-varying values?\n+        \"\"\"\n+        # Check if the function itself is runtime-varying\n+        if isinstance(node.func, ast.Attribute):\n+            if self._is_runtime_varying_attribute_call(node.func):\n+                return True\n+        elif isinstance(node.func, ast.Name):\n+            if self._is_runtime_varying_name_call(node.func):\n+                return True\n+\n+        # Check if arguments contain runtime-varying values\n+        return self._has_varying_arguments(node)\n+\n+    def _has_varying_arguments(self, node: ast.Call) -> bool:\n+        \"\"\"Check if function arguments contain runtime-varying values.\"\"\"\n+        for arg in node.args:\n+            if self.get_varying_source(arg):\n+                return True\n+\n+        for kw in node.keywords:\n+            if self.get_varying_source(kw.value):\n+                return True\n+\n+        return False\n+\n+    def _is_runtime_varying_attribute_call(self, attr: ast.Attribute) -> bool:\n+        \"\"\"Check for runtime-varying calls like datetime.now().\"\"\"\n+        method_name = attr.attr\n+\n+        if isinstance(attr.value, ast.Name):\n+            module_or_alias = attr.value.id\n+            actual_module = self.imports.get(module_or_alias, module_or_alias)\n+\n+            # If imported via \"from import\"\n+            if module_or_alias in self.from_imports:\n+                _, original_name = self.from_imports[module_or_alias]\n+                actual_module = original_name\n+\n+            return (actual_module, method_name) in RUNTIME_VARYING_CALLS\n+\n+        # Nested attribute (e.g., datetime.datetime.now)\n+        if isinstance(attr.value, ast.Attribute):\n+            inner_attr = attr.value\n+            if isinstance(inner_attr.value, ast.Name):\n+                return (inner_attr.attr, method_name) in RUNTIME_VARYING_CALLS\n+\n+        return False\n+\n+    def _is_runtime_varying_name_call(self, func: ast.Name) -> bool:\n+        \"\"\"Check for runtime-varying calls like now() (when imported via 'from import').\"\"\"\n+        func_name = func.id\n+\n+        if func_name in self.from_imports:\n+            module, original_name = self.from_imports[func_name]\n+            module_parts = module.split(\".\")\n+\n+            for part in module_parts:\n+                if (part, original_name) in RUNTIME_VARYING_CALLS:\n+                    return True\n+\n+        return False\n+\n+\n+class DagTaskDetector:\n+    \"\"\"\n+    Detector dedicated to identifying Dag and Task constructors.\n+\n+    This detector identifies when code is creating Dag or Task objects\n+    in Airflow. It needs to handle both traditional class instantiation and decorator styles.\n+    \"\"\"\n+\n+    def __init__(self, from_imports: dict):\n+        self.from_imports = from_imports\n+        self.dag_instances: set[str] = set()\n+        self.is_in_dag_context: bool = False\n+\n+    def is_dag_constructor(self, node: ast.Call) -> bool:\n+        \"\"\"Check if a call is a Dag constructor.\"\"\"\n+        if not isinstance(node.func, ast.Name):\n+            return False\n+\n+        func_name = node.func.id\n+\n+        # \"from airflow import DAG\" form or \"from airflow.decorator import dag\"\n+        if func_name in self.from_imports:\n+            module, original = self.from_imports[func_name]\n+            if (module == \"airflow\" or module.startswith(\"airflow.\")) and original in (\"DAG\", \"dag\"):\n+                return True\n+\n+        return False\n+\n+    def is_task_constructor(self, node: ast.Call) -> bool:\n+        \"\"\"\n+        Check if a call is a Task constructor.\n+\n+        Criteria:\n+        1. All calls within a Dag with block\n+        2. Calls that receive a Dag instance as an argument (dag=...)\n+        \"\"\"\n+        # Inside Dag with block\n+        if self.is_in_dag_context:\n+            return True\n+\n+        # Passing Dag instance as argument\n+        for arg in node.args:\n+            if isinstance(arg, ast.Name) and arg.id in self.dag_instances:\n+                return True\n+\n+        for keyword in node.keywords:\n+            if keyword.value and isinstance(keyword.value, ast.Name):\n+                if keyword.value.id in self.dag_instances:\n+                    return True\n+\n+        return False\n+\n+    def register_dag_instance(self, var_name: str):\n+        \"\"\"Register a Dag instance variable name.\"\"\"\n+        self.dag_instances.add(var_name)\n+\n+    def enter_dag_context(self):\n+        \"\"\"Enter a Dag with block.\"\"\"\n+        self.is_in_dag_context = True\n+\n+    def exit_dag_context(self):\n+        \"\"\"Exit a Dag with block.\"\"\"\n+        self.is_in_dag_context = False\n+\n+\n+class AirflowRuntimeVaryingValueChecker(ast.NodeVisitor):\n+    \"\"\"\n+    Main visitor class to detect runtime-varying value usage in Airflow Dag/Task.\n+\n+    Main responsibilities:\n+    - Traverse AST and visit nodes\n+    - Detect Dag/Task creation\n+    - Track runtime-varying values and generate warnings\n+    \"\"\"\n+\n+    def __init__(self, check_level: DagStabilityCheckLevel = DagStabilityCheckLevel.warning):\n+        self.static_check_result: DagStabilityCheckerResult = DagStabilityCheckerResult(\n+            check_level=check_level\n+        )\n+        self.imports: dict[str, str] = {}\n+        self.from_imports: dict[str, tuple[str, str]] = {}\n+        self.varying_vars: dict[str, tuple[int, str]] = {}\n+        self.check_level = check_level\n+\n+        # Helper objects\n+        self.value_analyzer = RuntimeVaryingValueAnalyzer(self.varying_vars, self.imports, self.from_imports)\n+        self.dag_detector = DagTaskDetector(self.from_imports)\n+\n+    def visit_Import(self, node: ast.Import):\n+        \"\"\"Process import statements.\"\"\"\n+        for alias in node.names:\n+            name = alias.asname or alias.name\n+            self.imports[name] = alias.name\n+\n+    def visit_ImportFrom(self, node: ast.ImportFrom):\n+        \"\"\"Process from ... import statements.\"\"\"\n+        if node.module:\n+            for alias in node.names:\n+                name = alias.asname or alias.name\n+                self.from_imports[name] = (node.module, alias.name)\n+\n+    def visit_Assign(self, node: ast.Assign):\n+        \"\"\"\n+        Process variable assignments.\n+\n+        Checks:\n+        1. Dag instance assignment\n+        2. Task instance assignment\n+        3. Runtime-varying value assignment\n+        \"\"\"\n+        value = node.value\n+\n+        # Dag constructor\n+        if isinstance(value, ast.Call) and self.dag_detector.is_dag_constructor(value):\n+            self._register_dag_instances(node.targets)\n+            self._check_and_warn(value, WarningContext.DAG_CONSTRUCTOR)\n+\n+        # Task constructor\n+        elif isinstance(value, ast.Call) and self.dag_detector.is_task_constructor(value):\n+            self._check_and_warn(value, WarningContext.TASK_CONSTRUCTOR)\n+\n+        # Track runtime-varying values\n+        else:\n+            self._track_varying_assignment(node)\n+\n+    def visit_Call(self, node: ast.Call):\n+        \"\"\"\n+        Process function calls.\n+\n+        Check not assign but just call the function or Dag definition via decorator.\n+        \"\"\"\n+        if self.dag_detector.is_dag_constructor(node):\n+            self._check_and_warn(node, WarningContext.DAG_CONSTRUCTOR)\n+\n+        elif self.dag_detector.is_task_constructor(node):\n+            self._check_and_warn(node, WarningContext.TASK_CONSTRUCTOR)\n+\n+    def visit_For(self, node: ast.For):\n+        \"\"\"\n+        Process for statements.\n+\n+        Check if iteration target contains runtime-varying values.\n+        \"\"\"\n+        # check the iterator value is runtime-varying\n+        # iter is runtime-varying : for iter in [datetime.now(), 3]\n+        varying_source = self.value_analyzer.get_varying_source(node.iter)\n+        if varying_source:\n+            if isinstance(node.target, ast.Name):\n+                self.varying_vars[node.target.id] = (node.lineno, varying_source)\n+\n+        for body in node.body:\n+            self.visit(body)\n+\n+        if varying_source:\n+            if isinstance(node.target, ast.Name):\n+                self.varying_vars.pop(node.target.id)\n+\n+    def visit_With(self, node: ast.With):\n+        \"\"\"\n+        Process with statements.\n+\n+        Detect Dag context manager.\n+        \"\"\"\n+        is_with_dag_context = False\n+        for item in node.items:\n+            # check if the Dag instance exists in with context\n+            self.visit(item)\n+            if isinstance(item.context_expr, ast.Call):\n+                if self.dag_detector.is_dag_constructor(item.context_expr):\n+                    # check the value defined in with statement to detect entering Dag with block\n+                    is_with_dag_context = True\n+\n+        if is_with_dag_context:\n+            self.dag_detector.enter_dag_context()\n+\n+        for body in node.body:\n+            self.visit(body)\n+\n+        # Exit Dag with block\n+        self.dag_detector.exit_dag_context()\n+\n+    def _register_dag_instances(self, targets: list):\n+        \"\"\"Register Dag instance variable names.\"\"\"\n+        for target in targets:\n+            if isinstance(target, ast.Name):\n+                self.dag_detector.register_dag_instance(target.id)\n+\n+    def _track_varying_assignment(self, node: ast.Assign):\n+        \"\"\"Track variable assignments with runtime-varying values.\"\"\"\n+        varying_source = self.value_analyzer.get_varying_source(node.value)\n+        if varying_source:\n+            for target in node.targets:\n+                if isinstance(target, ast.Name):\n+                    self.varying_vars[target.id] = (node.lineno, varying_source)\n+\n+    def _check_and_warn(self, call: ast.Call, context: WarningContext):\n+        \"\"\"Check function call arguments and generate warnings.\"\"\"\n+        varying_source = self.value_analyzer.get_varying_source(call)\n+        if varying_source:\n+            self.static_check_result.warnings.append(\n+                RuntimeVaryingValueWarning(\n+                    line=call.lineno,\n+                    col=call.col_offset,\n+                    code=ast.unparse(call),\n+                    message=self._get_warning_message(context),\n+                )\n+            )\n+\n+    def _get_warning_message(self, context: WarningContext):",
      "comment": "```suggestion\n    def _get_warning_message(self, context: WarningContext) -> str:\n```",
      "comment_id": 2667575146,
      "user": "Lee-W",
      "created_at": "2026-01-07T08:54:04Z",
      "url": "https://github.com/apache/airflow/pull/59430#discussion_r2667575146"
    },
    {
      "repo": "apache/airflow",
      "pr_number": 59430,
      "file_path": "airflow-core/src/airflow/utils/dag_stability_checker.py",
      "line": 527,
      "side": "RIGHT",
      "diff_hunk": "@@ -0,0 +1,533 @@\n+# Licensed to the Apache Software Foundation (ASF) under one\n+# or more contributor license agreements.  See the NOTICE file\n+# distributed with this work for additional information\n+# regarding copyright ownership.  The ASF licenses this file\n+# to you under the Apache License, Version 2.0 (the\n+# \"License\"); you may not use this file except in compliance\n+# with the License.  You may obtain a copy of the License at\n+#\n+#   http://www.apache.org/licenses/LICENSE-2.0\n+#\n+# Unless required by applicable law or agreed to in writing,\n+# software distributed under the License is distributed on an\n+# \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+# KIND, either express or implied.  See the License for the\n+# specific language governing permissions and limitations\n+# under the License.\n+from __future__ import annotations\n+\n+import ast\n+from dataclasses import dataclass\n+from enum import Enum\n+from pathlib import Path\n+\n+RUNTIME_VARYING_CALLS = [\n+    (\"datetime\", \"now\"),\n+    (\"datetime\", \"today\"),\n+    (\"datetime\", \"utcnow\"),\n+    (\"date\", \"today\"),\n+    (\"time\", \"time\"),\n+    (\"time\", \"localtime\"),\n+    (\"random\", \"random\"),\n+    (\"random\", \"randint\"),\n+    (\"random\", \"choice\"),\n+    (\"random\", \"uniform\"),\n+    (\"uuid\", \"uuid4\"),\n+    (\"uuid\", \"uuid1\"),\n+    (\"pendulum\", \"now\"),\n+    (\"pendulum\", \"today\"),\n+    (\"pendulum\", \"yesterday\"),\n+    (\"pendulum\", \"tomorrow\"),\n+]\n+\n+\n+class DagStabilityCheckLevel(Enum):\n+    \"\"\"enum class for Dag stability check level.\"\"\"\n+\n+    off = \"off\"\n+    warning = \"warning\"\n+    error = \"error\"\n+\n+\n+class DagStabilityCheckerResult:\n+    \"\"\"\n+    Represents the result of stability analysis on a Dag file.\n+\n+    Stores detected warnings and formats them appropriately based on the configured check level\n+    (warning or error).\n+    \"\"\"\n+\n+    def __init__(self, check_level: DagStabilityCheckLevel):\n+        self.check_level: DagStabilityCheckLevel = check_level\n+        self.warnings: list[RuntimeVaryingValueWarning] = []\n+        self.runtime_varying_values: dict = {}\n+\n+    def format_warnings(self) -> str | None:\n+        \"\"\"Return formatted string of warning list.\"\"\"\n+        if not self.warnings:\n+            return None\n+\n+        lines = [\n+            \"This Dag uses runtime-variable values in Dag construction.\",\n+            \"It causes the Dag version to increase as values change on every Dag parse.\",\n+            \"\",\n+        ]\n+        for w in self.warnings:\n+            lines.extend(\n+                [\n+                    f\"Line {w.line}, Col {w.col}\",\n+                    f\"Code: {w.code}\",\n+                    f\"Issue: {w.message}\",\n+                    \"\",\n+                ]\n+            )\n+\n+        if self.runtime_varying_values:\n+            lines.extend(\n+                [\n+                    \"\ufe0fDon't use the variables as arguments in Dag/Task constructors:\",\n+                    *(\n+                        f\"  Line {line}: '{var_name}' related '{source}'\"\n+                        for var_name, (line, source) in sorted(\n+                            self.runtime_varying_values.items(),\n+                            key=lambda x: x[1][0],\n+                        )\n+                    ),\n+                    \"\",\n+                ]\n+            )\n+\n+        return \"\\n\".join(lines)\n+\n+    def get_warning_dag_format_dict(self, dag_ids: list[str]) -> list[dict[str, str | None]]:\n+        \"\"\"Convert warning statement to Dag warning format.\"\"\"\n+        from airflow.models.dagwarning import DagWarningType\n+\n+        if not self.warnings or self.check_level != DagStabilityCheckLevel.warning:\n+            return []\n+        return [\n+            {\n+                \"dag_id\": dag_id,\n+                \"warning_type\": DagWarningType.RUNTIME_VARYING_VALUE.value,\n+                \"message\": self.format_warnings(),\n+            }\n+            for dag_id in dag_ids\n+        ]\n+\n+    def get_error_format_dict(self, file_path, bundle_path):\n+        if not self.warnings or self.check_level != DagStabilityCheckLevel.error:\n+            return None\n+\n+        relative_file_path = str(Path(file_path).relative_to(bundle_path)) if bundle_path else file_path\n+        return {relative_file_path: self.format_warnings()}\n+\n+\n+@dataclass\n+class RuntimeVaryingValueWarning:\n+    \"\"\"Warning information for runtime-varying value detection.\"\"\"\n+\n+    line: int\n+    col: int\n+    code: str\n+    message: str\n+\n+\n+class WarningContext(str, Enum):\n+    \"\"\"Context types for warnings.\"\"\"\n+\n+    TASK_CONSTRUCTOR = \"Task constructor\"\n+    DAG_CONSTRUCTOR = \"Dag constructor\"\n+\n+\n+class RuntimeVaryingValueAnalyzer:\n+    \"\"\"\n+    Analyzer dedicated to tracking and detecting runtime-varying values.\n+\n+    This analyzer is responsible for identifying if a given AST node\n+    contains values that change on every execution (datetime.now(), random(), etc.).\n+    \"\"\"\n+\n+    def __init__(\n+        self,\n+        varying_vars: dict[str, tuple[int, str]],\n+        imports: dict[str, str],\n+        from_imports: dict[str, tuple[str, str]],\n+    ):\n+        self.varying_vars = varying_vars\n+        self.imports = imports\n+        self.from_imports = from_imports\n+\n+    def get_varying_source(self, node: ast.expr) -> str | None:\n+        \"\"\"\n+        Check if an AST node contains runtime-varying values and return the source.\n+\n+        Checks:\n+        - Runtime-varying function calls (datetime.now(), etc.)\n+        - Runtime-varying variable references\n+        - Runtime-varying values in f-strings\n+        - Runtime-varying values in expressions/collections\n+        \"\"\"\n+        # 1. Direct runtime-varying call\n+        if isinstance(node, ast.Call) and self.is_runtime_varying_call(node):\n+            return ast.unparse(node)\n+\n+        # 2. Runtime-varying variable reference\n+        if isinstance(node, ast.Name) and node.id in self.varying_vars:\n+            _, source = self.varying_vars[node.id]\n+            return source\n+\n+        # 3. f-string\n+        if isinstance(node, ast.JoinedStr):\n+            return self.get_varying_fstring(node)\n+\n+        # 4. Binary operation\n+        if isinstance(node, ast.BinOp):\n+            return self.get_varying_source(node.left) or self.get_varying_source(node.right)\n+\n+        # 5. Collections (list/tuple/set)\n+        if isinstance(node, (ast.List, ast.Tuple, ast.Set)):\n+            return self.get_varying_collection(node.elts)\n+\n+        # 6. List comprehension\n+        if isinstance(node, ast.ListComp):\n+            return self.get_varying_source(node.elt)\n+\n+        # 7. Dictionary\n+        if isinstance(node, ast.Dict):\n+            return self.get_varying_dict(node)\n+\n+        # 8. Method call chain\n+        if isinstance(node, ast.Call) and isinstance(node.func, ast.Attribute):\n+            return self.get_varying_source(node.func.value)\n+\n+        return None\n+\n+    def get_varying_fstring(self, node: ast.JoinedStr) -> str | None:\n+        \"\"\"Check for runtime-varying values inside f-strings.\"\"\"\n+        for value in node.values:\n+            if isinstance(value, ast.FormattedValue):\n+                if source := self.get_varying_source(value.value):\n+                    return source\n+        return None\n+\n+    def get_varying_collection(self, elements: list) -> str | None:\n+        \"\"\"Check for runtime-varying values in collection elements.\"\"\"\n+        for elt in elements:\n+            source = self.get_varying_source(elt)\n+            if source:\n+                return source\n+        return None\n+\n+    def get_varying_dict(self, node: ast.Dict) -> str | None:\n+        \"\"\"Check for runtime-varying values in dictionary keys/values.\"\"\"\n+        for key, value in zip(node.keys, node.values):\n+            if key:\n+                source = self.get_varying_source(key)\n+                if source:\n+                    return source\n+            if value:\n+                source = self.get_varying_source(value)\n+                if source:\n+                    return source\n+        return None\n+\n+    def is_runtime_varying_call(self, node: ast.Call) -> bool:\n+        \"\"\"\n+        Check if a call is runtime-varying.\n+\n+        1. Is the function itself runtime-varying?\n+        2. Do the arguments contain runtime-varying values?\n+        \"\"\"\n+        # Check if the function itself is runtime-varying\n+        if isinstance(node.func, ast.Attribute):\n+            if self._is_runtime_varying_attribute_call(node.func):\n+                return True\n+        elif isinstance(node.func, ast.Name):\n+            if self._is_runtime_varying_name_call(node.func):\n+                return True\n+\n+        # Check if arguments contain runtime-varying values\n+        return self._has_varying_arguments(node)\n+\n+    def _has_varying_arguments(self, node: ast.Call) -> bool:\n+        \"\"\"Check if function arguments contain runtime-varying values.\"\"\"\n+        for arg in node.args:\n+            if self.get_varying_source(arg):\n+                return True\n+\n+        for kw in node.keywords:\n+            if self.get_varying_source(kw.value):\n+                return True\n+\n+        return False\n+\n+    def _is_runtime_varying_attribute_call(self, attr: ast.Attribute) -> bool:\n+        \"\"\"Check for runtime-varying calls like datetime.now().\"\"\"\n+        method_name = attr.attr\n+\n+        if isinstance(attr.value, ast.Name):\n+            module_or_alias = attr.value.id\n+            actual_module = self.imports.get(module_or_alias, module_or_alias)\n+\n+            # If imported via \"from import\"\n+            if module_or_alias in self.from_imports:\n+                _, original_name = self.from_imports[module_or_alias]\n+                actual_module = original_name\n+\n+            return (actual_module, method_name) in RUNTIME_VARYING_CALLS\n+\n+        # Nested attribute (e.g., datetime.datetime.now)\n+        if isinstance(attr.value, ast.Attribute):\n+            inner_attr = attr.value\n+            if isinstance(inner_attr.value, ast.Name):\n+                return (inner_attr.attr, method_name) in RUNTIME_VARYING_CALLS\n+\n+        return False\n+\n+    def _is_runtime_varying_name_call(self, func: ast.Name) -> bool:\n+        \"\"\"Check for runtime-varying calls like now() (when imported via 'from import').\"\"\"\n+        func_name = func.id\n+\n+        if func_name in self.from_imports:\n+            module, original_name = self.from_imports[func_name]\n+            module_parts = module.split(\".\")\n+\n+            for part in module_parts:\n+                if (part, original_name) in RUNTIME_VARYING_CALLS:\n+                    return True\n+\n+        return False\n+\n+\n+class DagTaskDetector:\n+    \"\"\"\n+    Detector dedicated to identifying Dag and Task constructors.\n+\n+    This detector identifies when code is creating Dag or Task objects\n+    in Airflow. It needs to handle both traditional class instantiation and decorator styles.\n+    \"\"\"\n+\n+    def __init__(self, from_imports: dict):\n+        self.from_imports = from_imports\n+        self.dag_instances: set[str] = set()\n+        self.is_in_dag_context: bool = False\n+\n+    def is_dag_constructor(self, node: ast.Call) -> bool:\n+        \"\"\"Check if a call is a Dag constructor.\"\"\"\n+        if not isinstance(node.func, ast.Name):\n+            return False\n+\n+        func_name = node.func.id\n+\n+        # \"from airflow import DAG\" form or \"from airflow.decorator import dag\"\n+        if func_name in self.from_imports:\n+            module, original = self.from_imports[func_name]\n+            if (module == \"airflow\" or module.startswith(\"airflow.\")) and original in (\"DAG\", \"dag\"):\n+                return True\n+\n+        return False\n+\n+    def is_task_constructor(self, node: ast.Call) -> bool:\n+        \"\"\"\n+        Check if a call is a Task constructor.\n+\n+        Criteria:\n+        1. All calls within a Dag with block\n+        2. Calls that receive a Dag instance as an argument (dag=...)\n+        \"\"\"\n+        # Inside Dag with block\n+        if self.is_in_dag_context:\n+            return True\n+\n+        # Passing Dag instance as argument\n+        for arg in node.args:\n+            if isinstance(arg, ast.Name) and arg.id in self.dag_instances:\n+                return True\n+\n+        for keyword in node.keywords:\n+            if keyword.value and isinstance(keyword.value, ast.Name):\n+                if keyword.value.id in self.dag_instances:\n+                    return True\n+\n+        return False\n+\n+    def register_dag_instance(self, var_name: str):\n+        \"\"\"Register a Dag instance variable name.\"\"\"\n+        self.dag_instances.add(var_name)\n+\n+    def enter_dag_context(self):\n+        \"\"\"Enter a Dag with block.\"\"\"\n+        self.is_in_dag_context = True\n+\n+    def exit_dag_context(self):\n+        \"\"\"Exit a Dag with block.\"\"\"\n+        self.is_in_dag_context = False\n+\n+\n+class AirflowRuntimeVaryingValueChecker(ast.NodeVisitor):\n+    \"\"\"\n+    Main visitor class to detect runtime-varying value usage in Airflow Dag/Task.\n+\n+    Main responsibilities:\n+    - Traverse AST and visit nodes\n+    - Detect Dag/Task creation\n+    - Track runtime-varying values and generate warnings\n+    \"\"\"\n+\n+    def __init__(self, check_level: DagStabilityCheckLevel = DagStabilityCheckLevel.warning):\n+        self.static_check_result: DagStabilityCheckerResult = DagStabilityCheckerResult(\n+            check_level=check_level\n+        )\n+        self.imports: dict[str, str] = {}\n+        self.from_imports: dict[str, tuple[str, str]] = {}\n+        self.varying_vars: dict[str, tuple[int, str]] = {}\n+        self.check_level = check_level\n+\n+        # Helper objects\n+        self.value_analyzer = RuntimeVaryingValueAnalyzer(self.varying_vars, self.imports, self.from_imports)\n+        self.dag_detector = DagTaskDetector(self.from_imports)\n+\n+    def visit_Import(self, node: ast.Import):\n+        \"\"\"Process import statements.\"\"\"\n+        for alias in node.names:\n+            name = alias.asname or alias.name\n+            self.imports[name] = alias.name\n+\n+    def visit_ImportFrom(self, node: ast.ImportFrom):\n+        \"\"\"Process from ... import statements.\"\"\"\n+        if node.module:\n+            for alias in node.names:\n+                name = alias.asname or alias.name\n+                self.from_imports[name] = (node.module, alias.name)\n+\n+    def visit_Assign(self, node: ast.Assign):\n+        \"\"\"\n+        Process variable assignments.\n+\n+        Checks:\n+        1. Dag instance assignment\n+        2. Task instance assignment\n+        3. Runtime-varying value assignment\n+        \"\"\"\n+        value = node.value\n+\n+        # Dag constructor\n+        if isinstance(value, ast.Call) and self.dag_detector.is_dag_constructor(value):\n+            self._register_dag_instances(node.targets)\n+            self._check_and_warn(value, WarningContext.DAG_CONSTRUCTOR)\n+\n+        # Task constructor\n+        elif isinstance(value, ast.Call) and self.dag_detector.is_task_constructor(value):\n+            self._check_and_warn(value, WarningContext.TASK_CONSTRUCTOR)\n+\n+        # Track runtime-varying values\n+        else:\n+            self._track_varying_assignment(node)\n+\n+    def visit_Call(self, node: ast.Call):\n+        \"\"\"\n+        Process function calls.\n+\n+        Check not assign but just call the function or Dag definition via decorator.\n+        \"\"\"\n+        if self.dag_detector.is_dag_constructor(node):\n+            self._check_and_warn(node, WarningContext.DAG_CONSTRUCTOR)\n+\n+        elif self.dag_detector.is_task_constructor(node):\n+            self._check_and_warn(node, WarningContext.TASK_CONSTRUCTOR)\n+\n+    def visit_For(self, node: ast.For):\n+        \"\"\"\n+        Process for statements.\n+\n+        Check if iteration target contains runtime-varying values.\n+        \"\"\"\n+        # check the iterator value is runtime-varying\n+        # iter is runtime-varying : for iter in [datetime.now(), 3]\n+        varying_source = self.value_analyzer.get_varying_source(node.iter)\n+        if varying_source:\n+            if isinstance(node.target, ast.Name):\n+                self.varying_vars[node.target.id] = (node.lineno, varying_source)\n+\n+        for body in node.body:\n+            self.visit(body)\n+\n+        if varying_source:\n+            if isinstance(node.target, ast.Name):\n+                self.varying_vars.pop(node.target.id)\n+\n+    def visit_With(self, node: ast.With):\n+        \"\"\"\n+        Process with statements.\n+\n+        Detect Dag context manager.\n+        \"\"\"\n+        is_with_dag_context = False\n+        for item in node.items:\n+            # check if the Dag instance exists in with context\n+            self.visit(item)\n+            if isinstance(item.context_expr, ast.Call):\n+                if self.dag_detector.is_dag_constructor(item.context_expr):\n+                    # check the value defined in with statement to detect entering Dag with block\n+                    is_with_dag_context = True\n+\n+        if is_with_dag_context:\n+            self.dag_detector.enter_dag_context()\n+\n+        for body in node.body:\n+            self.visit(body)\n+\n+        # Exit Dag with block\n+        self.dag_detector.exit_dag_context()\n+\n+    def _register_dag_instances(self, targets: list):\n+        \"\"\"Register Dag instance variable names.\"\"\"\n+        for target in targets:\n+            if isinstance(target, ast.Name):\n+                self.dag_detector.register_dag_instance(target.id)\n+\n+    def _track_varying_assignment(self, node: ast.Assign):\n+        \"\"\"Track variable assignments with runtime-varying values.\"\"\"\n+        varying_source = self.value_analyzer.get_varying_source(node.value)\n+        if varying_source:\n+            for target in node.targets:\n+                if isinstance(target, ast.Name):\n+                    self.varying_vars[target.id] = (node.lineno, varying_source)\n+\n+    def _check_and_warn(self, call: ast.Call, context: WarningContext):\n+        \"\"\"Check function call arguments and generate warnings.\"\"\"\n+        varying_source = self.value_analyzer.get_varying_source(call)\n+        if varying_source:\n+            self.static_check_result.warnings.append(\n+                RuntimeVaryingValueWarning(\n+                    line=call.lineno,\n+                    col=call.col_offset,\n+                    code=ast.unparse(call),\n+                    message=self._get_warning_message(context),\n+                )\n+            )\n+\n+    def _get_warning_message(self, context: WarningContext):\n+        \"\"\"Get appropriate warning message based on context.\"\"\"\n+        if self.dag_detector.is_in_dag_context and context == WarningContext.TASK_CONSTRUCTOR:\n+            return \"Don't use runtime-varying values as function arguments within with Dag block\"\n+        return f\"Don't use runtime-varying value as argument in {context.value}\"\n+\n+\n+def check_dag_file_stability(file_path) -> DagStabilityCheckerResult:\n+    from airflow.configuration import conf\n+\n+    check_level = conf.getenum(\"dag_processor\", \"dag_stability_check_level\", DagStabilityCheckLevel)\n+\n+    if check_level == DagStabilityCheckLevel.off:\n+        return DagStabilityCheckerResult(check_level=check_level)\n+\n+    try:\n+        parsed = ast.parse(Path(file_path).read_bytes())\n+    except Exception:",
      "comment": "```suggestion\n    except SyntaxError, ValueError, TypeError:\n```",
      "comment_id": 2667586062,
      "user": "Lee-W",
      "created_at": "2026-01-07T08:57:41Z",
      "url": "https://github.com/apache/airflow/pull/59430#discussion_r2667586062"
    },
    {
      "repo": "apache/airflow",
      "pr_number": 59430,
      "file_path": "airflow-core/src/airflow/utils/dag_version_inflation_checker.py",
      "line": 495,
      "side": "RIGHT",
      "diff_hunk": "@@ -0,0 +1,533 @@\n+# Licensed to the Apache Software Foundation (ASF) under one\n+# or more contributor license agreements.  See the NOTICE file\n+# distributed with this work for additional information\n+# regarding copyright ownership.  The ASF licenses this file\n+# to you under the Apache License, Version 2.0 (the\n+# \"License\"); you may not use this file except in compliance\n+# with the License.  You may obtain a copy of the License at\n+#\n+#   http://www.apache.org/licenses/LICENSE-2.0\n+#\n+# Unless required by applicable law or agreed to in writing,\n+# software distributed under the License is distributed on an\n+# \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+# KIND, either express or implied.  See the License for the\n+# specific language governing permissions and limitations\n+# under the License.\n+from __future__ import annotations\n+\n+import ast\n+from dataclasses import dataclass\n+from enum import Enum\n+from pathlib import Path\n+\n+RUNTIME_VARYING_CALLS = [\n+    (\"datetime\", \"now\"),\n+    (\"datetime\", \"today\"),\n+    (\"datetime\", \"utcnow\"),\n+    (\"date\", \"today\"),\n+    (\"time\", \"time\"),\n+    (\"time\", \"localtime\"),\n+    (\"random\", \"random\"),\n+    (\"random\", \"randint\"),\n+    (\"random\", \"choice\"),\n+    (\"random\", \"uniform\"),\n+    (\"uuid\", \"uuid4\"),\n+    (\"uuid\", \"uuid1\"),\n+    (\"pendulum\", \"now\"),\n+    (\"pendulum\", \"today\"),\n+    (\"pendulum\", \"yesterday\"),\n+    (\"pendulum\", \"tomorrow\"),\n+]\n+\n+\n+class DagStabilityCheckLevel(Enum):\n+    \"\"\"enum class for Dag stability check level.\"\"\"\n+\n+    off = \"off\"\n+    warning = \"warning\"\n+    error = \"error\"\n+\n+\n+class DagStabilityCheckerResult:\n+    \"\"\"\n+    Represents the result of stability analysis on a Dag file.\n+\n+    Stores detected warnings and formats them appropriately based on the configured check level\n+    (warning or error).\n+    \"\"\"\n+\n+    def __init__(self, check_level: DagStabilityCheckLevel):\n+        self.check_level: DagStabilityCheckLevel = check_level\n+        self.warnings: list[RuntimeVaryingValueWarning] = []\n+        self.runtime_varying_values: dict = {}\n+\n+    def format_warnings(self) -> str | None:\n+        \"\"\"Return formatted string of warning list.\"\"\"\n+        if not self.warnings:\n+            return None\n+\n+        lines = [\n+            \"This Dag uses runtime-variable values in Dag construction.\",\n+            \"It causes the Dag version to increase as values change on every Dag parse.\",\n+            \"\",\n+        ]\n+        for w in self.warnings:\n+            lines.extend(\n+                [\n+                    f\"Line {w.line}, Col {w.col}\",\n+                    f\"Code: {w.code}\",\n+                    f\"Issue: {w.message}\",\n+                    \"\",\n+                ]\n+            )\n+\n+        if self.runtime_varying_values:\n+            lines.extend(\n+                [\n+                    \"\ufe0fDon't use the variables as arguments in Dag/Task constructors:\",\n+                    *(\n+                        f\"  Line {line}: '{var_name}' related '{source}'\"\n+                        for var_name, (line, source) in sorted(\n+                            self.runtime_varying_values.items(),\n+                            key=lambda x: x[1][0],\n+                        )\n+                    ),\n+                    \"\",\n+                ]\n+            )\n+\n+        return \"\\n\".join(lines)\n+\n+    def get_warning_dag_format_dict(self, dag_ids: list[str]) -> list[dict[str, str | None]]:\n+        \"\"\"Convert warning statement to Dag warning format.\"\"\"\n+        from airflow.models.dagwarning import DagWarningType\n+\n+        if not self.warnings or self.check_level != DagStabilityCheckLevel.warning:\n+            return []\n+        return [\n+            {\n+                \"dag_id\": dag_id,\n+                \"warning_type\": DagWarningType.RUNTIME_VARYING_VALUE.value,\n+                \"message\": self.format_warnings(),\n+            }\n+            for dag_id in dag_ids\n+        ]\n+\n+    def get_error_format_dict(self, file_path, bundle_path):\n+        if not self.warnings or self.check_level != DagStabilityCheckLevel.error:\n+            return None\n+\n+        relative_file_path = str(Path(file_path).relative_to(bundle_path)) if bundle_path else file_path\n+        return {relative_file_path: self.format_warnings()}\n+\n+\n+@dataclass\n+class RuntimeVaryingValueWarning:\n+    \"\"\"Warning information for runtime-varying value detection.\"\"\"\n+\n+    line: int\n+    col: int\n+    code: str\n+    message: str\n+\n+\n+class WarningContext(str, Enum):\n+    \"\"\"Context types for warnings.\"\"\"\n+\n+    TASK_CONSTRUCTOR = \"Task constructor\"\n+    DAG_CONSTRUCTOR = \"Dag constructor\"\n+\n+\n+class RuntimeVaryingValueAnalyzer:\n+    \"\"\"\n+    Analyzer dedicated to tracking and detecting runtime-varying values.\n+\n+    This analyzer is responsible for identifying if a given AST node\n+    contains values that change on every execution (datetime.now(), random(), etc.).\n+    \"\"\"\n+\n+    def __init__(\n+        self,\n+        varying_vars: dict[str, tuple[int, str]],\n+        imports: dict[str, str],\n+        from_imports: dict[str, tuple[str, str]],\n+    ):\n+        self.varying_vars = varying_vars\n+        self.imports = imports\n+        self.from_imports = from_imports\n+\n+    def get_varying_source(self, node: ast.expr) -> str | None:\n+        \"\"\"\n+        Check if an AST node contains runtime-varying values and return the source.\n+\n+        Checks:\n+        - Runtime-varying function calls (datetime.now(), etc.)\n+        - Runtime-varying variable references\n+        - Runtime-varying values in f-strings\n+        - Runtime-varying values in expressions/collections\n+        \"\"\"\n+        # 1. Direct runtime-varying call\n+        if isinstance(node, ast.Call) and self.is_runtime_varying_call(node):\n+            return ast.unparse(node)\n+\n+        # 2. Runtime-varying variable reference\n+        if isinstance(node, ast.Name) and node.id in self.varying_vars:\n+            _, source = self.varying_vars[node.id]\n+            return source\n+\n+        # 3. f-string\n+        if isinstance(node, ast.JoinedStr):\n+            return self.get_varying_fstring(node)\n+\n+        # 4. Binary operation\n+        if isinstance(node, ast.BinOp):\n+            return self.get_varying_source(node.left) or self.get_varying_source(node.right)\n+\n+        # 5. Collections (list/tuple/set)\n+        if isinstance(node, (ast.List, ast.Tuple, ast.Set)):\n+            return self.get_varying_collection(node.elts)\n+\n+        # 6. List comprehension\n+        if isinstance(node, ast.ListComp):\n+            return self.get_varying_source(node.elt)\n+\n+        # 7. Dictionary\n+        if isinstance(node, ast.Dict):\n+            return self.get_varying_dict(node)\n+\n+        # 8. Method call chain\n+        if isinstance(node, ast.Call) and isinstance(node.func, ast.Attribute):\n+            return self.get_varying_source(node.func.value)\n+\n+        return None\n+\n+    def get_varying_fstring(self, node: ast.JoinedStr) -> str | None:\n+        \"\"\"Check for runtime-varying values inside f-strings.\"\"\"\n+        for value in node.values:\n+            if isinstance(value, ast.FormattedValue):\n+                if source := self.get_varying_source(value.value):\n+                    return source\n+        return None\n+\n+    def get_varying_collection(self, elements: list) -> str | None:\n+        \"\"\"Check for runtime-varying values in collection elements.\"\"\"\n+        for elt in elements:\n+            source = self.get_varying_source(elt)\n+            if source:\n+                return source\n+        return None\n+\n+    def get_varying_dict(self, node: ast.Dict) -> str | None:\n+        \"\"\"Check for runtime-varying values in dictionary keys/values.\"\"\"\n+        for key, value in zip(node.keys, node.values):\n+            if key:\n+                source = self.get_varying_source(key)\n+                if source:\n+                    return source\n+            if value:\n+                source = self.get_varying_source(value)\n+                if source:\n+                    return source\n+        return None\n+\n+    def is_runtime_varying_call(self, node: ast.Call) -> bool:\n+        \"\"\"\n+        Check if a call is runtime-varying.\n+\n+        1. Is the function itself runtime-varying?\n+        2. Do the arguments contain runtime-varying values?\n+        \"\"\"\n+        # Check if the function itself is runtime-varying\n+        if isinstance(node.func, ast.Attribute):\n+            if self._is_runtime_varying_attribute_call(node.func):\n+                return True\n+        elif isinstance(node.func, ast.Name):\n+            if self._is_runtime_varying_name_call(node.func):\n+                return True\n+\n+        # Check if arguments contain runtime-varying values\n+        return self._has_varying_arguments(node)\n+\n+    def _has_varying_arguments(self, node: ast.Call) -> bool:\n+        \"\"\"Check if function arguments contain runtime-varying values.\"\"\"\n+        for arg in node.args:\n+            if self.get_varying_source(arg):\n+                return True\n+\n+        for kw in node.keywords:\n+            if self.get_varying_source(kw.value):\n+                return True\n+\n+        return False\n+\n+    def _is_runtime_varying_attribute_call(self, attr: ast.Attribute) -> bool:\n+        \"\"\"Check for runtime-varying calls like datetime.now().\"\"\"\n+        method_name = attr.attr\n+\n+        if isinstance(attr.value, ast.Name):\n+            module_or_alias = attr.value.id\n+            actual_module = self.imports.get(module_or_alias, module_or_alias)\n+\n+            # If imported via \"from import\"\n+            if module_or_alias in self.from_imports:\n+                _, original_name = self.from_imports[module_or_alias]\n+                actual_module = original_name\n+\n+            return (actual_module, method_name) in RUNTIME_VARYING_CALLS\n+\n+        # Nested attribute (e.g., datetime.datetime.now)\n+        if isinstance(attr.value, ast.Attribute):\n+            inner_attr = attr.value\n+            if isinstance(inner_attr.value, ast.Name):\n+                return (inner_attr.attr, method_name) in RUNTIME_VARYING_CALLS\n+\n+        return False\n+\n+    def _is_runtime_varying_name_call(self, func: ast.Name) -> bool:\n+        \"\"\"Check for runtime-varying calls like now() (when imported via 'from import').\"\"\"\n+        func_name = func.id\n+\n+        if func_name in self.from_imports:\n+            module, original_name = self.from_imports[func_name]\n+            module_parts = module.split(\".\")\n+\n+            for part in module_parts:\n+                if (part, original_name) in RUNTIME_VARYING_CALLS:\n+                    return True\n+\n+        return False\n+\n+\n+class DagTaskDetector:\n+    \"\"\"\n+    Detector dedicated to identifying Dag and Task constructors.\n+\n+    This detector identifies when code is creating Dag or Task objects\n+    in Airflow. It needs to handle both traditional class instantiation and decorator styles.\n+    \"\"\"\n+\n+    def __init__(self, from_imports: dict):\n+        self.from_imports = from_imports\n+        self.dag_instances: set[str] = set()\n+        self.is_in_dag_context: bool = False\n+\n+    def is_dag_constructor(self, node: ast.Call) -> bool:\n+        \"\"\"Check if a call is a Dag constructor.\"\"\"\n+        if not isinstance(node.func, ast.Name):\n+            return False\n+\n+        func_name = node.func.id\n+\n+        # \"from airflow import DAG\" form or \"from airflow.decorator import dag\"\n+        if func_name in self.from_imports:\n+            module, original = self.from_imports[func_name]\n+            if (module == \"airflow\" or module.startswith(\"airflow.\")) and original in (\"DAG\", \"dag\"):\n+                return True\n+\n+        return False\n+\n+    def is_task_constructor(self, node: ast.Call) -> bool:\n+        \"\"\"\n+        Check if a call is a Task constructor.\n+\n+        Criteria:\n+        1. All calls within a Dag with block\n+        2. Calls that receive a Dag instance as an argument (dag=...)\n+        \"\"\"\n+        # Inside Dag with block\n+        if self.is_in_dag_context:\n+            return True\n+\n+        # Passing Dag instance as argument\n+        for arg in node.args:\n+            if isinstance(arg, ast.Name) and arg.id in self.dag_instances:\n+                return True\n+\n+        for keyword in node.keywords:\n+            if keyword.value and isinstance(keyword.value, ast.Name):\n+                if keyword.value.id in self.dag_instances:\n+                    return True\n+\n+        return False\n+\n+    def register_dag_instance(self, var_name: str):\n+        \"\"\"Register a Dag instance variable name.\"\"\"\n+        self.dag_instances.add(var_name)\n+\n+    def enter_dag_context(self):\n+        \"\"\"Enter a Dag with block.\"\"\"\n+        self.is_in_dag_context = True\n+\n+    def exit_dag_context(self):\n+        \"\"\"Exit a Dag with block.\"\"\"\n+        self.is_in_dag_context = False\n+\n+\n+class AirflowRuntimeVaryingValueChecker(ast.NodeVisitor):\n+    \"\"\"\n+    Main visitor class to detect runtime-varying value usage in Airflow Dag/Task.\n+\n+    Main responsibilities:\n+    - Traverse AST and visit nodes\n+    - Detect Dag/Task creation\n+    - Track runtime-varying values and generate warnings\n+    \"\"\"\n+\n+    def __init__(self, check_level: DagStabilityCheckLevel = DagStabilityCheckLevel.warning):\n+        self.static_check_result: DagStabilityCheckerResult = DagStabilityCheckerResult(\n+            check_level=check_level\n+        )\n+        self.imports: dict[str, str] = {}\n+        self.from_imports: dict[str, tuple[str, str]] = {}\n+        self.varying_vars: dict[str, tuple[int, str]] = {}\n+        self.check_level = check_level\n+\n+        # Helper objects\n+        self.value_analyzer = RuntimeVaryingValueAnalyzer(self.varying_vars, self.imports, self.from_imports)\n+        self.dag_detector = DagTaskDetector(self.from_imports)\n+\n+    def visit_Import(self, node: ast.Import):\n+        \"\"\"Process import statements.\"\"\"\n+        for alias in node.names:\n+            name = alias.asname or alias.name\n+            self.imports[name] = alias.name\n+\n+    def visit_ImportFrom(self, node: ast.ImportFrom):\n+        \"\"\"Process from ... import statements.\"\"\"\n+        if node.module:\n+            for alias in node.names:\n+                name = alias.asname or alias.name\n+                self.from_imports[name] = (node.module, alias.name)\n+\n+    def visit_Assign(self, node: ast.Assign):\n+        \"\"\"\n+        Process variable assignments.\n+\n+        Checks:\n+        1. Dag instance assignment\n+        2. Task instance assignment\n+        3. Runtime-varying value assignment\n+        \"\"\"\n+        value = node.value\n+\n+        # Dag constructor\n+        if isinstance(value, ast.Call) and self.dag_detector.is_dag_constructor(value):\n+            self._register_dag_instances(node.targets)\n+            self._check_and_warn(value, WarningContext.DAG_CONSTRUCTOR)\n+\n+        # Task constructor\n+        elif isinstance(value, ast.Call) and self.dag_detector.is_task_constructor(value):\n+            self._check_and_warn(value, WarningContext.TASK_CONSTRUCTOR)\n+\n+        # Track runtime-varying values\n+        else:\n+            self._track_varying_assignment(node)\n+\n+    def visit_Call(self, node: ast.Call):\n+        \"\"\"\n+        Process function calls.\n+\n+        Check not assign but just call the function or Dag definition via decorator.\n+        \"\"\"\n+        if self.dag_detector.is_dag_constructor(node):\n+            self._check_and_warn(node, WarningContext.DAG_CONSTRUCTOR)\n+\n+        elif self.dag_detector.is_task_constructor(node):\n+            self._check_and_warn(node, WarningContext.TASK_CONSTRUCTOR)\n+\n+    def visit_For(self, node: ast.For):\n+        \"\"\"\n+        Process for statements.\n+\n+        Check if iteration target contains runtime-varying values.\n+        \"\"\"\n+        # check the iterator value is runtime-varying\n+        # iter is runtime-varying : for iter in [datetime.now(), 3]\n+        varying_source = self.value_analyzer.get_varying_source(node.iter)\n+        if varying_source:\n+            if isinstance(node.target, ast.Name):\n+                self.varying_vars[node.target.id] = (node.lineno, varying_source)\n+\n+        for body in node.body:\n+            self.visit(body)\n+\n+        if varying_source:\n+            if isinstance(node.target, ast.Name):\n+                self.varying_vars.pop(node.target.id)\n+\n+    def visit_With(self, node: ast.With):\n+        \"\"\"\n+        Process with statements.\n+\n+        Detect Dag context manager.\n+        \"\"\"\n+        is_with_dag_context = False\n+        for item in node.items:\n+            # check if the Dag instance exists in with context\n+            self.visit(item)\n+            if isinstance(item.context_expr, ast.Call):\n+                if self.dag_detector.is_dag_constructor(item.context_expr):\n+                    # check the value defined in with statement to detect entering Dag with block\n+                    is_with_dag_context = True\n+\n+        if is_with_dag_context:\n+            self.dag_detector.enter_dag_context()\n+\n+        for body in node.body:\n+            self.visit(body)\n+\n+        # Exit Dag with block\n+        self.dag_detector.exit_dag_context()\n+\n+    def _register_dag_instances(self, targets: list):\n+        \"\"\"Register Dag instance variable names.\"\"\"\n+        for target in targets:\n+            if isinstance(target, ast.Name):\n+                self.dag_detector.register_dag_instance(target.id)\n+\n+    def _track_varying_assignment(self, node: ast.Assign):\n+        \"\"\"Track variable assignments with runtime-varying values.\"\"\"\n+        varying_source = self.value_analyzer.get_varying_source(node.value)\n+        if varying_source:\n+            for target in node.targets:\n+                if isinstance(target, ast.Name):\n+                    self.varying_vars[target.id] = (node.lineno, varying_source)\n+\n+    def _check_and_warn(self, call: ast.Call, context: WarningContext):\n+        \"\"\"Check function call arguments and generate warnings.\"\"\"\n+        varying_source = self.value_analyzer.get_varying_source(call)\n+        if varying_source:",
      "comment": "```suggestion\n        if (varying_source := self.value_analyzer.get_varying_source(call)):\n```",
      "comment_id": 2667588699,
      "user": "Lee-W",
      "created_at": "2026-01-07T08:58:33Z",
      "url": "https://github.com/apache/airflow/pull/59430#discussion_r2667588699"
    },
    {
      "repo": "apache/airflow",
      "pr_number": 60781,
      "file_path": "providers/keycloak/src/airflow/providers/keycloak/auth_manager/keycloak_auth_manager.py",
      "line": 167,
      "side": "RIGHT",
      "diff_hunk": "@@ -162,13 +164,7 @@ def refresh_tokens(self, *, user: KeycloakAuthManagerUser) -> dict[str, str]:\n             client = self.get_keycloak_client()\n             return client.refresh_token(user.refresh_token)\n         except KeycloakPostError as exc:\n-            log.warning(\n-                \"KeycloakPostError encountered during token refresh. \"\n-                \"Suppressing the exception and returning None.\",\n-                exc_info=exc,\n-            )\n-\n-        return {}\n+            raise AuthManagerRefreshTokenExpiredException(exc)",
      "comment": "This is going to fail when the provider is used with older versions of Airflow isn't it?",
      "comment_id": 2705469483,
      "user": "ashb",
      "created_at": "2026-01-19T16:38:43Z",
      "url": "https://github.com/apache/airflow/pull/60781#discussion_r2705469483"
    },
    {
      "repo": "apache/airflow",
      "pr_number": 60781,
      "file_path": "providers/keycloak/src/airflow/providers/keycloak/auth_manager/keycloak_auth_manager.py",
      "line": 172,
      "side": "RIGHT",
      "diff_hunk": "@@ -162,13 +164,19 @@ def refresh_tokens(self, *, user: KeycloakAuthManagerUser) -> dict[str, str]:\n             client = self.get_keycloak_client()\n             return client.refresh_token(user.refresh_token)\n         except KeycloakPostError as exc:\n+            if AIRFLOW_V_3_2_0_PLUS:\n+                from airflow.api_fastapi.auth.managers.exceptions import (\n+                    AuthManagerRefreshTokenExpiredException,\n+                )\n+\n+                raise AuthManagerRefreshTokenExpiredException(exc)",
      "comment": "Generally in cases like this I'd say \"try to import, catch the error\" instead of a specific version check (in case we need to backport this etc)\r\n\r\n```suggestion\r\n            try:\r\n                from airflow.api_fastapi.auth.managers.exceptions import (\r\n                    AuthManagerRefreshTokenExpiredException,\r\n                )\r\n            except ImportError:\r\n                pass\r\n            else:\r\n                raise AuthManagerRefreshTokenExpiredException(exc)\r\n```",
      "comment_id": 2705481050,
      "user": "ashb",
      "created_at": "2026-01-19T16:40:53Z",
      "url": "https://github.com/apache/airflow/pull/60781#discussion_r2705481050"
    },
    {
      "repo": "apache/airflow",
      "pr_number": 60781,
      "file_path": "airflow-core/tests/unit/api_fastapi/auth/middlewares/test_refresh_token.py",
      "line": 67,
      "side": "RIGHT",
      "diff_hunk": "@@ -64,8 +64,8 @@ async def test_dispatch_invalid_token(self, mock_refresh_user, middleware, mock_\n         call_next = AsyncMock(return_value=Response())\n \n         response = await middleware.dispatch(mock_request, call_next)\n-        assert response.status_code == 403\n-        assert response.body == b'{\"detail\":\"Invalid JWT token\"}'\n+        assert response.status_code == 200",
      "comment": "do clients rely on 401/403 codes to trigger re-login logic? I suspect a 200 might cause them to try parsing the body as a success? what do you think?  Could we send the Set-Cookie header with a 403 instead?",
      "comment_id": 2705814033,
      "user": "dheerajturaga",
      "created_at": "2026-01-19T18:55:56Z",
      "url": "https://github.com/apache/airflow/pull/60781#discussion_r2705814033"
    },
    {
      "repo": "apache/airflow",
      "pr_number": 60781,
      "file_path": "airflow-core/tests/unit/api_fastapi/auth/middlewares/test_refresh_token.py",
      "line": 67,
      "side": "RIGHT",
      "diff_hunk": "@@ -64,8 +64,8 @@ async def test_dispatch_invalid_token(self, mock_refresh_user, middleware, mock_\n         call_next = AsyncMock(return_value=Response())\n \n         response = await middleware.dispatch(mock_request, call_next)\n-        assert response.status_code == 403\n-        assert response.body == b'{\"detail\":\"Invalid JWT token\"}'\n+        assert response.status_code == 200",
      "comment": "Good question. In reality this will most likely return a 401. The difference here is it is a test, thus the route itself is mocked and return a 200. But in real life, if the token is expired, the route itself will also return a 401",
      "comment_id": 2705835748,
      "user": "vincbeck",
      "created_at": "2026-01-19T19:07:34Z",
      "url": "https://github.com/apache/airflow/pull/60781#discussion_r2705835748"
    },
    {
      "repo": "apache/airflow",
      "pr_number": 59224,
      "file_path": "airflow-core/src/airflow/models/variable.py",
      "line": 176,
      "side": "RIGHT",
      "diff_hunk": "@@ -173,7 +173,7 @@ def get(\n         if var_val is None:\n             if default_var is not cls.__NO_DEFAULT_SENTINEL:\n                 return default_var\n-            raise KeyError(f\"Variable {key} does not exist\")\n+            raise KeyError(f\"Variable {key} does not exist. Try using a full path to your secret if you have one.\")",
      "comment": "This applies to all variables, regardless of how they're fetched (secrets backend/DB/etc.), would remove.",
      "comment_id": 2601667581,
      "user": "BasPH",
      "created_at": "2025-12-09T08:52:57Z",
      "url": "https://github.com/apache/airflow/pull/59224#discussion_r2601667581"
    },
    {
      "repo": "apache/airflow",
      "pr_number": 59224,
      "file_path": "airflow-core/src/airflow/models/variable.py",
      "line": 490,
      "side": "RIGHT",
      "diff_hunk": "@@ -487,6 +487,7 @@ def get_variable_from_secrets(key: str) -> str | None:\n                 )\n \n         SecretCache.save_variable(key, var_val)  # we save None as well\n+        # should I change this return file to include error message?",
      "comment": "This also applies to all variables, would limit changes to the Vault-specific code only.",
      "comment_id": 2601690629,
      "user": "BasPH",
      "created_at": "2025-12-09T08:58:55Z",
      "url": "https://github.com/apache/airflow/pull/59224#discussion_r2601690629"
    },
    {
      "repo": "apache/airflow",
      "pr_number": 59224,
      "file_path": "providers/hashicorp/src/airflow/providers/hashicorp/secrets/vault.py",
      "line": 205,
      "side": "RIGHT",
      "diff_hunk": "@@ -199,14 +199,15 @@ def get_connection(self, conn_id: str) -> Connection | None:\n         from airflow.models.connection import Connection\n \n         response = self.get_response(conn_id)\n-        if response is None:\n+        if not response:\n             return None\n+        try:\n+            uri = response[\"conn_uri\"]",
      "comment": "For readability sake I'd place the `return Connection(conn_id, uri=uri)` inside the `try` clause, but the business logic looks ok.",
      "comment_id": 2626708970,
      "user": "BasPH",
      "created_at": "2025-12-17T11:34:34Z",
      "url": "https://github.com/apache/airflow/pull/59224#discussion_r2626708970"
    },
    {
      "repo": "apache/airflow",
      "pr_number": 59224,
      "file_path": "providers/hashicorp/tests/unit/hashicorp/secrets/test_vault.py",
      "line": 161,
      "side": "RIGHT",
      "diff_hunk": "@@ -111,6 +111,56 @@ def test_get_connection_without_predefined_mount_point(self, mock_hvac):\n         connection = test_client.get_connection(conn_id=\"airflow/test_postgres\")\n         assert connection.get_uri() == \"postgresql://airflow:airflow@host:5432/airflow?foo=bar&baz=taz\"\n \n+    @mock.patch(\"airflow.providers.hashicorp._internal_client.vault_client.hvac\")\n+    def test_get_connection_without_conn_uri_key(self, mock_hvac):\n+        \"\"\"\n+        If a connection is found but the 'conn_uri' is missing,\n+        a warning should be logged and the returned connection should be None\n+        \"\"\"\n+        mock_client = mock.MagicMock()\n+        mock_hvac.Client.return_value = mock_client\n+        mock_client.secrets.kv.v2.read_secret_version.return_value = {\n+            \"request_id\": \"94011e25-f8dc-ec29-221b-1f9c1d9ad2ae\",\n+            \"lease_id\": \"\",\n+            \"renewable\": False,\n+            \"lease_duration\": 0,\n+            \"data\": {\n+                \"data\": {\n+                    \"conn_type\": \"postgresql\",\n+                    \"login\": \"airflow\",\n+                    \"password\": \"airflow\",\n+                    \"host\": \"host\",\n+                    \"port\": \"5432\",\n+                    \"schema\": \"airflow\",\n+                    \"extra\": '{\"foo\":\"bar\",\"baz\":\"taz\"}',\n+                },\n+                \"metadata\": {\n+                    \"created_time\": \"2020-03-16T21:01:43.331126Z\",\n+                    \"deletion_time\": \"\",\n+                    \"destroyed\": False,\n+                    \"version\": 1,\n+                },\n+            },\n+            \"wrap_info\": None,\n+            \"warnings\": None,\n+            \"auth\": None,\n+        }\n+\n+        kwargs = {\n+            \"connections_path\": \"connections\",\n+            \"mount_point\": \"airflow\",\n+            \"auth_type\": \"token\",\n+            \"url\": \"http://127.0.0.1:8200\",\n+            \"token\": \"s.7AU0I51yv1Q1lxOIg1F3ZRAS\",\n+        }\n+\n+        test_client = VaultBackend(**kwargs)\n+        response = {\"test_key\": \"data\"}\n+        test_client.vault_client.get_response = mock.MagicMock(return_value=response)\n+        connection = test_client.get_connection(conn_id=\"test_postgres\")\n+        # How to test the KeyError branch of get_connection?",
      "comment": "I left a comment regarding the test for variables, the same approach can be applied here.",
      "comment_id": 2626852817,
      "user": "BasPH",
      "created_at": "2025-12-17T12:22:19Z",
      "url": "https://github.com/apache/airflow/pull/59224#discussion_r2626852817"
    },
    {
      "repo": "apache/airflow",
      "pr_number": 59224,
      "file_path": "providers/hashicorp/src/airflow/providers/hashicorp/_internal_client/vault_client.py",
      "line": 425,
      "side": "RIGHT",
      "diff_hunk": "@@ -421,7 +421,9 @@ def _parse_secret_path(self, secret_path: str) -> tuple[str, str]:\n         if not self.mount_point:\n             split_secret_path = secret_path.split(\"/\", 1)\n             if len(split_secret_path) < 2:\n-                raise InvalidPath\n+                raise InvalidPath(\n+                    \"The variable path you have provided is invalid. Please provide a full path: path/to/secret/variable\"",
      "comment": "```suggestion\n                    \"The variable path you have provided is invalid. Please provide a full path of the format: path/to/secret/variable\"\n```",
      "comment_id": 2629803348,
      "user": "amoghrajesh",
      "created_at": "2025-12-18T06:49:01Z",
      "url": "https://github.com/apache/airflow/pull/59224#discussion_r2629803348"
    },
    {
      "repo": "apache/airflow",
      "pr_number": 59224,
      "file_path": "providers/hashicorp/src/airflow/providers/hashicorp/secrets/vault.py",
      "line": 208,
      "side": "RIGHT",
      "diff_hunk": "@@ -199,14 +199,15 @@ def get_connection(self, conn_id: str) -> Connection | None:\n         from airflow.models.connection import Connection\n \n         response = self.get_response(conn_id)\n-        if response is None:\n+        if not response:\n             return None\n-\n-        uri = response.get(\"conn_uri\")\n-        if uri:\n+        try:\n+            uri = response[\"conn_uri\"]\n             return Connection(conn_id, uri=uri)\n-\n-        return Connection(conn_id, **response)\n+        except KeyError:\n+            self.log.warning('Vault connection %s fetched but does not have required key \"conn_uri\"', conn_id)",
      "comment": "On second thought, this is not the behaviour we want for fetching connections. While variables and configs can only be set via one key `value` (where it makes sense to warn when a key `value` isn't set), connections can be set in two ways: `conn_uri` or the [json-representation keys](https://airflow.apache.org/docs/apache-airflow/3.1.5/howto/connection.html#generating-a-json-connection-representation) (`host`, `login`, etc.). This code would therefore introduce an (undesirable) warning when fetching connections that are configured with the json convention.\r\n\r\nI suggest we remove the changes for `get_connection`.",
      "comment_id": 2634134095,
      "user": "BasPH",
      "created_at": "2025-12-19T08:13:11Z",
      "url": "https://github.com/apache/airflow/pull/59224#discussion_r2634134095"
    },
    {
      "repo": "apache/airflow",
      "pr_number": 59224,
      "file_path": "providers/hashicorp/tests/unit/hashicorp/secrets/test_vault.py",
      "line": 290,
      "side": "RIGHT",
      "diff_hunk": "@@ -263,6 +313,52 @@ def test_get_variable_value_non_existent_key(self, mock_hvac):\n         )\n         assert test_client.get_variable(\"hello\") is None\n \n+    @mock.patch(\"airflow.providers.hashicorp._internal_client.vault_client.hvac\")\n+    def test_get_variable_does_not_contain_value_key(self, mock_hvac):\n+        \"\"\"\n+        Test that if the 'value' key is not present in Vault, _VaultClient.get_variable\n+        should log a warning and return None\n+        \"\"\"\n+        mock_client = mock.MagicMock()\n+        mock_hvac.Client.return_value = mock_client\n+\n+        kwargs = {\n+            \"variables_path\": \"variables\",\n+            \"mount_point\": \"airflow\",\n+            \"auth_type\": \"token\",\n+            \"url\": \"http://127.0.0.1:8200\",\n+            \"token\": \"s.7AU0I51yv1Q1lxOIg1F3ZRAS\",\n+        }\n+        test_client = VaultBackend(**kwargs)\n+        response = {\"test_key\": \"data\"}\n+        test_client.vault_client.get_secret = mock.MagicMock(return_value=response)\n+\n+        result = test_client.get_variable(\"hello\")\n+        assert result is None",
      "comment": "Oh, caplog is banned. Please use other means in capturing logs, not caplog.",
      "comment_id": 2645426708,
      "user": "jscheffl",
      "created_at": "2025-12-24T10:54:30Z",
      "url": "https://github.com/apache/airflow/pull/59224#discussion_r2645426708"
    },
    {
      "repo": "apache/airflow",
      "pr_number": 59224,
      "file_path": "providers/hashicorp/tests/unit/hashicorp/secrets/test_vault.py",
      "line": 290,
      "side": "RIGHT",
      "diff_hunk": "@@ -263,6 +313,52 @@ def test_get_variable_value_non_existent_key(self, mock_hvac):\n         )\n         assert test_client.get_variable(\"hello\") is None\n \n+    @mock.patch(\"airflow.providers.hashicorp._internal_client.vault_client.hvac\")\n+    def test_get_variable_does_not_contain_value_key(self, mock_hvac):\n+        \"\"\"\n+        Test that if the 'value' key is not present in Vault, _VaultClient.get_variable\n+        should log a warning and return None\n+        \"\"\"\n+        mock_client = mock.MagicMock()\n+        mock_hvac.Client.return_value = mock_client\n+\n+        kwargs = {\n+            \"variables_path\": \"variables\",\n+            \"mount_point\": \"airflow\",\n+            \"auth_type\": \"token\",\n+            \"url\": \"http://127.0.0.1:8200\",\n+            \"token\": \"s.7AU0I51yv1Q1lxOIg1F3ZRAS\",\n+        }\n+        test_client = VaultBackend(**kwargs)\n+        response = {\"test_key\": \"data\"}\n+        test_client.vault_client.get_secret = mock.MagicMock(return_value=response)\n+\n+        result = test_client.get_variable(\"hello\")\n+        assert result is None",
      "comment": "Wasn't aware of that, and I see caplog used in other tests? Could you elaborate?",
      "comment_id": 2645498688,
      "user": "BasPH",
      "created_at": "2025-12-24T11:36:47Z",
      "url": "https://github.com/apache/airflow/pull/59224#discussion_r2645498688"
    },
    {
      "repo": "apache/airflow",
      "pr_number": 59224,
      "file_path": "providers/hashicorp/tests/unit/hashicorp/secrets/test_vault.py",
      "line": 290,
      "side": "RIGHT",
      "diff_hunk": "@@ -263,6 +313,52 @@ def test_get_variable_value_non_existent_key(self, mock_hvac):\n         )\n         assert test_client.get_variable(\"hello\") is None\n \n+    @mock.patch(\"airflow.providers.hashicorp._internal_client.vault_client.hvac\")\n+    def test_get_variable_does_not_contain_value_key(self, mock_hvac):\n+        \"\"\"\n+        Test that if the 'value' key is not present in Vault, _VaultClient.get_variable\n+        should log a warning and return None\n+        \"\"\"\n+        mock_client = mock.MagicMock()\n+        mock_hvac.Client.return_value = mock_client\n+\n+        kwargs = {\n+            \"variables_path\": \"variables\",\n+            \"mount_point\": \"airflow\",\n+            \"auth_type\": \"token\",\n+            \"url\": \"http://127.0.0.1:8200\",\n+            \"token\": \"s.7AU0I51yv1Q1lxOIg1F3ZRAS\",\n+        }\n+        test_client = VaultBackend(**kwargs)\n+        response = {\"test_key\": \"data\"}\n+        test_client.vault_client.get_secret = mock.MagicMock(return_value=response)\n+\n+        result = test_client.get_variable(\"hello\")\n+        assert result is None",
      "comment": "I'd refer to devlist discussions we had in Feb-2025: https://lists.apache.org/thread/f7t5zl6t3t0s89rt37orfcv4966crojt",
      "comment_id": 2645515009,
      "user": "jscheffl",
      "created_at": "2025-12-24T11:46:16Z",
      "url": "https://github.com/apache/airflow/pull/59224#discussion_r2645515009"
    },
    {
      "repo": "apache/airflow",
      "pr_number": 59224,
      "file_path": "providers/hashicorp/tests/unit/hashicorp/secrets/test_vault.py",
      "line": 290,
      "side": "RIGHT",
      "diff_hunk": "@@ -263,6 +313,52 @@ def test_get_variable_value_non_existent_key(self, mock_hvac):\n         )\n         assert test_client.get_variable(\"hello\") is None\n \n+    @mock.patch(\"airflow.providers.hashicorp._internal_client.vault_client.hvac\")\n+    def test_get_variable_does_not_contain_value_key(self, mock_hvac):\n+        \"\"\"\n+        Test that if the 'value' key is not present in Vault, _VaultClient.get_variable\n+        should log a warning and return None\n+        \"\"\"\n+        mock_client = mock.MagicMock()\n+        mock_hvac.Client.return_value = mock_client\n+\n+        kwargs = {\n+            \"variables_path\": \"variables\",\n+            \"mount_point\": \"airflow\",\n+            \"auth_type\": \"token\",\n+            \"url\": \"http://127.0.0.1:8200\",\n+            \"token\": \"s.7AU0I51yv1Q1lxOIg1F3ZRAS\",\n+        }\n+        test_client = VaultBackend(**kwargs)\n+        response = {\"test_key\": \"data\"}\n+        test_client.vault_client.get_secret = mock.MagicMock(return_value=response)\n+\n+        result = test_client.get_variable(\"hello\")\n+        assert result is None",
      "comment": "Just changed the unit tests to mock the logs instead of caplog. ",
      "comment_id": 2646227993,
      "user": "FoxHelms",
      "created_at": "2025-12-24T20:22:32Z",
      "url": "https://github.com/apache/airflow/pull/59224#discussion_r2646227993"
    },
    {
      "repo": "apache/airflow",
      "pr_number": 59224,
      "file_path": "providers/hashicorp/tests/unit/hashicorp/secrets/test_vault.py",
      "line": 274,
      "side": "RIGHT",
      "diff_hunk": "@@ -263,6 +263,65 @@ def test_get_variable_value_non_existent_key(self, mock_hvac):\n         )\n         assert test_client.get_variable(\"hello\") is None\n \n+    @mock.patch(\"airflow.providers.hashicorp._internal_client.vault_client.hvac\")\n+    @mock.patch(\"airflow.utils.log.logging_mixin.structlog.get_logger\")\n+    def test_get_variable_does_not_contain_value_key(self, mock_hvac, mock_get_logger):\n+        \"\"\"\n+        Test that if the 'value' key is not present in Vault, _VaultClient.get_variable\n+        should log a warning and return None\n+        \"\"\"\n+        mock_client = mock.MagicMock()\n+        mock_hvac.Client.return_value = mock_client",
      "comment": "```suggestion\n        mock_hvac.Client.return_value = mock.MagicMock()\n```",
      "comment_id": 2660832850,
      "user": "Lee-W",
      "created_at": "2026-01-05T09:30:16Z",
      "url": "https://github.com/apache/airflow/pull/59224#discussion_r2660832850"
    },
    {
      "repo": "apache/airflow",
      "pr_number": 59224,
      "file_path": "providers/hashicorp/tests/unit/hashicorp/secrets/test_vault.py",
      "line": 288,
      "side": "RIGHT",
      "diff_hunk": "@@ -263,6 +263,65 @@ def test_get_variable_value_non_existent_key(self, mock_hvac):\n         )\n         assert test_client.get_variable(\"hello\") is None\n \n+    @mock.patch(\"airflow.providers.hashicorp._internal_client.vault_client.hvac\")\n+    @mock.patch(\"airflow.utils.log.logging_mixin.structlog.get_logger\")\n+    def test_get_variable_does_not_contain_value_key(self, mock_hvac, mock_get_logger):\n+        \"\"\"\n+        Test that if the 'value' key is not present in Vault, _VaultClient.get_variable\n+        should log a warning and return None\n+        \"\"\"\n+        mock_client = mock.MagicMock()\n+        mock_hvac.Client.return_value = mock_client\n+        mock_logger = mock.MagicMock()\n+        mock_get_logger.return_value = mock_logger\n+\n+        kwargs = {\n+            \"variables_path\": \"variables\",\n+            \"mount_point\": \"airflow\",\n+            \"auth_type\": \"token\",\n+            \"url\": \"http://127.0.0.1:8200\",\n+            \"token\": \"s.7AU0I51yv1Q1lxOIg1F3ZRAS\",\n+        }\n+        test_client = VaultBackend(**kwargs)\n+        test_client._log = mock_logger\n+        response = {\"test_key\": \"data\"}\n+        test_client.vault_client.get_secret = mock.MagicMock(return_value=response)",
      "comment": "```suggestion\n        test_client = VaultBackend(\n            **{\n                \"variables_path\": \"variables\",\n                \"mount_point\": \"airflow\",\n                \"auth_type\": \"token\",\n                \"url\": \"http://127.0.0.1:8200\",\n                \"token\": \"s.7AU0I51yv1Q1lxOIg1F3ZRAS\",\n            }\n        )\n        test_client._log = mock_logger\n        test_client.vault_client.get_secret = mock.MagicMock(return_value={\"test_key\": \"data\"})\n```",
      "comment_id": 2660835600,
      "user": "Lee-W",
      "created_at": "2026-01-05T09:30:59Z",
      "url": "https://github.com/apache/airflow/pull/59224#discussion_r2660835600"
    },
    {
      "repo": "apache/airflow",
      "pr_number": 59224,
      "file_path": "providers/hashicorp/tests/unit/hashicorp/secrets/test_vault.py",
      "line": 288,
      "side": "RIGHT",
      "diff_hunk": "@@ -263,6 +263,65 @@ def test_get_variable_value_non_existent_key(self, mock_hvac):\n         )\n         assert test_client.get_variable(\"hello\") is None\n \n+    @mock.patch(\"airflow.providers.hashicorp._internal_client.vault_client.hvac\")\n+    @mock.patch(\"airflow.utils.log.logging_mixin.structlog.get_logger\")\n+    def test_get_variable_does_not_contain_value_key(self, mock_hvac, mock_get_logger):\n+        \"\"\"\n+        Test that if the 'value' key is not present in Vault, _VaultClient.get_variable\n+        should log a warning and return None\n+        \"\"\"\n+        mock_client = mock.MagicMock()\n+        mock_hvac.Client.return_value = mock_client\n+        mock_logger = mock.MagicMock()\n+        mock_get_logger.return_value = mock_logger\n+\n+        kwargs = {\n+            \"variables_path\": \"variables\",\n+            \"mount_point\": \"airflow\",\n+            \"auth_type\": \"token\",\n+            \"url\": \"http://127.0.0.1:8200\",\n+            \"token\": \"s.7AU0I51yv1Q1lxOIg1F3ZRAS\",\n+        }\n+        test_client = VaultBackend(**kwargs)\n+        test_client._log = mock_logger\n+        response = {\"test_key\": \"data\"}\n+        test_client.vault_client.get_secret = mock.MagicMock(return_value=response)",
      "comment": "some variable are not re-used and thus might not be needed",
      "comment_id": 2660836786,
      "user": "Lee-W",
      "created_at": "2026-01-05T09:31:16Z",
      "url": "https://github.com/apache/airflow/pull/59224#discussion_r2660836786"
    },
    {
      "repo": "apache/airflow",
      "pr_number": 60698,
      "file_path": "shared/observability/src/airflow_shared/observability/metrics/stats.py",
      "line": 61,
      "side": "RIGHT",
      "diff_hunk": "@@ -58,16 +58,16 @@ def initialize(cls, *, is_statsd_datadog_enabled: bool, is_statsd_on: bool, is_o\n         type.__setattr__(cls, \"instance\", None)\n \n         if is_statsd_datadog_enabled:\n-            from airflow.observability.metrics import datadog_logger\n+            from airflow.sdk._shared.observability.metrics import datadog_logger",
      "comment": "Oh wait thats the shared library. This won't work.",
      "comment_id": 2701022442,
      "user": "amoghrajesh",
      "created_at": "2026-01-17T12:02:47Z",
      "url": "https://github.com/apache/airflow/pull/60698#discussion_r2701022442"
    },
    {
      "repo": "apache/airflow",
      "pr_number": 60698,
      "file_path": "shared/observability/src/airflow_shared/observability/metrics/statsd_logger.py",
      "line": 160,
      "side": "RIGHT",
      "diff_hunk": "@@ -157,7 +157,7 @@ def timer(\n \n def get_statsd_logger(\n     *,\n-    stats_class: type[StatsClient],\n+    stats_class: type[StatsClient] | None = None,",
      "comment": "Oh not needed anymore. This was to fix something else",
      "comment_id": 2705045005,
      "user": "amoghrajesh",
      "created_at": "2026-01-19T14:40:56Z",
      "url": "https://github.com/apache/airflow/pull/60698#discussion_r2705045005"
    },
    {
      "repo": "apache/airflow",
      "pr_number": 60771,
      "file_path": "task-sdk/src/airflow/sdk/crypto.py",
      "line": 72,
      "side": "RIGHT",
      "diff_hunk": "@@ -0,0 +1,118 @@\n+#\n+# Licensed to the Apache Software Foundation (ASF) under one\n+# or more contributor license agreements.  See the NOTICE file\n+# distributed with this work for additional information\n+# regarding copyright ownership.  The ASF licenses this file\n+# to you under the Apache License, Version 2.0 (the\n+# \"License\"); you may not use this file except in compliance\n+# with the License.  You may obtain a copy of the License at\n+#\n+#   http://www.apache.org/licenses/LICENSE-2.0\n+#\n+# Unless required by applicable law or agreed to in writing,\n+# software distributed under the License is distributed on an\n+# \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+# KIND, either express or implied.  See the License for the\n+# specific language governing permissions and limitations\n+# under the License.\n+from __future__ import annotations\n+\n+import logging\n+from functools import cache\n+from typing import Protocol\n+\n+log = logging.getLogger(__name__)\n+\n+\n+class FernetProtocol(Protocol):\n+    \"\"\"This class is only used for TypeChecking (for IDEs, mypy, etc).\"\"\"\n+\n+    is_encrypted: bool\n+\n+    def decrypt(self, msg: bytes | str, ttl: int | None = None) -> bytes:\n+        \"\"\"Decrypt with Fernet.\"\"\"\n+        ...\n+\n+    def encrypt(self, msg: bytes) -> bytes:\n+        \"\"\"Encrypt with Fernet.\"\"\"\n+        ...\n+\n+\n+class _NullFernet:\n+    \"\"\"\n+    A \"Null\" encryptor class that doesn't encrypt or decrypt but that presents a similar interface to Fernet.\n+\n+    The purpose of this is to make the rest of the code not have to know the\n+    difference, and to only display the message once, not 20 times when\n+    `airflow db migrate` is run.\n+    \"\"\"\n+\n+    is_encrypted = False\n+\n+    def decrypt(self, msg: bytes | str, ttl: int | None = None) -> bytes:\n+        \"\"\"Decrypt with Fernet.\"\"\"\n+        if isinstance(msg, bytes):\n+            return msg\n+        if isinstance(msg, str):\n+            return msg.encode(\"utf-8\")\n+        raise ValueError(f\"Expected bytes or str, got {type(msg)}\")\n+\n+    def encrypt(self, msg: bytes) -> bytes:\n+        \"\"\"Encrypt with Fernet.\"\"\"\n+        return msg\n+\n+\n+class _RealFernet:\n+    \"\"\"\n+    A wrapper around the real Fernet to set is_encrypted to True.\n+\n+    This class is only used internally to avoid changing the interface of\n+    the get_fernet function.\n+    \"\"\"\n+",
      "comment": "These imports at class body level execute at class definition time (not lazy) and are redundant since `get_fernet()` already imports them. Should be removed.",
      "comment_id": 2705300264,
      "user": "kaxil",
      "created_at": "2026-01-19T15:52:23Z",
      "url": "https://github.com/apache/airflow/pull/60771#discussion_r2705300264"
    },
    {
      "repo": "apache/airflow",
      "pr_number": 60771,
      "file_path": "task-sdk/src/airflow/sdk/crypto.py",
      "line": 88,
      "side": "RIGHT",
      "diff_hunk": "@@ -0,0 +1,118 @@\n+#\n+# Licensed to the Apache Software Foundation (ASF) under one\n+# or more contributor license agreements.  See the NOTICE file\n+# distributed with this work for additional information\n+# regarding copyright ownership.  The ASF licenses this file\n+# to you under the Apache License, Version 2.0 (the\n+# \"License\"); you may not use this file except in compliance\n+# with the License.  You may obtain a copy of the License at\n+#\n+#   http://www.apache.org/licenses/LICENSE-2.0\n+#\n+# Unless required by applicable law or agreed to in writing,\n+# software distributed under the License is distributed on an\n+# \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+# KIND, either express or implied.  See the License for the\n+# specific language governing permissions and limitations\n+# under the License.\n+from __future__ import annotations\n+\n+import logging\n+from functools import cache\n+from typing import Protocol\n+\n+log = logging.getLogger(__name__)\n+\n+\n+class FernetProtocol(Protocol):\n+    \"\"\"This class is only used for TypeChecking (for IDEs, mypy, etc).\"\"\"\n+\n+    is_encrypted: bool\n+\n+    def decrypt(self, msg: bytes | str, ttl: int | None = None) -> bytes:\n+        \"\"\"Decrypt with Fernet.\"\"\"\n+        ...\n+\n+    def encrypt(self, msg: bytes) -> bytes:\n+        \"\"\"Encrypt with Fernet.\"\"\"\n+        ...\n+\n+\n+class _NullFernet:\n+    \"\"\"\n+    A \"Null\" encryptor class that doesn't encrypt or decrypt but that presents a similar interface to Fernet.\n+\n+    The purpose of this is to make the rest of the code not have to know the\n+    difference, and to only display the message once, not 20 times when\n+    `airflow db migrate` is run.\n+    \"\"\"\n+\n+    is_encrypted = False\n+\n+    def decrypt(self, msg: bytes | str, ttl: int | None = None) -> bytes:\n+        \"\"\"Decrypt with Fernet.\"\"\"\n+        if isinstance(msg, bytes):\n+            return msg\n+        if isinstance(msg, str):\n+            return msg.encode(\"utf-8\")\n+        raise ValueError(f\"Expected bytes or str, got {type(msg)}\")\n+\n+    def encrypt(self, msg: bytes) -> bytes:\n+        \"\"\"Encrypt with Fernet.\"\"\"\n+        return msg\n+\n+\n+class _RealFernet:\n+    \"\"\"\n+    A wrapper around the real Fernet to set is_encrypted to True.\n+\n+    This class is only used internally to avoid changing the interface of\n+    the get_fernet function.\n+    \"\"\"\n+\n+    from cryptography.fernet import Fernet, MultiFernet\n+\n+    is_encrypted = True\n+\n+    def __init__(self, fernet: MultiFernet):\n+        self._fernet = fernet\n+\n+    def decrypt(self, msg: bytes | str, ttl: int | None = None) -> bytes:\n+        \"\"\"Decrypt with Fernet.\"\"\"\n+        return self._fernet.decrypt(msg, ttl)\n+\n+    def encrypt(self, msg: bytes) -> bytes:\n+        \"\"\"Encrypt with Fernet.\"\"\"\n+        return self._fernet.encrypt(msg)\n+\n+    def rotate(self, msg: bytes | str) -> bytes:",
      "comment": "`_RealFernet` has `rotate` but `FernetProtocol` doesn't define it. Calling `rotate()` on a `FernetProtocol` type would fail at runtime if it's a `_NullFernet`.",
      "comment_id": 2705300272,
      "user": "kaxil",
      "created_at": "2026-01-19T15:52:24Z",
      "url": "https://github.com/apache/airflow/pull/60771#discussion_r2705300272"
    },
    {
      "repo": "apache/airflow",
      "pr_number": 60771,
      "file_path": "task-sdk/tests/task_sdk/serde/test_serializers.py",
      "line": 45,
      "side": "RIGHT",
      "diff_hunk": "@@ -42,6 +43,7 @@\n from airflow.sdk.serde import CLASSNAME, DATA, VERSION, decode, deserialize, serialize\n from airflow.sdk.serde.serializers import builtin\n ",
      "comment": "Consider adding dedicated unit tests for `crypto.py` - e.g., `_NullFernet` behavior when key is empty, error handling for invalid keys.",
      "comment_id": 2705300277,
      "user": "kaxil",
      "created_at": "2026-01-19T15:52:24Z",
      "url": "https://github.com/apache/airflow/pull/60771#discussion_r2705300277"
    },
    {
      "repo": "apache/airflow",
      "pr_number": 60771,
      "file_path": "task-sdk/src/airflow/sdk/crypto.py",
      "line": 88,
      "side": "RIGHT",
      "diff_hunk": "@@ -0,0 +1,118 @@\n+#\n+# Licensed to the Apache Software Foundation (ASF) under one\n+# or more contributor license agreements.  See the NOTICE file\n+# distributed with this work for additional information\n+# regarding copyright ownership.  The ASF licenses this file\n+# to you under the Apache License, Version 2.0 (the\n+# \"License\"); you may not use this file except in compliance\n+# with the License.  You may obtain a copy of the License at\n+#\n+#   http://www.apache.org/licenses/LICENSE-2.0\n+#\n+# Unless required by applicable law or agreed to in writing,\n+# software distributed under the License is distributed on an\n+# \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+# KIND, either express or implied.  See the License for the\n+# specific language governing permissions and limitations\n+# under the License.\n+from __future__ import annotations\n+\n+import logging\n+from functools import cache\n+from typing import Protocol\n+\n+log = logging.getLogger(__name__)\n+\n+\n+class FernetProtocol(Protocol):\n+    \"\"\"This class is only used for TypeChecking (for IDEs, mypy, etc).\"\"\"\n+\n+    is_encrypted: bool\n+\n+    def decrypt(self, msg: bytes | str, ttl: int | None = None) -> bytes:\n+        \"\"\"Decrypt with Fernet.\"\"\"\n+        ...\n+\n+    def encrypt(self, msg: bytes) -> bytes:\n+        \"\"\"Encrypt with Fernet.\"\"\"\n+        ...\n+\n+\n+class _NullFernet:\n+    \"\"\"\n+    A \"Null\" encryptor class that doesn't encrypt or decrypt but that presents a similar interface to Fernet.\n+\n+    The purpose of this is to make the rest of the code not have to know the\n+    difference, and to only display the message once, not 20 times when\n+    `airflow db migrate` is run.\n+    \"\"\"\n+\n+    is_encrypted = False\n+\n+    def decrypt(self, msg: bytes | str, ttl: int | None = None) -> bytes:\n+        \"\"\"Decrypt with Fernet.\"\"\"\n+        if isinstance(msg, bytes):\n+            return msg\n+        if isinstance(msg, str):\n+            return msg.encode(\"utf-8\")\n+        raise ValueError(f\"Expected bytes or str, got {type(msg)}\")\n+\n+    def encrypt(self, msg: bytes) -> bytes:\n+        \"\"\"Encrypt with Fernet.\"\"\"\n+        return msg\n+\n+\n+class _RealFernet:\n+    \"\"\"\n+    A wrapper around the real Fernet to set is_encrypted to True.\n+\n+    This class is only used internally to avoid changing the interface of\n+    the get_fernet function.\n+    \"\"\"\n+\n+    from cryptography.fernet import Fernet, MultiFernet\n+\n+    is_encrypted = True\n+\n+    def __init__(self, fernet: MultiFernet):\n+        self._fernet = fernet\n+\n+    def decrypt(self, msg: bytes | str, ttl: int | None = None) -> bytes:\n+        \"\"\"Decrypt with Fernet.\"\"\"\n+        return self._fernet.decrypt(msg, ttl)\n+\n+    def encrypt(self, msg: bytes) -> bytes:\n+        \"\"\"Encrypt with Fernet.\"\"\"\n+        return self._fernet.encrypt(msg)\n+\n+    def rotate(self, msg: bytes | str) -> bytes:",
      "comment": "This is because of my previous work where I cleaned-up code.\nNulLFernet is just kept for the very special cases where no KEY is provided in unit tests, in all regular runs the fernet key is either externally provided or generated at startup (config file is re-written then)\n\nI left this gap explicitly, rotation is called by CLI only if you make this in a unit test it might fail. But all real deployments will not have NullFernet.\n\nI actually wanted to completely delete it but in the PR review the discussion tended to keep it... still I'd propose again to just drop it... and for testing we could still use a fixture in my view.",
      "comment_id": 2705944190,
      "user": "jscheffl",
      "created_at": "2026-01-19T20:00:04Z",
      "url": "https://github.com/apache/airflow/pull/60771#discussion_r2705944190"
    },
    {
      "repo": "apache/airflow",
      "pr_number": 60771,
      "file_path": "task-sdk/src/airflow/sdk/crypto.py",
      "line": 72,
      "side": "RIGHT",
      "diff_hunk": "@@ -0,0 +1,118 @@\n+#\n+# Licensed to the Apache Software Foundation (ASF) under one\n+# or more contributor license agreements.  See the NOTICE file\n+# distributed with this work for additional information\n+# regarding copyright ownership.  The ASF licenses this file\n+# to you under the Apache License, Version 2.0 (the\n+# \"License\"); you may not use this file except in compliance\n+# with the License.  You may obtain a copy of the License at\n+#\n+#   http://www.apache.org/licenses/LICENSE-2.0\n+#\n+# Unless required by applicable law or agreed to in writing,\n+# software distributed under the License is distributed on an\n+# \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+# KIND, either express or implied.  See the License for the\n+# specific language governing permissions and limitations\n+# under the License.\n+from __future__ import annotations\n+\n+import logging\n+from functools import cache\n+from typing import Protocol\n+\n+log = logging.getLogger(__name__)\n+\n+\n+class FernetProtocol(Protocol):\n+    \"\"\"This class is only used for TypeChecking (for IDEs, mypy, etc).\"\"\"\n+\n+    is_encrypted: bool\n+\n+    def decrypt(self, msg: bytes | str, ttl: int | None = None) -> bytes:\n+        \"\"\"Decrypt with Fernet.\"\"\"\n+        ...\n+\n+    def encrypt(self, msg: bytes) -> bytes:\n+        \"\"\"Encrypt with Fernet.\"\"\"\n+        ...\n+\n+\n+class _NullFernet:\n+    \"\"\"\n+    A \"Null\" encryptor class that doesn't encrypt or decrypt but that presents a similar interface to Fernet.\n+\n+    The purpose of this is to make the rest of the code not have to know the\n+    difference, and to only display the message once, not 20 times when\n+    `airflow db migrate` is run.\n+    \"\"\"\n+\n+    is_encrypted = False\n+\n+    def decrypt(self, msg: bytes | str, ttl: int | None = None) -> bytes:\n+        \"\"\"Decrypt with Fernet.\"\"\"\n+        if isinstance(msg, bytes):\n+            return msg\n+        if isinstance(msg, str):\n+            return msg.encode(\"utf-8\")\n+        raise ValueError(f\"Expected bytes or str, got {type(msg)}\")\n+\n+    def encrypt(self, msg: bytes) -> bytes:\n+        \"\"\"Encrypt with Fernet.\"\"\"\n+        return msg\n+\n+\n+class _RealFernet:\n+    \"\"\"\n+    A wrapper around the real Fernet to set is_encrypted to True.\n+\n+    This class is only used internally to avoid changing the interface of\n+    the get_fernet function.\n+    \"\"\"\n+",
      "comment": "ACK, removing `Fernet` but `MultiFernet` is used for typing so moving it up in a type checking block",
      "comment_id": 2706932516,
      "user": "amoghrajesh",
      "created_at": "2026-01-20T06:26:42Z",
      "url": "https://github.com/apache/airflow/pull/60771#discussion_r2706932516"
    },
    {
      "repo": "apache/airflow",
      "pr_number": 60771,
      "file_path": "task-sdk/tests/task_sdk/serde/test_serializers.py",
      "line": 45,
      "side": "RIGHT",
      "diff_hunk": "@@ -42,6 +43,7 @@\n from airflow.sdk.serde import CLASSNAME, DATA, VERSION, decode, deserialize, serialize\n from airflow.sdk.serde.serializers import builtin\n ",
      "comment": "Valid point, added in here: [adding unit tests for crypto](https://github.com/apache/airflow/pull/60771/commits/78b872edf9c549fd86f6009ffb86e34d71eeaff6)",
      "comment_id": 2706967566,
      "user": "amoghrajesh",
      "created_at": "2026-01-20T06:41:19Z",
      "url": "https://github.com/apache/airflow/pull/60771#discussion_r2706967566"
    },
    {
      "repo": "apache/airflow",
      "pr_number": 60771,
      "file_path": "task-sdk/src/airflow/sdk/crypto.py",
      "line": 72,
      "side": "RIGHT",
      "diff_hunk": "@@ -0,0 +1,118 @@\n+#\n+# Licensed to the Apache Software Foundation (ASF) under one\n+# or more contributor license agreements.  See the NOTICE file\n+# distributed with this work for additional information\n+# regarding copyright ownership.  The ASF licenses this file\n+# to you under the Apache License, Version 2.0 (the\n+# \"License\"); you may not use this file except in compliance\n+# with the License.  You may obtain a copy of the License at\n+#\n+#   http://www.apache.org/licenses/LICENSE-2.0\n+#\n+# Unless required by applicable law or agreed to in writing,\n+# software distributed under the License is distributed on an\n+# \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+# KIND, either express or implied.  See the License for the\n+# specific language governing permissions and limitations\n+# under the License.\n+from __future__ import annotations\n+\n+import logging\n+from functools import cache\n+from typing import Protocol\n+\n+log = logging.getLogger(__name__)\n+\n+\n+class FernetProtocol(Protocol):\n+    \"\"\"This class is only used for TypeChecking (for IDEs, mypy, etc).\"\"\"\n+\n+    is_encrypted: bool\n+\n+    def decrypt(self, msg: bytes | str, ttl: int | None = None) -> bytes:\n+        \"\"\"Decrypt with Fernet.\"\"\"\n+        ...\n+\n+    def encrypt(self, msg: bytes) -> bytes:\n+        \"\"\"Encrypt with Fernet.\"\"\"\n+        ...\n+\n+\n+class _NullFernet:\n+    \"\"\"\n+    A \"Null\" encryptor class that doesn't encrypt or decrypt but that presents a similar interface to Fernet.\n+\n+    The purpose of this is to make the rest of the code not have to know the\n+    difference, and to only display the message once, not 20 times when\n+    `airflow db migrate` is run.\n+    \"\"\"\n+\n+    is_encrypted = False\n+\n+    def decrypt(self, msg: bytes | str, ttl: int | None = None) -> bytes:\n+        \"\"\"Decrypt with Fernet.\"\"\"\n+        if isinstance(msg, bytes):\n+            return msg\n+        if isinstance(msg, str):\n+            return msg.encode(\"utf-8\")\n+        raise ValueError(f\"Expected bytes or str, got {type(msg)}\")\n+\n+    def encrypt(self, msg: bytes) -> bytes:\n+        \"\"\"Encrypt with Fernet.\"\"\"\n+        return msg\n+\n+\n+class _RealFernet:\n+    \"\"\"\n+    A wrapper around the real Fernet to set is_encrypted to True.\n+\n+    This class is only used internally to avoid changing the interface of\n+    the get_fernet function.\n+    \"\"\"\n+",
      "comment": "[adding unit tests for crypto](https://github.com/apache/airflow/pull/60771/commits/78b872edf9c549fd86f6009ffb86e34d71eeaff6)",
      "comment_id": 2706969375,
      "user": "amoghrajesh",
      "created_at": "2026-01-20T06:42:06Z",
      "url": "https://github.com/apache/airflow/pull/60771#discussion_r2706969375"
    },
    {
      "repo": "apache/airflow",
      "pr_number": 60771,
      "file_path": "task-sdk/src/airflow/sdk/crypto.py",
      "line": 88,
      "side": "RIGHT",
      "diff_hunk": "@@ -0,0 +1,118 @@\n+#\n+# Licensed to the Apache Software Foundation (ASF) under one\n+# or more contributor license agreements.  See the NOTICE file\n+# distributed with this work for additional information\n+# regarding copyright ownership.  The ASF licenses this file\n+# to you under the Apache License, Version 2.0 (the\n+# \"License\"); you may not use this file except in compliance\n+# with the License.  You may obtain a copy of the License at\n+#\n+#   http://www.apache.org/licenses/LICENSE-2.0\n+#\n+# Unless required by applicable law or agreed to in writing,\n+# software distributed under the License is distributed on an\n+# \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+# KIND, either express or implied.  See the License for the\n+# specific language governing permissions and limitations\n+# under the License.\n+from __future__ import annotations\n+\n+import logging\n+from functools import cache\n+from typing import Protocol\n+\n+log = logging.getLogger(__name__)\n+\n+\n+class FernetProtocol(Protocol):\n+    \"\"\"This class is only used for TypeChecking (for IDEs, mypy, etc).\"\"\"\n+\n+    is_encrypted: bool\n+\n+    def decrypt(self, msg: bytes | str, ttl: int | None = None) -> bytes:\n+        \"\"\"Decrypt with Fernet.\"\"\"\n+        ...\n+\n+    def encrypt(self, msg: bytes) -> bytes:\n+        \"\"\"Encrypt with Fernet.\"\"\"\n+        ...\n+\n+\n+class _NullFernet:\n+    \"\"\"\n+    A \"Null\" encryptor class that doesn't encrypt or decrypt but that presents a similar interface to Fernet.\n+\n+    The purpose of this is to make the rest of the code not have to know the\n+    difference, and to only display the message once, not 20 times when\n+    `airflow db migrate` is run.\n+    \"\"\"\n+\n+    is_encrypted = False\n+\n+    def decrypt(self, msg: bytes | str, ttl: int | None = None) -> bytes:\n+        \"\"\"Decrypt with Fernet.\"\"\"\n+        if isinstance(msg, bytes):\n+            return msg\n+        if isinstance(msg, str):\n+            return msg.encode(\"utf-8\")\n+        raise ValueError(f\"Expected bytes or str, got {type(msg)}\")\n+\n+    def encrypt(self, msg: bytes) -> bytes:\n+        \"\"\"Encrypt with Fernet.\"\"\"\n+        return msg\n+\n+\n+class _RealFernet:\n+    \"\"\"\n+    A wrapper around the real Fernet to set is_encrypted to True.\n+\n+    This class is only used internally to avoid changing the interface of\n+    the get_fernet function.\n+    \"\"\"\n+\n+    from cryptography.fernet import Fernet, MultiFernet\n+\n+    is_encrypted = True\n+\n+    def __init__(self, fernet: MultiFernet):\n+        self._fernet = fernet\n+\n+    def decrypt(self, msg: bytes | str, ttl: int | None = None) -> bytes:\n+        \"\"\"Decrypt with Fernet.\"\"\"\n+        return self._fernet.decrypt(msg, ttl)\n+\n+    def encrypt(self, msg: bytes) -> bytes:\n+        \"\"\"Encrypt with Fernet.\"\"\"\n+        return self._fernet.encrypt(msg)\n+\n+    def rotate(self, msg: bytes | str) -> bytes:",
      "comment": "I think its a separate discussion about having to delete the NullFernet and using fixture instead as I see from linked PRs. To reach a status quo I documented it instead: [adding unit tests for crypto](https://github.com/apache/airflow/pull/60771/commits/78b872edf9c549fd86f6009ffb86e34d71eeaff6)",
      "comment_id": 2706970976,
      "user": "amoghrajesh",
      "created_at": "2026-01-20T06:42:51Z",
      "url": "https://github.com/apache/airflow/pull/60771#discussion_r2706970976"
    },
    {
      "repo": "apache/airflow",
      "pr_number": 60803,
      "file_path": "airflow-core/src/airflow/api_fastapi/execution_api/versions/v2026_03_31.py",
      "line": 50,
      "side": "RIGHT",
      "diff_hunk": "@@ -33,3 +33,20 @@ class ModifyDeferredTaskKwargsToJsonValue(VersionChange):\n         schema(TIDeferredStatePayload).field(\"trigger_kwargs\").had(type=dict[str, Any] | str),\n         schema(TIDeferredStatePayload).field(\"next_kwargs\").had(type=dict[str, Any]),\n     )\n+\n+\n+class RemoveUpstreamMapIndexesField(VersionChange):\n+    \"\"\"Remove upstream_map_indexes field from TIRunContext - now computed by Task SDK.\"\"\"\n+\n+    description = __doc__\n+\n+    instructions_to_migrate_to_previous_version = (\n+        schema(TIRunContext)\n+        .field(\"upstream_map_indexes\")\n+        .existed_as(type=dict[str, int | list[int] | None] | None),\n+    )\n+\n+    @convert_response_to_previous_version_for(TIRunContext)  # type: ignore[arg-type]\n+    def add_upstream_map_indexes_field(response: ResponseInfo) -> None:  # type: ignore[misc]",
      "comment": "```suggestion\n    def add_empty_upstream_map_indexes_to_response(response: ResponseInfo) -> None:  # type: ignore[misc]\n```",
      "comment_id": 2706826495,
      "user": "amoghrajesh",
      "created_at": "2026-01-20T05:36:35Z",
      "url": "https://github.com/apache/airflow/pull/60803#discussion_r2706826495"
    },
    {
      "repo": "apache/airflow",
      "pr_number": 58248,
      "file_path": "airflow-core/src/airflow/models/deadline.py",
      "line": 121,
      "side": "RIGHT",
      "diff_hunk": "@@ -98,13 +104,21 @@ class Deadline(Base):\n     )\n     callback = relationship(\"Callback\", uselist=False, cascade=\"all, delete-orphan\", single_parent=True)\n \n+    # The DeadlineAlert that generated this deadline\n+    deadline_alert_id: Mapped[str | None] = mapped_column(\n+        UUIDType(binary=False), ForeignKey(\"deadline_alert.id\", ondelete=\"SET NULL\"), nullable=True\n+    )\n+    deadline_alert: Mapped[DeadlineAlert | None] = relationship(\"DeadlineAlert\")\n+\n     __table_args__ = (Index(\"deadline_missed_deadline_time_idx\", missed, deadline_time, unique=False),)\n \n     def __init__(\n         self,\n         deadline_time: datetime,\n         callback: CallbackDefinitionProtocol,\n         dagrun_id: int,\n+        deadline_alert_id: str | None,\n+        # TODO: can't we drop this and use self.dagrun.dag_id??",
      "comment": "I added the dag_id param here because the constructor doesn't have access to the session so it cannot lookup relationships. Once we implement lazy initialization of callbacks, which requires this PR to be merged, we wouldn't need this here because we could do the `Callback.create_from_sdk_def()` call in the `handle_miss` method",
      "comment_id": 2520730153,
      "user": "ramitkataria",
      "created_at": "2025-11-13T01:39:58Z",
      "url": "https://github.com/apache/airflow/pull/58248#discussion_r2520730153"
    },
    {
      "repo": "apache/airflow",
      "pr_number": 58248,
      "file_path": "airflow-core/src/airflow/models/deadline.py",
      "line": 149,
      "side": "RIGHT",
      "diff_hunk": "@@ -127,8 +142,11 @@ def _determine_resource() -> tuple[str, str]:\n         resource_type, resource_details = _determine_resource()\n \n         return (\n-            f\"[{resource_type} Deadline] {resource_details} needed by \"\n-            f\"{self.deadline_time} or run: {self.callback}\"\n+            f\"[{resource_type} Deadline] \"\n+            f\"created at {self.created_at}, \"\n+            f\"{resource_details}, \"\n+            f\"needed by {self.deadline_time} \"\n+            f\"or run: {self.callback.path}({self.callback.kwargs or ''})\"",
      "comment": "The callback portion is now handled by its own `__repr__` so I think we should revert this line to `or run: {self.callback}`",
      "comment_id": 2520735518,
      "user": "ramitkataria",
      "created_at": "2025-11-13T01:41:08Z",
      "url": "https://github.com/apache/airflow/pull/58248#discussion_r2520735518"
    },
    {
      "repo": "apache/airflow",
      "pr_number": 58248,
      "file_path": "airflow-core/src/airflow/models/deadline_alert.py",
      "line": 53,
      "side": "RIGHT",
      "diff_hunk": "@@ -0,0 +1,101 @@\n+# Licensed to the Apache Software Foundation (ASF) under one\n+# or more contributor license agreements.  See the NOTICE file\n+# distributed with this work for additional information\n+# regarding copyright ownership.  The ASF licenses this file\n+# to you under the Apache License, Version 2.0 (the\n+# \"License\"); you may not use this file except in compliance\n+# with the License.  You may obtain a copy of the License at\n+#\n+#   http://www.apache.org/licenses/LICENSE-2.0\n+#\n+# Unless required by applicable law or agreed to in writing,\n+# software distributed under the License is distributed on an\n+# \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+# KIND, either express or implied.  See the License for the\n+# specific language governing permissions and limitations\n+# under the License.\n+from __future__ import annotations\n+\n+from datetime import datetime\n+from typing import TYPE_CHECKING\n+\n+import uuid6\n+from sqlalchemy import JSON, Float, ForeignKey, String, Text, select\n+from sqlalchemy.orm import Mapped\n+from sqlalchemy_utils import UUIDType\n+\n+from airflow._shared.timezones import timezone\n+from airflow.models import Base\n+from airflow.models.deadline import ReferenceModels\n+from airflow.utils.session import NEW_SESSION, provide_session\n+from airflow.utils.sqlalchemy import UtcDateTime, mapped_column\n+\n+if TYPE_CHECKING:\n+    from sqlalchemy.orm import Session\n+\n+\n+class DeadlineAlert(Base):\n+    \"\"\"Table containing DeadlineAlert properties.\"\"\"\n+\n+    __tablename__ = \"deadline_alert\"\n+\n+    id: Mapped[str] = mapped_column(UUIDType(binary=False), primary_key=True, default=uuid6.uuid7)\n+    created_at: Mapped[datetime] = mapped_column(UtcDateTime, nullable=False, default=timezone.utcnow)\n+\n+    serialized_dag_id: Mapped[str] = mapped_column(\n+        UUIDType(binary=False), ForeignKey(\"serialized_dag.id\"), nullable=False\n+    )\n+\n+    name: Mapped[str | None] = mapped_column(String(250), nullable=True)\n+    description: Mapped[str | None] = mapped_column(Text, nullable=True)\n+    reference: Mapped[dict] = mapped_column(JSON, nullable=False)\n+    interval: Mapped[float] = mapped_column(Float, nullable=False)\n+    callback: Mapped[dict] = mapped_column(JSON, nullable=False)",
      "comment": "We might want to call this callback_def for consistency with deadline and callback models",
      "comment_id": 2520740058,
      "user": "ramitkataria",
      "created_at": "2025-11-13T01:42:05Z",
      "url": "https://github.com/apache/airflow/pull/58248#discussion_r2520740058"
    },
    {
      "repo": "apache/airflow",
      "pr_number": 58248,
      "file_path": "airflow-core/src/airflow/models/deadline.py",
      "line": 121,
      "side": "RIGHT",
      "diff_hunk": "@@ -98,13 +104,21 @@ class Deadline(Base):\n     )\n     callback = relationship(\"Callback\", uselist=False, cascade=\"all, delete-orphan\", single_parent=True)\n \n+    # The DeadlineAlert that generated this deadline\n+    deadline_alert_id: Mapped[str | None] = mapped_column(\n+        UUIDType(binary=False), ForeignKey(\"deadline_alert.id\", ondelete=\"SET NULL\"), nullable=True\n+    )\n+    deadline_alert: Mapped[DeadlineAlert | None] = relationship(\"DeadlineAlert\")\n+\n     __table_args__ = (Index(\"deadline_missed_deadline_time_idx\", missed, deadline_time, unique=False),)\n \n     def __init__(\n         self,\n         deadline_time: datetime,\n         callback: CallbackDefinitionProtocol,\n         dagrun_id: int,\n+        deadline_alert_id: str | None,\n+        # TODO: can't we drop this and use self.dagrun.dag_id??",
      "comment": "I meant to message you about that before I merged but forgot.  Thanks.",
      "comment_id": 2521036342,
      "user": "ferruzzi",
      "created_at": "2025-11-13T02:55:29Z",
      "url": "https://github.com/apache/airflow/pull/58248#discussion_r2521036342"
    },
    {
      "repo": "apache/airflow",
      "pr_number": 58248,
      "file_path": "airflow-core/src/airflow/migrations/versions/0094_3_2_0_ui_improvements_for_deadlines.py",
      "line": 131,
      "side": "RIGHT",
      "diff_hunk": "@@ -0,0 +1,563 @@\n+#\n+# Licensed to the Apache Software Foundation (ASF) under one\n+# or more contributor license agreements.  See the NOTICE file\n+# distributed with this work for additional information\n+# regarding copyright ownership.  The ASF licenses this file\n+# to you under the Apache License, Version 2.0 (the\n+# \"License\"); you may not use this file except in compliance\n+# with the License.  You may obtain a copy of the License at\n+#\n+#   http://www.apache.org/licenses/LICENSE-2.0\n+#\n+# Unless required by applicable law or agreed to in writing,\n+# software distributed under the License is distributed on an\n+# \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+# KIND, either express or implied.  See the License for the\n+# specific language governing permissions and limitations\n+# under the License.\n+\n+\"\"\"\n+Add required fields to enable UI integrations for the Deadline Alerts feature.\n+\n+This migration creates the deadline_alert table to store DeadlineAlert definitions\n+and migrates existing Deadline Alert data from the serialized_dag JSON structure\n+into the new normalized table structure.\n+\n+Revision ID: 55297ae24532\n+Revises: 665854ef0536\n+Create Date: 2025-10-17 16:04:55.016272\n+\"\"\"\n+\n+from __future__ import annotations\n+\n+import json\n+import zlib\n+from collections import defaultdict\n+from typing import TYPE_CHECKING\n+\n+import sqlalchemy as sa\n+import uuid6\n+from alembic import op\n+from sqlalchemy_utils import UUIDType\n+\n+from airflow._shared.timezones import timezone\n+from airflow.migrations.db_types import TIMESTAMP\n+from airflow.utils.sqlalchemy import UtcDateTime\n+\n+if TYPE_CHECKING:\n+    from typing import Any\n+\n+    from sqlalchemy.engine import Connection\n+\n+    ErrorDict = dict[str, list[str]]\n+\n+revision = \"55297ae24532\"\n+down_revision = \"665854ef0536\"\n+branch_labels = None\n+depends_on = None\n+airflow_version = \"3.2.0\"\n+\n+\n+DEADLINE_ALERT_REQUIRED_FIELDS = {\"reference\", \"callback\", \"interval\"}\n+CALLBACK_KEY = \"callback\"\n+DAG_KEY = \"dag\"\n+DEADLINE_KEY = \"deadline\"\n+INTERVAL_KEY = \"interval\"\n+REFERENCE_KEY = \"reference\"\n+DEFAULT_BATCH_SIZE = 1000\n+ENCODING_TYPE = \"deadline_alert\"\n+\n+\n+def upgrade() -> None:\n+    \"\"\"Make changes to enable adding DeadlineAlerts to the UI.\"\"\"\n+    # TODO: We may finally have come up with a better naming convention. For ease of migration,\n+    #   we are going to keep deadline_alert here to match the model's name, but in the near future\n+    #   when this migration work is done we should deprecate the name DeadlineAlert (and all related\n+    #   classes, tables, etc) and replace it with DeadlineDefinition. Then we will have the\n+    #   user-provided DeadlineDefinition, and the actual instance of a Definition is (still) the Deadline.\n+    #   This feels more intuitive than DeadlineAlert defining the Deadline.\n+\n+    op.create_table(\n+        \"deadline_alert\",\n+        sa.Column(\"id\", UUIDType(binary=False), default=uuid6.uuid7),\n+        sa.Column(\n+            \"created_at\", UtcDateTime, nullable=False, server_default=sa.text(\"timezone('utc', now())\")\n+        ),\n+        sa.Column(\"serialized_dag_id\", UUIDType(binary=False), nullable=False),\n+        sa.Column(\"name\", sa.String(250), nullable=True),\n+        sa.Column(\"description\", sa.Text(), nullable=True),\n+        sa.Column(\"reference\", sa.JSON(), nullable=False),\n+        sa.Column(\"interval\", sa.Float(), nullable=False),\n+        sa.Column(\"callback\", sa.JSON(), nullable=False),\n+        sa.PrimaryKeyConstraint(\"id\", name=op.f(\"deadline_alert_pkey\")),\n+    )\n+\n+    with op.batch_alter_table(\"deadline\", schema=None) as batch_op:\n+        batch_op.add_column(sa.Column(\"deadline_alert_id\", UUIDType(binary=False), nullable=True))\n+        batch_op.add_column(\n+            sa.Column(\"created_at\", TIMESTAMP(timezone=True), nullable=False, server_default=sa.func.now())\n+        )\n+        batch_op.add_column(\n+            sa.Column(\n+                \"last_updated_at\", TIMESTAMP(timezone=True), nullable=False, server_default=sa.func.now()\n+            )\n+        )\n+\n+    op.create_foreign_key(\n+        op.f(\"deadline_deadline_alert_id_fkey\"),\n+        \"deadline\",\n+        \"deadline_alert\",\n+        [\"deadline_alert_id\"],\n+        [\"id\"],\n+        ondelete=\"SET NULL\",\n+    )\n+\n+    op.create_foreign_key(\n+        op.f(\"deadline_alert_serialized_dag_id_fkey\"),\n+        \"deadline_alert\",\n+        \"serialized_dag\",\n+        [\"serialized_dag_id\"],\n+        [\"id\"],\n+        ondelete=\"CASCADE\",\n+    )\n+\n+    migrate_existing_deadline_alert_data_from_serialized_dag()\n+\n+\n+def downgrade() -> None:\n+    \"\"\"Remove changes that were added to enable adding DeadlineAlerts to the UI.\"\"\"\n+    migrate_deadline_alert_data_back_to_serialized_dag()\n+\n+    op.drop_constraint(op.f(\"deadline_deadline_alert_id_fkey\"), \"deadline\", type_=\"foreignkey\")",
      "comment": "we'll need to to `\"PRAGMA foreign_keys=OFF\"` for sqlite. otherwise, it might break\n",
      "comment_id": 2521828870,
      "user": "Lee-W",
      "created_at": "2025-11-13T06:42:05Z",
      "url": "https://github.com/apache/airflow/pull/58248#discussion_r2521828870"
    },
    {
      "repo": "apache/airflow",
      "pr_number": 58248,
      "file_path": "airflow-core/src/airflow/models/deadline_alert.py",
      "line": 46,
      "side": "RIGHT",
      "diff_hunk": "@@ -0,0 +1,101 @@\n+# Licensed to the Apache Software Foundation (ASF) under one\n+# or more contributor license agreements.  See the NOTICE file\n+# distributed with this work for additional information\n+# regarding copyright ownership.  The ASF licenses this file\n+# to you under the Apache License, Version 2.0 (the\n+# \"License\"); you may not use this file except in compliance\n+# with the License.  You may obtain a copy of the License at\n+#\n+#   http://www.apache.org/licenses/LICENSE-2.0\n+#\n+# Unless required by applicable law or agreed to in writing,\n+# software distributed under the License is distributed on an\n+# \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+# KIND, either express or implied.  See the License for the\n+# specific language governing permissions and limitations\n+# under the License.\n+from __future__ import annotations\n+\n+from datetime import datetime\n+from typing import TYPE_CHECKING\n+\n+import uuid6\n+from sqlalchemy import JSON, Float, ForeignKey, String, Text, select\n+from sqlalchemy.orm import Mapped\n+from sqlalchemy_utils import UUIDType\n+\n+from airflow._shared.timezones import timezone\n+from airflow.models import Base\n+from airflow.models.deadline import ReferenceModels\n+from airflow.utils.session import NEW_SESSION, provide_session\n+from airflow.utils.sqlalchemy import UtcDateTime, mapped_column\n+\n+if TYPE_CHECKING:\n+    from sqlalchemy.orm import Session\n+\n+\n+class DeadlineAlert(Base):\n+    \"\"\"Table containing DeadlineAlert properties.\"\"\"\n+\n+    __tablename__ = \"deadline_alert\"\n+\n+    id: Mapped[str] = mapped_column(UUIDType(binary=False), primary_key=True, default=uuid6.uuid7)\n+    created_at: Mapped[datetime] = mapped_column(UtcDateTime, nullable=False, default=timezone.utcnow)\n+\n+    serialized_dag_id: Mapped[str] = mapped_column(",
      "comment": "Using serialized_dag_id should keep it synced with the proper dag version, but also since I am pulling the data out of the serialized_dag into the new table and replacing the old data with the UUIDs of the new rows, so it seemed the most logical",
      "comment_id": 2522673602,
      "user": "ferruzzi",
      "created_at": "2025-11-13T09:54:48Z",
      "url": "https://github.com/apache/airflow/pull/58248#discussion_r2522673602"
    },
    {
      "repo": "apache/airflow",
      "pr_number": 58248,
      "file_path": "airflow-core/src/airflow/models/dagrun.py",
      "line": 1263,
      "side": "RIGHT",
      "diff_hunk": "@@ -1259,11 +1260,15 @@ def recalculate(self) -> _UnfinishedStates:\n                     msg=\"success\",\n                 )\n \n-            if dag.deadline:\n+            if dag.deadline and isinstance(dag.deadline[0], str):",
      "comment": "I think I may have had to add it to make mypy's type checking happy, I'll try removing it and see what happens.  It's possible I'm mis-remembering.",
      "comment_id": 2522680922,
      "user": "ferruzzi",
      "created_at": "2025-11-13T09:56:13Z",
      "url": "https://github.com/apache/airflow/pull/58248#discussion_r2522680922"
    },
    {
      "repo": "apache/airflow",
      "pr_number": 58248,
      "file_path": "airflow-core/src/airflow/migrations/versions/0094_3_2_0_ui_improvements_for_deadlines.py",
      "line": 131,
      "side": "RIGHT",
      "diff_hunk": "@@ -0,0 +1,563 @@\n+#\n+# Licensed to the Apache Software Foundation (ASF) under one\n+# or more contributor license agreements.  See the NOTICE file\n+# distributed with this work for additional information\n+# regarding copyright ownership.  The ASF licenses this file\n+# to you under the Apache License, Version 2.0 (the\n+# \"License\"); you may not use this file except in compliance\n+# with the License.  You may obtain a copy of the License at\n+#\n+#   http://www.apache.org/licenses/LICENSE-2.0\n+#\n+# Unless required by applicable law or agreed to in writing,\n+# software distributed under the License is distributed on an\n+# \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+# KIND, either express or implied.  See the License for the\n+# specific language governing permissions and limitations\n+# under the License.\n+\n+\"\"\"\n+Add required fields to enable UI integrations for the Deadline Alerts feature.\n+\n+This migration creates the deadline_alert table to store DeadlineAlert definitions\n+and migrates existing Deadline Alert data from the serialized_dag JSON structure\n+into the new normalized table structure.\n+\n+Revision ID: 55297ae24532\n+Revises: 665854ef0536\n+Create Date: 2025-10-17 16:04:55.016272\n+\"\"\"\n+\n+from __future__ import annotations\n+\n+import json\n+import zlib\n+from collections import defaultdict\n+from typing import TYPE_CHECKING\n+\n+import sqlalchemy as sa\n+import uuid6\n+from alembic import op\n+from sqlalchemy_utils import UUIDType\n+\n+from airflow._shared.timezones import timezone\n+from airflow.migrations.db_types import TIMESTAMP\n+from airflow.utils.sqlalchemy import UtcDateTime\n+\n+if TYPE_CHECKING:\n+    from typing import Any\n+\n+    from sqlalchemy.engine import Connection\n+\n+    ErrorDict = dict[str, list[str]]\n+\n+revision = \"55297ae24532\"\n+down_revision = \"665854ef0536\"\n+branch_labels = None\n+depends_on = None\n+airflow_version = \"3.2.0\"\n+\n+\n+DEADLINE_ALERT_REQUIRED_FIELDS = {\"reference\", \"callback\", \"interval\"}\n+CALLBACK_KEY = \"callback\"\n+DAG_KEY = \"dag\"\n+DEADLINE_KEY = \"deadline\"\n+INTERVAL_KEY = \"interval\"\n+REFERENCE_KEY = \"reference\"\n+DEFAULT_BATCH_SIZE = 1000\n+ENCODING_TYPE = \"deadline_alert\"\n+\n+\n+def upgrade() -> None:\n+    \"\"\"Make changes to enable adding DeadlineAlerts to the UI.\"\"\"\n+    # TODO: We may finally have come up with a better naming convention. For ease of migration,\n+    #   we are going to keep deadline_alert here to match the model's name, but in the near future\n+    #   when this migration work is done we should deprecate the name DeadlineAlert (and all related\n+    #   classes, tables, etc) and replace it with DeadlineDefinition. Then we will have the\n+    #   user-provided DeadlineDefinition, and the actual instance of a Definition is (still) the Deadline.\n+    #   This feels more intuitive than DeadlineAlert defining the Deadline.\n+\n+    op.create_table(\n+        \"deadline_alert\",\n+        sa.Column(\"id\", UUIDType(binary=False), default=uuid6.uuid7),\n+        sa.Column(\n+            \"created_at\", UtcDateTime, nullable=False, server_default=sa.text(\"timezone('utc', now())\")\n+        ),\n+        sa.Column(\"serialized_dag_id\", UUIDType(binary=False), nullable=False),\n+        sa.Column(\"name\", sa.String(250), nullable=True),\n+        sa.Column(\"description\", sa.Text(), nullable=True),\n+        sa.Column(\"reference\", sa.JSON(), nullable=False),\n+        sa.Column(\"interval\", sa.Float(), nullable=False),\n+        sa.Column(\"callback\", sa.JSON(), nullable=False),\n+        sa.PrimaryKeyConstraint(\"id\", name=op.f(\"deadline_alert_pkey\")),\n+    )\n+\n+    with op.batch_alter_table(\"deadline\", schema=None) as batch_op:\n+        batch_op.add_column(sa.Column(\"deadline_alert_id\", UUIDType(binary=False), nullable=True))\n+        batch_op.add_column(\n+            sa.Column(\"created_at\", TIMESTAMP(timezone=True), nullable=False, server_default=sa.func.now())\n+        )\n+        batch_op.add_column(\n+            sa.Column(\n+                \"last_updated_at\", TIMESTAMP(timezone=True), nullable=False, server_default=sa.func.now()\n+            )\n+        )\n+\n+    op.create_foreign_key(\n+        op.f(\"deadline_deadline_alert_id_fkey\"),\n+        \"deadline\",\n+        \"deadline_alert\",\n+        [\"deadline_alert_id\"],\n+        [\"id\"],\n+        ondelete=\"SET NULL\",\n+    )\n+\n+    op.create_foreign_key(\n+        op.f(\"deadline_alert_serialized_dag_id_fkey\"),\n+        \"deadline_alert\",\n+        \"serialized_dag\",\n+        [\"serialized_dag_id\"],\n+        [\"id\"],\n+        ondelete=\"CASCADE\",\n+    )\n+\n+    migrate_existing_deadline_alert_data_from_serialized_dag()\n+\n+\n+def downgrade() -> None:\n+    \"\"\"Remove changes that were added to enable adding DeadlineAlerts to the UI.\"\"\"\n+    migrate_deadline_alert_data_back_to_serialized_dag()\n+\n+    op.drop_constraint(op.f(\"deadline_deadline_alert_id_fkey\"), \"deadline\", type_=\"foreignkey\")",
      "comment": "Let me know if I did that right: https://github.com/apache/airflow/pull/58248/commits/8f4196cfc96aa2d70fe34fdd489bdf000774f7a4",
      "comment_id": 2522707945,
      "user": "ferruzzi",
      "created_at": "2025-11-13T10:01:53Z",
      "url": "https://github.com/apache/airflow/pull/58248#discussion_r2522707945"
    },
    {
      "repo": "apache/airflow",
      "pr_number": 58248,
      "file_path": "airflow-core/src/airflow/models/deadline_alert.py",
      "line": 53,
      "side": "RIGHT",
      "diff_hunk": "@@ -0,0 +1,101 @@\n+# Licensed to the Apache Software Foundation (ASF) under one\n+# or more contributor license agreements.  See the NOTICE file\n+# distributed with this work for additional information\n+# regarding copyright ownership.  The ASF licenses this file\n+# to you under the Apache License, Version 2.0 (the\n+# \"License\"); you may not use this file except in compliance\n+# with the License.  You may obtain a copy of the License at\n+#\n+#   http://www.apache.org/licenses/LICENSE-2.0\n+#\n+# Unless required by applicable law or agreed to in writing,\n+# software distributed under the License is distributed on an\n+# \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+# KIND, either express or implied.  See the License for the\n+# specific language governing permissions and limitations\n+# under the License.\n+from __future__ import annotations\n+\n+from datetime import datetime\n+from typing import TYPE_CHECKING\n+\n+import uuid6\n+from sqlalchemy import JSON, Float, ForeignKey, String, Text, select\n+from sqlalchemy.orm import Mapped\n+from sqlalchemy_utils import UUIDType\n+\n+from airflow._shared.timezones import timezone\n+from airflow.models import Base\n+from airflow.models.deadline import ReferenceModels\n+from airflow.utils.session import NEW_SESSION, provide_session\n+from airflow.utils.sqlalchemy import UtcDateTime, mapped_column\n+\n+if TYPE_CHECKING:\n+    from sqlalchemy.orm import Session\n+\n+\n+class DeadlineAlert(Base):\n+    \"\"\"Table containing DeadlineAlert properties.\"\"\"\n+\n+    __tablename__ = \"deadline_alert\"\n+\n+    id: Mapped[str] = mapped_column(UUIDType(binary=False), primary_key=True, default=uuid6.uuid7)\n+    created_at: Mapped[datetime] = mapped_column(UtcDateTime, nullable=False, default=timezone.utcnow)\n+\n+    serialized_dag_id: Mapped[str] = mapped_column(\n+        UUIDType(binary=False), ForeignKey(\"serialized_dag.id\"), nullable=False\n+    )\n+\n+    name: Mapped[str | None] = mapped_column(String(250), nullable=True)\n+    description: Mapped[str | None] = mapped_column(Text, nullable=True)\n+    reference: Mapped[dict] = mapped_column(JSON, nullable=False)\n+    interval: Mapped[float] = mapped_column(Float, nullable=False)\n+    callback: Mapped[dict] = mapped_column(JSON, nullable=False)",
      "comment": "Done here:  https://github.com/apache/airflow/pull/58248/commits/ed9e75a08c800598887b0042324d1ca0d3d39737",
      "comment_id": 2522712594,
      "user": "ferruzzi",
      "created_at": "2025-11-13T10:02:50Z",
      "url": "https://github.com/apache/airflow/pull/58248#discussion_r2522712594"
    },
    {
      "repo": "apache/airflow",
      "pr_number": 58248,
      "file_path": "airflow-core/src/airflow/models/dagrun.py",
      "line": 1263,
      "side": "RIGHT",
      "diff_hunk": "@@ -1259,11 +1260,15 @@ def recalculate(self) -> _UnfinishedStates:\n                     msg=\"success\",\n                 )\n \n-            if dag.deadline:\n+            if dag.deadline and isinstance(dag.deadline[0], str):",
      "comment": "Yeah, it was for mypy, but I've gone back and fixed the root cause on that one.  There was a type hint that I missed switching over during the migration.",
      "comment_id": 2525027197,
      "user": "ferruzzi",
      "created_at": "2025-11-13T21:41:48Z",
      "url": "https://github.com/apache/airflow/pull/58248#discussion_r2525027197"
    },
    {
      "repo": "apache/airflow",
      "pr_number": 58248,
      "file_path": "airflow-core/src/airflow/models/deadline_alert.py",
      "line": 101,
      "side": "RIGHT",
      "diff_hunk": "@@ -0,0 +1,101 @@\n+# Licensed to the Apache Software Foundation (ASF) under one\n+# or more contributor license agreements.  See the NOTICE file\n+# distributed with this work for additional information\n+# regarding copyright ownership.  The ASF licenses this file\n+# to you under the Apache License, Version 2.0 (the\n+# \"License\"); you may not use this file except in compliance\n+# with the License.  You may obtain a copy of the License at\n+#\n+#   http://www.apache.org/licenses/LICENSE-2.0\n+#\n+# Unless required by applicable law or agreed to in writing,\n+# software distributed under the License is distributed on an\n+# \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+# KIND, either express or implied.  See the License for the\n+# specific language governing permissions and limitations\n+# under the License.\n+from __future__ import annotations\n+\n+from datetime import datetime\n+from typing import TYPE_CHECKING\n+\n+import uuid6\n+from sqlalchemy import JSON, Float, ForeignKey, String, Text, select\n+from sqlalchemy.orm import Mapped\n+from sqlalchemy_utils import UUIDType\n+\n+from airflow._shared.timezones import timezone\n+from airflow.models import Base\n+from airflow.models.deadline import ReferenceModels\n+from airflow.utils.session import NEW_SESSION, provide_session\n+from airflow.utils.sqlalchemy import UtcDateTime, mapped_column\n+\n+if TYPE_CHECKING:\n+    from sqlalchemy.orm import Session\n+\n+\n+class DeadlineAlert(Base):\n+    \"\"\"Table containing DeadlineAlert properties.\"\"\"\n+\n+    __tablename__ = \"deadline_alert\"\n+\n+    id: Mapped[str] = mapped_column(UUIDType(binary=False), primary_key=True, default=uuid6.uuid7)\n+    created_at: Mapped[datetime] = mapped_column(UtcDateTime, nullable=False, default=timezone.utcnow)\n+\n+    serialized_dag_id: Mapped[str] = mapped_column(\n+        UUIDType(binary=False), ForeignKey(\"serialized_dag.id\"), nullable=False\n+    )\n+\n+    name: Mapped[str | None] = mapped_column(String(250), nullable=True)\n+    description: Mapped[str | None] = mapped_column(Text, nullable=True)\n+    reference: Mapped[dict] = mapped_column(JSON, nullable=False)\n+    interval: Mapped[float] = mapped_column(Float, nullable=False)\n+    callback_def: Mapped[dict] = mapped_column(JSON, nullable=False)\n+\n+    def __repr__(self):\n+        interval_seconds = int(self.interval)\n+\n+        if interval_seconds >= 3600:\n+            interval_display = f\"{interval_seconds // 3600}h\"\n+        elif interval_seconds >= 60:\n+            interval_display = f\"{interval_seconds // 60}m\"\n+        else:\n+            interval_display = f\"{interval_seconds}s\"\n+\n+        return (\n+            f\"[DeadlineAlert] \"\n+            f\"id={str(self.id)[:8]}, \"\n+            f\"created_at={self.created_at}, \"\n+            f\"name={self.name or 'Unnamed'}, \"\n+            f\"reference={self.reference}, \"\n+            f\"interval={interval_display}, \"\n+            f\"callback={self.callback_def}\"\n+        )\n+\n+    def __eq__(self, other):\n+        if not isinstance(other, DeadlineAlert):\n+            return False\n+        return (\n+            self.reference == other.reference\n+            and self.interval == other.interval\n+            and self.callback_def == other.callback_def\n+        )\n+\n+    def __hash__(self):\n+        return hash((str(self.reference), self.interval, str(self.callback_def)))\n+\n+    @property\n+    def reference_class(self) -> type[ReferenceModels.BaseDeadlineReference]:\n+        \"\"\"Return the deserialized reference object.\"\"\"\n+        return ReferenceModels.get_reference_class(self.reference[ReferenceModels.REFERENCE_TYPE_FIELD])\n+\n+    @classmethod\n+    @provide_session\n+    def get_by_id(cls, deadline_alert_id: str, session: Session = NEW_SESSION) -> DeadlineAlert:\n+        \"\"\"\n+        Retrieve a DeadlineAlert record by its UUID.\n+\n+        :param deadline_alert_id: The UUID of the DeadlineAlert to retrieve\n+        :param session: Database session\n+        \"\"\"\n+        return session.execute(select(cls).filter_by(id=deadline_alert_id)).scalar_one()",
      "comment": "```suggestion\r\n        return session.scalar(select(cls).where(cls.id=deadline_alert_id))\r\n```",
      "comment_id": 2563791878,
      "user": "ephraimbuddy",
      "created_at": "2025-11-26T07:52:47Z",
      "url": "https://github.com/apache/airflow/pull/58248#discussion_r2563791878"
    },
    {
      "repo": "apache/airflow",
      "pr_number": 58248,
      "file_path": "airflow-core/src/airflow/models/serialized_dag.py",
      "line": 421,
      "side": "RIGHT",
      "diff_hunk": "@@ -371,6 +374,111 @@ def _sort_serialized_dag_dict(cls, serialized_dag: Any):\n             return [cls._sort_serialized_dag_dict(i) for i in serialized_dag]\n         return serialized_dag\n \n+    @classmethod\n+    def _process_deadline_alerts(\n+        cls,\n+        serialized_dag_id: str,\n+        dag_data: dict[str, Any],\n+        session: Session,\n+    ) -> bool:\n+        \"\"\"\n+        Process DeadlineAlerts for a Dag during serialization.\n+\n+        Creates or finds deadline_alert records in the database and replaces\n+        the deadline field in dag_data with UUID references.\n+\n+        :param serialized_dag_id: The serialized_dag id\n+        :param dag_data: The serialized Dag data dictionary (will be modified in place)\n+        :param session: Database session\n+        \"\"\"\n+        dag_deadline_data = dag_data.get(\"dag\", {}).get(\"deadline\")\n+        if not dag_deadline_data:\n+            return False\n+\n+        log.debug(\"Processing DeadlineAlerts for Dag: %s\", serialized_dag_id)\n+\n+        deadline_alerts = dag_deadline_data if isinstance(dag_deadline_data, list) else [dag_deadline_data]\n+        deadline_alert_ids = []\n+        new_alerts = []\n+\n+        for deadline_alert in deadline_alerts:\n+            deadline_data = deadline_alert.get(Encoding.VAR, deadline_alert)\n+\n+            reference = deadline_data[DeadlineAlertFields.REFERENCE]\n+            interval = deadline_data[DeadlineAlertFields.INTERVAL]\n+            callback = deadline_data[DeadlineAlertFields.CALLBACK]\n+\n+            # This looks odd, but I had issues comparing the serialized data directly\n+            # while doing manual testing. To avoid them, we fetch by dag_id and interval,\n+            # then use python's dict comparison instead of trying to match strings in SQL.\n+            candidates = (\n+                session.execute(\n+                    select(DeadlineAlertModel).filter(\n+                        DeadlineAlertModel.serialized_dag_id == serialized_dag_id,\n+                        DeadlineAlertModel.interval == interval,\n+                    )\n+                )\n+                .scalars()",
      "comment": "```suggestion\r\n                session.scalars(\r\n                    select(DeadlineAlertModel).where(\r\n                        DeadlineAlertModel.serialized_dag_id == serialized_dag_id,\r\n                        DeadlineAlertModel.interval == interval,\r\n                    )\r\n                )\r\n```",
      "comment_id": 2563802006,
      "user": "ephraimbuddy",
      "created_at": "2025-11-26T07:55:28Z",
      "url": "https://github.com/apache/airflow/pull/58248#discussion_r2563802006"
    },
    {
      "repo": "apache/airflow",
      "pr_number": 58248,
      "file_path": "airflow-core/src/airflow/models/serialized_dag.py",
      "line": 422,
      "side": "RIGHT",
      "diff_hunk": "@@ -371,6 +374,111 @@ def _sort_serialized_dag_dict(cls, serialized_dag: Any):\n             return [cls._sort_serialized_dag_dict(i) for i in serialized_dag]\n         return serialized_dag\n \n+    @classmethod\n+    def _process_deadline_alerts(\n+        cls,\n+        serialized_dag_id: str,\n+        dag_data: dict[str, Any],\n+        session: Session,\n+    ) -> bool:\n+        \"\"\"\n+        Process DeadlineAlerts for a Dag during serialization.\n+\n+        Creates or finds deadline_alert records in the database and replaces\n+        the deadline field in dag_data with UUID references.\n+\n+        :param serialized_dag_id: The serialized_dag id\n+        :param dag_data: The serialized Dag data dictionary (will be modified in place)\n+        :param session: Database session\n+        \"\"\"\n+        dag_deadline_data = dag_data.get(\"dag\", {}).get(\"deadline\")\n+        if not dag_deadline_data:\n+            return False\n+\n+        log.debug(\"Processing DeadlineAlerts for Dag: %s\", serialized_dag_id)\n+\n+        deadline_alerts = dag_deadline_data if isinstance(dag_deadline_data, list) else [dag_deadline_data]\n+        deadline_alert_ids = []\n+        new_alerts = []\n+\n+        for deadline_alert in deadline_alerts:\n+            deadline_data = deadline_alert.get(Encoding.VAR, deadline_alert)\n+\n+            reference = deadline_data[DeadlineAlertFields.REFERENCE]\n+            interval = deadline_data[DeadlineAlertFields.INTERVAL]\n+            callback = deadline_data[DeadlineAlertFields.CALLBACK]\n+\n+            # This looks odd, but I had issues comparing the serialized data directly\n+            # while doing manual testing. To avoid them, we fetch by dag_id and interval,\n+            # then use python's dict comparison instead of trying to match strings in SQL.\n+            candidates = (\n+                session.execute(\n+                    select(DeadlineAlertModel).filter(\n+                        DeadlineAlertModel.serialized_dag_id == serialized_dag_id,\n+                        DeadlineAlertModel.interval == interval,\n+                    )\n+                )\n+                .scalars()\n+                .all()",
      "comment": "You might want to remove `all()` and iterate with the ScalarsResult generator",
      "comment_id": 2563807254,
      "user": "ephraimbuddy",
      "created_at": "2025-11-26T07:57:03Z",
      "url": "https://github.com/apache/airflow/pull/58248#discussion_r2563807254"
    },
    {
      "repo": "apache/airflow",
      "pr_number": 58248,
      "file_path": "airflow-core/src/airflow/models/serialized_dag.py",
      "line": 435,
      "side": "RIGHT",
      "diff_hunk": "@@ -371,6 +374,111 @@ def _sort_serialized_dag_dict(cls, serialized_dag: Any):\n             return [cls._sort_serialized_dag_dict(i) for i in serialized_dag]\n         return serialized_dag\n \n+    @classmethod\n+    def _process_deadline_alerts(\n+        cls,\n+        serialized_dag_id: str,\n+        dag_data: dict[str, Any],\n+        session: Session,\n+    ) -> bool:\n+        \"\"\"\n+        Process DeadlineAlerts for a Dag during serialization.\n+\n+        Creates or finds deadline_alert records in the database and replaces\n+        the deadline field in dag_data with UUID references.\n+\n+        :param serialized_dag_id: The serialized_dag id\n+        :param dag_data: The serialized Dag data dictionary (will be modified in place)\n+        :param session: Database session\n+        \"\"\"\n+        dag_deadline_data = dag_data.get(\"dag\", {}).get(\"deadline\")\n+        if not dag_deadline_data:\n+            return False\n+\n+        log.debug(\"Processing DeadlineAlerts for Dag: %s\", serialized_dag_id)\n+\n+        deadline_alerts = dag_deadline_data if isinstance(dag_deadline_data, list) else [dag_deadline_data]\n+        deadline_alert_ids = []\n+        new_alerts = []\n+\n+        for deadline_alert in deadline_alerts:\n+            deadline_data = deadline_alert.get(Encoding.VAR, deadline_alert)\n+\n+            reference = deadline_data[DeadlineAlertFields.REFERENCE]\n+            interval = deadline_data[DeadlineAlertFields.INTERVAL]\n+            callback = deadline_data[DeadlineAlertFields.CALLBACK]\n+\n+            # This looks odd, but I had issues comparing the serialized data directly\n+            # while doing manual testing. To avoid them, we fetch by dag_id and interval,\n+            # then use python's dict comparison instead of trying to match strings in SQL.\n+            candidates = (\n+                session.execute(\n+                    select(DeadlineAlertModel).filter(\n+                        DeadlineAlertModel.serialized_dag_id == serialized_dag_id,\n+                        DeadlineAlertModel.interval == interval,\n+                    )\n+                )\n+                .scalars()\n+                .all()\n+            )\n+\n+            existing_alert = None\n+            for alert in candidates:\n+                if alert.reference == reference and alert.callback_def == callback:\n+                    existing_alert = alert\n+                    break\n+\n+            if existing_alert:\n+                log.debug(\"Found existing DeadlineAlert: %s\", existing_alert.id)\n+                deadline_alert_ids.append(str(existing_alert.id))\n+            else:\n+                log.warning(\"No existing alert found, creating... \")",
      "comment": "```suggestion\r\n                log.warning(\"Creating deadline alert...\")\r\n```\r\nI think there's no need informing users that there was no existing alert",
      "comment_id": 2563813070,
      "user": "ephraimbuddy",
      "created_at": "2025-11-26T07:58:43Z",
      "url": "https://github.com/apache/airflow/pull/58248#discussion_r2563813070"
    },
    {
      "repo": "apache/airflow",
      "pr_number": 58248,
      "file_path": "airflow-core/src/airflow/models/serialized_dag.py",
      "line": 581,
      "side": "RIGHT",
      "diff_hunk": "@@ -470,6 +578,15 @@ def write_dag(\n         log.debug(\"Writing Serialized DAG: %s to the DB\", dag.dag_id)\n         new_serialized_dag.dag_version = dagv\n         session.add(new_serialized_dag)\n+        session.flush()",
      "comment": "We cannot flush here. The whole operations on `write_dag` should be atomic, no commit, no flushing. ",
      "comment_id": 2563821452,
      "user": "ephraimbuddy",
      "created_at": "2025-11-26T08:00:50Z",
      "url": "https://github.com/apache/airflow/pull/58248#discussion_r2563821452"
    },
    {
      "repo": "apache/airflow",
      "pr_number": 58248,
      "file_path": "airflow-core/src/airflow/models/serialized_dag.py",
      "line": 712,
      "side": "RIGHT",
      "diff_hunk": "@@ -563,6 +680,65 @@ def data(self) -> dict | None:\n \n         return self.__data_cache\n \n+    @classmethod\n+    def _reconstruct_deadline_alerts(\n+        cls,\n+        dag_data: dict[str, Any],\n+        serialized_dag_id: str,\n+        session: Session,\n+    ) -> dict[str, Any]:\n+        \"\"\"\n+        Reconstruct DeadlineAlert objects from UUID references during deserialization.\n+\n+        Queries the deadline_alert table to fetch full DeadlineAlert definitions\n+        and reconstructs them in the serialized format expected by SerializedDAG.\n+\n+        :param dag_data: The serialized Dag data dictionary\n+        :param serialized_dag_id: The serialized_dag ID\n+        \"\"\"\n+        dag_deadline_data = dag_data.get(\"dag\", {}).get(\"deadline\")\n+        if not dag_deadline_data:\n+            return dag_data\n+\n+        deadline_list = dag_deadline_data if isinstance(dag_deadline_data, list) else [dag_deadline_data]\n+        deadline_alerts_by_id = {\n+            str(alert.id): alert\n+            for alert in session.execute(\n+                select(DeadlineAlertModel).filter(\n+                    DeadlineAlertModel.id.in_(deadline_list),\n+                    DeadlineAlertModel.serialized_dag_id == serialized_dag_id,\n+                )\n+            )\n+            .scalars()",
      "comment": "```suggestion\r\n            for alert in session.scalars(\r\n                select(DeadlineAlertModel).where(\r\n                    DeadlineAlertModel.id.in_(deadline_list),\r\n                    DeadlineAlertModel.serialized_dag_id == serialized_dag_id,\r\n                )\r\n            )\r\n```\r\nexecute is used where we want some tuples. Using scalars directly is better",
      "comment_id": 2563848167,
      "user": "ephraimbuddy",
      "created_at": "2025-11-26T08:07:48Z",
      "url": "https://github.com/apache/airflow/pull/58248#discussion_r2563848167"
    },
    {
      "repo": "apache/airflow",
      "pr_number": 58248,
      "file_path": "airflow-core/src/airflow/serialization/serialized_objects.py",
      "line": 3223,
      "side": "RIGHT",
      "diff_hunk": "@@ -3361,27 +3356,77 @@ def create_dagrun(\n         )\n \n         if self.deadline:\n-            for deadline in cast(\"list\", self.deadline):\n-                if isinstance(deadline.reference, DeadlineReference.TYPES.DAGRUN):\n-                    deadline_time = deadline.reference.evaluate_with(\n-                        session=session,\n-                        interval=deadline.interval,\n-                        dag_id=self.dag_id,\n-                        run_id=run_id,\n-                    )\n-                    if deadline_time is not None:\n-                        session.add(\n-                            Deadline(\n-                                deadline_time=deadline_time,\n-                                callback=deadline.callback,\n-                                dagrun_id=orm_dagrun.id,\n-                                dag_id=orm_dagrun.dag_id,\n-                            )\n-                        )\n-                        Stats.incr(\"deadline_alerts.deadline_created\", tags={\"dag_id\": self.dag_id})\n+            self._process_dagrun_deadline_alerts(orm_dagrun, session)\n \n         return orm_dagrun\n \n+    def _process_dagrun_deadline_alerts(\n+        self,\n+        orm_dagrun: DagRun,\n+        session: Session,\n+    ) -> None:\n+        \"\"\"\n+        Process deadline alerts for a newly created DagRun.\n+\n+        Creates Deadline records for any DeadlineAlerts that reference DAGRUN.\n+\n+        :param orm_dagrun: The newly created DagRun\n+        :param session: Database session\n+        \"\"\"\n+        # Import here to avoid circular dependency\n+        from airflow.models.serialized_dag import SerializedDagModel\n+\n+        # Get the serialized_dag ID for this DAG\n+        serialized_dag_id = session.scalar(\n+            select(SerializedDagModel.id).where(SerializedDagModel.dag_id == self.dag_id).limit(1)\n+        )",
      "comment": "I think the approach here is wrong in dag versioning context because you might end up getting the wrong version of the serdag. ",
      "comment_id": 2563861003,
      "user": "ephraimbuddy",
      "created_at": "2025-11-26T08:11:08Z",
      "url": "https://github.com/apache/airflow/pull/58248#discussion_r2563861003"
    },
    {
      "repo": "apache/airflow",
      "pr_number": 58248,
      "file_path": "airflow-core/src/airflow/serialization/serialized_objects.py",
      "line": 3223,
      "side": "RIGHT",
      "diff_hunk": "@@ -3361,27 +3356,77 @@ def create_dagrun(\n         )\n \n         if self.deadline:\n-            for deadline in cast(\"list\", self.deadline):\n-                if isinstance(deadline.reference, DeadlineReference.TYPES.DAGRUN):\n-                    deadline_time = deadline.reference.evaluate_with(\n-                        session=session,\n-                        interval=deadline.interval,\n-                        dag_id=self.dag_id,\n-                        run_id=run_id,\n-                    )\n-                    if deadline_time is not None:\n-                        session.add(\n-                            Deadline(\n-                                deadline_time=deadline_time,\n-                                callback=deadline.callback,\n-                                dagrun_id=orm_dagrun.id,\n-                                dag_id=orm_dagrun.dag_id,\n-                            )\n-                        )\n-                        Stats.incr(\"deadline_alerts.deadline_created\", tags={\"dag_id\": self.dag_id})\n+            self._process_dagrun_deadline_alerts(orm_dagrun, session)\n \n         return orm_dagrun\n \n+    def _process_dagrun_deadline_alerts(\n+        self,\n+        orm_dagrun: DagRun,\n+        session: Session,\n+    ) -> None:\n+        \"\"\"\n+        Process deadline alerts for a newly created DagRun.\n+\n+        Creates Deadline records for any DeadlineAlerts that reference DAGRUN.\n+\n+        :param orm_dagrun: The newly created DagRun\n+        :param session: Database session\n+        \"\"\"\n+        # Import here to avoid circular dependency\n+        from airflow.models.serialized_dag import SerializedDagModel\n+\n+        # Get the serialized_dag ID for this DAG\n+        serialized_dag_id = session.scalar(\n+            select(SerializedDagModel.id).where(SerializedDagModel.dag_id == self.dag_id).limit(1)\n+        )",
      "comment": "Do you have a suggestion?   I thought the serdag was versioned, one serdag is one specific version of a given dag? ",
      "comment_id": 2563927598,
      "user": "ferruzzi",
      "created_at": "2025-11-26T08:26:02Z",
      "url": "https://github.com/apache/airflow/pull/58248#discussion_r2563927598"
    },
    {
      "repo": "apache/airflow",
      "pr_number": 58248,
      "file_path": "airflow-core/src/airflow/models/serialized_dag.py",
      "line": 712,
      "side": "RIGHT",
      "diff_hunk": "@@ -563,6 +680,65 @@ def data(self) -> dict | None:\n \n         return self.__data_cache\n \n+    @classmethod\n+    def _reconstruct_deadline_alerts(\n+        cls,\n+        dag_data: dict[str, Any],\n+        serialized_dag_id: str,\n+        session: Session,\n+    ) -> dict[str, Any]:\n+        \"\"\"\n+        Reconstruct DeadlineAlert objects from UUID references during deserialization.\n+\n+        Queries the deadline_alert table to fetch full DeadlineAlert definitions\n+        and reconstructs them in the serialized format expected by SerializedDAG.\n+\n+        :param dag_data: The serialized Dag data dictionary\n+        :param serialized_dag_id: The serialized_dag ID\n+        \"\"\"\n+        dag_deadline_data = dag_data.get(\"dag\", {}).get(\"deadline\")\n+        if not dag_deadline_data:\n+            return dag_data\n+\n+        deadline_list = dag_deadline_data if isinstance(dag_deadline_data, list) else [dag_deadline_data]\n+        deadline_alerts_by_id = {\n+            str(alert.id): alert\n+            for alert in session.execute(\n+                select(DeadlineAlertModel).filter(\n+                    DeadlineAlertModel.id.in_(deadline_list),\n+                    DeadlineAlertModel.serialized_dag_id == serialized_dag_id,\n+                )\n+            )\n+            .scalars()",
      "comment": "Thanks!   I was a bit confused on when to use one vs the other, I think that makes sense now.  I'll make the changes.",
      "comment_id": 2563930843,
      "user": "ferruzzi",
      "created_at": "2025-11-26T08:26:49Z",
      "url": "https://github.com/apache/airflow/pull/58248#discussion_r2563930843"
    },
    {
      "repo": "apache/airflow",
      "pr_number": 58248,
      "file_path": "airflow-core/src/airflow/serialization/serialized_objects.py",
      "line": 3223,
      "side": "RIGHT",
      "diff_hunk": "@@ -3361,27 +3356,77 @@ def create_dagrun(\n         )\n \n         if self.deadline:\n-            for deadline in cast(\"list\", self.deadline):\n-                if isinstance(deadline.reference, DeadlineReference.TYPES.DAGRUN):\n-                    deadline_time = deadline.reference.evaluate_with(\n-                        session=session,\n-                        interval=deadline.interval,\n-                        dag_id=self.dag_id,\n-                        run_id=run_id,\n-                    )\n-                    if deadline_time is not None:\n-                        session.add(\n-                            Deadline(\n-                                deadline_time=deadline_time,\n-                                callback=deadline.callback,\n-                                dagrun_id=orm_dagrun.id,\n-                                dag_id=orm_dagrun.dag_id,\n-                            )\n-                        )\n-                        Stats.incr(\"deadline_alerts.deadline_created\", tags={\"dag_id\": self.dag_id})\n+            self._process_dagrun_deadline_alerts(orm_dagrun, session)\n \n         return orm_dagrun\n \n+    def _process_dagrun_deadline_alerts(\n+        self,\n+        orm_dagrun: DagRun,\n+        session: Session,\n+    ) -> None:\n+        \"\"\"\n+        Process deadline alerts for a newly created DagRun.\n+\n+        Creates Deadline records for any DeadlineAlerts that reference DAGRUN.\n+\n+        :param orm_dagrun: The newly created DagRun\n+        :param session: Database session\n+        \"\"\"\n+        # Import here to avoid circular dependency\n+        from airflow.models.serialized_dag import SerializedDagModel\n+\n+        # Get the serialized_dag ID for this DAG\n+        serialized_dag_id = session.scalar(\n+            select(SerializedDagModel.id).where(SerializedDagModel.dag_id == self.dag_id).limit(1)\n+        )",
      "comment": "We can check the dag_version associated with the dagrun then use the dag_version to retrieve the serdag",
      "comment_id": 2563993388,
      "user": "ephraimbuddy",
      "created_at": "2025-11-26T08:41:43Z",
      "url": "https://github.com/apache/airflow/pull/58248#discussion_r2563993388"
    },
    {
      "repo": "apache/airflow",
      "pr_number": 58248,
      "file_path": "airflow-core/src/airflow/models/serialized_dag.py",
      "line": 422,
      "side": "RIGHT",
      "diff_hunk": "@@ -371,6 +374,111 @@ def _sort_serialized_dag_dict(cls, serialized_dag: Any):\n             return [cls._sort_serialized_dag_dict(i) for i in serialized_dag]\n         return serialized_dag\n \n+    @classmethod\n+    def _process_deadline_alerts(\n+        cls,\n+        serialized_dag_id: str,\n+        dag_data: dict[str, Any],\n+        session: Session,\n+    ) -> bool:\n+        \"\"\"\n+        Process DeadlineAlerts for a Dag during serialization.\n+\n+        Creates or finds deadline_alert records in the database and replaces\n+        the deadline field in dag_data with UUID references.\n+\n+        :param serialized_dag_id: The serialized_dag id\n+        :param dag_data: The serialized Dag data dictionary (will be modified in place)\n+        :param session: Database session\n+        \"\"\"\n+        dag_deadline_data = dag_data.get(\"dag\", {}).get(\"deadline\")\n+        if not dag_deadline_data:\n+            return False\n+\n+        log.debug(\"Processing DeadlineAlerts for Dag: %s\", serialized_dag_id)\n+\n+        deadline_alerts = dag_deadline_data if isinstance(dag_deadline_data, list) else [dag_deadline_data]\n+        deadline_alert_ids = []\n+        new_alerts = []\n+\n+        for deadline_alert in deadline_alerts:\n+            deadline_data = deadline_alert.get(Encoding.VAR, deadline_alert)\n+\n+            reference = deadline_data[DeadlineAlertFields.REFERENCE]\n+            interval = deadline_data[DeadlineAlertFields.INTERVAL]\n+            callback = deadline_data[DeadlineAlertFields.CALLBACK]\n+\n+            # This looks odd, but I had issues comparing the serialized data directly\n+            # while doing manual testing. To avoid them, we fetch by dag_id and interval,\n+            # then use python's dict comparison instead of trying to match strings in SQL.\n+            candidates = (\n+                session.execute(\n+                    select(DeadlineAlertModel).filter(\n+                        DeadlineAlertModel.serialized_dag_id == serialized_dag_id,\n+                        DeadlineAlertModel.interval == interval,\n+                    )\n+                )\n+                .scalars()\n+                .all()",
      "comment": "I just read up on that and you are absolutely right, that's a much better answer.",
      "comment_id": 2564007579,
      "user": "ferruzzi",
      "created_at": "2025-11-26T08:44:52Z",
      "url": "https://github.com/apache/airflow/pull/58248#discussion_r2564007579"
    },
    {
      "repo": "apache/airflow",
      "pr_number": 58248,
      "file_path": "airflow-core/src/airflow/serialization/serialized_objects.py",
      "line": 3223,
      "side": "RIGHT",
      "diff_hunk": "@@ -3361,27 +3356,77 @@ def create_dagrun(\n         )\n \n         if self.deadline:\n-            for deadline in cast(\"list\", self.deadline):\n-                if isinstance(deadline.reference, DeadlineReference.TYPES.DAGRUN):\n-                    deadline_time = deadline.reference.evaluate_with(\n-                        session=session,\n-                        interval=deadline.interval,\n-                        dag_id=self.dag_id,\n-                        run_id=run_id,\n-                    )\n-                    if deadline_time is not None:\n-                        session.add(\n-                            Deadline(\n-                                deadline_time=deadline_time,\n-                                callback=deadline.callback,\n-                                dagrun_id=orm_dagrun.id,\n-                                dag_id=orm_dagrun.dag_id,\n-                            )\n-                        )\n-                        Stats.incr(\"deadline_alerts.deadline_created\", tags={\"dag_id\": self.dag_id})\n+            self._process_dagrun_deadline_alerts(orm_dagrun, session)\n \n         return orm_dagrun\n \n+    def _process_dagrun_deadline_alerts(\n+        self,\n+        orm_dagrun: DagRun,\n+        session: Session,\n+    ) -> None:\n+        \"\"\"\n+        Process deadline alerts for a newly created DagRun.\n+\n+        Creates Deadline records for any DeadlineAlerts that reference DAGRUN.\n+\n+        :param orm_dagrun: The newly created DagRun\n+        :param session: Database session\n+        \"\"\"\n+        # Import here to avoid circular dependency\n+        from airflow.models.serialized_dag import SerializedDagModel\n+\n+        # Get the serialized_dag ID for this DAG\n+        serialized_dag_id = session.scalar(\n+            select(SerializedDagModel.id).where(SerializedDagModel.dag_id == self.dag_id).limit(1)\n+        )",
      "comment": "Would this work?\r\n\r\n```\r\nserialized_dag_id = session.scalar(\r\n    select(SerializedDagModel.id).where(\r\n        SerializedDagModel.dag_version_id == orm_dagrun.created_dag_version_id\r\n    )\r\n)\r\n```",
      "comment_id": 2564177270,
      "user": "ferruzzi",
      "created_at": "2025-11-26T09:18:50Z",
      "url": "https://github.com/apache/airflow/pull/58248#discussion_r2564177270"
    },
    {
      "repo": "apache/airflow",
      "pr_number": 58248,
      "file_path": "airflow-core/src/airflow/models/serialized_dag.py",
      "line": 583,
      "side": "RIGHT",
      "diff_hunk": "@@ -470,6 +578,15 @@ def write_dag(\n         log.debug(\"Writing Serialized DAG: %s to the DB\", dag.dag_id)\n         new_serialized_dag.dag_version = dagv\n         session.add(new_serialized_dag)\n+        session.flush()\n+\n+        if new_serialized_dag.data:",
      "comment": "I'm surprised by that. See what we do here:\r\nhttps://github.com/apache/airflow/blob/b54700e7b75470f98ff963d6314ba21536f24360/airflow-core/src/airflow/models/serialized_dag.py#L327-L332",
      "comment_id": 2564424640,
      "user": "ephraimbuddy",
      "created_at": "2025-11-26T10:25:36Z",
      "url": "https://github.com/apache/airflow/pull/58248#discussion_r2564424640"
    },
    {
      "repo": "apache/airflow",
      "pr_number": 58248,
      "file_path": "airflow-core/src/airflow/models/serialized_dag.py",
      "line": 581,
      "side": "RIGHT",
      "diff_hunk": "@@ -470,6 +578,15 @@ def write_dag(\n         log.debug(\"Writing Serialized DAG: %s to the DB\", dag.dag_id)\n         new_serialized_dag.dag_version = dagv\n         session.add(new_serialized_dag)\n+        session.flush()",
      "comment": "On this, we should check about flushing though. My thinking is that once we flush and now have some id, we risk committing it differently if there's error while adding other items",
      "comment_id": 2564438062,
      "user": "ephraimbuddy",
      "created_at": "2025-11-26T10:29:40Z",
      "url": "https://github.com/apache/airflow/pull/58248#discussion_r2564438062"
    },
    {
      "repo": "apache/airflow",
      "pr_number": 58248,
      "file_path": "airflow-core/src/airflow/models/serialized_dag.py",
      "line": 581,
      "side": "RIGHT",
      "diff_hunk": "@@ -470,6 +578,15 @@ def write_dag(\n         log.debug(\"Writing Serialized DAG: %s to the DB\", dag.dag_id)\n         new_serialized_dag.dag_version = dagv\n         session.add(new_serialized_dag)\n+        session.flush()",
      "comment": "I think I may need a hand on this one.  If we don't flush then we don't have the serdag id.  I initially had all of this tied to dag_id instead of serdag_id, and we do have dag_id at this point so we didn't need the flush, but serdag does feel like the more accurate \"connection point\".\r\n\r\nI'll have a look and see if I can shift the logic to somewhere outside of write_dag maybe",
      "comment_id": 2566580844,
      "user": "ferruzzi",
      "created_at": "2025-11-26T21:55:22Z",
      "url": "https://github.com/apache/airflow/pull/58248#discussion_r2566580844"
    },
    {
      "repo": "apache/airflow",
      "pr_number": 58248,
      "file_path": "airflow-core/src/airflow/models/serialized_dag.py",
      "line": 581,
      "side": "RIGHT",
      "diff_hunk": "@@ -470,6 +578,15 @@ def write_dag(\n         log.debug(\"Writing Serialized DAG: %s to the DB\", dag.dag_id)\n         new_serialized_dag.dag_version = dagv\n         session.add(new_serialized_dag)\n+        session.flush()",
      "comment": "I think I have an answer.  I'm going to test it out and make sure it works, but it will remove the flush here and in SerializedDagModel::_process_deadline_alerts  I'll let you know tomorrow.",
      "comment_id": 2566762425,
      "user": "ferruzzi",
      "created_at": "2025-11-27T00:09:44Z",
      "url": "https://github.com/apache/airflow/pull/58248#discussion_r2566762425"
    },
    {
      "repo": "apache/airflow",
      "pr_number": 58248,
      "file_path": "airflow-core/src/airflow/models/serialized_dag.py",
      "line": 581,
      "side": "RIGHT",
      "diff_hunk": "@@ -470,6 +578,15 @@ def write_dag(\n         log.debug(\"Writing Serialized DAG: %s to the DB\", dag.dag_id)\n         new_serialized_dag.dag_version = dagv\n         session.add(new_serialized_dag)\n+        session.flush()",
      "comment": "Alright, that took a bit of massaging, but I thin k I got it sorted out..  Let me know what you think",
      "comment_id": 2572688815,
      "user": "ferruzzi",
      "created_at": "2025-11-29T00:35:11Z",
      "url": "https://github.com/apache/airflow/pull/58248#discussion_r2572688815"
    },
    {
      "repo": "apache/airflow",
      "pr_number": 58248,
      "file_path": "airflow-core/src/airflow/migrations/versions/0099_3_2_0_ui_improvements_for_deadlines.py",
      "line": 531,
      "side": "RIGHT",
      "diff_hunk": "@@ -0,0 +1,636 @@\n+#\n+# Licensed to the Apache Software Foundation (ASF) under one\n+# or more contributor license agreements.  See the NOTICE file\n+# distributed with this work for additional information\n+# regarding copyright ownership.  The ASF licenses this file\n+# to you under the Apache License, Version 2.0 (the\n+# \"License\"); you may not use this file except in compliance\n+# with the License.  You may obtain a copy of the License at\n+#\n+#   http://www.apache.org/licenses/LICENSE-2.0\n+#\n+# Unless required by applicable law or agreed to in writing,\n+# software distributed under the License is distributed on an\n+# \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+# KIND, either express or implied.  See the License for the\n+# specific language governing permissions and limitations\n+# under the License.\n+\n+\"\"\"\n+Add required fields to enable UI integrations for the Deadline Alerts feature.\n+\n+This migration creates the deadline_alert table to store DeadlineAlert definitions\n+and migrates existing Deadline Alert data from the serialized_dag JSON structure\n+into the new normalized table structure.\n+\n+Revision ID: 55297ae24532\n+Revises: 665854ef0536\n+Create Date: 2025-10-17 16:04:55.016272\n+\"\"\"\n+\n+from __future__ import annotations\n+\n+import json\n+import zlib\n+from collections import defaultdict\n+from typing import TYPE_CHECKING\n+\n+import sqlalchemy as sa\n+import uuid6\n+from alembic import context, op\n+from sqlalchemy_utils import UUIDType\n+\n+from airflow._shared.timezones import timezone\n+from airflow.configuration import conf\n+from airflow.serialization.enums import Encoding\n+from airflow.utils.sqlalchemy import UtcDateTime\n+\n+if TYPE_CHECKING:\n+    from typing import Any\n+\n+    from sqlalchemy.engine import Connection\n+\n+    ErrorDict = dict[str, list[str]]\n+\n+revision = \"55297ae24532\"\n+down_revision = \"665854ef0536\"\n+branch_labels = None\n+depends_on = None\n+airflow_version = \"3.2.0\"\n+\n+\n+CALLBACK_KEY = \"callback_def\"\n+DAG_KEY = \"dag\"\n+DEADLINE_KEY = \"deadline\"\n+INTERVAL_KEY = \"interval\"\n+REFERENCE_KEY = \"reference\"\n+DEADLINE_ALERT_REQUIRED_FIELDS = {REFERENCE_KEY, CALLBACK_KEY, INTERVAL_KEY}\n+DEFAULT_BATCH_SIZE = 1000\n+ENCODING_TYPE = \"deadline_alert\"\n+\n+\n+def upgrade() -> None:\n+    \"\"\"Make changes to enable adding DeadlineAlerts to the UI.\"\"\"\n+    # TODO: We may finally have come up with a better naming convention. For ease of migration,\n+    #   we are going to keep deadline_alert here to match the model's name, but in the near future\n+    #   when this migration work is done we should deprecate the name DeadlineAlert (and all related\n+    #   classes, tables, etc) and replace it with DeadlineDefinition. Then we will have the\n+    #   user-provided DeadlineDefinition, and the actual instance of a Definition is (still) the Deadline.\n+    #   This feels more intuitive than DeadlineAlert defining the Deadline.\n+\n+    op.create_table(\n+        \"deadline_alert\",\n+        sa.Column(\"id\", UUIDType(binary=False), default=uuid6.uuid7),\n+        sa.Column(\"created_at\", UtcDateTime, nullable=False),\n+        sa.Column(\"serialized_dag_id\", UUIDType(binary=False), nullable=False),\n+        sa.Column(\"name\", sa.String(250), nullable=True),\n+        sa.Column(\"description\", sa.Text(), nullable=True),\n+        sa.Column(\"reference\", sa.JSON(), nullable=False),\n+        sa.Column(\"interval\", sa.Float(), nullable=False),\n+        sa.Column(\"callback_def\", sa.JSON(), nullable=False),\n+        sa.PrimaryKeyConstraint(\"id\", name=op.f(\"deadline_alert_pkey\")),\n+    )\n+\n+    conn = op.get_bind()\n+    dialect_name = conn.dialect.name\n+\n+    if dialect_name == \"sqlite\":\n+        conn.execute(sa.text(\"PRAGMA foreign_keys=OFF\"))\n+\n+    with op.batch_alter_table(\"deadline\", schema=None) as batch_op:\n+        batch_op.add_column(sa.Column(\"deadline_alert_id\", UUIDType(binary=False), nullable=True))\n+        batch_op.add_column(sa.Column(\"created_at\", UtcDateTime, nullable=True))\n+        batch_op.add_column(sa.Column(\"last_updated_at\", UtcDateTime, nullable=True))\n+        batch_op.create_foreign_key(\n+            batch_op.f(\"deadline_deadline_alert_id_fkey\"),\n+            \"deadline_alert\",\n+            [\"deadline_alert_id\"],\n+            [\"id\"],\n+            ondelete=\"SET NULL\",\n+        )\n+\n+    # For migration/backcompat purposes if no timestamp is there from the migration, use now()\n+    # then lock the columns down so all new entries require the timestamps to be provided.\n+    now = timezone.utcnow()\n+    conn.execute(\n+        sa.text(\"\"\"\n+            UPDATE deadline\n+            SET created_at = :now, last_updated_at = :now\n+            WHERE created_at IS NULL OR last_updated_at IS NULL\n+        \"\"\"),\n+        {\"now\": now},\n+    )\n+\n+    with op.batch_alter_table(\"deadline\", schema=None) as batch_op:\n+        batch_op.alter_column(\"created_at\", existing_type=UtcDateTime, nullable=False)\n+        batch_op.alter_column(\"last_updated_at\", existing_type=UtcDateTime, nullable=False)\n+\n+    with op.batch_alter_table(\"deadline_alert\", schema=None) as batch_op:\n+        batch_op.create_foreign_key(\n+            batch_op.f(\"deadline_alert_serialized_dag_id_fkey\"),\n+            \"serialized_dag\",\n+            [\"serialized_dag_id\"],\n+            [\"id\"],\n+            ondelete=\"CASCADE\",\n+        )\n+\n+    if dialect_name == \"sqlite\":\n+        conn.execute(sa.text(\"PRAGMA foreign_keys=ON\"))\n+\n+    migrate_existing_deadline_alert_data_from_serialized_dag()\n+\n+\n+def downgrade() -> None:\n+    \"\"\"Remove changes that were added to enable adding DeadlineAlerts to the UI.\"\"\"\n+    migrate_deadline_alert_data_back_to_serialized_dag()\n+\n+    conn = op.get_bind()\n+    dialect_name = conn.dialect.name\n+\n+    if dialect_name == \"sqlite\":\n+        conn.execute(sa.text(\"PRAGMA foreign_keys=OFF\"))\n+\n+    with op.batch_alter_table(\"deadline\", schema=None) as batch_op:\n+        batch_op.drop_constraint(batch_op.f(\"deadline_deadline_alert_id_fkey\"), type_=\"foreignkey\")\n+        batch_op.drop_column(\"deadline_alert_id\")\n+        batch_op.drop_column(\"last_updated_at\")\n+        batch_op.drop_column(\"created_at\")\n+\n+    with op.batch_alter_table(\"deadline_alert\", schema=None) as batch_op:\n+        batch_op.drop_constraint(batch_op.f(\"deadline_alert_serialized_dag_id_fkey\"), type_=\"foreignkey\")\n+\n+    if dialect_name == \"sqlite\":\n+        conn.execute(sa.text(\"PRAGMA foreign_keys=ON\"))\n+\n+    op.drop_table(\"deadline_alert\")\n+\n+\n+def get_dag_data(data: dict[str, Any] | str | None, data_compressed: bytes | None) -> dict[str, Any]:\n+    \"\"\"\n+    Extract and decompress DAG data regardless of storage format.\n+\n+    Returns the parsed JSON data, handling both compressed and uncompressed formats.\n+\n+    :param data: The uncompressed DAG data as dict or JSON string.\n+    :param data_compressed: The compressed DAG data as bytes.\n+    \"\"\"\n+    if data_compressed:\n+        decompressed = zlib.decompress(data_compressed)\n+        return json.loads(decompressed)\n+    return data if isinstance(data, dict) else json.loads(data)\n+\n+\n+def update_dag_deadline_field(\n+    conn: Connection,\n+    serialized_dag_id: str,\n+    deadline_data: list[str] | list[dict[str, Any]],\n+    dialect: str,\n+) -> None:\n+    \"\"\"\n+    Update the deadline field in serialized_dag using the appropriate format.\n+\n+    Checks the existing row to determine whether to use compressed or uncompressed format,\n+    and uses dialect-specific JSON operations when available.\n+\n+    :param conn: SQLAlchemy database connection.\n+    :param serialized_dag_id: The serialized_dag.id identifier.\n+    :param deadline_data: List of deadline alert UUIDs (upgrade) or deadline objects (downgrade).\n+    :param dialect: Database dialect name (e.g., 'postgresql', 'mysql', 'sqlite').\n+    \"\"\"\n+    check_compressed = conn.execute(\n+        sa.text(\"SELECT data_compressed FROM serialized_dag WHERE id = :serialized_dag_id\"),\n+        {\"serialized_dag_id\": serialized_dag_id},\n+    ).fetchone()\n+\n+    if check_compressed and check_compressed.data_compressed:\n+        decompressed = zlib.decompress(check_compressed.data_compressed)\n+        dag_data = json.loads(decompressed)\n+        dag_data[DAG_KEY][DEADLINE_KEY] = deadline_data\n+        new_compressed = zlib.compress(json.dumps(dag_data).encode(\"utf-8\"))\n+        conn.execute(\n+            sa.text(\"UPDATE serialized_dag SET data_compressed = :data WHERE id = :serialized_dag_id\"),\n+            {\"data\": new_compressed, \"serialized_dag_id\": serialized_dag_id},\n+        )\n+    elif dialect == \"postgresql\":\n+        conn.execute(\n+            sa.text(\"\"\"\n+                    UPDATE serialized_dag\n+                    SET data = jsonb_set(\n+                        data::jsonb,\n+                        '{dag,deadline}',\n+                        CAST(:deadline_data AS jsonb)\n+                    )::json\n+                    WHERE id = :serialized_dag_id\n+                    \"\"\"),\n+            {\"serialized_dag_id\": serialized_dag_id, \"deadline_data\": json.dumps(deadline_data)},\n+        )\n+    elif dialect == \"mysql\":\n+        conn.execute(\n+            sa.text(\"\"\"\n+                    UPDATE serialized_dag\n+                    SET data = JSON_SET(\n+                        data,\n+                        '$.dag.deadline',\n+                        CAST(:deadline_data AS JSON)\n+                    )\n+                    WHERE id = :serialized_dag_id\n+                    \"\"\"),\n+            {\"serialized_dag_id\": serialized_dag_id, \"deadline_data\": json.dumps(deadline_data)},\n+        )\n+    else:\n+        result = conn.execute(\n+            sa.text(\"SELECT data FROM serialized_dag WHERE id = :serialized_dag_id\"),\n+            {\"serialized_dag_id\": serialized_dag_id},\n+        ).fetchone()\n+\n+        if result and result.data:\n+            dag_data = json.loads(result.data) if isinstance(result.data, str) else result.data\n+            dag_data[DAG_KEY][DEADLINE_KEY] = deadline_data\n+\n+            conn.execute(\n+                sa.text(\"UPDATE serialized_dag SET data = :data WHERE id = :serialized_dag_id\"),\n+                {\"data\": json.dumps(dag_data), \"serialized_dag_id\": serialized_dag_id},\n+            )\n+\n+\n+def validate_written_data(\n+    conn: Connection,\n+    deadline_alert_id: str,\n+    expected_reference: str,\n+    expected_interval: float,\n+    expected_callback: str,\n+) -> bool:\n+    \"\"\"\n+    Read back the inserted data and validate that it matches what we expect.\n+\n+    This provides an extra safety check for data integrity during migration.\n+\n+    :param conn: SQLAlchemy database connection.\n+    :param deadline_alert_id: The UUID of the deadline alert to validate.\n+    :param expected_reference: Expected JSON string of the reference field.\n+    :param expected_interval: Expected interval value as float.\n+    :param expected_callback: Expected JSON string of the callback field.\n+    \"\"\"\n+    # TODO: Is this overkill?  Maybe... Consider adding a config option to\n+    #   disable validation for large deployments where performance is critical??\n+\n+    validation_result = conn.execute(\n+        sa.text(\"\"\"\n+                SELECT reference, interval, callback_def\n+                FROM deadline_alert\n+                WHERE id = :alert_id\n+                \"\"\"),\n+        {\"alert_id\": deadline_alert_id},\n+    ).fetchone()\n+\n+    if not validation_result:\n+        print(f\"ERROR: Failed to read back deadline_alert for DeadlineAlert {deadline_alert_id}\")\n+        return False\n+\n+    checks = [\n+        (REFERENCE_KEY, json.dumps(validation_result.reference, sort_keys=True), expected_reference),\n+        (INTERVAL_KEY, validation_result.interval, expected_interval),\n+        (CALLBACK_KEY, json.dumps(validation_result.callback_def, sort_keys=True), expected_callback),\n+    ]\n+\n+    for name, actual, expected in checks:\n+        if actual != expected:\n+            print(f\"ERROR: Written {name} does not match expected! Written: {actual}, Expected: {expected}\")\n+            return False\n+\n+    return True\n+\n+\n+def report_errors(errors: ErrorDict, operation: str = \"migration\") -> None:\n+    if errors:\n+        print(f\"{len(errors)} Dags encountered errors: \")\n+        for dag_id, error in errors.items():\n+            print(f\"  {dag_id}: {'; '.join(error)}\")\n+    else:\n+        print(f\"No Dags encountered errors during {operation}.\")\n+\n+\n+def migrate_existing_deadline_alert_data_from_serialized_dag() -> None:\n+    \"\"\"Extract DeadlineAlert data from serialized Dag data and populate deadline_alert table.\"\"\"\n+    if context.is_offline_mode():\n+        print(\n+            \"\"\"\n+            ------------\n+            --  WARNING: Unable to migrate DeadlineAlert data while in offline mode!\n+            --  The deadline_alert table will remain empty in offline mode.\n+            --  Run the migration in online mode to populate the deadline_alert table.\n+            ------------\n+            \"\"\"\n+        )\n+        return\n+\n+    BATCH_SIZE = conf.getint(\"database\", \"migration_batch_size\", fallback=DEFAULT_BATCH_SIZE)\n+\n+    processed_dags: list[str] = []\n+    dags_with_deadlines: set[str] = set()\n+    migrated_alerts_count: int = 0\n+    dags_with_errors: ErrorDict = defaultdict(list)\n+    batch_num = 0\n+    last_dag_id = \"\"\n+\n+    conn = op.get_bind()\n+    dialect = conn.dialect.name\n+\n+    total_dags = conn.execute(\n+        sa.text(\"SELECT COUNT(*) FROM serialized_dag WHERE data IS NOT NULL OR data_compressed IS NOT NULL\")\n+    ).scalar()\n+    total_batches = (total_dags + BATCH_SIZE - 1) // BATCH_SIZE\n+\n+    print(f\"Using migration_batch_size of {BATCH_SIZE} as set in Airflow configuration.\")\n+    print(f\"Starting migration of {total_dags} Dags in {total_batches} batches.\\n\")\n+\n+    while True:\n+        batch_num += 1\n+\n+        result = conn.execute(\n+            sa.text(\"\"\"\n+                SELECT id, dag_id, data, data_compressed, created_at\n+                FROM serialized_dag\n+                WHERE (data IS NOT NULL OR data_compressed IS NOT NULL)\n+                  AND dag_id > :last_dag_id\n+                ORDER BY dag_id\n+                LIMIT :batch_size\n+            \"\"\"),\n+            {\"last_dag_id\": last_dag_id, \"batch_size\": BATCH_SIZE},\n+        )\n+\n+        batch_results = list(result)\n+        if not batch_results:\n+            break\n+\n+        print(f\"Processing batch {batch_num}...\")\n+\n+        for serialized_dag_id, dag_id, data, data_compressed, created_at in batch_results:\n+            processed_dags.append(dag_id)\n+            last_dag_id = dag_id\n+\n+            # Create a savepoint for this Dag to allow rollback on error.\n+            savepoint = conn.begin_nested()\n+\n+            try:\n+                dag_data = get_dag_data(data, data_compressed)\n+\n+                if dag_deadline := dag_data[DAG_KEY][DEADLINE_KEY]:\n+                    dags_with_deadlines.add(dag_id)\n+                    deadline_alerts = dag_deadline if isinstance(dag_deadline, list) else [dag_deadline]\n+\n+                    migrated_alert_ids = []\n+\n+                    for serialized_alert in deadline_alerts:\n+                        if isinstance(serialized_alert, dict):\n+                            try:\n+                                alert_data = serialized_alert.get(Encoding.VAR, serialized_alert)\n+\n+                                if not DEADLINE_ALERT_REQUIRED_FIELDS.issubset(alert_data):\n+                                    dags_with_errors[dag_id].append(\n+                                        f\"Invalid DeadlineAlert structure: {serialized_alert}\"\n+                                    )\n+                                    continue\n+\n+                                reference_data = json.dumps(alert_data[REFERENCE_KEY], sort_keys=True)\n+                                interval_data = float(alert_data.get(INTERVAL_KEY))\n+                                callback_data = json.dumps(alert_data[CALLBACK_KEY], sort_keys=True)\n+                                deadline_alert_id = str(uuid6.uuid7())\n+\n+                                conn.execute(\n+                                    sa.text(\"\"\"\n+                                            INSERT INTO deadline_alert (\n+                                                id,\n+                                                created_at,\n+                                                serialized_dag_id,\n+                                                reference,\n+                                                interval,\n+                                                callback_def,\n+                                                name,\n+                                                description)\n+                                            VALUES (\n+                                                :id,\n+                                                :created_at,\n+                                                :serialized_dag_id,\n+                                                :reference,\n+                                                :interval,\n+                                                :callback_def,\n+                                                NULL,\n+                                                NULL)\n+                                            \"\"\"),\n+                                    {\n+                                        \"id\": deadline_alert_id,\n+                                        \"created_at\": created_at or timezone.utcnow(),\n+                                        \"serialized_dag_id\": serialized_dag_id,\n+                                        \"reference\": reference_data,\n+                                        \"interval\": interval_data,\n+                                        \"callback_def\": callback_data,\n+                                    },\n+                                )\n+\n+                                if not validate_written_data(\n+                                    conn, deadline_alert_id, reference_data, interval_data, callback_data\n+                                ):\n+                                    dags_with_errors[dag_id].append(\n+                                        f\"Invalid DeadlineAlert data: {serialized_alert}\"\n+                                    )\n+                                    continue\n+\n+                                migrated_alert_ids.append(deadline_alert_id)\n+                                migrated_alerts_count += 1\n+\n+                                conn.execute(\n+                                    sa.text(\"\"\"\n+                                        UPDATE deadline\n+                                        SET deadline_alert_id = :alert_id\n+                                        WHERE dagrun_id IN (\n+                                            SELECT dr.id\n+                                            FROM dag_run dr\n+                                                 JOIN serialized_dag sd ON dr.dag_id = sd.dag_id\n+                                            WHERE sd.id = :serialized_dag_id)\n+                                          AND deadline_alert_id IS NULL\n+                                    \"\"\"),\n+                                    {\"alert_id\": deadline_alert_id, \"serialized_dag_id\": serialized_dag_id},\n+                                )\n+                            except Exception as e:\n+                                dags_with_errors[dag_id].append(f\"Failed to process {serialized_alert}: {e}\")\n+                                continue\n+\n+                    if migrated_alert_ids:\n+                        uuid_strings = [str(uuid_id) for uuid_id in migrated_alert_ids]\n+                        update_dag_deadline_field(conn, serialized_dag_id, uuid_strings, dialect)\n+\n+                        # Recalculate and update the dag_hash after modifying the deadline data to ensure\n+                        # it matches what write_dag() will compute later and avoid re-serialization.\n+                        updated_result = conn.execute(\n+                            sa.text(\n+                                \"SELECT data, data_compressed \"\n+                                \"FROM serialized_dag \"\n+                                \"WHERE id = :serialized_dag_id\"\n+                            ),\n+                            {\"serialized_dag_id\": serialized_dag_id},\n+                        ).fetchone()\n+\n+                        if updated_result:\n+                            updated_dag_data = get_dag_data(\n+                                updated_result.data, updated_result.data_compressed\n+                            )\n+                            # Import here to avoid a circular dependency issue\n+                            from airflow.models.serialized_dag import SerializedDagModel\n+\n+                            new_hash = SerializedDagModel.hash(updated_dag_data)\n+\n+                            conn.execute(\n+                                sa.text(\n+                                    \"UPDATE serialized_dag \"\n+                                    \"SET dag_hash = :new_hash \"\n+                                    \"WHERE id = :serialized_dag_id\"\n+                                ),\n+                                {\"new_hash\": new_hash, \"serialized_dag_id\": serialized_dag_id},\n+                            )",
      "comment": "I was running into an issue where the serialized_dag's hash was recalculating and adding a new row tot eh serialized_dag table because the created_at and updated_at are getting modified.  This was my workaround for that.  I'm not honestly sure if it's the right answer, but it DOES prevent the reserialization.  Suggestions for better approaches are very welcome.",
      "comment_id": 2582437743,
      "user": "ferruzzi",
      "created_at": "2025-12-02T18:49:40Z",
      "url": "https://github.com/apache/airflow/pull/58248#discussion_r2582437743"
    },
    {
      "repo": "apache/airflow",
      "pr_number": 58248,
      "file_path": "airflow-core/src/airflow/models/serialized_dag.py",
      "line": 438,
      "side": "RIGHT",
      "diff_hunk": "@@ -373,6 +383,104 @@ def _sort_serialized_dag_dict(cls, serialized_dag: Any):\n             return [cls._sort_serialized_dag_dict(i) for i in serialized_dag]\n         return serialized_dag\n \n+    @classmethod\n+    def _generate_deadline_uuids(cls, dag_data: dict[str, Any]) -> dict[str, dict]:\n+        \"\"\"\n+        Generate UUIDs for DeadlineAlerts and replace dicts with list[UUID] in dag_data.\n+\n+        This modifies dag_data in place, replacing deadline alert definitions with UUID strings.\n+        Called before SerializedDagModel creation to ensure UUIDs are included in the hash.\n+\n+        :param dag_data: The serialized DAG data dictionary\n+        :return: Mapping of UUID strings to deadline alert data dicts\n+        \"\"\"\n+        uuid_mapping: dict[str, dict] = {}\n+\n+        dag_deadline_data = dag_data.get(\"dag\", {}).get(\"deadline\")\n+        if not dag_deadline_data:\n+            return uuid_mapping\n+\n+        for deadline_alert in dag_deadline_data:\n+            deadline_data = deadline_alert.get(Encoding.VAR, deadline_alert)\n+\n+            deadline_uuid = str(uuid6.uuid7())\n+            uuid_mapping[deadline_uuid] = deadline_data\n+\n+        dag_data[\"dag\"][\"deadline\"] = list(uuid_mapping.keys())\n+\n+        return uuid_mapping\n+\n+    @classmethod\n+    def _create_deadline_alert_records(\n+        cls,\n+        serialized_dag: SerializedDagModel,\n+        uuid_mapping: dict[str, dict],\n+    ) -> None:\n+        \"\"\"\n+        Create DeadlineAlert records in the database and appends them to serialized_dag.\n+\n+        :param serialized_dag: The SerializedDagModel instance (not yet flushed)\n+        :param uuid_mapping: Mapping of UUID strings to deadline alert data dicts\n+        \"\"\"\n+        if not uuid_mapping:\n+            return\n+\n+        for uuid_str, deadline_data in uuid_mapping.items():\n+            alert = DeadlineAlertModel(\n+                id=uuid_str,\n+                reference=deadline_data[DeadlineAlertFields.REFERENCE],\n+                interval=deadline_data[DeadlineAlertFields.INTERVAL],\n+                callback_def=deadline_data[DeadlineAlertFields.CALLBACK],\n+            )\n+            serialized_dag.deadline_alerts.append(alert)\n+\n+    @classmethod\n+    def _get_existing_deadline_uuids(",
      "comment": "I don't see this being called anywhere here. Am I missing something?",
      "comment_id": 2608609874,
      "user": "o-nikolas",
      "created_at": "2025-12-10T23:52:06Z",
      "url": "https://github.com/apache/airflow/pull/58248#discussion_r2608609874"
    },
    {
      "repo": "apache/airflow",
      "pr_number": 58248,
      "file_path": "airflow-core/src/airflow/models/serialized_dag.py",
      "line": 438,
      "side": "RIGHT",
      "diff_hunk": "@@ -373,6 +383,104 @@ def _sort_serialized_dag_dict(cls, serialized_dag: Any):\n             return [cls._sort_serialized_dag_dict(i) for i in serialized_dag]\n         return serialized_dag\n \n+    @classmethod\n+    def _generate_deadline_uuids(cls, dag_data: dict[str, Any]) -> dict[str, dict]:\n+        \"\"\"\n+        Generate UUIDs for DeadlineAlerts and replace dicts with list[UUID] in dag_data.\n+\n+        This modifies dag_data in place, replacing deadline alert definitions with UUID strings.\n+        Called before SerializedDagModel creation to ensure UUIDs are included in the hash.\n+\n+        :param dag_data: The serialized DAG data dictionary\n+        :return: Mapping of UUID strings to deadline alert data dicts\n+        \"\"\"\n+        uuid_mapping: dict[str, dict] = {}\n+\n+        dag_deadline_data = dag_data.get(\"dag\", {}).get(\"deadline\")\n+        if not dag_deadline_data:\n+            return uuid_mapping\n+\n+        for deadline_alert in dag_deadline_data:\n+            deadline_data = deadline_alert.get(Encoding.VAR, deadline_alert)\n+\n+            deadline_uuid = str(uuid6.uuid7())\n+            uuid_mapping[deadline_uuid] = deadline_data\n+\n+        dag_data[\"dag\"][\"deadline\"] = list(uuid_mapping.keys())\n+\n+        return uuid_mapping\n+\n+    @classmethod\n+    def _create_deadline_alert_records(\n+        cls,\n+        serialized_dag: SerializedDagModel,\n+        uuid_mapping: dict[str, dict],\n+    ) -> None:\n+        \"\"\"\n+        Create DeadlineAlert records in the database and appends them to serialized_dag.\n+\n+        :param serialized_dag: The SerializedDagModel instance (not yet flushed)\n+        :param uuid_mapping: Mapping of UUID strings to deadline alert data dicts\n+        \"\"\"\n+        if not uuid_mapping:\n+            return\n+\n+        for uuid_str, deadline_data in uuid_mapping.items():\n+            alert = DeadlineAlertModel(\n+                id=uuid_str,\n+                reference=deadline_data[DeadlineAlertFields.REFERENCE],\n+                interval=deadline_data[DeadlineAlertFields.INTERVAL],\n+                callback_def=deadline_data[DeadlineAlertFields.CALLBACK],\n+            )\n+            serialized_dag.deadline_alerts.append(alert)\n+\n+    @classmethod\n+    def _get_existing_deadline_uuids(",
      "comment": "You are missing the fact that I ended up not needing it.  :P \r\n\r\nGood catch, should be safe to remove, I'll double check and either remove it or let you know why it's there.   Sorry about that.",
      "comment_id": 2608664477,
      "user": "ferruzzi",
      "created_at": "2025-12-11T00:20:54Z",
      "url": "https://github.com/apache/airflow/pull/58248#discussion_r2608664477"
    },
    {
      "repo": "apache/airflow",
      "pr_number": 60789,
      "file_path": "airflow-core/src/airflow/dag_processing/manager.py",
      "line": 328,
      "side": "RIGHT",
      "diff_hunk": "@@ -324,7 +324,12 @@ def deactivate_stale_dags(\n             file_info = DagFileInfo(rel_path=Path(dag.relative_fileloc), bundle_name=dag.bundle_name)\n             if last_finish_time := last_parsed.get(file_info, None):\n                 if dag.last_parsed_time + timedelta(seconds=self.stale_dag_threshold) < last_finish_time:\n-                    self.log.info(\"DAG %s is missing and will be deactivated.\", dag.dag_id)\n+                    self.log.info(\n+                        \"DAG %s is marked as stale, due to not being parsed for %s seconds and will be deactivated, dag was last parsed at %s.\",",
      "comment": "`timedelta.total_seconds()` returns a float with high precision (e.g., 305.123951). Logging this directly creates noisy logs. It is usually better to round this to 2 decimal places or cast it to an integer\n```suggestion\n                        \"Deactivating stale DAG %s. Not parsed for %s seconds (last parsed: %s).\"\",\n```",
      "comment_id": 2705767348,
      "user": "dheerajturaga",
      "created_at": "2026-01-19T18:31:32Z",
      "url": "https://github.com/apache/airflow/pull/60789#discussion_r2705767348"
    },
    {
      "repo": "apache/airflow",
      "pr_number": 60789,
      "file_path": "airflow-core/src/airflow/dag_processing/manager.py",
      "line": 330,
      "side": "RIGHT",
      "diff_hunk": "@@ -324,7 +324,12 @@ def deactivate_stale_dags(\n             file_info = DagFileInfo(rel_path=Path(dag.relative_fileloc), bundle_name=dag.bundle_name)\n             if last_finish_time := last_parsed.get(file_info, None):\n                 if dag.last_parsed_time + timedelta(seconds=self.stale_dag_threshold) < last_finish_time:\n-                    self.log.info(\"DAG %s is missing and will be deactivated.\", dag.dag_id)\n+                    self.log.info(\n+                        \"DAG %s is marked as stale, due to not being parsed for %s seconds and will be deactivated, dag was last parsed at %s.\",\n+                        dag.dag_id,\n+                        (last_finish_time - dag.last_parsed_time).total_seconds(),",
      "comment": "```suggestion\n                        int((last_finish_time - dag.last_parsed_time).total_seconds()),\n```",
      "comment_id": 2705768508,
      "user": "dheerajturaga",
      "created_at": "2026-01-19T18:32:03Z",
      "url": "https://github.com/apache/airflow/pull/60789#discussion_r2705768508"
    },
    {
      "repo": "apache/airflow",
      "pr_number": 60218,
      "file_path": "airflow-core/src/airflow/providers_manager.py",
      "line": 434,
      "side": "RIGHT",
      "diff_hunk": "@@ -429,6 +429,33 @@ def __init__(self):\n         self._plugins_set: set[PluginInfo] = set()\n         self._init_airflow_core_hooks()\n \n+        self._runtime_manager = None\n+\n+    def __getattribute__(self, name: str):",
      "comment": "Don't love this, maybe change it to each method I guess",
      "comment_id": 2675305616,
      "user": "amoghrajesh",
      "created_at": "2026-01-09T08:33:28Z",
      "url": "https://github.com/apache/airflow/pull/60218#discussion_r2675305616"
    },
    {
      "repo": "apache/airflow",
      "pr_number": 60218,
      "file_path": "shared/providers_discovery/src/airflow_shared/providers_discovery/__init__.py",
      "line": 36,
      "side": "RIGHT",
      "diff_hunk": "@@ -0,0 +1,395 @@\n+#\n+# Licensed to the Apache Software Foundation (ASF) under one\n+# or more contributor license agreements.  See the NOTICE file\n+# distributed with this work for additional information\n+# regarding copyright ownership.  The ASF licenses this file\n+# to you under the Apache License, Version 2.0 (the\n+# \"License\"); you may not use this file except in compliance\n+# with the License.  You may obtain a copy of the License at\n+#\n+#   http://www.apache.org/licenses/LICENSE-2.0\n+#\n+# Unless required by applicable law or agreed to in writing,\n+# software distributed under the License is distributed on an\n+# \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+# KIND, either express or implied.  See the License for the\n+# specific language governing permissions and limitations\n+# under the License.\n+\"\"\"Shared provider discovery utilities and data structures.\"\"\"\n+\n+from __future__ import annotations\n+\n+import contextlib\n+import json\n+import logging\n+import pathlib\n+from collections.abc import Callable, MutableMapping\n+from dataclasses import dataclass\n+from functools import wraps\n+from importlib.resources import files as resource_files\n+from time import perf_counter\n+from typing import Any, NamedTuple, ParamSpec\n+\n+from packaging.utils import canonicalize_name\n+\n+from airflow._shared.module_loading import entry_points_with_dist, import_string\n+from airflow.exceptions import AirflowOptionalProviderFeatureException",
      "comment": "Moving it to task sdk: https://github.com/apache/airflow/pull/60323",
      "comment_id": 2676118842,
      "user": "amoghrajesh",
      "created_at": "2026-01-09T13:01:02Z",
      "url": "https://github.com/apache/airflow/pull/60218#discussion_r2676118842"
    },
    {
      "repo": "apache/airflow",
      "pr_number": 60218,
      "file_path": "task-sdk/src/airflow/sdk/providers_manager_runtime.py",
      "line": 42,
      "side": "RIGHT",
      "diff_hunk": "@@ -0,0 +1,441 @@\n+#\n+# Licensed to the Apache Software Foundation (ASF) under one\n+# or more contributor license agreements.  See the NOTICE file\n+# distributed with this work for additional information\n+# regarding copyright ownership.  The ASF licenses this file\n+# to you under the Apache License, Version 2.0 (the\n+# \"License\"); you may not use this file except in compliance\n+# with the License.  You may obtain a copy of the License at\n+#\n+#   http://www.apache.org/licenses/LICENSE-2.0\n+#\n+# Unless required by applicable law or agreed to in writing,\n+# software distributed under the License is distributed on an\n+# \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+# KIND, either express or implied.  See the License for the\n+# specific language governing permissions and limitations\n+# under the License.\n+\"\"\"Manages runtime provider resources for task execution.\"\"\"\n+\n+from __future__ import annotations\n+\n+import functools\n+import inspect\n+import logging\n+import traceback\n+from collections.abc import Callable, MutableMapping\n+from typing import TYPE_CHECKING, Any\n+from urllib.parse import SplitResult\n+\n+from airflow._shared.module_loading import import_string\n+from airflow._shared.providers_discovery import (\n+    HookClassProvider,\n+    HookInfo,\n+    LazyDictWithCache,\n+    ProviderInfo,\n+    _correctness_check,\n+    _create_provider_info_schema_validator,\n+    discover_all_providers_from_packages,\n+    provider_info_cache,\n+)\n+from airflow.utils.log.logging_mixin import LoggingMixin\n+from airflow.utils.singleton import Singleton",
      "comment": "https://github.com/apache/airflow/pull/60324 and https://github.com/apache/airflow/pull/60327 will do it for singleton, `LoggingMixin` is already in sdk, will update this to consume that",
      "comment_id": 2676249499,
      "user": "amoghrajesh",
      "created_at": "2026-01-09T13:44:54Z",
      "url": "https://github.com/apache/airflow/pull/60218#discussion_r2676249499"
    },
    {
      "repo": "apache/airflow",
      "pr_number": 60218,
      "file_path": "airflow-core/src/airflow/providers_manager.py",
      "line": 434,
      "side": "RIGHT",
      "diff_hunk": "@@ -429,6 +429,33 @@ def __init__(self):\n         self._plugins_set: set[PluginInfo] = set()\n         self._init_airflow_core_hooks()\n \n+        self._runtime_manager = None\n+\n+    def __getattribute__(self, name: str):",
      "comment": "How would it look in regards of this surgery if you remove this compatibility shim? Is this called by _all_ providers as well?",
      "comment_id": 2677588852,
      "user": "jscheffl",
      "created_at": "2026-01-09T20:50:47Z",
      "url": "https://github.com/apache/airflow/pull/60218#discussion_r2677588852"
    },
    {
      "repo": "apache/airflow",
      "pr_number": 60218,
      "file_path": "airflow-core/src/airflow/providers_manager.py",
      "line": 434,
      "side": "RIGHT",
      "diff_hunk": "@@ -429,6 +429,33 @@ def __init__(self):\n         self._plugins_set: set[PluginInfo] = set()\n         self._init_airflow_core_hooks()\n \n+        self._runtime_manager = None\n+\n+    def __getattribute__(self, name: str):",
      "comment": "Pretty much yes. I will have follow ups to start making providers use providersmanager and providersmanagerruntime where applicable ",
      "comment_id": 2678323202,
      "user": "amoghrajesh",
      "created_at": "2026-01-10T04:54:32Z",
      "url": "https://github.com/apache/airflow/pull/60218#discussion_r2678323202"
    },
    {
      "repo": "apache/airflow",
      "pr_number": 60218,
      "file_path": "airflow-core/tests/unit/always/test_providers_manager.py",
      "line": 198,
      "side": "LEFT",
      "diff_hunk": "@@ -83,104 +81,6 @@ def test_providers_are_loaded(self):\n             assert len(provider_list) > 65\n             assert self._caplog.records == []\n \n-    def test_hooks_deprecation_warnings_generated(self):\n-        providers_manager = ProvidersManager()\n-        providers_manager._provider_dict[\"test-package\"] = ProviderInfo(\n-            version=\"0.0.1\",\n-            data={\"hook-class-names\": [\"airflow.providers.sftp.hooks.sftp.SFTPHook\"]},\n-        )\n-        with pytest.warns(expected_warning=DeprecationWarning, match=\"hook-class-names\") as warning_records:\n-            providers_manager._discover_hooks()\n-        assert warning_records\n-\n-    def test_hooks_deprecation_warnings_not_generated(self):\n-        with warnings.catch_warnings(record=True) as warning_records:\n-            providers_manager = ProvidersManager()\n-            providers_manager._provider_dict[\"apache-airflow-providers-sftp\"] = ProviderInfo(\n-                version=\"0.0.1\",\n-                data={\n-                    \"hook-class-names\": [\"airflow.providers.sftp.hooks.sftp.SFTPHook\"],\n-                    \"connection-types\": [\n-                        {\n-                            \"hook-class-name\": \"airflow.providers.sftp.hooks.sftp.SFTPHook\",\n-                            \"connection-type\": \"sftp\",\n-                        }\n-                    ],\n-                },\n-            )\n-            providers_manager._discover_hooks()\n-        assert [w.message for w in warning_records if \"hook-class-names\" in str(w.message)] == []\n-\n-    def test_warning_logs_generated(self):\n-        providers_manager = ProvidersManager()\n-        providers_manager._hooks_lazy_dict = LazyDictWithCache()\n-        with self._caplog.at_level(logging.WARNING):\n-            providers_manager._provider_dict[\"apache-airflow-providers-sftp\"] = ProviderInfo(\n-                version=\"0.0.1\",\n-                data={\n-                    \"hook-class-names\": [\"airflow.providers.sftp.hooks.sftp.SFTPHook\"],\n-                    \"connection-types\": [\n-                        {\n-                            \"hook-class-name\": \"airflow.providers.sftp.hooks.sftp.SFTPHook\",\n-                            \"connection-type\": \"wrong-connection-type\",\n-                        }\n-                    ],\n-                },\n-            )\n-            providers_manager._discover_hooks()\n-            _ = providers_manager._hooks_lazy_dict[\"wrong-connection-type\"]\n-        assert len(self._caplog.entries) == 1\n-        assert \"Inconsistency!\" in self._caplog[0][\"event\"]\n-        assert \"sftp\" not in providers_manager.hooks\n-\n-    def test_warning_logs_not_generated(self):\n-        with self._caplog.at_level(logging.WARNING):\n-            providers_manager = ProvidersManager()\n-            providers_manager._provider_dict[\"apache-airflow-providers-sftp\"] = ProviderInfo(\n-                version=\"0.0.1\",\n-                data={\n-                    \"hook-class-names\": [\"airflow.providers.sftp.hooks.sftp.SFTPHook\"],\n-                    \"connection-types\": [\n-                        {\n-                            \"hook-class-name\": \"airflow.providers.sftp.hooks.sftp.SFTPHook\",\n-                            \"connection-type\": \"sftp\",\n-                        }\n-                    ],\n-                },\n-            )\n-            providers_manager._discover_hooks()\n-            _ = providers_manager._hooks_lazy_dict[\"sftp\"]\n-        assert not self._caplog.records\n-        assert \"sftp\" in providers_manager.hooks\n-\n-    def test_already_registered_conn_type_in_provide(self):\n-        with self._caplog.at_level(logging.WARNING):\n-            providers_manager = ProvidersManager()\n-            providers_manager._provider_dict[\"apache-airflow-providers-dummy\"] = ProviderInfo(\n-                version=\"0.0.1\",\n-                data={\n-                    \"connection-types\": [\n-                        {\n-                            \"hook-class-name\": \"airflow.providers.dummy.hooks.dummy.DummyHook\",\n-                            \"connection-type\": \"dummy\",\n-                        },\n-                        {\n-                            \"hook-class-name\": \"airflow.providers.dummy.hooks.dummy.DummyHook2\",\n-                            \"connection-type\": \"dummy\",\n-                        },\n-                    ],\n-                },\n-            )\n-            providers_manager._discover_hooks()\n-            _ = providers_manager._hooks_lazy_dict[\"dummy\"]\n-        assert len(self._caplog.records) == 1\n-        msg = self._caplog.messages[0]\n-        assert msg.startswith(\"The connection type 'dummy' is already registered\")\n-        assert (\n-            \"different class names: 'airflow.providers.dummy.hooks.dummy.DummyHook'\"\n-            \" and 'airflow.providers.dummy.hooks.dummy.DummyHook2'.\"\n-        ) in msg\n-",
      "comment": "These tests deal with hooks, so they have been moved into `sdk` because `ProvidersManagerRuntime` deals with hooks",
      "comment_id": 2680915651,
      "user": "amoghrajesh",
      "created_at": "2026-01-12T05:29:57Z",
      "url": "https://github.com/apache/airflow/pull/60218#discussion_r2680915651"
    },
    {
      "repo": "apache/airflow",
      "pr_number": 60218,
      "file_path": "airflow-core/tests/unit/always/test_providers_manager.py",
      "line": 548,
      "side": "LEFT",
      "diff_hunk": "@@ -441,93 +258,3 @@ def test_executors_without_check_property_should_not_called_import_string(\n         mock_correctness_check.assert_not_called()\n \n         assert providers_manager._executor_without_check_set == result\n-\n-\n-@pytest.mark.parametrize(\n-    (\"value\", \"expected_outputs\"),\n-    [\n-        (\"a\", \"a\"),\n-        (1, 1),\n-        (None, None),\n-        (lambda: 0, 0),\n-        (lambda: None, None),\n-        (lambda: \"z\", \"z\"),\n-    ],\n-)\n-def test_lazy_cache_dict_resolving(value, expected_outputs):\n-    lazy_cache_dict = LazyDictWithCache()\n-    lazy_cache_dict[\"key\"] = value\n-    assert lazy_cache_dict[\"key\"] == expected_outputs\n-    # Retrieve it again to see if it is correctly returned again\n-    assert lazy_cache_dict[\"key\"] == expected_outputs\n-\n-\n-def test_lazy_cache_dict_raises_error():\n-    def raise_method():\n-        raise RuntimeError(\"test\")\n-\n-    lazy_cache_dict = LazyDictWithCache()\n-    lazy_cache_dict[\"key\"] = raise_method\n-    with pytest.raises(RuntimeError, match=\"test\"):\n-        _ = lazy_cache_dict[\"key\"]\n-\n-\n-def test_lazy_cache_dict_del_item():\n-    lazy_cache_dict = LazyDictWithCache()\n-\n-    def answer():\n-        return 42\n-\n-    lazy_cache_dict[\"spam\"] = answer\n-    assert \"spam\" in lazy_cache_dict._raw_dict\n-    assert \"spam\" not in lazy_cache_dict._resolved  # Not resoled yet\n-    assert lazy_cache_dict[\"spam\"] == 42\n-    assert \"spam\" in lazy_cache_dict._resolved\n-    del lazy_cache_dict[\"spam\"]\n-    assert \"spam\" not in lazy_cache_dict._raw_dict\n-    assert \"spam\" not in lazy_cache_dict._resolved\n-\n-    lazy_cache_dict[\"foo\"] = answer\n-    assert lazy_cache_dict[\"foo\"] == 42\n-    assert \"foo\" in lazy_cache_dict._resolved\n-    # Emulate some mess in data, e.g. value from `_raw_dict` deleted but not from `_resolved`\n-    del lazy_cache_dict._raw_dict[\"foo\"]\n-    assert \"foo\" in lazy_cache_dict._resolved\n-    with pytest.raises(KeyError):\n-        # Error expected here, but we still expect to remove also record into `resolved`\n-        del lazy_cache_dict[\"foo\"]\n-    assert \"foo\" not in lazy_cache_dict._resolved\n-\n-    lazy_cache_dict[\"baz\"] = answer\n-    # Key in `_resolved` not created yet\n-    assert \"baz\" in lazy_cache_dict._raw_dict\n-    assert \"baz\" not in lazy_cache_dict._resolved\n-    del lazy_cache_dict._raw_dict[\"baz\"]\n-    assert \"baz\" not in lazy_cache_dict._raw_dict\n-    assert \"baz\" not in lazy_cache_dict._resolved\n-\n-\n-def test_lazy_cache_dict_clear():\n-    def answer():\n-        return 42\n-\n-    lazy_cache_dict = LazyDictWithCache()\n-    assert len(lazy_cache_dict) == 0\n-    lazy_cache_dict[\"spam\"] = answer\n-    lazy_cache_dict[\"foo\"] = answer\n-    lazy_cache_dict[\"baz\"] = answer\n-\n-    assert len(lazy_cache_dict) == 3\n-    assert len(lazy_cache_dict._raw_dict) == 3\n-    assert not lazy_cache_dict._resolved\n-    assert lazy_cache_dict[\"spam\"] == 42\n-    assert len(lazy_cache_dict._resolved) == 1\n-    # Emulate some mess in data, contain some data into the `_resolved`\n-    lazy_cache_dict._resolved.add(\"biz\")\n-    assert len(lazy_cache_dict) == 3\n-    assert len(lazy_cache_dict._resolved) == 2\n-    # And finally cleanup everything\n-    lazy_cache_dict.clear()\n-    assert len(lazy_cache_dict) == 0\n-    assert not lazy_cache_dict._raw_dict\n-    assert not lazy_cache_dict._resolved",
      "comment": "These deal with `LazyDictWithCache` which is now in shared library and due to that it these tests are in shared now",
      "comment_id": 2680917001,
      "user": "amoghrajesh",
      "created_at": "2026-01-12T05:30:57Z",
      "url": "https://github.com/apache/airflow/pull/60218#discussion_r2680917001"
    },
    {
      "repo": "apache/airflow",
      "pr_number": 60218,
      "file_path": "shared/providers_discovery/src/airflow_shared/providers_discovery/providers_discovery.py",
      "line": 293,
      "side": "RIGHT",
      "diff_hunk": "@@ -0,0 +1,348 @@\n+#\n+# Licensed to the Apache Software Foundation (ASF) under one\n+# or more contributor license agreements.  See the NOTICE file\n+# distributed with this work for additional information\n+# regarding copyright ownership.  The ASF licenses this file\n+# to you under the Apache License, Version 2.0 (the\n+# \"License\"); you may not use this file except in compliance\n+# with the License.  You may obtain a copy of the License at\n+#\n+#   http://www.apache.org/licenses/LICENSE-2.0\n+#\n+# Unless required by applicable law or agreed to in writing,\n+# software distributed under the License is distributed on an\n+# \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+# KIND, either express or implied.  See the License for the\n+# specific language governing permissions and limitations\n+# under the License.\n+\"\"\"Shared provider discovery utilities.\"\"\"\n+\n+from __future__ import annotations\n+\n+import contextlib\n+import json\n+import logging\n+import pathlib\n+from collections.abc import Callable, MutableMapping\n+from dataclasses import dataclass\n+from functools import wraps\n+from importlib.resources import files as resource_files\n+from time import perf_counter\n+from typing import Any, NamedTuple, ParamSpec\n+\n+from packaging.utils import canonicalize_name\n+\n+from ..module_loading import entry_points_with_dist\n+\n+log = logging.getLogger(__name__)\n+\n+\n+PS = ParamSpec(\"PS\")\n+\n+\n+KNOWN_UNHANDLED_OPTIONAL_FEATURE_ERRORS = [(\"apache-airflow-providers-google\", \"No module named 'paramiko'\")]\n+\n+\n+@dataclass\n+class ProviderInfo:\n+    \"\"\"\n+    Provider information.\n+\n+    :param version: version string\n+    :param data: dictionary with information about the provider\n+    \"\"\"\n+\n+    version: str\n+    data: dict\n+\n+\n+class HookClassProvider(NamedTuple):\n+    \"\"\"Hook class and Provider it comes from.\"\"\"\n+\n+    hook_class_name: str\n+    package_name: str\n+\n+\n+class HookInfo(NamedTuple):\n+    \"\"\"Hook information.\"\"\"\n+\n+    hook_class_name: str\n+    connection_id_attribute_name: str\n+    package_name: str\n+    hook_name: str\n+    connection_type: str\n+    connection_testable: bool\n+    dialects: list[str] = []\n+\n+\n+class ConnectionFormWidgetInfo(NamedTuple):\n+    \"\"\"Connection Form Widget information.\"\"\"\n+\n+    hook_class_name: str\n+    package_name: str\n+    field: Any\n+    field_name: str\n+    is_sensitive: bool\n+\n+\n+class PluginInfo(NamedTuple):\n+    \"\"\"Plugin class, name and provider it comes from.\"\"\"\n+\n+    name: str\n+    plugin_class: str\n+    provider_name: str\n+\n+\n+class NotificationInfo(NamedTuple):\n+    \"\"\"Notification class and provider it comes from.\"\"\"\n+\n+    notification_class_name: str\n+    package_name: str\n+\n+\n+class TriggerInfo(NamedTuple):\n+    \"\"\"Trigger class and provider it comes from.\"\"\"\n+\n+    trigger_class_name: str\n+    package_name: str\n+    integration_name: str\n+\n+\n+class DialectInfo(NamedTuple):\n+    \"\"\"Dialect class and Provider it comes from.\"\"\"\n+\n+    name: str\n+    dialect_class_name: str\n+    provider_name: str\n+\n+\n+class LazyDictWithCache(MutableMapping):\n+    \"\"\"\n+    Lazy-loaded cached dictionary.\n+\n+    Dictionary, which in case you set callable, executes the passed callable with `key` attribute\n+    at first use - and returns and caches the result.\n+    \"\"\"\n+\n+    __slots__ = [\"_resolved\", \"_raw_dict\"]\n+\n+    def __init__(self, *args, **kw):\n+        self._resolved = set()\n+        self._raw_dict = dict(*args, **kw)\n+\n+    def __setitem__(self, key, value):\n+        self._raw_dict.__setitem__(key, value)\n+\n+    def __getitem__(self, key):\n+        value = self._raw_dict.__getitem__(key)\n+        if key not in self._resolved and callable(value):\n+            # exchange callable with result of calling it -- but only once! allow resolver to return a\n+            # callable itself\n+            value = value()\n+            self._resolved.add(key)\n+            self._raw_dict.__setitem__(key, value)\n+        return value\n+\n+    def __delitem__(self, key):\n+        with contextlib.suppress(KeyError):\n+            self._resolved.remove(key)\n+        self._raw_dict.__delitem__(key)\n+\n+    def __iter__(self):\n+        return iter(self._raw_dict)\n+\n+    def __len__(self):\n+        return len(self._raw_dict)\n+\n+    def __contains__(self, key):\n+        return key in self._raw_dict\n+\n+    def clear(self):\n+        self._resolved.clear()\n+        self._raw_dict.clear()\n+\n+\n+def _read_schema_from_resources_or_local_file(filename: str) -> dict:\n+    \"\"\"Read JSON schema from resources or local file.\"\"\"\n+    try:\n+        with resource_files(\"airflow\").joinpath(filename).open(\"rb\") as f:\n+            schema = json.load(f)\n+    except (TypeError, FileNotFoundError):\n+        with (pathlib.Path(__file__).parent / filename).open(\"rb\") as f:\n+            schema = json.load(f)\n+    return schema\n+\n+\n+def _create_provider_info_schema_validator():\n+    \"\"\"Create JSON schema validator from the provider_info.schema.json.\"\"\"\n+    import jsonschema\n+\n+    schema = _read_schema_from_resources_or_local_file(\"provider_info.schema.json\")\n+    cls = jsonschema.validators.validator_for(schema)\n+    validator = cls(schema)\n+    return validator\n+\n+\n+def _create_customized_form_field_behaviours_schema_validator():\n+    \"\"\"Create JSON schema validator from the customized_form_field_behaviours.schema.json.\"\"\"\n+    import jsonschema\n+\n+    schema = _read_schema_from_resources_or_local_file(\"customized_form_field_behaviours.schema.json\")\n+    cls = jsonschema.validators.validator_for(schema)\n+    validator = cls(schema)\n+    return validator\n+\n+\n+def _check_builtin_provider_prefix(provider_package: str, class_name: str) -> bool:\n+    \"\"\"Check if builtin provider class has correct prefix.\"\"\"\n+    if provider_package.startswith(\"apache-airflow\"):\n+        provider_path = provider_package[len(\"apache-\") :].replace(\"-\", \".\")\n+        if not class_name.startswith(provider_path):\n+            log.warning(\n+                \"Coherence check failed when importing '%s' from '%s' package. It should start with '%s'\",\n+                class_name,\n+                provider_package,\n+                provider_path,\n+            )\n+            return False\n+    return True\n+\n+\n+def _ensure_prefix_for_placeholders(field_behaviors: dict[str, Any], conn_type: str):\n+    \"\"\"\n+    Verify the correct placeholder prefix.\n+\n+    If the given field_behaviors dict contains a placeholder's node, and there\n+    are placeholders for extra fields (i.e. anything other than the built-in conn\n+    attrs), and if those extra fields are unprefixed, then add the prefix.\n+\n+    The reason we need to do this is, all custom conn fields live in the same dictionary,\n+    so we need to namespace them with a prefix internally.  But for user convenience,\n+    and consistency between the `get_ui_field_behaviour` method and the extra dict itself,\n+    we allow users to supply the unprefixed name.\n+    \"\"\"\n+    conn_attrs = {\"host\", \"schema\", \"login\", \"password\", \"port\", \"extra\"}\n+\n+    def ensure_prefix(field):\n+        if field not in conn_attrs and not field.startswith(\"extra__\"):\n+            return f\"extra__{conn_type}__{field}\"\n+        return field\n+\n+    if \"placeholders\" in field_behaviors:\n+        placeholders = field_behaviors[\"placeholders\"]\n+        field_behaviors[\"placeholders\"] = {ensure_prefix(k): v for k, v in placeholders.items()}\n+\n+    return field_behaviors\n+\n+\n+def log_optional_feature_disabled(class_name, e, provider_package):\n+    \"\"\"Log optional feature disabled.\"\"\"\n+    log.debug(\n+        \"Optional feature disabled on exception when importing '%s' from '%s' package\",\n+        class_name,\n+        provider_package,\n+        exc_info=e,\n+    )\n+    log.info(\n+        \"Optional provider feature disabled when importing '%s' from '%s' package\",\n+        class_name,\n+        provider_package,\n+    )\n+\n+\n+def log_import_warning(class_name, e, provider_package):\n+    \"\"\"Log import warning.\"\"\"\n+    log.warning(\n+        \"Exception when importing '%s' from '%s' package\",\n+        class_name,\n+        provider_package,\n+        exc_info=e,\n+    )\n+\n+\n+def provider_info_cache(cache_name: str) -> Callable[[Callable[PS, None]], Callable[PS, None]]:\n+    \"\"\"\n+    Decorate and cache provider info.\n+\n+    Decorator factory that create decorator that caches initialization of provider's parameters\n+    :param cache_name: Name of the cache\n+    \"\"\"\n+\n+    def provider_info_cache_decorator(func: Callable[PS, None]) -> Callable[PS, None]:\n+        @wraps(func)\n+        def wrapped_function(*args: PS.args, **kwargs: PS.kwargs) -> None:\n+            instance = args[0]\n+\n+            if cache_name in instance._initialized_cache:\n+                return\n+            start_time = perf_counter()\n+            log.debug(\"Initializing Provider Manager[%s]\", cache_name)\n+            func(*args, **kwargs)\n+            instance._initialized_cache[cache_name] = True\n+            log.debug(\n+                \"Initialization of Provider Manager[%s] took %.2f seconds\",\n+                cache_name,\n+                perf_counter() - start_time,\n+            )\n+\n+        return wrapped_function\n+\n+    return provider_info_cache_decorator\n+\n+\n+def discover_all_providers_from_packages(",
      "comment": "Is the logic of this duplicated with \n\nhttps://github.com/astronomer/airflow/blob/a9af1406de16cbe1b1bd040184c2ba08fc0dd06b/airflow-core/src/airflow/providers_manager.py#L638-L650",
      "comment_id": 2690891430,
      "user": "kaxil",
      "created_at": "2026-01-14T15:19:33Z",
      "url": "https://github.com/apache/airflow/pull/60218#discussion_r2690891430"
    },
    {
      "repo": "apache/airflow",
      "pr_number": 60218,
      "file_path": "shared/providers_discovery/src/airflow_shared/providers_discovery/providers_discovery.py",
      "line": 293,
      "side": "RIGHT",
      "diff_hunk": "@@ -0,0 +1,348 @@\n+#\n+# Licensed to the Apache Software Foundation (ASF) under one\n+# or more contributor license agreements.  See the NOTICE file\n+# distributed with this work for additional information\n+# regarding copyright ownership.  The ASF licenses this file\n+# to you under the Apache License, Version 2.0 (the\n+# \"License\"); you may not use this file except in compliance\n+# with the License.  You may obtain a copy of the License at\n+#\n+#   http://www.apache.org/licenses/LICENSE-2.0\n+#\n+# Unless required by applicable law or agreed to in writing,\n+# software distributed under the License is distributed on an\n+# \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+# KIND, either express or implied.  See the License for the\n+# specific language governing permissions and limitations\n+# under the License.\n+\"\"\"Shared provider discovery utilities.\"\"\"\n+\n+from __future__ import annotations\n+\n+import contextlib\n+import json\n+import logging\n+import pathlib\n+from collections.abc import Callable, MutableMapping\n+from dataclasses import dataclass\n+from functools import wraps\n+from importlib.resources import files as resource_files\n+from time import perf_counter\n+from typing import Any, NamedTuple, ParamSpec\n+\n+from packaging.utils import canonicalize_name\n+\n+from ..module_loading import entry_points_with_dist\n+\n+log = logging.getLogger(__name__)\n+\n+\n+PS = ParamSpec(\"PS\")\n+\n+\n+KNOWN_UNHANDLED_OPTIONAL_FEATURE_ERRORS = [(\"apache-airflow-providers-google\", \"No module named 'paramiko'\")]\n+\n+\n+@dataclass\n+class ProviderInfo:\n+    \"\"\"\n+    Provider information.\n+\n+    :param version: version string\n+    :param data: dictionary with information about the provider\n+    \"\"\"\n+\n+    version: str\n+    data: dict\n+\n+\n+class HookClassProvider(NamedTuple):\n+    \"\"\"Hook class and Provider it comes from.\"\"\"\n+\n+    hook_class_name: str\n+    package_name: str\n+\n+\n+class HookInfo(NamedTuple):\n+    \"\"\"Hook information.\"\"\"\n+\n+    hook_class_name: str\n+    connection_id_attribute_name: str\n+    package_name: str\n+    hook_name: str\n+    connection_type: str\n+    connection_testable: bool\n+    dialects: list[str] = []\n+\n+\n+class ConnectionFormWidgetInfo(NamedTuple):\n+    \"\"\"Connection Form Widget information.\"\"\"\n+\n+    hook_class_name: str\n+    package_name: str\n+    field: Any\n+    field_name: str\n+    is_sensitive: bool\n+\n+\n+class PluginInfo(NamedTuple):\n+    \"\"\"Plugin class, name and provider it comes from.\"\"\"\n+\n+    name: str\n+    plugin_class: str\n+    provider_name: str\n+\n+\n+class NotificationInfo(NamedTuple):\n+    \"\"\"Notification class and provider it comes from.\"\"\"\n+\n+    notification_class_name: str\n+    package_name: str\n+\n+\n+class TriggerInfo(NamedTuple):\n+    \"\"\"Trigger class and provider it comes from.\"\"\"\n+\n+    trigger_class_name: str\n+    package_name: str\n+    integration_name: str\n+\n+\n+class DialectInfo(NamedTuple):\n+    \"\"\"Dialect class and Provider it comes from.\"\"\"\n+\n+    name: str\n+    dialect_class_name: str\n+    provider_name: str\n+\n+\n+class LazyDictWithCache(MutableMapping):\n+    \"\"\"\n+    Lazy-loaded cached dictionary.\n+\n+    Dictionary, which in case you set callable, executes the passed callable with `key` attribute\n+    at first use - and returns and caches the result.\n+    \"\"\"\n+\n+    __slots__ = [\"_resolved\", \"_raw_dict\"]\n+\n+    def __init__(self, *args, **kw):\n+        self._resolved = set()\n+        self._raw_dict = dict(*args, **kw)\n+\n+    def __setitem__(self, key, value):\n+        self._raw_dict.__setitem__(key, value)\n+\n+    def __getitem__(self, key):\n+        value = self._raw_dict.__getitem__(key)\n+        if key not in self._resolved and callable(value):\n+            # exchange callable with result of calling it -- but only once! allow resolver to return a\n+            # callable itself\n+            value = value()\n+            self._resolved.add(key)\n+            self._raw_dict.__setitem__(key, value)\n+        return value\n+\n+    def __delitem__(self, key):\n+        with contextlib.suppress(KeyError):\n+            self._resolved.remove(key)\n+        self._raw_dict.__delitem__(key)\n+\n+    def __iter__(self):\n+        return iter(self._raw_dict)\n+\n+    def __len__(self):\n+        return len(self._raw_dict)\n+\n+    def __contains__(self, key):\n+        return key in self._raw_dict\n+\n+    def clear(self):\n+        self._resolved.clear()\n+        self._raw_dict.clear()\n+\n+\n+def _read_schema_from_resources_or_local_file(filename: str) -> dict:\n+    \"\"\"Read JSON schema from resources or local file.\"\"\"\n+    try:\n+        with resource_files(\"airflow\").joinpath(filename).open(\"rb\") as f:\n+            schema = json.load(f)\n+    except (TypeError, FileNotFoundError):\n+        with (pathlib.Path(__file__).parent / filename).open(\"rb\") as f:\n+            schema = json.load(f)\n+    return schema\n+\n+\n+def _create_provider_info_schema_validator():\n+    \"\"\"Create JSON schema validator from the provider_info.schema.json.\"\"\"\n+    import jsonschema\n+\n+    schema = _read_schema_from_resources_or_local_file(\"provider_info.schema.json\")\n+    cls = jsonschema.validators.validator_for(schema)\n+    validator = cls(schema)\n+    return validator\n+\n+\n+def _create_customized_form_field_behaviours_schema_validator():\n+    \"\"\"Create JSON schema validator from the customized_form_field_behaviours.schema.json.\"\"\"\n+    import jsonschema\n+\n+    schema = _read_schema_from_resources_or_local_file(\"customized_form_field_behaviours.schema.json\")\n+    cls = jsonschema.validators.validator_for(schema)\n+    validator = cls(schema)\n+    return validator\n+\n+\n+def _check_builtin_provider_prefix(provider_package: str, class_name: str) -> bool:\n+    \"\"\"Check if builtin provider class has correct prefix.\"\"\"\n+    if provider_package.startswith(\"apache-airflow\"):\n+        provider_path = provider_package[len(\"apache-\") :].replace(\"-\", \".\")\n+        if not class_name.startswith(provider_path):\n+            log.warning(\n+                \"Coherence check failed when importing '%s' from '%s' package. It should start with '%s'\",\n+                class_name,\n+                provider_package,\n+                provider_path,\n+            )\n+            return False\n+    return True\n+\n+\n+def _ensure_prefix_for_placeholders(field_behaviors: dict[str, Any], conn_type: str):\n+    \"\"\"\n+    Verify the correct placeholder prefix.\n+\n+    If the given field_behaviors dict contains a placeholder's node, and there\n+    are placeholders for extra fields (i.e. anything other than the built-in conn\n+    attrs), and if those extra fields are unprefixed, then add the prefix.\n+\n+    The reason we need to do this is, all custom conn fields live in the same dictionary,\n+    so we need to namespace them with a prefix internally.  But for user convenience,\n+    and consistency between the `get_ui_field_behaviour` method and the extra dict itself,\n+    we allow users to supply the unprefixed name.\n+    \"\"\"\n+    conn_attrs = {\"host\", \"schema\", \"login\", \"password\", \"port\", \"extra\"}\n+\n+    def ensure_prefix(field):\n+        if field not in conn_attrs and not field.startswith(\"extra__\"):\n+            return f\"extra__{conn_type}__{field}\"\n+        return field\n+\n+    if \"placeholders\" in field_behaviors:\n+        placeholders = field_behaviors[\"placeholders\"]\n+        field_behaviors[\"placeholders\"] = {ensure_prefix(k): v for k, v in placeholders.items()}\n+\n+    return field_behaviors\n+\n+\n+def log_optional_feature_disabled(class_name, e, provider_package):\n+    \"\"\"Log optional feature disabled.\"\"\"\n+    log.debug(\n+        \"Optional feature disabled on exception when importing '%s' from '%s' package\",\n+        class_name,\n+        provider_package,\n+        exc_info=e,\n+    )\n+    log.info(\n+        \"Optional provider feature disabled when importing '%s' from '%s' package\",\n+        class_name,\n+        provider_package,\n+    )\n+\n+\n+def log_import_warning(class_name, e, provider_package):\n+    \"\"\"Log import warning.\"\"\"\n+    log.warning(\n+        \"Exception when importing '%s' from '%s' package\",\n+        class_name,\n+        provider_package,\n+        exc_info=e,\n+    )\n+\n+\n+def provider_info_cache(cache_name: str) -> Callable[[Callable[PS, None]], Callable[PS, None]]:\n+    \"\"\"\n+    Decorate and cache provider info.\n+\n+    Decorator factory that create decorator that caches initialization of provider's parameters\n+    :param cache_name: Name of the cache\n+    \"\"\"\n+\n+    def provider_info_cache_decorator(func: Callable[PS, None]) -> Callable[PS, None]:\n+        @wraps(func)\n+        def wrapped_function(*args: PS.args, **kwargs: PS.kwargs) -> None:\n+            instance = args[0]\n+\n+            if cache_name in instance._initialized_cache:\n+                return\n+            start_time = perf_counter()\n+            log.debug(\"Initializing Provider Manager[%s]\", cache_name)\n+            func(*args, **kwargs)\n+            instance._initialized_cache[cache_name] = True\n+            log.debug(\n+                \"Initialization of Provider Manager[%s] took %.2f seconds\",\n+                cache_name,\n+                perf_counter() - start_time,\n+            )\n+\n+        return wrapped_function\n+\n+    return provider_info_cache_decorator\n+\n+\n+def discover_all_providers_from_packages(",
      "comment": "Yep its a copy paste, since we will be needing it in both runtime and core providersmanager, it is put in shared",
      "comment_id": 2693673671,
      "user": "amoghrajesh",
      "created_at": "2026-01-15T09:43:31Z",
      "url": "https://github.com/apache/airflow/pull/60218#discussion_r2693673671"
    },
    {
      "repo": "apache/airflow",
      "pr_number": 60218,
      "file_path": "task-sdk/src/airflow/sdk/providers_manager_runtime.py",
      "line": 530,
      "side": "RIGHT",
      "diff_hunk": "@@ -0,0 +1,614 @@\n+#\n+# Licensed to the Apache Software Foundation (ASF) under one\n+# or more contributor license agreements.  See the NOTICE file\n+# distributed with this work for additional information\n+# regarding copyright ownership.  The ASF licenses this file\n+# to you under the Apache License, Version 2.0 (the\n+# \"License\"); you may not use this file except in compliance\n+# with the License.  You may obtain a copy of the License at\n+#\n+#   http://www.apache.org/licenses/LICENSE-2.0\n+#\n+# Unless required by applicable law or agreed to in writing,\n+# software distributed under the License is distributed on an\n+# \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+# KIND, either express or implied.  See the License for the\n+# specific language governing permissions and limitations\n+# under the License.\n+\"\"\"Manages runtime provider resources for task execution.\"\"\"\n+\n+from __future__ import annotations\n+\n+import functools\n+import inspect\n+import logging\n+import traceback\n+import warnings\n+from collections.abc import Callable, MutableMapping\n+from typing import TYPE_CHECKING, Any\n+from urllib.parse import SplitResult\n+\n+from airflow.sdk._shared.module_loading import import_string\n+from airflow.sdk._shared.providers_discovery import (\n+    KNOWN_UNHANDLED_OPTIONAL_FEATURE_ERRORS,\n+    HookClassProvider,\n+    HookInfo,\n+    LazyDictWithCache,\n+    PluginInfo,\n+    ProviderInfo,\n+    _check_builtin_provider_prefix,\n+    _create_provider_info_schema_validator,\n+    discover_all_providers_from_packages,\n+    log_import_warning,\n+    log_optional_feature_disabled,\n+    provider_info_cache,\n+)\n+from airflow.sdk.definitions._internal.logging_mixin import LoggingMixin\n+from airflow.sdk.exceptions import AirflowOptionalProviderFeatureException\n+\n+if TYPE_CHECKING:\n+    from airflow.sdk import BaseHook\n+    from airflow.sdk.bases.decorator import TaskDecorator\n+    from airflow.sdk.definitions.asset import Asset\n+\n+log = logging.getLogger(__name__)\n+\n+\n+def _correctness_check(provider_package: str, class_name: str, provider_info: ProviderInfo) -> Any:\n+    \"\"\"\n+    Perform coherence check on provider classes.\n+\n+    For apache-airflow providers - it checks if it starts with appropriate package. For all providers\n+    it tries to import the provider - checking that there are no exceptions during importing.\n+    It logs appropriate warning in case it detects any problems.\n+\n+    :param provider_package: name of the provider package\n+    :param class_name: name of the class to import\n+\n+    :return the class if the class is OK, None otherwise.\n+    \"\"\"\n+    if not _check_builtin_provider_prefix(provider_package, class_name):\n+        return None\n+    try:\n+        imported_class = import_string(class_name)\n+    except AirflowOptionalProviderFeatureException as e:\n+        # When the provider class raises AirflowOptionalProviderFeatureException\n+        # this is an expected case when only some classes in provider are\n+        # available. We just log debug level here and print info message in logs so that\n+        # the user is aware of it\n+        log_optional_feature_disabled(class_name, e, provider_package)\n+        return None\n+    except ImportError as e:\n+        if \"No module named 'airflow.providers.\" in e.msg:\n+            # handle cases where another provider is missing. This can only happen if\n+            # there is an optional feature, so we log debug and print information about it\n+            log_optional_feature_disabled(class_name, e, provider_package)\n+            return None\n+        for known_error in KNOWN_UNHANDLED_OPTIONAL_FEATURE_ERRORS:\n+            # Until we convert all providers to use AirflowOptionalProviderFeatureException\n+            # we assume any problem with importing another \"provider\" is because this is an\n+            # optional feature, so we log debug and print information about it\n+            if known_error[0] == provider_package and known_error[1] in e.msg:\n+                log_optional_feature_disabled(class_name, e, provider_package)\n+                return None\n+        # But when we have no idea - we print warning to logs\n+        log_import_warning(class_name, e, provider_package)\n+        return None\n+    except Exception as e:\n+        log_import_warning(class_name, e, provider_package)\n+        return None\n+    return imported_class\n+\n+\n+class ProvidersManagerRuntime(LoggingMixin):\n+    \"\"\"\n+    Manages runtime provider resources for task execution.\n+\n+    This is a Singleton class. The first time it is instantiated, it discovers all available\n+    runtime provider resources (hooks, taskflow decorators, filesystems, asset handlers).\n+    \"\"\"\n+\n+    resource_version = \"0\"\n+    _initialized: bool = False\n+    _initialization_stack_trace = None\n+    _instance: ProvidersManagerRuntime | None = None\n+\n+    def __new__(cls):\n+        if cls._instance is None:\n+            cls._instance = super().__new__(cls)\n+        return cls._instance\n+\n+    @staticmethod\n+    def initialized() -> bool:\n+        return ProvidersManagerRuntime._initialized\n+\n+    @staticmethod\n+    def initialization_stack_trace() -> str | None:\n+        return ProvidersManagerRuntime._initialization_stack_trace\n+\n+    def __init__(self):\n+        \"\"\"Initialize the runtime manager.\"\"\"\n+        # skip initialization if already initialized\n+        if self.initialized():\n+            return\n+        super().__init__()\n+        ProvidersManagerRuntime._initialized = True\n+        ProvidersManagerRuntime._initialization_stack_trace = \"\".join(\n+            traceback.format_stack(inspect.currentframe())\n+        )\n+        self._initialized_cache: dict[str, bool] = {}\n+        # Keeps dict of providers keyed by module name\n+        self._provider_dict: dict[str, ProviderInfo] = {}\n+        self._fs_set: set[str] = set()\n+        self._asset_uri_handlers: dict[str, Callable[[SplitResult], SplitResult]] = {}\n+        self._asset_factories: dict[str, Callable[..., Asset]] = {}\n+        self._asset_to_openlineage_converters: dict[str, Callable] = {}\n+        self._taskflow_decorators: dict[str, Callable] = LazyDictWithCache()\n+        # keeps mapping between connection_types and hook class, package they come from\n+        self._hook_provider_dict: dict[str, HookClassProvider] = {}\n+        # Keeps dict of hooks keyed by connection type. They are lazy evaluated at access time\n+        self._hooks_lazy_dict: LazyDictWithCache[str, HookInfo | Callable] = LazyDictWithCache()\n+        self._plugins_set: set[PluginInfo] = set()\n+        self._provider_schema_validator = _create_provider_info_schema_validator()\n+        self._init_airflow_core_hooks()\n+\n+    def _init_airflow_core_hooks(self):\n+        \"\"\"Initialize the hooks dict with default hooks from Airflow core.\"\"\"\n+        core_dummy_hooks = {\n+            \"generic\": \"Generic\",\n+            \"email\": \"Email\",\n+        }\n+        for key, display in core_dummy_hooks.items():\n+            self._hooks_lazy_dict[key] = HookInfo(\n+                hook_class_name=None,\n+                connection_id_attribute_name=None,\n+                package_name=None,\n+                hook_name=display,\n+                connection_type=None,\n+                connection_testable=False,\n+            )\n+        for conn_type, class_name in (\n+            (\"fs\", \"airflow.providers.standard.hooks.filesystem.FSHook\"),\n+            (\"package_index\", \"airflow.providers.standard.hooks.package_index.PackageIndexHook\"),\n+        ):\n+            self._hooks_lazy_dict[conn_type] = functools.partial(\n+                self._import_hook,\n+                connection_type=None,\n+                package_name=\"apache-airflow-providers-standard\",\n+                hook_class_name=class_name,\n+                provider_info=None,\n+            )\n+\n+    @provider_info_cache(\"list\")\n+    def initialize_providers_list(self):\n+        \"\"\"Lazy initialization of providers list.\"\"\"\n+        discover_all_providers_from_packages(self._provider_dict, self._provider_schema_validator)\n+        self._provider_dict = dict(sorted(self._provider_dict.items()))\n+\n+    @provider_info_cache(\"hooks\")\n+    def initialize_providers_hooks(self):\n+        \"\"\"Lazy initialization of providers hooks.\"\"\"\n+        self._init_airflow_core_hooks()\n+        self.initialize_providers_list()\n+        self._discover_hooks()\n+        self._hook_provider_dict = dict(sorted(self._hook_provider_dict.items()))\n+\n+    @provider_info_cache(\"filesystems\")\n+    def initialize_providers_filesystems(self):\n+        \"\"\"Lazy initialization of providers filesystems.\"\"\"\n+        self.initialize_providers_list()\n+        self._discover_filesystems()\n+\n+    @provider_info_cache(\"asset_uris\")\n+    def initialize_providers_asset_uri_resources(self):\n+        \"\"\"Lazy initialization of provider asset URI handlers, factories, converters etc.\"\"\"\n+        self.initialize_providers_list()\n+        self._discover_asset_uri_resources()\n+\n+    @provider_info_cache(\"plugins\")\n+    def initialize_providers_plugins(self):\n+        \"\"\"Lazy initialization of providers plugins.\"\"\"\n+        self.initialize_providers_list()\n+        self._discover_plugins()\n+\n+    @provider_info_cache(\"taskflow_decorators\")\n+    def initialize_providers_taskflow_decorator(self):\n+        \"\"\"Lazy initialization of providers taskflow decorators.\"\"\"\n+        self.initialize_providers_list()\n+        self._discover_taskflow_decorators()\n+\n+    def _discover_hooks_from_connection_types(\n+        self,\n+        hook_class_names_registered: set[str],\n+        already_registered_warning_connection_types: set[str],\n+        package_name: str,\n+        provider: ProviderInfo,\n+    ):\n+        \"\"\"\n+        Discover hooks from the \"connection-types\" property.\n+\n+        This is new, better method that replaces discovery from hook-class-names as it\n+        allows to lazy import individual Hook classes when they are accessed.\n+        The \"connection-types\" keeps information about both - connection type and class\n+        name so we can discover all connection-types without importing the classes.\n+        :param hook_class_names_registered: set of registered hook class names for this provider\n+        :param already_registered_warning_connection_types: set of connections for which warning should be\n+            printed in logs as they were already registered before\n+        :param package_name:\n+        :param provider:\n+        :return:\n+        \"\"\"\n+        provider_uses_connection_types = False\n+        connection_types = provider.data.get(\"connection-types\")\n+        if connection_types:\n+            for connection_type_dict in connection_types:\n+                connection_type = connection_type_dict[\"connection-type\"]\n+                hook_class_name = connection_type_dict[\"hook-class-name\"]\n+                hook_class_names_registered.add(hook_class_name)\n+                already_registered = self._hook_provider_dict.get(connection_type)\n+                if already_registered:\n+                    if already_registered.package_name != package_name:\n+                        already_registered_warning_connection_types.add(connection_type)\n+                    else:\n+                        log.warning(\n+                            \"The connection type '%s' is already registered in the\"\n+                            \" package '%s' with different class names: '%s' and '%s'. \",\n+                            connection_type,\n+                            package_name,\n+                            already_registered.hook_class_name,\n+                            hook_class_name,\n+                        )\n+                else:\n+                    self._hook_provider_dict[connection_type] = HookClassProvider(\n+                        hook_class_name=hook_class_name, package_name=package_name\n+                    )\n+                    # Defer importing hook to access time by setting import hook method as dict value\n+                    self._hooks_lazy_dict[connection_type] = functools.partial(\n+                        self._import_hook,\n+                        connection_type=connection_type,\n+                        provider_info=provider,\n+                    )\n+            provider_uses_connection_types = True\n+        return provider_uses_connection_types\n+\n+    def _discover_hooks_from_hook_class_names(\n+        self,\n+        hook_class_names_registered: set[str],\n+        already_registered_warning_connection_types: set[str],\n+        package_name: str,\n+        provider: ProviderInfo,\n+        provider_uses_connection_types: bool,\n+    ):\n+        \"\"\"\n+        Discover hooks from \"hook-class-names' property.\n+\n+        This property is deprecated but we should support it in Airflow 2.\n+        The hook-class-names array contained just Hook names without connection type,\n+        therefore we need to import all those classes immediately to know which connection types\n+        are supported. This makes it impossible to selectively only import those hooks that are used.\n+        :param already_registered_warning_connection_types: list of connection hooks that we should warn\n+            about when finished discovery\n+        :param package_name: name of the provider package\n+        :param provider: class that keeps information about version and details of the provider\n+        :param provider_uses_connection_types: determines whether the provider uses \"connection-types\" new\n+           form of passing connection types\n+        :return:\n+        \"\"\"\n+        hook_class_names = provider.data.get(\"hook-class-names\")\n+        if hook_class_names:\n+            for hook_class_name in hook_class_names:\n+                if hook_class_name in hook_class_names_registered:\n+                    # Silently ignore the hook class - it's already marked for lazy-import by\n+                    # connection-types discovery\n+                    continue\n+                hook_info = self._import_hook(\n+                    connection_type=None,\n+                    provider_info=provider,\n+                    hook_class_name=hook_class_name,\n+                    package_name=package_name,\n+                )\n+                if not hook_info:\n+                    # Problem why importing class - we ignore it. Log is written at import time\n+                    continue\n+                already_registered = self._hook_provider_dict.get(hook_info.connection_type)\n+                if already_registered:\n+                    if already_registered.package_name != package_name:\n+                        already_registered_warning_connection_types.add(hook_info.connection_type)\n+                    else:\n+                        if already_registered.hook_class_name != hook_class_name:\n+                            log.warning(\n+                                \"The hook connection type '%s' is registered twice in the\"\n+                                \" package '%s' with different class names: '%s' and '%s'. \"\n+                                \" Please fix it!\",\n+                                hook_info.connection_type,\n+                                package_name,\n+                                already_registered.hook_class_name,\n+                                hook_class_name,\n+                            )\n+                else:\n+                    self._hook_provider_dict[hook_info.connection_type] = HookClassProvider(\n+                        hook_class_name=hook_class_name, package_name=package_name\n+                    )\n+                    self._hooks_lazy_dict[hook_info.connection_type] = hook_info\n+\n+            if not provider_uses_connection_types:\n+                warnings.warn(\n+                    f\"The provider {package_name} uses `hook-class-names` \"\n+                    \"property in provider-info and has no `connection-types` one. \"\n+                    \"The 'hook-class-names' property has been deprecated in favour \"\n+                    \"of 'connection-types' in Airflow 2.2. Use **both** in case you want to \"\n+                    \"have backwards compatibility with Airflow < 2.2\",\n+                    DeprecationWarning,\n+                    stacklevel=1,\n+                )\n+        for already_registered_connection_type in already_registered_warning_connection_types:\n+            log.warning(\n+                \"The connection_type '%s' has been already registered by provider '%s.'\",\n+                already_registered_connection_type,\n+                self._hook_provider_dict[already_registered_connection_type].package_name,\n+            )\n+\n+    def _discover_hooks(self) -> None:\n+        \"\"\"Retrieve all connections defined in the providers via Hooks.\"\"\"\n+        for package_name, provider in self._provider_dict.items():\n+            duplicated_connection_types: set[str] = set()\n+            hook_class_names_registered: set[str] = set()\n+            provider_uses_connection_types = self._discover_hooks_from_connection_types(\n+                hook_class_names_registered, duplicated_connection_types, package_name, provider\n+            )\n+            self._discover_hooks_from_hook_class_names(\n+                hook_class_names_registered,\n+                duplicated_connection_types,\n+                package_name,\n+                provider,\n+                provider_uses_connection_types,\n+            )\n+        self._hook_provider_dict = dict(sorted(self._hook_provider_dict.items()))\n+\n+    @staticmethod\n+    def _get_attr(obj: Any, attr_name: str):\n+        \"\"\"Retrieve attributes of an object, or warn if not found.\"\"\"\n+        if not hasattr(obj, attr_name):\n+            log.warning(\"The object '%s' is missing %s attribute and cannot be registered\", obj, attr_name)\n+            return None\n+        return getattr(obj, attr_name)\n+\n+    def _import_hook(\n+        self,\n+        connection_type: str | None,\n+        provider_info: ProviderInfo,\n+        hook_class_name: str | None = None,\n+        package_name: str | None = None,\n+    ) -> HookInfo | None:\n+        \"\"\"\n+        Import hook and retrieve hook information.\n+\n+        Either connection_type (for lazy loading) or hook_class_name must be set - but not both).\n+        Only needs package_name if hook_class_name is passed (for lazy loading, package_name\n+        is retrieved from _connection_type_class_provider_dict together with hook_class_name).\n+\n+        :param connection_type: type of the connection\n+        :param hook_class_name: name of the hook class\n+        :param package_name: provider package - only needed in case connection_type is missing\n+        : return\n+        \"\"\"\n+        if connection_type is None and hook_class_name is None:\n+            raise ValueError(\"Either connection_type or hook_class_name must be set\")\n+        if connection_type is not None and hook_class_name is not None:\n+            raise ValueError(\n+                f\"Both connection_type ({connection_type} and \"\n+                f\"hook_class_name {hook_class_name} are set. Only one should be set!\"\n+            )\n+        if connection_type is not None:\n+            class_provider = self._hook_provider_dict[connection_type]\n+            package_name = class_provider.package_name\n+            hook_class_name = class_provider.hook_class_name\n+        else:\n+            if not hook_class_name:\n+                raise ValueError(\"Either connection_type or hook_class_name must be set\")\n+            if not package_name:\n+                raise ValueError(\n+                    f\"Provider package name is not set when hook_class_name ({hook_class_name}) is used\"\n+                )\n+        hook_class: type[BaseHook] | None = _correctness_check(package_name, hook_class_name, provider_info)\n+        if hook_class is None:\n+            return None\n+\n+        hook_connection_type = self._get_attr(hook_class, \"conn_type\")\n+        if connection_type:\n+            if hook_connection_type != connection_type:\n+                log.warning(\n+                    \"Inconsistency! The hook class '%s' declares connection type '%s'\"\n+                    \" but it is added by provider '%s' as connection_type '%s' in provider info. \"\n+                    \"This should be fixed!\",\n+                    hook_class,\n+                    hook_connection_type,\n+                    package_name,\n+                    connection_type,\n+                )\n+        connection_type = hook_connection_type\n+        connection_id_attribute_name: str = self._get_attr(hook_class, \"conn_name_attr\")\n+        hook_name: str = self._get_attr(hook_class, \"hook_name\")\n+\n+        if not connection_type or not connection_id_attribute_name or not hook_name:\n+            log.warning(\n+                \"The hook misses one of the key attributes: \"\n+                \"conn_type: %s, conn_id_attribute_name: %s, hook_name: %s\",\n+                connection_type,\n+                connection_id_attribute_name,\n+                hook_name,\n+            )\n+            return None\n+\n+        return HookInfo(\n+            hook_class_name=hook_class_name,\n+            connection_id_attribute_name=connection_id_attribute_name,\n+            package_name=package_name,\n+            hook_name=hook_name,\n+            connection_type=connection_type,\n+            connection_testable=hasattr(hook_class, \"test_connection\"),\n+        )\n+\n+    def _discover_filesystems(self) -> None:\n+        \"\"\"Retrieve all filesystems defined in the providers.\"\"\"\n+        for provider_package, provider in self._provider_dict.items():\n+            for fs_module_name in provider.data.get(\"filesystems\", []):\n+                if _correctness_check(provider_package, f\"{fs_module_name}.get_fs\", provider):\n+                    self._fs_set.add(fs_module_name)\n+        self._fs_set = set(sorted(self._fs_set))\n+\n+    def _discover_asset_uri_resources(self) -> None:\n+        \"\"\"Discovers and registers asset URI handlers, factories, and converters for all providers.\"\"\"\n+        from airflow.sdk.definitions.asset import normalize_noop\n+\n+        def _safe_register_resource(\n+            provider_package_name: str,\n+            schemes_list: list[str],\n+            resource_path: str | None,\n+            resource_registry: dict,\n+            default_resource: Any = None,\n+        ):\n+            \"\"\"\n+            Register a specific resource (handler, factory, or converter) for the given schemes.\n+\n+            If the resolved resource (either from the path or the default) is valid, it updates\n+            the resource registry with the appropriate resource for each scheme.\n+            \"\"\"\n+            resource = (\n+                _correctness_check(provider_package_name, resource_path, provider)\n+                if resource_path is not None\n+                else default_resource\n+            )\n+            if resource:\n+                resource_registry.update((scheme, resource) for scheme in schemes_list)\n+\n+        for provider_name, provider in self._provider_dict.items():\n+            for uri_info in provider.data.get(\"asset-uris\", []):\n+                if \"schemes\" not in uri_info or \"handler\" not in uri_info:\n+                    continue  # Both schemas and handler must be explicitly set, handler can be set to null\n+                common_args = {\"schemes_list\": uri_info[\"schemes\"], \"provider_package_name\": provider_name}\n+                _safe_register_resource(\n+                    resource_path=uri_info[\"handler\"],\n+                    resource_registry=self._asset_uri_handlers,\n+                    default_resource=normalize_noop,\n+                    **common_args,\n+                )\n+                _safe_register_resource(\n+                    resource_path=uri_info.get(\"factory\"),\n+                    resource_registry=self._asset_factories,\n+                    **common_args,\n+                )\n+                _safe_register_resource(\n+                    resource_path=uri_info.get(\"to_openlineage_converter\"),\n+                    resource_registry=self._asset_to_openlineage_converters,\n+                    **common_args,\n+                )\n+\n+    def _discover_plugins(self) -> None:\n+        \"\"\"Retrieve all plugins defined in the providers.\"\"\"\n+        for provider_package, provider in self._provider_dict.items():\n+            for plugin_dict in provider.data.get(\"plugins\", ()):\n+                if not _correctness_check(provider_package, plugin_dict[\"plugin-class\"], provider):\n+                    log.warning(\"Plugin not loaded due to above correctness check problem.\")\n+                    continue\n+                self._plugins_set.add(\n+                    PluginInfo(\n+                        name=plugin_dict[\"name\"],\n+                        plugin_class=plugin_dict[\"plugin-class\"],\n+                        provider_name=provider_package,\n+                    )\n+                )\n+\n+    def _discover_taskflow_decorators(self) -> None:\n+        for name, info in self._provider_dict.items():\n+            for taskflow_decorator in info.data.get(\"task-decorators\", []):\n+                self._add_taskflow_decorator(\n+                    taskflow_decorator[\"name\"], taskflow_decorator[\"class-name\"], name\n+                )\n+\n+    def _add_taskflow_decorator(self, name, decorator_class_name: str, provider_package: str) -> None:\n+        from airflow._shared.providers_discovery import _check_builtin_provider_prefix",
      "comment": "It's not? I do not see it being imported.\n\nSince its specific to runtime providers manager, it is only defined here",
      "comment_id": 2693681385,
      "user": "amoghrajesh",
      "created_at": "2026-01-15T09:45:52Z",
      "url": "https://github.com/apache/airflow/pull/60218#discussion_r2693681385"
    },
    {
      "repo": "apache/airflow",
      "pr_number": 60218,
      "file_path": "airflow-core/src/airflow/providers_manager.py",
      "line": 453,
      "side": "RIGHT",
      "diff_hunk": "@@ -438,6 +439,33 @@ def __init__(self):\n         self._plugins_set: set[PluginInfo] = set()\n         self._init_airflow_core_hooks()\n \n+        self._runtime_manager = None\n+\n+    def __getattribute__(self, name: str):\n+        # Hacky but does the trick for now\n+        runtime_properties = {\n+            \"hooks\",\n+            \"taskflow_decorators\",\n+            \"filesystem_module_names\",\n+            \"asset_factories\",\n+            \"asset_uri_handlers\",\n+            \"asset_to_openlineage_converters\",\n+        }",
      "comment": "Do we need to cleanup these existed properties that are belongs to `runtime_properties` for core ProviderManager?\r\n\r\nhttps://github.com/apache/airflow/blob/26a9d3b81b1d514ac00476885ba29676cd8f27e6/airflow-core/src/airflow/providers_manager.py#L1238-L1248\r\n\r\nSince those properites will be handled by `getattr(object.__getattribute__(self, \"_runtime_manager\"), name)`.",
      "comment_id": 2693714161,
      "user": "jason810496",
      "created_at": "2026-01-15T09:54:59Z",
      "url": "https://github.com/apache/airflow/pull/60218#discussion_r2693714161"
    },
    {
      "repo": "apache/airflow",
      "pr_number": 60218,
      "file_path": "shared/providers_discovery/src/airflow_shared/providers_discovery/providers_discovery.py",
      "line": 293,
      "side": "RIGHT",
      "diff_hunk": "@@ -0,0 +1,348 @@\n+#\n+# Licensed to the Apache Software Foundation (ASF) under one\n+# or more contributor license agreements.  See the NOTICE file\n+# distributed with this work for additional information\n+# regarding copyright ownership.  The ASF licenses this file\n+# to you under the Apache License, Version 2.0 (the\n+# \"License\"); you may not use this file except in compliance\n+# with the License.  You may obtain a copy of the License at\n+#\n+#   http://www.apache.org/licenses/LICENSE-2.0\n+#\n+# Unless required by applicable law or agreed to in writing,\n+# software distributed under the License is distributed on an\n+# \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+# KIND, either express or implied.  See the License for the\n+# specific language governing permissions and limitations\n+# under the License.\n+\"\"\"Shared provider discovery utilities.\"\"\"\n+\n+from __future__ import annotations\n+\n+import contextlib\n+import json\n+import logging\n+import pathlib\n+from collections.abc import Callable, MutableMapping\n+from dataclasses import dataclass\n+from functools import wraps\n+from importlib.resources import files as resource_files\n+from time import perf_counter\n+from typing import Any, NamedTuple, ParamSpec\n+\n+from packaging.utils import canonicalize_name\n+\n+from ..module_loading import entry_points_with_dist\n+\n+log = logging.getLogger(__name__)\n+\n+\n+PS = ParamSpec(\"PS\")\n+\n+\n+KNOWN_UNHANDLED_OPTIONAL_FEATURE_ERRORS = [(\"apache-airflow-providers-google\", \"No module named 'paramiko'\")]\n+\n+\n+@dataclass\n+class ProviderInfo:\n+    \"\"\"\n+    Provider information.\n+\n+    :param version: version string\n+    :param data: dictionary with information about the provider\n+    \"\"\"\n+\n+    version: str\n+    data: dict\n+\n+\n+class HookClassProvider(NamedTuple):\n+    \"\"\"Hook class and Provider it comes from.\"\"\"\n+\n+    hook_class_name: str\n+    package_name: str\n+\n+\n+class HookInfo(NamedTuple):\n+    \"\"\"Hook information.\"\"\"\n+\n+    hook_class_name: str\n+    connection_id_attribute_name: str\n+    package_name: str\n+    hook_name: str\n+    connection_type: str\n+    connection_testable: bool\n+    dialects: list[str] = []\n+\n+\n+class ConnectionFormWidgetInfo(NamedTuple):\n+    \"\"\"Connection Form Widget information.\"\"\"\n+\n+    hook_class_name: str\n+    package_name: str\n+    field: Any\n+    field_name: str\n+    is_sensitive: bool\n+\n+\n+class PluginInfo(NamedTuple):\n+    \"\"\"Plugin class, name and provider it comes from.\"\"\"\n+\n+    name: str\n+    plugin_class: str\n+    provider_name: str\n+\n+\n+class NotificationInfo(NamedTuple):\n+    \"\"\"Notification class and provider it comes from.\"\"\"\n+\n+    notification_class_name: str\n+    package_name: str\n+\n+\n+class TriggerInfo(NamedTuple):\n+    \"\"\"Trigger class and provider it comes from.\"\"\"\n+\n+    trigger_class_name: str\n+    package_name: str\n+    integration_name: str\n+\n+\n+class DialectInfo(NamedTuple):\n+    \"\"\"Dialect class and Provider it comes from.\"\"\"\n+\n+    name: str\n+    dialect_class_name: str\n+    provider_name: str\n+\n+\n+class LazyDictWithCache(MutableMapping):\n+    \"\"\"\n+    Lazy-loaded cached dictionary.\n+\n+    Dictionary, which in case you set callable, executes the passed callable with `key` attribute\n+    at first use - and returns and caches the result.\n+    \"\"\"\n+\n+    __slots__ = [\"_resolved\", \"_raw_dict\"]\n+\n+    def __init__(self, *args, **kw):\n+        self._resolved = set()\n+        self._raw_dict = dict(*args, **kw)\n+\n+    def __setitem__(self, key, value):\n+        self._raw_dict.__setitem__(key, value)\n+\n+    def __getitem__(self, key):\n+        value = self._raw_dict.__getitem__(key)\n+        if key not in self._resolved and callable(value):\n+            # exchange callable with result of calling it -- but only once! allow resolver to return a\n+            # callable itself\n+            value = value()\n+            self._resolved.add(key)\n+            self._raw_dict.__setitem__(key, value)\n+        return value\n+\n+    def __delitem__(self, key):\n+        with contextlib.suppress(KeyError):\n+            self._resolved.remove(key)\n+        self._raw_dict.__delitem__(key)\n+\n+    def __iter__(self):\n+        return iter(self._raw_dict)\n+\n+    def __len__(self):\n+        return len(self._raw_dict)\n+\n+    def __contains__(self, key):\n+        return key in self._raw_dict\n+\n+    def clear(self):\n+        self._resolved.clear()\n+        self._raw_dict.clear()\n+\n+\n+def _read_schema_from_resources_or_local_file(filename: str) -> dict:\n+    \"\"\"Read JSON schema from resources or local file.\"\"\"\n+    try:\n+        with resource_files(\"airflow\").joinpath(filename).open(\"rb\") as f:\n+            schema = json.load(f)\n+    except (TypeError, FileNotFoundError):\n+        with (pathlib.Path(__file__).parent / filename).open(\"rb\") as f:\n+            schema = json.load(f)\n+    return schema\n+\n+\n+def _create_provider_info_schema_validator():\n+    \"\"\"Create JSON schema validator from the provider_info.schema.json.\"\"\"\n+    import jsonschema\n+\n+    schema = _read_schema_from_resources_or_local_file(\"provider_info.schema.json\")\n+    cls = jsonschema.validators.validator_for(schema)\n+    validator = cls(schema)\n+    return validator\n+\n+\n+def _create_customized_form_field_behaviours_schema_validator():\n+    \"\"\"Create JSON schema validator from the customized_form_field_behaviours.schema.json.\"\"\"\n+    import jsonschema\n+\n+    schema = _read_schema_from_resources_or_local_file(\"customized_form_field_behaviours.schema.json\")\n+    cls = jsonschema.validators.validator_for(schema)\n+    validator = cls(schema)\n+    return validator\n+\n+\n+def _check_builtin_provider_prefix(provider_package: str, class_name: str) -> bool:\n+    \"\"\"Check if builtin provider class has correct prefix.\"\"\"\n+    if provider_package.startswith(\"apache-airflow\"):\n+        provider_path = provider_package[len(\"apache-\") :].replace(\"-\", \".\")\n+        if not class_name.startswith(provider_path):\n+            log.warning(\n+                \"Coherence check failed when importing '%s' from '%s' package. It should start with '%s'\",\n+                class_name,\n+                provider_package,\n+                provider_path,\n+            )\n+            return False\n+    return True\n+\n+\n+def _ensure_prefix_for_placeholders(field_behaviors: dict[str, Any], conn_type: str):\n+    \"\"\"\n+    Verify the correct placeholder prefix.\n+\n+    If the given field_behaviors dict contains a placeholder's node, and there\n+    are placeholders for extra fields (i.e. anything other than the built-in conn\n+    attrs), and if those extra fields are unprefixed, then add the prefix.\n+\n+    The reason we need to do this is, all custom conn fields live in the same dictionary,\n+    so we need to namespace them with a prefix internally.  But for user convenience,\n+    and consistency between the `get_ui_field_behaviour` method and the extra dict itself,\n+    we allow users to supply the unprefixed name.\n+    \"\"\"\n+    conn_attrs = {\"host\", \"schema\", \"login\", \"password\", \"port\", \"extra\"}\n+\n+    def ensure_prefix(field):\n+        if field not in conn_attrs and not field.startswith(\"extra__\"):\n+            return f\"extra__{conn_type}__{field}\"\n+        return field\n+\n+    if \"placeholders\" in field_behaviors:\n+        placeholders = field_behaviors[\"placeholders\"]\n+        field_behaviors[\"placeholders\"] = {ensure_prefix(k): v for k, v in placeholders.items()}\n+\n+    return field_behaviors\n+\n+\n+def log_optional_feature_disabled(class_name, e, provider_package):\n+    \"\"\"Log optional feature disabled.\"\"\"\n+    log.debug(\n+        \"Optional feature disabled on exception when importing '%s' from '%s' package\",\n+        class_name,\n+        provider_package,\n+        exc_info=e,\n+    )\n+    log.info(\n+        \"Optional provider feature disabled when importing '%s' from '%s' package\",\n+        class_name,\n+        provider_package,\n+    )\n+\n+\n+def log_import_warning(class_name, e, provider_package):\n+    \"\"\"Log import warning.\"\"\"\n+    log.warning(\n+        \"Exception when importing '%s' from '%s' package\",\n+        class_name,\n+        provider_package,\n+        exc_info=e,\n+    )\n+\n+\n+def provider_info_cache(cache_name: str) -> Callable[[Callable[PS, None]], Callable[PS, None]]:\n+    \"\"\"\n+    Decorate and cache provider info.\n+\n+    Decorator factory that create decorator that caches initialization of provider's parameters\n+    :param cache_name: Name of the cache\n+    \"\"\"\n+\n+    def provider_info_cache_decorator(func: Callable[PS, None]) -> Callable[PS, None]:\n+        @wraps(func)\n+        def wrapped_function(*args: PS.args, **kwargs: PS.kwargs) -> None:\n+            instance = args[0]\n+\n+            if cache_name in instance._initialized_cache:\n+                return\n+            start_time = perf_counter()\n+            log.debug(\"Initializing Provider Manager[%s]\", cache_name)\n+            func(*args, **kwargs)\n+            instance._initialized_cache[cache_name] = True\n+            log.debug(\n+                \"Initialization of Provider Manager[%s] took %.2f seconds\",\n+                cache_name,\n+                perf_counter() - start_time,\n+            )\n+\n+        return wrapped_function\n+\n+    return provider_info_cache_decorator\n+\n+\n+def discover_all_providers_from_packages(",
      "comment": "If I understand correct:\r\n\r\nWould it be better to replace `_discover_all_providers_from_packages` private method of core ProviderManager (https://github.com/apache/airflow/blob/5dcdccc3f507929192b033686f3c41d4b77a202d/airflow-core/src/airflow/providers_manager.py#L503-L504)\r\n\r\n with `discover_all_providers_from_packages(self._provider_dict, self._provider_schema_validator)` ?",
      "comment_id": 2693754531,
      "user": "jason810496",
      "created_at": "2026-01-15T10:06:39Z",
      "url": "https://github.com/apache/airflow/pull/60218#discussion_r2693754531"
    },
    {
      "repo": "apache/airflow",
      "pr_number": 60218,
      "file_path": "task-sdk/src/airflow/sdk/providers_manager_runtime.py",
      "line": 54,
      "side": "RIGHT",
      "diff_hunk": "@@ -0,0 +1,614 @@\n+#\n+# Licensed to the Apache Software Foundation (ASF) under one\n+# or more contributor license agreements.  See the NOTICE file\n+# distributed with this work for additional information\n+# regarding copyright ownership.  The ASF licenses this file\n+# to you under the Apache License, Version 2.0 (the\n+# \"License\"); you may not use this file except in compliance\n+# with the License.  You may obtain a copy of the License at\n+#\n+#   http://www.apache.org/licenses/LICENSE-2.0\n+#\n+# Unless required by applicable law or agreed to in writing,\n+# software distributed under the License is distributed on an\n+# \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+# KIND, either express or implied.  See the License for the\n+# specific language governing permissions and limitations\n+# under the License.\n+\"\"\"Manages runtime provider resources for task execution.\"\"\"\n+\n+from __future__ import annotations\n+\n+import functools\n+import inspect\n+import logging\n+import traceback\n+import warnings\n+from collections.abc import Callable, MutableMapping\n+from typing import TYPE_CHECKING, Any\n+from urllib.parse import SplitResult\n+\n+from airflow.sdk._shared.module_loading import import_string\n+from airflow.sdk._shared.providers_discovery import (\n+    KNOWN_UNHANDLED_OPTIONAL_FEATURE_ERRORS,\n+    HookClassProvider,\n+    HookInfo,\n+    LazyDictWithCache,\n+    PluginInfo,\n+    ProviderInfo,\n+    _check_builtin_provider_prefix,\n+    _create_provider_info_schema_validator,\n+    discover_all_providers_from_packages,\n+    log_import_warning,\n+    log_optional_feature_disabled,\n+    provider_info_cache,\n+)\n+from airflow.sdk.definitions._internal.logging_mixin import LoggingMixin\n+from airflow.sdk.exceptions import AirflowOptionalProviderFeatureException\n+\n+if TYPE_CHECKING:\n+    from airflow.sdk import BaseHook\n+    from airflow.sdk.bases.decorator import TaskDecorator\n+    from airflow.sdk.definitions.asset import Asset\n+\n+log = logging.getLogger(__name__)",
      "comment": "```suggestion\r\nlog = structlog.getLogger(__name__)\r\n```",
      "comment_id": 2693773347,
      "user": "jason810496",
      "created_at": "2026-01-15T10:12:24Z",
      "url": "https://github.com/apache/airflow/pull/60218#discussion_r2693773347"
    },
    {
      "repo": "apache/airflow",
      "pr_number": 60218,
      "file_path": "shared/providers_discovery/src/airflow_shared/providers_discovery/providers_discovery.py",
      "line": 37,
      "side": "RIGHT",
      "diff_hunk": "@@ -0,0 +1,348 @@\n+#\n+# Licensed to the Apache Software Foundation (ASF) under one\n+# or more contributor license agreements.  See the NOTICE file\n+# distributed with this work for additional information\n+# regarding copyright ownership.  The ASF licenses this file\n+# to you under the Apache License, Version 2.0 (the\n+# \"License\"); you may not use this file except in compliance\n+# with the License.  You may obtain a copy of the License at\n+#\n+#   http://www.apache.org/licenses/LICENSE-2.0\n+#\n+# Unless required by applicable law or agreed to in writing,\n+# software distributed under the License is distributed on an\n+# \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+# KIND, either express or implied.  See the License for the\n+# specific language governing permissions and limitations\n+# under the License.\n+\"\"\"Shared provider discovery utilities.\"\"\"\n+\n+from __future__ import annotations\n+\n+import contextlib\n+import json\n+import logging\n+import pathlib\n+from collections.abc import Callable, MutableMapping\n+from dataclasses import dataclass\n+from functools import wraps\n+from importlib.resources import files as resource_files\n+from time import perf_counter\n+from typing import Any, NamedTuple, ParamSpec\n+\n+from packaging.utils import canonicalize_name\n+\n+from ..module_loading import entry_points_with_dist\n+\n+log = logging.getLogger(__name__)",
      "comment": "```suggestion\r\nlog = structlog.getLogger(__name__)\r\n```",
      "comment_id": 2693775508,
      "user": "jason810496",
      "created_at": "2026-01-15T10:13:04Z",
      "url": "https://github.com/apache/airflow/pull/60218#discussion_r2693775508"
    },
    {
      "repo": "apache/airflow",
      "pr_number": 60218,
      "file_path": "task-sdk/src/airflow/sdk/providers_manager_runtime.py",
      "line": 530,
      "side": "RIGHT",
      "diff_hunk": "@@ -0,0 +1,614 @@\n+#\n+# Licensed to the Apache Software Foundation (ASF) under one\n+# or more contributor license agreements.  See the NOTICE file\n+# distributed with this work for additional information\n+# regarding copyright ownership.  The ASF licenses this file\n+# to you under the Apache License, Version 2.0 (the\n+# \"License\"); you may not use this file except in compliance\n+# with the License.  You may obtain a copy of the License at\n+#\n+#   http://www.apache.org/licenses/LICENSE-2.0\n+#\n+# Unless required by applicable law or agreed to in writing,\n+# software distributed under the License is distributed on an\n+# \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+# KIND, either express or implied.  See the License for the\n+# specific language governing permissions and limitations\n+# under the License.\n+\"\"\"Manages runtime provider resources for task execution.\"\"\"\n+\n+from __future__ import annotations\n+\n+import functools\n+import inspect\n+import logging\n+import traceback\n+import warnings\n+from collections.abc import Callable, MutableMapping\n+from typing import TYPE_CHECKING, Any\n+from urllib.parse import SplitResult\n+\n+from airflow.sdk._shared.module_loading import import_string\n+from airflow.sdk._shared.providers_discovery import (\n+    KNOWN_UNHANDLED_OPTIONAL_FEATURE_ERRORS,\n+    HookClassProvider,\n+    HookInfo,\n+    LazyDictWithCache,\n+    PluginInfo,\n+    ProviderInfo,\n+    _check_builtin_provider_prefix,\n+    _create_provider_info_schema_validator,\n+    discover_all_providers_from_packages,\n+    log_import_warning,\n+    log_optional_feature_disabled,\n+    provider_info_cache,\n+)\n+from airflow.sdk.definitions._internal.logging_mixin import LoggingMixin\n+from airflow.sdk.exceptions import AirflowOptionalProviderFeatureException\n+\n+if TYPE_CHECKING:\n+    from airflow.sdk import BaseHook\n+    from airflow.sdk.bases.decorator import TaskDecorator\n+    from airflow.sdk.definitions.asset import Asset\n+\n+log = logging.getLogger(__name__)\n+\n+\n+def _correctness_check(provider_package: str, class_name: str, provider_info: ProviderInfo) -> Any:\n+    \"\"\"\n+    Perform coherence check on provider classes.\n+\n+    For apache-airflow providers - it checks if it starts with appropriate package. For all providers\n+    it tries to import the provider - checking that there are no exceptions during importing.\n+    It logs appropriate warning in case it detects any problems.\n+\n+    :param provider_package: name of the provider package\n+    :param class_name: name of the class to import\n+\n+    :return the class if the class is OK, None otherwise.\n+    \"\"\"\n+    if not _check_builtin_provider_prefix(provider_package, class_name):\n+        return None\n+    try:\n+        imported_class = import_string(class_name)\n+    except AirflowOptionalProviderFeatureException as e:\n+        # When the provider class raises AirflowOptionalProviderFeatureException\n+        # this is an expected case when only some classes in provider are\n+        # available. We just log debug level here and print info message in logs so that\n+        # the user is aware of it\n+        log_optional_feature_disabled(class_name, e, provider_package)\n+        return None\n+    except ImportError as e:\n+        if \"No module named 'airflow.providers.\" in e.msg:\n+            # handle cases where another provider is missing. This can only happen if\n+            # there is an optional feature, so we log debug and print information about it\n+            log_optional_feature_disabled(class_name, e, provider_package)\n+            return None\n+        for known_error in KNOWN_UNHANDLED_OPTIONAL_FEATURE_ERRORS:\n+            # Until we convert all providers to use AirflowOptionalProviderFeatureException\n+            # we assume any problem with importing another \"provider\" is because this is an\n+            # optional feature, so we log debug and print information about it\n+            if known_error[0] == provider_package and known_error[1] in e.msg:\n+                log_optional_feature_disabled(class_name, e, provider_package)\n+                return None\n+        # But when we have no idea - we print warning to logs\n+        log_import_warning(class_name, e, provider_package)\n+        return None\n+    except Exception as e:\n+        log_import_warning(class_name, e, provider_package)\n+        return None\n+    return imported_class\n+\n+\n+class ProvidersManagerRuntime(LoggingMixin):\n+    \"\"\"\n+    Manages runtime provider resources for task execution.\n+\n+    This is a Singleton class. The first time it is instantiated, it discovers all available\n+    runtime provider resources (hooks, taskflow decorators, filesystems, asset handlers).\n+    \"\"\"\n+\n+    resource_version = \"0\"\n+    _initialized: bool = False\n+    _initialization_stack_trace = None\n+    _instance: ProvidersManagerRuntime | None = None\n+\n+    def __new__(cls):\n+        if cls._instance is None:\n+            cls._instance = super().__new__(cls)\n+        return cls._instance\n+\n+    @staticmethod\n+    def initialized() -> bool:\n+        return ProvidersManagerRuntime._initialized\n+\n+    @staticmethod\n+    def initialization_stack_trace() -> str | None:\n+        return ProvidersManagerRuntime._initialization_stack_trace\n+\n+    def __init__(self):\n+        \"\"\"Initialize the runtime manager.\"\"\"\n+        # skip initialization if already initialized\n+        if self.initialized():\n+            return\n+        super().__init__()\n+        ProvidersManagerRuntime._initialized = True\n+        ProvidersManagerRuntime._initialization_stack_trace = \"\".join(\n+            traceback.format_stack(inspect.currentframe())\n+        )\n+        self._initialized_cache: dict[str, bool] = {}\n+        # Keeps dict of providers keyed by module name\n+        self._provider_dict: dict[str, ProviderInfo] = {}\n+        self._fs_set: set[str] = set()\n+        self._asset_uri_handlers: dict[str, Callable[[SplitResult], SplitResult]] = {}\n+        self._asset_factories: dict[str, Callable[..., Asset]] = {}\n+        self._asset_to_openlineage_converters: dict[str, Callable] = {}\n+        self._taskflow_decorators: dict[str, Callable] = LazyDictWithCache()\n+        # keeps mapping between connection_types and hook class, package they come from\n+        self._hook_provider_dict: dict[str, HookClassProvider] = {}\n+        # Keeps dict of hooks keyed by connection type. They are lazy evaluated at access time\n+        self._hooks_lazy_dict: LazyDictWithCache[str, HookInfo | Callable] = LazyDictWithCache()\n+        self._plugins_set: set[PluginInfo] = set()\n+        self._provider_schema_validator = _create_provider_info_schema_validator()\n+        self._init_airflow_core_hooks()\n+\n+    def _init_airflow_core_hooks(self):\n+        \"\"\"Initialize the hooks dict with default hooks from Airflow core.\"\"\"\n+        core_dummy_hooks = {\n+            \"generic\": \"Generic\",\n+            \"email\": \"Email\",\n+        }\n+        for key, display in core_dummy_hooks.items():\n+            self._hooks_lazy_dict[key] = HookInfo(\n+                hook_class_name=None,\n+                connection_id_attribute_name=None,\n+                package_name=None,\n+                hook_name=display,\n+                connection_type=None,\n+                connection_testable=False,\n+            )\n+        for conn_type, class_name in (\n+            (\"fs\", \"airflow.providers.standard.hooks.filesystem.FSHook\"),\n+            (\"package_index\", \"airflow.providers.standard.hooks.package_index.PackageIndexHook\"),\n+        ):\n+            self._hooks_lazy_dict[conn_type] = functools.partial(\n+                self._import_hook,\n+                connection_type=None,\n+                package_name=\"apache-airflow-providers-standard\",\n+                hook_class_name=class_name,\n+                provider_info=None,\n+            )\n+\n+    @provider_info_cache(\"list\")\n+    def initialize_providers_list(self):\n+        \"\"\"Lazy initialization of providers list.\"\"\"\n+        discover_all_providers_from_packages(self._provider_dict, self._provider_schema_validator)\n+        self._provider_dict = dict(sorted(self._provider_dict.items()))\n+\n+    @provider_info_cache(\"hooks\")\n+    def initialize_providers_hooks(self):\n+        \"\"\"Lazy initialization of providers hooks.\"\"\"\n+        self._init_airflow_core_hooks()\n+        self.initialize_providers_list()\n+        self._discover_hooks()\n+        self._hook_provider_dict = dict(sorted(self._hook_provider_dict.items()))\n+\n+    @provider_info_cache(\"filesystems\")\n+    def initialize_providers_filesystems(self):\n+        \"\"\"Lazy initialization of providers filesystems.\"\"\"\n+        self.initialize_providers_list()\n+        self._discover_filesystems()\n+\n+    @provider_info_cache(\"asset_uris\")\n+    def initialize_providers_asset_uri_resources(self):\n+        \"\"\"Lazy initialization of provider asset URI handlers, factories, converters etc.\"\"\"\n+        self.initialize_providers_list()\n+        self._discover_asset_uri_resources()\n+\n+    @provider_info_cache(\"plugins\")\n+    def initialize_providers_plugins(self):\n+        \"\"\"Lazy initialization of providers plugins.\"\"\"\n+        self.initialize_providers_list()\n+        self._discover_plugins()\n+\n+    @provider_info_cache(\"taskflow_decorators\")\n+    def initialize_providers_taskflow_decorator(self):\n+        \"\"\"Lazy initialization of providers taskflow decorators.\"\"\"\n+        self.initialize_providers_list()\n+        self._discover_taskflow_decorators()\n+\n+    def _discover_hooks_from_connection_types(\n+        self,\n+        hook_class_names_registered: set[str],\n+        already_registered_warning_connection_types: set[str],\n+        package_name: str,\n+        provider: ProviderInfo,\n+    ):\n+        \"\"\"\n+        Discover hooks from the \"connection-types\" property.\n+\n+        This is new, better method that replaces discovery from hook-class-names as it\n+        allows to lazy import individual Hook classes when they are accessed.\n+        The \"connection-types\" keeps information about both - connection type and class\n+        name so we can discover all connection-types without importing the classes.\n+        :param hook_class_names_registered: set of registered hook class names for this provider\n+        :param already_registered_warning_connection_types: set of connections for which warning should be\n+            printed in logs as they were already registered before\n+        :param package_name:\n+        :param provider:\n+        :return:\n+        \"\"\"\n+        provider_uses_connection_types = False\n+        connection_types = provider.data.get(\"connection-types\")\n+        if connection_types:\n+            for connection_type_dict in connection_types:\n+                connection_type = connection_type_dict[\"connection-type\"]\n+                hook_class_name = connection_type_dict[\"hook-class-name\"]\n+                hook_class_names_registered.add(hook_class_name)\n+                already_registered = self._hook_provider_dict.get(connection_type)\n+                if already_registered:\n+                    if already_registered.package_name != package_name:\n+                        already_registered_warning_connection_types.add(connection_type)\n+                    else:\n+                        log.warning(\n+                            \"The connection type '%s' is already registered in the\"\n+                            \" package '%s' with different class names: '%s' and '%s'. \",\n+                            connection_type,\n+                            package_name,\n+                            already_registered.hook_class_name,\n+                            hook_class_name,\n+                        )\n+                else:\n+                    self._hook_provider_dict[connection_type] = HookClassProvider(\n+                        hook_class_name=hook_class_name, package_name=package_name\n+                    )\n+                    # Defer importing hook to access time by setting import hook method as dict value\n+                    self._hooks_lazy_dict[connection_type] = functools.partial(\n+                        self._import_hook,\n+                        connection_type=connection_type,\n+                        provider_info=provider,\n+                    )\n+            provider_uses_connection_types = True\n+        return provider_uses_connection_types\n+\n+    def _discover_hooks_from_hook_class_names(\n+        self,\n+        hook_class_names_registered: set[str],\n+        already_registered_warning_connection_types: set[str],\n+        package_name: str,\n+        provider: ProviderInfo,\n+        provider_uses_connection_types: bool,\n+    ):\n+        \"\"\"\n+        Discover hooks from \"hook-class-names' property.\n+\n+        This property is deprecated but we should support it in Airflow 2.\n+        The hook-class-names array contained just Hook names without connection type,\n+        therefore we need to import all those classes immediately to know which connection types\n+        are supported. This makes it impossible to selectively only import those hooks that are used.\n+        :param already_registered_warning_connection_types: list of connection hooks that we should warn\n+            about when finished discovery\n+        :param package_name: name of the provider package\n+        :param provider: class that keeps information about version and details of the provider\n+        :param provider_uses_connection_types: determines whether the provider uses \"connection-types\" new\n+           form of passing connection types\n+        :return:\n+        \"\"\"\n+        hook_class_names = provider.data.get(\"hook-class-names\")\n+        if hook_class_names:\n+            for hook_class_name in hook_class_names:\n+                if hook_class_name in hook_class_names_registered:\n+                    # Silently ignore the hook class - it's already marked for lazy-import by\n+                    # connection-types discovery\n+                    continue\n+                hook_info = self._import_hook(\n+                    connection_type=None,\n+                    provider_info=provider,\n+                    hook_class_name=hook_class_name,\n+                    package_name=package_name,\n+                )\n+                if not hook_info:\n+                    # Problem why importing class - we ignore it. Log is written at import time\n+                    continue\n+                already_registered = self._hook_provider_dict.get(hook_info.connection_type)\n+                if already_registered:\n+                    if already_registered.package_name != package_name:\n+                        already_registered_warning_connection_types.add(hook_info.connection_type)\n+                    else:\n+                        if already_registered.hook_class_name != hook_class_name:\n+                            log.warning(\n+                                \"The hook connection type '%s' is registered twice in the\"\n+                                \" package '%s' with different class names: '%s' and '%s'. \"\n+                                \" Please fix it!\",\n+                                hook_info.connection_type,\n+                                package_name,\n+                                already_registered.hook_class_name,\n+                                hook_class_name,\n+                            )\n+                else:\n+                    self._hook_provider_dict[hook_info.connection_type] = HookClassProvider(\n+                        hook_class_name=hook_class_name, package_name=package_name\n+                    )\n+                    self._hooks_lazy_dict[hook_info.connection_type] = hook_info\n+\n+            if not provider_uses_connection_types:\n+                warnings.warn(\n+                    f\"The provider {package_name} uses `hook-class-names` \"\n+                    \"property in provider-info and has no `connection-types` one. \"\n+                    \"The 'hook-class-names' property has been deprecated in favour \"\n+                    \"of 'connection-types' in Airflow 2.2. Use **both** in case you want to \"\n+                    \"have backwards compatibility with Airflow < 2.2\",\n+                    DeprecationWarning,\n+                    stacklevel=1,\n+                )\n+        for already_registered_connection_type in already_registered_warning_connection_types:\n+            log.warning(\n+                \"The connection_type '%s' has been already registered by provider '%s.'\",\n+                already_registered_connection_type,\n+                self._hook_provider_dict[already_registered_connection_type].package_name,\n+            )\n+\n+    def _discover_hooks(self) -> None:\n+        \"\"\"Retrieve all connections defined in the providers via Hooks.\"\"\"\n+        for package_name, provider in self._provider_dict.items():\n+            duplicated_connection_types: set[str] = set()\n+            hook_class_names_registered: set[str] = set()\n+            provider_uses_connection_types = self._discover_hooks_from_connection_types(\n+                hook_class_names_registered, duplicated_connection_types, package_name, provider\n+            )\n+            self._discover_hooks_from_hook_class_names(\n+                hook_class_names_registered,\n+                duplicated_connection_types,\n+                package_name,\n+                provider,\n+                provider_uses_connection_types,\n+            )\n+        self._hook_provider_dict = dict(sorted(self._hook_provider_dict.items()))\n+\n+    @staticmethod\n+    def _get_attr(obj: Any, attr_name: str):\n+        \"\"\"Retrieve attributes of an object, or warn if not found.\"\"\"\n+        if not hasattr(obj, attr_name):\n+            log.warning(\"The object '%s' is missing %s attribute and cannot be registered\", obj, attr_name)\n+            return None\n+        return getattr(obj, attr_name)\n+\n+    def _import_hook(\n+        self,\n+        connection_type: str | None,\n+        provider_info: ProviderInfo,\n+        hook_class_name: str | None = None,\n+        package_name: str | None = None,\n+    ) -> HookInfo | None:\n+        \"\"\"\n+        Import hook and retrieve hook information.\n+\n+        Either connection_type (for lazy loading) or hook_class_name must be set - but not both).\n+        Only needs package_name if hook_class_name is passed (for lazy loading, package_name\n+        is retrieved from _connection_type_class_provider_dict together with hook_class_name).\n+\n+        :param connection_type: type of the connection\n+        :param hook_class_name: name of the hook class\n+        :param package_name: provider package - only needed in case connection_type is missing\n+        : return\n+        \"\"\"\n+        if connection_type is None and hook_class_name is None:\n+            raise ValueError(\"Either connection_type or hook_class_name must be set\")\n+        if connection_type is not None and hook_class_name is not None:\n+            raise ValueError(\n+                f\"Both connection_type ({connection_type} and \"\n+                f\"hook_class_name {hook_class_name} are set. Only one should be set!\"\n+            )\n+        if connection_type is not None:\n+            class_provider = self._hook_provider_dict[connection_type]\n+            package_name = class_provider.package_name\n+            hook_class_name = class_provider.hook_class_name\n+        else:\n+            if not hook_class_name:\n+                raise ValueError(\"Either connection_type or hook_class_name must be set\")\n+            if not package_name:\n+                raise ValueError(\n+                    f\"Provider package name is not set when hook_class_name ({hook_class_name}) is used\"\n+                )\n+        hook_class: type[BaseHook] | None = _correctness_check(package_name, hook_class_name, provider_info)\n+        if hook_class is None:\n+            return None\n+\n+        hook_connection_type = self._get_attr(hook_class, \"conn_type\")\n+        if connection_type:\n+            if hook_connection_type != connection_type:\n+                log.warning(\n+                    \"Inconsistency! The hook class '%s' declares connection type '%s'\"\n+                    \" but it is added by provider '%s' as connection_type '%s' in provider info. \"\n+                    \"This should be fixed!\",\n+                    hook_class,\n+                    hook_connection_type,\n+                    package_name,\n+                    connection_type,\n+                )\n+        connection_type = hook_connection_type\n+        connection_id_attribute_name: str = self._get_attr(hook_class, \"conn_name_attr\")\n+        hook_name: str = self._get_attr(hook_class, \"hook_name\")\n+\n+        if not connection_type or not connection_id_attribute_name or not hook_name:\n+            log.warning(\n+                \"The hook misses one of the key attributes: \"\n+                \"conn_type: %s, conn_id_attribute_name: %s, hook_name: %s\",\n+                connection_type,\n+                connection_id_attribute_name,\n+                hook_name,\n+            )\n+            return None\n+\n+        return HookInfo(\n+            hook_class_name=hook_class_name,\n+            connection_id_attribute_name=connection_id_attribute_name,\n+            package_name=package_name,\n+            hook_name=hook_name,\n+            connection_type=connection_type,\n+            connection_testable=hasattr(hook_class, \"test_connection\"),\n+        )\n+\n+    def _discover_filesystems(self) -> None:\n+        \"\"\"Retrieve all filesystems defined in the providers.\"\"\"\n+        for provider_package, provider in self._provider_dict.items():\n+            for fs_module_name in provider.data.get(\"filesystems\", []):\n+                if _correctness_check(provider_package, f\"{fs_module_name}.get_fs\", provider):\n+                    self._fs_set.add(fs_module_name)\n+        self._fs_set = set(sorted(self._fs_set))\n+\n+    def _discover_asset_uri_resources(self) -> None:\n+        \"\"\"Discovers and registers asset URI handlers, factories, and converters for all providers.\"\"\"\n+        from airflow.sdk.definitions.asset import normalize_noop\n+\n+        def _safe_register_resource(\n+            provider_package_name: str,\n+            schemes_list: list[str],\n+            resource_path: str | None,\n+            resource_registry: dict,\n+            default_resource: Any = None,\n+        ):\n+            \"\"\"\n+            Register a specific resource (handler, factory, or converter) for the given schemes.\n+\n+            If the resolved resource (either from the path or the default) is valid, it updates\n+            the resource registry with the appropriate resource for each scheme.\n+            \"\"\"\n+            resource = (\n+                _correctness_check(provider_package_name, resource_path, provider)\n+                if resource_path is not None\n+                else default_resource\n+            )\n+            if resource:\n+                resource_registry.update((scheme, resource) for scheme in schemes_list)\n+\n+        for provider_name, provider in self._provider_dict.items():\n+            for uri_info in provider.data.get(\"asset-uris\", []):\n+                if \"schemes\" not in uri_info or \"handler\" not in uri_info:\n+                    continue  # Both schemas and handler must be explicitly set, handler can be set to null\n+                common_args = {\"schemes_list\": uri_info[\"schemes\"], \"provider_package_name\": provider_name}\n+                _safe_register_resource(\n+                    resource_path=uri_info[\"handler\"],\n+                    resource_registry=self._asset_uri_handlers,\n+                    default_resource=normalize_noop,\n+                    **common_args,\n+                )\n+                _safe_register_resource(\n+                    resource_path=uri_info.get(\"factory\"),\n+                    resource_registry=self._asset_factories,\n+                    **common_args,\n+                )\n+                _safe_register_resource(\n+                    resource_path=uri_info.get(\"to_openlineage_converter\"),\n+                    resource_registry=self._asset_to_openlineage_converters,\n+                    **common_args,\n+                )\n+\n+    def _discover_plugins(self) -> None:\n+        \"\"\"Retrieve all plugins defined in the providers.\"\"\"\n+        for provider_package, provider in self._provider_dict.items():\n+            for plugin_dict in provider.data.get(\"plugins\", ()):\n+                if not _correctness_check(provider_package, plugin_dict[\"plugin-class\"], provider):\n+                    log.warning(\"Plugin not loaded due to above correctness check problem.\")\n+                    continue\n+                self._plugins_set.add(\n+                    PluginInfo(\n+                        name=plugin_dict[\"name\"],\n+                        plugin_class=plugin_dict[\"plugin-class\"],\n+                        provider_name=provider_package,\n+                    )\n+                )\n+\n+    def _discover_taskflow_decorators(self) -> None:\n+        for name, info in self._provider_dict.items():\n+            for taskflow_decorator in info.data.get(\"task-decorators\", []):\n+                self._add_taskflow_decorator(\n+                    taskflow_decorator[\"name\"], taskflow_decorator[\"class-name\"], name\n+                )\n+\n+    def _add_taskflow_decorator(self, name, decorator_class_name: str, provider_package: str) -> None:\n+        from airflow._shared.providers_discovery import _check_builtin_provider_prefix",
      "comment": "I just double checked that `_check_builtin_provider_prefix` function is already imported on top level.",
      "comment_id": 2693786801,
      "user": "jason810496",
      "created_at": "2026-01-15T10:16:31Z",
      "url": "https://github.com/apache/airflow/pull/60218#discussion_r2693786801"
    },
    {
      "repo": "apache/airflow",
      "pr_number": 60218,
      "file_path": "airflow-core/src/airflow/providers_manager.py",
      "line": 453,
      "side": "RIGHT",
      "diff_hunk": "@@ -438,6 +439,33 @@ def __init__(self):\n         self._plugins_set: set[PluginInfo] = set()\n         self._init_airflow_core_hooks()\n \n+        self._runtime_manager = None\n+\n+    def __getattribute__(self, name: str):\n+        # Hacky but does the trick for now\n+        runtime_properties = {\n+            \"hooks\",\n+            \"taskflow_decorators\",\n+            \"filesystem_module_names\",\n+            \"asset_factories\",\n+            \"asset_uri_handlers\",\n+            \"asset_to_openlineage_converters\",\n+        }",
      "comment": "That's true, but I didn't want to change a lot on that front and would rather handle it when I am getting rid of this compat shim",
      "comment_id": 2694065523,
      "user": "amoghrajesh",
      "created_at": "2026-01-15T11:44:30Z",
      "url": "https://github.com/apache/airflow/pull/60218#discussion_r2694065523"
    },
    {
      "repo": "apache/airflow",
      "pr_number": 60218,
      "file_path": "shared/providers_discovery/src/airflow_shared/providers_discovery/providers_discovery.py",
      "line": 293,
      "side": "RIGHT",
      "diff_hunk": "@@ -0,0 +1,348 @@\n+#\n+# Licensed to the Apache Software Foundation (ASF) under one\n+# or more contributor license agreements.  See the NOTICE file\n+# distributed with this work for additional information\n+# regarding copyright ownership.  The ASF licenses this file\n+# to you under the Apache License, Version 2.0 (the\n+# \"License\"); you may not use this file except in compliance\n+# with the License.  You may obtain a copy of the License at\n+#\n+#   http://www.apache.org/licenses/LICENSE-2.0\n+#\n+# Unless required by applicable law or agreed to in writing,\n+# software distributed under the License is distributed on an\n+# \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+# KIND, either express or implied.  See the License for the\n+# specific language governing permissions and limitations\n+# under the License.\n+\"\"\"Shared provider discovery utilities.\"\"\"\n+\n+from __future__ import annotations\n+\n+import contextlib\n+import json\n+import logging\n+import pathlib\n+from collections.abc import Callable, MutableMapping\n+from dataclasses import dataclass\n+from functools import wraps\n+from importlib.resources import files as resource_files\n+from time import perf_counter\n+from typing import Any, NamedTuple, ParamSpec\n+\n+from packaging.utils import canonicalize_name\n+\n+from ..module_loading import entry_points_with_dist\n+\n+log = logging.getLogger(__name__)\n+\n+\n+PS = ParamSpec(\"PS\")\n+\n+\n+KNOWN_UNHANDLED_OPTIONAL_FEATURE_ERRORS = [(\"apache-airflow-providers-google\", \"No module named 'paramiko'\")]\n+\n+\n+@dataclass\n+class ProviderInfo:\n+    \"\"\"\n+    Provider information.\n+\n+    :param version: version string\n+    :param data: dictionary with information about the provider\n+    \"\"\"\n+\n+    version: str\n+    data: dict\n+\n+\n+class HookClassProvider(NamedTuple):\n+    \"\"\"Hook class and Provider it comes from.\"\"\"\n+\n+    hook_class_name: str\n+    package_name: str\n+\n+\n+class HookInfo(NamedTuple):\n+    \"\"\"Hook information.\"\"\"\n+\n+    hook_class_name: str\n+    connection_id_attribute_name: str\n+    package_name: str\n+    hook_name: str\n+    connection_type: str\n+    connection_testable: bool\n+    dialects: list[str] = []\n+\n+\n+class ConnectionFormWidgetInfo(NamedTuple):\n+    \"\"\"Connection Form Widget information.\"\"\"\n+\n+    hook_class_name: str\n+    package_name: str\n+    field: Any\n+    field_name: str\n+    is_sensitive: bool\n+\n+\n+class PluginInfo(NamedTuple):\n+    \"\"\"Plugin class, name and provider it comes from.\"\"\"\n+\n+    name: str\n+    plugin_class: str\n+    provider_name: str\n+\n+\n+class NotificationInfo(NamedTuple):\n+    \"\"\"Notification class and provider it comes from.\"\"\"\n+\n+    notification_class_name: str\n+    package_name: str\n+\n+\n+class TriggerInfo(NamedTuple):\n+    \"\"\"Trigger class and provider it comes from.\"\"\"\n+\n+    trigger_class_name: str\n+    package_name: str\n+    integration_name: str\n+\n+\n+class DialectInfo(NamedTuple):\n+    \"\"\"Dialect class and Provider it comes from.\"\"\"\n+\n+    name: str\n+    dialect_class_name: str\n+    provider_name: str\n+\n+\n+class LazyDictWithCache(MutableMapping):\n+    \"\"\"\n+    Lazy-loaded cached dictionary.\n+\n+    Dictionary, which in case you set callable, executes the passed callable with `key` attribute\n+    at first use - and returns and caches the result.\n+    \"\"\"\n+\n+    __slots__ = [\"_resolved\", \"_raw_dict\"]\n+\n+    def __init__(self, *args, **kw):\n+        self._resolved = set()\n+        self._raw_dict = dict(*args, **kw)\n+\n+    def __setitem__(self, key, value):\n+        self._raw_dict.__setitem__(key, value)\n+\n+    def __getitem__(self, key):\n+        value = self._raw_dict.__getitem__(key)\n+        if key not in self._resolved and callable(value):\n+            # exchange callable with result of calling it -- but only once! allow resolver to return a\n+            # callable itself\n+            value = value()\n+            self._resolved.add(key)\n+            self._raw_dict.__setitem__(key, value)\n+        return value\n+\n+    def __delitem__(self, key):\n+        with contextlib.suppress(KeyError):\n+            self._resolved.remove(key)\n+        self._raw_dict.__delitem__(key)\n+\n+    def __iter__(self):\n+        return iter(self._raw_dict)\n+\n+    def __len__(self):\n+        return len(self._raw_dict)\n+\n+    def __contains__(self, key):\n+        return key in self._raw_dict\n+\n+    def clear(self):\n+        self._resolved.clear()\n+        self._raw_dict.clear()\n+\n+\n+def _read_schema_from_resources_or_local_file(filename: str) -> dict:\n+    \"\"\"Read JSON schema from resources or local file.\"\"\"\n+    try:\n+        with resource_files(\"airflow\").joinpath(filename).open(\"rb\") as f:\n+            schema = json.load(f)\n+    except (TypeError, FileNotFoundError):\n+        with (pathlib.Path(__file__).parent / filename).open(\"rb\") as f:\n+            schema = json.load(f)\n+    return schema\n+\n+\n+def _create_provider_info_schema_validator():\n+    \"\"\"Create JSON schema validator from the provider_info.schema.json.\"\"\"\n+    import jsonschema\n+\n+    schema = _read_schema_from_resources_or_local_file(\"provider_info.schema.json\")\n+    cls = jsonschema.validators.validator_for(schema)\n+    validator = cls(schema)\n+    return validator\n+\n+\n+def _create_customized_form_field_behaviours_schema_validator():\n+    \"\"\"Create JSON schema validator from the customized_form_field_behaviours.schema.json.\"\"\"\n+    import jsonschema\n+\n+    schema = _read_schema_from_resources_or_local_file(\"customized_form_field_behaviours.schema.json\")\n+    cls = jsonschema.validators.validator_for(schema)\n+    validator = cls(schema)\n+    return validator\n+\n+\n+def _check_builtin_provider_prefix(provider_package: str, class_name: str) -> bool:\n+    \"\"\"Check if builtin provider class has correct prefix.\"\"\"\n+    if provider_package.startswith(\"apache-airflow\"):\n+        provider_path = provider_package[len(\"apache-\") :].replace(\"-\", \".\")\n+        if not class_name.startswith(provider_path):\n+            log.warning(\n+                \"Coherence check failed when importing '%s' from '%s' package. It should start with '%s'\",\n+                class_name,\n+                provider_package,\n+                provider_path,\n+            )\n+            return False\n+    return True\n+\n+\n+def _ensure_prefix_for_placeholders(field_behaviors: dict[str, Any], conn_type: str):\n+    \"\"\"\n+    Verify the correct placeholder prefix.\n+\n+    If the given field_behaviors dict contains a placeholder's node, and there\n+    are placeholders for extra fields (i.e. anything other than the built-in conn\n+    attrs), and if those extra fields are unprefixed, then add the prefix.\n+\n+    The reason we need to do this is, all custom conn fields live in the same dictionary,\n+    so we need to namespace them with a prefix internally.  But for user convenience,\n+    and consistency between the `get_ui_field_behaviour` method and the extra dict itself,\n+    we allow users to supply the unprefixed name.\n+    \"\"\"\n+    conn_attrs = {\"host\", \"schema\", \"login\", \"password\", \"port\", \"extra\"}\n+\n+    def ensure_prefix(field):\n+        if field not in conn_attrs and not field.startswith(\"extra__\"):\n+            return f\"extra__{conn_type}__{field}\"\n+        return field\n+\n+    if \"placeholders\" in field_behaviors:\n+        placeholders = field_behaviors[\"placeholders\"]\n+        field_behaviors[\"placeholders\"] = {ensure_prefix(k): v for k, v in placeholders.items()}\n+\n+    return field_behaviors\n+\n+\n+def log_optional_feature_disabled(class_name, e, provider_package):\n+    \"\"\"Log optional feature disabled.\"\"\"\n+    log.debug(\n+        \"Optional feature disabled on exception when importing '%s' from '%s' package\",\n+        class_name,\n+        provider_package,\n+        exc_info=e,\n+    )\n+    log.info(\n+        \"Optional provider feature disabled when importing '%s' from '%s' package\",\n+        class_name,\n+        provider_package,\n+    )\n+\n+\n+def log_import_warning(class_name, e, provider_package):\n+    \"\"\"Log import warning.\"\"\"\n+    log.warning(\n+        \"Exception when importing '%s' from '%s' package\",\n+        class_name,\n+        provider_package,\n+        exc_info=e,\n+    )\n+\n+\n+def provider_info_cache(cache_name: str) -> Callable[[Callable[PS, None]], Callable[PS, None]]:\n+    \"\"\"\n+    Decorate and cache provider info.\n+\n+    Decorator factory that create decorator that caches initialization of provider's parameters\n+    :param cache_name: Name of the cache\n+    \"\"\"\n+\n+    def provider_info_cache_decorator(func: Callable[PS, None]) -> Callable[PS, None]:\n+        @wraps(func)\n+        def wrapped_function(*args: PS.args, **kwargs: PS.kwargs) -> None:\n+            instance = args[0]\n+\n+            if cache_name in instance._initialized_cache:\n+                return\n+            start_time = perf_counter()\n+            log.debug(\"Initializing Provider Manager[%s]\", cache_name)\n+            func(*args, **kwargs)\n+            instance._initialized_cache[cache_name] = True\n+            log.debug(\n+                \"Initialization of Provider Manager[%s] took %.2f seconds\",\n+                cache_name,\n+                perf_counter() - start_time,\n+            )\n+\n+        return wrapped_function\n+\n+    return provider_info_cache_decorator\n+\n+\n+def discover_all_providers_from_packages(",
      "comment": "Oh I think I had misundertood kaxil's comments. Yeah that makes sense.",
      "comment_id": 2694078825,
      "user": "amoghrajesh",
      "created_at": "2026-01-15T11:49:20Z",
      "url": "https://github.com/apache/airflow/pull/60218#discussion_r2694078825"
    },
    {
      "repo": "apache/airflow",
      "pr_number": 60218,
      "file_path": "task-sdk/src/airflow/sdk/providers_manager_runtime.py",
      "line": 24,
      "side": "RIGHT",
      "diff_hunk": "@@ -0,0 +1,614 @@\n+#\n+# Licensed to the Apache Software Foundation (ASF) under one\n+# or more contributor license agreements.  See the NOTICE file\n+# distributed with this work for additional information\n+# regarding copyright ownership.  The ASF licenses this file\n+# to you under the Apache License, Version 2.0 (the\n+# \"License\"); you may not use this file except in compliance\n+# with the License.  You may obtain a copy of the License at\n+#\n+#   http://www.apache.org/licenses/LICENSE-2.0\n+#\n+# Unless required by applicable law or agreed to in writing,\n+# software distributed under the License is distributed on an\n+# \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+# KIND, either express or implied.  See the License for the\n+# specific language governing permissions and limitations\n+# under the License.\n+\"\"\"Manages runtime provider resources for task execution.\"\"\"\n+\n+from __future__ import annotations\n+\n+import functools\n+import inspect\n+import logging",
      "comment": "Handled in https://github.com/apache/airflow/commit/b285dcda7e6d4a699cedc5c963f3e03a9a969cfe",
      "comment_id": 2694088227,
      "user": "amoghrajesh",
      "created_at": "2026-01-15T11:52:32Z",
      "url": "https://github.com/apache/airflow/pull/60218#discussion_r2694088227"
    },
    {
      "repo": "apache/airflow",
      "pr_number": 60218,
      "file_path": "shared/providers_discovery/src/airflow_shared/providers_discovery/providers_discovery.py",
      "line": 24,
      "side": "RIGHT",
      "diff_hunk": "@@ -0,0 +1,348 @@\n+#\n+# Licensed to the Apache Software Foundation (ASF) under one\n+# or more contributor license agreements.  See the NOTICE file\n+# distributed with this work for additional information\n+# regarding copyright ownership.  The ASF licenses this file\n+# to you under the Apache License, Version 2.0 (the\n+# \"License\"); you may not use this file except in compliance\n+# with the License.  You may obtain a copy of the License at\n+#\n+#   http://www.apache.org/licenses/LICENSE-2.0\n+#\n+# Unless required by applicable law or agreed to in writing,\n+# software distributed under the License is distributed on an\n+# \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+# KIND, either express or implied.  See the License for the\n+# specific language governing permissions and limitations\n+# under the License.\n+\"\"\"Shared provider discovery utilities.\"\"\"\n+\n+from __future__ import annotations\n+\n+import contextlib\n+import json\n+import logging",
      "comment": "Handled in https://github.com/apache/airflow/commit/b285dcda7e6d4a699cedc5c963f3e03a9a969cfe",
      "comment_id": 2694088519,
      "user": "amoghrajesh",
      "created_at": "2026-01-15T11:52:39Z",
      "url": "https://github.com/apache/airflow/pull/60218#discussion_r2694088519"
    },
    {
      "repo": "apache/airflow",
      "pr_number": 60218,
      "file_path": "shared/providers_discovery/src/airflow_shared/providers_discovery/providers_discovery.py",
      "line": 37,
      "side": "RIGHT",
      "diff_hunk": "@@ -0,0 +1,348 @@\n+#\n+# Licensed to the Apache Software Foundation (ASF) under one\n+# or more contributor license agreements.  See the NOTICE file\n+# distributed with this work for additional information\n+# regarding copyright ownership.  The ASF licenses this file\n+# to you under the Apache License, Version 2.0 (the\n+# \"License\"); you may not use this file except in compliance\n+# with the License.  You may obtain a copy of the License at\n+#\n+#   http://www.apache.org/licenses/LICENSE-2.0\n+#\n+# Unless required by applicable law or agreed to in writing,\n+# software distributed under the License is distributed on an\n+# \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+# KIND, either express or implied.  See the License for the\n+# specific language governing permissions and limitations\n+# under the License.\n+\"\"\"Shared provider discovery utilities.\"\"\"\n+\n+from __future__ import annotations\n+\n+import contextlib\n+import json\n+import logging\n+import pathlib\n+from collections.abc import Callable, MutableMapping\n+from dataclasses import dataclass\n+from functools import wraps\n+from importlib.resources import files as resource_files\n+from time import perf_counter\n+from typing import Any, NamedTuple, ParamSpec\n+\n+from packaging.utils import canonicalize_name\n+\n+from ..module_loading import entry_points_with_dist\n+\n+log = logging.getLogger(__name__)",
      "comment": "Handled in https://github.com/apache/airflow/commit/b285dcda7e6d4a699cedc5c963f3e03a9a969cfe",
      "comment_id": 2694088773,
      "user": "amoghrajesh",
      "created_at": "2026-01-15T11:52:44Z",
      "url": "https://github.com/apache/airflow/pull/60218#discussion_r2694088773"
    },
    {
      "repo": "apache/airflow",
      "pr_number": 60218,
      "file_path": "airflow-core/src/airflow/providers_manager.py",
      "line": 453,
      "side": "RIGHT",
      "diff_hunk": "@@ -438,6 +439,33 @@ def __init__(self):\n         self._plugins_set: set[PluginInfo] = set()\n         self._init_airflow_core_hooks()\n \n+        self._runtime_manager = None\n+\n+    def __getattribute__(self, name: str):\n+        # Hacky but does the trick for now\n+        runtime_properties = {\n+            \"hooks\",\n+            \"taskflow_decorators\",\n+            \"filesystem_module_names\",\n+            \"asset_factories\",\n+            \"asset_uri_handlers\",\n+            \"asset_to_openlineage_converters\",\n+        }",
      "comment": "> would rather handle it when I am getting rid of this compat shim\r\nSure, it makes sense to me.",
      "comment_id": 2697273297,
      "user": "jason810496",
      "created_at": "2026-01-16T07:12:15Z",
      "url": "https://github.com/apache/airflow/pull/60218#discussion_r2697273297"
    },
    {
      "repo": "apache/airflow",
      "pr_number": 60218,
      "file_path": "task-sdk/src/airflow/sdk/providers_manager_runtime.py",
      "line": 173,
      "side": "RIGHT",
      "diff_hunk": "@@ -0,0 +1,613 @@\n+#\n+# Licensed to the Apache Software Foundation (ASF) under one\n+# or more contributor license agreements.  See the NOTICE file\n+# distributed with this work for additional information\n+# regarding copyright ownership.  The ASF licenses this file\n+# to you under the Apache License, Version 2.0 (the\n+# \"License\"); you may not use this file except in compliance\n+# with the License.  You may obtain a copy of the License at\n+#\n+#   http://www.apache.org/licenses/LICENSE-2.0\n+#\n+# Unless required by applicable law or agreed to in writing,\n+# software distributed under the License is distributed on an\n+# \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+# KIND, either express or implied.  See the License for the\n+# specific language governing permissions and limitations\n+# under the License.\n+\"\"\"Manages runtime provider resources for task execution.\"\"\"\n+\n+from __future__ import annotations\n+\n+import functools\n+import inspect\n+import traceback\n+import warnings\n+from collections.abc import Callable, MutableMapping\n+from typing import TYPE_CHECKING, Any\n+from urllib.parse import SplitResult\n+\n+import structlog\n+\n+from airflow.sdk._shared.module_loading import import_string\n+from airflow.sdk._shared.providers_discovery import (\n+    KNOWN_UNHANDLED_OPTIONAL_FEATURE_ERRORS,\n+    HookClassProvider,\n+    HookInfo,\n+    LazyDictWithCache,\n+    PluginInfo,\n+    ProviderInfo,\n+    _check_builtin_provider_prefix,\n+    _create_provider_info_schema_validator,\n+    discover_all_providers_from_packages,\n+    log_import_warning,\n+    log_optional_feature_disabled,\n+    provider_info_cache,\n+)\n+from airflow.sdk.definitions._internal.logging_mixin import LoggingMixin\n+from airflow.sdk.exceptions import AirflowOptionalProviderFeatureException\n+\n+if TYPE_CHECKING:\n+    from airflow.sdk import BaseHook\n+    from airflow.sdk.bases.decorator import TaskDecorator\n+    from airflow.sdk.definitions.asset import Asset\n+\n+log = structlog.getLogger(__name__)\n+\n+\n+def _correctness_check(provider_package: str, class_name: str, provider_info: ProviderInfo) -> Any:\n+    \"\"\"\n+    Perform coherence check on provider classes.\n+\n+    For apache-airflow providers - it checks if it starts with appropriate package. For all providers\n+    it tries to import the provider - checking that there are no exceptions during importing.\n+    It logs appropriate warning in case it detects any problems.\n+\n+    :param provider_package: name of the provider package\n+    :param class_name: name of the class to import\n+\n+    :return the class if the class is OK, None otherwise.\n+    \"\"\"\n+    if not _check_builtin_provider_prefix(provider_package, class_name):\n+        return None\n+    try:\n+        imported_class = import_string(class_name)\n+    except AirflowOptionalProviderFeatureException as e:\n+        # When the provider class raises AirflowOptionalProviderFeatureException\n+        # this is an expected case when only some classes in provider are\n+        # available. We just log debug level here and print info message in logs so that\n+        # the user is aware of it\n+        log_optional_feature_disabled(class_name, e, provider_package)\n+        return None\n+    except ImportError as e:\n+        if \"No module named 'airflow.providers.\" in e.msg:\n+            # handle cases where another provider is missing. This can only happen if\n+            # there is an optional feature, so we log debug and print information about it\n+            log_optional_feature_disabled(class_name, e, provider_package)\n+            return None\n+        for known_error in KNOWN_UNHANDLED_OPTIONAL_FEATURE_ERRORS:\n+            # Until we convert all providers to use AirflowOptionalProviderFeatureException\n+            # we assume any problem with importing another \"provider\" is because this is an\n+            # optional feature, so we log debug and print information about it\n+            if known_error[0] == provider_package and known_error[1] in e.msg:\n+                log_optional_feature_disabled(class_name, e, provider_package)\n+                return None\n+        # But when we have no idea - we print warning to logs\n+        log_import_warning(class_name, e, provider_package)\n+        return None\n+    except Exception as e:\n+        log_import_warning(class_name, e, provider_package)\n+        return None\n+    return imported_class\n+\n+\n+class ProvidersManagerRuntime(LoggingMixin):\n+    \"\"\"\n+    Manages runtime provider resources for task execution.\n+\n+    This is a Singleton class. The first time it is instantiated, it discovers all available\n+    runtime provider resources (hooks, taskflow decorators, filesystems, asset handlers).\n+    \"\"\"\n+\n+    resource_version = \"0\"\n+    _initialized: bool = False\n+    _initialization_stack_trace = None\n+    _instance: ProvidersManagerRuntime | None = None\n+\n+    def __new__(cls):\n+        if cls._instance is None:\n+            cls._instance = super().__new__(cls)\n+        return cls._instance\n+\n+    @staticmethod\n+    def initialized() -> bool:\n+        return ProvidersManagerRuntime._initialized\n+\n+    @staticmethod\n+    def initialization_stack_trace() -> str | None:\n+        return ProvidersManagerRuntime._initialization_stack_trace\n+\n+    def __init__(self):\n+        \"\"\"Initialize the runtime manager.\"\"\"\n+        # skip initialization if already initialized\n+        if self.initialized():\n+            return\n+        super().__init__()\n+        ProvidersManagerRuntime._initialized = True\n+        ProvidersManagerRuntime._initialization_stack_trace = \"\".join(\n+            traceback.format_stack(inspect.currentframe())\n+        )\n+        self._initialized_cache: dict[str, bool] = {}\n+        # Keeps dict of providers keyed by module name\n+        self._provider_dict: dict[str, ProviderInfo] = {}\n+        self._fs_set: set[str] = set()\n+        self._asset_uri_handlers: dict[str, Callable[[SplitResult], SplitResult]] = {}\n+        self._asset_factories: dict[str, Callable[..., Asset]] = {}\n+        self._asset_to_openlineage_converters: dict[str, Callable] = {}\n+        self._taskflow_decorators: dict[str, Callable] = LazyDictWithCache()\n+        # keeps mapping between connection_types and hook class, package they come from\n+        self._hook_provider_dict: dict[str, HookClassProvider] = {}\n+        # Keeps dict of hooks keyed by connection type. They are lazy evaluated at access time\n+        self._hooks_lazy_dict: LazyDictWithCache[str, HookInfo | Callable] = LazyDictWithCache()\n+        self._plugins_set: set[PluginInfo] = set()\n+        self._provider_schema_validator = _create_provider_info_schema_validator()\n+        self._init_airflow_core_hooks()\n+\n+    def _init_airflow_core_hooks(self):\n+        \"\"\"Initialize the hooks dict with default hooks from Airflow core.\"\"\"\n+        core_dummy_hooks = {\n+            \"generic\": \"Generic\",\n+            \"email\": \"Email\",\n+        }\n+        for key, display in core_dummy_hooks.items():\n+            self._hooks_lazy_dict[key] = HookInfo(\n+                hook_class_name=None,\n+                connection_id_attribute_name=None,\n+                package_name=None,\n+                hook_name=display,\n+                connection_type=None,\n+                connection_testable=False,\n+            )\n+        for conn_type, class_name in (\n+            (\"fs\", \"airflow.providers.standard.hooks.filesystem.FSHook\"),\n+            (\"package_index\", \"airflow.providers.standard.hooks.package_index.PackageIndexHook\"),",
      "comment": "Hmm. Should not that be moved to standard provider ",
      "comment_id": 2698279956,
      "user": "potiuk",
      "created_at": "2026-01-16T12:08:28Z",
      "url": "https://github.com/apache/airflow/pull/60218#discussion_r2698279956"
    },
    {
      "repo": "apache/airflow",
      "pr_number": 60218,
      "file_path": "task-sdk/src/airflow/sdk/providers_manager_runtime.py",
      "line": 104,
      "side": "RIGHT",
      "diff_hunk": "@@ -0,0 +1,613 @@\n+#\n+# Licensed to the Apache Software Foundation (ASF) under one\n+# or more contributor license agreements.  See the NOTICE file\n+# distributed with this work for additional information\n+# regarding copyright ownership.  The ASF licenses this file\n+# to you under the Apache License, Version 2.0 (the\n+# \"License\"); you may not use this file except in compliance\n+# with the License.  You may obtain a copy of the License at\n+#\n+#   http://www.apache.org/licenses/LICENSE-2.0\n+#\n+# Unless required by applicable law or agreed to in writing,\n+# software distributed under the License is distributed on an\n+# \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+# KIND, either express or implied.  See the License for the\n+# specific language governing permissions and limitations\n+# under the License.\n+\"\"\"Manages runtime provider resources for task execution.\"\"\"\n+\n+from __future__ import annotations\n+\n+import functools\n+import inspect\n+import traceback\n+import warnings\n+from collections.abc import Callable, MutableMapping\n+from typing import TYPE_CHECKING, Any\n+from urllib.parse import SplitResult\n+\n+import structlog\n+\n+from airflow.sdk._shared.module_loading import import_string\n+from airflow.sdk._shared.providers_discovery import (\n+    KNOWN_UNHANDLED_OPTIONAL_FEATURE_ERRORS,\n+    HookClassProvider,\n+    HookInfo,\n+    LazyDictWithCache,\n+    PluginInfo,\n+    ProviderInfo,\n+    _check_builtin_provider_prefix,\n+    _create_provider_info_schema_validator,\n+    discover_all_providers_from_packages,\n+    log_import_warning,\n+    log_optional_feature_disabled,\n+    provider_info_cache,\n+)\n+from airflow.sdk.definitions._internal.logging_mixin import LoggingMixin\n+from airflow.sdk.exceptions import AirflowOptionalProviderFeatureException\n+\n+if TYPE_CHECKING:\n+    from airflow.sdk import BaseHook\n+    from airflow.sdk.bases.decorator import TaskDecorator\n+    from airflow.sdk.definitions.asset import Asset\n+\n+log = structlog.getLogger(__name__)\n+\n+\n+def _correctness_check(provider_package: str, class_name: str, provider_info: ProviderInfo) -> Any:\n+    \"\"\"\n+    Perform coherence check on provider classes.\n+\n+    For apache-airflow providers - it checks if it starts with appropriate package. For all providers\n+    it tries to import the provider - checking that there are no exceptions during importing.\n+    It logs appropriate warning in case it detects any problems.\n+\n+    :param provider_package: name of the provider package\n+    :param class_name: name of the class to import\n+\n+    :return the class if the class is OK, None otherwise.\n+    \"\"\"\n+    if not _check_builtin_provider_prefix(provider_package, class_name):\n+        return None\n+    try:\n+        imported_class = import_string(class_name)\n+    except AirflowOptionalProviderFeatureException as e:\n+        # When the provider class raises AirflowOptionalProviderFeatureException\n+        # this is an expected case when only some classes in provider are\n+        # available. We just log debug level here and print info message in logs so that\n+        # the user is aware of it\n+        log_optional_feature_disabled(class_name, e, provider_package)\n+        return None\n+    except ImportError as e:\n+        if \"No module named 'airflow.providers.\" in e.msg:\n+            # handle cases where another provider is missing. This can only happen if\n+            # there is an optional feature, so we log debug and print information about it\n+            log_optional_feature_disabled(class_name, e, provider_package)\n+            return None\n+        for known_error in KNOWN_UNHANDLED_OPTIONAL_FEATURE_ERRORS:\n+            # Until we convert all providers to use AirflowOptionalProviderFeatureException\n+            # we assume any problem with importing another \"provider\" is because this is an\n+            # optional feature, so we log debug and print information about it\n+            if known_error[0] == provider_package and known_error[1] in e.msg:\n+                log_optional_feature_disabled(class_name, e, provider_package)\n+                return None\n+        # But when we have no idea - we print warning to logs\n+        log_import_warning(class_name, e, provider_package)\n+        return None\n+    except Exception as e:\n+        log_import_warning(class_name, e, provider_package)\n+        return None\n+    return imported_class\n+\n+\n+class ProvidersManagerRuntime(LoggingMixin):",
      "comment": "```suggestion\nclass ProvidersManagerTaskRuntime(LoggingMixin):\n```",
      "comment_id": 2698285318,
      "user": "potiuk",
      "created_at": "2026-01-16T12:10:23Z",
      "url": "https://github.com/apache/airflow/pull/60218#discussion_r2698285318"
    },
    {
      "repo": "apache/airflow",
      "pr_number": 60218,
      "file_path": "task-sdk/src/airflow/sdk/providers_manager_runtime.py",
      "line": 104,
      "side": "RIGHT",
      "diff_hunk": "@@ -0,0 +1,613 @@\n+#\n+# Licensed to the Apache Software Foundation (ASF) under one\n+# or more contributor license agreements.  See the NOTICE file\n+# distributed with this work for additional information\n+# regarding copyright ownership.  The ASF licenses this file\n+# to you under the Apache License, Version 2.0 (the\n+# \"License\"); you may not use this file except in compliance\n+# with the License.  You may obtain a copy of the License at\n+#\n+#   http://www.apache.org/licenses/LICENSE-2.0\n+#\n+# Unless required by applicable law or agreed to in writing,\n+# software distributed under the License is distributed on an\n+# \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+# KIND, either express or implied.  See the License for the\n+# specific language governing permissions and limitations\n+# under the License.\n+\"\"\"Manages runtime provider resources for task execution.\"\"\"\n+\n+from __future__ import annotations\n+\n+import functools\n+import inspect\n+import traceback\n+import warnings\n+from collections.abc import Callable, MutableMapping\n+from typing import TYPE_CHECKING, Any\n+from urllib.parse import SplitResult\n+\n+import structlog\n+\n+from airflow.sdk._shared.module_loading import import_string\n+from airflow.sdk._shared.providers_discovery import (\n+    KNOWN_UNHANDLED_OPTIONAL_FEATURE_ERRORS,\n+    HookClassProvider,\n+    HookInfo,\n+    LazyDictWithCache,\n+    PluginInfo,\n+    ProviderInfo,\n+    _check_builtin_provider_prefix,\n+    _create_provider_info_schema_validator,\n+    discover_all_providers_from_packages,\n+    log_import_warning,\n+    log_optional_feature_disabled,\n+    provider_info_cache,\n+)\n+from airflow.sdk.definitions._internal.logging_mixin import LoggingMixin\n+from airflow.sdk.exceptions import AirflowOptionalProviderFeatureException\n+\n+if TYPE_CHECKING:\n+    from airflow.sdk import BaseHook\n+    from airflow.sdk.bases.decorator import TaskDecorator\n+    from airflow.sdk.definitions.asset import Asset\n+\n+log = structlog.getLogger(__name__)\n+\n+\n+def _correctness_check(provider_package: str, class_name: str, provider_info: ProviderInfo) -> Any:\n+    \"\"\"\n+    Perform coherence check on provider classes.\n+\n+    For apache-airflow providers - it checks if it starts with appropriate package. For all providers\n+    it tries to import the provider - checking that there are no exceptions during importing.\n+    It logs appropriate warning in case it detects any problems.\n+\n+    :param provider_package: name of the provider package\n+    :param class_name: name of the class to import\n+\n+    :return the class if the class is OK, None otherwise.\n+    \"\"\"\n+    if not _check_builtin_provider_prefix(provider_package, class_name):\n+        return None\n+    try:\n+        imported_class = import_string(class_name)\n+    except AirflowOptionalProviderFeatureException as e:\n+        # When the provider class raises AirflowOptionalProviderFeatureException\n+        # this is an expected case when only some classes in provider are\n+        # available. We just log debug level here and print info message in logs so that\n+        # the user is aware of it\n+        log_optional_feature_disabled(class_name, e, provider_package)\n+        return None\n+    except ImportError as e:\n+        if \"No module named 'airflow.providers.\" in e.msg:\n+            # handle cases where another provider is missing. This can only happen if\n+            # there is an optional feature, so we log debug and print information about it\n+            log_optional_feature_disabled(class_name, e, provider_package)\n+            return None\n+        for known_error in KNOWN_UNHANDLED_OPTIONAL_FEATURE_ERRORS:\n+            # Until we convert all providers to use AirflowOptionalProviderFeatureException\n+            # we assume any problem with importing another \"provider\" is because this is an\n+            # optional feature, so we log debug and print information about it\n+            if known_error[0] == provider_package and known_error[1] in e.msg:\n+                log_optional_feature_disabled(class_name, e, provider_package)\n+                return None\n+        # But when we have no idea - we print warning to logs\n+        log_import_warning(class_name, e, provider_package)\n+        return None\n+    except Exception as e:\n+        log_import_warning(class_name, e, provider_package)\n+        return None\n+    return imported_class\n+\n+\n+class ProvidersManagerRuntime(LoggingMixin):",
      "comment": "I think it would be better to use \"Task\" here to indicate that this is related to task-sdk usage. I know it is inside the `sdk` package which already kind of implies it, but adding Task here will make it crystal clear that this is about disovery and registration of  providers for \"task\" purposes.",
      "comment_id": 2698292188,
      "user": "potiuk",
      "created_at": "2026-01-16T12:12:59Z",
      "url": "https://github.com/apache/airflow/pull/60218#discussion_r2698292188"
    },
    {
      "repo": "apache/airflow",
      "pr_number": 60218,
      "file_path": "task-sdk/src/airflow/sdk/providers_manager_runtime.py",
      "line": 173,
      "side": "RIGHT",
      "diff_hunk": "@@ -0,0 +1,613 @@\n+#\n+# Licensed to the Apache Software Foundation (ASF) under one\n+# or more contributor license agreements.  See the NOTICE file\n+# distributed with this work for additional information\n+# regarding copyright ownership.  The ASF licenses this file\n+# to you under the Apache License, Version 2.0 (the\n+# \"License\"); you may not use this file except in compliance\n+# with the License.  You may obtain a copy of the License at\n+#\n+#   http://www.apache.org/licenses/LICENSE-2.0\n+#\n+# Unless required by applicable law or agreed to in writing,\n+# software distributed under the License is distributed on an\n+# \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+# KIND, either express or implied.  See the License for the\n+# specific language governing permissions and limitations\n+# under the License.\n+\"\"\"Manages runtime provider resources for task execution.\"\"\"\n+\n+from __future__ import annotations\n+\n+import functools\n+import inspect\n+import traceback\n+import warnings\n+from collections.abc import Callable, MutableMapping\n+from typing import TYPE_CHECKING, Any\n+from urllib.parse import SplitResult\n+\n+import structlog\n+\n+from airflow.sdk._shared.module_loading import import_string\n+from airflow.sdk._shared.providers_discovery import (\n+    KNOWN_UNHANDLED_OPTIONAL_FEATURE_ERRORS,\n+    HookClassProvider,\n+    HookInfo,\n+    LazyDictWithCache,\n+    PluginInfo,\n+    ProviderInfo,\n+    _check_builtin_provider_prefix,\n+    _create_provider_info_schema_validator,\n+    discover_all_providers_from_packages,\n+    log_import_warning,\n+    log_optional_feature_disabled,\n+    provider_info_cache,\n+)\n+from airflow.sdk.definitions._internal.logging_mixin import LoggingMixin\n+from airflow.sdk.exceptions import AirflowOptionalProviderFeatureException\n+\n+if TYPE_CHECKING:\n+    from airflow.sdk import BaseHook\n+    from airflow.sdk.bases.decorator import TaskDecorator\n+    from airflow.sdk.definitions.asset import Asset\n+\n+log = structlog.getLogger(__name__)\n+\n+\n+def _correctness_check(provider_package: str, class_name: str, provider_info: ProviderInfo) -> Any:\n+    \"\"\"\n+    Perform coherence check on provider classes.\n+\n+    For apache-airflow providers - it checks if it starts with appropriate package. For all providers\n+    it tries to import the provider - checking that there are no exceptions during importing.\n+    It logs appropriate warning in case it detects any problems.\n+\n+    :param provider_package: name of the provider package\n+    :param class_name: name of the class to import\n+\n+    :return the class if the class is OK, None otherwise.\n+    \"\"\"\n+    if not _check_builtin_provider_prefix(provider_package, class_name):\n+        return None\n+    try:\n+        imported_class = import_string(class_name)\n+    except AirflowOptionalProviderFeatureException as e:\n+        # When the provider class raises AirflowOptionalProviderFeatureException\n+        # this is an expected case when only some classes in provider are\n+        # available. We just log debug level here and print info message in logs so that\n+        # the user is aware of it\n+        log_optional_feature_disabled(class_name, e, provider_package)\n+        return None\n+    except ImportError as e:\n+        if \"No module named 'airflow.providers.\" in e.msg:\n+            # handle cases where another provider is missing. This can only happen if\n+            # there is an optional feature, so we log debug and print information about it\n+            log_optional_feature_disabled(class_name, e, provider_package)\n+            return None\n+        for known_error in KNOWN_UNHANDLED_OPTIONAL_FEATURE_ERRORS:\n+            # Until we convert all providers to use AirflowOptionalProviderFeatureException\n+            # we assume any problem with importing another \"provider\" is because this is an\n+            # optional feature, so we log debug and print information about it\n+            if known_error[0] == provider_package and known_error[1] in e.msg:\n+                log_optional_feature_disabled(class_name, e, provider_package)\n+                return None\n+        # But when we have no idea - we print warning to logs\n+        log_import_warning(class_name, e, provider_package)\n+        return None\n+    except Exception as e:\n+        log_import_warning(class_name, e, provider_package)\n+        return None\n+    return imported_class\n+\n+\n+class ProvidersManagerRuntime(LoggingMixin):\n+    \"\"\"\n+    Manages runtime provider resources for task execution.\n+\n+    This is a Singleton class. The first time it is instantiated, it discovers all available\n+    runtime provider resources (hooks, taskflow decorators, filesystems, asset handlers).\n+    \"\"\"\n+\n+    resource_version = \"0\"\n+    _initialized: bool = False\n+    _initialization_stack_trace = None\n+    _instance: ProvidersManagerRuntime | None = None\n+\n+    def __new__(cls):\n+        if cls._instance is None:\n+            cls._instance = super().__new__(cls)\n+        return cls._instance\n+\n+    @staticmethod\n+    def initialized() -> bool:\n+        return ProvidersManagerRuntime._initialized\n+\n+    @staticmethod\n+    def initialization_stack_trace() -> str | None:\n+        return ProvidersManagerRuntime._initialization_stack_trace\n+\n+    def __init__(self):\n+        \"\"\"Initialize the runtime manager.\"\"\"\n+        # skip initialization if already initialized\n+        if self.initialized():\n+            return\n+        super().__init__()\n+        ProvidersManagerRuntime._initialized = True\n+        ProvidersManagerRuntime._initialization_stack_trace = \"\".join(\n+            traceback.format_stack(inspect.currentframe())\n+        )\n+        self._initialized_cache: dict[str, bool] = {}\n+        # Keeps dict of providers keyed by module name\n+        self._provider_dict: dict[str, ProviderInfo] = {}\n+        self._fs_set: set[str] = set()\n+        self._asset_uri_handlers: dict[str, Callable[[SplitResult], SplitResult]] = {}\n+        self._asset_factories: dict[str, Callable[..., Asset]] = {}\n+        self._asset_to_openlineage_converters: dict[str, Callable] = {}\n+        self._taskflow_decorators: dict[str, Callable] = LazyDictWithCache()\n+        # keeps mapping between connection_types and hook class, package they come from\n+        self._hook_provider_dict: dict[str, HookClassProvider] = {}\n+        # Keeps dict of hooks keyed by connection type. They are lazy evaluated at access time\n+        self._hooks_lazy_dict: LazyDictWithCache[str, HookInfo | Callable] = LazyDictWithCache()\n+        self._plugins_set: set[PluginInfo] = set()\n+        self._provider_schema_validator = _create_provider_info_schema_validator()\n+        self._init_airflow_core_hooks()\n+\n+    def _init_airflow_core_hooks(self):\n+        \"\"\"Initialize the hooks dict with default hooks from Airflow core.\"\"\"\n+        core_dummy_hooks = {\n+            \"generic\": \"Generic\",\n+            \"email\": \"Email\",\n+        }\n+        for key, display in core_dummy_hooks.items():\n+            self._hooks_lazy_dict[key] = HookInfo(\n+                hook_class_name=None,\n+                connection_id_attribute_name=None,\n+                package_name=None,\n+                hook_name=display,\n+                connection_type=None,\n+                connection_testable=False,\n+            )\n+        for conn_type, class_name in (\n+            (\"fs\", \"airflow.providers.standard.hooks.filesystem.FSHook\"),\n+            (\"package_index\", \"airflow.providers.standard.hooks.package_index.PackageIndexHook\"),",
      "comment": "I do not know why it is here tbh. I thinkd default hooks that we certainly want installed?",
      "comment_id": 2703800771,
      "user": "amoghrajesh",
      "created_at": "2026-01-19T08:49:42Z",
      "url": "https://github.com/apache/airflow/pull/60218#discussion_r2703800771"
    },
    {
      "repo": "apache/airflow",
      "pr_number": 60218,
      "file_path": "task-sdk/src/airflow/sdk/providers_manager_runtime.py",
      "line": 173,
      "side": "RIGHT",
      "diff_hunk": "@@ -0,0 +1,613 @@\n+#\n+# Licensed to the Apache Software Foundation (ASF) under one\n+# or more contributor license agreements.  See the NOTICE file\n+# distributed with this work for additional information\n+# regarding copyright ownership.  The ASF licenses this file\n+# to you under the Apache License, Version 2.0 (the\n+# \"License\"); you may not use this file except in compliance\n+# with the License.  You may obtain a copy of the License at\n+#\n+#   http://www.apache.org/licenses/LICENSE-2.0\n+#\n+# Unless required by applicable law or agreed to in writing,\n+# software distributed under the License is distributed on an\n+# \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+# KIND, either express or implied.  See the License for the\n+# specific language governing permissions and limitations\n+# under the License.\n+\"\"\"Manages runtime provider resources for task execution.\"\"\"\n+\n+from __future__ import annotations\n+\n+import functools\n+import inspect\n+import traceback\n+import warnings\n+from collections.abc import Callable, MutableMapping\n+from typing import TYPE_CHECKING, Any\n+from urllib.parse import SplitResult\n+\n+import structlog\n+\n+from airflow.sdk._shared.module_loading import import_string\n+from airflow.sdk._shared.providers_discovery import (\n+    KNOWN_UNHANDLED_OPTIONAL_FEATURE_ERRORS,\n+    HookClassProvider,\n+    HookInfo,\n+    LazyDictWithCache,\n+    PluginInfo,\n+    ProviderInfo,\n+    _check_builtin_provider_prefix,\n+    _create_provider_info_schema_validator,\n+    discover_all_providers_from_packages,\n+    log_import_warning,\n+    log_optional_feature_disabled,\n+    provider_info_cache,\n+)\n+from airflow.sdk.definitions._internal.logging_mixin import LoggingMixin\n+from airflow.sdk.exceptions import AirflowOptionalProviderFeatureException\n+\n+if TYPE_CHECKING:\n+    from airflow.sdk import BaseHook\n+    from airflow.sdk.bases.decorator import TaskDecorator\n+    from airflow.sdk.definitions.asset import Asset\n+\n+log = structlog.getLogger(__name__)\n+\n+\n+def _correctness_check(provider_package: str, class_name: str, provider_info: ProviderInfo) -> Any:\n+    \"\"\"\n+    Perform coherence check on provider classes.\n+\n+    For apache-airflow providers - it checks if it starts with appropriate package. For all providers\n+    it tries to import the provider - checking that there are no exceptions during importing.\n+    It logs appropriate warning in case it detects any problems.\n+\n+    :param provider_package: name of the provider package\n+    :param class_name: name of the class to import\n+\n+    :return the class if the class is OK, None otherwise.\n+    \"\"\"\n+    if not _check_builtin_provider_prefix(provider_package, class_name):\n+        return None\n+    try:\n+        imported_class = import_string(class_name)\n+    except AirflowOptionalProviderFeatureException as e:\n+        # When the provider class raises AirflowOptionalProviderFeatureException\n+        # this is an expected case when only some classes in provider are\n+        # available. We just log debug level here and print info message in logs so that\n+        # the user is aware of it\n+        log_optional_feature_disabled(class_name, e, provider_package)\n+        return None\n+    except ImportError as e:\n+        if \"No module named 'airflow.providers.\" in e.msg:\n+            # handle cases where another provider is missing. This can only happen if\n+            # there is an optional feature, so we log debug and print information about it\n+            log_optional_feature_disabled(class_name, e, provider_package)\n+            return None\n+        for known_error in KNOWN_UNHANDLED_OPTIONAL_FEATURE_ERRORS:\n+            # Until we convert all providers to use AirflowOptionalProviderFeatureException\n+            # we assume any problem with importing another \"provider\" is because this is an\n+            # optional feature, so we log debug and print information about it\n+            if known_error[0] == provider_package and known_error[1] in e.msg:\n+                log_optional_feature_disabled(class_name, e, provider_package)\n+                return None\n+        # But when we have no idea - we print warning to logs\n+        log_import_warning(class_name, e, provider_package)\n+        return None\n+    except Exception as e:\n+        log_import_warning(class_name, e, provider_package)\n+        return None\n+    return imported_class\n+\n+\n+class ProvidersManagerRuntime(LoggingMixin):\n+    \"\"\"\n+    Manages runtime provider resources for task execution.\n+\n+    This is a Singleton class. The first time it is instantiated, it discovers all available\n+    runtime provider resources (hooks, taskflow decorators, filesystems, asset handlers).\n+    \"\"\"\n+\n+    resource_version = \"0\"\n+    _initialized: bool = False\n+    _initialization_stack_trace = None\n+    _instance: ProvidersManagerRuntime | None = None\n+\n+    def __new__(cls):\n+        if cls._instance is None:\n+            cls._instance = super().__new__(cls)\n+        return cls._instance\n+\n+    @staticmethod\n+    def initialized() -> bool:\n+        return ProvidersManagerRuntime._initialized\n+\n+    @staticmethod\n+    def initialization_stack_trace() -> str | None:\n+        return ProvidersManagerRuntime._initialization_stack_trace\n+\n+    def __init__(self):\n+        \"\"\"Initialize the runtime manager.\"\"\"\n+        # skip initialization if already initialized\n+        if self.initialized():\n+            return\n+        super().__init__()\n+        ProvidersManagerRuntime._initialized = True\n+        ProvidersManagerRuntime._initialization_stack_trace = \"\".join(\n+            traceback.format_stack(inspect.currentframe())\n+        )\n+        self._initialized_cache: dict[str, bool] = {}\n+        # Keeps dict of providers keyed by module name\n+        self._provider_dict: dict[str, ProviderInfo] = {}\n+        self._fs_set: set[str] = set()\n+        self._asset_uri_handlers: dict[str, Callable[[SplitResult], SplitResult]] = {}\n+        self._asset_factories: dict[str, Callable[..., Asset]] = {}\n+        self._asset_to_openlineage_converters: dict[str, Callable] = {}\n+        self._taskflow_decorators: dict[str, Callable] = LazyDictWithCache()\n+        # keeps mapping between connection_types and hook class, package they come from\n+        self._hook_provider_dict: dict[str, HookClassProvider] = {}\n+        # Keeps dict of hooks keyed by connection type. They are lazy evaluated at access time\n+        self._hooks_lazy_dict: LazyDictWithCache[str, HookInfo | Callable] = LazyDictWithCache()\n+        self._plugins_set: set[PluginInfo] = set()\n+        self._provider_schema_validator = _create_provider_info_schema_validator()\n+        self._init_airflow_core_hooks()\n+\n+    def _init_airflow_core_hooks(self):\n+        \"\"\"Initialize the hooks dict with default hooks from Airflow core.\"\"\"\n+        core_dummy_hooks = {\n+            \"generic\": \"Generic\",\n+            \"email\": \"Email\",\n+        }\n+        for key, display in core_dummy_hooks.items():\n+            self._hooks_lazy_dict[key] = HookInfo(\n+                hook_class_name=None,\n+                connection_id_attribute_name=None,\n+                package_name=None,\n+                hook_name=display,\n+                connection_type=None,\n+                connection_testable=False,\n+            )\n+        for conn_type, class_name in (\n+            (\"fs\", \"airflow.providers.standard.hooks.filesystem.FSHook\"),\n+            (\"package_index\", \"airflow.providers.standard.hooks.package_index.PackageIndexHook\"),",
      "comment": "@jscheffl had written that some time ago, wondering if we know the background behind why? IAC, let me handle that in a follow up, the PR is big as-is",
      "comment_id": 2703804052,
      "user": "amoghrajesh",
      "created_at": "2026-01-19T08:50:43Z",
      "url": "https://github.com/apache/airflow/pull/60218#discussion_r2703804052"
    },
    {
      "repo": "apache/airflow",
      "pr_number": 60218,
      "file_path": "task-sdk/src/airflow/sdk/providers_manager_runtime.py",
      "line": 104,
      "side": "RIGHT",
      "diff_hunk": "@@ -0,0 +1,613 @@\n+#\n+# Licensed to the Apache Software Foundation (ASF) under one\n+# or more contributor license agreements.  See the NOTICE file\n+# distributed with this work for additional information\n+# regarding copyright ownership.  The ASF licenses this file\n+# to you under the Apache License, Version 2.0 (the\n+# \"License\"); you may not use this file except in compliance\n+# with the License.  You may obtain a copy of the License at\n+#\n+#   http://www.apache.org/licenses/LICENSE-2.0\n+#\n+# Unless required by applicable law or agreed to in writing,\n+# software distributed under the License is distributed on an\n+# \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+# KIND, either express or implied.  See the License for the\n+# specific language governing permissions and limitations\n+# under the License.\n+\"\"\"Manages runtime provider resources for task execution.\"\"\"\n+\n+from __future__ import annotations\n+\n+import functools\n+import inspect\n+import traceback\n+import warnings\n+from collections.abc import Callable, MutableMapping\n+from typing import TYPE_CHECKING, Any\n+from urllib.parse import SplitResult\n+\n+import structlog\n+\n+from airflow.sdk._shared.module_loading import import_string\n+from airflow.sdk._shared.providers_discovery import (\n+    KNOWN_UNHANDLED_OPTIONAL_FEATURE_ERRORS,\n+    HookClassProvider,\n+    HookInfo,\n+    LazyDictWithCache,\n+    PluginInfo,\n+    ProviderInfo,\n+    _check_builtin_provider_prefix,\n+    _create_provider_info_schema_validator,\n+    discover_all_providers_from_packages,\n+    log_import_warning,\n+    log_optional_feature_disabled,\n+    provider_info_cache,\n+)\n+from airflow.sdk.definitions._internal.logging_mixin import LoggingMixin\n+from airflow.sdk.exceptions import AirflowOptionalProviderFeatureException\n+\n+if TYPE_CHECKING:\n+    from airflow.sdk import BaseHook\n+    from airflow.sdk.bases.decorator import TaskDecorator\n+    from airflow.sdk.definitions.asset import Asset\n+\n+log = structlog.getLogger(__name__)\n+\n+\n+def _correctness_check(provider_package: str, class_name: str, provider_info: ProviderInfo) -> Any:\n+    \"\"\"\n+    Perform coherence check on provider classes.\n+\n+    For apache-airflow providers - it checks if it starts with appropriate package. For all providers\n+    it tries to import the provider - checking that there are no exceptions during importing.\n+    It logs appropriate warning in case it detects any problems.\n+\n+    :param provider_package: name of the provider package\n+    :param class_name: name of the class to import\n+\n+    :return the class if the class is OK, None otherwise.\n+    \"\"\"\n+    if not _check_builtin_provider_prefix(provider_package, class_name):\n+        return None\n+    try:\n+        imported_class = import_string(class_name)\n+    except AirflowOptionalProviderFeatureException as e:\n+        # When the provider class raises AirflowOptionalProviderFeatureException\n+        # this is an expected case when only some classes in provider are\n+        # available. We just log debug level here and print info message in logs so that\n+        # the user is aware of it\n+        log_optional_feature_disabled(class_name, e, provider_package)\n+        return None\n+    except ImportError as e:\n+        if \"No module named 'airflow.providers.\" in e.msg:\n+            # handle cases where another provider is missing. This can only happen if\n+            # there is an optional feature, so we log debug and print information about it\n+            log_optional_feature_disabled(class_name, e, provider_package)\n+            return None\n+        for known_error in KNOWN_UNHANDLED_OPTIONAL_FEATURE_ERRORS:\n+            # Until we convert all providers to use AirflowOptionalProviderFeatureException\n+            # we assume any problem with importing another \"provider\" is because this is an\n+            # optional feature, so we log debug and print information about it\n+            if known_error[0] == provider_package and known_error[1] in e.msg:\n+                log_optional_feature_disabled(class_name, e, provider_package)\n+                return None\n+        # But when we have no idea - we print warning to logs\n+        log_import_warning(class_name, e, provider_package)\n+        return None\n+    except Exception as e:\n+        log_import_warning(class_name, e, provider_package)\n+        return None\n+    return imported_class\n+\n+\n+class ProvidersManagerRuntime(LoggingMixin):",
      "comment": "Handled in [comments from jarek](https://github.com/apache/airflow/pull/60218/commits/836f5dd0c7c0e84a30c963594dfe4be8ba8b9228)",
      "comment_id": 2703811619,
      "user": "amoghrajesh",
      "created_at": "2026-01-19T08:52:41Z",
      "url": "https://github.com/apache/airflow/pull/60218#discussion_r2703811619"
    },
    {
      "repo": "apache/airflow",
      "pr_number": 60218,
      "file_path": "task-sdk/src/airflow/sdk/providers_manager_runtime.py",
      "line": 173,
      "side": "RIGHT",
      "diff_hunk": "@@ -0,0 +1,613 @@\n+#\n+# Licensed to the Apache Software Foundation (ASF) under one\n+# or more contributor license agreements.  See the NOTICE file\n+# distributed with this work for additional information\n+# regarding copyright ownership.  The ASF licenses this file\n+# to you under the Apache License, Version 2.0 (the\n+# \"License\"); you may not use this file except in compliance\n+# with the License.  You may obtain a copy of the License at\n+#\n+#   http://www.apache.org/licenses/LICENSE-2.0\n+#\n+# Unless required by applicable law or agreed to in writing,\n+# software distributed under the License is distributed on an\n+# \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+# KIND, either express or implied.  See the License for the\n+# specific language governing permissions and limitations\n+# under the License.\n+\"\"\"Manages runtime provider resources for task execution.\"\"\"\n+\n+from __future__ import annotations\n+\n+import functools\n+import inspect\n+import traceback\n+import warnings\n+from collections.abc import Callable, MutableMapping\n+from typing import TYPE_CHECKING, Any\n+from urllib.parse import SplitResult\n+\n+import structlog\n+\n+from airflow.sdk._shared.module_loading import import_string\n+from airflow.sdk._shared.providers_discovery import (\n+    KNOWN_UNHANDLED_OPTIONAL_FEATURE_ERRORS,\n+    HookClassProvider,\n+    HookInfo,\n+    LazyDictWithCache,\n+    PluginInfo,\n+    ProviderInfo,\n+    _check_builtin_provider_prefix,\n+    _create_provider_info_schema_validator,\n+    discover_all_providers_from_packages,\n+    log_import_warning,\n+    log_optional_feature_disabled,\n+    provider_info_cache,\n+)\n+from airflow.sdk.definitions._internal.logging_mixin import LoggingMixin\n+from airflow.sdk.exceptions import AirflowOptionalProviderFeatureException\n+\n+if TYPE_CHECKING:\n+    from airflow.sdk import BaseHook\n+    from airflow.sdk.bases.decorator import TaskDecorator\n+    from airflow.sdk.definitions.asset import Asset\n+\n+log = structlog.getLogger(__name__)\n+\n+\n+def _correctness_check(provider_package: str, class_name: str, provider_info: ProviderInfo) -> Any:\n+    \"\"\"\n+    Perform coherence check on provider classes.\n+\n+    For apache-airflow providers - it checks if it starts with appropriate package. For all providers\n+    it tries to import the provider - checking that there are no exceptions during importing.\n+    It logs appropriate warning in case it detects any problems.\n+\n+    :param provider_package: name of the provider package\n+    :param class_name: name of the class to import\n+\n+    :return the class if the class is OK, None otherwise.\n+    \"\"\"\n+    if not _check_builtin_provider_prefix(provider_package, class_name):\n+        return None\n+    try:\n+        imported_class = import_string(class_name)\n+    except AirflowOptionalProviderFeatureException as e:\n+        # When the provider class raises AirflowOptionalProviderFeatureException\n+        # this is an expected case when only some classes in provider are\n+        # available. We just log debug level here and print info message in logs so that\n+        # the user is aware of it\n+        log_optional_feature_disabled(class_name, e, provider_package)\n+        return None\n+    except ImportError as e:\n+        if \"No module named 'airflow.providers.\" in e.msg:\n+            # handle cases where another provider is missing. This can only happen if\n+            # there is an optional feature, so we log debug and print information about it\n+            log_optional_feature_disabled(class_name, e, provider_package)\n+            return None\n+        for known_error in KNOWN_UNHANDLED_OPTIONAL_FEATURE_ERRORS:\n+            # Until we convert all providers to use AirflowOptionalProviderFeatureException\n+            # we assume any problem with importing another \"provider\" is because this is an\n+            # optional feature, so we log debug and print information about it\n+            if known_error[0] == provider_package and known_error[1] in e.msg:\n+                log_optional_feature_disabled(class_name, e, provider_package)\n+                return None\n+        # But when we have no idea - we print warning to logs\n+        log_import_warning(class_name, e, provider_package)\n+        return None\n+    except Exception as e:\n+        log_import_warning(class_name, e, provider_package)\n+        return None\n+    return imported_class\n+\n+\n+class ProvidersManagerRuntime(LoggingMixin):\n+    \"\"\"\n+    Manages runtime provider resources for task execution.\n+\n+    This is a Singleton class. The first time it is instantiated, it discovers all available\n+    runtime provider resources (hooks, taskflow decorators, filesystems, asset handlers).\n+    \"\"\"\n+\n+    resource_version = \"0\"\n+    _initialized: bool = False\n+    _initialization_stack_trace = None\n+    _instance: ProvidersManagerRuntime | None = None\n+\n+    def __new__(cls):\n+        if cls._instance is None:\n+            cls._instance = super().__new__(cls)\n+        return cls._instance\n+\n+    @staticmethod\n+    def initialized() -> bool:\n+        return ProvidersManagerRuntime._initialized\n+\n+    @staticmethod\n+    def initialization_stack_trace() -> str | None:\n+        return ProvidersManagerRuntime._initialization_stack_trace\n+\n+    def __init__(self):\n+        \"\"\"Initialize the runtime manager.\"\"\"\n+        # skip initialization if already initialized\n+        if self.initialized():\n+            return\n+        super().__init__()\n+        ProvidersManagerRuntime._initialized = True\n+        ProvidersManagerRuntime._initialization_stack_trace = \"\".join(\n+            traceback.format_stack(inspect.currentframe())\n+        )\n+        self._initialized_cache: dict[str, bool] = {}\n+        # Keeps dict of providers keyed by module name\n+        self._provider_dict: dict[str, ProviderInfo] = {}\n+        self._fs_set: set[str] = set()\n+        self._asset_uri_handlers: dict[str, Callable[[SplitResult], SplitResult]] = {}\n+        self._asset_factories: dict[str, Callable[..., Asset]] = {}\n+        self._asset_to_openlineage_converters: dict[str, Callable] = {}\n+        self._taskflow_decorators: dict[str, Callable] = LazyDictWithCache()\n+        # keeps mapping between connection_types and hook class, package they come from\n+        self._hook_provider_dict: dict[str, HookClassProvider] = {}\n+        # Keeps dict of hooks keyed by connection type. They are lazy evaluated at access time\n+        self._hooks_lazy_dict: LazyDictWithCache[str, HookInfo | Callable] = LazyDictWithCache()\n+        self._plugins_set: set[PluginInfo] = set()\n+        self._provider_schema_validator = _create_provider_info_schema_validator()\n+        self._init_airflow_core_hooks()\n+\n+    def _init_airflow_core_hooks(self):\n+        \"\"\"Initialize the hooks dict with default hooks from Airflow core.\"\"\"\n+        core_dummy_hooks = {\n+            \"generic\": \"Generic\",\n+            \"email\": \"Email\",\n+        }\n+        for key, display in core_dummy_hooks.items():\n+            self._hooks_lazy_dict[key] = HookInfo(\n+                hook_class_name=None,\n+                connection_id_attribute_name=None,\n+                package_name=None,\n+                hook_name=display,\n+                connection_type=None,\n+                connection_testable=False,\n+            )\n+        for conn_type, class_name in (\n+            (\"fs\", \"airflow.providers.standard.hooks.filesystem.FSHook\"),\n+            (\"package_index\", \"airflow.providers.standard.hooks.package_index.PackageIndexHook\"),",
      "comment": "This was marked from me as a carry-over and cleanup from Airflow 1.0 times where the list of providers were hardcoded. All hooks/connection types went to providers and the leftover residual were only these two. If we move them to standard provider (which would be best) then we do not need this special treatment anymore. Just at time of writing that did not exist.\r\n\r\nMaybe also generic and email can be moved to standard provider as well.",
      "comment_id": 2705909982,
      "user": "jscheffl",
      "created_at": "2026-01-19T19:45:30Z",
      "url": "https://github.com/apache/airflow/pull/60218#discussion_r2705909982"
    },
    {
      "repo": "apache/airflow",
      "pr_number": 60218,
      "file_path": "task-sdk/src/airflow/sdk/providers_manager_runtime.py",
      "line": 173,
      "side": "RIGHT",
      "diff_hunk": "@@ -0,0 +1,613 @@\n+#\n+# Licensed to the Apache Software Foundation (ASF) under one\n+# or more contributor license agreements.  See the NOTICE file\n+# distributed with this work for additional information\n+# regarding copyright ownership.  The ASF licenses this file\n+# to you under the Apache License, Version 2.0 (the\n+# \"License\"); you may not use this file except in compliance\n+# with the License.  You may obtain a copy of the License at\n+#\n+#   http://www.apache.org/licenses/LICENSE-2.0\n+#\n+# Unless required by applicable law or agreed to in writing,\n+# software distributed under the License is distributed on an\n+# \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+# KIND, either express or implied.  See the License for the\n+# specific language governing permissions and limitations\n+# under the License.\n+\"\"\"Manages runtime provider resources for task execution.\"\"\"\n+\n+from __future__ import annotations\n+\n+import functools\n+import inspect\n+import traceback\n+import warnings\n+from collections.abc import Callable, MutableMapping\n+from typing import TYPE_CHECKING, Any\n+from urllib.parse import SplitResult\n+\n+import structlog\n+\n+from airflow.sdk._shared.module_loading import import_string\n+from airflow.sdk._shared.providers_discovery import (\n+    KNOWN_UNHANDLED_OPTIONAL_FEATURE_ERRORS,\n+    HookClassProvider,\n+    HookInfo,\n+    LazyDictWithCache,\n+    PluginInfo,\n+    ProviderInfo,\n+    _check_builtin_provider_prefix,\n+    _create_provider_info_schema_validator,\n+    discover_all_providers_from_packages,\n+    log_import_warning,\n+    log_optional_feature_disabled,\n+    provider_info_cache,\n+)\n+from airflow.sdk.definitions._internal.logging_mixin import LoggingMixin\n+from airflow.sdk.exceptions import AirflowOptionalProviderFeatureException\n+\n+if TYPE_CHECKING:\n+    from airflow.sdk import BaseHook\n+    from airflow.sdk.bases.decorator import TaskDecorator\n+    from airflow.sdk.definitions.asset import Asset\n+\n+log = structlog.getLogger(__name__)\n+\n+\n+def _correctness_check(provider_package: str, class_name: str, provider_info: ProviderInfo) -> Any:\n+    \"\"\"\n+    Perform coherence check on provider classes.\n+\n+    For apache-airflow providers - it checks if it starts with appropriate package. For all providers\n+    it tries to import the provider - checking that there are no exceptions during importing.\n+    It logs appropriate warning in case it detects any problems.\n+\n+    :param provider_package: name of the provider package\n+    :param class_name: name of the class to import\n+\n+    :return the class if the class is OK, None otherwise.\n+    \"\"\"\n+    if not _check_builtin_provider_prefix(provider_package, class_name):\n+        return None\n+    try:\n+        imported_class = import_string(class_name)\n+    except AirflowOptionalProviderFeatureException as e:\n+        # When the provider class raises AirflowOptionalProviderFeatureException\n+        # this is an expected case when only some classes in provider are\n+        # available. We just log debug level here and print info message in logs so that\n+        # the user is aware of it\n+        log_optional_feature_disabled(class_name, e, provider_package)\n+        return None\n+    except ImportError as e:\n+        if \"No module named 'airflow.providers.\" in e.msg:\n+            # handle cases where another provider is missing. This can only happen if\n+            # there is an optional feature, so we log debug and print information about it\n+            log_optional_feature_disabled(class_name, e, provider_package)\n+            return None\n+        for known_error in KNOWN_UNHANDLED_OPTIONAL_FEATURE_ERRORS:\n+            # Until we convert all providers to use AirflowOptionalProviderFeatureException\n+            # we assume any problem with importing another \"provider\" is because this is an\n+            # optional feature, so we log debug and print information about it\n+            if known_error[0] == provider_package and known_error[1] in e.msg:\n+                log_optional_feature_disabled(class_name, e, provider_package)\n+                return None\n+        # But when we have no idea - we print warning to logs\n+        log_import_warning(class_name, e, provider_package)\n+        return None\n+    except Exception as e:\n+        log_import_warning(class_name, e, provider_package)\n+        return None\n+    return imported_class\n+\n+\n+class ProvidersManagerRuntime(LoggingMixin):\n+    \"\"\"\n+    Manages runtime provider resources for task execution.\n+\n+    This is a Singleton class. The first time it is instantiated, it discovers all available\n+    runtime provider resources (hooks, taskflow decorators, filesystems, asset handlers).\n+    \"\"\"\n+\n+    resource_version = \"0\"\n+    _initialized: bool = False\n+    _initialization_stack_trace = None\n+    _instance: ProvidersManagerRuntime | None = None\n+\n+    def __new__(cls):\n+        if cls._instance is None:\n+            cls._instance = super().__new__(cls)\n+        return cls._instance\n+\n+    @staticmethod\n+    def initialized() -> bool:\n+        return ProvidersManagerRuntime._initialized\n+\n+    @staticmethod\n+    def initialization_stack_trace() -> str | None:\n+        return ProvidersManagerRuntime._initialization_stack_trace\n+\n+    def __init__(self):\n+        \"\"\"Initialize the runtime manager.\"\"\"\n+        # skip initialization if already initialized\n+        if self.initialized():\n+            return\n+        super().__init__()\n+        ProvidersManagerRuntime._initialized = True\n+        ProvidersManagerRuntime._initialization_stack_trace = \"\".join(\n+            traceback.format_stack(inspect.currentframe())\n+        )\n+        self._initialized_cache: dict[str, bool] = {}\n+        # Keeps dict of providers keyed by module name\n+        self._provider_dict: dict[str, ProviderInfo] = {}\n+        self._fs_set: set[str] = set()\n+        self._asset_uri_handlers: dict[str, Callable[[SplitResult], SplitResult]] = {}\n+        self._asset_factories: dict[str, Callable[..., Asset]] = {}\n+        self._asset_to_openlineage_converters: dict[str, Callable] = {}\n+        self._taskflow_decorators: dict[str, Callable] = LazyDictWithCache()\n+        # keeps mapping between connection_types and hook class, package they come from\n+        self._hook_provider_dict: dict[str, HookClassProvider] = {}\n+        # Keeps dict of hooks keyed by connection type. They are lazy evaluated at access time\n+        self._hooks_lazy_dict: LazyDictWithCache[str, HookInfo | Callable] = LazyDictWithCache()\n+        self._plugins_set: set[PluginInfo] = set()\n+        self._provider_schema_validator = _create_provider_info_schema_validator()\n+        self._init_airflow_core_hooks()\n+\n+    def _init_airflow_core_hooks(self):\n+        \"\"\"Initialize the hooks dict with default hooks from Airflow core.\"\"\"\n+        core_dummy_hooks = {\n+            \"generic\": \"Generic\",\n+            \"email\": \"Email\",\n+        }\n+        for key, display in core_dummy_hooks.items():\n+            self._hooks_lazy_dict[key] = HookInfo(\n+                hook_class_name=None,\n+                connection_id_attribute_name=None,\n+                package_name=None,\n+                hook_name=display,\n+                connection_type=None,\n+                connection_testable=False,\n+            )\n+        for conn_type, class_name in (\n+            (\"fs\", \"airflow.providers.standard.hooks.filesystem.FSHook\"),\n+            (\"package_index\", \"airflow.providers.standard.hooks.package_index.PackageIndexHook\"),",
      "comment": "So I#d say: Was a cleanup from Airflow 1.x to 2.x with a bit of cleanup and residual tech dept to perfect beauty",
      "comment_id": 2705910830,
      "user": "jscheffl",
      "created_at": "2026-01-19T19:45:56Z",
      "url": "https://github.com/apache/airflow/pull/60218#discussion_r2705910830"
    },
    {
      "repo": "apache/airflow",
      "pr_number": 60676,
      "file_path": "scripts/ci/prek/check_core_imports_in_sdk.py",
      "line": 20,
      "side": "RIGHT",
      "diff_hunk": "@@ -0,0 +1,88 @@\n+#!/usr/bin/env python\n+#\n+# Licensed to the Apache Software Foundation (ASF) under one\n+# or more contributor license agreements.  See the NOTICE file\n+# distributed with this work for additional information\n+# regarding copyright ownership.  The ASF licenses this file\n+# to you under the Apache License, Version 2.0 (the\n+# \"License\"); you may not use this file except in compliance\n+# with the License.  You may obtain a copy of the License at\n+#\n+#   http://www.apache.org/licenses/LICENSE-2.0\n+#\n+# Unless required by applicable law or agreed to in writing,\n+# software distributed under the License is distributed on an\n+# \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+# KIND, either express or implied.  See the License for the\n+# specific language governing permissions and limitations\n+# under the License.\n+# /// script\n+# requires-python = \">=3.10,<3.11\"",
      "comment": "Some time ago, we had decided to limit prek hooks to run py3.10 via: https://github.com/apache/airflow/pull/58439, there was some discussion in that PR itself",
      "comment_id": 2700962885,
      "user": "amoghrajesh",
      "created_at": "2026-01-17T11:16:30Z",
      "url": "https://github.com/apache/airflow/pull/60676#discussion_r2700962885"
    },
    {
      "repo": "apache/airflow",
      "pr_number": 60676,
      "file_path": "scripts/ci/prek/check_core_imports_in_sdk.py",
      "line": 41,
      "side": "RIGHT",
      "diff_hunk": "@@ -0,0 +1,97 @@\n+#!/usr/bin/env python\n+#\n+# Licensed to the Apache Software Foundation (ASF) under one\n+# or more contributor license agreements.  See the NOTICE file\n+# distributed with this work for additional information\n+# regarding copyright ownership.  The ASF licenses this file\n+# to you under the Apache License, Version 2.0 (the\n+# \"License\"); you may not use this file except in compliance\n+# with the License.  You may obtain a copy of the License at\n+#\n+#   http://www.apache.org/licenses/LICENSE-2.0\n+#\n+# Unless required by applicable law or agreed to in writing,\n+# software distributed under the License is distributed on an\n+# \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+# KIND, either express or implied.  See the License for the\n+# specific language governing permissions and limitations\n+# under the License.\n+# /// script\n+# requires-python = \">=3.10,<3.11\"\n+# dependencies = [\n+#   \"rich>=13.6.0\",\n+# ]\n+# ///\n+from __future__ import annotations\n+\n+import argparse\n+import ast\n+import sys\n+from pathlib import Path\n+\n+sys.path.insert(0, str(Path(__file__).parent.resolve()))\n+from common_prek_utils import console\n+\n+\n+def check_file_for_core_imports(file_path: Path) -> list[tuple[int, str]]:\n+    \"\"\"Check file for airflow-core imports (anything except airflow.sdk). Returns list of (line_num, import_statement).\"\"\"\n+    try:\n+        with open(file_path, encoding=\"utf-8\") as f:\n+            source = f.read()\n+            tree = ast.parse(source, filename=str(file_path))",
      "comment": "What if we use `tree = ast.parse(file_path.read_text(encoding=\"utf-8\"), filename=str(file_path))`, since it automatically opens, closes, and reads the text, and also supports encoding, just like other hook scripts?",
      "comment_id": 2700987571,
      "user": "Prab-27",
      "created_at": "2026-01-17T11:33:28Z",
      "url": "https://github.com/apache/airflow/pull/60676#discussion_r2700987571"
    },
    {
      "repo": "apache/airflow",
      "pr_number": 60676,
      "file_path": "scripts/ci/prek/check_core_imports_in_sdk.py",
      "line": 78,
      "side": "RIGHT",
      "diff_hunk": "@@ -0,0 +1,97 @@\n+#!/usr/bin/env python\n+#\n+# Licensed to the Apache Software Foundation (ASF) under one\n+# or more contributor license agreements.  See the NOTICE file\n+# distributed with this work for additional information\n+# regarding copyright ownership.  The ASF licenses this file\n+# to you under the Apache License, Version 2.0 (the\n+# \"License\"); you may not use this file except in compliance\n+# with the License.  You may obtain a copy of the License at\n+#\n+#   http://www.apache.org/licenses/LICENSE-2.0\n+#\n+# Unless required by applicable law or agreed to in writing,\n+# software distributed under the License is distributed on an\n+# \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+# KIND, either express or implied.  See the License for the\n+# specific language governing permissions and limitations\n+# under the License.\n+# /// script\n+# requires-python = \">=3.10,<3.11\"\n+# dependencies = [\n+#   \"rich>=13.6.0\",\n+# ]\n+# ///\n+from __future__ import annotations\n+\n+import argparse\n+import ast\n+import sys\n+from pathlib import Path\n+\n+sys.path.insert(0, str(Path(__file__).parent.resolve()))\n+from common_prek_utils import console\n+\n+\n+def check_file_for_core_imports(file_path: Path) -> list[tuple[int, str]]:\n+    \"\"\"Check file for airflow-core imports (anything except airflow.sdk). Returns list of (line_num, import_statement).\"\"\"\n+    try:\n+        with open(file_path, encoding=\"utf-8\") as f:\n+            source = f.read()\n+            tree = ast.parse(source, filename=str(file_path))\n+    except (OSError, UnicodeDecodeError, SyntaxError):\n+        return []\n+\n+    mismatches = []\n+\n+    for node in ast.walk(tree):\n+        # for `from airflow.x import y` statements\n+        if isinstance(node, ast.ImportFrom):\n+            if (\n+                node.module\n+                and node.module.startswith(\"airflow.\")\n+                and not node.module.startswith(\"airflow.sdk\")\n+            ):\n+                import_names = \", \".join(alias.name for alias in node.names)\n+                statement = f\"from {node.module} import {import_names}\"\n+                mismatches.append((node.lineno, statement))\n+        # for `import airflow.x` statements\n+        elif isinstance(node, ast.Import):\n+            for alias in node.names:\n+                if alias.name.startswith(\"airflow.\") and not alias.name.startswith(\"airflow.sdk\"):\n+                    statement = f\"import {alias.name}\"\n+                    if alias.asname:\n+                        statement += f\" as {alias.asname}\"\n+                    mismatches.append((node.lineno, statement))\n+\n+    return mismatches\n+\n+\n+def main():\n+    parser = argparse.ArgumentParser(description=\"Check for core imports in task-sdk files\")\n+    parser.add_argument(\"files\", nargs=\"*\", help=\"Files to check\")\n+    args = parser.parse_args()\n+\n+    if not args.files:\n+        return\n+\n+    files_to_check = [Path(f) for f in args.files if f.endswith(\".py\")]",
      "comment": "Is it okay to check only Python files in the pre\u2011commit hook, as it already filters them similar to other hooks? like -files :` ^src/airflow/.*\\.py$`",
      "comment_id": 2701020324,
      "user": "Prab-27",
      "created_at": "2026-01-17T12:00:25Z",
      "url": "https://github.com/apache/airflow/pull/60676#discussion_r2701020324"
    },
    {
      "repo": "apache/airflow",
      "pr_number": 60676,
      "file_path": "scripts/ci/prek/check_core_imports_in_sdk.py",
      "line": 78,
      "side": "RIGHT",
      "diff_hunk": "@@ -0,0 +1,97 @@\n+#!/usr/bin/env python\n+#\n+# Licensed to the Apache Software Foundation (ASF) under one\n+# or more contributor license agreements.  See the NOTICE file\n+# distributed with this work for additional information\n+# regarding copyright ownership.  The ASF licenses this file\n+# to you under the Apache License, Version 2.0 (the\n+# \"License\"); you may not use this file except in compliance\n+# with the License.  You may obtain a copy of the License at\n+#\n+#   http://www.apache.org/licenses/LICENSE-2.0\n+#\n+# Unless required by applicable law or agreed to in writing,\n+# software distributed under the License is distributed on an\n+# \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+# KIND, either express or implied.  See the License for the\n+# specific language governing permissions and limitations\n+# under the License.\n+# /// script\n+# requires-python = \">=3.10,<3.11\"\n+# dependencies = [\n+#   \"rich>=13.6.0\",\n+# ]\n+# ///\n+from __future__ import annotations\n+\n+import argparse\n+import ast\n+import sys\n+from pathlib import Path\n+\n+sys.path.insert(0, str(Path(__file__).parent.resolve()))\n+from common_prek_utils import console\n+\n+\n+def check_file_for_core_imports(file_path: Path) -> list[tuple[int, str]]:\n+    \"\"\"Check file for airflow-core imports (anything except airflow.sdk). Returns list of (line_num, import_statement).\"\"\"\n+    try:\n+        with open(file_path, encoding=\"utf-8\") as f:\n+            source = f.read()\n+            tree = ast.parse(source, filename=str(file_path))\n+    except (OSError, UnicodeDecodeError, SyntaxError):\n+        return []\n+\n+    mismatches = []\n+\n+    for node in ast.walk(tree):\n+        # for `from airflow.x import y` statements\n+        if isinstance(node, ast.ImportFrom):\n+            if (\n+                node.module\n+                and node.module.startswith(\"airflow.\")\n+                and not node.module.startswith(\"airflow.sdk\")\n+            ):\n+                import_names = \", \".join(alias.name for alias in node.names)\n+                statement = f\"from {node.module} import {import_names}\"\n+                mismatches.append((node.lineno, statement))\n+        # for `import airflow.x` statements\n+        elif isinstance(node, ast.Import):\n+            for alias in node.names:\n+                if alias.name.startswith(\"airflow.\") and not alias.name.startswith(\"airflow.sdk\"):\n+                    statement = f\"import {alias.name}\"\n+                    if alias.asname:\n+                        statement += f\" as {alias.asname}\"\n+                    mismatches.append((node.lineno, statement))\n+\n+    return mismatches\n+\n+\n+def main():\n+    parser = argparse.ArgumentParser(description=\"Check for core imports in task-sdk files\")\n+    parser.add_argument(\"files\", nargs=\"*\", help=\"Files to check\")\n+    args = parser.parse_args()\n+\n+    if not args.files:\n+        return\n+\n+    files_to_check = [Path(f) for f in args.files if f.endswith(\".py\")]",
      "comment": "Does not hurt. We have to remember that you could also run the script with `uv run` - it does not have to be run with `prek`.",
      "comment_id": 2701104997,
      "user": "potiuk",
      "created_at": "2026-01-17T13:28:34Z",
      "url": "https://github.com/apache/airflow/pull/60676#discussion_r2701104997"
    },
    {
      "repo": "apache/airflow",
      "pr_number": 60676,
      "file_path": "scripts/ci/prek/check_core_imports_in_sdk.py",
      "line": 41,
      "side": "RIGHT",
      "diff_hunk": "@@ -0,0 +1,97 @@\n+#!/usr/bin/env python\n+#\n+# Licensed to the Apache Software Foundation (ASF) under one\n+# or more contributor license agreements.  See the NOTICE file\n+# distributed with this work for additional information\n+# regarding copyright ownership.  The ASF licenses this file\n+# to you under the Apache License, Version 2.0 (the\n+# \"License\"); you may not use this file except in compliance\n+# with the License.  You may obtain a copy of the License at\n+#\n+#   http://www.apache.org/licenses/LICENSE-2.0\n+#\n+# Unless required by applicable law or agreed to in writing,\n+# software distributed under the License is distributed on an\n+# \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+# KIND, either express or implied.  See the License for the\n+# specific language governing permissions and limitations\n+# under the License.\n+# /// script\n+# requires-python = \">=3.10,<3.11\"\n+# dependencies = [\n+#   \"rich>=13.6.0\",\n+# ]\n+# ///\n+from __future__ import annotations\n+\n+import argparse\n+import ast\n+import sys\n+from pathlib import Path\n+\n+sys.path.insert(0, str(Path(__file__).parent.resolve()))\n+from common_prek_utils import console\n+\n+\n+def check_file_for_core_imports(file_path: Path) -> list[tuple[int, str]]:\n+    \"\"\"Check file for airflow-core imports (anything except airflow.sdk). Returns list of (line_num, import_statement).\"\"\"\n+    try:\n+        with open(file_path, encoding=\"utf-8\") as f:\n+            source = f.read()\n+            tree = ast.parse(source, filename=str(file_path))",
      "comment": "Yep. Good suggestion - AI often generates `with open` because of vast amount of Python code out there that was historically developed. I keep on correcting my agents to replace those with open with more modern ways :) ",
      "comment_id": 2701107751,
      "user": "potiuk",
      "created_at": "2026-01-17T13:30:53Z",
      "url": "https://github.com/apache/airflow/pull/60676#discussion_r2701107751"
    },
    {
      "repo": "apache/airflow",
      "pr_number": 60676,
      "file_path": "scripts/ci/prek/check_core_imports_in_sdk.py",
      "line": 48,
      "side": "RIGHT",
      "diff_hunk": "@@ -0,0 +1,88 @@\n+#!/usr/bin/env python\n+#\n+# Licensed to the Apache Software Foundation (ASF) under one\n+# or more contributor license agreements.  See the NOTICE file\n+# distributed with this work for additional information\n+# regarding copyright ownership.  The ASF licenses this file\n+# to you under the Apache License, Version 2.0 (the\n+# \"License\"); you may not use this file except in compliance\n+# with the License.  You may obtain a copy of the License at\n+#\n+#   http://www.apache.org/licenses/LICENSE-2.0\n+#\n+# Unless required by applicable law or agreed to in writing,\n+# software distributed under the License is distributed on an\n+# \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+# KIND, either express or implied.  See the License for the\n+# specific language governing permissions and limitations\n+# under the License.\n+# /// script\n+# requires-python = \">=3.10,<3.11\"\n+# dependencies = [\n+#   \"rich>=13.6.0\",\n+# ]\n+# ///\n+from __future__ import annotations\n+\n+import argparse\n+import ast\n+import sys\n+from pathlib import Path\n+\n+sys.path.insert(0, str(Path(__file__).parent.resolve()))\n+from common_prek_utils import console\n+\n+\n+def check_file_for_core_imports(file_path: Path) -> list[tuple[int, str]]:\n+    \"\"\"Check file for airflow-core imports (anything except airflow.sdk). Returns list of (line_num, import_statement).\"\"\"\n+    try:\n+        with open(file_path, encoding=\"utf-8\") as f:\n+            source = f.read()\n+            tree = ast.parse(source, filename=str(file_path))\n+    except (OSError, UnicodeDecodeError, SyntaxError):\n+        return []\n+\n+    mismatches = []\n+\n+    for node in ast.walk(tree):\n+        if isinstance(node, ast.ImportFrom):",
      "comment": "Yep - look at our sphinx.ext code:\n\n```python\n        if isinstance(node, (ast.Import, ast.ImportFrom)):\n            for alias in node.names:\n                module_prefix = f\"{node.module}.\" if hasattr(node, \"module\") and node.module else \"\"\n                imports[alias.asname or alias.name] = f\"{module_prefix}{alias.name}\"\n```\n\nYou also should handle ast.Import",
      "comment_id": 2701116037,
      "user": "potiuk",
      "created_at": "2026-01-17T13:39:53Z",
      "url": "https://github.com/apache/airflow/pull/60676#discussion_r2701116037"
    },
    {
      "repo": "apache/airflow",
      "pr_number": 60676,
      "file_path": "scripts/ci/prek/check_core_imports_in_sdk.py",
      "line": 78,
      "side": "RIGHT",
      "diff_hunk": "@@ -0,0 +1,97 @@\n+#!/usr/bin/env python\n+#\n+# Licensed to the Apache Software Foundation (ASF) under one\n+# or more contributor license agreements.  See the NOTICE file\n+# distributed with this work for additional information\n+# regarding copyright ownership.  The ASF licenses this file\n+# to you under the Apache License, Version 2.0 (the\n+# \"License\"); you may not use this file except in compliance\n+# with the License.  You may obtain a copy of the License at\n+#\n+#   http://www.apache.org/licenses/LICENSE-2.0\n+#\n+# Unless required by applicable law or agreed to in writing,\n+# software distributed under the License is distributed on an\n+# \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+# KIND, either express or implied.  See the License for the\n+# specific language governing permissions and limitations\n+# under the License.\n+# /// script\n+# requires-python = \">=3.10,<3.11\"\n+# dependencies = [\n+#   \"rich>=13.6.0\",\n+# ]\n+# ///\n+from __future__ import annotations\n+\n+import argparse\n+import ast\n+import sys\n+from pathlib import Path\n+\n+sys.path.insert(0, str(Path(__file__).parent.resolve()))\n+from common_prek_utils import console\n+\n+\n+def check_file_for_core_imports(file_path: Path) -> list[tuple[int, str]]:\n+    \"\"\"Check file for airflow-core imports (anything except airflow.sdk). Returns list of (line_num, import_statement).\"\"\"\n+    try:\n+        with open(file_path, encoding=\"utf-8\") as f:\n+            source = f.read()\n+            tree = ast.parse(source, filename=str(file_path))\n+    except (OSError, UnicodeDecodeError, SyntaxError):\n+        return []\n+\n+    mismatches = []\n+\n+    for node in ast.walk(tree):\n+        # for `from airflow.x import y` statements\n+        if isinstance(node, ast.ImportFrom):\n+            if (\n+                node.module\n+                and node.module.startswith(\"airflow.\")\n+                and not node.module.startswith(\"airflow.sdk\")\n+            ):\n+                import_names = \", \".join(alias.name for alias in node.names)\n+                statement = f\"from {node.module} import {import_names}\"\n+                mismatches.append((node.lineno, statement))\n+        # for `import airflow.x` statements\n+        elif isinstance(node, ast.Import):\n+            for alias in node.names:\n+                if alias.name.startswith(\"airflow.\") and not alias.name.startswith(\"airflow.sdk\"):\n+                    statement = f\"import {alias.name}\"\n+                    if alias.asname:\n+                        statement += f\" as {alias.asname}\"\n+                    mismatches.append((node.lineno, statement))\n+\n+    return mismatches\n+\n+\n+def main():\n+    parser = argparse.ArgumentParser(description=\"Check for core imports in task-sdk files\")\n+    parser.add_argument(\"files\", nargs=\"*\", help=\"Files to check\")\n+    args = parser.parse_args()\n+\n+    if not args.files:\n+        return\n+\n+    files_to_check = [Path(f) for f in args.files if f.endswith(\".py\")]",
      "comment": "Wow! I didn\u2019t know about this \u2014 I tried running `uv run --script task-sdk/src/airflow/sdk/log.py`, and it's building (it has also some --python options). \r\n\r\nI felt that UV installs dependencies much faster than Breeze image building. Could I also use only `UV` tools instead of image building ? (like rebuilding the image and other things )\r\n",
      "comment_id": 2703403507,
      "user": "Prab-27",
      "created_at": "2026-01-19T06:35:37Z",
      "url": "https://github.com/apache/airflow/pull/60676#discussion_r2703403507"
    },
    {
      "repo": "apache/airflow",
      "pr_number": 60676,
      "file_path": "scripts/ci/prek/check_core_imports_in_sdk.py",
      "line": 41,
      "side": "RIGHT",
      "diff_hunk": "@@ -0,0 +1,97 @@\n+#!/usr/bin/env python\n+#\n+# Licensed to the Apache Software Foundation (ASF) under one\n+# or more contributor license agreements.  See the NOTICE file\n+# distributed with this work for additional information\n+# regarding copyright ownership.  The ASF licenses this file\n+# to you under the Apache License, Version 2.0 (the\n+# \"License\"); you may not use this file except in compliance\n+# with the License.  You may obtain a copy of the License at\n+#\n+#   http://www.apache.org/licenses/LICENSE-2.0\n+#\n+# Unless required by applicable law or agreed to in writing,\n+# software distributed under the License is distributed on an\n+# \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+# KIND, either express or implied.  See the License for the\n+# specific language governing permissions and limitations\n+# under the License.\n+# /// script\n+# requires-python = \">=3.10,<3.11\"\n+# dependencies = [\n+#   \"rich>=13.6.0\",\n+# ]\n+# ///\n+from __future__ import annotations\n+\n+import argparse\n+import ast\n+import sys\n+from pathlib import Path\n+\n+sys.path.insert(0, str(Path(__file__).parent.resolve()))\n+from common_prek_utils import console\n+\n+\n+def check_file_for_core_imports(file_path: Path) -> list[tuple[int, str]]:\n+    \"\"\"Check file for airflow-core imports (anything except airflow.sdk). Returns list of (line_num, import_statement).\"\"\"\n+    try:\n+        with open(file_path, encoding=\"utf-8\") as f:\n+            source = f.read()\n+            tree = ast.parse(source, filename=str(file_path))",
      "comment": "Good suggestion. I didn't know of that option in ast.parse",
      "comment_id": 2703517874,
      "user": "amoghrajesh",
      "created_at": "2026-01-19T07:22:21Z",
      "url": "https://github.com/apache/airflow/pull/60676#discussion_r2703517874"
    },
    {
      "repo": "apache/airflow",
      "pr_number": 60676,
      "file_path": "scripts/ci/prek/check_core_imports_in_sdk.py",
      "line": 78,
      "side": "RIGHT",
      "diff_hunk": "@@ -0,0 +1,97 @@\n+#!/usr/bin/env python\n+#\n+# Licensed to the Apache Software Foundation (ASF) under one\n+# or more contributor license agreements.  See the NOTICE file\n+# distributed with this work for additional information\n+# regarding copyright ownership.  The ASF licenses this file\n+# to you under the Apache License, Version 2.0 (the\n+# \"License\"); you may not use this file except in compliance\n+# with the License.  You may obtain a copy of the License at\n+#\n+#   http://www.apache.org/licenses/LICENSE-2.0\n+#\n+# Unless required by applicable law or agreed to in writing,\n+# software distributed under the License is distributed on an\n+# \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+# KIND, either express or implied.  See the License for the\n+# specific language governing permissions and limitations\n+# under the License.\n+# /// script\n+# requires-python = \">=3.10,<3.11\"\n+# dependencies = [\n+#   \"rich>=13.6.0\",\n+# ]\n+# ///\n+from __future__ import annotations\n+\n+import argparse\n+import ast\n+import sys\n+from pathlib import Path\n+\n+sys.path.insert(0, str(Path(__file__).parent.resolve()))\n+from common_prek_utils import console\n+\n+\n+def check_file_for_core_imports(file_path: Path) -> list[tuple[int, str]]:\n+    \"\"\"Check file for airflow-core imports (anything except airflow.sdk). Returns list of (line_num, import_statement).\"\"\"\n+    try:\n+        with open(file_path, encoding=\"utf-8\") as f:\n+            source = f.read()\n+            tree = ast.parse(source, filename=str(file_path))\n+    except (OSError, UnicodeDecodeError, SyntaxError):\n+        return []\n+\n+    mismatches = []\n+\n+    for node in ast.walk(tree):\n+        # for `from airflow.x import y` statements\n+        if isinstance(node, ast.ImportFrom):\n+            if (\n+                node.module\n+                and node.module.startswith(\"airflow.\")\n+                and not node.module.startswith(\"airflow.sdk\")\n+            ):\n+                import_names = \", \".join(alias.name for alias in node.names)\n+                statement = f\"from {node.module} import {import_names}\"\n+                mismatches.append((node.lineno, statement))\n+        # for `import airflow.x` statements\n+        elif isinstance(node, ast.Import):\n+            for alias in node.names:\n+                if alias.name.startswith(\"airflow.\") and not alias.name.startswith(\"airflow.sdk\"):\n+                    statement = f\"import {alias.name}\"\n+                    if alias.asname:\n+                        statement += f\" as {alias.asname}\"\n+                    mismatches.append((node.lineno, statement))\n+\n+    return mismatches\n+\n+\n+def main():\n+    parser = argparse.ArgumentParser(description=\"Check for core imports in task-sdk files\")\n+    parser.add_argument(\"files\", nargs=\"*\", help=\"Files to check\")\n+    args = parser.parse_args()\n+\n+    if not args.files:\n+        return\n+\n+    files_to_check = [Path(f) for f in args.files if f.endswith(\".py\")]",
      "comment": "Yep end of the day its a python script :)\r\n\r\nSure I can add filter for py files only as well",
      "comment_id": 2703529317,
      "user": "amoghrajesh",
      "created_at": "2026-01-19T07:27:19Z",
      "url": "https://github.com/apache/airflow/pull/60676#discussion_r2703529317"
    },
    {
      "repo": "apache/airflow",
      "pr_number": 60676,
      "file_path": "scripts/ci/prek/check_core_imports_in_sdk.py",
      "line": 78,
      "side": "RIGHT",
      "diff_hunk": "@@ -0,0 +1,97 @@\n+#!/usr/bin/env python\n+#\n+# Licensed to the Apache Software Foundation (ASF) under one\n+# or more contributor license agreements.  See the NOTICE file\n+# distributed with this work for additional information\n+# regarding copyright ownership.  The ASF licenses this file\n+# to you under the Apache License, Version 2.0 (the\n+# \"License\"); you may not use this file except in compliance\n+# with the License.  You may obtain a copy of the License at\n+#\n+#   http://www.apache.org/licenses/LICENSE-2.0\n+#\n+# Unless required by applicable law or agreed to in writing,\n+# software distributed under the License is distributed on an\n+# \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+# KIND, either express or implied.  See the License for the\n+# specific language governing permissions and limitations\n+# under the License.\n+# /// script\n+# requires-python = \">=3.10,<3.11\"\n+# dependencies = [\n+#   \"rich>=13.6.0\",\n+# ]\n+# ///\n+from __future__ import annotations\n+\n+import argparse\n+import ast\n+import sys\n+from pathlib import Path\n+\n+sys.path.insert(0, str(Path(__file__).parent.resolve()))\n+from common_prek_utils import console\n+\n+\n+def check_file_for_core_imports(file_path: Path) -> list[tuple[int, str]]:\n+    \"\"\"Check file for airflow-core imports (anything except airflow.sdk). Returns list of (line_num, import_statement).\"\"\"\n+    try:\n+        with open(file_path, encoding=\"utf-8\") as f:\n+            source = f.read()\n+            tree = ast.parse(source, filename=str(file_path))\n+    except (OSError, UnicodeDecodeError, SyntaxError):\n+        return []\n+\n+    mismatches = []\n+\n+    for node in ast.walk(tree):\n+        # for `from airflow.x import y` statements\n+        if isinstance(node, ast.ImportFrom):\n+            if (\n+                node.module\n+                and node.module.startswith(\"airflow.\")\n+                and not node.module.startswith(\"airflow.sdk\")\n+            ):\n+                import_names = \", \".join(alias.name for alias in node.names)\n+                statement = f\"from {node.module} import {import_names}\"\n+                mismatches.append((node.lineno, statement))\n+        # for `import airflow.x` statements\n+        elif isinstance(node, ast.Import):\n+            for alias in node.names:\n+                if alias.name.startswith(\"airflow.\") and not alias.name.startswith(\"airflow.sdk\"):\n+                    statement = f\"import {alias.name}\"\n+                    if alias.asname:\n+                        statement += f\" as {alias.asname}\"\n+                    mismatches.append((node.lineno, statement))\n+\n+    return mismatches\n+\n+\n+def main():\n+    parser = argparse.ArgumentParser(description=\"Check for core imports in task-sdk files\")\n+    parser.add_argument(\"files\", nargs=\"*\", help=\"Files to check\")\n+    args = parser.parse_args()\n+\n+    if not args.files:\n+        return\n+\n+    files_to_check = [Path(f) for f in args.files if f.endswith(\".py\")]",
      "comment": "> I felt that UV installs dependencies much faster than Breeze image building. Could I also use only UV tools instead of image building ? (like rebuilding the image and other things )\r\n\r\nUpto you. But in case of this hook it should be fine to use prek since its lightweight.\r\n\r\nWe anyways built breeze image prior to these checks for _other_ purposes so no real bottleneck there",
      "comment_id": 2703530608,
      "user": "amoghrajesh",
      "created_at": "2026-01-19T07:27:50Z",
      "url": "https://github.com/apache/airflow/pull/60676#discussion_r2703530608"
    },
    {
      "repo": "apache/airflow",
      "pr_number": 60676,
      "file_path": "scripts/ci/prek/check_core_imports_in_sdk.py",
      "line": 78,
      "side": "RIGHT",
      "diff_hunk": "@@ -0,0 +1,97 @@\n+#!/usr/bin/env python\n+#\n+# Licensed to the Apache Software Foundation (ASF) under one\n+# or more contributor license agreements.  See the NOTICE file\n+# distributed with this work for additional information\n+# regarding copyright ownership.  The ASF licenses this file\n+# to you under the Apache License, Version 2.0 (the\n+# \"License\"); you may not use this file except in compliance\n+# with the License.  You may obtain a copy of the License at\n+#\n+#   http://www.apache.org/licenses/LICENSE-2.0\n+#\n+# Unless required by applicable law or agreed to in writing,\n+# software distributed under the License is distributed on an\n+# \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+# KIND, either express or implied.  See the License for the\n+# specific language governing permissions and limitations\n+# under the License.\n+# /// script\n+# requires-python = \">=3.10,<3.11\"\n+# dependencies = [\n+#   \"rich>=13.6.0\",\n+# ]\n+# ///\n+from __future__ import annotations\n+\n+import argparse\n+import ast\n+import sys\n+from pathlib import Path\n+\n+sys.path.insert(0, str(Path(__file__).parent.resolve()))\n+from common_prek_utils import console\n+\n+\n+def check_file_for_core_imports(file_path: Path) -> list[tuple[int, str]]:\n+    \"\"\"Check file for airflow-core imports (anything except airflow.sdk). Returns list of (line_num, import_statement).\"\"\"\n+    try:\n+        with open(file_path, encoding=\"utf-8\") as f:\n+            source = f.read()\n+            tree = ast.parse(source, filename=str(file_path))\n+    except (OSError, UnicodeDecodeError, SyntaxError):\n+        return []\n+\n+    mismatches = []\n+\n+    for node in ast.walk(tree):\n+        # for `from airflow.x import y` statements\n+        if isinstance(node, ast.ImportFrom):\n+            if (\n+                node.module\n+                and node.module.startswith(\"airflow.\")\n+                and not node.module.startswith(\"airflow.sdk\")\n+            ):\n+                import_names = \", \".join(alias.name for alias in node.names)\n+                statement = f\"from {node.module} import {import_names}\"\n+                mismatches.append((node.lineno, statement))\n+        # for `import airflow.x` statements\n+        elif isinstance(node, ast.Import):\n+            for alias in node.names:\n+                if alias.name.startswith(\"airflow.\") and not alias.name.startswith(\"airflow.sdk\"):\n+                    statement = f\"import {alias.name}\"\n+                    if alias.asname:\n+                        statement += f\" as {alias.asname}\"\n+                    mismatches.append((node.lineno, statement))\n+\n+    return mismatches\n+\n+\n+def main():\n+    parser = argparse.ArgumentParser(description=\"Check for core imports in task-sdk files\")\n+    parser.add_argument(\"files\", nargs=\"*\", help=\"Files to check\")\n+    args = parser.parse_args()\n+\n+    if not args.files:\n+        return\n+\n+    files_to_check = [Path(f) for f in args.files if f.endswith(\".py\")]",
      "comment": "Handled in [suggestion from Prab-27](https://github.com/apache/airflow/pull/60676/commits/c80058c8dbbace090324e0086af0d45434c68108)",
      "comment_id": 2703539582,
      "user": "amoghrajesh",
      "created_at": "2026-01-19T07:31:18Z",
      "url": "https://github.com/apache/airflow/pull/60676#discussion_r2703539582"
    },
    {
      "repo": "apache/airflow",
      "pr_number": 60676,
      "file_path": "scripts/ci/prek/check_core_imports_in_sdk.py",
      "line": 41,
      "side": "RIGHT",
      "diff_hunk": "@@ -0,0 +1,97 @@\n+#!/usr/bin/env python\n+#\n+# Licensed to the Apache Software Foundation (ASF) under one\n+# or more contributor license agreements.  See the NOTICE file\n+# distributed with this work for additional information\n+# regarding copyright ownership.  The ASF licenses this file\n+# to you under the Apache License, Version 2.0 (the\n+# \"License\"); you may not use this file except in compliance\n+# with the License.  You may obtain a copy of the License at\n+#\n+#   http://www.apache.org/licenses/LICENSE-2.0\n+#\n+# Unless required by applicable law or agreed to in writing,\n+# software distributed under the License is distributed on an\n+# \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+# KIND, either express or implied.  See the License for the\n+# specific language governing permissions and limitations\n+# under the License.\n+# /// script\n+# requires-python = \">=3.10,<3.11\"\n+# dependencies = [\n+#   \"rich>=13.6.0\",\n+# ]\n+# ///\n+from __future__ import annotations\n+\n+import argparse\n+import ast\n+import sys\n+from pathlib import Path\n+\n+sys.path.insert(0, str(Path(__file__).parent.resolve()))\n+from common_prek_utils import console\n+\n+\n+def check_file_for_core_imports(file_path: Path) -> list[tuple[int, str]]:\n+    \"\"\"Check file for airflow-core imports (anything except airflow.sdk). Returns list of (line_num, import_statement).\"\"\"\n+    try:\n+        with open(file_path, encoding=\"utf-8\") as f:\n+            source = f.read()\n+            tree = ast.parse(source, filename=str(file_path))",
      "comment": "Handled it: [suggestion from Prab-27](https://github.com/apache/airflow/pull/60676/commits/c80058c8dbbace090324e0086af0d45434c68108)",
      "comment_id": 2703539900,
      "user": "amoghrajesh",
      "created_at": "2026-01-19T07:31:27Z",
      "url": "https://github.com/apache/airflow/pull/60676#discussion_r2703539900"
    },
    {
      "repo": "apache/airflow",
      "pr_number": 56457,
      "file_path": "providers/edge3/src/airflow/providers/edge3/cli/api_client.py",
      "line": 112,
      "side": "RIGHT",
      "diff_hunk": "@@ -92,39 +92,42 @@ def jwt_generator() -> JWTGenerator:\n     wait_timeouts=_default_wait,\n     wait_rate_limited=wait_retry_after(fallback=_default_wait),  # No infinite timeout on HTTP 429\n     before_sleep=before_sleep_log(logger, logging.WARNING),\n+    network_errors=ClientConnectionError,\n+    timeouts=ServerTimeoutError,\n )\n-def _make_generic_request(method: str, rest_path: str, data: str | None = None) -> Any:\n+async def _make_generic_request(method: str, rest_path: str, data: str | None = None) -> Any:\n     authorization = jwt_generator().generate({\"method\": rest_path})\n     api_url = conf.get(\"edge\", \"api_url\")\n+    content_type = {\"Content-Type\": \"application/json\"} if data else {}\n     headers = {\n-        \"Content-Type\": \"application/json\",\n+        **content_type,\n         \"Accept\": \"application/json\",\n         \"Authorization\": authorization,\n     }\n     api_endpoint = urljoin(api_url, rest_path)\n-    response = requests.request(method, url=api_endpoint, data=data, headers=headers)\n-    response.raise_for_status()\n-    if response.status_code == HTTPStatus.NO_CONTENT:\n-        return None\n-    return json.loads(response.content)\n+    async with request(method, url=api_endpoint, data=data, headers=headers) as response:\n+        response.raise_for_status()\n+        if response.status == HTTPStatus.NO_CONTENT:\n+            return None\n+        return json.loads(await response.read())",
      "comment": "I think here you can simply do:\r\n\r\n`return await response.json()`\r\n\r\nThe ClientResponse has an async json() method just like it's requests counterpart",
      "comment_id": 2671845461,
      "user": "dabla",
      "created_at": "2026-01-08T10:44:07Z",
      "url": "https://github.com/apache/airflow/pull/56457#discussion_r2671845461"
    },
    {
      "repo": "apache/airflow",
      "pr_number": 60543,
      "file_path": "providers/databricks/src/airflow/providers/databricks/operators/databricks_sql.py",
      "line": 167,
      "side": "RIGHT",
      "diff_hunk": "@@ -127,41 +148,151 @@ def get_db_hook(self) -> DatabricksSqlHook:\n     def _should_run_output_processing(self) -> bool:\n         return self.do_xcom_push or bool(self._output_path)\n \n+    def _is_gcs_path(self, path: str) -> bool:\n+        \"\"\"Check if the path is a GCS URI.\"\"\"\n+        return path.startswith(\"gs://\")\n+\n+    def _parse_gcs_path(self, path: str) -> tuple[str, str]:\n+        \"\"\"Parse a GCS URI into bucket and object name.\"\"\"\n+        parsed = urlparse(path)\n+        bucket = parsed.netloc\n+        object_name = parsed.path.lstrip(\"/\")\n+        return bucket, object_name\n+\n+    def _upload_to_gcs(self, local_path: str, gcs_path: str) -> None:\n+        \"\"\"Upload a local file to GCS.\"\"\"\n+        try:\n+            from airflow.providers.google.cloud.hooks.gcs import GCSHook\n+        except ImportError:\n+            raise AirflowException(",
      "comment": "```suggestion\r\n            raise AirflowOptionalProviderFeatureException(\r\n```",
      "comment_id": 2692815430,
      "user": "jason810496",
      "created_at": "2026-01-15T03:05:15Z",
      "url": "https://github.com/apache/airflow/pull/60543#discussion_r2692815430"
    },
    {
      "repo": "apache/airflow",
      "pr_number": 60543,
      "file_path": "providers/databricks/src/airflow/providers/databricks/operators/databricks_sql.py",
      "line": 288,
      "side": "RIGHT",
      "diff_hunk": "@@ -127,41 +148,151 @@ def get_db_hook(self) -> DatabricksSqlHook:\n     def _should_run_output_processing(self) -> bool:\n         return self.do_xcom_push or bool(self._output_path)\n \n+    def _is_gcs_path(self, path: str) -> bool:\n+        \"\"\"Check if the path is a GCS URI.\"\"\"\n+        return path.startswith(\"gs://\")\n+\n+    def _parse_gcs_path(self, path: str) -> tuple[str, str]:\n+        \"\"\"Parse a GCS URI into bucket and object name.\"\"\"\n+        parsed = urlparse(path)\n+        bucket = parsed.netloc\n+        object_name = parsed.path.lstrip(\"/\")\n+        return bucket, object_name\n+\n+    def _upload_to_gcs(self, local_path: str, gcs_path: str) -> None:\n+        \"\"\"Upload a local file to GCS.\"\"\"\n+        try:\n+            from airflow.providers.google.cloud.hooks.gcs import GCSHook\n+        except ImportError:\n+            raise AirflowException(\n+                \"The 'apache-airflow-providers-google' package is required for GCS output. \"\n+                \"Install it with: pip install apache-airflow-providers-google\"\n+            )\n+\n+        bucket, object_name = self._parse_gcs_path(gcs_path)\n+        hook = GCSHook(\n+            gcp_conn_id=self._gcp_conn_id,\n+            impersonation_chain=self._gcs_impersonation_chain,\n+        )\n+        hook.upload(\n+            bucket_name=bucket,\n+            object_name=object_name,\n+            filename=local_path,\n+        )\n+        self.log.info(\"Uploaded output to %s\", gcs_path)\n+\n+    def _write_parquet(self, file_path: str, field_names: list[str], rows: list[Any]) -> None:\n+        \"\"\"Write data to a Parquet file.\"\"\"\n+        import pyarrow as pa\n+        import pyarrow.parquet as pq\n+\n+        data: dict[str, list] = {name: [] for name in field_names}\n+        for row in rows:\n+            row_dict = row._asdict()\n+            for name in field_names:\n+                data[name].append(row_dict[name])\n+\n+        table = pa.Table.from_pydict(data)\n+        pq.write_table(table, file_path)\n+\n+    def _write_avro(self, file_path: str, field_names: list[str], rows: list[Any]) -> None:\n+        \"\"\"Write data to an Avro file using fastavro.\"\"\"\n+        try:\n+            from fastavro import writer\n+        except ImportError:\n+            raise AirflowException(\n+                \"The 'fastavro' package is required for Avro output. Install it with: pip install fastavro\"\n+            )\n+\n+        data: dict[str, list] = {name: [] for name in field_names}\n+        for row in rows:\n+            row_dict = row._asdict()\n+            for name in field_names:\n+                data[name].append(row_dict[name])\n+\n+        schema_fields = []\n+        for name in field_names:\n+            sample_val = next(\n+                (data[name][i] for i in range(len(data[name])) if data[name][i] is not None), None\n+            )\n+            if sample_val is None:\n+                avro_type = [\"null\", \"string\"]\n+            elif isinstance(sample_val, bool):\n+                avro_type = [\"null\", \"boolean\"]\n+            elif isinstance(sample_val, int):\n+                avro_type = [\"null\", \"long\"]\n+            elif isinstance(sample_val, float):\n+                avro_type = [\"null\", \"double\"]\n+            else:\n+                avro_type = [\"null\", \"string\"]\n+            schema_fields.append({\"name\": name, \"type\": avro_type})\n+\n+        avro_schema = {\n+            \"type\": \"record\",\n+            \"name\": \"QueryResult\",\n+            \"fields\": schema_fields,\n+        }\n+\n+        records = [row._asdict() for row in rows]\n+        with open(file_path, \"wb\") as f:\n+            writer(f, avro_schema, records)\n+\n     def _process_output(self, results: list[Any], descriptions: list[Sequence[Sequence] | None]) -> list[Any]:\n         if not self._output_path:\n             return list(zip(descriptions, results))\n         if not self._output_format:\n             raise AirflowException(\"Output format should be specified!\")\n-        # Output to a file only the result of last query\n+\n         last_description = descriptions[-1]\n         last_results = results[-1]\n         if last_description is None:\n-            raise AirflowException(\"There is missing description present for the output file. .\")\n+            raise AirflowException(\"There is missing description present for the output file.\")\n         field_names = [field[0] for field in last_description]\n-        if self._output_format.lower() == \"csv\":\n-            with open(self._output_path, \"w\", newline=\"\") as file:\n-                if self._csv_params:\n-                    csv_params = self._csv_params\n-                else:\n-                    csv_params = {}\n-                write_header = csv_params.get(\"header\", True)\n-                if \"header\" in csv_params:\n-                    del csv_params[\"header\"]\n-                writer = csv.DictWriter(file, fieldnames=field_names, **csv_params)\n-                if write_header:\n-                    writer.writeheader()\n-                for row in last_results:\n-                    writer.writerow(row._asdict())\n-        elif self._output_format.lower() == \"json\":\n-            with open(self._output_path, \"w\") as file:\n-                file.write(json.dumps([row._asdict() for row in last_results]))\n-        elif self._output_format.lower() == \"jsonl\":\n-            with open(self._output_path, \"w\") as file:\n-                for row in last_results:\n-                    file.write(json.dumps(row._asdict()))\n-                    file.write(\"\\n\")\n+\n+        is_gcs = self._is_gcs_path(self._output_path)\n+        if is_gcs:\n+            suffix = f\".{self._output_format.lower()}\"\n+            tmp_file = NamedTemporaryFile(mode=\"w\", suffix=suffix, delete=False, newline=\"\")\n+            local_path = tmp_file.name\n+            tmp_file.close()\n         else:\n-            raise AirflowException(f\"Unsupported output format: '{self._output_format}'\")\n+            local_path = self._output_path\n+\n+        try:\n+            output_format = self._output_format.lower()\n+            if output_format == \"csv\":\n+                with open(local_path, \"w\", newline=\"\") as file:\n+                    if self._csv_params:\n+                        csv_params = self._csv_params.copy()\n+                    else:\n+                        csv_params = {}\n+                    write_header = csv_params.pop(\"header\", True)\n+                    writer = csv.DictWriter(file, fieldnames=field_names, **csv_params)\n+                    if write_header:\n+                        writer.writeheader()\n+                    for row in last_results:\n+                        writer.writerow(row._asdict())\n+            elif output_format == \"json\":\n+                with open(local_path, \"w\") as file:\n+                    file.write(json.dumps([row._asdict() for row in last_results]))\n+            elif output_format == \"jsonl\":\n+                with open(local_path, \"w\") as file:\n+                    for row in last_results:\n+                        file.write(json.dumps(row._asdict()))\n+                        file.write(\"\\n\")\n+            elif output_format == \"parquet\":\n+                self._write_parquet(local_path, field_names, last_results)\n+            elif output_format == \"avro\":\n+                self._write_avro(local_path, field_names, last_results)\n+            else:\n+                raise AirflowException(f\"Unsupported output format: '{self._output_format}'\")",
      "comment": "```suggestion\r\n                raise ValueError(f\"Unsupported output format: '{self._output_format}'\")\r\n```",
      "comment_id": 2692823007,
      "user": "jason810496",
      "created_at": "2026-01-15T03:08:23Z",
      "url": "https://github.com/apache/airflow/pull/60543#discussion_r2692823007"
    },
    {
      "repo": "apache/airflow",
      "pr_number": 60699,
      "file_path": "scripts/ci/prek/check_notice_files.py",
      "line": 51,
      "side": "RIGHT",
      "diff_hunk": "@@ -0,0 +1,53 @@\n+#!/usr/bin/env python\n+# Licensed to the Apache Software Foundation (ASF) under one\n+# or more contributor license agreements.  See the NOTICE file\n+# distributed with this work for additional information\n+# regarding copyright ownership.  The ASF licenses this file\n+# to you under the Apache License, Version 2.0 (the\n+# \"License\"); you may not use this file except in compliance\n+# with the License.  You may obtain a copy of the License at\n+#\n+#   http://www.apache.org/licenses/LICENSE-2.0\n+#\n+# Unless required by applicable law or agreed to in writing,\n+# software distributed under the License is distributed on an\n+# \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+# KIND, either express or implied.  See the License for the\n+# specific language governing permissions and limitations\n+# under the License.\n+# /// script\n+# requires-python = \">=3.10\"\n+# dependencies = []\n+# ///\n+\"\"\"\n+Check that NOTICE files contain the current year and Apache Software Foundation reference.\n+\n+This script validates NOTICE files to ensure they:\n+- Include the current year in copyright statements\n+- Reference the Apache Software Foundation\n+\n+Usage: check_notice_files.py <notice_file_paths...>\n+\"\"\"\n+\n+from __future__ import annotations\n+\n+import sys\n+from datetime import datetime\n+from pathlib import Path\n+\n+CURRENT_YEAR = str(datetime.now().year)\n+\n+errors = 0\n+\n+for notice_file in sys.argv[1:]:\n+    content = Path(notice_file).read_text()\n+\n+    if \"Copyright\" in content and CURRENT_YEAR not in content:\n+        print(f\"\u274c {notice_file}: Missing current year ({CURRENT_YEAR}) in copyright\")\n+        errors += 1\n+\n+    if \"Apache Software Foundation\" not in content:\n+        print(f\"\u274c {notice_file}: Missing 'Apache Software Foundation' reference\")\n+        errors += 1",
      "comment": "I just found that the format is `Copyright 2016-{CURRENT_YEAR} The Apache Software Foundation`, not sure whether it would be bette to use f-string approach.\r\n\r\n```suggestion\r\n    expected = f\"Copyright 2016-{CURRENT_YEAR} The Apache Software Foundation\"\r\n    if \"Copyright\" in content and expected not in content:\r\n        print(f\"\u274c {notice_file}: Missing expected string: {expected!r}\")\r\n        errors += 1\r\n```",
      "comment_id": 2701046292,
      "user": "jason810496",
      "created_at": "2026-01-17T12:27:21Z",
      "url": "https://github.com/apache/airflow/pull/60699#discussion_r2701046292"
    },
    {
      "repo": "apache/airflow",
      "pr_number": 60392,
      "file_path": "airflow-core/tests/unit/api_fastapi/core_api/routes/ui/test_connections.py",
      "line": 98,
      "side": "RIGHT",
      "diff_hunk": "@@ -58,6 +58,48 @@ def test_hook_meta_data(self, test_client):\n                 },\n                 {\"secret_key\": \"***\", \"extra_fields\": \"test-extra_fields\", \"password\": \"***\"},\n             ),\n+            (\n+                {\n+                    \"auth_type\": {\n+                        \"value\": \"oauth2\",\n+                        \"schema\": {\n+                            \"type\": [\"string\", \"null\"],\n+                            \"title\": \"Auth Type\",\n+                        },\n+                        \"description\": \"Authentication type: 'basic' (default) | 'oauth2'\",\n+                        \"source\": None,\n+                    },\n+                    \"access_token\": {  # sensitive field\n+                        \"value\": \"oauth2-bearer-token\",\n+                        \"schema\": {\n+                            \"type\": [\"string\", \"null\"],  # Optional field\n+                            \"title\": \"Access Token\",\n+                        },\n+                        \"description\": \"OAuth 2 bearer (one-hour).\",\n+                        \"source\": None,\n+                    },\n+                },\n+                {\n+                    \"auth_type\": {\n+                        \"value\": \"oauth2\",\n+                        \"schema\": {\n+                            \"type\": [\"string\", \"null\"],\n+                            \"title\": \"Auth Type\",\n+                        },\n+                        \"description\": \"Authentication type: 'basic' (default) | 'oauth2'\",\n+                        \"source\": None,\n+                    },\n+                    \"access_token\": {  # sensitive field - masked but schema.type preserved\n+                        \"value\": \"***\",\n+                        \"schema\": {\n+                            \"type\": [\"string\", \"null\"],  # Should be preserved\n+                            \"title\": \"***\",\n+                        },\n+                        \"description\": \"***\",",
      "comment": "Based on the expected result of test cases, do we need to preserve the \"schema .title\" and \"description\" as well?",
      "comment_id": 2682387351,
      "user": "jason810496",
      "created_at": "2026-01-12T13:56:18Z",
      "url": "https://github.com/apache/airflow/pull/60392#discussion_r2682387351"
    },
    {
      "repo": "apache/airflow",
      "pr_number": 60392,
      "file_path": "airflow-core/tests/unit/api_fastapi/core_api/routes/ui/test_connections.py",
      "line": 98,
      "side": "RIGHT",
      "diff_hunk": "@@ -58,6 +58,48 @@ def test_hook_meta_data(self, test_client):\n                 },\n                 {\"secret_key\": \"***\", \"extra_fields\": \"test-extra_fields\", \"password\": \"***\"},\n             ),\n+            (\n+                {\n+                    \"auth_type\": {\n+                        \"value\": \"oauth2\",\n+                        \"schema\": {\n+                            \"type\": [\"string\", \"null\"],\n+                            \"title\": \"Auth Type\",\n+                        },\n+                        \"description\": \"Authentication type: 'basic' (default) | 'oauth2'\",\n+                        \"source\": None,\n+                    },\n+                    \"access_token\": {  # sensitive field\n+                        \"value\": \"oauth2-bearer-token\",\n+                        \"schema\": {\n+                            \"type\": [\"string\", \"null\"],  # Optional field\n+                            \"title\": \"Access Token\",\n+                        },\n+                        \"description\": \"OAuth 2 bearer (one-hour).\",\n+                        \"source\": None,\n+                    },\n+                },\n+                {\n+                    \"auth_type\": {\n+                        \"value\": \"oauth2\",\n+                        \"schema\": {\n+                            \"type\": [\"string\", \"null\"],\n+                            \"title\": \"Auth Type\",\n+                        },\n+                        \"description\": \"Authentication type: 'basic' (default) | 'oauth2'\",\n+                        \"source\": None,\n+                    },\n+                    \"access_token\": {  # sensitive field - masked but schema.type preserved\n+                        \"value\": \"***\",\n+                        \"schema\": {\n+                            \"type\": [\"string\", \"null\"],  # Should be preserved\n+                            \"title\": \"***\",\n+                        },\n+                        \"description\": \"***\",",
      "comment": "Thanks for the review!\r\n\r\nI initially misunderstood the previous implementation - I thought it was intentionally masking everything (including schema.title and description) and accidentally masked schema.type as well. However, only the `value` field should be masked for sensitive fields.\r\n\r\nI'll update the code to mask only the `value` field.\r\n\r\nThanks for catching this!",
      "comment_id": 2682533899,
      "user": "yuseok89",
      "created_at": "2026-01-12T14:32:38Z",
      "url": "https://github.com/apache/airflow/pull/60392#discussion_r2682533899"
    },
    {
      "repo": "apache/airflow",
      "pr_number": 60392,
      "file_path": "airflow-core/tests/unit/api_fastapi/core_api/routes/ui/test_connections.py",
      "line": 98,
      "side": "RIGHT",
      "diff_hunk": "@@ -58,6 +58,48 @@ def test_hook_meta_data(self, test_client):\n                 },\n                 {\"secret_key\": \"***\", \"extra_fields\": \"test-extra_fields\", \"password\": \"***\"},\n             ),\n+            (\n+                {\n+                    \"auth_type\": {\n+                        \"value\": \"oauth2\",\n+                        \"schema\": {\n+                            \"type\": [\"string\", \"null\"],\n+                            \"title\": \"Auth Type\",\n+                        },\n+                        \"description\": \"Authentication type: 'basic' (default) | 'oauth2'\",\n+                        \"source\": None,\n+                    },\n+                    \"access_token\": {  # sensitive field\n+                        \"value\": \"oauth2-bearer-token\",\n+                        \"schema\": {\n+                            \"type\": [\"string\", \"null\"],  # Optional field\n+                            \"title\": \"Access Token\",\n+                        },\n+                        \"description\": \"OAuth 2 bearer (one-hour).\",\n+                        \"source\": None,\n+                    },\n+                },\n+                {\n+                    \"auth_type\": {\n+                        \"value\": \"oauth2\",\n+                        \"schema\": {\n+                            \"type\": [\"string\", \"null\"],\n+                            \"title\": \"Auth Type\",\n+                        },\n+                        \"description\": \"Authentication type: 'basic' (default) | 'oauth2'\",\n+                        \"source\": None,\n+                    },\n+                    \"access_token\": {  # sensitive field - masked but schema.type preserved\n+                        \"value\": \"***\",\n+                        \"schema\": {\n+                            \"type\": [\"string\", \"null\"],  # Should be preserved\n+                            \"title\": \"***\",\n+                        },\n+                        \"description\": \"***\",",
      "comment": "@jason810496\r\nI've updated the implementation.\r\nThe code now masks only the `value` field for sensitive fields in param spec structures, preserving schema.type, schema.title, and description.\r\n\r\nCould you please take another look when you have a chance?\r\nThanks!",
      "comment_id": 2682699547,
      "user": "yuseok89",
      "created_at": "2026-01-12T15:12:30Z",
      "url": "https://github.com/apache/airflow/pull/60392#discussion_r2682699547"
    },
    {
      "repo": "apache/airflow",
      "pr_number": 60392,
      "file_path": "airflow-core/src/airflow/api_fastapi/core_api/datamodels/connections.py",
      "line": 151,
      "side": "RIGHT",
      "diff_hunk": "@@ -129,6 +129,28 @@ def redact_extra_fields(cls, v: Mapping | None):\n         if v is None:\n             return None\n \n+        # Check if extra_fields contains param spec structures (result of SerializedParam.dump())\n+        # which have \"value\" and \"schema\" keys, or simple dictionary structures\n+        has_param_spec_structure = any(\n+            isinstance(field_spec, dict) and \"value\" in field_spec and \"schema\" in field_spec\n+            for field_spec in v.values()\n+        )\n+\n+        if has_param_spec_structure:\n+            redacted_extra_fields = {}\n+            for field_name, field_spec in v.items():\n+                if isinstance(field_spec, dict) and \"value\" in field_spec and \"schema\" in field_spec:\n+                    if should_hide_value_for_key(field_name) and field_spec.get(\"value\") is not None:\n+                        # Mask only the value, preserve everything else including schema.type\n+                        redacted_extra_fields[field_name] = {**field_spec, \"value\": \"***\"}\n+                    else:\n+                        # Not sensitive or no value, keep as is\n+                        redacted_extra_fields[field_name] = field_spec\n+                else:\n+                    # Not a param spec structure, keep as is\n+                    redacted_extra_fields[field_name] = field_spec",
      "comment": "For the else case here, would it be better to add `redact` by default?\r\n\r\n```suggestion\r\n                    # Not a param spec structure, keep as is\r\n                    redacted_extra_fields[field_name] = redact(field_spec)\r\n```\r\n\r\n",
      "comment_id": 2697341569,
      "user": "jason810496",
      "created_at": "2026-01-16T07:39:29Z",
      "url": "https://github.com/apache/airflow/pull/60392#discussion_r2697341569"
    },
    {
      "repo": "apache/airflow",
      "pr_number": 60392,
      "file_path": "airflow-core/src/airflow/api_fastapi/core_api/datamodels/connections.py",
      "line": 151,
      "side": "RIGHT",
      "diff_hunk": "@@ -129,6 +129,28 @@ def redact_extra_fields(cls, v: Mapping | None):\n         if v is None:\n             return None\n \n+        # Check if extra_fields contains param spec structures (result of SerializedParam.dump())\n+        # which have \"value\" and \"schema\" keys, or simple dictionary structures\n+        has_param_spec_structure = any(\n+            isinstance(field_spec, dict) and \"value\" in field_spec and \"schema\" in field_spec\n+            for field_spec in v.values()\n+        )\n+\n+        if has_param_spec_structure:\n+            redacted_extra_fields = {}\n+            for field_name, field_spec in v.items():\n+                if isinstance(field_spec, dict) and \"value\" in field_spec and \"schema\" in field_spec:\n+                    if should_hide_value_for_key(field_name) and field_spec.get(\"value\") is not None:\n+                        # Mask only the value, preserve everything else including schema.type\n+                        redacted_extra_fields[field_name] = {**field_spec, \"value\": \"***\"}\n+                    else:\n+                        # Not sensitive or no value, keep as is\n+                        redacted_extra_fields[field_name] = field_spec\n+                else:\n+                    # Not a param spec structure, keep as is\n+                    redacted_extra_fields[field_name] = field_spec",
      "comment": "Thanks for the suggestion! This ensures that non-param-spec fields are also properly redacted if they're sensitive, which is more consistent and secure.",
      "comment_id": 2698437813,
      "user": "yuseok89",
      "created_at": "2026-01-16T13:02:31Z",
      "url": "https://github.com/apache/airflow/pull/60392#discussion_r2698437813"
    },
    {
      "repo": "apache/airflow",
      "pr_number": 59918,
      "file_path": "airflow-core/src/airflow/utils/db_cleanup.py",
      "line": 187,
      "side": "RIGHT",
      "diff_hunk": "@@ -183,17 +184,17 @@ def readable_config(self):\n config_dict: dict[str, _TableConfig] = {x.orm_model.name: x for x in sorted(config_list)}\n \n \n-def _check_for_rows(*, query: Query, print_rows: bool = False) -> int:\n-    num_entities = query.count()\n+def _check_for_rows(*, query: Select, print_rows: bool = False, session: Session) -> int:",
      "comment": "Should query be renamed to statement(select_stmt) too?",
      "comment_id": 2660979704,
      "user": "ephraimbuddy",
      "created_at": "2026-01-05T10:14:47Z",
      "url": "https://github.com/apache/airflow/pull/59918#discussion_r2660979704"
    },
    {
      "repo": "apache/airflow",
      "pr_number": 59918,
      "file_path": "airflow-core/src/airflow/utils/db_cleanup.py",
      "line": 187,
      "side": "RIGHT",
      "diff_hunk": "@@ -183,17 +184,17 @@ def readable_config(self):\n config_dict: dict[str, _TableConfig] = {x.orm_model.name: x for x in sorted(config_list)}\n \n \n-def _check_for_rows(*, query: Query, print_rows: bool = False) -> int:\n-    num_entities = query.count()\n+def _check_for_rows(*, query: Select, print_rows: bool = False, session: Session) -> int:",
      "comment": "Good point! Renamed `query` to `statement` in `_check_for_rows` and `_do_delete` for consistency with SQLAlchemy 2.0 terminology. Thanks!",
      "comment_id": 2661017732,
      "user": "ricky-chaoju",
      "created_at": "2026-01-05T10:28:28Z",
      "url": "https://github.com/apache/airflow/pull/59918#discussion_r2661017732"
    },
    {
      "repo": "apache/airflow",
      "pr_number": 59918,
      "file_path": "airflow-core/src/airflow/utils/db_cleanup.py",
      "line": 230,
      "side": "RIGHT",
      "diff_hunk": "@@ -223,8 +224,10 @@ def _do_delete(\n     batch_counter = itertools.count(1)\n \n     while True:\n-        limited_query = query.limit(batch_size) if batch_size else query\n-        if limited_query.count() == 0:  # nothing left to delete\n+        limited_statement = statement.limit(batch_size) if batch_size else statement\n+        if (\n+            session.execute(select(func.count()).select_from(limited_statement.subquery())).scalar() or 0\n+        ) == 0:",
      "comment": "What if we directly use `(session.scalar() or 0)` ? (It's just my point of view)\r\n\r\nCould you please share your thoughts on this ? ",
      "comment_id": 2667880573,
      "user": "Prab-27",
      "created_at": "2026-01-07T10:26:32Z",
      "url": "https://github.com/apache/airflow/pull/59918#discussion_r2667880573"
    },
    {
      "repo": "apache/airflow",
      "pr_number": 59918,
      "file_path": "airflow-core/src/airflow/utils/db_cleanup.py",
      "line": 230,
      "side": "RIGHT",
      "diff_hunk": "@@ -223,8 +224,10 @@ def _do_delete(\n     batch_counter = itertools.count(1)\n \n     while True:\n-        limited_query = query.limit(batch_size) if batch_size else query\n-        if limited_query.count() == 0:  # nothing left to delete\n+        limited_statement = statement.limit(batch_size) if batch_size else statement\n+        if (\n+            session.execute(select(func.count()).select_from(limited_statement.subquery())).scalar() or 0\n+        ) == 0:",
      "comment": "Yeah, that makes sense.\r\nUsing session.scalar(...) or 0 is simpler and reads better here.\r\nI\u2019ve updated it accordingly.",
      "comment_id": 2667972334,
      "user": "ricky-chaoju",
      "created_at": "2026-01-07T10:55:55Z",
      "url": "https://github.com/apache/airflow/pull/59918#discussion_r2667972334"
    },
    {
      "repo": "apache/airflow",
      "pr_number": 59918,
      "file_path": "airflow-core/src/airflow/utils/db_cleanup.py",
      "line": 339,
      "side": "RIGHT",
      "diff_hunk": "@@ -332,10 +333,10 @@ def _build_query(\n     dag_ids: list[str] | None = None,\n     exclude_dag_ids: list[str] | None = None,\n     **kwargs,\n-) -> Query:\n+) -> Select:\n     base_table_alias = \"base\"\n     base_table = aliased(orm_model, name=base_table_alias)\n-    query = session.query(base_table).with_entities(text(f\"{base_table_alias}.*\"))\n+    query = select(text(f\"{base_table_alias}.*\")).select_from(base_table)",
      "comment": "OK! Renamed query to statement to better reflect that it's now a Select object rather than a Query object.",
      "comment_id": 2671503732,
      "user": "ricky-chaoju",
      "created_at": "2026-01-08T09:03:11Z",
      "url": "https://github.com/apache/airflow/pull/59918#discussion_r2671503732"
    },
    {
      "repo": "apache/airflow",
      "pr_number": 59918,
      "file_path": "airflow-core/src/airflow/jobs/scheduler_job_runner.py",
      "line": 2437,
      "side": "RIGHT",
      "diff_hunk": "@@ -2432,19 +2432,23 @@ def _get_num_times_stuck_in_queued(self, ti: TaskInstance, session: Session = NE\n             .limit(1)\n         )\n \n-        query = session.query(Log).where(\n-            Log.task_id == ti.task_id,\n-            Log.dag_id == ti.dag_id,\n-            Log.run_id == ti.run_id,\n-            Log.map_index == ti.map_index,\n-            Log.try_number == ti.try_number,\n-            Log.event == TASK_STUCK_IN_QUEUED_RESCHEDULE_EVENT,\n+        statement = (\n+            select(func.count())\n+            .select_from(Log)",
      "comment": "This also works fine but we can also customize it to use only `select()` and not `func.count()` here since above query is not using this and we applied it in `count_result `\n\nWhat do you think ? ",
      "comment_id": 2700593686,
      "user": "Prab-27",
      "created_at": "2026-01-17T03:32:11Z",
      "url": "https://github.com/apache/airflow/pull/59918#discussion_r2700593686"
    },
    {
      "repo": "apache/airflow",
      "pr_number": 59918,
      "file_path": "airflow-core/src/airflow/utils/db_cleanup.py",
      "line": 230,
      "side": "LEFT",
      "diff_hunk": "@@ -224,10 +224,8 @@ def _do_delete(\n     batch_counter = itertools.count(1)\n \n     while True:\n-        limited_query = query.limit(batch_size) if batch_size else query\n-        if (\n-            session.scalars(select(func.count()).select_from(limited_query.subquery())).one() == 0\n-        ):  # nothing left to delete",
      "comment": "It's also good to add this comment in the` if` statement as it is \n\nWDYT ? ",
      "comment_id": 2700596985,
      "user": "Prab-27",
      "created_at": "2026-01-17T03:35:15Z",
      "url": "https://github.com/apache/airflow/pull/59918#discussion_r2700596985"
    },
    {
      "repo": "apache/airflow",
      "pr_number": 59918,
      "file_path": "airflow-core/src/airflow/jobs/scheduler_job_runner.py",
      "line": 2437,
      "side": "RIGHT",
      "diff_hunk": "@@ -2432,19 +2432,23 @@ def _get_num_times_stuck_in_queued(self, ti: TaskInstance, session: Session = NE\n             .limit(1)\n         )\n \n-        query = session.query(Log).where(\n-            Log.task_id == ti.task_id,\n-            Log.dag_id == ti.dag_id,\n-            Log.run_id == ti.run_id,\n-            Log.map_index == ti.map_index,\n-            Log.try_number == ti.try_number,\n-            Log.event == TASK_STUCK_IN_QUEUED_RESCHEDULE_EVENT,\n+        statement = (\n+            select(func.count())\n+            .select_from(Log)",
      "comment": "I think `func.count()` is the right approach here since we need to count matching rows. The query above (`select(Log.dttm)`) fetches a datetime value, which has a different purpose. Using `func.count()` performs the counting in the database efficiently, whereas alternatives like `len(session.scalars(...).all())` would fetch all rows to Python first. ",
      "comment_id": 2700649049,
      "user": "ricky-chaoju",
      "created_at": "2026-01-17T05:12:01Z",
      "url": "https://github.com/apache/airflow/pull/59918#discussion_r2700649049"
    },
    {
      "repo": "apache/airflow",
      "pr_number": 59918,
      "file_path": "airflow-core/src/airflow/jobs/scheduler_job_runner.py",
      "line": 2437,
      "side": "RIGHT",
      "diff_hunk": "@@ -2432,19 +2432,23 @@ def _get_num_times_stuck_in_queued(self, ti: TaskInstance, session: Session = NE\n             .limit(1)\n         )\n \n-        query = session.query(Log).where(\n-            Log.task_id == ti.task_id,\n-            Log.dag_id == ti.dag_id,\n-            Log.run_id == ti.run_id,\n-            Log.map_index == ti.map_index,\n-            Log.try_number == ti.try_number,\n-            Log.event == TASK_STUCK_IN_QUEUED_RESCHEDULE_EVENT,\n+        statement = (\n+            select(func.count())\n+            .select_from(Log)",
      "comment": "Yes ! You are right !! but what if  - (It's just my thought)\n\n```\nstatement =  select(Log).where(\n            Log.task_id == ti.task_id,\n            Log.dag_id == ti.dag_id,\n            Log.run_id == ti.run_id,\n            Log.map_index == ti.map_index,\n            Log.try_number == ti.try_number,\n            Log.event == TASK_STUCK_IN_QUEUED_RESCHEDULE_EVENT,\n\n```\nand we can use `func.count` in `count_result`  like `session.scalar(select(func.count(statement)).select_from(Log)`\n\nI apologize if I created any confusion here\n",
      "comment_id": 2700658277,
      "user": "Prab-27",
      "created_at": "2026-01-17T05:27:52Z",
      "url": "https://github.com/apache/airflow/pull/59918#discussion_r2700658277"
    },
    {
      "repo": "apache/airflow",
      "pr_number": 59918,
      "file_path": "airflow-core/src/airflow/jobs/scheduler_job_runner.py",
      "line": 2437,
      "side": "RIGHT",
      "diff_hunk": "@@ -2432,19 +2432,23 @@ def _get_num_times_stuck_in_queued(self, ti: TaskInstance, session: Session = NE\n             .limit(1)\n         )\n \n-        query = session.query(Log).where(\n-            Log.task_id == ti.task_id,\n-            Log.dag_id == ti.dag_id,\n-            Log.run_id == ti.run_id,\n-            Log.map_index == ti.map_index,\n-            Log.try_number == ti.try_number,\n-            Log.event == TASK_STUCK_IN_QUEUED_RESCHEDULE_EVENT,\n+        statement = (\n+            select(func.count())\n+            .select_from(Log)",
      "comment": "Thanks for the suggestion! I tested both approaches:\r\nCurrent approach:\r\n```select(func.count()).select_from(Log).where(...)```\r\nGenerates:\r\n```SELECT count(*) FROM log WHERE ...```\r\n\r\nSeparated approach:\r\n```\r\nstatement = select(Log).where(...)\r\nselect(func.count(statement)).select_from(Log)\r\n```\r\nGenerates:\r\n```SELECT count((SELECT log.id, log.task_id FROM log WHERE ...)) FROM log```\r\n\r\nThis triggers a SQLAlchemy warning about implicit coercion and produces unexpected SQL.\r\n\r\nThe current approach generates the cleanest and most efficient query. What do you think? Please correct me if I'm wrong.",
      "comment_id": 2700668485,
      "user": "ricky-chaoju",
      "created_at": "2026-01-17T05:48:14Z",
      "url": "https://github.com/apache/airflow/pull/59918#discussion_r2700668485"
    },
    {
      "repo": "apache/airflow",
      "pr_number": 59918,
      "file_path": "airflow-core/src/airflow/jobs/scheduler_job_runner.py",
      "line": 2437,
      "side": "RIGHT",
      "diff_hunk": "@@ -2432,19 +2432,23 @@ def _get_num_times_stuck_in_queued(self, ti: TaskInstance, session: Session = NE\n             .limit(1)\n         )\n \n-        query = session.query(Log).where(\n-            Log.task_id == ti.task_id,\n-            Log.dag_id == ti.dag_id,\n-            Log.run_id == ti.run_id,\n-            Log.map_index == ti.map_index,\n-            Log.try_number == ti.try_number,\n-            Log.event == TASK_STUCK_IN_QUEUED_RESCHEDULE_EVENT,\n+        statement = (\n+            select(func.count())\n+            .select_from(Log)",
      "comment": "Thanks !! \r\n\r\nI need to deep dive into this and then get back to you  ",
      "comment_id": 2700673447,
      "user": "Prab-27",
      "created_at": "2026-01-17T05:56:50Z",
      "url": "https://github.com/apache/airflow/pull/59918#discussion_r2700673447"
    },
    {
      "repo": "apache/airflow",
      "pr_number": 59918,
      "file_path": "airflow-core/src/airflow/jobs/scheduler_job_runner.py",
      "line": 2437,
      "side": "RIGHT",
      "diff_hunk": "@@ -2432,19 +2432,23 @@ def _get_num_times_stuck_in_queued(self, ti: TaskInstance, session: Session = NE\n             .limit(1)\n         )\n \n-        query = session.query(Log).where(\n-            Log.task_id == ti.task_id,\n-            Log.dag_id == ti.dag_id,\n-            Log.run_id == ti.run_id,\n-            Log.map_index == ti.map_index,\n-            Log.try_number == ti.try_number,\n-            Log.event == TASK_STUCK_IN_QUEUED_RESCHEDULE_EVENT,\n+        statement = (\n+            select(func.count())\n+            .select_from(Log)",
      "comment": "Yes, you are right! This is the simplest and best approach.\nAnd if we follow that approach, we might need to use `.subquery()`, which will make it more complex\n\nThanks a lot, I learned a lot from this discussion. ",
      "comment_id": 2700693841,
      "user": "Prab-27",
      "created_at": "2026-01-17T06:34:23Z",
      "url": "https://github.com/apache/airflow/pull/59918#discussion_r2700693841"
    },
    {
      "repo": "apache/airflow",
      "pr_number": 59918,
      "file_path": "airflow-core/src/airflow/jobs/scheduler_job_runner.py",
      "line": 2437,
      "side": "RIGHT",
      "diff_hunk": "@@ -2432,19 +2432,23 @@ def _get_num_times_stuck_in_queued(self, ti: TaskInstance, session: Session = NE\n             .limit(1)\n         )\n \n-        query = session.query(Log).where(\n-            Log.task_id == ti.task_id,\n-            Log.dag_id == ti.dag_id,\n-            Log.run_id == ti.run_id,\n-            Log.map_index == ti.map_index,\n-            Log.try_number == ti.try_number,\n-            Log.event == TASK_STUCK_IN_QUEUED_RESCHEDULE_EVENT,\n+        statement = (\n+            select(func.count())\n+            .select_from(Log)",
      "comment": "Thanks for raising the question and for the review!",
      "comment_id": 2700733370,
      "user": "ricky-chaoju",
      "created_at": "2026-01-17T07:46:24Z",
      "url": "https://github.com/apache/airflow/pull/59918#discussion_r2700733370"
    },
    {
      "repo": "apache/airflow",
      "pr_number": 44279,
      "file_path": "providers/src/airflow/providers/google/cloud/operators/bigquery.py",
      "line": 2596,
      "side": "RIGHT",
      "diff_hunk": "@@ -2592,8 +2592,15 @@ def _submit_job(\n             nowait=True,\n         )\n \n-    @staticmethod\n-    def _handle_job_error(job: BigQueryJob | UnknownJob) -> None:\n+    def _handle_job_error(self, job: BigQueryJob | UnknownJob) -> None:\n+        self.log.debug(\"Job %s is completed. checking the job status\", self.job_id)",
      "comment": "```suggestion\r\n        self.log.debug(\"Job %s is completed. Checking the job status\", self.job_id)\r\n```",
      "comment_id": 1853416369,
      "user": "ephraimbuddy",
      "created_at": "2024-11-22T07:43:59Z",
      "url": "https://github.com/apache/airflow/pull/44279#discussion_r1853416369"
    },
    {
      "repo": "apache/airflow",
      "pr_number": 44279,
      "file_path": "providers/src/airflow/providers/google/cloud/operators/bigquery.py",
      "line": 2599,
      "side": "RIGHT",
      "diff_hunk": "@@ -2592,8 +2592,15 @@ def _submit_job(\n             nowait=True,\n         )\n \n-    @staticmethod\n-    def _handle_job_error(job: BigQueryJob | UnknownJob) -> None:\n+    def _handle_job_error(self, job: BigQueryJob | UnknownJob) -> None:\n+        self.log.info(\"Job %s is completed. Checking the job status\", self.job_id)\n+        # I've noticed that sometimes BigQuery jobs transiently report the wrong status, causing the Airflow job to be incorrectly marked as successful.\n+        # To avoid this, we refresh the job properties before checking the final state and handling any errors.\n+        while job.state != \"DONE\":",
      "comment": "I don't follow why we should do this.\r\nIs there a bug report to BigQuery that we can track?\r\n\r\nI am very against such permanent workarounds. Airflow should not be the fixer for upstream library bugs. Its OK to do this a temporary workaround when upstream library is engaged and working on a fix but otherwise not.\r\n",
      "comment_id": 1853912328,
      "user": "eladkal",
      "created_at": "2024-11-22T13:25:37Z",
      "url": "https://github.com/apache/airflow/pull/44279#discussion_r1853912328"
    },
    {
      "repo": "apache/airflow",
      "pr_number": 44279,
      "file_path": "providers/src/airflow/providers/google/cloud/operators/bigquery.py",
      "line": 2599,
      "side": "RIGHT",
      "diff_hunk": "@@ -2592,8 +2592,15 @@ def _submit_job(\n             nowait=True,\n         )\n \n-    @staticmethod\n-    def _handle_job_error(job: BigQueryJob | UnknownJob) -> None:\n+    def _handle_job_error(self, job: BigQueryJob | UnknownJob) -> None:\n+        self.log.info(\"Job %s is completed. Checking the job status\", self.job_id)\n+        # I've noticed that sometimes BigQuery jobs transiently report the wrong status, causing the Airflow job to be incorrectly marked as successful.\n+        # To avoid this, we refresh the job properties before checking the final state and handling any errors.\n+        while job.state != \"DONE\":",
      "comment": "Hey @pankajastro and thanks for putting more details!\r\n\r\nIndeed, according to BigQuery docs - the lack of `error_result` could be considered as an expected behavior:\r\n```\r\nThe table does not include all possible HTTP errors or other networking errors. Therefore, don't assume that an error object is present in every error response from BigQuery.\r\n```\r\nTherefore, handling it with an additional `if job.state != \"DONE\"` could be sufficient for now to ensure that the operator does not report errorneous results.\r\n\r\nApplying the `while` loop on the other hand, as currently implmented in @kandharvishnu 's [PR](https://github.com/apache/airflow/blame/8fdf29d39dd315f3d7144b4bba66f348221292e6/providers/src/airflow/providers/google/cloud/operators/bigquery.py#L2688), exceeds the atomicity the operation (we already called `job.result()` that should provides a final answer - why do we need to recall it?). That makes us in this case, Airflow maintainers, responsible for handling BQ transient errors - I assume that we don't want to get there.\r\n\r\nTo sum it up, I'm ok with merging this solution as-is, with Elad's consent.",
      "comment_id": 1863373235,
      "user": "shahar1",
      "created_at": "2024-11-29T11:19:25Z",
      "url": "https://github.com/apache/airflow/pull/44279#discussion_r1863373235"
    },
    {
      "repo": "apache/airflow",
      "pr_number": 44279,
      "file_path": "providers/src/airflow/providers/google/cloud/operators/bigquery.py",
      "line": 2599,
      "side": "RIGHT",
      "diff_hunk": "@@ -2592,8 +2592,15 @@ def _submit_job(\n             nowait=True,\n         )\n \n-    @staticmethod\n-    def _handle_job_error(job: BigQueryJob | UnknownJob) -> None:\n+    def _handle_job_error(self, job: BigQueryJob | UnknownJob) -> None:\n+        self.log.info(\"Job %s is completed. Checking the job status\", self.job_id)\n+        # I've noticed that sometimes BigQuery jobs transiently report the wrong status, causing the Airflow job to be incorrectly marked as successful.\n+        # To avoid this, we refresh the job properties before checking the final state and handling any errors.\n+        while job.state != \"DONE\":",
      "comment": "@shahar1 @pankajastro \u2013 I'm suspecting that the `job.state != \"DONE\"` didn't need to be introduced here. I took a look at the client library while fixing a silent bug introduced by this PR (see fix: https://github.com/apache/airflow/pull/60679), and found that `job.result()` can only return successfully when `state=DONE` or it raises an Exception which will cause the task to fail.\r\n\r\nReferences:\r\n1. https://github.com/googleapis/python-bigquery/blob/73228432a3c821db05d898ea4a4788adf15b033d/google/cloud/bigquery/job/base.py#L990-L1016\r\n2. https://github.com/googleapis/python-bigquery/blob/73228432a3c821db05d898ea4a4788adf15b033d/google/cloud/bigquery/job/query.py#L1770-L1787\r\n\r\nAlso, per [docs](https://docs.cloud.google.com/bigquery/docs/reference/rest/v2/Job#JobStatus):\r\n> Output only. Running state of the job. Valid states include 'PENDING', 'RUNNING', and 'DONE'.\r\n\r\nSo it's very unlikely that `\"Job failed with state: PENDING|RUNNING\"` is a valid exception.\r\n\r\nLet me know your thoughts here, I can remove it in my [PR](https://github.com/apache/airflow/pull/60679) since it's somewhat related.",
      "comment_id": 2700707375,
      "user": "dejii",
      "created_at": "2026-01-17T06:53:34Z",
      "url": "https://github.com/apache/airflow/pull/44279#discussion_r2700707375"
    },
    {
      "repo": "apache/airflow",
      "pr_number": 60427,
      "file_path": "helm-tests/tests/helm_tests/airflow_core/test_worker.py",
      "line": 988,
      "side": "RIGHT",
      "diff_hunk": "@@ -970,6 +970,67 @@ def test_airflow_kerberos_init_container(\n             assert initContainers[1][\"name\"] == \"kerberos-init\"\n             assert initContainers[1][\"args\"] == [\"kerberos\", \"-o\"]\n \n+    @pytest.mark.parametrize(\n+        \"workers_values\",\n+        [\n+            {\"kerberosInitContainer\": {\"enabled\": True}},\n+            {\"celery\": {\"kerberosInitContainer\": {\"enabled\": True}}},\n+            {\n+                \"kerberosInitContainer\": {\"enabled\": False},\n+                \"celery\": {\"kerberosInitContainer\": {\"enabled\": True}},\n+            },\n+        ],\n+    )\n+    def test_airflow_kerberos_init_container_celery_values(self, workers_values):\n+        \"\"\"Test that workers.celery.kerberosInitContainer configuration works and takes precedence.\"\"\"\n+        docs = render_chart(\n+            values={\n+                \"airflowVersion\": \"2.8.0\",",
      "comment": "I think its not needed, it should work on default Airflow version",
      "comment_id": 2696179806,
      "user": "Miretpl",
      "created_at": "2026-01-15T22:24:14Z",
      "url": "https://github.com/apache/airflow/pull/60427#discussion_r2696179806"
    },
    {
      "repo": "apache/airflow",
      "pr_number": 60427,
      "file_path": "helm-tests/tests/helm_tests/airflow_core/test_worker.py",
      "line": 995,
      "side": "RIGHT",
      "diff_hunk": "@@ -970,6 +970,67 @@ def test_airflow_kerberos_init_container(\n             assert initContainers[1][\"name\"] == \"kerberos-init\"\n             assert initContainers[1][\"args\"] == [\"kerberos\", \"-o\"]\n \n+    @pytest.mark.parametrize(\n+        \"workers_values\",\n+        [\n+            {\"kerberosInitContainer\": {\"enabled\": True}},\n+            {\"celery\": {\"kerberosInitContainer\": {\"enabled\": True}}},\n+            {\n+                \"kerberosInitContainer\": {\"enabled\": False},\n+                \"celery\": {\"kerberosInitContainer\": {\"enabled\": True}},\n+            },\n+        ],\n+    )\n+    def test_airflow_kerberos_init_container_celery_values(self, workers_values):\n+        \"\"\"Test that workers.celery.kerberosInitContainer configuration works and takes precedence.\"\"\"\n+        docs = render_chart(\n+            values={\n+                \"airflowVersion\": \"2.8.0\",\n+                \"workers\": {\n+                    **workers_values,\n+                    \"celery\": {\n+                        **workers_values.get(\"celery\", {}),\n+                        \"persistence\": {\"fixPermissions\": True},\n+                    },\n+                },",
      "comment": "```python\r\n\"workers\": workers_values\r\n```\r\n`persistence` is not required for `kerberosInitContainer` to be present",
      "comment_id": 2696183728,
      "user": "Miretpl",
      "created_at": "2026-01-15T22:25:33Z",
      "url": "https://github.com/apache/airflow/pull/60427#discussion_r2696183728"
    },
    {
      "repo": "apache/airflow",
      "pr_number": 60427,
      "file_path": "helm-tests/tests/helm_tests/airflow_core/test_worker.py",
      "line": 1004,
      "side": "RIGHT",
      "diff_hunk": "@@ -970,6 +970,67 @@ def test_airflow_kerberos_init_container(\n             assert initContainers[1][\"name\"] == \"kerberos-init\"\n             assert initContainers[1][\"args\"] == [\"kerberos\", \"-o\"]\n \n+    @pytest.mark.parametrize(\n+        \"workers_values\",\n+        [\n+            {\"kerberosInitContainer\": {\"enabled\": True}},\n+            {\"celery\": {\"kerberosInitContainer\": {\"enabled\": True}}},\n+            {\n+                \"kerberosInitContainer\": {\"enabled\": False},\n+                \"celery\": {\"kerberosInitContainer\": {\"enabled\": True}},\n+            },\n+        ],\n+    )\n+    def test_airflow_kerberos_init_container_celery_values(self, workers_values):\n+        \"\"\"Test that workers.celery.kerberosInitContainer configuration works and takes precedence.\"\"\"\n+        docs = render_chart(\n+            values={\n+                \"airflowVersion\": \"2.8.0\",\n+                \"workers\": {\n+                    **workers_values,\n+                    \"celery\": {\n+                        **workers_values.get(\"celery\", {}),\n+                        \"persistence\": {\"fixPermissions\": True},\n+                    },\n+                },\n+            },\n+            show_only=[\"templates/workers/worker-deployment.yaml\"],\n+        )\n+\n+        initContainers = jmespath.search(\"spec.template.spec.initContainers\", docs[0])\n+        # Should have 3 init containers: wait-for-migrations, kerberos-init, volume-permissions\n+        assert len(initContainers) == 3\n+        assert initContainers[1][\"name\"] == \"kerberos-init\"\n+        assert initContainers[1][\"args\"] == [\"kerberos\", \"-o\"]",
      "comment": "Personally, I would split tests to test particular arguments and this one left only for testing `enabled` flag",
      "comment_id": 2696186117,
      "user": "Miretpl",
      "created_at": "2026-01-15T22:26:36Z",
      "url": "https://github.com/apache/airflow/pull/60427#discussion_r2696186117"
    },
    {
      "repo": "apache/airflow",
      "pr_number": 60268,
      "file_path": "airflow-core/src/airflow/jobs/triggerer_job_runner.py",
      "line": 817,
      "side": "RIGHT",
      "diff_hunk": "@@ -816,7 +814,7 @@ async def asend(self, msg: ToTriggerSupervisor) -> ToTriggerRunner | None:\n         frame = _RequestFrame(id=next(self.id_counter), body=msg.model_dump())\n         bytes = frame.as_bytes()\n \n-        async with self._lock:\n+        async with self._async_lock:",
      "comment": "I think I\u2019m missing something, this attribute doesn\u2019t seem to exist?",
      "comment_id": 2674323599,
      "user": "uranusjr",
      "created_at": "2026-01-09T00:14:40Z",
      "url": "https://github.com/apache/airflow/pull/60268#discussion_r2674323599"
    },
    {
      "repo": "apache/airflow",
      "pr_number": 60268,
      "file_path": "airflow-core/src/airflow/jobs/triggerer_job_runner.py",
      "line": 817,
      "side": "RIGHT",
      "diff_hunk": "@@ -816,7 +814,7 @@ async def asend(self, msg: ToTriggerSupervisor) -> ToTriggerRunner | None:\n         frame = _RequestFrame(id=next(self.id_counter), body=msg.model_dump())\n         bytes = frame.as_bytes()\n \n-        async with self._lock:\n+        async with self._async_lock:",
      "comment": "It exists in the parent class CommsDecoder, @kaxil correctly suggested that I should align those, otherwise we would have duplicate lock definitions.",
      "comment_id": 2675051994,
      "user": "dabla",
      "created_at": "2026-01-09T06:48:11Z",
      "url": "https://github.com/apache/airflow/pull/60268#discussion_r2675051994"
    },
    {
      "repo": "apache/airflow",
      "pr_number": 60268,
      "file_path": "providers/common/compat/src/airflow/providers/common/compat/standard/operators.py",
      "line": 129,
      "side": "RIGHT",
      "diff_hunk": "@@ -17,18 +17,118 @@\n \n from __future__ import annotations\n \n+from typing import TYPE_CHECKING\n+\n from airflow.providers.common.compat._compat_utils import create_module_getattr\n+from airflow.providers.common.compat.version_compat import (\n+    AIRFLOW_V_3_0_PLUS,\n+    AIRFLOW_V_3_1_PLUS,\n+    AIRFLOW_V_3_2_PLUS,\n+)\n \n _IMPORT_MAP: dict[str, str | tuple[str, ...]] = {\n     # Re-export from sdk (which handles Airflow 2.x/3.x fallbacks)\n     \"BaseOperator\": \"airflow.providers.common.compat.sdk\",\n+    \"BaseAsyncOperator\": \"airflow.providers.common.compat.sdk\",\n     \"get_current_context\": \"airflow.providers.common.compat.sdk\",\n+    \"is_async_callable\": \"airflow.providers.common.compat.sdk\",\n     # Standard provider items with direct fallbacks\n     \"PythonOperator\": (\"airflow.providers.standard.operators.python\", \"airflow.operators.python\"),\n     \"ShortCircuitOperator\": (\"airflow.providers.standard.operators.python\", \"airflow.operators.python\"),\n     \"_SERIALIZERS\": (\"airflow.providers.standard.operators.python\", \"airflow.operators.python\"),\n }\n \n+if TYPE_CHECKING:\n+    from airflow.sdk.bases.decorator import is_async_callable\n+    from airflow.sdk.bases.operator import BaseAsyncOperator\n+elif AIRFLOW_V_3_2_PLUS:\n+    from airflow.sdk.bases.decorator import is_async_callable\n+    from airflow.sdk.bases.operator import BaseAsyncOperator\n+else:\n+    import inspect\n+    from contextlib import suppress\n+    from functools import partial\n+\n+    if AIRFLOW_V_3_0_PLUS:\n+        from airflow.sdk import BaseOperator\n+        from airflow.sdk.bases.decorator import _TaskDecorator\n+        from airflow.sdk.definitions.mappedoperator import OperatorPartial\n+    else:\n+        from airflow.decorators.base import _TaskDecorator\n+        from airflow.models import BaseOperator\n+        from airflow.models.mappedoperator import OperatorPartial\n+\n+    def unwrap_partial(fn):\n+        while isinstance(fn, partial):\n+            fn = fn.func\n+        return fn\n+\n+    def unwrap_callable(func):\n+        # Airflow-specific unwrap\n+        if isinstance(func, (_TaskDecorator, OperatorPartial)):\n+            func = getattr(func, \"function\", getattr(func, \"_func\", func))\n+\n+        # Unwrap functools.partial\n+        func = unwrap_partial(func)\n+\n+        # Unwrap @functools.wraps chains\n+        with suppress(Exception):\n+            func = inspect.unwrap(func)\n+\n+        return func\n+\n+    def is_async_callable(func):\n+        \"\"\"Detect if a callable (possibly wrapped) is an async function.\"\"\"\n+        func = unwrap_callable(func)\n+\n+        if not callable(func):\n+            return False\n+\n+        # Direct async function\n+        if inspect.iscoroutinefunction(func):\n+            return True\n+\n+        # Callable object with async __call__\n+        if not inspect.isfunction(func):\n+            call = type(func).__call__  # Bandit-safe\n+            with suppress(Exception):\n+                call = inspect.unwrap(call)\n+            if inspect.iscoroutinefunction(call):\n+                return True\n+\n+        return False\n+\n+    class BaseAsyncOperator(BaseOperator):\n+        \"\"\"\n+        Base class for async-capable operators.\n+\n+        As opposed to deferred operators which are executed on the triggerer, async operators are executed\n+        on the worker.\n+        \"\"\"\n+\n+        @property\n+        def is_async(self) -> bool:\n+            return True\n+\n+        if not AIRFLOW_V_3_1_PLUS:\n+\n+            @property\n+            def xcom_push(self) -> bool:\n+                return self.do_xcom_push\n+\n+            @xcom_push.setter\n+            def xcom_push(self, value: bool):\n+                self.do_xcom_push = value\n+\n+        async def aexecute(self, context):\n+            \"\"\"Async version of execute(). Subclasses should implement this.\"\"\"\n+            raise NotImplementedError()\n+\n+        def execute(self, context):\n+            \"\"\"Run `aexecute()` inside an event loop.\"\"\"\n+            raise NotImplementedError(\"Airflow 3.2+ is required to allow executing async operators!\")",
      "comment": "Wouldn't something like this be more simpler?\n```suggestion\nif TYPE_CHECKING:\n    from airflow.sdk.bases.decorator import is_async_callable\n    from airflow.sdk.bases.operator import BaseAsyncOperator\nelif AIRFLOW_V_3_2_PLUS:\n    from airflow.sdk.bases.decorator import is_async_callable\n    from airflow.sdk.bases.operator import BaseAsyncOperator\nelse:\n    if AIRFLOW_V_3_0_PLUS:\n        from airflow.sdk import BaseOperator\n    else:\n        from airflow.models import BaseOperator\n\n    def is_async_callable(func) -> bool:\n        \"\"\"Detect async callables. \"\"\"\n        import inspect\n        from functools import partial\n        \n        while isinstance(func, partial):\n            func = func.func\n        return inspect.iscoroutinefunction(func)\n\n    class BaseAsyncOperator(BaseOperator):\n        \"\"\"Stub for AF < 3.2 that raises a clear error.\"\"\"\n        \n        @property\n        def is_async(self) -> bool:\n            return True\n\n        async def aexecute(self, context):\n            raise NotImplementedError()\n\n        def execute(self, context):\n            raise RuntimeError(\n                \"Async operators require Airflow 3.2+. \"\n                \"Upgrade Airflow or use a synchronous callable.\"\n            )\n```",
      "comment_id": 2677517026,
      "user": "kaxil",
      "created_at": "2026-01-09T20:21:04Z",
      "url": "https://github.com/apache/airflow/pull/60268#discussion_r2677517026"
    },
    {
      "repo": "apache/airflow",
      "pr_number": 60268,
      "file_path": "task-sdk/src/airflow/sdk/bases/decorator.py",
      "line": 160,
      "side": "RIGHT",
      "diff_hunk": "@@ -149,6 +150,52 @@ def _find_id_suffixes(dag: DAG) -> Iterator[int]:\n     return f\"{core}__{max(_find_id_suffixes(dag)) + 1}\"\n \n \n+def unwrap_partial(fn):\n+    while isinstance(fn, partial):\n+        fn = fn.func\n+    return fn\n+\n+\n+def unwrap_callable(func):\n+    from airflow.sdk.bases.decorator import _TaskDecorator",
      "comment": "This class is in the same file ! :) We don't need to import it",
      "comment_id": 2677523914,
      "user": "kaxil",
      "created_at": "2026-01-09T20:24:01Z",
      "url": "https://github.com/apache/airflow/pull/60268#discussion_r2677523914"
    },
    {
      "repo": "apache/airflow",
      "pr_number": 60268,
      "file_path": "task-sdk/src/airflow/sdk/bases/decorator.py",
      "line": 161,
      "side": "RIGHT",
      "diff_hunk": "@@ -149,6 +150,52 @@ def _find_id_suffixes(dag: DAG) -> Iterator[int]:\n     return f\"{core}__{max(_find_id_suffixes(dag)) + 1}\"\n \n \n+def unwrap_partial(fn):\n+    while isinstance(fn, partial):\n+        fn = fn.func\n+    return fn\n+\n+\n+def unwrap_callable(func):\n+    from airflow.sdk.bases.decorator import _TaskDecorator\n+    from airflow.sdk.definitions.mappedoperator import OperatorPartial",
      "comment": "This module is already imported at the top of the file -- just add `OperatorPartial` there",
      "comment_id": 2677525028,
      "user": "kaxil",
      "created_at": "2026-01-09T20:24:31Z",
      "url": "https://github.com/apache/airflow/pull/60268#discussion_r2677525028"
    },
    {
      "repo": "apache/airflow",
      "pr_number": 60268,
      "file_path": "task-sdk/src/airflow/sdk/bases/decorator.py",
      "line": 170,
      "side": "RIGHT",
      "diff_hunk": "@@ -149,6 +150,52 @@ def _find_id_suffixes(dag: DAG) -> Iterator[int]:\n     return f\"{core}__{max(_find_id_suffixes(dag)) + 1}\"\n \n \n+def unwrap_partial(fn):\n+    while isinstance(fn, partial):\n+        fn = fn.func\n+    return fn\n+\n+\n+def unwrap_callable(func):\n+    from airflow.sdk.bases.decorator import _TaskDecorator\n+    from airflow.sdk.definitions.mappedoperator import OperatorPartial\n+\n+    # Airflow-specific unwrap\n+    if isinstance(func, (_TaskDecorator, OperatorPartial)):\n+        func = getattr(func, \"function\", getattr(func, \"_func\", func))\n+\n+    # Unwrap functools.partial\n+    func = unwrap_partial(func)\n+\n+    # Unwrap @functools.wraps chains",
      "comment": "Worth removing this code comments -- AI sometime generates obvious / useless comments :) ",
      "comment_id": 2677526245,
      "user": "kaxil",
      "created_at": "2026-01-09T20:25:03Z",
      "url": "https://github.com/apache/airflow/pull/60268#discussion_r2677526245"
    },
    {
      "repo": "apache/airflow",
      "pr_number": 60268,
      "file_path": "providers/common/compat/src/airflow/providers/common/compat/standard/operators.py",
      "line": 61,
      "side": "RIGHT",
      "diff_hunk": "@@ -17,18 +17,118 @@\n \n from __future__ import annotations\n \n+from typing import TYPE_CHECKING\n+\n from airflow.providers.common.compat._compat_utils import create_module_getattr\n+from airflow.providers.common.compat.version_compat import (\n+    AIRFLOW_V_3_0_PLUS,\n+    AIRFLOW_V_3_1_PLUS,\n+    AIRFLOW_V_3_2_PLUS,\n+)\n \n _IMPORT_MAP: dict[str, str | tuple[str, ...]] = {\n     # Re-export from sdk (which handles Airflow 2.x/3.x fallbacks)\n     \"BaseOperator\": \"airflow.providers.common.compat.sdk\",\n+    \"BaseAsyncOperator\": \"airflow.providers.common.compat.sdk\",\n     \"get_current_context\": \"airflow.providers.common.compat.sdk\",\n+    \"is_async_callable\": \"airflow.providers.common.compat.sdk\",\n     # Standard provider items with direct fallbacks\n     \"PythonOperator\": (\"airflow.providers.standard.operators.python\", \"airflow.operators.python\"),\n     \"ShortCircuitOperator\": (\"airflow.providers.standard.operators.python\", \"airflow.operators.python\"),\n     \"_SERIALIZERS\": (\"airflow.providers.standard.operators.python\", \"airflow.operators.python\"),\n }\n \n+if TYPE_CHECKING:\n+    from airflow.sdk.bases.decorator import is_async_callable\n+    from airflow.sdk.bases.operator import BaseAsyncOperator\n+elif AIRFLOW_V_3_2_PLUS:\n+    from airflow.sdk.bases.decorator import is_async_callable\n+    from airflow.sdk.bases.operator import BaseAsyncOperator\n+else:\n+    import inspect\n+    from contextlib import suppress\n+    from functools import partial\n+\n+    if AIRFLOW_V_3_0_PLUS:\n+        from airflow.sdk import BaseOperator\n+        from airflow.sdk.bases.decorator import _TaskDecorator\n+        from airflow.sdk.definitions.mappedoperator import OperatorPartial\n+    else:\n+        from airflow.decorators.base import _TaskDecorator\n+        from airflow.models import BaseOperator\n+        from airflow.models.mappedoperator import OperatorPartial\n+\n+    def unwrap_partial(fn):",
      "comment": "```suggestion\n    def unwrap_partial(fn: Callable) -> Callable:\n```",
      "comment_id": 2677533346,
      "user": "kaxil",
      "created_at": "2026-01-09T20:27:47Z",
      "url": "https://github.com/apache/airflow/pull/60268#discussion_r2677533346"
    },
    {
      "repo": "apache/airflow",
      "pr_number": 60268,
      "file_path": "airflow-core/src/airflow/jobs/triggerer_job_runner.py",
      "line": 781,
      "side": "RIGHT",
      "diff_hunk": "@@ -780,8 +780,6 @@ class TriggerCommsDecoder(CommsDecoder[ToTriggerRunner, ToTriggerSupervisor]):\n         factory=lambda: TypeAdapter(ToTriggerRunner), repr=False\n     )",
      "comment": "Oh and I think it is worth adding a newsfragment for significant changes. This is a nice feature that deserves entry at the top of the changelog :) ",
      "comment_id": 2677563185,
      "user": "kaxil",
      "created_at": "2026-01-09T20:40:14Z",
      "url": "https://github.com/apache/airflow/pull/60268#discussion_r2677563185"
    },
    {
      "repo": "apache/airflow",
      "pr_number": 60268,
      "file_path": "providers/common/compat/src/airflow/providers/common/compat/standard/operators.py",
      "line": 129,
      "side": "RIGHT",
      "diff_hunk": "@@ -17,18 +17,118 @@\n \n from __future__ import annotations\n \n+from typing import TYPE_CHECKING\n+\n from airflow.providers.common.compat._compat_utils import create_module_getattr\n+from airflow.providers.common.compat.version_compat import (\n+    AIRFLOW_V_3_0_PLUS,\n+    AIRFLOW_V_3_1_PLUS,\n+    AIRFLOW_V_3_2_PLUS,\n+)\n \n _IMPORT_MAP: dict[str, str | tuple[str, ...]] = {\n     # Re-export from sdk (which handles Airflow 2.x/3.x fallbacks)\n     \"BaseOperator\": \"airflow.providers.common.compat.sdk\",\n+    \"BaseAsyncOperator\": \"airflow.providers.common.compat.sdk\",\n     \"get_current_context\": \"airflow.providers.common.compat.sdk\",\n+    \"is_async_callable\": \"airflow.providers.common.compat.sdk\",\n     # Standard provider items with direct fallbacks\n     \"PythonOperator\": (\"airflow.providers.standard.operators.python\", \"airflow.operators.python\"),\n     \"ShortCircuitOperator\": (\"airflow.providers.standard.operators.python\", \"airflow.operators.python\"),\n     \"_SERIALIZERS\": (\"airflow.providers.standard.operators.python\", \"airflow.operators.python\"),\n }\n \n+if TYPE_CHECKING:\n+    from airflow.sdk.bases.decorator import is_async_callable\n+    from airflow.sdk.bases.operator import BaseAsyncOperator\n+elif AIRFLOW_V_3_2_PLUS:\n+    from airflow.sdk.bases.decorator import is_async_callable\n+    from airflow.sdk.bases.operator import BaseAsyncOperator\n+else:\n+    import inspect\n+    from contextlib import suppress\n+    from functools import partial\n+\n+    if AIRFLOW_V_3_0_PLUS:\n+        from airflow.sdk import BaseOperator\n+        from airflow.sdk.bases.decorator import _TaskDecorator\n+        from airflow.sdk.definitions.mappedoperator import OperatorPartial\n+    else:\n+        from airflow.decorators.base import _TaskDecorator\n+        from airflow.models import BaseOperator\n+        from airflow.models.mappedoperator import OperatorPartial\n+\n+    def unwrap_partial(fn):\n+        while isinstance(fn, partial):\n+            fn = fn.func\n+        return fn\n+\n+    def unwrap_callable(func):\n+        # Airflow-specific unwrap\n+        if isinstance(func, (_TaskDecorator, OperatorPartial)):\n+            func = getattr(func, \"function\", getattr(func, \"_func\", func))\n+\n+        # Unwrap functools.partial\n+        func = unwrap_partial(func)\n+\n+        # Unwrap @functools.wraps chains\n+        with suppress(Exception):\n+            func = inspect.unwrap(func)\n+\n+        return func\n+\n+    def is_async_callable(func):\n+        \"\"\"Detect if a callable (possibly wrapped) is an async function.\"\"\"\n+        func = unwrap_callable(func)\n+\n+        if not callable(func):\n+            return False\n+\n+        # Direct async function\n+        if inspect.iscoroutinefunction(func):\n+            return True\n+\n+        # Callable object with async __call__\n+        if not inspect.isfunction(func):\n+            call = type(func).__call__  # Bandit-safe\n+            with suppress(Exception):\n+                call = inspect.unwrap(call)\n+            if inspect.iscoroutinefunction(call):\n+                return True\n+\n+        return False\n+\n+    class BaseAsyncOperator(BaseOperator):\n+        \"\"\"\n+        Base class for async-capable operators.\n+\n+        As opposed to deferred operators which are executed on the triggerer, async operators are executed\n+        on the worker.\n+        \"\"\"\n+\n+        @property\n+        def is_async(self) -> bool:\n+            return True\n+\n+        if not AIRFLOW_V_3_1_PLUS:\n+\n+            @property\n+            def xcom_push(self) -> bool:\n+                return self.do_xcom_push\n+\n+            @xcom_push.setter\n+            def xcom_push(self, value: bool):\n+                self.do_xcom_push = value\n+\n+        async def aexecute(self, context):\n+            \"\"\"Async version of execute(). Subclasses should implement this.\"\"\"\n+            raise NotImplementedError()\n+\n+        def execute(self, context):\n+            \"\"\"Run `aexecute()` inside an event loop.\"\"\"\n+            raise NotImplementedError(\"Airflow 3.2+ is required to allow executing async operators!\")",
      "comment": "@potiuk: What do you think of this simplification, at then end this is only for backward compat, so the check here doens't need to be as advanced as for the real async PythonOperator or the DecoratedOperator in Airflow 3.2+.  I think it's indeed a good idea?\r\n\r\n```\r\ndef is_async_callable(func) -> bool:\r\n        \"\"\"Detect async callables. \"\"\"\r\n        import inspect\r\n        from functools import partial\r\n        \r\n        while isinstance(func, partial):\r\n            func = func.func\r\n        return inspect.iscoroutinefunction(func)\r\n```",
      "comment_id": 2678449486,
      "user": "dabla",
      "created_at": "2026-01-10T08:30:49Z",
      "url": "https://github.com/apache/airflow/pull/60268#discussion_r2678449486"
    },
    {
      "repo": "apache/airflow",
      "pr_number": 60268,
      "file_path": "task-sdk/src/airflow/sdk/bases/decorator.py",
      "line": 160,
      "side": "RIGHT",
      "diff_hunk": "@@ -149,6 +150,52 @@ def _find_id_suffixes(dag: DAG) -> Iterator[int]:\n     return f\"{core}__{max(_find_id_suffixes(dag)) + 1}\"\n \n \n+def unwrap_partial(fn):\n+    while isinstance(fn, partial):\n+        fn = fn.func\n+    return fn\n+\n+\n+def unwrap_callable(func):\n+    from airflow.sdk.bases.decorator import _TaskDecorator",
      "comment": "Good catch kaxil, that's probably due to movements of those functions across different modules during refactoring that didn't pay attention anymore, well viewedf! :-)",
      "comment_id": 2678455931,
      "user": "dabla",
      "created_at": "2026-01-10T08:32:35Z",
      "url": "https://github.com/apache/airflow/pull/60268#discussion_r2678455931"
    },
    {
      "repo": "apache/airflow",
      "pr_number": 60268,
      "file_path": "task-sdk/src/airflow/sdk/bases/decorator.py",
      "line": 161,
      "side": "RIGHT",
      "diff_hunk": "@@ -149,6 +150,52 @@ def _find_id_suffixes(dag: DAG) -> Iterator[int]:\n     return f\"{core}__{max(_find_id_suffixes(dag)) + 1}\"\n \n \n+def unwrap_partial(fn):\n+    while isinstance(fn, partial):\n+        fn = fn.func\n+    return fn\n+\n+\n+def unwrap_callable(func):\n+    from airflow.sdk.bases.decorator import _TaskDecorator\n+    from airflow.sdk.definitions.mappedoperator import OperatorPartial",
      "comment": "No this one is not, it's imported at top of operator module, not decorator.",
      "comment_id": 2678457856,
      "user": "dabla",
      "created_at": "2026-01-10T08:36:17Z",
      "url": "https://github.com/apache/airflow/pull/60268#discussion_r2678457856"
    },
    {
      "repo": "apache/airflow",
      "pr_number": 60268,
      "file_path": "airflow-core/src/airflow/jobs/triggerer_job_runner.py",
      "line": 781,
      "side": "RIGHT",
      "diff_hunk": "@@ -780,8 +780,6 @@ class TriggerCommsDecoder(CommsDecoder[ToTriggerRunner, ToTriggerSupervisor]):\n         factory=lambda: TypeAdapter(ToTriggerRunner), repr=False\n     )",
      "comment": "I see in the RELEASE_NOTES.rst that there is not entry for Airflow 3.2.0 yet?  Do I have to add it manually and specify this feature?",
      "comment_id": 2678469005,
      "user": "dabla",
      "created_at": "2026-01-10T08:52:35Z",
      "url": "https://github.com/apache/airflow/pull/60268#discussion_r2678469005"
    },
    {
      "repo": "apache/airflow",
      "pr_number": 60268,
      "file_path": "airflow-core/src/airflow/jobs/triggerer_job_runner.py",
      "line": 781,
      "side": "RIGHT",
      "diff_hunk": "@@ -780,8 +780,6 @@ class TriggerCommsDecoder(CommsDecoder[ToTriggerRunner, ToTriggerSupervisor]):\n         factory=lambda: TypeAdapter(ToTriggerRunner), repr=False\n     )",
      "comment": "No, just add a file in `airflow-core/newsfragments`. Release notes are generated from those files on release.",
      "comment_id": 2681100508,
      "user": "uranusjr",
      "created_at": "2026-01-12T07:16:56Z",
      "url": "https://github.com/apache/airflow/pull/60268#discussion_r2681100508"
    },
    {
      "repo": "apache/airflow",
      "pr_number": 60268,
      "file_path": "providers/common/compat/src/airflow/providers/common/compat/standard/operators.py",
      "line": 77,
      "side": "RIGHT",
      "diff_hunk": "@@ -17,18 +17,74 @@\n \n from __future__ import annotations\n \n+from typing import TYPE_CHECKING\n+\n from airflow.providers.common.compat._compat_utils import create_module_getattr\n+from airflow.providers.common.compat.version_compat import (\n+    AIRFLOW_V_3_0_PLUS,\n+    AIRFLOW_V_3_1_PLUS,\n+    AIRFLOW_V_3_2_PLUS,\n+)\n \n _IMPORT_MAP: dict[str, str | tuple[str, ...]] = {\n     # Re-export from sdk (which handles Airflow 2.x/3.x fallbacks)\n     \"BaseOperator\": \"airflow.providers.common.compat.sdk\",\n+    \"BaseAsyncOperator\": \"airflow.providers.common.compat.sdk\",\n     \"get_current_context\": \"airflow.providers.common.compat.sdk\",\n+    \"is_async_callable\": \"airflow.providers.common.compat.sdk\",\n     # Standard provider items with direct fallbacks\n     \"PythonOperator\": (\"airflow.providers.standard.operators.python\", \"airflow.operators.python\"),\n     \"ShortCircuitOperator\": (\"airflow.providers.standard.operators.python\", \"airflow.operators.python\"),\n     \"_SERIALIZERS\": (\"airflow.providers.standard.operators.python\", \"airflow.operators.python\"),\n }\n \n+if TYPE_CHECKING:\n+    from airflow.sdk.bases.decorator import is_async_callable\n+    from airflow.sdk.bases.operator import BaseAsyncOperator\n+elif AIRFLOW_V_3_2_PLUS:\n+    from airflow.sdk.bases.decorator import is_async_callable\n+    from airflow.sdk.bases.operator import BaseAsyncOperator\n+else:\n+    if AIRFLOW_V_3_0_PLUS:\n+        from airflow.sdk import BaseOperator\n+    else:\n+        from airflow.models import BaseOperator\n+\n+    def is_async_callable(func) -> bool:\n+        \"\"\"Detect if a callable is an async function.\"\"\"\n+        import inspect\n+        from functools import partial\n+\n+        while isinstance(func, partial):\n+            func = func.func\n+        return inspect.iscoroutinefunction(func)\n+\n+    class BaseAsyncOperator(BaseOperator):\n+        \"\"\"Stub for Airflow < 3.2 that raises a clear error.\"\"\"\n+\n+        @property\n+        def is_async(self) -> bool:\n+            return True\n+\n+        if not AIRFLOW_V_3_1_PLUS:\n+\n+            @property\n+            def xcom_push(self) -> bool:\n+                return self.do_xcom_push\n+\n+            @xcom_push.setter\n+            def xcom_push(self, value: bool):\n+                self.do_xcom_push = value",
      "comment": "Is this part correct @dabla ? It's breaking my AF2 dags, when installing standard provider from main. Should it have another if/elif for AF2?\n\nExample dag:\n```\nfrom datetime import datetime\n\nfrom airflow.providers.common.compat.assets import Asset\nfrom airflow.providers.standard.operators.python import PythonOperator\n\nfrom airflow import DAG\n\n\ndef do_nothing():\n    pass\n\nDAG_ID = \"test_dag\"\n\nwith DAG(\n    dag_id=DAG_ID,\n    start_date=datetime(2021, 1, 1),\n    schedule=None,\n    catchup=False,\n    default_args={\"retries\": 0},\n) as dag:\n\n    task = PythonOperator(\n        task_id=\"task\",\n        python_callable=do_nothing,\n        inlets=[Asset(uri=\"s3://bucket2/dir2/file2.txt\"), Asset(uri=\"s3://bucket2/dir2/file3.txt\")],\n    )\n```\n\nError:\n```\n[2026-01-16, 14:20:00 UTC] {__init__.py:77} DEBUG - Lineage called with inlets: [Dataset(uri='s3://bucket2/dir2/file2.txt', extra=None), Dataset(uri='s3://bucket2/dir2/file3.txt', extra=None)], outlets: []\n[2026-01-16, 14:20:00 UTC] {taskinstance.py:3336} ERROR - Task failed with exception\nTraceback (most recent call last):\n  File \"/usr/local/lib/python3.12/site-packages/airflow/models/taskinstance.py\", line 282, in _run_raw_task\n    TaskInstance._execute_task_with_callbacks(\n  File \"/usr/local/lib/python3.12/site-packages/airflow/models/taskinstance.py\", line 3194, in _execute_task_with_callbacks\n    self.task.post_execute(context=context, result=result)\n  File \"/usr/local/lib/python3.12/site-packages/airflow/lineage/__init__.py\", line 88, in wrapper\n    self.xcom_push(context, key=PIPELINE_INLETS, value=inlets)\nTypeError: 'bool' object is not callable\n```\n\nFull logs: \n\n[dag_id=test_dag_run_id=manual__2026-01-16T14_19_59.788247+00_00_task_id=task_attempt=1.log](https://github.com/user-attachments/files/24673818/dag_id.test_dag_run_id.manual__2026-01-16T14_19_59.788247%2B00_00_task_id.task_attempt.1.log)",
      "comment_id": 2698701448,
      "user": "kacpermuda",
      "created_at": "2026-01-16T14:21:37Z",
      "url": "https://github.com/apache/airflow/pull/60268#discussion_r2698701448"
    },
    {
      "repo": "apache/airflow",
      "pr_number": 60268,
      "file_path": "providers/common/compat/src/airflow/providers/common/compat/standard/operators.py",
      "line": 77,
      "side": "RIGHT",
      "diff_hunk": "@@ -17,18 +17,74 @@\n \n from __future__ import annotations\n \n+from typing import TYPE_CHECKING\n+\n from airflow.providers.common.compat._compat_utils import create_module_getattr\n+from airflow.providers.common.compat.version_compat import (\n+    AIRFLOW_V_3_0_PLUS,\n+    AIRFLOW_V_3_1_PLUS,\n+    AIRFLOW_V_3_2_PLUS,\n+)\n \n _IMPORT_MAP: dict[str, str | tuple[str, ...]] = {\n     # Re-export from sdk (which handles Airflow 2.x/3.x fallbacks)\n     \"BaseOperator\": \"airflow.providers.common.compat.sdk\",\n+    \"BaseAsyncOperator\": \"airflow.providers.common.compat.sdk\",\n     \"get_current_context\": \"airflow.providers.common.compat.sdk\",\n+    \"is_async_callable\": \"airflow.providers.common.compat.sdk\",\n     # Standard provider items with direct fallbacks\n     \"PythonOperator\": (\"airflow.providers.standard.operators.python\", \"airflow.operators.python\"),\n     \"ShortCircuitOperator\": (\"airflow.providers.standard.operators.python\", \"airflow.operators.python\"),\n     \"_SERIALIZERS\": (\"airflow.providers.standard.operators.python\", \"airflow.operators.python\"),\n }\n \n+if TYPE_CHECKING:\n+    from airflow.sdk.bases.decorator import is_async_callable\n+    from airflow.sdk.bases.operator import BaseAsyncOperator\n+elif AIRFLOW_V_3_2_PLUS:\n+    from airflow.sdk.bases.decorator import is_async_callable\n+    from airflow.sdk.bases.operator import BaseAsyncOperator\n+else:\n+    if AIRFLOW_V_3_0_PLUS:\n+        from airflow.sdk import BaseOperator\n+    else:\n+        from airflow.models import BaseOperator\n+\n+    def is_async_callable(func) -> bool:\n+        \"\"\"Detect if a callable is an async function.\"\"\"\n+        import inspect\n+        from functools import partial\n+\n+        while isinstance(func, partial):\n+            func = func.func\n+        return inspect.iscoroutinefunction(func)\n+\n+    class BaseAsyncOperator(BaseOperator):\n+        \"\"\"Stub for Airflow < 3.2 that raises a clear error.\"\"\"\n+\n+        @property\n+        def is_async(self) -> bool:\n+            return True\n+\n+        if not AIRFLOW_V_3_1_PLUS:\n+\n+            @property\n+            def xcom_push(self) -> bool:\n+                return self.do_xcom_push\n+\n+            @xcom_push.setter\n+            def xcom_push(self, value: bool):\n+                self.do_xcom_push = value",
      "comment": "Hello @kacpermuda, thanks for reporting this is indeed an issue will check asap.\r\n",
      "comment_id": 2699608191,
      "user": "dabla",
      "created_at": "2026-01-16T18:48:04Z",
      "url": "https://github.com/apache/airflow/pull/60268#discussion_r2699608191"
    },
    {
      "repo": "apache/airflow",
      "pr_number": 60268,
      "file_path": "providers/common/compat/src/airflow/providers/common/compat/standard/operators.py",
      "line": 77,
      "side": "RIGHT",
      "diff_hunk": "@@ -17,18 +17,74 @@\n \n from __future__ import annotations\n \n+from typing import TYPE_CHECKING\n+\n from airflow.providers.common.compat._compat_utils import create_module_getattr\n+from airflow.providers.common.compat.version_compat import (\n+    AIRFLOW_V_3_0_PLUS,\n+    AIRFLOW_V_3_1_PLUS,\n+    AIRFLOW_V_3_2_PLUS,\n+)\n \n _IMPORT_MAP: dict[str, str | tuple[str, ...]] = {\n     # Re-export from sdk (which handles Airflow 2.x/3.x fallbacks)\n     \"BaseOperator\": \"airflow.providers.common.compat.sdk\",\n+    \"BaseAsyncOperator\": \"airflow.providers.common.compat.sdk\",\n     \"get_current_context\": \"airflow.providers.common.compat.sdk\",\n+    \"is_async_callable\": \"airflow.providers.common.compat.sdk\",\n     # Standard provider items with direct fallbacks\n     \"PythonOperator\": (\"airflow.providers.standard.operators.python\", \"airflow.operators.python\"),\n     \"ShortCircuitOperator\": (\"airflow.providers.standard.operators.python\", \"airflow.operators.python\"),\n     \"_SERIALIZERS\": (\"airflow.providers.standard.operators.python\", \"airflow.operators.python\"),\n }\n \n+if TYPE_CHECKING:\n+    from airflow.sdk.bases.decorator import is_async_callable\n+    from airflow.sdk.bases.operator import BaseAsyncOperator\n+elif AIRFLOW_V_3_2_PLUS:\n+    from airflow.sdk.bases.decorator import is_async_callable\n+    from airflow.sdk.bases.operator import BaseAsyncOperator\n+else:\n+    if AIRFLOW_V_3_0_PLUS:\n+        from airflow.sdk import BaseOperator\n+    else:\n+        from airflow.models import BaseOperator\n+\n+    def is_async_callable(func) -> bool:\n+        \"\"\"Detect if a callable is an async function.\"\"\"\n+        import inspect\n+        from functools import partial\n+\n+        while isinstance(func, partial):\n+            func = func.func\n+        return inspect.iscoroutinefunction(func)\n+\n+    class BaseAsyncOperator(BaseOperator):\n+        \"\"\"Stub for Airflow < 3.2 that raises a clear error.\"\"\"\n+\n+        @property\n+        def is_async(self) -> bool:\n+            return True\n+\n+        if not AIRFLOW_V_3_1_PLUS:\n+\n+            @property\n+            def xcom_push(self) -> bool:\n+                return self.do_xcom_push\n+\n+            @xcom_push.setter\n+            def xcom_push(self, value: bool):\n+                self.do_xcom_push = value",
      "comment": "Open [PR ](https://github.com/apache/airflow/pull/60663) for this.",
      "comment_id": 2699675280,
      "user": "dabla",
      "created_at": "2026-01-16T19:13:29Z",
      "url": "https://github.com/apache/airflow/pull/60268#discussion_r2699675280"
    },
    {
      "repo": "apache/airflow",
      "pr_number": 59938,
      "file_path": "airflow-core/src/airflow/models/pool.py",
      "line": 50,
      "side": "RIGHT",
      "diff_hunk": "@@ -36,6 +37,23 @@\n     from sqlalchemy.sql import Select\n \n \n+def validate_pool_name(name: str) -> None:\n+    \"\"\"\n+    Validate that pool name only contains valid characters for stats reporting.\n+\n+    Pool names must only contain ASCII alphabets, numbers, underscores, dots, and dashes\n+    to ensure compatibility with stats naming requirements.\n+\n+    :param name: The pool name to validate\n+    :raises ValueError: If the pool name contains invalid characters\n+    \"\"\"\n+    if not re.match(r\"^[a-zA-Z0-9_.-]+$\", name):",
      "comment": "Just a thought : Do we need this additional validation method ? Is it possible to refactor a code a bit and use the same validation logic used while reporting stats ? \r\nElse, any new validation rule would have to be updated here",
      "comment_id": 2654835466,
      "user": "Prajwal7842",
      "created_at": "2025-12-31T05:34:52Z",
      "url": "https://github.com/apache/airflow/pull/59938#discussion_r2654835466"
    },
    {
      "repo": "apache/airflow",
      "pr_number": 59938,
      "file_path": "airflow-core/src/airflow/models/pool.py",
      "line": 50,
      "side": "RIGHT",
      "diff_hunk": "@@ -36,6 +37,23 @@\n     from sqlalchemy.sql import Select\n \n \n+def validate_pool_name(name: str) -> None:\n+    \"\"\"\n+    Validate that pool name only contains valid characters for stats reporting.\n+\n+    Pool names must only contain ASCII alphabets, numbers, underscores, dots, and dashes\n+    to ensure compatibility with stats naming requirements.\n+\n+    :param name: The pool name to validate\n+    :raises ValueError: If the pool name contains invalid characters\n+    \"\"\"\n+    if not re.match(r\"^[a-zA-Z0-9_.-]+$\", name):",
      "comment": "@Prajwal7842  Good question! I looked into the stats validation code, but it's in the statsd library (at the reporting level) rather than in Airflow core. \r\n\r\nCreating a separate validation function here has these benefits:\r\n1. Catches invalid names early (at creation time) rather than at runtime\r\n2. Provides clear, actionable error messages to users\r\n3. Keeps the validation logic in one place in Airflow\r\n\r\nHowever, if there's an existing Airflow utility function for stats name validation that I missed, I'd be happy to use that instead. Could you point me to it?",
      "comment_id": 2655204924,
      "user": "kalluripradeep",
      "created_at": "2025-12-31T10:51:47Z",
      "url": "https://github.com/apache/airflow/pull/59938#discussion_r2655204924"
    },
    {
      "repo": "apache/airflow",
      "pr_number": 59938,
      "file_path": "airflow-core/src/airflow/models/pool.py",
      "line": 402,
      "side": "RIGHT",
      "diff_hunk": "@@ -389,4 +399,4 @@ def get_name_to_team_name_mapping(\n         pool_names: list[str], session: Session = NEW_SESSION\n     ) -> dict[str, str | None]:\n         stmt = select(Pool.pool, Pool.team_name).where(Pool.pool.in_(pool_names))\n-        return {pool: team_name for pool, team_name in session.execute(stmt)}\n+        return {pool: team_name for pool, team_name in session.execute(stmt)}",
      "comment": "@potiuk  Fixed both issues:\r\n1. Removed the accidental fix_quote.py file\r\n2. Fixed the duplicate return statement (it was from an earlier commit)\r\n\r\nAlso fixed the LoggingMixin usage by switching to a module-level logger as per the pre-commit checks.\r\n\r\nThanks for the quick review!",
      "comment_id": 2655581544,
      "user": "kalluripradeep",
      "created_at": "2025-12-31T15:53:23Z",
      "url": "https://github.com/apache/airflow/pull/59938#discussion_r2655581544"
    },
    {
      "repo": "apache/airflow",
      "pr_number": 59938,
      "file_path": "tests/models/test_pool.py",
      "line": 18,
      "side": "RIGHT",
      "diff_hunk": "@@ -0,0 +1,18 @@\n+# Licensed to the Apache Software Foundation (ASF) under one\n+# or more contributor license agreements.  See the NOTICE file\n+# distributed with this work for additional information\n+# regarding copyright ownership.  The ASF licenses this file\n+# to you under the Apache License, Version 2.0 (the\n+# \"License\"); you may not use this file except in compliance\n+# with the License.  You may obtain a copy of the License at\n+#\n+#   http://www.apache.org/licenses/LICENSE-2.0\n+#\n+# Unless required by applicable law or agreed to in writing,\n+# software distributed under the License is distributed on an\n+# \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+# KIND, either express or implied.  See the License for the\n+# specific language governing permissions and limitations\n+# under the License.\n+\n+from __future__ import annotations",
      "comment": "Hi @kaxil! \r\n\r\nThe tests were included in my original PR commits (1edd0d3, 6ff4d64, 0025d3a) but looks like they were removed in #60548 as part of a cleanup.\r\n\r\nI see @jedcunningham  has opened #60553 to add them back with optimizations. Happy to help review or add more test coverage if needed!\r\n\r\nLet me know if you'd like me to contribute additional tests. \ud83d\udc4d",
      "comment_id": 2699242129,
      "user": "kalluripradeep",
      "created_at": "2026-01-16T16:48:43Z",
      "url": "https://github.com/apache/airflow/pull/59938#discussion_r2699242129"
    },
    {
      "repo": "apache/airflow",
      "pr_number": 56406,
      "file_path": "airflow-core/src/airflow/api_fastapi/core_api/routes/public/dag_run.py",
      "line": 102,
      "side": "RIGHT",
      "diff_hunk": "@@ -93,6 +95,51 @@\n dag_run_router = AirflowRouter(tags=[\"DagRun\"], prefix=\"/dags/{dag_id}/dagRuns\")\n \n \n+@dag_run_router.get(\n+    \"/recent-configurations\",\n+    responses=create_openapi_http_exception_doc([status.HTTP_404_NOT_FOUND]),\n+    dependencies=[Depends(requires_access_dag(method=\"GET\", access_entity=DagAccessEntity.RUN))],\n+)",
      "comment": "`airflow-core/src/airflow/api_fastapi/core_api/routes/ui/dag_run.py` might be a better place for this route.",
      "comment_id": 2572701616,
      "user": "jason810496",
      "created_at": "2025-11-29T01:08:46Z",
      "url": "https://github.com/apache/airflow/pull/56406#discussion_r2572701616"
    },
    {
      "repo": "apache/airflow",
      "pr_number": 56406,
      "file_path": "airflow-core/src/airflow/api_fastapi/core_api/datamodels/dag_run.py",
      "line": 199,
      "side": "RIGHT",
      "diff_hunk": "@@ -182,3 +182,18 @@ class DAGRunsBatchBody(StrictBaseModel):\n     duration_lt: float | None = None\n \n     conf_contains: str | None = None\n+\n+\n+class RecentConfigurationResponse(BaseModel):\n+    \"\"\"Response model for recent DAG run configurations.\"\"\"\n+    \n+    run_id: str = Field(description=\"The run ID of the DAG run\")\n+    conf: dict | None = Field(description=\"The configuration used for this DAG run\")\n+    logical_date: AwareDatetime | None = Field(description=\"The logical date of the DAG run\")\n+    start_date: AwareDatetime | None = Field(description=\"The start date of the DAG run\")\n+\n+\n+class RecentConfigurationsResponse(BaseModel):\n+    \"\"\"Response model for recent DAG run configurations collection.\"\"\"\n+    \n+    configurations: list[RecentConfigurationResponse] = Field(description=\"List of recent configurations\")",
      "comment": "```suggestion\nclass RecentConfigurationsCollectionResponse(BaseModel):\n    \"\"\"Response model for recent DAG run configurations collection.\"\"\"\n    \n    configurations: Iterable[RecentConfigurationResponse]\n```",
      "comment_id": 2572825703,
      "user": "jason810496",
      "created_at": "2025-11-29T05:57:20Z",
      "url": "https://github.com/apache/airflow/pull/56406#discussion_r2572825703"
    },
    {
      "repo": "apache/airflow",
      "pr_number": 56406,
      "file_path": "airflow-core/src/airflow/api_fastapi/core_api/routes/public/dag_run.py",
      "line": 140,
      "side": "RIGHT",
      "diff_hunk": "@@ -93,6 +95,51 @@\n dag_run_router = AirflowRouter(tags=[\"DagRun\"], prefix=\"/dags/{dag_id}/dagRuns\")\n \n \n+@dag_run_router.get(\n+    \"/recent-configurations\",\n+    responses=create_openapi_http_exception_doc([status.HTTP_404_NOT_FOUND]),\n+    dependencies=[Depends(requires_access_dag(method=\"GET\", access_entity=DagAccessEntity.RUN))],\n+)\n+def get_recent_dag_run_configurations(\n+    dag_id: str,\n+    session: SessionDep,\n+    dag_bag: DagBagDep,\n+    limit: Annotated[int, Query(ge=1, le=50, description=\"Maximum number of recent configurations to return\")] = 5,\n+) -> RecentConfigurationsResponse:\n+    \"\"\"Get recent manual DAG run configurations for a specific DAG.\"\"\"\n+    # Check if the DAG exists\n+    get_latest_version_of_dag(dag_bag, dag_id, session)\n+    \n+    # Get the configured limit from settings\n+    configured_limit = conf.getint(\"webserver\", \"num_recent_configurations_for_trigger\", fallback=5)\n+    actual_limit = min(limit, configured_limit)\n+    \n+    # Query recent manual DAG runs with configurations\n+    query = (\n+        select(DagRun.run_id, DagRun.conf, DagRun.logical_date, DagRun.start_date)\n+        .where(\n+            DagRun.dag_id == dag_id,\n+            DagRun.run_type == DagRunType.MANUAL,\n+            DagRun.conf.is_not(None)\n+        )\n+        .order_by(DagRun.start_date.desc())\n+        .limit(actual_limit)\n+    )\n+    \n+    results = session.execute(query).all()\n+    \n+    configurations = []\n+    for result in results:\n+        configurations.append({\n+            \"run_id\": result.run_id,\n+            \"conf\": result.conf,\n+            \"logical_date\": result.logical_date,\n+            \"start_date\": result.start_date,\n+        })\n+    \n+    return RecentConfigurationsResponse(configurations=configurations)",
      "comment": "```suggestion\n    configurations = session.scalars(query)\n    \n    return RecentConfigurationsResponse(configurations=configurations)\n```",
      "comment_id": 2572826069,
      "user": "jason810496",
      "created_at": "2025-11-29T05:58:36Z",
      "url": "https://github.com/apache/airflow/pull/56406#discussion_r2572826069"
    },
    {
      "repo": "apache/airflow",
      "pr_number": 60357,
      "file_path": "airflow-core/src/airflow/executors/base_executor.py",
      "line": 289,
      "side": "RIGHT",
      "diff_hunk": "@@ -281,22 +285,12 @@ def _emit_metrics(self, open_slots, num_running_tasks, num_queued_tasks):\n         \"\"\"\n         name = self.__class__.__name__\n         multiple_executors_configured = len(ExecutorLoader.get_executor_names()) > 1\n-        if multiple_executors_configured:\n-            metric_suffix = name\n \n-        open_slots_metric_name = (\n-            f\"executor.open_slots.{metric_suffix}\" if multiple_executors_configured else \"executor.open_slots\"\n-        )\n-        queued_tasks_metric_name = (\n-            f\"executor.queued_tasks.{metric_suffix}\"\n-            if multiple_executors_configured\n-            else \"executor.queued_tasks\"\n-        )\n-        running_tasks_metric_name = (\n-            f\"executor.running_tasks.{metric_suffix}\"\n-            if multiple_executors_configured\n-            else \"executor.running_tasks\"\n-        )\n+        metric_suffix = name if multiple_executors_configured else None",
      "comment": "Why not just compute metric_suffix within _get_metric_name? So that you don't have to pass it in every time? If a method call takes a arg every single call it might as well just own it.",
      "comment_id": 2677955316,
      "user": "o-nikolas",
      "created_at": "2026-01-09T23:44:13Z",
      "url": "https://github.com/apache/airflow/pull/60357#discussion_r2677955316"
    },
    {
      "repo": "apache/airflow",
      "pr_number": 60508,
      "file_path": "dev/breeze/src/airflow_breeze/commands/release_command.py",
      "line": 34,
      "side": "RIGHT",
      "diff_hunk": "@@ -30,8 +30,8 @@\n from airflow_breeze.utils.path_utils import AIRFLOW_ROOT_PATH\n from airflow_breeze.utils.run_utils import run_command\n \n-# Pattern to match Airflow release versions (e.g., \"3.0.5\")\n-RELEASE_PATTERN = re.compile(r\"^(?P<major>\\d+)\\.(?P<minor>\\d+)\\.(?P<patch>\\d+)$\")\n+# Pattern to match Airflow release versions starting with 3 (e.g., \"3.0.5\")\n+RELEASE_PATTERN = re.compile(r\"^(?P<major>3)\\.(?P<minor>\\d+)\\.(?P<patch>\\d+)$\")",
      "comment": "This is so we don't accidentally delete 2.11 in svn",
      "comment_id": 2689915313,
      "user": "ephraimbuddy",
      "created_at": "2026-01-14T10:41:09Z",
      "url": "https://github.com/apache/airflow/pull/60508#discussion_r2689915313"
    },
    {
      "repo": "apache/airflow",
      "pr_number": 60508,
      "file_path": "dev/breeze/src/airflow_breeze/commands/release_command.py",
      "line": 34,
      "side": "RIGHT",
      "diff_hunk": "@@ -30,8 +30,8 @@\n from airflow_breeze.utils.path_utils import AIRFLOW_ROOT_PATH\n from airflow_breeze.utils.run_utils import run_command\n \n-# Pattern to match Airflow release versions (e.g., \"3.0.5\")\n-RELEASE_PATTERN = re.compile(r\"^(?P<major>\\d+)\\.(?P<minor>\\d+)\\.(?P<patch>\\d+)$\")\n+# Pattern to match Airflow release versions starting with 3 (e.g., \"3.0.5\")\n+RELEASE_PATTERN = re.compile(r\"^(?P<major>3)\\.(?P<minor>\\d+)\\.(?P<patch>\\d+)$\")",
      "comment": "What about Task SDK versions that don't start with 3?",
      "comment_id": 2690341461,
      "user": "kaxil",
      "created_at": "2026-01-14T13:01:23Z",
      "url": "https://github.com/apache/airflow/pull/60508#discussion_r2690341461"
    },
    {
      "repo": "apache/airflow",
      "pr_number": 60508,
      "file_path": "dev/breeze/src/airflow_breeze/commands/release_command.py",
      "line": 33,
      "side": "RIGHT",
      "diff_hunk": "@@ -30,7 +30,7 @@\n from airflow_breeze.utils.path_utils import AIRFLOW_ROOT_PATH\n from airflow_breeze.utils.run_utils import run_command\n \n-# Pattern to match Airflow release versions (e.g., \"3.0.5\")\n+# Pattern to match Airflow release versions starting with 3 (e.g., \"3.0.5\")",
      "comment": "```suggestion\n# Pattern to match Airflow release versions (e.g., \"3.0.5\")\n```",
      "comment_id": 2690625183,
      "user": "ephraimbuddy",
      "created_at": "2026-01-14T14:16:10Z",
      "url": "https://github.com/apache/airflow/pull/60508#discussion_r2690625183"
    },
    {
      "repo": "apache/airflow",
      "pr_number": 60274,
      "file_path": "providers/fab/src/airflow/providers/fab/get_provider_info.py",
      "line": 182,
      "side": "RIGHT",
      "diff_hunk": "@@ -177,6 +177,13 @@ def get_provider_info():\n                         \"example\": None,\n                         \"default\": \"1\",\n                     },\n+                    \"cache_ttl\": {\n+                        \"description\": \"Number of seconds after which the user cache will expire to refetch updated user and\\npermissions.\\n\",\n+                        \"version_added\": \"3.1.2\",",
      "comment": "```suggestion\r\n                        \"version_added\": \"3.2.0\",\r\n```",
      "comment_id": 2690269359,
      "user": "eladkal",
      "created_at": "2026-01-14T12:37:53Z",
      "url": "https://github.com/apache/airflow/pull/60274#discussion_r2690269359"
    },
    {
      "repo": "apache/airflow",
      "pr_number": 60274,
      "file_path": "providers/fab/src/airflow/providers/fab/auth_manager/fab_auth_manager.py",
      "line": 165,
      "side": "RIGHT",
      "diff_hunk": "@@ -161,6 +162,7 @@\n     MenuItem.XCOMS: RESOURCE_XCOM,\n }\n \n+CACHE_TTL = conf.getint(\"fab\", \"cache_ttl\", fallback=30)",
      "comment": "Have you tried to update this value in the config? By setting this constant at the module level I am not sure Airflow has time to load config from providers before loading this file. Instead of a constant at the module level, I would create a property with `@cached_property` in `FabAuthManager`",
      "comment_id": 2690633184,
      "user": "vincbeck",
      "created_at": "2026-01-14T14:18:12Z",
      "url": "https://github.com/apache/airflow/pull/60274#discussion_r2690633184"
    },
    {
      "repo": "apache/airflow",
      "pr_number": 60274,
      "file_path": "providers/fab/src/airflow/providers/fab/auth_manager/fab_auth_manager.py",
      "line": 165,
      "side": "RIGHT",
      "diff_hunk": "@@ -161,6 +162,7 @@\n     MenuItem.XCOMS: RESOURCE_XCOM,\n }\n \n+CACHE_TTL = conf.getint(\"fab\", \"cache_ttl\", fallback=30)",
      "comment": "Yes, I had set it to zero to test disabling cache and also added a print statement. It had the value from configuration printed. I am initializing the cache at class level so `self` will not be accessible to do below when ttl becomes a `@cached_property`\r\n\r\n```python\r\nclass FabAuthManager(BaseAuthManager[User]):\r\n    cache: TTLCache = TTLCache(maxsize=1024, ttl=CACHE_TTL)\r\n```",
      "comment_id": 2690660596,
      "user": "tirkarthi",
      "created_at": "2026-01-14T14:25:04Z",
      "url": "https://github.com/apache/airflow/pull/60274#discussion_r2690660596"
    },
    {
      "repo": "apache/airflow",
      "pr_number": 60008,
      "file_path": "airflow-core/tests/unit/api_fastapi/common/test_parameters.py",
      "line": 125,
      "side": "RIGHT",
      "diff_hunk": "@@ -99,3 +100,26 @@ def test_sort_param_max_number_of_filers(self):\n             ),\n         ):\n             param.to_orm(None)\n+\n+\n+class TestSearchParam:\n+    def test_to_orm_single_value(self):\n+        \"\"\"Test search with a single term.\"\"\"\n+        param = _SearchParam(DagModel.dag_id).set_value(\"example_bash\")\n+        statement = select(DagModel)\n+        statement = param.to_orm(statement)\n+\n+        sql = str(statement.compile(compile_kwargs={\"literal_binds\": True})).lower()\n+        assert \"dag_id\" in sql\n+        assert \"like\" in sql\n+\n+    def test_to_orm_multiple_values_or(self):\n+        \"\"\"Test search with multiple terms using the pipe | operator.\"\"\"\n+        param = _SearchParam(DagModel.dag_id).set_value(\"example_bash | example_python\")\n+        statement = select(DagModel)\n+        statement = param.to_orm(statement)\n+\n+        sql = str(statement.compile(compile_kwargs={\"literal_binds\": True}))\n+        assert \"OR\" in sql\n+        assert \"example_bash\" in sql\n+        assert \"example_python\" in sql",
      "comment": "small nit: How about asserting the whole expected SQL statement as str for better readability?",
      "comment_id": 2656243659,
      "user": "jason810496",
      "created_at": "2026-01-01T10:17:51Z",
      "url": "https://github.com/apache/airflow/pull/60008#discussion_r2656243659"
    },
    {
      "repo": "apache/airflow",
      "pr_number": 60008,
      "file_path": "airflow-core/tests/unit/api_fastapi/common/test_parameters.py",
      "line": 125,
      "side": "RIGHT",
      "diff_hunk": "@@ -99,3 +100,26 @@ def test_sort_param_max_number_of_filers(self):\n             ),\n         ):\n             param.to_orm(None)\n+\n+\n+class TestSearchParam:\n+    def test_to_orm_single_value(self):\n+        \"\"\"Test search with a single term.\"\"\"\n+        param = _SearchParam(DagModel.dag_id).set_value(\"example_bash\")\n+        statement = select(DagModel)\n+        statement = param.to_orm(statement)\n+\n+        sql = str(statement.compile(compile_kwargs={\"literal_binds\": True})).lower()\n+        assert \"dag_id\" in sql\n+        assert \"like\" in sql\n+\n+    def test_to_orm_multiple_values_or(self):\n+        \"\"\"Test search with multiple terms using the pipe | operator.\"\"\"\n+        param = _SearchParam(DagModel.dag_id).set_value(\"example_bash | example_python\")\n+        statement = select(DagModel)\n+        statement = param.to_orm(statement)\n+\n+        sql = str(statement.compile(compile_kwargs={\"literal_binds\": True}))\n+        assert \"OR\" in sql\n+        assert \"example_bash\" in sql\n+        assert \"example_python\" in sql",
      "comment": "Thanks for the suggestion! I went with the keyword assertions because I thought asserting the full compiled SQL string might make the test brittle / requre maintenance in the future.  If the SQLAlchemy version changes its formatting or if we run tests against different DB dialects, then a hardcoded string could cause failures.  By checking for the presence of the `OR` operator and the specific search terms used, we can verify the logic and keep the test robust.  What do you think?",
      "comment_id": 2656353774,
      "user": "Jkhall81",
      "created_at": "2026-01-01T13:19:24Z",
      "url": "https://github.com/apache/airflow/pull/60008#discussion_r2656353774"
    },
    {
      "repo": "apache/airflow",
      "pr_number": 60008,
      "file_path": "airflow-core/tests/unit/api_fastapi/common/test_parameters.py",
      "line": 125,
      "side": "RIGHT",
      "diff_hunk": "@@ -99,3 +100,26 @@ def test_sort_param_max_number_of_filers(self):\n             ),\n         ):\n             param.to_orm(None)\n+\n+\n+class TestSearchParam:\n+    def test_to_orm_single_value(self):\n+        \"\"\"Test search with a single term.\"\"\"\n+        param = _SearchParam(DagModel.dag_id).set_value(\"example_bash\")\n+        statement = select(DagModel)\n+        statement = param.to_orm(statement)\n+\n+        sql = str(statement.compile(compile_kwargs={\"literal_binds\": True})).lower()\n+        assert \"dag_id\" in sql\n+        assert \"like\" in sql\n+\n+    def test_to_orm_multiple_values_or(self):\n+        \"\"\"Test search with multiple terms using the pipe | operator.\"\"\"\n+        param = _SearchParam(DagModel.dag_id).set_value(\"example_bash | example_python\")\n+        statement = select(DagModel)\n+        statement = param.to_orm(statement)\n+\n+        sql = str(statement.compile(compile_kwargs={\"literal_binds\": True}))\n+        assert \"OR\" in sql\n+        assert \"example_bash\" in sql\n+        assert \"example_python\" in sql",
      "comment": "> requre maintenance in the future. If the SQLAlchemy version changes its formatting \r\n\r\nWe didn't bump the SQLAlchemy version that often, so it does't seem to be our concern.\r\n\r\n>  if we run tests against different DB dialects, then a hardcoded string could cause failures.\r\n\r\nWe could resolve it by dynamically generating `pytest.param` for each dialects\r\n\r\ne.g. https://github.com/apache/airflow/blob/7d5d2c61942dc91ab64b576cb5c9b1b6b0ff7bd6/airflow-core/tests/unit/api_fastapi/common/test_exceptions.py#L128-L156 ( For `TestUniqueConstraintErrorHandler`, we need to check the returning statement in case of showing sensitive value in the response )\r\n\r\nActually, I just want to confirm the generated SQL statement is as expected.",
      "comment_id": 2656749021,
      "user": "jason810496",
      "created_at": "2026-01-02T02:26:19Z",
      "url": "https://github.com/apache/airflow/pull/60008#discussion_r2656749021"
    },
    {
      "repo": "apache/airflow",
      "pr_number": 60008,
      "file_path": "airflow-core/tests/unit/api_fastapi/common/test_parameters.py",
      "line": 125,
      "side": "RIGHT",
      "diff_hunk": "@@ -99,3 +100,26 @@ def test_sort_param_max_number_of_filers(self):\n             ),\n         ):\n             param.to_orm(None)\n+\n+\n+class TestSearchParam:\n+    def test_to_orm_single_value(self):\n+        \"\"\"Test search with a single term.\"\"\"\n+        param = _SearchParam(DagModel.dag_id).set_value(\"example_bash\")\n+        statement = select(DagModel)\n+        statement = param.to_orm(statement)\n+\n+        sql = str(statement.compile(compile_kwargs={\"literal_binds\": True})).lower()\n+        assert \"dag_id\" in sql\n+        assert \"like\" in sql\n+\n+    def test_to_orm_multiple_values_or(self):\n+        \"\"\"Test search with multiple terms using the pipe | operator.\"\"\"\n+        param = _SearchParam(DagModel.dag_id).set_value(\"example_bash | example_python\")\n+        statement = select(DagModel)\n+        statement = param.to_orm(statement)\n+\n+        sql = str(statement.compile(compile_kwargs={\"literal_binds\": True}))\n+        assert \"OR\" in sql\n+        assert \"example_bash\" in sql\n+        assert \"example_python\" in sql",
      "comment": "I'm happy to make that change if that's the preferred standard.  Since you mentioned deferring to @pierrejeambrun for the final call, I'll hold off on the refactor until he weighs in on the interface overall. That way, I can tackle all the feedback at once and avoid having to possibly redo the assertions, or other things, if he has a different preference.  Does that work for you?",
      "comment_id": 2656758999,
      "user": "Jkhall81",
      "created_at": "2026-01-02T02:45:36Z",
      "url": "https://github.com/apache/airflow/pull/60008#discussion_r2656758999"
    },
    {
      "repo": "apache/airflow",
      "pr_number": 60008,
      "file_path": "airflow-core/tests/unit/api_fastapi/common/test_parameters.py",
      "line": 125,
      "side": "RIGHT",
      "diff_hunk": "@@ -99,3 +100,26 @@ def test_sort_param_max_number_of_filers(self):\n             ),\n         ):\n             param.to_orm(None)\n+\n+\n+class TestSearchParam:\n+    def test_to_orm_single_value(self):\n+        \"\"\"Test search with a single term.\"\"\"\n+        param = _SearchParam(DagModel.dag_id).set_value(\"example_bash\")\n+        statement = select(DagModel)\n+        statement = param.to_orm(statement)\n+\n+        sql = str(statement.compile(compile_kwargs={\"literal_binds\": True})).lower()\n+        assert \"dag_id\" in sql\n+        assert \"like\" in sql\n+\n+    def test_to_orm_multiple_values_or(self):\n+        \"\"\"Test search with multiple terms using the pipe | operator.\"\"\"\n+        param = _SearchParam(DagModel.dag_id).set_value(\"example_bash | example_python\")\n+        statement = select(DagModel)\n+        statement = param.to_orm(statement)\n+\n+        sql = str(statement.compile(compile_kwargs={\"literal_binds\": True}))\n+        assert \"OR\" in sql\n+        assert \"example_bash\" in sql\n+        assert \"example_python\" in sql",
      "comment": "Sure! It's more like preference instead of strong suggestion for the test case.",
      "comment_id": 2656763157,
      "user": "jason810496",
      "created_at": "2026-01-02T02:53:52Z",
      "url": "https://github.com/apache/airflow/pull/60008#discussion_r2656763157"
    },
    {
      "repo": "apache/airflow",
      "pr_number": 60008,
      "file_path": "airflow-core/tests/unit/api_fastapi/common/test_parameters.py",
      "line": 125,
      "side": "RIGHT",
      "diff_hunk": "@@ -99,3 +100,26 @@ def test_sort_param_max_number_of_filers(self):\n             ),\n         ):\n             param.to_orm(None)\n+\n+\n+class TestSearchParam:\n+    def test_to_orm_single_value(self):\n+        \"\"\"Test search with a single term.\"\"\"\n+        param = _SearchParam(DagModel.dag_id).set_value(\"example_bash\")\n+        statement = select(DagModel)\n+        statement = param.to_orm(statement)\n+\n+        sql = str(statement.compile(compile_kwargs={\"literal_binds\": True})).lower()\n+        assert \"dag_id\" in sql\n+        assert \"like\" in sql\n+\n+    def test_to_orm_multiple_values_or(self):\n+        \"\"\"Test search with multiple terms using the pipe | operator.\"\"\"\n+        param = _SearchParam(DagModel.dag_id).set_value(\"example_bash | example_python\")\n+        statement = select(DagModel)\n+        statement = param.to_orm(statement)\n+\n+        sql = str(statement.compile(compile_kwargs={\"literal_binds\": True}))\n+        assert \"OR\" in sql\n+        assert \"example_bash\" in sql\n+        assert \"example_python\" in sql",
      "comment": "I agree with @Jkhall81's approach and reasoning regarding the sql assertion - the exact sql sqlalchemy outputs is an implementation detail, and we shouldn't be tied to that on principal.\r\n\r\nLet's assume for a second an extreme case where sqla is not deterministic - sometimes outputs `A OR B` and sometimes `B OR A`. How would we define the test in that case?",
      "comment_id": 2658793384,
      "user": "Dev-iL",
      "created_at": "2026-01-03T08:10:00Z",
      "url": "https://github.com/apache/airflow/pull/60008#discussion_r2658793384"
    },
    {
      "repo": "apache/airflow",
      "pr_number": 60008,
      "file_path": "airflow-core/tests/unit/api_fastapi/common/test_parameters.py",
      "line": 125,
      "side": "RIGHT",
      "diff_hunk": "@@ -99,3 +100,26 @@ def test_sort_param_max_number_of_filers(self):\n             ),\n         ):\n             param.to_orm(None)\n+\n+\n+class TestSearchParam:\n+    def test_to_orm_single_value(self):\n+        \"\"\"Test search with a single term.\"\"\"\n+        param = _SearchParam(DagModel.dag_id).set_value(\"example_bash\")\n+        statement = select(DagModel)\n+        statement = param.to_orm(statement)\n+\n+        sql = str(statement.compile(compile_kwargs={\"literal_binds\": True})).lower()\n+        assert \"dag_id\" in sql\n+        assert \"like\" in sql\n+\n+    def test_to_orm_multiple_values_or(self):\n+        \"\"\"Test search with multiple terms using the pipe | operator.\"\"\"\n+        param = _SearchParam(DagModel.dag_id).set_value(\"example_bash | example_python\")\n+        statement = select(DagModel)\n+        statement = param.to_orm(statement)\n+\n+        sql = str(statement.compile(compile_kwargs={\"literal_binds\": True}))\n+        assert \"OR\" in sql\n+        assert \"example_bash\" in sql\n+        assert \"example_python\" in sql",
      "comment": "Yeah the dialect thing is a problem. Lets not delay because of a test, just to be sure I added a test case to dag that is actually using a OR search, just to be sure.\r\n\r\nWe can always improve later.",
      "comment_id": 2691433739,
      "user": "pierrejeambrun",
      "created_at": "2026-01-14T17:43:55Z",
      "url": "https://github.com/apache/airflow/pull/60008#discussion_r2691433739"
    },
    {
      "repo": "apache/airflow",
      "pr_number": 58918,
      "file_path": "providers/teradata/src/airflow/providers/teradata/hooks/tpt.py",
      "line": 341,
      "side": "RIGHT",
      "diff_hunk": "@@ -240,6 +241,244 @@ def _execute_tbuild_locally(\n                 secure_delete(local_script_file, logging.getLogger(__name__))\n                 terminate_subprocess(sp, logging.getLogger(__name__))\n \n+    def execute_tdload(\n+        self,\n+        remote_working_dir: str,\n+        job_var_content: str | None = None,\n+        tdload_options: str | None = None,\n+        tdload_job_name: str | None = None,\n+    ) -> int:\n+        \"\"\"\n+        Execute a tdload operation using the tdload command-line utility.\n+\n+        Args:\n+            remote_working_dir: Remote working directory for SSH execution\n+            job_var_content: Content of the job variable file\n+            tdload_options: Additional command-line options for tdload\n+            tdload_job_name: Name for the tdload job\n+\n+        Returns:\n+            Exit code from the tdload operation\n+\n+        Raises:\n+            RuntimeError: Non-zero tdload exit status or unexpected execution failure\n+            ConnectionError: SSH connection not established or fails\n+            TimeoutError: SSH connection/network timeout\n+            FileNotFoundError: tdload binary not found in PATH\n+        \"\"\"\n+        tdload_job_name = tdload_job_name or f\"tdload_job_{uuid.uuid4().hex}\"\n+        if self.ssh_hook:\n+            self.log.info(\"Executing tdload via SSH on remote host with job name: %s\", tdload_job_name)\n+            return self._execute_tdload_via_ssh(\n+                remote_working_dir, job_var_content, tdload_options, tdload_job_name\n+            )\n+        self.log.info(\"Executing tdload locally with job name: %s\", tdload_job_name)\n+        return self._execute_tdload_locally(job_var_content, tdload_options, tdload_job_name)\n+\n+    def _execute_tdload_via_ssh(\n+        self,\n+        remote_working_dir: str,\n+        job_var_content: str | None,\n+        tdload_options: str | None,\n+        tdload_job_name: str | None,\n+    ) -> int:\n+        \"\"\"\n+        Write job_var_content to a temporary file, then transfer and execute it on the remote host.\n+\n+        Args:\n+            remote_working_dir: Remote working directory\n+            job_var_content: Content for the job variable file\n+            tdload_options: Additional tdload command options\n+            tdload_job_name: Name for the tdload job\n+\n+        Returns:\n+            Exit code from the tdload operation\n+        \"\"\"\n+        with self.preferred_temp_directory() as tmp_dir:\n+            local_job_var_file = os.path.join(tmp_dir, f\"tdload_job_var_{uuid.uuid4().hex}.txt\")\n+            write_file(local_job_var_file, job_var_content or \"\")\n+            return self._transfer_to_and_execute_tdload_on_remote(\n+                local_job_var_file, remote_working_dir, tdload_options, tdload_job_name\n+            )\n+\n+    def _transfer_to_and_execute_tdload_on_remote(\n+        self,\n+        local_job_var_file: str,\n+        remote_working_dir: str,\n+        tdload_options: str | None,\n+        tdload_job_name: str | None,\n+    ) -> int:\n+        \"\"\"Transfer job variable file to remote host and execute tdload command.\"\"\"\n+        encrypted_file_path = f\"{local_job_var_file}.enc\"\n+        remote_encrypted_job_file = os.path.join(remote_working_dir, os.path.basename(encrypted_file_path))\n+        remote_job_file = os.path.join(remote_working_dir, os.path.basename(local_job_var_file))\n+\n+        try:\n+            if not self.ssh_hook:\n+                raise ConnectionError(\"SSH connection is not established. `ssh_hook` is None or invalid.\")\n+            with self.ssh_hook.get_conn() as ssh_client:\n+                verify_tpt_utility_on_remote_host(ssh_client, \"tdload\", logging.getLogger(__name__))\n+                password = generate_random_password()\n+                generate_encrypted_file_with_openssl(local_job_var_file, password, encrypted_file_path)\n+                transfer_file_sftp(\n+                    ssh_client, encrypted_file_path, remote_encrypted_job_file, logging.getLogger(__name__)\n+                )\n+                decrypt_remote_file(\n+                    ssh_client,\n+                    remote_encrypted_job_file,\n+                    remote_job_file,\n+                    password,\n+                    logging.getLogger(__name__),\n+                )\n+\n+                set_remote_file_permissions(ssh_client, remote_job_file, logging.getLogger(__name__))\n+\n+                # Build tdload command more robustly\n+                tdload_cmd = self._build_tdload_command(remote_job_file, tdload_options, tdload_job_name)\n+\n+                self.log.info(\"=\" * 80)\n+                self.log.info(\"Executing tdload command on remote server: %s\", \" \".join(tdload_cmd))\n+                self.log.info(\"=\" * 80)",
      "comment": "i assume was used for testing...? not needed now right? the `self.log.info(\"=\" * 80)` logs i mean",
      "comment_id": 2581539659,
      "user": "prdai",
      "created_at": "2025-12-02T14:53:19Z",
      "url": "https://github.com/apache/airflow/pull/58918#discussion_r2581539659"
    },
    {
      "repo": "apache/airflow",
      "pr_number": 58918,
      "file_path": "providers/teradata/src/airflow/providers/teradata/hooks/tpt.py",
      "line": 341,
      "side": "RIGHT",
      "diff_hunk": "@@ -240,6 +241,244 @@ def _execute_tbuild_locally(\n                 secure_delete(local_script_file, logging.getLogger(__name__))\n                 terminate_subprocess(sp, logging.getLogger(__name__))\n \n+    def execute_tdload(\n+        self,\n+        remote_working_dir: str,\n+        job_var_content: str | None = None,\n+        tdload_options: str | None = None,\n+        tdload_job_name: str | None = None,\n+    ) -> int:\n+        \"\"\"\n+        Execute a tdload operation using the tdload command-line utility.\n+\n+        Args:\n+            remote_working_dir: Remote working directory for SSH execution\n+            job_var_content: Content of the job variable file\n+            tdload_options: Additional command-line options for tdload\n+            tdload_job_name: Name for the tdload job\n+\n+        Returns:\n+            Exit code from the tdload operation\n+\n+        Raises:\n+            RuntimeError: Non-zero tdload exit status or unexpected execution failure\n+            ConnectionError: SSH connection not established or fails\n+            TimeoutError: SSH connection/network timeout\n+            FileNotFoundError: tdload binary not found in PATH\n+        \"\"\"\n+        tdload_job_name = tdload_job_name or f\"tdload_job_{uuid.uuid4().hex}\"\n+        if self.ssh_hook:\n+            self.log.info(\"Executing tdload via SSH on remote host with job name: %s\", tdload_job_name)\n+            return self._execute_tdload_via_ssh(\n+                remote_working_dir, job_var_content, tdload_options, tdload_job_name\n+            )\n+        self.log.info(\"Executing tdload locally with job name: %s\", tdload_job_name)\n+        return self._execute_tdload_locally(job_var_content, tdload_options, tdload_job_name)\n+\n+    def _execute_tdload_via_ssh(\n+        self,\n+        remote_working_dir: str,\n+        job_var_content: str | None,\n+        tdload_options: str | None,\n+        tdload_job_name: str | None,\n+    ) -> int:\n+        \"\"\"\n+        Write job_var_content to a temporary file, then transfer and execute it on the remote host.\n+\n+        Args:\n+            remote_working_dir: Remote working directory\n+            job_var_content: Content for the job variable file\n+            tdload_options: Additional tdload command options\n+            tdload_job_name: Name for the tdload job\n+\n+        Returns:\n+            Exit code from the tdload operation\n+        \"\"\"\n+        with self.preferred_temp_directory() as tmp_dir:\n+            local_job_var_file = os.path.join(tmp_dir, f\"tdload_job_var_{uuid.uuid4().hex}.txt\")\n+            write_file(local_job_var_file, job_var_content or \"\")\n+            return self._transfer_to_and_execute_tdload_on_remote(\n+                local_job_var_file, remote_working_dir, tdload_options, tdload_job_name\n+            )\n+\n+    def _transfer_to_and_execute_tdload_on_remote(\n+        self,\n+        local_job_var_file: str,\n+        remote_working_dir: str,\n+        tdload_options: str | None,\n+        tdload_job_name: str | None,\n+    ) -> int:\n+        \"\"\"Transfer job variable file to remote host and execute tdload command.\"\"\"\n+        encrypted_file_path = f\"{local_job_var_file}.enc\"\n+        remote_encrypted_job_file = os.path.join(remote_working_dir, os.path.basename(encrypted_file_path))\n+        remote_job_file = os.path.join(remote_working_dir, os.path.basename(local_job_var_file))\n+\n+        try:\n+            if not self.ssh_hook:\n+                raise ConnectionError(\"SSH connection is not established. `ssh_hook` is None or invalid.\")\n+            with self.ssh_hook.get_conn() as ssh_client:\n+                verify_tpt_utility_on_remote_host(ssh_client, \"tdload\", logging.getLogger(__name__))\n+                password = generate_random_password()\n+                generate_encrypted_file_with_openssl(local_job_var_file, password, encrypted_file_path)\n+                transfer_file_sftp(\n+                    ssh_client, encrypted_file_path, remote_encrypted_job_file, logging.getLogger(__name__)\n+                )\n+                decrypt_remote_file(\n+                    ssh_client,\n+                    remote_encrypted_job_file,\n+                    remote_job_file,\n+                    password,\n+                    logging.getLogger(__name__),\n+                )\n+\n+                set_remote_file_permissions(ssh_client, remote_job_file, logging.getLogger(__name__))\n+\n+                # Build tdload command more robustly\n+                tdload_cmd = self._build_tdload_command(remote_job_file, tdload_options, tdload_job_name)\n+\n+                self.log.info(\"=\" * 80)\n+                self.log.info(\"Executing tdload command on remote server: %s\", \" \".join(tdload_cmd))\n+                self.log.info(\"=\" * 80)",
      "comment": "I added the `self.log.info(\"=\" * 80)`  lines intentionally to provide visual separation in the logs, making it easier for users to quickly identify the actual `tdload` command that is going to be executed. If you prefer a cleaner log output, I can remove them. Kindly let me know your preference.",
      "comment_id": 2583550127,
      "user": "snreddygopu",
      "created_at": "2025-12-03T04:05:19Z",
      "url": "https://github.com/apache/airflow/pull/58918#discussion_r2583550127"
    },
    {
      "repo": "apache/airflow",
      "pr_number": 58918,
      "file_path": "providers/teradata/src/airflow/providers/teradata/hooks/tpt.py",
      "line": 341,
      "side": "RIGHT",
      "diff_hunk": "@@ -240,6 +241,244 @@ def _execute_tbuild_locally(\n                 secure_delete(local_script_file, logging.getLogger(__name__))\n                 terminate_subprocess(sp, logging.getLogger(__name__))\n \n+    def execute_tdload(\n+        self,\n+        remote_working_dir: str,\n+        job_var_content: str | None = None,\n+        tdload_options: str | None = None,\n+        tdload_job_name: str | None = None,\n+    ) -> int:\n+        \"\"\"\n+        Execute a tdload operation using the tdload command-line utility.\n+\n+        Args:\n+            remote_working_dir: Remote working directory for SSH execution\n+            job_var_content: Content of the job variable file\n+            tdload_options: Additional command-line options for tdload\n+            tdload_job_name: Name for the tdload job\n+\n+        Returns:\n+            Exit code from the tdload operation\n+\n+        Raises:\n+            RuntimeError: Non-zero tdload exit status or unexpected execution failure\n+            ConnectionError: SSH connection not established or fails\n+            TimeoutError: SSH connection/network timeout\n+            FileNotFoundError: tdload binary not found in PATH\n+        \"\"\"\n+        tdload_job_name = tdload_job_name or f\"tdload_job_{uuid.uuid4().hex}\"\n+        if self.ssh_hook:\n+            self.log.info(\"Executing tdload via SSH on remote host with job name: %s\", tdload_job_name)\n+            return self._execute_tdload_via_ssh(\n+                remote_working_dir, job_var_content, tdload_options, tdload_job_name\n+            )\n+        self.log.info(\"Executing tdload locally with job name: %s\", tdload_job_name)\n+        return self._execute_tdload_locally(job_var_content, tdload_options, tdload_job_name)\n+\n+    def _execute_tdload_via_ssh(\n+        self,\n+        remote_working_dir: str,\n+        job_var_content: str | None,\n+        tdload_options: str | None,\n+        tdload_job_name: str | None,\n+    ) -> int:\n+        \"\"\"\n+        Write job_var_content to a temporary file, then transfer and execute it on the remote host.\n+\n+        Args:\n+            remote_working_dir: Remote working directory\n+            job_var_content: Content for the job variable file\n+            tdload_options: Additional tdload command options\n+            tdload_job_name: Name for the tdload job\n+\n+        Returns:\n+            Exit code from the tdload operation\n+        \"\"\"\n+        with self.preferred_temp_directory() as tmp_dir:\n+            local_job_var_file = os.path.join(tmp_dir, f\"tdload_job_var_{uuid.uuid4().hex}.txt\")\n+            write_file(local_job_var_file, job_var_content or \"\")\n+            return self._transfer_to_and_execute_tdload_on_remote(\n+                local_job_var_file, remote_working_dir, tdload_options, tdload_job_name\n+            )\n+\n+    def _transfer_to_and_execute_tdload_on_remote(\n+        self,\n+        local_job_var_file: str,\n+        remote_working_dir: str,\n+        tdload_options: str | None,\n+        tdload_job_name: str | None,\n+    ) -> int:\n+        \"\"\"Transfer job variable file to remote host and execute tdload command.\"\"\"\n+        encrypted_file_path = f\"{local_job_var_file}.enc\"\n+        remote_encrypted_job_file = os.path.join(remote_working_dir, os.path.basename(encrypted_file_path))\n+        remote_job_file = os.path.join(remote_working_dir, os.path.basename(local_job_var_file))\n+\n+        try:\n+            if not self.ssh_hook:\n+                raise ConnectionError(\"SSH connection is not established. `ssh_hook` is None or invalid.\")\n+            with self.ssh_hook.get_conn() as ssh_client:\n+                verify_tpt_utility_on_remote_host(ssh_client, \"tdload\", logging.getLogger(__name__))\n+                password = generate_random_password()\n+                generate_encrypted_file_with_openssl(local_job_var_file, password, encrypted_file_path)\n+                transfer_file_sftp(\n+                    ssh_client, encrypted_file_path, remote_encrypted_job_file, logging.getLogger(__name__)\n+                )\n+                decrypt_remote_file(\n+                    ssh_client,\n+                    remote_encrypted_job_file,\n+                    remote_job_file,\n+                    password,\n+                    logging.getLogger(__name__),\n+                )\n+\n+                set_remote_file_permissions(ssh_client, remote_job_file, logging.getLogger(__name__))\n+\n+                # Build tdload command more robustly\n+                tdload_cmd = self._build_tdload_command(remote_job_file, tdload_options, tdload_job_name)\n+\n+                self.log.info(\"=\" * 80)\n+                self.log.info(\"Executing tdload command on remote server: %s\", \" \".join(tdload_cmd))\n+                self.log.info(\"=\" * 80)",
      "comment": "i do not exactly have a preference, and i do not have a say exactly of the standards but as far as i have gone through the codebase i do not think that is a pattern that the project follows, again i am not a officially affiliated with the project, this is just what i have seen",
      "comment_id": 2583731154,
      "user": "prdai",
      "created_at": "2025-12-03T05:55:47Z",
      "url": "https://github.com/apache/airflow/pull/58918#discussion_r2583731154"
    },
    {
      "repo": "apache/airflow",
      "pr_number": 58918,
      "file_path": "providers/teradata/src/airflow/providers/teradata/hooks/tpt.py",
      "line": 341,
      "side": "RIGHT",
      "diff_hunk": "@@ -240,6 +241,244 @@ def _execute_tbuild_locally(\n                 secure_delete(local_script_file, logging.getLogger(__name__))\n                 terminate_subprocess(sp, logging.getLogger(__name__))\n \n+    def execute_tdload(\n+        self,\n+        remote_working_dir: str,\n+        job_var_content: str | None = None,\n+        tdload_options: str | None = None,\n+        tdload_job_name: str | None = None,\n+    ) -> int:\n+        \"\"\"\n+        Execute a tdload operation using the tdload command-line utility.\n+\n+        Args:\n+            remote_working_dir: Remote working directory for SSH execution\n+            job_var_content: Content of the job variable file\n+            tdload_options: Additional command-line options for tdload\n+            tdload_job_name: Name for the tdload job\n+\n+        Returns:\n+            Exit code from the tdload operation\n+\n+        Raises:\n+            RuntimeError: Non-zero tdload exit status or unexpected execution failure\n+            ConnectionError: SSH connection not established or fails\n+            TimeoutError: SSH connection/network timeout\n+            FileNotFoundError: tdload binary not found in PATH\n+        \"\"\"\n+        tdload_job_name = tdload_job_name or f\"tdload_job_{uuid.uuid4().hex}\"\n+        if self.ssh_hook:\n+            self.log.info(\"Executing tdload via SSH on remote host with job name: %s\", tdload_job_name)\n+            return self._execute_tdload_via_ssh(\n+                remote_working_dir, job_var_content, tdload_options, tdload_job_name\n+            )\n+        self.log.info(\"Executing tdload locally with job name: %s\", tdload_job_name)\n+        return self._execute_tdload_locally(job_var_content, tdload_options, tdload_job_name)\n+\n+    def _execute_tdload_via_ssh(\n+        self,\n+        remote_working_dir: str,\n+        job_var_content: str | None,\n+        tdload_options: str | None,\n+        tdload_job_name: str | None,\n+    ) -> int:\n+        \"\"\"\n+        Write job_var_content to a temporary file, then transfer and execute it on the remote host.\n+\n+        Args:\n+            remote_working_dir: Remote working directory\n+            job_var_content: Content for the job variable file\n+            tdload_options: Additional tdload command options\n+            tdload_job_name: Name for the tdload job\n+\n+        Returns:\n+            Exit code from the tdload operation\n+        \"\"\"\n+        with self.preferred_temp_directory() as tmp_dir:\n+            local_job_var_file = os.path.join(tmp_dir, f\"tdload_job_var_{uuid.uuid4().hex}.txt\")\n+            write_file(local_job_var_file, job_var_content or \"\")\n+            return self._transfer_to_and_execute_tdload_on_remote(\n+                local_job_var_file, remote_working_dir, tdload_options, tdload_job_name\n+            )\n+\n+    def _transfer_to_and_execute_tdload_on_remote(\n+        self,\n+        local_job_var_file: str,\n+        remote_working_dir: str,\n+        tdload_options: str | None,\n+        tdload_job_name: str | None,\n+    ) -> int:\n+        \"\"\"Transfer job variable file to remote host and execute tdload command.\"\"\"\n+        encrypted_file_path = f\"{local_job_var_file}.enc\"\n+        remote_encrypted_job_file = os.path.join(remote_working_dir, os.path.basename(encrypted_file_path))\n+        remote_job_file = os.path.join(remote_working_dir, os.path.basename(local_job_var_file))\n+\n+        try:\n+            if not self.ssh_hook:\n+                raise ConnectionError(\"SSH connection is not established. `ssh_hook` is None or invalid.\")\n+            with self.ssh_hook.get_conn() as ssh_client:\n+                verify_tpt_utility_on_remote_host(ssh_client, \"tdload\", logging.getLogger(__name__))\n+                password = generate_random_password()\n+                generate_encrypted_file_with_openssl(local_job_var_file, password, encrypted_file_path)\n+                transfer_file_sftp(\n+                    ssh_client, encrypted_file_path, remote_encrypted_job_file, logging.getLogger(__name__)\n+                )\n+                decrypt_remote_file(\n+                    ssh_client,\n+                    remote_encrypted_job_file,\n+                    remote_job_file,\n+                    password,\n+                    logging.getLogger(__name__),\n+                )\n+\n+                set_remote_file_permissions(ssh_client, remote_job_file, logging.getLogger(__name__))\n+\n+                # Build tdload command more robustly\n+                tdload_cmd = self._build_tdload_command(remote_job_file, tdload_options, tdload_job_name)\n+\n+                self.log.info(\"=\" * 80)\n+                self.log.info(\"Executing tdload command on remote server: %s\", \" \".join(tdload_cmd))\n+                self.log.info(\"=\" * 80)",
      "comment": "Thank you for sharing your perspective. These log separator lines were already approved in the DdlOperator, so I kept them here for consistency and for visual clarity across similar operators. I think it\u2019s fine to keep them for now. If the main maintainers want them removed, I\u2019m happy to do that.",
      "comment_id": 2583838081,
      "user": "snreddygopu",
      "created_at": "2025-12-03T06:41:33Z",
      "url": "https://github.com/apache/airflow/pull/58918#discussion_r2583838081"
    },
    {
      "repo": "apache/airflow",
      "pr_number": 58918,
      "file_path": "providers/teradata/src/airflow/providers/teradata/hooks/tpt.py",
      "line": 341,
      "side": "RIGHT",
      "diff_hunk": "@@ -240,6 +241,244 @@ def _execute_tbuild_locally(\n                 secure_delete(local_script_file, logging.getLogger(__name__))\n                 terminate_subprocess(sp, logging.getLogger(__name__))\n \n+    def execute_tdload(\n+        self,\n+        remote_working_dir: str,\n+        job_var_content: str | None = None,\n+        tdload_options: str | None = None,\n+        tdload_job_name: str | None = None,\n+    ) -> int:\n+        \"\"\"\n+        Execute a tdload operation using the tdload command-line utility.\n+\n+        Args:\n+            remote_working_dir: Remote working directory for SSH execution\n+            job_var_content: Content of the job variable file\n+            tdload_options: Additional command-line options for tdload\n+            tdload_job_name: Name for the tdload job\n+\n+        Returns:\n+            Exit code from the tdload operation\n+\n+        Raises:\n+            RuntimeError: Non-zero tdload exit status or unexpected execution failure\n+            ConnectionError: SSH connection not established or fails\n+            TimeoutError: SSH connection/network timeout\n+            FileNotFoundError: tdload binary not found in PATH\n+        \"\"\"\n+        tdload_job_name = tdload_job_name or f\"tdload_job_{uuid.uuid4().hex}\"\n+        if self.ssh_hook:\n+            self.log.info(\"Executing tdload via SSH on remote host with job name: %s\", tdload_job_name)\n+            return self._execute_tdload_via_ssh(\n+                remote_working_dir, job_var_content, tdload_options, tdload_job_name\n+            )\n+        self.log.info(\"Executing tdload locally with job name: %s\", tdload_job_name)\n+        return self._execute_tdload_locally(job_var_content, tdload_options, tdload_job_name)\n+\n+    def _execute_tdload_via_ssh(\n+        self,\n+        remote_working_dir: str,\n+        job_var_content: str | None,\n+        tdload_options: str | None,\n+        tdload_job_name: str | None,\n+    ) -> int:\n+        \"\"\"\n+        Write job_var_content to a temporary file, then transfer and execute it on the remote host.\n+\n+        Args:\n+            remote_working_dir: Remote working directory\n+            job_var_content: Content for the job variable file\n+            tdload_options: Additional tdload command options\n+            tdload_job_name: Name for the tdload job\n+\n+        Returns:\n+            Exit code from the tdload operation\n+        \"\"\"\n+        with self.preferred_temp_directory() as tmp_dir:\n+            local_job_var_file = os.path.join(tmp_dir, f\"tdload_job_var_{uuid.uuid4().hex}.txt\")\n+            write_file(local_job_var_file, job_var_content or \"\")\n+            return self._transfer_to_and_execute_tdload_on_remote(\n+                local_job_var_file, remote_working_dir, tdload_options, tdload_job_name\n+            )\n+\n+    def _transfer_to_and_execute_tdload_on_remote(\n+        self,\n+        local_job_var_file: str,\n+        remote_working_dir: str,\n+        tdload_options: str | None,\n+        tdload_job_name: str | None,\n+    ) -> int:\n+        \"\"\"Transfer job variable file to remote host and execute tdload command.\"\"\"\n+        encrypted_file_path = f\"{local_job_var_file}.enc\"\n+        remote_encrypted_job_file = os.path.join(remote_working_dir, os.path.basename(encrypted_file_path))\n+        remote_job_file = os.path.join(remote_working_dir, os.path.basename(local_job_var_file))\n+\n+        try:\n+            if not self.ssh_hook:\n+                raise ConnectionError(\"SSH connection is not established. `ssh_hook` is None or invalid.\")\n+            with self.ssh_hook.get_conn() as ssh_client:\n+                verify_tpt_utility_on_remote_host(ssh_client, \"tdload\", logging.getLogger(__name__))\n+                password = generate_random_password()\n+                generate_encrypted_file_with_openssl(local_job_var_file, password, encrypted_file_path)\n+                transfer_file_sftp(\n+                    ssh_client, encrypted_file_path, remote_encrypted_job_file, logging.getLogger(__name__)\n+                )\n+                decrypt_remote_file(\n+                    ssh_client,\n+                    remote_encrypted_job_file,\n+                    remote_job_file,\n+                    password,\n+                    logging.getLogger(__name__),\n+                )\n+\n+                set_remote_file_permissions(ssh_client, remote_job_file, logging.getLogger(__name__))\n+\n+                # Build tdload command more robustly\n+                tdload_cmd = self._build_tdload_command(remote_job_file, tdload_options, tdload_job_name)\n+\n+                self.log.info(\"=\" * 80)\n+                self.log.info(\"Executing tdload command on remote server: %s\", \" \".join(tdload_cmd))\n+                self.log.info(\"=\" * 80)",
      "comment": "I have removed the log separator lines for consistency with the rest of the codebase. Thanks for the feedback.",
      "comment_id": 2588889188,
      "user": "snreddygopu",
      "created_at": "2025-12-04T12:31:34Z",
      "url": "https://github.com/apache/airflow/pull/58918#discussion_r2588889188"
    },
    {
      "repo": "apache/airflow",
      "pr_number": 58918,
      "file_path": "providers/teradata/src/airflow/providers/teradata/hooks/tpt.py",
      "line": 341,
      "side": "RIGHT",
      "diff_hunk": "@@ -240,6 +241,244 @@ def _execute_tbuild_locally(\n                 secure_delete(local_script_file, logging.getLogger(__name__))\n                 terminate_subprocess(sp, logging.getLogger(__name__))\n \n+    def execute_tdload(\n+        self,\n+        remote_working_dir: str,\n+        job_var_content: str | None = None,\n+        tdload_options: str | None = None,\n+        tdload_job_name: str | None = None,\n+    ) -> int:\n+        \"\"\"\n+        Execute a tdload operation using the tdload command-line utility.\n+\n+        Args:\n+            remote_working_dir: Remote working directory for SSH execution\n+            job_var_content: Content of the job variable file\n+            tdload_options: Additional command-line options for tdload\n+            tdload_job_name: Name for the tdload job\n+\n+        Returns:\n+            Exit code from the tdload operation\n+\n+        Raises:\n+            RuntimeError: Non-zero tdload exit status or unexpected execution failure\n+            ConnectionError: SSH connection not established or fails\n+            TimeoutError: SSH connection/network timeout\n+            FileNotFoundError: tdload binary not found in PATH\n+        \"\"\"\n+        tdload_job_name = tdload_job_name or f\"tdload_job_{uuid.uuid4().hex}\"\n+        if self.ssh_hook:\n+            self.log.info(\"Executing tdload via SSH on remote host with job name: %s\", tdload_job_name)\n+            return self._execute_tdload_via_ssh(\n+                remote_working_dir, job_var_content, tdload_options, tdload_job_name\n+            )\n+        self.log.info(\"Executing tdload locally with job name: %s\", tdload_job_name)\n+        return self._execute_tdload_locally(job_var_content, tdload_options, tdload_job_name)\n+\n+    def _execute_tdload_via_ssh(\n+        self,\n+        remote_working_dir: str,\n+        job_var_content: str | None,\n+        tdload_options: str | None,\n+        tdload_job_name: str | None,\n+    ) -> int:\n+        \"\"\"\n+        Write job_var_content to a temporary file, then transfer and execute it on the remote host.\n+\n+        Args:\n+            remote_working_dir: Remote working directory\n+            job_var_content: Content for the job variable file\n+            tdload_options: Additional tdload command options\n+            tdload_job_name: Name for the tdload job\n+\n+        Returns:\n+            Exit code from the tdload operation\n+        \"\"\"\n+        with self.preferred_temp_directory() as tmp_dir:\n+            local_job_var_file = os.path.join(tmp_dir, f\"tdload_job_var_{uuid.uuid4().hex}.txt\")\n+            write_file(local_job_var_file, job_var_content or \"\")\n+            return self._transfer_to_and_execute_tdload_on_remote(\n+                local_job_var_file, remote_working_dir, tdload_options, tdload_job_name\n+            )\n+\n+    def _transfer_to_and_execute_tdload_on_remote(\n+        self,\n+        local_job_var_file: str,\n+        remote_working_dir: str,\n+        tdload_options: str | None,\n+        tdload_job_name: str | None,\n+    ) -> int:\n+        \"\"\"Transfer job variable file to remote host and execute tdload command.\"\"\"\n+        encrypted_file_path = f\"{local_job_var_file}.enc\"\n+        remote_encrypted_job_file = os.path.join(remote_working_dir, os.path.basename(encrypted_file_path))\n+        remote_job_file = os.path.join(remote_working_dir, os.path.basename(local_job_var_file))\n+\n+        try:\n+            if not self.ssh_hook:\n+                raise ConnectionError(\"SSH connection is not established. `ssh_hook` is None or invalid.\")\n+            with self.ssh_hook.get_conn() as ssh_client:\n+                verify_tpt_utility_on_remote_host(ssh_client, \"tdload\", logging.getLogger(__name__))\n+                password = generate_random_password()\n+                generate_encrypted_file_with_openssl(local_job_var_file, password, encrypted_file_path)\n+                transfer_file_sftp(\n+                    ssh_client, encrypted_file_path, remote_encrypted_job_file, logging.getLogger(__name__)\n+                )\n+                decrypt_remote_file(\n+                    ssh_client,\n+                    remote_encrypted_job_file,\n+                    remote_job_file,\n+                    password,\n+                    logging.getLogger(__name__),\n+                )\n+\n+                set_remote_file_permissions(ssh_client, remote_job_file, logging.getLogger(__name__))\n+\n+                # Build tdload command more robustly\n+                tdload_cmd = self._build_tdload_command(remote_job_file, tdload_options, tdload_job_name)\n+\n+                self.log.info(\"=\" * 80)\n+                self.log.info(\"Executing tdload command on remote server: %s\", \" \".join(tdload_cmd))\n+                self.log.info(\"=\" * 80)",
      "comment": "Please resolve the conversation if you have no further review comments.",
      "comment_id": 2600266229,
      "user": "snreddygopu",
      "created_at": "2025-12-08T21:51:39Z",
      "url": "https://github.com/apache/airflow/pull/58918#discussion_r2600266229"
    },
    {
      "repo": "apache/airflow",
      "pr_number": 58918,
      "file_path": "providers/teradata/src/airflow/providers/teradata/hooks/tpt.py",
      "line": 341,
      "side": "RIGHT",
      "diff_hunk": "@@ -240,6 +241,244 @@ def _execute_tbuild_locally(\n                 secure_delete(local_script_file, logging.getLogger(__name__))\n                 terminate_subprocess(sp, logging.getLogger(__name__))\n \n+    def execute_tdload(\n+        self,\n+        remote_working_dir: str,\n+        job_var_content: str | None = None,\n+        tdload_options: str | None = None,\n+        tdload_job_name: str | None = None,\n+    ) -> int:\n+        \"\"\"\n+        Execute a tdload operation using the tdload command-line utility.\n+\n+        Args:\n+            remote_working_dir: Remote working directory for SSH execution\n+            job_var_content: Content of the job variable file\n+            tdload_options: Additional command-line options for tdload\n+            tdload_job_name: Name for the tdload job\n+\n+        Returns:\n+            Exit code from the tdload operation\n+\n+        Raises:\n+            RuntimeError: Non-zero tdload exit status or unexpected execution failure\n+            ConnectionError: SSH connection not established or fails\n+            TimeoutError: SSH connection/network timeout\n+            FileNotFoundError: tdload binary not found in PATH\n+        \"\"\"\n+        tdload_job_name = tdload_job_name or f\"tdload_job_{uuid.uuid4().hex}\"\n+        if self.ssh_hook:\n+            self.log.info(\"Executing tdload via SSH on remote host with job name: %s\", tdload_job_name)\n+            return self._execute_tdload_via_ssh(\n+                remote_working_dir, job_var_content, tdload_options, tdload_job_name\n+            )\n+        self.log.info(\"Executing tdload locally with job name: %s\", tdload_job_name)\n+        return self._execute_tdload_locally(job_var_content, tdload_options, tdload_job_name)\n+\n+    def _execute_tdload_via_ssh(\n+        self,\n+        remote_working_dir: str,\n+        job_var_content: str | None,\n+        tdload_options: str | None,\n+        tdload_job_name: str | None,\n+    ) -> int:\n+        \"\"\"\n+        Write job_var_content to a temporary file, then transfer and execute it on the remote host.\n+\n+        Args:\n+            remote_working_dir: Remote working directory\n+            job_var_content: Content for the job variable file\n+            tdload_options: Additional tdload command options\n+            tdload_job_name: Name for the tdload job\n+\n+        Returns:\n+            Exit code from the tdload operation\n+        \"\"\"\n+        with self.preferred_temp_directory() as tmp_dir:\n+            local_job_var_file = os.path.join(tmp_dir, f\"tdload_job_var_{uuid.uuid4().hex}.txt\")\n+            write_file(local_job_var_file, job_var_content or \"\")\n+            return self._transfer_to_and_execute_tdload_on_remote(\n+                local_job_var_file, remote_working_dir, tdload_options, tdload_job_name\n+            )\n+\n+    def _transfer_to_and_execute_tdload_on_remote(\n+        self,\n+        local_job_var_file: str,\n+        remote_working_dir: str,\n+        tdload_options: str | None,\n+        tdload_job_name: str | None,\n+    ) -> int:\n+        \"\"\"Transfer job variable file to remote host and execute tdload command.\"\"\"\n+        encrypted_file_path = f\"{local_job_var_file}.enc\"\n+        remote_encrypted_job_file = os.path.join(remote_working_dir, os.path.basename(encrypted_file_path))\n+        remote_job_file = os.path.join(remote_working_dir, os.path.basename(local_job_var_file))\n+\n+        try:\n+            if not self.ssh_hook:\n+                raise ConnectionError(\"SSH connection is not established. `ssh_hook` is None or invalid.\")\n+            with self.ssh_hook.get_conn() as ssh_client:\n+                verify_tpt_utility_on_remote_host(ssh_client, \"tdload\", logging.getLogger(__name__))\n+                password = generate_random_password()\n+                generate_encrypted_file_with_openssl(local_job_var_file, password, encrypted_file_path)\n+                transfer_file_sftp(\n+                    ssh_client, encrypted_file_path, remote_encrypted_job_file, logging.getLogger(__name__)\n+                )\n+                decrypt_remote_file(\n+                    ssh_client,\n+                    remote_encrypted_job_file,\n+                    remote_job_file,\n+                    password,\n+                    logging.getLogger(__name__),\n+                )\n+\n+                set_remote_file_permissions(ssh_client, remote_job_file, logging.getLogger(__name__))\n+\n+                # Build tdload command more robustly\n+                tdload_cmd = self._build_tdload_command(remote_job_file, tdload_options, tdload_job_name)\n+\n+                self.log.info(\"=\" * 80)\n+                self.log.info(\"Executing tdload command on remote server: %s\", \" \".join(tdload_cmd))\n+                self.log.info(\"=\" * 80)",
      "comment": "Hi @prdai,\r\n\r\nCould you please review the changes and approve the pull request?\r\n",
      "comment_id": 2607425839,
      "user": "snreddygopu",
      "created_at": "2025-12-10T16:43:17Z",
      "url": "https://github.com/apache/airflow/pull/58918#discussion_r2607425839"
    },
    {
      "repo": "apache/airflow",
      "pr_number": 53722,
      "file_path": "airflow-core/src/airflow/jobs/scheduler_job_runner.py",
      "line": 2517,
      "side": "RIGHT",
      "diff_hunk": "@@ -2108,18 +2136,43 @@ def _emit_pool_metrics(self, session: Session = NEW_SESSION) -> None:\n         with DebugTrace.start_span(span_name=\"emit_pool_metrics\", component=\"SchedulerJobRunner\") as span:\n             pools = Pool.slots_stats(session=session)\n             for pool_name, slot_stats in pools.items():\n-                Stats.gauge(f\"pool.open_slots.{pool_name}\", slot_stats[\"open\"])\n-                Stats.gauge(f\"pool.queued_slots.{pool_name}\", slot_stats[\"queued\"])\n-                Stats.gauge(f\"pool.running_slots.{pool_name}\", slot_stats[\"running\"])\n-                Stats.gauge(f\"pool.deferred_slots.{pool_name}\", slot_stats[\"deferred\"])\n-                Stats.gauge(f\"pool.scheduled_slots.{pool_name}\", slot_stats[\"scheduled\"])\n-\n-                # Same metrics with tagging\n-                Stats.gauge(\"pool.open_slots\", slot_stats[\"open\"], tags={\"pool_name\": pool_name})\n-                Stats.gauge(\"pool.queued_slots\", slot_stats[\"queued\"], tags={\"pool_name\": pool_name})\n-                Stats.gauge(\"pool.running_slots\", slot_stats[\"running\"], tags={\"pool_name\": pool_name})\n-                Stats.gauge(\"pool.deferred_slots\", slot_stats[\"deferred\"], tags={\"pool_name\": pool_name})\n-                Stats.gauge(\"pool.scheduled_slots\", slot_stats[\"scheduled\"], tags={\"pool_name\": pool_name})\n+                # If enabled on the config, publish metrics twice,\n+                # once with backward compatible name, and then with tags.\n+                DualStatsManager.gauge(\n+                    f\"pool.open_slots.{pool_name}\",\n+                    \"pool.open_slots\",\n+                    slot_stats[\"open\"],\n+                    tags={},\n+                    extra_tags={\"pool_name\": pool_name},\n+                )",
      "comment": "I didn't check all cases in this PR, but I wonder if we could do this as \r\n```suggestion\r\n                DualStatsManager.gauge(\r\n                    \"pool.open_slots\",\r\n                    slot_stats[\"open\"],\r\n                    tags={},\r\n                    extra_tags={\"pool_name\": pool_name},\r\n                )\r\n```\r\n\r\nAnd then we can build the old name via something like this:\r\n\r\n```python\r\nmetric_name = metric + \".\".join(extra_tags.values())\r\n```\r\n\r\nwdyt?",
      "comment_id": 2253687812,
      "user": "ashb",
      "created_at": "2025-08-05T09:22:04Z",
      "url": "https://github.com/apache/airflow/pull/53722#discussion_r2253687812"
    },
    {
      "repo": "apache/airflow",
      "pr_number": 53722,
      "file_path": "devel-common/src/tests_common/test_utils/otel_utils.py",
      "line": 107,
      "side": "RIGHT",
      "diff_hunk": "@@ -94,14 +95,23 @@ def clean_task_lines(lines: list) -> list:\n     return cleaned_lines\n \n \n-def extract_spans_from_output(output_lines: list):\n+def _extract_obj_from_output(output_lines: list[str], kind: str):\n     \"\"\"\n-    For a given list of ConsoleSpanExporter output lines, it extracts the json spans and creates two dictionaries.\n-\n-    :return: root spans dict (key: root_span_id - value: root_span), spans dict (key: span_id - value: span)\n+    Used to extract spans or metrics from the output.\n+\n+    Parameters\n+    ----------\n+    output_lines : list[str]\n+        The captured stdout split into lines.\n+    kind : \"spans\" | \"metrics\"\n+        Which json type to extract from the output.",
      "comment": "```suggestion\r\n    Parameters\r\n    ----------\r\n    :param output_lines: The captured stdout split into lines.\r\n    :param kind: Which json type to extract from the output.\r\n```",
      "comment_id": 2253693239,
      "user": "ashb",
      "created_at": "2025-08-05T09:24:20Z",
      "url": "https://github.com/apache/airflow/pull/53722#discussion_r2253693239"
    },
    {
      "repo": "apache/airflow",
      "pr_number": 53722,
      "file_path": "devel-common/src/tests_common/test_utils/otel_utils.py",
      "line": 98,
      "side": "RIGHT",
      "diff_hunk": "@@ -94,14 +95,23 @@ def clean_task_lines(lines: list) -> list:\n     return cleaned_lines\n \n \n-def extract_spans_from_output(output_lines: list):\n+def _extract_obj_from_output(output_lines: list[str], kind: str):",
      "comment": "```suggestion\r\ndef _extract_obj_from_output(output_lines: list[str], kind: Literal[\"spans\"] | Literal[\"metrics\"]):\r\n```",
      "comment_id": 2253693781,
      "user": "ashb",
      "created_at": "2025-08-05T09:24:35Z",
      "url": "https://github.com/apache/airflow/pull/53722#discussion_r2253693781"
    },
    {
      "repo": "apache/airflow",
      "pr_number": 53722,
      "file_path": "providers/edge3/src/airflow/providers/edge3/models/edge_worker.py",
      "line": 40,
      "side": "RIGHT",
      "diff_hunk": "@@ -27,13 +27,18 @@\n \n from airflow.exceptions import AirflowException\n from airflow.models.base import Base\n+from airflow.providers.edge3.version_compat import AIRFLOW_V_3_1_PLUS\n from airflow.stats import Stats\n-from airflow.utils import timezone\n from airflow.utils.log.logging_mixin import LoggingMixin\n from airflow.utils.providers_configuration_loader import providers_configuration_loaded\n from airflow.utils.session import NEW_SESSION, provide_session\n from airflow.utils.sqlalchemy import UtcDateTime\n \n+if AIRFLOW_V_3_1_PLUS:\n+    from airflow.sdk import timezone\n+else:\n+    from airflow.utils import timezone  # type: ignore[attr-defined,no-redef]",
      "comment": "```suggestion\r\ntry:\r\n    from airflow.sdk import timezone\r\nexcept ImportError:\r\n    from airflow.utils import timezone  # type: ignore[attr-defined,no-redef]\r\n```\r\n\r\nBetter not to use version checks, especially as this an import from TaskSDK, which is working torwards independence from the Airflow version.",
      "comment_id": 2253696298,
      "user": "ashb",
      "created_at": "2025-08-05T09:25:39Z",
      "url": "https://github.com/apache/airflow/pull/53722#discussion_r2253696298"
    },
    {
      "repo": "apache/airflow",
      "pr_number": 53722,
      "file_path": "providers/edge3/src/airflow/providers/edge3/version_compat.py",
      "line": 47,
      "side": "RIGHT",
      "diff_hunk": "@@ -33,3 +33,15 @@ def get_base_airflow_version_tuple() -> tuple[int, int, int]:\n \n \n AIRFLOW_V_3_0_PLUS = get_base_airflow_version_tuple() >= (3, 0, 0)\n+AIRFLOW_V_3_1_PLUS: bool = get_base_airflow_version_tuple() >= (3, 1, 0)\n+\n+if AIRFLOW_V_3_0_PLUS:\n+    from airflow.sdk import BaseOperator\n+else:\n+    from airflow.models import BaseOperator\n+\n+__all__ = [\n+    \"AIRFLOW_V_3_0_PLUS\",\n+    \"AIRFLOW_V_3_1_PLUS\",\n+    \"BaseOperator\",\n+]",
      "comment": "Ditto here\r\n```suggestion\r\n\r\ntry:\r\n    from airflow.sdk import BaseOperator\r\nexcept ImportError:\r\n    from airflow.models import BaseOperator\r\n\r\n__all__ = [\r\n    \"AIRFLOW_V_3_0_PLUS\",\r\n    \"BaseOperator\",\r\n]\r\n```",
      "comment_id": 2253700555,
      "user": "ashb",
      "created_at": "2025-08-05T09:27:22Z",
      "url": "https://github.com/apache/airflow/pull/53722#discussion_r2253700555"
    },
    {
      "repo": "apache/airflow",
      "pr_number": 53722,
      "file_path": "providers/edge3/src/airflow/providers/edge3/version_compat.py",
      "line": 47,
      "side": "RIGHT",
      "diff_hunk": "@@ -33,3 +33,15 @@ def get_base_airflow_version_tuple() -> tuple[int, int, int]:\n \n \n AIRFLOW_V_3_0_PLUS = get_base_airflow_version_tuple() >= (3, 0, 0)\n+AIRFLOW_V_3_1_PLUS: bool = get_base_airflow_version_tuple() >= (3, 1, 0)\n+\n+if AIRFLOW_V_3_0_PLUS:\n+    from airflow.sdk import BaseOperator\n+else:\n+    from airflow.models import BaseOperator\n+\n+__all__ = [\n+    \"AIRFLOW_V_3_0_PLUS\",\n+    \"AIRFLOW_V_3_1_PLUS\",\n+    \"BaseOperator\",\n+]",
      "comment": "A few more places have this pattern that I haven't commented on",
      "comment_id": 2253701174,
      "user": "ashb",
      "created_at": "2025-08-05T09:27:37Z",
      "url": "https://github.com/apache/airflow/pull/53722#discussion_r2253701174"
    },
    {
      "repo": "apache/airflow",
      "pr_number": 53722,
      "file_path": "providers/openlineage/src/airflow/providers/openlineage/plugins/adapter.py",
      "line": 174,
      "side": "RIGHT",
      "diff_hunk": "@@ -157,15 +158,30 @@ def emit(self, event: RunEvent):\n         transport_type = f\"{self._client.transport.kind}\".lower()\n \n         try:\n-            with ExitStack() as stack:\n-                stack.enter_context(Stats.timer(f\"ol.emit.attempts.{event_type}.{transport_type}\"))\n-                stack.enter_context(Stats.timer(\"ol.emit.attempts\"))\n-                self._client.emit(redacted_event)\n-                self.log.info(\n-                    \"Successfully emitted OpenLineage `%s` event of id `%s`\",\n-                    event_type.upper(),\n-                    event.run.runId,\n-                )\n+            if AIRFLOW_V_3_1_PLUS:\n+                from airflow.metrics.dual_stats_manager import DualStatsManager\n+\n+                # If enabled on the config, publish metrics twice,\n+                # once with backward compatible name, and then with tags.\n+                with DualStatsManager.timer(\n+                    f\"ol.emit.attempts.{event_type}.{transport_type}\", \"ol.emit.attempts\"\n+                ):\n+                    self._client.emit(redacted_event)\n+                    self.log.info(\n+                        \"Successfully emitted OpenLineage `%s` event of id `%s`\",\n+                        event_type.upper(),\n+                        event.run.runId,\n+                    )",
      "comment": "Rather than duplicating the code here, I think it would be better to use the exist stack and have this as something like\r\n\r\n```python\r\n            with ExitStack() as stack:\r\n                if AIRFLOW_V_3_1_PLUS:\r\n                    stack.enter_context(DualStatsManager)\r\n                else:\r\n                    stack.enter_context(Stats.timer(...))\r\n                    stack.enter_context(Stats.timer(...))\r\n\r\n                self._client.emit(redacted_event)\r\n                self.log.info(\r\n                    \"Successfully emitted OpenLineage `%s` event of id `%s`\",\r\n                    event_type.upper(),\r\n                    event.run.runId,\r\n                )\r\n```",
      "comment_id": 2253707802,
      "user": "ashb",
      "created_at": "2025-08-05T09:30:04Z",
      "url": "https://github.com/apache/airflow/pull/53722#discussion_r2253707802"
    },
    {
      "repo": "apache/airflow",
      "pr_number": 53722,
      "file_path": "airflow-core/src/airflow/jobs/scheduler_job_runner.py",
      "line": 2517,
      "side": "RIGHT",
      "diff_hunk": "@@ -2108,18 +2136,43 @@ def _emit_pool_metrics(self, session: Session = NEW_SESSION) -> None:\n         with DebugTrace.start_span(span_name=\"emit_pool_metrics\", component=\"SchedulerJobRunner\") as span:\n             pools = Pool.slots_stats(session=session)\n             for pool_name, slot_stats in pools.items():\n-                Stats.gauge(f\"pool.open_slots.{pool_name}\", slot_stats[\"open\"])\n-                Stats.gauge(f\"pool.queued_slots.{pool_name}\", slot_stats[\"queued\"])\n-                Stats.gauge(f\"pool.running_slots.{pool_name}\", slot_stats[\"running\"])\n-                Stats.gauge(f\"pool.deferred_slots.{pool_name}\", slot_stats[\"deferred\"])\n-                Stats.gauge(f\"pool.scheduled_slots.{pool_name}\", slot_stats[\"scheduled\"])\n-\n-                # Same metrics with tagging\n-                Stats.gauge(\"pool.open_slots\", slot_stats[\"open\"], tags={\"pool_name\": pool_name})\n-                Stats.gauge(\"pool.queued_slots\", slot_stats[\"queued\"], tags={\"pool_name\": pool_name})\n-                Stats.gauge(\"pool.running_slots\", slot_stats[\"running\"], tags={\"pool_name\": pool_name})\n-                Stats.gauge(\"pool.deferred_slots\", slot_stats[\"deferred\"], tags={\"pool_name\": pool_name})\n-                Stats.gauge(\"pool.scheduled_slots\", slot_stats[\"scheduled\"], tags={\"pool_name\": pool_name})\n+                # If enabled on the config, publish metrics twice,\n+                # once with backward compatible name, and then with tags.\n+                DualStatsManager.gauge(\n+                    f\"pool.open_slots.{pool_name}\",\n+                    \"pool.open_slots\",\n+                    slot_stats[\"open\"],\n+                    tags={},\n+                    extra_tags={\"pool_name\": pool_name},\n+                )",
      "comment": "We could iterate over the tags and for each tag, add a dot and the value in the name. That would standardize it, but the legacy names don't always follow the same format.\r\n\r\nFor example, in the `dagrun` the legacy name contains just the `dag_id` but the tags have extra info.\r\n\r\nHere are some examples,\r\n\r\nhttps://github.com/apache/airflow/blob/e4c01c3b330c68feff7cd7dee0983858e6d6c2d0/airflow-core/src/airflow/models/dagrun.py#L1723-L1728\r\n\r\nhttps://github.com/apache/airflow/blob/e4c01c3b330c68feff7cd7dee0983858e6d6c2d0/airflow-core/src/airflow/models/dagrun.py#L1153-L1158\r\n\r\nand these are the tags\r\n\r\nhttps://github.com/apache/airflow/blob/e4c01c3b330c68feff7cd7dee0983858e6d6c2d0/airflow-core/src/airflow/models/dagrun.py#L426-L427",
      "comment_id": 2253873622,
      "user": "xBis7",
      "created_at": "2025-08-05T10:10:07Z",
      "url": "https://github.com/apache/airflow/pull/53722#discussion_r2253873622"
    },
    {
      "repo": "apache/airflow",
      "pr_number": 53722,
      "file_path": "airflow-core/src/airflow/jobs/scheduler_job_runner.py",
      "line": 2517,
      "side": "RIGHT",
      "diff_hunk": "@@ -2108,18 +2136,43 @@ def _emit_pool_metrics(self, session: Session = NEW_SESSION) -> None:\n         with DebugTrace.start_span(span_name=\"emit_pool_metrics\", component=\"SchedulerJobRunner\") as span:\n             pools = Pool.slots_stats(session=session)\n             for pool_name, slot_stats in pools.items():\n-                Stats.gauge(f\"pool.open_slots.{pool_name}\", slot_stats[\"open\"])\n-                Stats.gauge(f\"pool.queued_slots.{pool_name}\", slot_stats[\"queued\"])\n-                Stats.gauge(f\"pool.running_slots.{pool_name}\", slot_stats[\"running\"])\n-                Stats.gauge(f\"pool.deferred_slots.{pool_name}\", slot_stats[\"deferred\"])\n-                Stats.gauge(f\"pool.scheduled_slots.{pool_name}\", slot_stats[\"scheduled\"])\n-\n-                # Same metrics with tagging\n-                Stats.gauge(\"pool.open_slots\", slot_stats[\"open\"], tags={\"pool_name\": pool_name})\n-                Stats.gauge(\"pool.queued_slots\", slot_stats[\"queued\"], tags={\"pool_name\": pool_name})\n-                Stats.gauge(\"pool.running_slots\", slot_stats[\"running\"], tags={\"pool_name\": pool_name})\n-                Stats.gauge(\"pool.deferred_slots\", slot_stats[\"deferred\"], tags={\"pool_name\": pool_name})\n-                Stats.gauge(\"pool.scheduled_slots\", slot_stats[\"scheduled\"], tags={\"pool_name\": pool_name})\n+                # If enabled on the config, publish metrics twice,\n+                # once with backward compatible name, and then with tags.\n+                DualStatsManager.gauge(\n+                    f\"pool.open_slots.{pool_name}\",\n+                    \"pool.open_slots\",\n+                    slot_stats[\"open\"],\n+                    tags={},\n+                    extra_tags={\"pool_name\": pool_name},\n+                )",
      "comment": "Maybe then a `legacy_name` that defaults to None and is generated in that case? That would make most cases simpler?",
      "comment_id": 2253949087,
      "user": "ashb",
      "created_at": "2025-08-05T10:41:20Z",
      "url": "https://github.com/apache/airflow/pull/53722#discussion_r2253949087"
    },
    {
      "repo": "apache/airflow",
      "pr_number": 53722,
      "file_path": "airflow-core/src/airflow/jobs/scheduler_job_runner.py",
      "line": 2517,
      "side": "RIGHT",
      "diff_hunk": "@@ -2108,18 +2136,43 @@ def _emit_pool_metrics(self, session: Session = NEW_SESSION) -> None:\n         with DebugTrace.start_span(span_name=\"emit_pool_metrics\", component=\"SchedulerJobRunner\") as span:\n             pools = Pool.slots_stats(session=session)\n             for pool_name, slot_stats in pools.items():\n-                Stats.gauge(f\"pool.open_slots.{pool_name}\", slot_stats[\"open\"])\n-                Stats.gauge(f\"pool.queued_slots.{pool_name}\", slot_stats[\"queued\"])\n-                Stats.gauge(f\"pool.running_slots.{pool_name}\", slot_stats[\"running\"])\n-                Stats.gauge(f\"pool.deferred_slots.{pool_name}\", slot_stats[\"deferred\"])\n-                Stats.gauge(f\"pool.scheduled_slots.{pool_name}\", slot_stats[\"scheduled\"])\n-\n-                # Same metrics with tagging\n-                Stats.gauge(\"pool.open_slots\", slot_stats[\"open\"], tags={\"pool_name\": pool_name})\n-                Stats.gauge(\"pool.queued_slots\", slot_stats[\"queued\"], tags={\"pool_name\": pool_name})\n-                Stats.gauge(\"pool.running_slots\", slot_stats[\"running\"], tags={\"pool_name\": pool_name})\n-                Stats.gauge(\"pool.deferred_slots\", slot_stats[\"deferred\"], tags={\"pool_name\": pool_name})\n-                Stats.gauge(\"pool.scheduled_slots\", slot_stats[\"scheduled\"], tags={\"pool_name\": pool_name})\n+                # If enabled on the config, publish metrics twice,\n+                # once with backward compatible name, and then with tags.\n+                DualStatsManager.gauge(\n+                    f\"pool.open_slots.{pool_name}\",\n+                    \"pool.open_slots\",\n+                    slot_stats[\"open\"],\n+                    tags={},\n+                    extra_tags={\"pool_name\": pool_name},\n+                )",
      "comment": "When it defaults to `None`, we will append all available tags to the legacy_name? \r\n \r\nMy preference would be to remove the legacy names entirely but I don't know how many people are using the names in their workflows to gather stats. That's why I tried to keep the exports the same and tried to make the existing tests work with the new code.\r\n\r\nYour suggestion will make the code simpler but it might not be that easy to maintain exactly the same metrics as before.",
      "comment_id": 2254001767,
      "user": "xBis7",
      "created_at": "2025-08-05T11:05:13Z",
      "url": "https://github.com/apache/airflow/pull/53722#discussion_r2254001767"
    },
    {
      "repo": "apache/airflow",
      "pr_number": 53722,
      "file_path": "providers/edge3/src/airflow/providers/edge3/models/edge_worker.py",
      "line": 30,
      "side": "RIGHT",
      "diff_hunk": "@@ -27,13 +27,18 @@\n \n from airflow.exceptions import AirflowException\n from airflow.models.base import Base\n+from airflow.providers.edge3.version_compat import AIRFLOW_V_3_1_PLUS",
      "comment": "This is still needed because it's used later on \r\n\r\nhttps://github.com/apache/airflow/blob/2f737d2e252e8651f877ee2ab809475db9d8f62e/providers/edge3/src/airflow/providers/edge3/models/edge_worker.py#L173-L225",
      "comment_id": 2254608903,
      "user": "xBis7",
      "created_at": "2025-08-05T14:54:48Z",
      "url": "https://github.com/apache/airflow/pull/53722#discussion_r2254608903"
    },
    {
      "repo": "apache/airflow",
      "pr_number": 53722,
      "file_path": "providers/edge3/src/airflow/providers/edge3/version_compat.py",
      "line": 47,
      "side": "RIGHT",
      "diff_hunk": "@@ -33,3 +33,15 @@ def get_base_airflow_version_tuple() -> tuple[int, int, int]:\n \n \n AIRFLOW_V_3_0_PLUS = get_base_airflow_version_tuple() >= (3, 0, 0)\n+AIRFLOW_V_3_1_PLUS: bool = get_base_airflow_version_tuple() >= (3, 1, 0)\n+\n+if AIRFLOW_V_3_0_PLUS:\n+    from airflow.sdk import BaseOperator\n+else:\n+    from airflow.models import BaseOperator\n+\n+__all__ = [\n+    \"AIRFLOW_V_3_0_PLUS\",\n+    \"AIRFLOW_V_3_1_PLUS\",\n+    \"BaseOperator\",\n+]",
      "comment": "I get the idea but we still need \r\n\r\n```\r\nAIRFLOW_V_3_1_PLUS: bool = get_base_airflow_version_tuple() >= (3, 1, 0)\r\n```\r\n\r\nin order to check whether to use the `DualStatsManager` or the original code. Otherwise there are compatibility issues because the `DualStatsManager` doesn't exist in older providers.",
      "comment_id": 2254693193,
      "user": "xBis7",
      "created_at": "2025-08-05T15:26:39Z",
      "url": "https://github.com/apache/airflow/pull/53722#discussion_r2254693193"
    },
    {
      "repo": "apache/airflow",
      "pr_number": 53722,
      "file_path": "airflow-core/src/airflow/jobs/scheduler_job_runner.py",
      "line": 2517,
      "side": "RIGHT",
      "diff_hunk": "@@ -2108,18 +2136,43 @@ def _emit_pool_metrics(self, session: Session = NEW_SESSION) -> None:\n         with DebugTrace.start_span(span_name=\"emit_pool_metrics\", component=\"SchedulerJobRunner\") as span:\n             pools = Pool.slots_stats(session=session)\n             for pool_name, slot_stats in pools.items():\n-                Stats.gauge(f\"pool.open_slots.{pool_name}\", slot_stats[\"open\"])\n-                Stats.gauge(f\"pool.queued_slots.{pool_name}\", slot_stats[\"queued\"])\n-                Stats.gauge(f\"pool.running_slots.{pool_name}\", slot_stats[\"running\"])\n-                Stats.gauge(f\"pool.deferred_slots.{pool_name}\", slot_stats[\"deferred\"])\n-                Stats.gauge(f\"pool.scheduled_slots.{pool_name}\", slot_stats[\"scheduled\"])\n-\n-                # Same metrics with tagging\n-                Stats.gauge(\"pool.open_slots\", slot_stats[\"open\"], tags={\"pool_name\": pool_name})\n-                Stats.gauge(\"pool.queued_slots\", slot_stats[\"queued\"], tags={\"pool_name\": pool_name})\n-                Stats.gauge(\"pool.running_slots\", slot_stats[\"running\"], tags={\"pool_name\": pool_name})\n-                Stats.gauge(\"pool.deferred_slots\", slot_stats[\"deferred\"], tags={\"pool_name\": pool_name})\n-                Stats.gauge(\"pool.scheduled_slots\", slot_stats[\"scheduled\"], tags={\"pool_name\": pool_name})\n+                # If enabled on the config, publish metrics twice,\n+                # once with backward compatible name, and then with tags.\n+                DualStatsManager.gauge(\n+                    f\"pool.open_slots.{pool_name}\",\n+                    \"pool.open_slots\",\n+                    slot_stats[\"open\"],\n+                    tags={},\n+                    extra_tags={\"pool_name\": pool_name},\n+                )",
      "comment": "When I considered this problem in the past I had a half-baked idea of creating a \"metrics registry\" (a yaml file?) which would serve the purpose of being used to build the metrics documentation page so it was always up to date, and also providing a regex pattern for the old name conversion.  I don't know if you want to attempt that approach or not, but it's (half of) a thought.  Something like:\r\n\r\n- metrics\r\n  - metric_name_1\r\n    - description\r\n    - type\r\n    - legacy_name_pattern\r\n  - metric_name_2  \r\n  \r\n\r\nThen the table at https://airflow.apache.org/docs/apache-airflow/stable/administration-and-deployment/logging-monitoring/metrics.html#metric-descriptions could be built from that and we could use a static check to make sure that yaml (and therefor the docs) are always up to date.",
      "comment_id": 2393070561,
      "user": "ferruzzi",
      "created_at": "2025-09-30T23:44:34Z",
      "url": "https://github.com/apache/airflow/pull/53722#discussion_r2393070561"
    },
    {
      "repo": "apache/airflow",
      "pr_number": 53722,
      "file_path": "airflow-core/src/airflow/jobs/scheduler_job_runner.py",
      "line": 2517,
      "side": "RIGHT",
      "diff_hunk": "@@ -2108,18 +2136,43 @@ def _emit_pool_metrics(self, session: Session = NEW_SESSION) -> None:\n         with DebugTrace.start_span(span_name=\"emit_pool_metrics\", component=\"SchedulerJobRunner\") as span:\n             pools = Pool.slots_stats(session=session)\n             for pool_name, slot_stats in pools.items():\n-                Stats.gauge(f\"pool.open_slots.{pool_name}\", slot_stats[\"open\"])\n-                Stats.gauge(f\"pool.queued_slots.{pool_name}\", slot_stats[\"queued\"])\n-                Stats.gauge(f\"pool.running_slots.{pool_name}\", slot_stats[\"running\"])\n-                Stats.gauge(f\"pool.deferred_slots.{pool_name}\", slot_stats[\"deferred\"])\n-                Stats.gauge(f\"pool.scheduled_slots.{pool_name}\", slot_stats[\"scheduled\"])\n-\n-                # Same metrics with tagging\n-                Stats.gauge(\"pool.open_slots\", slot_stats[\"open\"], tags={\"pool_name\": pool_name})\n-                Stats.gauge(\"pool.queued_slots\", slot_stats[\"queued\"], tags={\"pool_name\": pool_name})\n-                Stats.gauge(\"pool.running_slots\", slot_stats[\"running\"], tags={\"pool_name\": pool_name})\n-                Stats.gauge(\"pool.deferred_slots\", slot_stats[\"deferred\"], tags={\"pool_name\": pool_name})\n-                Stats.gauge(\"pool.scheduled_slots\", slot_stats[\"scheduled\"], tags={\"pool_name\": pool_name})\n+                # If enabled on the config, publish metrics twice,\n+                # once with backward compatible name, and then with tags.\n+                DualStatsManager.gauge(\n+                    f\"pool.open_slots.{pool_name}\",\n+                    \"pool.open_slots\",\n+                    slot_stats[\"open\"],\n+                    tags={},\n+                    extra_tags={\"pool_name\": pool_name},\n+                )",
      "comment": "> also providing a regex pattern for the old name conversion.\r\n\r\n@ferruzzi Do you mean forcing all legacy metric names to follow the same convention?\r\n\r\nRight now, it goes like this\r\n\r\n* name: `<metric_name>`\r\n* legacy: `<metric_name>.<variables>`\r\n\r\nIn place of `<variables>` we could have any number of values. It could be one or more, all connected with dots. E.g. `<metric_name>.dag_id` or `<metric_name>.dag_id.task_id`. ",
      "comment_id": 2445258491,
      "user": "xBis7",
      "created_at": "2025-10-20T14:52:06Z",
      "url": "https://github.com/apache/airflow/pull/53722#discussion_r2445258491"
    },
    {
      "repo": "apache/airflow",
      "pr_number": 53722,
      "file_path": "airflow-core/src/airflow/jobs/scheduler_job_runner.py",
      "line": 2517,
      "side": "RIGHT",
      "diff_hunk": "@@ -2108,18 +2136,43 @@ def _emit_pool_metrics(self, session: Session = NEW_SESSION) -> None:\n         with DebugTrace.start_span(span_name=\"emit_pool_metrics\", component=\"SchedulerJobRunner\") as span:\n             pools = Pool.slots_stats(session=session)\n             for pool_name, slot_stats in pools.items():\n-                Stats.gauge(f\"pool.open_slots.{pool_name}\", slot_stats[\"open\"])\n-                Stats.gauge(f\"pool.queued_slots.{pool_name}\", slot_stats[\"queued\"])\n-                Stats.gauge(f\"pool.running_slots.{pool_name}\", slot_stats[\"running\"])\n-                Stats.gauge(f\"pool.deferred_slots.{pool_name}\", slot_stats[\"deferred\"])\n-                Stats.gauge(f\"pool.scheduled_slots.{pool_name}\", slot_stats[\"scheduled\"])\n-\n-                # Same metrics with tagging\n-                Stats.gauge(\"pool.open_slots\", slot_stats[\"open\"], tags={\"pool_name\": pool_name})\n-                Stats.gauge(\"pool.queued_slots\", slot_stats[\"queued\"], tags={\"pool_name\": pool_name})\n-                Stats.gauge(\"pool.running_slots\", slot_stats[\"running\"], tags={\"pool_name\": pool_name})\n-                Stats.gauge(\"pool.deferred_slots\", slot_stats[\"deferred\"], tags={\"pool_name\": pool_name})\n-                Stats.gauge(\"pool.scheduled_slots\", slot_stats[\"scheduled\"], tags={\"pool_name\": pool_name})\n+                # If enabled on the config, publish metrics twice,\n+                # once with backward compatible name, and then with tags.\n+                DualStatsManager.gauge(\n+                    f\"pool.open_slots.{pool_name}\",\n+                    \"pool.open_slots\",\n+                    slot_stats[\"open\"],\n+                    tags={},\n+                    extra_tags={\"pool_name\": pool_name},\n+                )",
      "comment": "No, I was thinking we could maybe have a default regex pattern, but not all legacy names follow the same naming convention so the legacy_name_pattern would let us define the regex pattern for each, or only for the ones that don't follow the default.",
      "comment_id": 2445839487,
      "user": "ferruzzi",
      "created_at": "2025-10-20T18:52:37Z",
      "url": "https://github.com/apache/airflow/pull/53722#discussion_r2445839487"
    },
    {
      "repo": "apache/airflow",
      "pr_number": 53722,
      "file_path": "airflow-core/src/airflow/jobs/scheduler_job_runner.py",
      "line": 2517,
      "side": "RIGHT",
      "diff_hunk": "@@ -2108,18 +2136,43 @@ def _emit_pool_metrics(self, session: Session = NEW_SESSION) -> None:\n         with DebugTrace.start_span(span_name=\"emit_pool_metrics\", component=\"SchedulerJobRunner\") as span:\n             pools = Pool.slots_stats(session=session)\n             for pool_name, slot_stats in pools.items():\n-                Stats.gauge(f\"pool.open_slots.{pool_name}\", slot_stats[\"open\"])\n-                Stats.gauge(f\"pool.queued_slots.{pool_name}\", slot_stats[\"queued\"])\n-                Stats.gauge(f\"pool.running_slots.{pool_name}\", slot_stats[\"running\"])\n-                Stats.gauge(f\"pool.deferred_slots.{pool_name}\", slot_stats[\"deferred\"])\n-                Stats.gauge(f\"pool.scheduled_slots.{pool_name}\", slot_stats[\"scheduled\"])\n-\n-                # Same metrics with tagging\n-                Stats.gauge(\"pool.open_slots\", slot_stats[\"open\"], tags={\"pool_name\": pool_name})\n-                Stats.gauge(\"pool.queued_slots\", slot_stats[\"queued\"], tags={\"pool_name\": pool_name})\n-                Stats.gauge(\"pool.running_slots\", slot_stats[\"running\"], tags={\"pool_name\": pool_name})\n-                Stats.gauge(\"pool.deferred_slots\", slot_stats[\"deferred\"], tags={\"pool_name\": pool_name})\n-                Stats.gauge(\"pool.scheduled_slots\", slot_stats[\"scheduled\"], tags={\"pool_name\": pool_name})\n+                # If enabled on the config, publish metrics twice,\n+                # once with backward compatible name, and then with tags.\n+                DualStatsManager.gauge(\n+                    f\"pool.open_slots.{pool_name}\",\n+                    \"pool.open_slots\",\n+                    slot_stats[\"open\"],\n+                    tags={},\n+                    extra_tags={\"pool_name\": pool_name},\n+                )",
      "comment": "> or only for the ones that don't follow the default.\r\n\r\nI think you mean that we can't define a pattern for the ones that don't follow the default naming convention.\r\n\r\nOr do you mean define a pattern so that they don't deviate much and make sure that the pattern is followed?",
      "comment_id": 2448796127,
      "user": "xBis7",
      "created_at": "2025-10-21T15:35:00Z",
      "url": "https://github.com/apache/airflow/pull/53722#discussion_r2448796127"
    },
    {
      "repo": "apache/airflow",
      "pr_number": 53722,
      "file_path": "airflow-core/src/airflow/jobs/scheduler_job_runner.py",
      "line": 2517,
      "side": "RIGHT",
      "diff_hunk": "@@ -2108,18 +2136,43 @@ def _emit_pool_metrics(self, session: Session = NEW_SESSION) -> None:\n         with DebugTrace.start_span(span_name=\"emit_pool_metrics\", component=\"SchedulerJobRunner\") as span:\n             pools = Pool.slots_stats(session=session)\n             for pool_name, slot_stats in pools.items():\n-                Stats.gauge(f\"pool.open_slots.{pool_name}\", slot_stats[\"open\"])\n-                Stats.gauge(f\"pool.queued_slots.{pool_name}\", slot_stats[\"queued\"])\n-                Stats.gauge(f\"pool.running_slots.{pool_name}\", slot_stats[\"running\"])\n-                Stats.gauge(f\"pool.deferred_slots.{pool_name}\", slot_stats[\"deferred\"])\n-                Stats.gauge(f\"pool.scheduled_slots.{pool_name}\", slot_stats[\"scheduled\"])\n-\n-                # Same metrics with tagging\n-                Stats.gauge(\"pool.open_slots\", slot_stats[\"open\"], tags={\"pool_name\": pool_name})\n-                Stats.gauge(\"pool.queued_slots\", slot_stats[\"queued\"], tags={\"pool_name\": pool_name})\n-                Stats.gauge(\"pool.running_slots\", slot_stats[\"running\"], tags={\"pool_name\": pool_name})\n-                Stats.gauge(\"pool.deferred_slots\", slot_stats[\"deferred\"], tags={\"pool_name\": pool_name})\n-                Stats.gauge(\"pool.scheduled_slots\", slot_stats[\"scheduled\"], tags={\"pool_name\": pool_name})\n+                # If enabled on the config, publish metrics twice,\n+                # once with backward compatible name, and then with tags.\n+                DualStatsManager.gauge(\n+                    f\"pool.open_slots.{pool_name}\",\n+                    \"pool.open_slots\",\n+                    slot_stats[\"open\"],\n+                    tags={},\n+                    extra_tags={\"pool_name\": pool_name},\n+                )",
      "comment": "LOL  Sory, I'm not explaining my idea very well I guess.  Alright, back this up a bit.  Forget everything about a possible default, that was just adding confusion.\r\n\r\nThe registry entries for `ti.finish.<dag_id>.<task_id>.<state>` and `task_restored_to_dag.<dag_id>` might look like this:\r\n\r\n```\r\nmetrics:\r\n  - name: \"ti.finish\"\r\n    description: \"Number of completed task in a given Dag. Similar to <job_name>_end but for task\"\r\n    type: \"counter\"\r\n    legacy_name: \"ti.finish.{dag_id}.{task_id}.{state}\"\r\n\r\n  - name: \"task_restored_to_dag\"\r\n    description: \"Number of tasks restored for a given Dag (i.e. task instance which was previously in REMOVED state in the DB is added to Dag file). Metric with dag_id and run_type tagging.\"\r\n    type: \"counter\"\r\n    legacy_name: \"task_restored_to_dag.{dag_id}\"\r\n\r\n```\r\n\r\nthen in the code before emitting the metric, we populate the legacy_name template using the metric's `tags`.  \r\n\r\nAs an added bonus, as part of the build-docs script we can walk through this registry and generate the table [in the docs](https://airflow.apache.org/docs/apache-airflow/stable/administration-and-deployment/logging-monitoring/metrics.html) so that doc page is always up to date.",
      "comment_id": 2449691238,
      "user": "ferruzzi",
      "created_at": "2025-10-21T21:00:53Z",
      "url": "https://github.com/apache/airflow/pull/53722#discussion_r2449691238"
    },
    {
      "repo": "apache/airflow",
      "pr_number": 53722,
      "file_path": "airflow-core/src/airflow/jobs/scheduler_job_runner.py",
      "line": 2517,
      "side": "RIGHT",
      "diff_hunk": "@@ -2108,18 +2136,43 @@ def _emit_pool_metrics(self, session: Session = NEW_SESSION) -> None:\n         with DebugTrace.start_span(span_name=\"emit_pool_metrics\", component=\"SchedulerJobRunner\") as span:\n             pools = Pool.slots_stats(session=session)\n             for pool_name, slot_stats in pools.items():\n-                Stats.gauge(f\"pool.open_slots.{pool_name}\", slot_stats[\"open\"])\n-                Stats.gauge(f\"pool.queued_slots.{pool_name}\", slot_stats[\"queued\"])\n-                Stats.gauge(f\"pool.running_slots.{pool_name}\", slot_stats[\"running\"])\n-                Stats.gauge(f\"pool.deferred_slots.{pool_name}\", slot_stats[\"deferred\"])\n-                Stats.gauge(f\"pool.scheduled_slots.{pool_name}\", slot_stats[\"scheduled\"])\n-\n-                # Same metrics with tagging\n-                Stats.gauge(\"pool.open_slots\", slot_stats[\"open\"], tags={\"pool_name\": pool_name})\n-                Stats.gauge(\"pool.queued_slots\", slot_stats[\"queued\"], tags={\"pool_name\": pool_name})\n-                Stats.gauge(\"pool.running_slots\", slot_stats[\"running\"], tags={\"pool_name\": pool_name})\n-                Stats.gauge(\"pool.deferred_slots\", slot_stats[\"deferred\"], tags={\"pool_name\": pool_name})\n-                Stats.gauge(\"pool.scheduled_slots\", slot_stats[\"scheduled\"], tags={\"pool_name\": pool_name})\n+                # If enabled on the config, publish metrics twice,\n+                # once with backward compatible name, and then with tags.\n+                DualStatsManager.gauge(\n+                    f\"pool.open_slots.{pool_name}\",\n+                    \"pool.open_slots\",\n+                    slot_stats[\"open\"],\n+                    tags={},\n+                    extra_tags={\"pool_name\": pool_name},\n+                )",
      "comment": "We could also use the registry to address the initial comment of this thread and simplify the usage of the `DualStatsManager` calls. Each method will only accept the metric name and we will look it up in the registry and get the legacy name from there. @ashb Wdyt?",
      "comment_id": 2450478680,
      "user": "xBis7",
      "created_at": "2025-10-22T05:30:51Z",
      "url": "https://github.com/apache/airflow/pull/53722#discussion_r2450478680"
    },
    {
      "repo": "apache/airflow",
      "pr_number": 53722,
      "file_path": "airflow-core/src/airflow/jobs/scheduler_job_runner.py",
      "line": 2517,
      "side": "RIGHT",
      "diff_hunk": "@@ -2108,18 +2136,43 @@ def _emit_pool_metrics(self, session: Session = NEW_SESSION) -> None:\n         with DebugTrace.start_span(span_name=\"emit_pool_metrics\", component=\"SchedulerJobRunner\") as span:\n             pools = Pool.slots_stats(session=session)\n             for pool_name, slot_stats in pools.items():\n-                Stats.gauge(f\"pool.open_slots.{pool_name}\", slot_stats[\"open\"])\n-                Stats.gauge(f\"pool.queued_slots.{pool_name}\", slot_stats[\"queued\"])\n-                Stats.gauge(f\"pool.running_slots.{pool_name}\", slot_stats[\"running\"])\n-                Stats.gauge(f\"pool.deferred_slots.{pool_name}\", slot_stats[\"deferred\"])\n-                Stats.gauge(f\"pool.scheduled_slots.{pool_name}\", slot_stats[\"scheduled\"])\n-\n-                # Same metrics with tagging\n-                Stats.gauge(\"pool.open_slots\", slot_stats[\"open\"], tags={\"pool_name\": pool_name})\n-                Stats.gauge(\"pool.queued_slots\", slot_stats[\"queued\"], tags={\"pool_name\": pool_name})\n-                Stats.gauge(\"pool.running_slots\", slot_stats[\"running\"], tags={\"pool_name\": pool_name})\n-                Stats.gauge(\"pool.deferred_slots\", slot_stats[\"deferred\"], tags={\"pool_name\": pool_name})\n-                Stats.gauge(\"pool.scheduled_slots\", slot_stats[\"scheduled\"], tags={\"pool_name\": pool_name})\n+                # If enabled on the config, publish metrics twice,\n+                # once with backward compatible name, and then with tags.\n+                DualStatsManager.gauge(\n+                    f\"pool.open_slots.{pool_name}\",\n+                    \"pool.open_slots\",\n+                    slot_stats[\"open\"],\n+                    tags={},\n+                    extra_tags={\"pool_name\": pool_name},\n+                )",
      "comment": "@ferruzzi I made the changes. The metric tables are generated from a common yaml file. I replaced the syntax `<variable>` with `{variable}` because we can do something like this\r\n\r\n```python\r\nlegacy_name = \"ti.finish.{dag_id}.{task_id}.{state}\"\r\nformatted_legacy_name = legacy_name.format(dag_id=\"my_dag\", task_id=\"my_task1\", state=\"success\")\r\n```\r\n\r\nI'm not sure if it's worth it. We could end up writing way more code and complicating things with no significant benefit. I'll do a POC first and see how it looks.",
      "comment_id": 2474126706,
      "user": "xBis7",
      "created_at": "2025-10-29T16:16:33Z",
      "url": "https://github.com/apache/airflow/pull/53722#discussion_r2474126706"
    },
    {
      "repo": "apache/airflow",
      "pr_number": 53722,
      "file_path": "airflow-core/src/airflow/jobs/scheduler_job_runner.py",
      "line": 2517,
      "side": "RIGHT",
      "diff_hunk": "@@ -2108,18 +2136,43 @@ def _emit_pool_metrics(self, session: Session = NEW_SESSION) -> None:\n         with DebugTrace.start_span(span_name=\"emit_pool_metrics\", component=\"SchedulerJobRunner\") as span:\n             pools = Pool.slots_stats(session=session)\n             for pool_name, slot_stats in pools.items():\n-                Stats.gauge(f\"pool.open_slots.{pool_name}\", slot_stats[\"open\"])\n-                Stats.gauge(f\"pool.queued_slots.{pool_name}\", slot_stats[\"queued\"])\n-                Stats.gauge(f\"pool.running_slots.{pool_name}\", slot_stats[\"running\"])\n-                Stats.gauge(f\"pool.deferred_slots.{pool_name}\", slot_stats[\"deferred\"])\n-                Stats.gauge(f\"pool.scheduled_slots.{pool_name}\", slot_stats[\"scheduled\"])\n-\n-                # Same metrics with tagging\n-                Stats.gauge(\"pool.open_slots\", slot_stats[\"open\"], tags={\"pool_name\": pool_name})\n-                Stats.gauge(\"pool.queued_slots\", slot_stats[\"queued\"], tags={\"pool_name\": pool_name})\n-                Stats.gauge(\"pool.running_slots\", slot_stats[\"running\"], tags={\"pool_name\": pool_name})\n-                Stats.gauge(\"pool.deferred_slots\", slot_stats[\"deferred\"], tags={\"pool_name\": pool_name})\n-                Stats.gauge(\"pool.scheduled_slots\", slot_stats[\"scheduled\"], tags={\"pool_name\": pool_name})\n+                # If enabled on the config, publish metrics twice,\n+                # once with backward compatible name, and then with tags.\n+                DualStatsManager.gauge(\n+                    f\"pool.open_slots.{pool_name}\",\n+                    \"pool.open_slots\",\n+                    slot_stats[\"open\"],\n+                    tags={},\n+                    extra_tags={\"pool_name\": pool_name},\n+                )",
      "comment": "I updated the patch. All legacy metrics are accessed through the yaml file. I also added some validations to make sure that the legacy names always exist on the yaml and that we have declared the variables needed for the name.\r\n\r\nI built the yaml using the existing tables from the `metrics.rst`. The failing tests on the CI have to do with the new validations. It seems that some metrics didn't exist in the old docs. I'm going to add them to the yaml and also fix any other failures.",
      "comment_id": 2492956460,
      "user": "xBis7",
      "created_at": "2025-11-05T04:52:47Z",
      "url": "https://github.com/apache/airflow/pull/53722#discussion_r2492956460"
    },
    {
      "repo": "apache/airflow",
      "pr_number": 53722,
      "file_path": "airflow-core/src/airflow/jobs/scheduler_job_runner.py",
      "line": 2517,
      "side": "RIGHT",
      "diff_hunk": "@@ -2108,18 +2136,43 @@ def _emit_pool_metrics(self, session: Session = NEW_SESSION) -> None:\n         with DebugTrace.start_span(span_name=\"emit_pool_metrics\", component=\"SchedulerJobRunner\") as span:\n             pools = Pool.slots_stats(session=session)\n             for pool_name, slot_stats in pools.items():\n-                Stats.gauge(f\"pool.open_slots.{pool_name}\", slot_stats[\"open\"])\n-                Stats.gauge(f\"pool.queued_slots.{pool_name}\", slot_stats[\"queued\"])\n-                Stats.gauge(f\"pool.running_slots.{pool_name}\", slot_stats[\"running\"])\n-                Stats.gauge(f\"pool.deferred_slots.{pool_name}\", slot_stats[\"deferred\"])\n-                Stats.gauge(f\"pool.scheduled_slots.{pool_name}\", slot_stats[\"scheduled\"])\n-\n-                # Same metrics with tagging\n-                Stats.gauge(\"pool.open_slots\", slot_stats[\"open\"], tags={\"pool_name\": pool_name})\n-                Stats.gauge(\"pool.queued_slots\", slot_stats[\"queued\"], tags={\"pool_name\": pool_name})\n-                Stats.gauge(\"pool.running_slots\", slot_stats[\"running\"], tags={\"pool_name\": pool_name})\n-                Stats.gauge(\"pool.deferred_slots\", slot_stats[\"deferred\"], tags={\"pool_name\": pool_name})\n-                Stats.gauge(\"pool.scheduled_slots\", slot_stats[\"scheduled\"], tags={\"pool_name\": pool_name})\n+                # If enabled on the config, publish metrics twice,\n+                # once with backward compatible name, and then with tags.\n+                DualStatsManager.gauge(\n+                    f\"pool.open_slots.{pool_name}\",\n+                    \"pool.open_slots\",\n+                    slot_stats[\"open\"],\n+                    tags={},\n+                    extra_tags={\"pool_name\": pool_name},\n+                )",
      "comment": "Sorry I missed you previous comment from last week.  The way you mentioned you were going to try is exactly my thought as well.\r\n\r\n> The failing tests on the CI have to do with the new validations. It seems that some metrics didn't exist in the old docs\r\n\r\nThat's exactly what I was hoping to catch and fix with the registry idea.  There needs to be a check the other way as well; just because it is in the docs doesn't mean it still exists in the code... but we can do that part later if you want.  That might just be an initial manual cleanup plus a pre-commit hook that checks the commit for changes, but that may be a side project on its own.",
      "comment_id": 2495605286,
      "user": "ferruzzi",
      "created_at": "2025-11-05T18:05:27Z",
      "url": "https://github.com/apache/airflow/pull/53722#discussion_r2495605286"
    },
    {
      "repo": "apache/airflow",
      "pr_number": 53722,
      "file_path": "airflow-core/src/airflow/jobs/scheduler_job_runner.py",
      "line": 656,
      "side": "RIGHT",
      "diff_hunk": "@@ -651,9 +652,14 @@ def _executable_task_instances_to_queued(self, max_tis: int, session: Session) -\n             )\n \n         for pool_name, num_starving_tasks in pool_num_starving_tasks.items():\n-            Stats.gauge(f\"pool.starving_tasks.{pool_name}\", num_starving_tasks)\n-            # Same metric with tagging\n-            Stats.gauge(\"pool.starving_tasks\", num_starving_tasks, tags={\"pool_name\": pool_name})\n+            # If enabled on the config, publish metrics twice,\n+            # once with backward compatible name, and then with tags.",
      "comment": "Just personal preference, but I don't think we need a 2-line comment every time we emit the metrics.  A good docstring in the DualStatsManager should suffice IMHO.",
      "comment_id": 2495614302,
      "user": "ferruzzi",
      "created_at": "2025-11-05T18:08:08Z",
      "url": "https://github.com/apache/airflow/pull/53722#discussion_r2495614302"
    },
    {
      "repo": "apache/airflow",
      "pr_number": 53722,
      "file_path": "airflow-core/src/airflow/jobs/scheduler_job_runner.py",
      "line": 2517,
      "side": "RIGHT",
      "diff_hunk": "@@ -2108,18 +2136,43 @@ def _emit_pool_metrics(self, session: Session = NEW_SESSION) -> None:\n         with DebugTrace.start_span(span_name=\"emit_pool_metrics\", component=\"SchedulerJobRunner\") as span:\n             pools = Pool.slots_stats(session=session)\n             for pool_name, slot_stats in pools.items():\n-                Stats.gauge(f\"pool.open_slots.{pool_name}\", slot_stats[\"open\"])\n-                Stats.gauge(f\"pool.queued_slots.{pool_name}\", slot_stats[\"queued\"])\n-                Stats.gauge(f\"pool.running_slots.{pool_name}\", slot_stats[\"running\"])\n-                Stats.gauge(f\"pool.deferred_slots.{pool_name}\", slot_stats[\"deferred\"])\n-                Stats.gauge(f\"pool.scheduled_slots.{pool_name}\", slot_stats[\"scheduled\"])\n-\n-                # Same metrics with tagging\n-                Stats.gauge(\"pool.open_slots\", slot_stats[\"open\"], tags={\"pool_name\": pool_name})\n-                Stats.gauge(\"pool.queued_slots\", slot_stats[\"queued\"], tags={\"pool_name\": pool_name})\n-                Stats.gauge(\"pool.running_slots\", slot_stats[\"running\"], tags={\"pool_name\": pool_name})\n-                Stats.gauge(\"pool.deferred_slots\", slot_stats[\"deferred\"], tags={\"pool_name\": pool_name})\n-                Stats.gauge(\"pool.scheduled_slots\", slot_stats[\"scheduled\"], tags={\"pool_name\": pool_name})\n+                # If enabled on the config, publish metrics twice,\n+                # once with backward compatible name, and then with tags.\n+                DualStatsManager.gauge(\n+                    f\"pool.open_slots.{pool_name}\",\n+                    \"pool.open_slots\",\n+                    slot_stats[\"open\"],\n+                    tags={},\n+                    extra_tags={\"pool_name\": pool_name},\n+                )",
      "comment": "Right now I added a validation just for when reading the legacy metric from the yaml.\r\n\r\nA pre-commit check or a cross-check validation everytime we try to add a metric to the metric_map would be good to have. But I think that it should happen in another PR because it would widen the scope of this one by a lot.\r\n\r\nJust to get the tests working, I'm adding metrics that have been missing from the docs. The issue is that I'm not entirely sure about the description. I'm reading the code but still what I'm writing is a guess. So the validation PR, should start as a draft with a list of newly documented metrics so that people can add comments and explain what each does.",
      "comment_id": 2495639245,
      "user": "xBis7",
      "created_at": "2025-11-05T18:17:19Z",
      "url": "https://github.com/apache/airflow/pull/53722#discussion_r2495639245"
    },
    {
      "repo": "apache/airflow",
      "pr_number": 53722,
      "file_path": "airflow-core/src/airflow/jobs/scheduler_job_runner.py",
      "line": 2517,
      "side": "RIGHT",
      "diff_hunk": "@@ -2108,18 +2136,43 @@ def _emit_pool_metrics(self, session: Session = NEW_SESSION) -> None:\n         with DebugTrace.start_span(span_name=\"emit_pool_metrics\", component=\"SchedulerJobRunner\") as span:\n             pools = Pool.slots_stats(session=session)\n             for pool_name, slot_stats in pools.items():\n-                Stats.gauge(f\"pool.open_slots.{pool_name}\", slot_stats[\"open\"])\n-                Stats.gauge(f\"pool.queued_slots.{pool_name}\", slot_stats[\"queued\"])\n-                Stats.gauge(f\"pool.running_slots.{pool_name}\", slot_stats[\"running\"])\n-                Stats.gauge(f\"pool.deferred_slots.{pool_name}\", slot_stats[\"deferred\"])\n-                Stats.gauge(f\"pool.scheduled_slots.{pool_name}\", slot_stats[\"scheduled\"])\n-\n-                # Same metrics with tagging\n-                Stats.gauge(\"pool.open_slots\", slot_stats[\"open\"], tags={\"pool_name\": pool_name})\n-                Stats.gauge(\"pool.queued_slots\", slot_stats[\"queued\"], tags={\"pool_name\": pool_name})\n-                Stats.gauge(\"pool.running_slots\", slot_stats[\"running\"], tags={\"pool_name\": pool_name})\n-                Stats.gauge(\"pool.deferred_slots\", slot_stats[\"deferred\"], tags={\"pool_name\": pool_name})\n-                Stats.gauge(\"pool.scheduled_slots\", slot_stats[\"scheduled\"], tags={\"pool_name\": pool_name})\n+                # If enabled on the config, publish metrics twice,\n+                # once with backward compatible name, and then with tags.\n+                DualStatsManager.gauge(\n+                    f\"pool.open_slots.{pool_name}\",\n+                    \"pool.open_slots\",\n+                    slot_stats[\"open\"],\n+                    tags={},\n+                    extra_tags={\"pool_name\": pool_name},\n+                )",
      "comment": "> I think that it should happen in another PR because it would widen the scope of this one by a lot.\r\n\r\nYeah, I'm happy with that.  Sorry to blow the scope out on this one already.  I'm working through the changes but have a lot of meetings today so i may not get through it all today.\r\n\r\nThanks for sticking with this one, I know it's been a pretty long haul ",
      "comment_id": 2495653763,
      "user": "ferruzzi",
      "created_at": "2025-11-05T18:22:48Z",
      "url": "https://github.com/apache/airflow/pull/53722#discussion_r2495653763"
    },
    {
      "repo": "apache/airflow",
      "pr_number": 53722,
      "file_path": "airflow-core/src/airflow/jobs/scheduler_job_runner.py",
      "line": 2517,
      "side": "RIGHT",
      "diff_hunk": "@@ -2108,18 +2136,43 @@ def _emit_pool_metrics(self, session: Session = NEW_SESSION) -> None:\n         with DebugTrace.start_span(span_name=\"emit_pool_metrics\", component=\"SchedulerJobRunner\") as span:\n             pools = Pool.slots_stats(session=session)\n             for pool_name, slot_stats in pools.items():\n-                Stats.gauge(f\"pool.open_slots.{pool_name}\", slot_stats[\"open\"])\n-                Stats.gauge(f\"pool.queued_slots.{pool_name}\", slot_stats[\"queued\"])\n-                Stats.gauge(f\"pool.running_slots.{pool_name}\", slot_stats[\"running\"])\n-                Stats.gauge(f\"pool.deferred_slots.{pool_name}\", slot_stats[\"deferred\"])\n-                Stats.gauge(f\"pool.scheduled_slots.{pool_name}\", slot_stats[\"scheduled\"])\n-\n-                # Same metrics with tagging\n-                Stats.gauge(\"pool.open_slots\", slot_stats[\"open\"], tags={\"pool_name\": pool_name})\n-                Stats.gauge(\"pool.queued_slots\", slot_stats[\"queued\"], tags={\"pool_name\": pool_name})\n-                Stats.gauge(\"pool.running_slots\", slot_stats[\"running\"], tags={\"pool_name\": pool_name})\n-                Stats.gauge(\"pool.deferred_slots\", slot_stats[\"deferred\"], tags={\"pool_name\": pool_name})\n-                Stats.gauge(\"pool.scheduled_slots\", slot_stats[\"scheduled\"], tags={\"pool_name\": pool_name})\n+                # If enabled on the config, publish metrics twice,\n+                # once with backward compatible name, and then with tags.\n+                DualStatsManager.gauge(\n+                    f\"pool.open_slots.{pool_name}\",\n+                    \"pool.open_slots\",\n+                    slot_stats[\"open\"],\n+                    tags={},\n+                    extra_tags={\"pool_name\": pool_name},\n+                )",
      "comment": "Don't worry about it. I'm also not done with the CI errors. Thanks!",
      "comment_id": 2495746142,
      "user": "xBis7",
      "created_at": "2025-11-05T18:55:53Z",
      "url": "https://github.com/apache/airflow/pull/53722#discussion_r2495746142"
    },
    {
      "repo": "apache/airflow",
      "pr_number": 53722,
      "file_path": "providers/openlineage/src/airflow/providers/openlineage/plugins/adapter.py",
      "line": 169,
      "side": "RIGHT",
      "diff_hunk": "@@ -161,8 +161,16 @@ def emit(self, event: RunEvent):\n \n         try:\n             with ExitStack() as stack:\n-                stack.enter_context(Stats.timer(f\"ol.emit.attempts.{event_type}.{transport_type}\"))\n-                stack.enter_context(Stats.timer(\"ol.emit.attempts\"))\n+                try:\n+                    from airflow.metrics.dual_stats_manager import DualStatsManager\n+\n+                    # If enabled on the config, publish metrics twice,\n+                    # once with backward compatible name, and then with tags.\n+                    stack.enter_context(DualStatsManager.timer(\"ol.emit.attempts\"))",
      "comment": "Yes, with the latest changes it will fail to build the legacy metric without them. BTW, that's another metric that doesn't exist in the docs and needs to be added.",
      "comment_id": 2495787706,
      "user": "xBis7",
      "created_at": "2025-11-05T19:10:45Z",
      "url": "https://github.com/apache/airflow/pull/53722#discussion_r2495787706"
    },
    {
      "repo": "apache/airflow",
      "pr_number": 53722,
      "file_path": "providers/openlineage/src/airflow/providers/openlineage/plugins/adapter.py",
      "line": 169,
      "side": "RIGHT",
      "diff_hunk": "@@ -161,8 +161,16 @@ def emit(self, event: RunEvent):\n \n         try:\n             with ExitStack() as stack:\n-                stack.enter_context(Stats.timer(f\"ol.emit.attempts.{event_type}.{transport_type}\"))\n-                stack.enter_context(Stats.timer(\"ol.emit.attempts\"))\n+                try:\n+                    from airflow.metrics.dual_stats_manager import DualStatsManager\n+\n+                    # If enabled on the config, publish metrics twice,\n+                    # once with backward compatible name, and then with tags.\n+                    stack.enter_context(DualStatsManager.timer(\"ol.emit.attempts\"))",
      "comment": ">  BTW, that's another metric that doesn't exist in the docs and needs to be added.\r\n\r\nI love that these are getting caught and updated.  Thanks.    At a guess, how many would you say you've \"discovered\" so far?  I'm concerned what that may mean for ones that we \"advertise\" but don't actually exist.  This is a great step forward.",
      "comment_id": 2497602231,
      "user": "ferruzzi",
      "created_at": "2025-11-06T06:07:48Z",
      "url": "https://github.com/apache/airflow/pull/53722#discussion_r2497602231"
    },
    {
      "repo": "apache/airflow",
      "pr_number": 53722,
      "file_path": "providers/openlineage/src/airflow/providers/openlineage/plugins/adapter.py",
      "line": 169,
      "side": "RIGHT",
      "diff_hunk": "@@ -161,8 +161,16 @@ def emit(self, event: RunEvent):\n \n         try:\n             with ExitStack() as stack:\n-                stack.enter_context(Stats.timer(f\"ol.emit.attempts.{event_type}.{transport_type}\"))\n-                stack.enter_context(Stats.timer(\"ol.emit.attempts\"))\n+                try:\n+                    from airflow.metrics.dual_stats_manager import DualStatsManager\n+\n+                    # If enabled on the config, publish metrics twice,\n+                    # once with backward compatible name, and then with tags.\n+                    stack.enter_context(DualStatsManager.timer(\"ol.emit.attempts\"))",
      "comment": "* https://github.com/apache/airflow/pull/53722/commits/043f1408cd2f34c0dc65c1f05454f1af21de453d#diff-1aa980cab8965838a6274f4d9c6fe4b39229d4b8c4cba216ed4e8a7f072efaa1R58\r\n    * In this one the legacy name was wrong in the docs. (1)\r\n\r\n* https://github.com/apache/airflow/pull/53722/commits/70d022ebe34e10adb25ce740c4d4d6fcaeb16413\r\n    * The variable in the legacy name was different from what was in the docs. (1)\r\n\r\n* https://github.com/apache/airflow/pull/53722/commits/b3053322f3301f733c0dbc97f48ecd05a22607bd\r\n    * 6 missing from the docs.\r\n\r\n* https://github.com/apache/airflow/pull/53722/commits/33d6f5aef4b684dbc6b6e13de7a5e3a79be9d289\r\n    * 1 more missing.\r\n\r\n* https://github.com/apache/airflow/pull/53722/commits/1889f45e59f66e4d85d2bac20082ca8148fb22d2\r\n    * 1 more missing.\r\n\r\nSo, it's 8 missing and 2 where there was a mismatch between the docs and the code. That's the total so far. \r\n\r\n\r\n",
      "comment_id": 2497643895,
      "user": "xBis7",
      "created_at": "2025-11-06T06:28:42Z",
      "url": "https://github.com/apache/airflow/pull/53722#discussion_r2497643895"
    },
    {
      "repo": "apache/airflow",
      "pr_number": 53722,
      "file_path": "devel-common/src/docs/build_docs.py",
      "line": 227,
      "side": "RIGHT",
      "diff_hunk": "@@ -224,6 +224,12 @@ def build_docs_for_packages(\n             builder = AirflowDocsBuilder(package_name=package_name)\n             builder.is_autobuild = is_autobuild\n             builder.clean_files()\n+",
      "comment": "Question: Should we do it as sphinx extension maybe? ",
      "comment_id": 2664266026,
      "user": "potiuk",
      "created_at": "2026-01-06T09:31:05Z",
      "url": "https://github.com/apache/airflow/pull/53722#discussion_r2664266026"
    },
    {
      "repo": "apache/airflow",
      "pr_number": 53722,
      "file_path": "devel-common/src/docs/build_docs.py",
      "line": 227,
      "side": "RIGHT",
      "diff_hunk": "@@ -224,6 +224,12 @@ def build_docs_for_packages(\n             builder = AirflowDocsBuilder(package_name=package_name)\n             builder.is_autobuild = is_autobuild\n             builder.clean_files()\n+",
      "comment": "I haven't worked with sphinx before. I did some research and it turns out you are right. A sphinx extension is cleaner and more suitable for this scenario.\r\n\r\nRight before building the docs, we read the yaml and generate a new metrics table. During the build, the metrics table is there and the `metrics.rst` successfully includes it.\r\n\r\nAn extension will handle the process and make sure that the table is always built and in sync with the yaml during the sphinx startup.\r\n",
      "comment_id": 2686669132,
      "user": "xBis7",
      "created_at": "2026-01-13T14:27:32Z",
      "url": "https://github.com/apache/airflow/pull/53722#discussion_r2686669132"
    },
    {
      "repo": "apache/airflow",
      "pr_number": 56760,
      "file_path": "airflow-core/src/airflow/api_fastapi/core_api/routes/public/hitl.py",
      "line": 96,
      "side": "RIGHT",
      "diff_hunk": "@@ -72,21 +75,31 @@ def _get_task_instance_with_hitl_detail(\n     task_id: str,\n     session: SessionDep,\n     map_index: int,\n-) -> TI:\n-    query = (\n-        select(TI)\n-        .where(\n-            TI.dag_id == dag_id,\n-            TI.run_id == dag_run_id,\n-            TI.task_id == task_id,\n+    try_number: int | None = None,\n+) -> TI | TIH:\n+    def _query(orm_object: Base) -> TI | TIH | None:\n+        query = (\n+            select(orm_object)\n+            .where(\n+                orm_object.dag_id == dag_id,\n+                orm_object.run_id == dag_run_id,\n+                orm_object.task_id == task_id,\n+                orm_object.map_index == map_index,\n+            )\n+            .options(joinedload(orm_object.hitl_detail))\n         )\n-        .options(joinedload(TI.hitl_detail))\n-    )\n \n-    if map_index is not None:\n-        query = query.where(TI.map_index == map_index)\n+        if try_number is not None:\n+            query = query.where(orm_object.try_number == try_number)\n+\n+        task_instance = session.scalar(query)",
      "comment": "This an be TIH, we shouldn't name it `task_instance` I believe \n```suggestion\n        <other_name> = session.scalar(query)\n```",
      "comment_id": 2490750289,
      "user": "pierrejeambrun",
      "created_at": "2025-11-04T14:30:15Z",
      "url": "https://github.com/apache/airflow/pull/56760#discussion_r2490750289"
    },
    {
      "repo": "apache/airflow",
      "pr_number": 56760,
      "file_path": "airflow-core/src/airflow/api_fastapi/core_api/routes/public/hitl.py",
      "line": 218,
      "side": "RIGHT",
      "diff_hunk": "@@ -190,10 +203,37 @@ def get_hitl_detail(\n         task_id=task_id,\n         session=session,\n         map_index=map_index,\n+        try_number=None,\n     )\n     return task_instance.hitl_detail\n \n \n+@task_instances_hitl_router.get(\n+    task_instance_hitl_path + \"/tries/{try_number}\",\n+    status_code=status.HTTP_200_OK,\n+    responses=create_openapi_http_exception_doc([status.HTTP_404_NOT_FOUND]),\n+    dependencies=[Depends(requires_access_dag(method=\"GET\", access_entity=DagAccessEntity.HITL_DETAIL))],\n+)\n+def get_hitl_detail_try(",
      "comment": "Nit:\n```suggestion\ndef get_hitl_try_details(\n```\n\nTo be consistant with `get_task_instance_try_details`\n",
      "comment_id": 2490763073,
      "user": "pierrejeambrun",
      "created_at": "2025-11-04T14:34:02Z",
      "url": "https://github.com/apache/airflow/pull/56760#discussion_r2490763073"
    },
    {
      "repo": "apache/airflow",
      "pr_number": 56760,
      "file_path": "airflow-core/src/airflow/api_fastapi/core_api/routes/public/hitl.py",
      "line": 96,
      "side": "RIGHT",
      "diff_hunk": "@@ -72,21 +75,31 @@ def _get_task_instance_with_hitl_detail(\n     task_id: str,\n     session: SessionDep,\n     map_index: int,\n-) -> TI:\n-    query = (\n-        select(TI)\n-        .where(\n-            TI.dag_id == dag_id,\n-            TI.run_id == dag_run_id,\n-            TI.task_id == task_id,\n+    try_number: int | None = None,\n+) -> TI | TIH:\n+    def _query(orm_object: Base) -> TI | TIH | None:\n+        query = (\n+            select(orm_object)\n+            .where(\n+                orm_object.dag_id == dag_id,\n+                orm_object.run_id == dag_run_id,\n+                orm_object.task_id == task_id,\n+                orm_object.map_index == map_index,\n+            )\n+            .options(joinedload(orm_object.hitl_detail))\n         )\n-        .options(joinedload(TI.hitl_detail))\n-    )\n \n-    if map_index is not None:\n-        query = query.where(TI.map_index == map_index)\n+        if try_number is not None:\n+            query = query.where(orm_object.try_number == try_number)\n+\n+        task_instance = session.scalar(query)",
      "comment": "This pattern is also used here \n\nhttps://github.com/apache/airflow/blob/1aa9b7af38b52afa79d5108a04ceb5fd181682ba/airflow-core/src/airflow/api_fastapi/core_api/routes/public/task_instances.py#L666-L680\n\nThis is TI or TIH. both of them are technically task instance. We could renamed it as `ti_or_tih` but I don't think that's better \ud83e\udd14 ",
      "comment_id": 2563774431,
      "user": "Lee-W",
      "created_at": "2025-11-26T07:47:59Z",
      "url": "https://github.com/apache/airflow/pull/56760#discussion_r2563774431"
    },
    {
      "repo": "apache/airflow",
      "pr_number": 56760,
      "file_path": "airflow-core/src/airflow/api_fastapi/core_api/routes/public/hitl.py",
      "line": 218,
      "side": "RIGHT",
      "diff_hunk": "@@ -190,10 +203,37 @@ def get_hitl_detail(\n         task_id=task_id,\n         session=session,\n         map_index=map_index,\n+        try_number=None,\n     )\n     return task_instance.hitl_detail\n \n \n+@task_instances_hitl_router.get(\n+    task_instance_hitl_path + \"/tries/{try_number}\",\n+    status_code=status.HTTP_200_OK,\n+    responses=create_openapi_http_exception_doc([status.HTTP_404_NOT_FOUND]),\n+    dependencies=[Depends(requires_access_dag(method=\"GET\", access_entity=DagAccessEntity.HITL_DETAIL))],\n+)\n+def get_hitl_detail_try(",
      "comment": "then it probably should be `get_hitl_detail_try_details` instead",
      "comment_id": 2563777750,
      "user": "Lee-W",
      "created_at": "2025-11-26T07:48:50Z",
      "url": "https://github.com/apache/airflow/pull/56760#discussion_r2563777750"
    },
    {
      "repo": "apache/airflow",
      "pr_number": 56760,
      "file_path": "airflow-core/src/airflow/api_fastapi/core_api/routes/public/hitl.py",
      "line": 218,
      "side": "RIGHT",
      "diff_hunk": "@@ -190,10 +203,37 @@ def get_hitl_detail(\n         task_id=task_id,\n         session=session,\n         map_index=map_index,\n+        try_number=None,\n     )\n     return task_instance.hitl_detail\n \n \n+@task_instances_hitl_router.get(\n+    task_instance_hitl_path + \"/tries/{try_number}\",\n+    status_code=status.HTTP_200_OK,\n+    responses=create_openapi_http_exception_doc([status.HTTP_404_NOT_FOUND]),\n+    dependencies=[Depends(requires_access_dag(method=\"GET\", access_entity=DagAccessEntity.HITL_DETAIL))],\n+)\n+def get_hitl_detail_try(",
      "comment": "Double `detail` in the name is confusing. I get why it's there though. \r\n\r\nAlso I think in the current impl, you missed the trailing `s` `get_hitl_detail_try_detail`",
      "comment_id": 2577679017,
      "user": "pierrejeambrun",
      "created_at": "2025-12-01T15:57:27Z",
      "url": "https://github.com/apache/airflow/pull/56760#discussion_r2577679017"
    },
    {
      "repo": "apache/airflow",
      "pr_number": 56760,
      "file_path": "airflow-core/src/airflow/api_fastapi/core_api/datamodels/hitl.py",
      "line": 107,
      "side": "RIGHT",
      "diff_hunk": "@@ -101,3 +102,9 @@ class HITLDetailCollection(BaseModel):\n \n     hitl_details: Iterable[HITLDetail]\n     total_entries: int\n+\n+\n+class HITLDetailHisotry(BaseHITLDetail):",
      "comment": "Needs to be deleted, this doesn't exist anymore, it's `HITLDetailHistory`",
      "comment_id": 2577683278,
      "user": "pierrejeambrun",
      "created_at": "2025-12-01T15:58:42Z",
      "url": "https://github.com/apache/airflow/pull/56760#discussion_r2577683278"
    },
    {
      "repo": "apache/airflow",
      "pr_number": 56760,
      "file_path": "airflow-core/src/airflow/api_fastapi/core_api/routes/public/hitl.py",
      "line": 96,
      "side": "RIGHT",
      "diff_hunk": "@@ -72,21 +75,31 @@ def _get_task_instance_with_hitl_detail(\n     task_id: str,\n     session: SessionDep,\n     map_index: int,\n-) -> TI:\n-    query = (\n-        select(TI)\n-        .where(\n-            TI.dag_id == dag_id,\n-            TI.run_id == dag_run_id,\n-            TI.task_id == task_id,\n+    try_number: int | None = None,\n+) -> TI | TIH:\n+    def _query(orm_object: Base) -> TI | TIH | None:\n+        query = (\n+            select(orm_object)\n+            .where(\n+                orm_object.dag_id == dag_id,\n+                orm_object.run_id == dag_run_id,\n+                orm_object.task_id == task_id,\n+                orm_object.map_index == map_index,\n+            )\n+            .options(joinedload(orm_object.hitl_detail))\n         )\n-        .options(joinedload(TI.hitl_detail))\n-    )\n \n-    if map_index is not None:\n-        query = query.where(TI.map_index == map_index)\n+        if try_number is not None:\n+            query = query.where(orm_object.try_number == try_number)\n+\n+        task_instance = session.scalar(query)",
      "comment": "We can name this `rows`, `entities`, `models` anything not confusing us about having TI while they can be TIH too.\r\n\r\n> both of them are technically task instance\r\n\r\nI don't understand this statement. Those are not the same model and don't expose the same interface. If I expect a TI and do `get_task_instance` on this I'll have a problem when it's a TIH.\r\n\r\nIdeally we could fix both places. That's not a big deal though. (so we can do that latter too, i'm fine)\r\n",
      "comment_id": 2577697914,
      "user": "pierrejeambrun",
      "created_at": "2025-12-01T16:02:55Z",
      "url": "https://github.com/apache/airflow/pull/56760#discussion_r2577697914"
    },
    {
      "repo": "apache/airflow",
      "pr_number": 56760,
      "file_path": "airflow-core/src/airflow/api_fastapi/core_api/routes/public/hitl.py",
      "line": 96,
      "side": "RIGHT",
      "diff_hunk": "@@ -72,21 +75,31 @@ def _get_task_instance_with_hitl_detail(\n     task_id: str,\n     session: SessionDep,\n     map_index: int,\n-) -> TI:\n-    query = (\n-        select(TI)\n-        .where(\n-            TI.dag_id == dag_id,\n-            TI.run_id == dag_run_id,\n-            TI.task_id == task_id,\n+    try_number: int | None = None,\n+) -> TI | TIH:\n+    def _query(orm_object: Base) -> TI | TIH | None:\n+        query = (\n+            select(orm_object)\n+            .where(\n+                orm_object.dag_id == dag_id,\n+                orm_object.run_id == dag_run_id,\n+                orm_object.task_id == task_id,\n+                orm_object.map_index == map_index,\n+            )\n+            .options(joinedload(orm_object.hitl_detail))\n         )\n-        .options(joinedload(TI.hitl_detail))\n-    )\n \n-    if map_index is not None:\n-        query = query.where(TI.map_index == map_index)\n+        if try_number is not None:\n+            query = query.where(orm_object.try_number == try_number)\n+\n+        task_instance = session.scalar(query)",
      "comment": "Yep, I think we should rename it on both sides. I'll make the update ",
      "comment_id": 2579364502,
      "user": "Lee-W",
      "created_at": "2025-12-02T02:22:09Z",
      "url": "https://github.com/apache/airflow/pull/56760#discussion_r2579364502"
    },
    {
      "repo": "apache/airflow",
      "pr_number": 58684,
      "file_path": "providers/cncf/kubernetes/src/airflow/providers/cncf/kubernetes/operators/pod.py",
      "line": 894,
      "side": "RIGHT",
      "diff_hunk": "@@ -851,32 +851,49 @@ def convert_config_file_to_dict(self):\n         else:\n             self._config_dict = None\n \n-    def invoke_defer_method(self, last_log_time: DateTime | None = None) -> None:\n+    def invoke_defer_method(self, context: Context, last_log_time: DateTime | None = None) -> None:\n         \"\"\"Redefine triggers which are being used in child classes.\"\"\"\n         self.convert_config_file_to_dict()\n         trigger_start_time = datetime.datetime.now(tz=datetime.timezone.utc)\n-        self.defer(\n-            trigger=KubernetesPodTrigger(\n-                pod_name=self.pod.metadata.name,  # type: ignore[union-attr]\n-                pod_namespace=self.pod.metadata.namespace,  # type: ignore[union-attr]\n-                trigger_start_time=trigger_start_time,\n-                kubernetes_conn_id=self.kubernetes_conn_id,\n-                cluster_context=self.cluster_context,\n-                config_dict=self._config_dict,\n-                in_cluster=self.in_cluster,\n-                poll_interval=self.poll_interval,\n-                get_logs=self.get_logs,\n-                startup_timeout=self.startup_timeout_seconds,\n-                startup_check_interval=self.startup_check_interval_seconds,\n-                schedule_timeout=self.schedule_timeout_seconds,\n-                base_container_name=self.base_container_name,\n-                on_finish_action=self.on_finish_action.value,\n-                last_log_time=last_log_time,\n-                logging_interval=self.logging_interval,\n-                trigger_kwargs=self.trigger_kwargs,\n-            ),\n-            method_name=\"trigger_reentry\",\n+\n+        trigger = KubernetesPodTrigger(\n+            pod_name=self.pod.metadata.name,  # type: ignore[union-attr]\n+            pod_namespace=self.pod.metadata.namespace,  # type: ignore[union-attr]\n+            trigger_start_time=trigger_start_time,\n+            kubernetes_conn_id=self.kubernetes_conn_id,\n+            cluster_context=self.cluster_context,\n+            config_dict=self._config_dict,\n+            in_cluster=self.in_cluster,\n+            poll_interval=self.poll_interval,\n+            get_logs=self.get_logs,\n+            startup_timeout=self.startup_timeout_seconds,\n+            startup_check_interval=self.startup_check_interval_seconds,\n+            schedule_timeout=self.schedule_timeout_seconds,\n+            base_container_name=self.base_container_name,\n+            on_finish_action=self.on_finish_action.value,\n+            last_log_time=last_log_time,\n+            logging_interval=self.logging_interval,\n+            trigger_kwargs=self.trigger_kwargs,\n         )\n+        container_state = trigger.define_container_state(self.pod)\n+        if container_state == ContainerState.TERMINATED or container_state == ContainerState.FAILED:\n+            self.log.info(\"Skipping deferral as pod is already in a terminal state\")\n+            self.trigger_reentry(\n+                context=context,\n+                event={\n+                    \"status\": \"success\" if container_state == ContainerState.TERMINATED else \"failed\",\n+                    \"namespace\": self.pod.metadata.namespace,\n+                    \"name\": self.pod.metadata.name,\n+                    \"message\": \"Container succeeded\"\n+                    if container_state == ContainerState.TERMINATED\n+                    else \"Container failed\",\n+                    \"last_log_time\": last_log_time,\n+                    **(self.trigger_kwargs or {}),\n+                },\n+            )\n+            return",
      "comment": "I would write this as an if else statement instead of return, because you actually don't return anything in this case, but that's a matter of taste, don't now what the consensus is in this case for Airflow code base.",
      "comment_id": 2563600240,
      "user": "dabla",
      "created_at": "2025-11-26T07:03:47Z",
      "url": "https://github.com/apache/airflow/pull/58684#discussion_r2563600240"
    },
    {
      "repo": "apache/airflow",
      "pr_number": 60398,
      "file_path": "providers/amazon/src/airflow/providers/amazon/aws/hooks/s3.py",
      "line": 1749,
      "side": "RIGHT",
      "diff_hunk": "@@ -1743,29 +1743,29 @@ def _sync_to_local_dir_delete_stale_local_files(self, current_s3_objects: list[P\n \n     def _sync_to_local_dir_if_changed(self, s3_bucket, s3_object, local_target_path: Path):\n         should_download = False\n-        download_msg = \"\"\n+        download_reasons = []\n         if not local_target_path.exists():\n             should_download = True\n-            download_msg = f\"Local file {local_target_path} does not exist.\"\n+            download_reasons.append(f\"Local file {local_target_path} does not exist.\")",
      "comment": "Instead of using f-string, can we do something like this instead?\n\n```python\ndownload_logs = []\ndownload_log_params = []\nif ...\n    download_logs.append(\"Local file %s does not exist.\")\n    download_log_params.append(local_target_path)\n...\ndownload_logs.append(\"Downloaded %s to %s\")\ndownload_log_params.extend((s3_object.key, local_target_path.as_posix()))\nself.log.debug(\" \".join(download_logs), *download_log_params)\n```\n\nOr, maybe just log each message separately. There\u2019s no need to combine them into one line.",
      "comment_id": 2680825564,
      "user": "uranusjr",
      "created_at": "2026-01-12T04:16:02Z",
      "url": "https://github.com/apache/airflow/pull/60398#discussion_r2680825564"
    },
    {
      "repo": "apache/airflow",
      "pr_number": 60398,
      "file_path": "providers/amazon/src/airflow/providers/amazon/aws/hooks/s3.py",
      "line": 1749,
      "side": "RIGHT",
      "diff_hunk": "@@ -1743,29 +1743,29 @@ def _sync_to_local_dir_delete_stale_local_files(self, current_s3_objects: list[P\n \n     def _sync_to_local_dir_if_changed(self, s3_bucket, s3_object, local_target_path: Path):\n         should_download = False\n-        download_msg = \"\"\n+        download_reasons = []\n         if not local_target_path.exists():\n             should_download = True\n-            download_msg = f\"Local file {local_target_path} does not exist.\"\n+            download_reasons.append(f\"Local file {local_target_path} does not exist.\")",
      "comment": "> Instead of using f-string, can we do something like this instead?\r\n> \r\n> ```python\r\n> download_logs = []\r\n> download_log_params = []\r\n> if ...\r\n>     download_logs.append(\"Local file %s does not exist.\")\r\n>     download_log_params.append(local_target_path)\r\n> ...\r\n> download_logs.append(\"Downloaded %s to %s\")\r\n> download_log_params.extend((s3_object.key, local_target_path.as_posix()))\r\n> self.log.debug(\" \".join(download_logs), *download_log_params)\r\n> ```\r\n> \r\n> Or, maybe just log each message separately. There\u2019s no need to combine them into one line.\r\n\r\nApplied!",
      "comment_id": 2681650623,
      "user": "henry3260",
      "created_at": "2026-01-12T10:24:08Z",
      "url": "https://github.com/apache/airflow/pull/60398#discussion_r2681650623"
    },
    {
      "repo": "apache/airflow",
      "pr_number": 60320,
      "file_path": "dev/breeze/src/airflow_breeze/commands/kubernetes_commands.py",
      "line": 974,
      "side": "RIGHT",
      "diff_hunk": "@@ -970,7 +971,7 @@ def _build_skaffold_config(\n                 # include test sources (the `breeze k8s configure-cluster` command ) like nodeport for apiServer, volume for Dag, etc\n                 # https://skaffold.dev/docs/references/yaml/?version=v4beta13#deploy-kubectl\n                 \"hooks\": {\n-                    \"before\": [\n+                    \"after\": [",
      "comment": "The hooks for deploying test resource (`nodeport.yaml`, `volume.yaml` in `scripts/ci/kubernetes` should be placed under `after` rather than `beforce`. Since the `airflow` namespace might not be exist before running `helm install`.",
      "comment_id": 2675901389,
      "user": "jason810496",
      "created_at": "2026-01-09T11:51:28Z",
      "url": "https://github.com/apache/airflow/pull/60320#discussion_r2675901389"
    },
    {
      "repo": "apache/airflow",
      "pr_number": 60041,
      "file_path": "providers/apache/spark/tests/system/apache/spark/example_pyspark.py",
      "line": 49,
      "side": "RIGHT",
      "diff_hunk": "@@ -46,7 +46,7 @@ def example_pyspark():\n \n     # [START task_pyspark]\n     @task.pyspark(conn_id=\"spark-local\")\n-    def spark_task(spark: SparkSession) -> pd.DataFrame:\n+    def spark_task(spark: SparkSession, sc) -> pd.DataFrame:",
      "comment": "The second argument can be named better, and maybe have a type annotation.",
      "comment_id": 2680787321,
      "user": "uranusjr",
      "created_at": "2026-01-12T03:55:59Z",
      "url": "https://github.com/apache/airflow/pull/60041#discussion_r2680787321"
    },
    {
      "repo": "apache/airflow",
      "pr_number": 60041,
      "file_path": "providers/apache/spark/tests/system/apache/spark/example_pyspark.py",
      "line": 49,
      "side": "RIGHT",
      "diff_hunk": "@@ -46,7 +46,7 @@ def example_pyspark():\n \n     # [START task_pyspark]\n     @task.pyspark(conn_id=\"spark-local\")\n-    def spark_task(spark: SparkSession) -> pd.DataFrame:\n+    def spark_task(spark: SparkSession, sc) -> pd.DataFrame:",
      "comment": "Also, does this imply an incompatibility with past versions?",
      "comment_id": 2680787973,
      "user": "uranusjr",
      "created_at": "2026-01-12T03:56:33Z",
      "url": "https://github.com/apache/airflow/pull/60041#discussion_r2680787973"
    },
    {
      "repo": "apache/airflow",
      "pr_number": 60041,
      "file_path": "providers/apache/spark/tests/system/apache/spark/example_pyspark.py",
      "line": 49,
      "side": "RIGHT",
      "diff_hunk": "@@ -46,7 +46,7 @@ def example_pyspark():\n \n     # [START task_pyspark]\n     @task.pyspark(conn_id=\"spark-local\")\n-    def spark_task(spark: SparkSession) -> pd.DataFrame:\n+    def spark_task(spark: SparkSession, sc) -> pd.DataFrame:",
      "comment": "yes the sc argument become mandatory \r\n\r\nbut I'm in favor to remove it , since \r\n\r\n\"sc\" is just \r\n\r\nspark.sparkContext\r\n\r\nso the user can do it in the python function if necessary",
      "comment_id": 2681648166,
      "user": "raphaelauv",
      "created_at": "2026-01-12T10:23:29Z",
      "url": "https://github.com/apache/airflow/pull/60041#discussion_r2681648166"
    },
    {
      "repo": "apache/airflow",
      "pr_number": 51883,
      "file_path": "providers/amazon/src/airflow/providers/amazon/aws/hooks/emr.py",
      "line": 327,
      "side": "RIGHT",
      "diff_hunk": "@@ -311,6 +311,24 @@ def cancel_running_jobs(\n \n         return count\n \n+    def cancel_job(self, application_id: str, job_run_id: str) -> None:\n+        \"\"\"\n+        Cancel a specific EMR Serverless job run.\n+\n+        :param application_id: The ID of the EMR Serverless application\n+        :param job_run_id: The ID of the job run to cancel\n+        :raises AirflowException: If cancellation fails\n+        \"\"\"\n+        try:\n+            self.log.info(\"Cancelling EMR Serverless job %s in application %s\", job_run_id, application_id)\n+            response = self.conn.cancel_job_run(applicationId=application_id, jobRunId=job_run_id)\n+            http_code = response[\"ResponseMetadata\"][\"HTTPStatusCode\"]\n+            if http_code != 200:\n+                raise AirflowException(f\"Failed to cancel job run {job_run_id}: HTTP {http_code}\")",
      "comment": "As far as I know this can never happen. If the call is not successful, you'll get an exception.\r\n\r\nOther than that, this method is just a thin wrapper on top of `self.conn.cancel_job_run`, I dont think it is necessary to create a method for that. You can call boto3 API directly in the operator.",
      "comment_id": 2154892781,
      "user": "vincbeck",
      "created_at": "2025-06-18T15:19:05Z",
      "url": "https://github.com/apache/airflow/pull/51883#discussion_r2154892781"
    },
    {
      "repo": "apache/airflow",
      "pr_number": 51883,
      "file_path": "providers/amazon/src/airflow/providers/amazon/aws/operators/emr.py",
      "line": 1292,
      "side": "RIGHT",
      "diff_hunk": "@@ -1280,6 +1288,9 @@ def execute_complete(self, context: Context, event: dict[str, Any] | None = None\n         if validated_event[\"status\"] == \"success\":\n             self.log.info(\"Serverless job completed\")\n             return validated_event[\"job_id\"]\n+        self.log.info(\"Cancelling EMR Serverless job %s\", self.job_id)\n+        self.hook.conn.cancel_job_run(applicationId=self.application_id, jobRunId=self.job_id)",
      "comment": "You should never use instance variable in `execute_complete`. The methods `execute` and `execute_method` are executed with 2 different instances, thus you have no guarantee these variables are set and equal the same across instances. You should only use data from the event. The job ID is available in `validated_event[\"job_id\"]` but you need to modify the trigger to also send the application ID as part of the event",
      "comment_id": 2154917618,
      "user": "vincbeck",
      "created_at": "2025-06-18T15:29:39Z",
      "url": "https://github.com/apache/airflow/pull/51883#discussion_r2154917618"
    },
    {
      "repo": "apache/airflow",
      "pr_number": 51883,
      "file_path": "providers/amazon/src/airflow/providers/amazon/aws/hooks/emr.py",
      "line": 327,
      "side": "RIGHT",
      "diff_hunk": "@@ -311,6 +311,24 @@ def cancel_running_jobs(\n \n         return count\n \n+    def cancel_job(self, application_id: str, job_run_id: str) -> None:\n+        \"\"\"\n+        Cancel a specific EMR Serverless job run.\n+\n+        :param application_id: The ID of the EMR Serverless application\n+        :param job_run_id: The ID of the job run to cancel\n+        :raises AirflowException: If cancellation fails\n+        \"\"\"\n+        try:\n+            self.log.info(\"Cancelling EMR Serverless job %s in application %s\", job_run_id, application_id)\n+            response = self.conn.cancel_job_run(applicationId=application_id, jobRunId=job_run_id)\n+            http_code = response[\"ResponseMetadata\"][\"HTTPStatusCode\"]\n+            if http_code != 200:\n+                raise AirflowException(f\"Failed to cancel job run {job_run_id}: HTTP {http_code}\")",
      "comment": "Makes total sense, thanks. I also used the boto3 one in my operator. ",
      "comment_id": 2155005263,
      "user": "dominikhei",
      "created_at": "2025-06-18T16:09:19Z",
      "url": "https://github.com/apache/airflow/pull/51883#discussion_r2155005263"
    },
    {
      "repo": "apache/airflow",
      "pr_number": 51883,
      "file_path": "providers/amazon/src/airflow/providers/amazon/aws/operators/emr.py",
      "line": 1292,
      "side": "RIGHT",
      "diff_hunk": "@@ -1280,6 +1288,9 @@ def execute_complete(self, context: Context, event: dict[str, Any] | None = None\n         if validated_event[\"status\"] == \"success\":\n             self.log.info(\"Serverless job completed\")\n             return validated_event[\"job_id\"]\n+        self.log.info(\"Cancelling EMR Serverless job %s\", self.job_id)\n+        self.hook.conn.cancel_job_run(applicationId=self.application_id, jobRunId=self.job_id)",
      "comment": "Thanks for the feedback. From what I have seen in the `AwsBaseWaiterTrigger` I can simply use a dictionary with both values as a `return_value`in the trigger?",
      "comment_id": 2155086717,
      "user": "dominikhei",
      "created_at": "2025-06-18T16:50:49Z",
      "url": "https://github.com/apache/airflow/pull/51883#discussion_r2155086717"
    },
    {
      "repo": "apache/airflow",
      "pr_number": 51883,
      "file_path": "providers/amazon/src/airflow/providers/amazon/aws/operators/emr.py",
      "line": 1292,
      "side": "RIGHT",
      "diff_hunk": "@@ -1280,6 +1288,9 @@ def execute_complete(self, context: Context, event: dict[str, Any] | None = None\n         if validated_event[\"status\"] == \"success\":\n             self.log.info(\"Serverless job completed\")\n             return validated_event[\"job_id\"]\n+        self.log.info(\"Cancelling EMR Serverless job %s\", self.job_id)\n+        self.hook.conn.cancel_job_run(applicationId=self.application_id, jobRunId=self.job_id)",
      "comment": "Correct. Please also update the `return_key` as well, since it no longer return the `job_id` but `job_id` and `application_id`. Maybe `job_infos`?",
      "comment_id": 2155100342,
      "user": "vincbeck",
      "created_at": "2025-06-18T16:58:49Z",
      "url": "https://github.com/apache/airflow/pull/51883#discussion_r2155100342"
    },
    {
      "repo": "apache/airflow",
      "pr_number": 60176,
      "file_path": "scripts/ci/prek/check_no_orm_refs_in_migration_scripts.py",
      "line": 105,
      "side": "RIGHT",
      "diff_hunk": "@@ -0,0 +1,111 @@\n+#!/usr/bin/env python\n+#\n+# Licensed to the Apache Software Foundation (ASF) under one\n+# or more contributor license agreements.  See the NOTICE file\n+# distributed with this work for additional information\n+# regarding copyright ownership.  The ASF licenses this file\n+# to you under the Apache License, Version 2.0 (the\n+# \"License\"); you may not use this file except in compliance\n+# with the License.  You may obtain a copy of the License at\n+#\n+#   http://www.apache.org/licenses/LICENSE-2.0\n+#\n+# Unless required by applicable law or agreed to in writing,\n+# software distributed under the License is distributed on an\n+# \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+# KIND, either express or implied.  See the License for the\n+# specific language governing permissions and limitations\n+# under the License.\n+# /// script\n+# requires-python = \">=3.10,<3.11\"\n+# dependencies = [\n+#   \"rich>=13.6.0\",\n+# ]\n+# ///\n+\"\"\"\n+Check that there are no imports of ORM classes in any of the alembic migration scripts.\n+This is to prevent the addition of migration code directly referencing any ORM definition,\n+which could potentially break downgrades. For more details, refer to the relevant discussion\n+thread at this link: https://github.com/apache/airflow/issues/59871\n+\"\"\"\n+\n+from __future__ import annotations\n+\n+import ast\n+import os\n+import sys\n+from pathlib import Path\n+from pprint import pformat\n+from typing import Final\n+\n+sys.path.insert(0, str(Path(__file__).parent.resolve()))\n+from common_prek_utils import AIRFLOW_CORE_SOURCES_PATH, console\n+\n+_MIGRATIONS_DIRPATH: Final[Path] = Path(\n+    os.path.join(AIRFLOW_CORE_SOURCES_PATH, \"airflow/migrations/versions\")\n+)\n+# Tuple of fully qualified references within `airflow.models.*` which are allowed to be imported by the\n+# migration scripts. Should only allow references to primitives or constants, and NOT ORM class definitions.\n+_MODELS_IMPORTS_ALLOWLIST: Final[tuple[str, ...]] = (\"airflow.models.ID_LEN\",)\n+\n+\n+def main() -> None:\n+    if len(sys.argv) > 1:\n+        migration_scripts = [Path(f) for f in sys.argv[1:]]\n+    else:\n+        migration_scripts = list(_MIGRATIONS_DIRPATH.glob(\"**/*.py\"))\n+    console.print(\n+        f\"Checking the following modified migration scripts: {pformat([str(path) for path in migration_scripts])}\"\n+    )\n+    violations = []\n+    for script_path in migration_scripts:\n+        violations.extend(_find_models_import_violations(script_path=script_path))\n+    if violations:\n+        for err in violations:\n+            console.print(f\"[red]{err}\")\n+        console.print(\"\\n[red]ORM references detected in one or more migration scripts[/]\")\n+        sys.exit(1)\n+    console.print(\"[green]No ORM references detected in migration scripts.\")\n+\n+\n+def _find_models_import_violations(script_path: Path) -> list[str]:\n+    \"\"\"\n+    Return a list of invalid imports of ORM definitions for the given migration script, if any.\n+    For simplicity and forward compatibility when individual tables are added / removed / renamed,\n+    this function uses the heuristic of checking for any non-allowlisted imports from within the\n+    `airflow.models` module.\n+    \"\"\"\n+    script_source = script_path.read_text(encoding=\"utf-8\")\n+    bad_imports = []\n+    for node in ast.walk(ast.parse(script_source)):\n+        if details := _is_violating_orm_import(node=node):\n+            line_no, src = details\n+            bad_imports.append(\n+                f\"Found bad import on line {line_no} in migration script {str(script_path)}: '{src}'\"\n+            )\n+    return bad_imports\n+\n+\n+def _is_violating_orm_import(node: ast.AST) -> tuple[int, str] | None:\n+    \"\"\"\n+    Return a tuple of line number and line text for the given node, if it is an import of any non-allowlisted object\n+    from within `airflow.models`, otherwise return `None`.\n+    \"\"\"\n+    # Match \"from x import y [as z]\"\n+    if isinstance(node, ast.ImportFrom) and node.module:\n+        fully_qualified_reference = \".\".join([node.module] + [alias.name for alias in node.names])\n+    # Match \"import x.y.z [as w]\"\n+    elif isinstance(node, ast.Import):\n+        fully_qualified_reference = \".\".join([alias.name for alias in node.names])\n+    else:\n+        return None\n+\n+    if not fully_qualified_reference.startswith(\"airflow.models\"):\n+        return None\n+    if fully_qualified_reference in _MODELS_IMPORTS_ALLOWLIST:",
      "comment": "How about importing it here and checking if it extends from BaseModel ? Yes. A little slower, and we would need to add \"airflow-core/src\" to sys.path, but this will be negligible. And more future proof.",
      "comment_id": 2665603996,
      "user": "potiuk",
      "created_at": "2026-01-06T16:58:09Z",
      "url": "https://github.com/apache/airflow/pull/60176#discussion_r2665603996"
    },
    {
      "repo": "apache/airflow",
      "pr_number": 59850,
      "file_path": "airflow-ctl/src/airflowctl/ctl/commands/pool_command.py",
      "line": 49,
      "side": "LEFT",
      "diff_hunk": "@@ -46,43 +46,6 @@ def import_(args, api_client: Client = NEW_API_CLIENT) -> None:\n     rich.print(success)\n \n \n-@provide_api_client(kind=ClientKind.CLI)",
      "comment": "Ok. \"all\" was a bit too much. Pool export does bit contain sensitive data, so we should not remove it. ",
      "comment_id": 2649061077,
      "user": "potiuk",
      "created_at": "2025-12-27T09:51:18Z",
      "url": "https://github.com/apache/airflow/pull/59850#discussion_r2649061077"
    },
    {
      "repo": "apache/airflow",
      "pr_number": 59850,
      "file_path": "airflow-ctl/src/airflowctl/ctl/commands/pool_command.py",
      "line": 49,
      "side": "LEFT",
      "diff_hunk": "@@ -46,43 +46,6 @@ def import_(args, api_client: Client = NEW_API_CLIENT) -> None:\n     rich.print(success)\n \n \n-@provide_api_client(kind=ClientKind.CLI)",
      "comment": "Was starting to review and had exactly the same thought in parallel.",
      "comment_id": 2649062031,
      "user": "jscheffl",
      "created_at": "2025-12-27T09:54:02Z",
      "url": "https://github.com/apache/airflow/pull/59850#discussion_r2649062031"
    },
    {
      "repo": "apache/airflow",
      "pr_number": 59850,
      "file_path": "airflow-ctl/src/airflowctl/ctl/cli_config.py",
      "line": 805,
      "side": "RIGHT",
      "diff_hunk": "@@ -803,8 +802,8 @@ def merge_commands(\n     ActionCommand(\n         name=\"import\",\n         help=\"Import connections from a file. \"\n-        \"This feature is compatible with airflow CLI `airflow connections export a.json` command. \"\n-        \"Export it from `airflow CLI` and import it securely via this command.\",\n+        \"Export functionality is only available via the local Airflow CLI command 'airflow connections export'. \"",
      "comment": "This seems a bit long (see the screenshot). I think it should be much shorter (\"Import connections from a file exported with local CLI.\") ",
      "comment_id": 2649083646,
      "user": "potiuk",
      "created_at": "2025-12-27T10:55:46Z",
      "url": "https://github.com/apache/airflow/pull/59850#discussion_r2649083646"
    },
    {
      "repo": "apache/airflow",
      "pr_number": 59850,
      "file_path": "airflow-ctl/src/airflowctl/ctl/cli_config.py",
      "line": 852,
      "side": "RIGHT",
      "diff_hunk": "@@ -852,16 +849,10 @@ def merge_commands(\n VARIABLE_COMMANDS = (\n     ActionCommand(\n         name=\"import\",\n-        help=\"Import variables\",\n+        help=\"Import variables. Export functionality is only available via the local Airflow CLI command 'airflow variables export'.\",",
      "comment": "This one is similarly - quite too long.\r\n\r\nAlso NIT(picking): It would be nice to increase width of airflow-ctl screenshots so tha the help line does not wrap. (https://github.com/apache/airflow/blob/main/scripts/in_container/run_capture_airflowctl_help.py#L67 is where the width of the screen is defined) ",
      "comment_id": 2649383008,
      "user": "potiuk",
      "created_at": "2025-12-27T23:41:57Z",
      "url": "https://github.com/apache/airflow/pull/59850#discussion_r2649383008"
    },
    {
      "repo": "apache/airflow",
      "pr_number": 59850,
      "file_path": "scripts/ci/prek/check_airflowctl_command_coverage.py",
      "line": 74,
      "side": "RIGHT",
      "diff_hunk": "@@ -70,6 +70,8 @@\n     \"dags delete\",\n     \"dags get-import-error\",\n     \"dags get-tags\",\n+    \"pools export\",  # Export only available via local Airflow CLI\n+    \"variables export\",  # Export only available via local Airflow CLI",
      "comment": "```suggestion\n    \"pools export\",\n    \"variables export\",\n```",
      "comment_id": 2650263296,
      "user": "amoghrajesh",
      "created_at": "2025-12-29T06:15:25Z",
      "url": "https://github.com/apache/airflow/pull/59850#discussion_r2650263296"
    },
    {
      "repo": "apache/airflow",
      "pr_number": 59850,
      "file_path": "scripts/in_container/run_capture_airflowctl_help.py",
      "line": 87,
      "side": "LEFT",
      "diff_hunk": "@@ -84,7 +84,7 @@ def regenerate_help_images_for_all_airflowctl_commands(commands: list[str], skip\n     os.makedirs(AIRFLOWCTL_IMAGES_PATH, exist_ok=True)\n     env = os.environ.copy()\n     env[\"TERM\"] = \"xterm-256color\"\n-    env[\"COLUMNS\"] = \"65\"",
      "comment": "NIT: I think it's **almost** good but you have to delete the corresponding hash and recreate both images - one of them still does not seem to take the new value into account. Also I think slightly smaller value would be good.",
      "comment_id": 2651868321,
      "user": "potiuk",
      "created_at": "2025-12-29T22:20:47Z",
      "url": "https://github.com/apache/airflow/pull/59850#discussion_r2651868321"
    },
    {
      "repo": "apache/airflow",
      "pr_number": 60412,
      "file_path": "airflow-core/src/airflow/api_fastapi/core_api/routes/public/log.py",
      "line": 173,
      "side": "RIGHT",
      "diff_hunk": "@@ -170,7 +170,7 @@ def get_log(\n @task_instances_log_router.get(\n     \"/{task_id}/externalLogUrl/{try_number}\",\n     responses=create_openapi_http_exception_doc([status.HTTP_400_BAD_REQUEST, status.HTTP_404_NOT_FOUND]),\n-    dependencies=[Depends(requires_access_dag(\"GET\", DagAccessEntity.TASK_INSTANCE))],\n+    dependencies=[Depends(requires_access_dag(\"GET\", DagAccessEntity.TASK_LOGS))],",
      "comment": "```suggestion\r\n    dependencies=[\r\n        Depends(requires_access_dag(\"GET\", DagAccessEntity.TASK_LOGS)),\r\n        Depends(requires_access_dag(\"GET\", DagAccessEntity.TASK_INSTANCE))\r\n    ],\r\n```\r\n\r\nInstead of removing authorization for `TASK_INSTANCE`, it would be better to add the authorization for `TASK_LOGS`. Since we will retrieve TaskInstance in the route.\r\n\r\nhttps://github.com/apache/airflow/blob/26a9d3b81b1d514ac00476885ba29676cd8f27e6/airflow-core/src/airflow/api_fastapi/core_api/routes/public/log.py#L189-L200",
      "comment_id": 2683214193,
      "user": "jason810496",
      "created_at": "2026-01-12T17:27:09Z",
      "url": "https://github.com/apache/airflow/pull/60412#discussion_r2683214193"
    },
    {
      "repo": "apache/airflow",
      "pr_number": 60412,
      "file_path": "airflow-core/src/airflow/api_fastapi/core_api/routes/public/log.py",
      "line": 173,
      "side": "RIGHT",
      "diff_hunk": "@@ -170,7 +170,7 @@ def get_log(\n @task_instances_log_router.get(\n     \"/{task_id}/externalLogUrl/{try_number}\",\n     responses=create_openapi_http_exception_doc([status.HTTP_400_BAD_REQUEST, status.HTTP_404_NOT_FOUND]),\n-    dependencies=[Depends(requires_access_dag(\"GET\", DagAccessEntity.TASK_INSTANCE))],\n+    dependencies=[Depends(requires_access_dag(\"GET\", DagAccessEntity.TASK_LOGS))],",
      "comment": "Since `TASK_LOGS` and `TASK_INSTANCE` are distinct DagAccessEntity I think it's fine.\n\nWe also only have `TASK_LOGS` above for `get_log`. Indeed the endpoint needs to fetch the particular TI to construct the log, but as long as we return the log only I think we are good.\n\nOtherwise I feel this could confuse users, having access to read logs of Task Instance 1 and still not be able to read logs of Task Instance 1 would be weird. (because TASK_INSTANCE on Task Instance 1 permission is missing)",
      "comment_id": 2685788198,
      "user": "pierrejeambrun",
      "created_at": "2026-01-13T10:28:40Z",
      "url": "https://github.com/apache/airflow/pull/60412#discussion_r2685788198"
    },
    {
      "repo": "apache/airflow",
      "pr_number": 60412,
      "file_path": "airflow-core/src/airflow/api_fastapi/core_api/routes/public/log.py",
      "line": 173,
      "side": "RIGHT",
      "diff_hunk": "@@ -170,7 +170,7 @@ def get_log(\n @task_instances_log_router.get(\n     \"/{task_id}/externalLogUrl/{try_number}\",\n     responses=create_openapi_http_exception_doc([status.HTTP_400_BAD_REQUEST, status.HTTP_404_NOT_FOUND]),\n-    dependencies=[Depends(requires_access_dag(\"GET\", DagAccessEntity.TASK_INSTANCE))],\n+    dependencies=[Depends(requires_access_dag(\"GET\", DagAccessEntity.TASK_LOGS))],",
      "comment": "Yes, +1\r\nAlso, @jason810496 , there is one `test_should_raises_403_unauthorized` test, which would remain unchanged for this PR, since we just change the access required.",
      "comment_id": 2686546425,
      "user": "shubhamraj-git",
      "created_at": "2026-01-13T13:57:22Z",
      "url": "https://github.com/apache/airflow/pull/60412#discussion_r2686546425"
    },
    {
      "repo": "apache/airflow",
      "pr_number": 60412,
      "file_path": "airflow-core/src/airflow/api_fastapi/core_api/routes/public/log.py",
      "line": 173,
      "side": "RIGHT",
      "diff_hunk": "@@ -170,7 +170,7 @@ def get_log(\n @task_instances_log_router.get(\n     \"/{task_id}/externalLogUrl/{try_number}\",\n     responses=create_openapi_http_exception_doc([status.HTTP_400_BAD_REQUEST, status.HTTP_404_NOT_FOUND]),\n-    dependencies=[Depends(requires_access_dag(\"GET\", DagAccessEntity.TASK_INSTANCE))],\n+    dependencies=[Depends(requires_access_dag(\"GET\", DagAccessEntity.TASK_LOGS))],",
      "comment": "Fair point, the example above make sense to me. Thanks for the clarification. ",
      "comment_id": 2689265332,
      "user": "jason810496",
      "created_at": "2026-01-14T07:22:14Z",
      "url": "https://github.com/apache/airflow/pull/60412#discussion_r2689265332"
    },
    {
      "repo": "apache/airflow",
      "pr_number": 60487,
      "file_path": "dev/prune_old_dirs.py",
      "line": 1,
      "side": "RIGHT",
      "diff_hunk": "@@ -0,0 +1,102 @@\n+#!/usr/bin/env python3",
      "comment": "Do we plan to use this file in other release scripts? (the file name is general, and currently it's being used only in the Airflow CTL scripts)",
      "comment_id": 2688167707,
      "user": "shahar1",
      "created_at": "2026-01-13T21:23:08Z",
      "url": "https://github.com/apache/airflow/pull/60487#discussion_r2688167707"
    },
    {
      "repo": "apache/airflow",
      "pr_number": 60438,
      "file_path": "airflow-core/src/airflow/executors/executor_loader.py",
      "line": 259,
      "side": "RIGHT",
      "diff_hunk": "@@ -249,6 +249,21 @@ def _get_team_executor_configs(cls, validate_teams: bool = True) -> list[tuple[s\n                 \"'CeleryExecutor;team1=LocalExecutor' instead of 'team1=CeleryExecutor;team2=LocalExecutor').\"\n             )\n \n+        # Validate that global executors come before team executors\n+        seen_team_executor = False\n+        for team_name, _ in configs:\n+            if team_name is not None:\n+                seen_team_executor = True\n+            elif seen_team_executor:\n+                # Found a global executor after we've already seen a team executor\n+                raise AirflowConfigException(",
      "comment": "Why setting a boolean and then raising an exception if that flag is True (but in a different loop iteration)? So if there is one executor configured and this executor is team based, it will not raise an exception?",
      "comment_id": 2686631830,
      "user": "vincbeck",
      "created_at": "2026-01-13T14:18:31Z",
      "url": "https://github.com/apache/airflow/pull/60438#discussion_r2686631830"
    },
    {
      "repo": "apache/airflow",
      "pr_number": 60438,
      "file_path": "airflow-core/src/airflow/executors/executor_loader.py",
      "line": 259,
      "side": "RIGHT",
      "diff_hunk": "@@ -249,6 +249,21 @@ def _get_team_executor_configs(cls, validate_teams: bool = True) -> list[tuple[s\n                 \"'CeleryExecutor;team1=LocalExecutor' instead of 'team1=CeleryExecutor;team2=LocalExecutor').\"\n             )\n \n+        # Validate that global executors come before team executors\n+        seen_team_executor = False\n+        for team_name, _ in configs:\n+            if team_name is not None:\n+                seen_team_executor = True\n+            elif seen_team_executor:\n+                # Found a global executor after we've already seen a team executor\n+                raise AirflowConfigException(",
      "comment": "If it's a global executor we'll not set the boolean and just loop again, and then as soon as we see the first team executor we'll note that with the boolean being set to true, and then every loop after that should be team executors (which also sets to true, but that doesn't really matter, it's a no op basically). So if one isn't a team executor, after we've seen at least one, then raise the exception.\n\nDoes that make sense?",
      "comment_id": 2687388728,
      "user": "o-nikolas",
      "created_at": "2026-01-13T17:25:58Z",
      "url": "https://github.com/apache/airflow/pull/60438#discussion_r2687388728"
    },
    {
      "repo": "apache/airflow",
      "pr_number": 60438,
      "file_path": "airflow-core/src/airflow/executors/executor_loader.py",
      "line": 259,
      "side": "RIGHT",
      "diff_hunk": "@@ -249,6 +249,21 @@ def _get_team_executor_configs(cls, validate_teams: bool = True) -> list[tuple[s\n                 \"'CeleryExecutor;team1=LocalExecutor' instead of 'team1=CeleryExecutor;team2=LocalExecutor').\"\n             )\n \n+        # Validate that global executors come before team executors\n+        seen_team_executor = False\n+        for team_name, _ in configs:\n+            if team_name is not None:\n+                seen_team_executor = True\n+            elif seen_team_executor:\n+                # Found a global executor after we've already seen a team executor\n+                raise AirflowConfigException(",
      "comment": "I see, that makes sense. Do we want to enforce at least one global executor? Cause this piece of code won't raise an exception in that case",
      "comment_id": 2687429618,
      "user": "vincbeck",
      "created_at": "2026-01-13T17:39:15Z",
      "url": "https://github.com/apache/airflow/pull/60438#discussion_r2687429618"
    },
    {
      "repo": "apache/airflow",
      "pr_number": 60438,
      "file_path": "airflow-core/src/airflow/executors/executor_loader.py",
      "line": 259,
      "side": "RIGHT",
      "diff_hunk": "@@ -249,6 +249,21 @@ def _get_team_executor_configs(cls, validate_teams: bool = True) -> list[tuple[s\n                 \"'CeleryExecutor;team1=LocalExecutor' instead of 'team1=CeleryExecutor;team2=LocalExecutor').\"\n             )\n \n+        # Validate that global executors come before team executors\n+        seen_team_executor = False\n+        for team_name, _ in configs:\n+            if team_name is not None:\n+                seen_team_executor = True\n+            elif seen_team_executor:\n+                # Found a global executor after we've already seen a team executor\n+                raise AirflowConfigException(",
      "comment": "Yupp, that's a separate assertion just above this one! \ud83d\ude03 ",
      "comment_id": 2687980152,
      "user": "o-nikolas",
      "created_at": "2026-01-13T20:12:18Z",
      "url": "https://github.com/apache/airflow/pull/60438#discussion_r2687980152"
    },
    {
      "repo": "apache/airflow",
      "pr_number": 60083,
      "file_path": "providers/google/tests/unit/google/cloud/operators/test_dataproc.py",
      "line": 1276,
      "side": "RIGHT",
      "diff_hunk": "@@ -1269,7 +1274,39 @@ def test_create_execute_call_finished_before_defer(self, mock_trigger_hook, mock\n         )\n \n         mock_hook.return_value.wait_for_operation.assert_not_called()\n-        assert not mock_defer.called\n+        assert mock_defer.called",
      "comment": "Is this related to this change? Not sure why this change is required?",
      "comment_id": 2660252781,
      "user": "shivannakarthik",
      "created_at": "2026-01-05T04:27:48Z",
      "url": "https://github.com/apache/airflow/pull/60083#discussion_r2660252781"
    },
    {
      "repo": "apache/airflow",
      "pr_number": 60083,
      "file_path": "providers/google/tests/unit/google/cloud/operators/test_dataproc.py",
      "line": 1276,
      "side": "RIGHT",
      "diff_hunk": "@@ -1269,7 +1274,39 @@ def test_create_execute_call_finished_before_defer(self, mock_trigger_hook, mock\n         )\n \n         mock_hook.return_value.wait_for_operation.assert_not_called()\n-        assert not mock_defer.called\n+        assert mock_defer.called",
      "comment": "Also would you be able to add a test case for deferrable mode?",
      "comment_id": 2660279459,
      "user": "shivannakarthik",
      "created_at": "2026-01-05T04:50:59Z",
      "url": "https://github.com/apache/airflow/pull/60083#discussion_r2660279459"
    },
    {
      "repo": "apache/airflow",
      "pr_number": 60083,
      "file_path": "providers/google/src/airflow/providers/google/cloud/operators/dataproc.py",
      "line": 28,
      "side": "RIGHT",
      "diff_hunk": "@@ -25,7 +25,7 @@\n import warnings\n from collections.abc import MutableSequence, Sequence\n from dataclasses import dataclass\n-from datetime import datetime, timedelta\n+from datetime import datetime, timedelta, timezone",
      "comment": "```\r\n- from airflow.utils import timezone\r\n+ from datetime import datetime, timedelta, timezone\r\n\r\n- utc_auto_delete_time = timezone.convert_to_utc(self.auto_delete_time)\r\n+ utc_auto_delete_time = self.auto_delete_time.astimezone(timezone.utc)\r\n\r\n```\r\nCould you please clarify if these changes are related to this bug fix? \r\n\r\nI'd suggest either removing this change entirely as I believe it's unrelated to the PR scope or \r\ncreate a separate PR with proper testing for naive datetime handling.",
      "comment_id": 2660283395,
      "user": "shivannakarthik",
      "created_at": "2026-01-05T04:54:22Z",
      "url": "https://github.com/apache/airflow/pull/60083#discussion_r2660283395"
    },
    {
      "repo": "apache/airflow",
      "pr_number": 60083,
      "file_path": "providers/google/src/airflow/providers/google/cloud/operators/dataproc.py",
      "line": 28,
      "side": "RIGHT",
      "diff_hunk": "@@ -25,7 +25,7 @@\n import warnings\n from collections.abc import MutableSequence, Sequence\n from dataclasses import dataclass\n-from datetime import datetime, timedelta\n+from datetime import datetime, timedelta, timezone",
      "comment": "airflow.utils do not support the timezone method any longer, thus the changes done as it was failing during the static checks",
      "comment_id": 2660286594,
      "user": "chirodip98",
      "created_at": "2026-01-05T04:56:59Z",
      "url": "https://github.com/apache/airflow/pull/60083#discussion_r2660286594"
    },
    {
      "repo": "apache/airflow",
      "pr_number": 60083,
      "file_path": "providers/google/tests/unit/google/cloud/operators/test_dataproc.py",
      "line": 1276,
      "side": "RIGHT",
      "diff_hunk": "@@ -1269,7 +1274,39 @@ def test_create_execute_call_finished_before_defer(self, mock_trigger_hook, mock\n         )\n \n         mock_hook.return_value.wait_for_operation.assert_not_called()\n-        assert not mock_defer.called\n+        assert mock_defer.called",
      "comment": "Yes, this is related to the changes and its required. Will try to add test cases.",
      "comment_id": 2660288390,
      "user": "chirodip98",
      "created_at": "2026-01-05T04:58:29Z",
      "url": "https://github.com/apache/airflow/pull/60083#discussion_r2660288390"
    },
    {
      "repo": "apache/airflow",
      "pr_number": 60083,
      "file_path": "providers/google/src/airflow/providers/google/cloud/operators/dataproc.py",
      "line": 1022,
      "side": "RIGHT",
      "diff_hunk": "@@ -995,35 +995,35 @@ def __init__(\n \n     def execute(self, context: Context) -> None:\n         hook = DataprocHook(gcp_conn_id=self.gcp_conn_id, impersonation_chain=self.impersonation_chain)\n-        operation = self._delete_cluster(hook)\n-        if not self.deferrable:\n-            hook.wait_for_operation(timeout=self.timeout, result_retry=self.retry, operation=operation)\n-            self.log.info(\"Cluster deleted.\")\n-        else:\n-            try:\n-                hook.get_cluster(\n-                    project_id=self.project_id, region=self.region, cluster_name=self.cluster_name\n-                )\n-            except NotFound:\n+        try:\n+            op: operation.Operation = self._delete_cluster(hook)\n+            if not self.deferrable:\n+                hook.wait_for_operation(timeout=self.timeout, result_retry=self.retry, operation=op)\n                 self.log.info(\"Cluster deleted.\")\n-                return\n-            except Exception as e:\n-                raise AirflowException(str(e))\n-\n-            end_time: float = time.time() + self.timeout\n-            self.defer(\n-                trigger=DataprocDeleteClusterTrigger(\n-                    gcp_conn_id=self.gcp_conn_id,\n-                    project_id=self.project_id,\n-                    region=self.region,\n-                    cluster_name=self.cluster_name,\n-                    end_time=end_time,\n-                    metadata=self.metadata,\n-                    impersonation_chain=self.impersonation_chain,\n-                    polling_interval_seconds=self.polling_interval_seconds,\n-                ),\n-                method_name=\"execute_complete\",\n+            else:\n+                end_time: float = time.time() + self.timeout\n+                self.defer(\n+                    trigger=DataprocDeleteClusterTrigger(\n+                        gcp_conn_id=self.gcp_conn_id,\n+                        project_id=self.project_id,\n+                        region=self.region,\n+                        cluster_name=self.cluster_name,\n+                        end_time=end_time,\n+                        metadata=self.metadata,\n+                        impersonation_chain=self.impersonation_chain,\n+                        polling_interval_seconds=self.polling_interval_seconds,\n+                    ),\n+                    method_name=\"execute_complete\",\n+                )\n+        except NotFound:\n+            self.log.info(\n+                \"Cluster %s not found in region %s. Skipping deletion.\", self.cluster_name, self.region\n+            )\n+            raise AirflowSkipException(",
      "comment": "I am not sure why we need to add this exception? The task will fail anyway if the cluster can not be deleted, I am not sure that logic here should be like this with raising SkipException",
      "comment_id": 2661089513,
      "user": "VladaZakharova",
      "created_at": "2026-01-05T10:54:16Z",
      "url": "https://github.com/apache/airflow/pull/60083#discussion_r2661089513"
    },
    {
      "repo": "apache/airflow",
      "pr_number": 60083,
      "file_path": "providers/google/tests/system/google/cloud/dataproc/example_dataproc_delete_cluster.py",
      "line": 1,
      "side": "RIGHT",
      "diff_hunk": "@@ -0,0 +1,127 @@\n+# Licensed to the Apache Software Foundation (ASF) under one",
      "comment": "We usually don't add a new system test for the updated logic in the operator. We already test this operator, so new need for the new one",
      "comment_id": 2661091786,
      "user": "VladaZakharova",
      "created_at": "2026-01-05T10:55:07Z",
      "url": "https://github.com/apache/airflow/pull/60083#discussion_r2661091786"
    },
    {
      "repo": "apache/airflow",
      "pr_number": 60083,
      "file_path": "providers/google/src/airflow/providers/google/cloud/operators/dataproc.py",
      "line": 1004,
      "side": "RIGHT",
      "diff_hunk": "@@ -995,35 +995,35 @@ def __init__(\n \n     def execute(self, context: Context) -> None:\n         hook = DataprocHook(gcp_conn_id=self.gcp_conn_id, impersonation_chain=self.impersonation_chain)\n-        operation = self._delete_cluster(hook)\n-        if not self.deferrable:\n-            hook.wait_for_operation(timeout=self.timeout, result_retry=self.retry, operation=operation)\n-            self.log.info(\"Cluster deleted.\")\n-        else:\n-            try:\n-                hook.get_cluster(\n-                    project_id=self.project_id, region=self.region, cluster_name=self.cluster_name\n-                )\n-            except NotFound:\n+        try:\n+            op: operation.Operation = self._delete_cluster(hook)\n+            if not self.deferrable:\n+                hook.wait_for_operation(timeout=self.timeout, result_retry=self.retry, operation=op)\n                 self.log.info(\"Cluster deleted.\")\n-                return\n-            except Exception as e:\n-                raise AirflowException(str(e))\n-\n-            end_time: float = time.time() + self.timeout\n-            self.defer(\n-                trigger=DataprocDeleteClusterTrigger(\n-                    gcp_conn_id=self.gcp_conn_id,\n-                    project_id=self.project_id,\n-                    region=self.region,\n-                    cluster_name=self.cluster_name,\n-                    end_time=end_time,\n-                    metadata=self.metadata,\n-                    impersonation_chain=self.impersonation_chain,\n-                    polling_interval_seconds=self.polling_interval_seconds,\n-                ),\n-                method_name=\"execute_complete\",\n+            else:\n+                end_time: float = time.time() + self.timeout\n+                self.defer(\n+                    trigger=DataprocDeleteClusterTrigger(\n+                        gcp_conn_id=self.gcp_conn_id,\n+                        project_id=self.project_id,\n+                        region=self.region,\n+                        cluster_name=self.cluster_name,\n+                        end_time=end_time,\n+                        metadata=self.metadata,\n+                        impersonation_chain=self.impersonation_chain,\n+                        polling_interval_seconds=self.polling_interval_seconds,\n+                    ),\n+                    method_name=\"execute_complete\",\n+                )\n+        except NotFound:",
      "comment": "NotFound exception I think will not be raised here from deferrable mode. If it will be raised, it will be raised by the API call, not the def mode itself.",
      "comment_id": 2661093959,
      "user": "VladaZakharova",
      "created_at": "2026-01-05T10:55:57Z",
      "url": "https://github.com/apache/airflow/pull/60083#discussion_r2661093959"
    },
    {
      "repo": "apache/airflow",
      "pr_number": 60083,
      "file_path": "providers/google/src/airflow/providers/google/cloud/operators/dataproc.py",
      "line": 1022,
      "side": "RIGHT",
      "diff_hunk": "@@ -995,35 +995,35 @@ def __init__(\n \n     def execute(self, context: Context) -> None:\n         hook = DataprocHook(gcp_conn_id=self.gcp_conn_id, impersonation_chain=self.impersonation_chain)\n-        operation = self._delete_cluster(hook)\n-        if not self.deferrable:\n-            hook.wait_for_operation(timeout=self.timeout, result_retry=self.retry, operation=operation)\n-            self.log.info(\"Cluster deleted.\")\n-        else:\n-            try:\n-                hook.get_cluster(\n-                    project_id=self.project_id, region=self.region, cluster_name=self.cluster_name\n-                )\n-            except NotFound:\n+        try:\n+            op: operation.Operation = self._delete_cluster(hook)\n+            if not self.deferrable:\n+                hook.wait_for_operation(timeout=self.timeout, result_retry=self.retry, operation=op)\n                 self.log.info(\"Cluster deleted.\")\n-                return\n-            except Exception as e:\n-                raise AirflowException(str(e))\n-\n-            end_time: float = time.time() + self.timeout\n-            self.defer(\n-                trigger=DataprocDeleteClusterTrigger(\n-                    gcp_conn_id=self.gcp_conn_id,\n-                    project_id=self.project_id,\n-                    region=self.region,\n-                    cluster_name=self.cluster_name,\n-                    end_time=end_time,\n-                    metadata=self.metadata,\n-                    impersonation_chain=self.impersonation_chain,\n-                    polling_interval_seconds=self.polling_interval_seconds,\n-                ),\n-                method_name=\"execute_complete\",\n+            else:\n+                end_time: float = time.time() + self.timeout\n+                self.defer(\n+                    trigger=DataprocDeleteClusterTrigger(\n+                        gcp_conn_id=self.gcp_conn_id,\n+                        project_id=self.project_id,\n+                        region=self.region,\n+                        cluster_name=self.cluster_name,\n+                        end_time=end_time,\n+                        metadata=self.metadata,\n+                        impersonation_chain=self.impersonation_chain,\n+                        polling_interval_seconds=self.polling_interval_seconds,\n+                    ),\n+                    method_name=\"execute_complete\",\n+                )\n+        except NotFound:\n+            self.log.info(\n+                \"Cluster %s not found in region %s. Skipping deletion.\", self.cluster_name, self.region\n+            )\n+            raise AirflowSkipException(",
      "comment": "The idea is here to exit safely incase the the cluster is deleted and deletion is tried. Let's say due to idle timeout. I was thinking of adding a flag to enable this behaviour like raise_exception_when_notfound (or something better!)\r\n , which will give the users the opportunity to handle the scenario , without failing the task altogether.\r\n\r\nKindly suggest!",
      "comment_id": 2661136146,
      "user": "chirodip98",
      "created_at": "2026-01-05T11:10:37Z",
      "url": "https://github.com/apache/airflow/pull/60083#discussion_r2661136146"
    },
    {
      "repo": "apache/airflow",
      "pr_number": 60083,
      "file_path": "providers/google/src/airflow/providers/google/cloud/operators/dataproc.py",
      "line": 1004,
      "side": "RIGHT",
      "diff_hunk": "@@ -995,35 +995,35 @@ def __init__(\n \n     def execute(self, context: Context) -> None:\n         hook = DataprocHook(gcp_conn_id=self.gcp_conn_id, impersonation_chain=self.impersonation_chain)\n-        operation = self._delete_cluster(hook)\n-        if not self.deferrable:\n-            hook.wait_for_operation(timeout=self.timeout, result_retry=self.retry, operation=operation)\n-            self.log.info(\"Cluster deleted.\")\n-        else:\n-            try:\n-                hook.get_cluster(\n-                    project_id=self.project_id, region=self.region, cluster_name=self.cluster_name\n-                )\n-            except NotFound:\n+        try:\n+            op: operation.Operation = self._delete_cluster(hook)\n+            if not self.deferrable:\n+                hook.wait_for_operation(timeout=self.timeout, result_retry=self.retry, operation=op)\n                 self.log.info(\"Cluster deleted.\")\n-                return\n-            except Exception as e:\n-                raise AirflowException(str(e))\n-\n-            end_time: float = time.time() + self.timeout\n-            self.defer(\n-                trigger=DataprocDeleteClusterTrigger(\n-                    gcp_conn_id=self.gcp_conn_id,\n-                    project_id=self.project_id,\n-                    region=self.region,\n-                    cluster_name=self.cluster_name,\n-                    end_time=end_time,\n-                    metadata=self.metadata,\n-                    impersonation_chain=self.impersonation_chain,\n-                    polling_interval_seconds=self.polling_interval_seconds,\n-                ),\n-                method_name=\"execute_complete\",\n+            else:\n+                end_time: float = time.time() + self.timeout\n+                self.defer(\n+                    trigger=DataprocDeleteClusterTrigger(\n+                        gcp_conn_id=self.gcp_conn_id,\n+                        project_id=self.project_id,\n+                        region=self.region,\n+                        cluster_name=self.cluster_name,\n+                        end_time=end_time,\n+                        metadata=self.metadata,\n+                        impersonation_chain=self.impersonation_chain,\n+                        polling_interval_seconds=self.polling_interval_seconds,\n+                    ),\n+                    method_name=\"execute_complete\",\n+                )\n+        except NotFound:",
      "comment": "Yes. The exception will be raised by self._delete_cluster() call alone",
      "comment_id": 2661142185,
      "user": "chirodip98",
      "created_at": "2026-01-05T11:12:54Z",
      "url": "https://github.com/apache/airflow/pull/60083#discussion_r2661142185"
    },
    {
      "repo": "apache/airflow",
      "pr_number": 60083,
      "file_path": "providers/google/src/airflow/providers/google/cloud/operators/dataproc.py",
      "line": 1022,
      "side": "RIGHT",
      "diff_hunk": "@@ -995,35 +995,35 @@ def __init__(\n \n     def execute(self, context: Context) -> None:\n         hook = DataprocHook(gcp_conn_id=self.gcp_conn_id, impersonation_chain=self.impersonation_chain)\n-        operation = self._delete_cluster(hook)\n-        if not self.deferrable:\n-            hook.wait_for_operation(timeout=self.timeout, result_retry=self.retry, operation=operation)\n-            self.log.info(\"Cluster deleted.\")\n-        else:\n-            try:\n-                hook.get_cluster(\n-                    project_id=self.project_id, region=self.region, cluster_name=self.cluster_name\n-                )\n-            except NotFound:\n+        try:\n+            op: operation.Operation = self._delete_cluster(hook)\n+            if not self.deferrable:\n+                hook.wait_for_operation(timeout=self.timeout, result_retry=self.retry, operation=op)\n                 self.log.info(\"Cluster deleted.\")\n-                return\n-            except Exception as e:\n-                raise AirflowException(str(e))\n-\n-            end_time: float = time.time() + self.timeout\n-            self.defer(\n-                trigger=DataprocDeleteClusterTrigger(\n-                    gcp_conn_id=self.gcp_conn_id,\n-                    project_id=self.project_id,\n-                    region=self.region,\n-                    cluster_name=self.cluster_name,\n-                    end_time=end_time,\n-                    metadata=self.metadata,\n-                    impersonation_chain=self.impersonation_chain,\n-                    polling_interval_seconds=self.polling_interval_seconds,\n-                ),\n-                method_name=\"execute_complete\",\n+            else:\n+                end_time: float = time.time() + self.timeout\n+                self.defer(\n+                    trigger=DataprocDeleteClusterTrigger(\n+                        gcp_conn_id=self.gcp_conn_id,\n+                        project_id=self.project_id,\n+                        region=self.region,\n+                        cluster_name=self.cluster_name,\n+                        end_time=end_time,\n+                        metadata=self.metadata,\n+                        impersonation_chain=self.impersonation_chain,\n+                        polling_interval_seconds=self.polling_interval_seconds,\n+                    ),\n+                    method_name=\"execute_complete\",\n+                )\n+        except NotFound:\n+            self.log.info(\n+                \"Cluster %s not found in region %s. Skipping deletion.\", self.cluster_name, self.region\n+            )\n+            raise AirflowSkipException(",
      "comment": "In general we don't use this Exception in Google system tests... I think it will be strange for users to see this :)",
      "comment_id": 2661174820,
      "user": "VladaZakharova",
      "created_at": "2026-01-05T11:25:42Z",
      "url": "https://github.com/apache/airflow/pull/60083#discussion_r2661174820"
    },
    {
      "repo": "apache/airflow",
      "pr_number": 60083,
      "file_path": "providers/google/src/airflow/providers/google/cloud/operators/dataproc.py",
      "line": 1022,
      "side": "RIGHT",
      "diff_hunk": "@@ -995,35 +995,35 @@ def __init__(\n \n     def execute(self, context: Context) -> None:\n         hook = DataprocHook(gcp_conn_id=self.gcp_conn_id, impersonation_chain=self.impersonation_chain)\n-        operation = self._delete_cluster(hook)\n-        if not self.deferrable:\n-            hook.wait_for_operation(timeout=self.timeout, result_retry=self.retry, operation=operation)\n-            self.log.info(\"Cluster deleted.\")\n-        else:\n-            try:\n-                hook.get_cluster(\n-                    project_id=self.project_id, region=self.region, cluster_name=self.cluster_name\n-                )\n-            except NotFound:\n+        try:\n+            op: operation.Operation = self._delete_cluster(hook)\n+            if not self.deferrable:\n+                hook.wait_for_operation(timeout=self.timeout, result_retry=self.retry, operation=op)\n                 self.log.info(\"Cluster deleted.\")\n-                return\n-            except Exception as e:\n-                raise AirflowException(str(e))\n-\n-            end_time: float = time.time() + self.timeout\n-            self.defer(\n-                trigger=DataprocDeleteClusterTrigger(\n-                    gcp_conn_id=self.gcp_conn_id,\n-                    project_id=self.project_id,\n-                    region=self.region,\n-                    cluster_name=self.cluster_name,\n-                    end_time=end_time,\n-                    metadata=self.metadata,\n-                    impersonation_chain=self.impersonation_chain,\n-                    polling_interval_seconds=self.polling_interval_seconds,\n-                ),\n-                method_name=\"execute_complete\",\n+            else:\n+                end_time: float = time.time() + self.timeout\n+                self.defer(\n+                    trigger=DataprocDeleteClusterTrigger(\n+                        gcp_conn_id=self.gcp_conn_id,\n+                        project_id=self.project_id,\n+                        region=self.region,\n+                        cluster_name=self.cluster_name,\n+                        end_time=end_time,\n+                        metadata=self.metadata,\n+                        impersonation_chain=self.impersonation_chain,\n+                        polling_interval_seconds=self.polling_interval_seconds,\n+                    ),\n+                    method_name=\"execute_complete\",\n+                )\n+        except NotFound:\n+            self.log.info(\n+                \"Cluster %s not found in region %s. Skipping deletion.\", self.cluster_name, self.region\n+            )\n+            raise AirflowSkipException(",
      "comment": "In that case, what about we simply return, after logging, instead of any Exception\r\n",
      "comment_id": 2661197146,
      "user": "chirodip98",
      "created_at": "2026-01-05T11:34:35Z",
      "url": "https://github.com/apache/airflow/pull/60083#discussion_r2661197146"
    },
    {
      "repo": "apache/airflow",
      "pr_number": 60083,
      "file_path": "providers/google/src/airflow/providers/google/cloud/operators/dataproc.py",
      "line": 1022,
      "side": "RIGHT",
      "diff_hunk": "@@ -995,35 +995,35 @@ def __init__(\n \n     def execute(self, context: Context) -> None:\n         hook = DataprocHook(gcp_conn_id=self.gcp_conn_id, impersonation_chain=self.impersonation_chain)\n-        operation = self._delete_cluster(hook)\n-        if not self.deferrable:\n-            hook.wait_for_operation(timeout=self.timeout, result_retry=self.retry, operation=operation)\n-            self.log.info(\"Cluster deleted.\")\n-        else:\n-            try:\n-                hook.get_cluster(\n-                    project_id=self.project_id, region=self.region, cluster_name=self.cluster_name\n-                )\n-            except NotFound:\n+        try:\n+            op: operation.Operation = self._delete_cluster(hook)\n+            if not self.deferrable:\n+                hook.wait_for_operation(timeout=self.timeout, result_retry=self.retry, operation=op)\n                 self.log.info(\"Cluster deleted.\")\n-                return\n-            except Exception as e:\n-                raise AirflowException(str(e))\n-\n-            end_time: float = time.time() + self.timeout\n-            self.defer(\n-                trigger=DataprocDeleteClusterTrigger(\n-                    gcp_conn_id=self.gcp_conn_id,\n-                    project_id=self.project_id,\n-                    region=self.region,\n-                    cluster_name=self.cluster_name,\n-                    end_time=end_time,\n-                    metadata=self.metadata,\n-                    impersonation_chain=self.impersonation_chain,\n-                    polling_interval_seconds=self.polling_interval_seconds,\n-                ),\n-                method_name=\"execute_complete\",\n+            else:\n+                end_time: float = time.time() + self.timeout\n+                self.defer(\n+                    trigger=DataprocDeleteClusterTrigger(\n+                        gcp_conn_id=self.gcp_conn_id,\n+                        project_id=self.project_id,\n+                        region=self.region,\n+                        cluster_name=self.cluster_name,\n+                        end_time=end_time,\n+                        metadata=self.metadata,\n+                        impersonation_chain=self.impersonation_chain,\n+                        polling_interval_seconds=self.polling_interval_seconds,\n+                    ),\n+                    method_name=\"execute_complete\",\n+                )\n+        except NotFound:\n+            self.log.info(\n+                \"Cluster %s not found in region %s. Skipping deletion.\", self.cluster_name, self.region\n+            )\n+            raise AirflowSkipException(",
      "comment": "<img width=\"1848\" height=\"871\" alt=\"image\" src=\"https://github.com/user-attachments/assets/e045a46b-58a9-4fbb-b7af-a062c806964c\" />\r\n",
      "comment_id": 2661436763,
      "user": "chirodip98",
      "created_at": "2026-01-05T13:05:08Z",
      "url": "https://github.com/apache/airflow/pull/60083#discussion_r2661436763"
    },
    {
      "repo": "apache/airflow",
      "pr_number": 60083,
      "file_path": "providers/google/src/airflow/providers/google/cloud/operators/dataproc.py",
      "line": 1022,
      "side": "RIGHT",
      "diff_hunk": "@@ -995,35 +995,35 @@ def __init__(\n \n     def execute(self, context: Context) -> None:\n         hook = DataprocHook(gcp_conn_id=self.gcp_conn_id, impersonation_chain=self.impersonation_chain)\n-        operation = self._delete_cluster(hook)\n-        if not self.deferrable:\n-            hook.wait_for_operation(timeout=self.timeout, result_retry=self.retry, operation=operation)\n-            self.log.info(\"Cluster deleted.\")\n-        else:\n-            try:\n-                hook.get_cluster(\n-                    project_id=self.project_id, region=self.region, cluster_name=self.cluster_name\n-                )\n-            except NotFound:\n+        try:\n+            op: operation.Operation = self._delete_cluster(hook)\n+            if not self.deferrable:\n+                hook.wait_for_operation(timeout=self.timeout, result_retry=self.retry, operation=op)\n                 self.log.info(\"Cluster deleted.\")\n-                return\n-            except Exception as e:\n-                raise AirflowException(str(e))\n-\n-            end_time: float = time.time() + self.timeout\n-            self.defer(\n-                trigger=DataprocDeleteClusterTrigger(\n-                    gcp_conn_id=self.gcp_conn_id,\n-                    project_id=self.project_id,\n-                    region=self.region,\n-                    cluster_name=self.cluster_name,\n-                    end_time=end_time,\n-                    metadata=self.metadata,\n-                    impersonation_chain=self.impersonation_chain,\n-                    polling_interval_seconds=self.polling_interval_seconds,\n-                ),\n-                method_name=\"execute_complete\",\n+            else:\n+                end_time: float = time.time() + self.timeout\n+                self.defer(\n+                    trigger=DataprocDeleteClusterTrigger(\n+                        gcp_conn_id=self.gcp_conn_id,\n+                        project_id=self.project_id,\n+                        region=self.region,\n+                        cluster_name=self.cluster_name,\n+                        end_time=end_time,\n+                        metadata=self.metadata,\n+                        impersonation_chain=self.impersonation_chain,\n+                        polling_interval_seconds=self.polling_interval_seconds,\n+                    ),\n+                    method_name=\"execute_complete\",\n+                )\n+        except NotFound:\n+            self.log.info(\n+                \"Cluster %s not found in region %s. Skipping deletion.\", self.cluster_name, self.region\n+            )\n+            raise AirflowSkipException(",
      "comment": "<img width=\"1918\" height=\"561\" alt=\"image\" src=\"https://github.com/user-attachments/assets/0fed2936-79ed-40ff-b8d9-ebd6bb7ef3d3\" />\r\n",
      "comment_id": 2661438453,
      "user": "chirodip98",
      "created_at": "2026-01-05T13:05:51Z",
      "url": "https://github.com/apache/airflow/pull/60083#discussion_r2661438453"
    },
    {
      "repo": "apache/airflow",
      "pr_number": 60083,
      "file_path": "providers/google/src/airflow/providers/google/cloud/operators/dataproc.py",
      "line": 28,
      "side": "RIGHT",
      "diff_hunk": "@@ -25,7 +25,7 @@\n import warnings\n from collections.abc import MutableSequence, Sequence\n from dataclasses import dataclass\n-from datetime import datetime, timedelta\n+from datetime import datetime, timedelta, timezone",
      "comment": "<img width=\"1160\" height=\"418\" alt=\"image\" src=\"https://github.com/user-attachments/assets/521e9c5f-4418-47ee-95cc-f1a398d77f22\" />\r\noriginal traceback",
      "comment_id": 2661441966,
      "user": "chirodip98",
      "created_at": "2026-01-05T13:07:14Z",
      "url": "https://github.com/apache/airflow/pull/60083#discussion_r2661441966"
    },
    {
      "repo": "apache/airflow",
      "pr_number": 60083,
      "file_path": "providers/google/src/airflow/providers/google/cloud/operators/dataproc.py",
      "line": 396,
      "side": "RIGHT",
      "diff_hunk": "@@ -391,6 +390,10 @@ def _build_lifecycle_config(self, cluster_data):\n             cluster_data[lifecycle_config][\"idle_delete_ttl\"] = {\"seconds\": self.idle_delete_ttl}\n \n         if self.auto_delete_time:\n+            try:\n+                from airflow.sdk import timezone\n+            except (ImportError, ModuleNotFoundError):\n+                from airflow.utils import timezone",
      "comment": "Please use `from airflow.providers.common.compat.sdk import timezone` instead and move this to top-level.",
      "comment_id": 2674279563,
      "user": "uranusjr",
      "created_at": "2026-01-08T23:49:33Z",
      "url": "https://github.com/apache/airflow/pull/60083#discussion_r2674279563"
    },
    {
      "repo": "apache/airflow",
      "pr_number": 60083,
      "file_path": "providers/google/src/airflow/providers/google/cloud/operators/dataproc.py",
      "line": 396,
      "side": "RIGHT",
      "diff_hunk": "@@ -391,6 +390,10 @@ def _build_lifecycle_config(self, cluster_data):\n             cluster_data[lifecycle_config][\"idle_delete_ttl\"] = {\"seconds\": self.idle_delete_ttl}\n \n         if self.auto_delete_time:\n+            try:\n+                from airflow.sdk import timezone\n+            except (ImportError, ModuleNotFoundError):\n+                from airflow.utils import timezone",
      "comment": "Thanks for pointing it out. Applied the suggested changes. @uranusjr ",
      "comment_id": 2674756510,
      "user": "chirodip98",
      "created_at": "2026-01-09T04:14:37Z",
      "url": "https://github.com/apache/airflow/pull/60083#discussion_r2674756510"
    },
    {
      "repo": "apache/airflow",
      "pr_number": 60127,
      "file_path": "airflow-core/src/airflow/dag_processing/importers/python_importer.py",
      "line": 134,
      "side": "RIGHT",
      "diff_hunk": "@@ -0,0 +1,430 @@\n+# Licensed to the Apache Software Foundation (ASF) under one\n+# or more contributor license agreements.  See the NOTICE file\n+# distributed with this work for additional information\n+# regarding copyright ownership.  The ASF licenses this file\n+# to you under the Apache License, Version 2.0 (the\n+# \"License\"); you may not use this file except in compliance\n+# with the License.  You may obtain a copy of the License at\n+#\n+#   http://www.apache.org/licenses/LICENSE-2.0\n+#\n+# Unless required by applicable law or agreed to in writing,\n+# software distributed under the License is distributed on an\n+# \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+# KIND, either express or implied.  See the License for the\n+# specific language governing permissions and limitations\n+# under the License.\n+\"\"\"Python DAG importer - imports DAGs from Python files.\"\"\"\n+\n+from __future__ import annotations\n+\n+import contextlib\n+import importlib\n+import importlib.machinery\n+import importlib.util\n+import logging\n+import os\n+import signal\n+import sys\n+import traceback\n+import warnings\n+import zipfile\n+from pathlib import Path\n+from typing import TYPE_CHECKING, Any\n+\n+from airflow import settings\n+from airflow.configuration import conf\n+from airflow.dag_processing.importers.base import (\n+    AbstractDagImporter,\n+    DagImportError,\n+    DagImportResult,\n+    DagImportWarning,\n+)\n+from airflow.exceptions import (\n+    AirflowClusterPolicyError,\n+    AirflowClusterPolicySkipDag,\n+    AirflowClusterPolicyViolation,\n+    AirflowDagDuplicatedIdException,\n+    UnknownExecutorException,\n+)\n+from airflow.executors.executor_loader import ExecutorLoader\n+from airflow.listeners.listener import get_listener_manager\n+from airflow.utils.docs import get_docs_url\n+from airflow.utils.file import get_unique_dag_module_name, might_contain_dag\n+\n+if TYPE_CHECKING:\n+    from types import ModuleType\n+\n+    from airflow.sdk import DAG\n+\n+log = logging.getLogger(__name__)\n+\n+\n+@contextlib.contextmanager\n+def _timeout(seconds: float = 1, error_message: str = \"Timeout\"):\n+    \"\"\"Context manager for timing out operations.\"\"\"\n+    error_message = error_message + \", PID: \" + str(os.getpid())\n+\n+    def handle_timeout(signum, frame):\n+        log.error(\"Process timed out, PID: %s\", str(os.getpid()))\n+        from airflow.sdk.exceptions import AirflowTaskTimeout\n+\n+        raise AirflowTaskTimeout(error_message)\n+\n+    try:\n+        try:\n+            signal.signal(signal.SIGALRM, handle_timeout)\n+            signal.setitimer(signal.ITIMER_REAL, seconds)\n+        except ValueError:\n+            log.warning(\"timeout can't be used in the current context\", exc_info=True)\n+        yield\n+    finally:\n+        with contextlib.suppress(ValueError):\n+            signal.setitimer(signal.ITIMER_REAL, 0)\n+\n+\n+def _executor_exists(executor_name: str, team_name: str | None) -> bool:\n+    \"\"\"Check if executor exists, with global fallback for teams.\"\"\"\n+    try:\n+        ExecutorLoader.lookup_executor_name_by_str(executor_name, team_name=team_name)\n+        return True\n+    except UnknownExecutorException:\n+        if team_name:\n+            try:\n+                ExecutorLoader.lookup_executor_name_by_str(executor_name, team_name=None)\n+                return True\n+            except UnknownExecutorException:\n+                pass\n+    return False\n+\n+\n+def _validate_executor_fields(dag: DAG, bundle_name: str | None = None) -> None:\n+    \"\"\"Validate that executors specified in tasks are available.\"\"\"\n+    dag_team_name = None\n+\n+    if conf.getboolean(\"core\", \"multi_team\"):\n+        if bundle_name:\n+            from airflow.dag_processing.bundles.manager import DagBundlesManager\n+\n+            bundle_manager = DagBundlesManager()\n+            bundle_config = bundle_manager._bundle_config[bundle_name]\n+            dag_team_name = bundle_config.team_name\n+\n+    for task in dag.tasks:\n+        if not task.executor:\n+            continue\n+\n+        if not _executor_exists(task.executor, dag_team_name):\n+            if dag_team_name:\n+                raise UnknownExecutorException(\n+                    f\"Task '{task.task_id}' specifies executor '{task.executor}', which is not available \"\n+                    f\"for team '{dag_team_name}' (the team associated with DAG '{dag.dag_id}') or as a global executor.\"\n+                )\n+            raise UnknownExecutorException(\n+                f\"Task '{task.task_id}' specifies executor '{task.executor}', which is not available.\"\n+            )\n+\n+\n+class PythonDagImporter(AbstractDagImporter):\n+    \"\"\"Importer for Python DAG files and zip archives.\"\"\"\n+\n+    @classmethod\n+    def supported_extensions(cls) -> list[str]:\n+        return [\".py\", \".zip\", \"\"]  # Empty string for extension-less files\n+",
      "comment": "The comment states 'Empty string for extension-less files', but returning an empty string as a file extension is unconventional and may lead to unexpected behavior. Empty strings typically indicate missing data rather than 'no extension'. Consider clarifying the intended handling of extension-less files or documenting why this approach is necessary.\n```suggestion\n        \"\"\"\n        Return the file extensions supported by this importer.\n\n        The empty string (\"\") is used as an explicit sentinel value to indicate\n        files with no extension (e.g. a filename like \"dagfile\" without a\n        trailing dot). Callers of this method should treat \"\" as \"no extension\",\n        not as \"missing data\".\n        \"\"\"\n        return [\".py\", \".zip\", \"\"]  # \"\" is an explicit sentinel for extension-less files\n```",
      "comment_id": 2661971492,
      "user": "Copilot",
      "created_at": "2026-01-05T15:53:23Z",
      "url": "https://github.com/apache/airflow/pull/60127#discussion_r2661971492"
    },
    {
      "repo": "apache/airflow",
      "pr_number": 60127,
      "file_path": "airflow-core/src/airflow/dag_processing/dagbag.py",
      "line": 380,
      "side": "RIGHT",
      "diff_hunk": "@@ -339,29 +331,62 @@ def process_file(self, filepath, only_if_updated=True, safe_mode=True):\n             self.log.exception(e)\n             return []\n \n-        # Ensure we don't pick up anything else we didn't mean to\n-        DagContext.autoregistered_dags.clear()\n-\n         self.captured_warnings.pop(filepath, None)\n-        with _capture_with_reraise() as captured_warnings:\n-            if filepath.endswith(\".py\") or not zipfile.is_zipfile(filepath):\n-                mods = self._load_modules_from_file(filepath, safe_mode)\n-            else:\n-                mods = self._load_modules_from_zip(filepath, safe_mode)\n \n-        if captured_warnings:\n-            formatted_warnings = []\n-            for msg in captured_warnings:\n-                category = msg.category.__name__\n-                if (module := msg.category.__module__) != \"builtins\":\n-                    category = f\"{module}.{category}\"\n-                formatted_warnings.append(f\"{msg.filename}:{msg.lineno}: {category}: {msg.message}\")\n+        from airflow.dag_processing.importers import get_importer_registry\n+\n+        registry = get_importer_registry()\n+        importer = registry.get_importer(filepath)\n+\n+        if importer is None:\n+            self.log.debug(\"No importer found for file: %s\", filepath)\n+            return []\n+\n+        result = importer.import_file(\n+            file_path=filepath,\n+            bundle_path=Path(self.dag_folder) if self.dag_folder else None,\n+            bundle_name=self.bundle_name,\n+            safe_mode=safe_mode,\n+        )\n+\n+        if result.skipped_files:\n+            for skipped in result.skipped_files:\n+                if not self.has_logged:\n+                    self.has_logged = True\n+                    self.log.info(\"File %s assumed to contain no DAGs. Skipping.\", skipped)\n+\n+        if result.errors:\n+            for error in result.errors:\n+                # Use the file path from error for ZIP files (contains zip/file.py format)\n+                # For regular files, use the original filepath\n+                if zipfile.is_zipfile(filepath):\n+                    error_path = error.file_path if error.file_path else filepath\n+                else:\n+                    error_path = filepath\n+                error_msg = error.stacktrace if error.stacktrace else error.message\n+                self.import_errors[error_path] = error_msg\n+                self.log.error(\"Error loading DAG from %s: %s\", error_path, error.message)\n+\n+        if result.warnings:\n+            formatted_warnings = [\n+                f\"{w.file_path}:{w.line_number}: {w.warning_type}: {w.message}\" for w in result.warnings\n+            ]\n             self.captured_warnings[filepath] = tuple(formatted_warnings)\n \n-        found_dags = self._process_modules(filepath, mods, file_last_changed_on_disk)\n+        bagged_dags = []\n+        for dag in result.dags:\n+            try:\n+                # Only set fileloc if not already set by importer (ZIP files have path inside archive)\n+                if not dag.fileloc:",
      "comment": "The comment on line 379 states 'Only set fileloc if not already set by importer (ZIP files have path inside archive)', but this logic may not correctly handle all cases. If a DAG's fileloc is explicitly set to an empty string or falsy value by the importer, this condition would incorrectly override it. Consider checking for None specifically or clarifying the expected behavior.\n```suggestion\n                if dag.fileloc is None:\n```",
      "comment_id": 2661971525,
      "user": "Copilot",
      "created_at": "2026-01-05T15:53:24Z",
      "url": "https://github.com/apache/airflow/pull/60127#discussion_r2661971525"
    },
    {
      "repo": "apache/airflow",
      "pr_number": 60127,
      "file_path": "airflow-core/src/airflow/dag_processing/importers/base.py",
      "line": 119,
      "side": "RIGHT",
      "diff_hunk": "@@ -0,0 +1,163 @@\n+# Licensed to the Apache Software Foundation (ASF) under one\n+# or more contributor license agreements.  See the NOTICE file\n+# distributed with this work for additional information\n+# regarding copyright ownership.  The ASF licenses this file\n+# to you under the Apache License, Version 2.0 (the\n+# \"License\"); you may not use this file except in compliance\n+# with the License.  You may obtain a copy of the License at\n+#\n+#   http://www.apache.org/licenses/LICENSE-2.0\n+#\n+# Unless required by applicable law or agreed to in writing,\n+# software distributed under the License is distributed on an\n+# \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+# KIND, either express or implied.  See the License for the\n+# specific language governing permissions and limitations\n+# under the License.\n+\"\"\"Abstract base class for DAG importers.\"\"\"\n+\n+from __future__ import annotations\n+\n+from abc import ABC, abstractmethod\n+from dataclasses import dataclass, field\n+from pathlib import Path\n+from typing import TYPE_CHECKING\n+\n+if TYPE_CHECKING:\n+    from airflow.sdk import DAG\n+\n+\n+@dataclass\n+class DagImportError:\n+    \"\"\"Structured error information for DAG import failures.\"\"\"\n+\n+    file_path: str\n+    message: str\n+    error_type: str = \"import\"\n+    line_number: int | None = None\n+    column_number: int | None = None\n+    context: str | None = None\n+    suggestion: str | None = None\n+    stacktrace: str | None = None\n+\n+    def format_message(self) -> str:\n+        \"\"\"Format the error as a human-readable string.\"\"\"\n+        parts = [f\"Error in {self.file_path}\"]\n+        if self.line_number is not None:\n+            loc = f\"line {self.line_number}\"\n+            if self.column_number is not None:\n+                loc += f\", column {self.column_number}\"\n+            parts.append(f\"Location: {loc}\")\n+        parts.append(f\"Error ({self.error_type}): {self.message}\")\n+        if self.context:\n+            parts.append(f\"Context:\\n{self.context}\")\n+        if self.suggestion:\n+            parts.append(f\"Suggestion: {self.suggestion}\")\n+        return \"\\n\".join(parts)\n+\n+\n+@dataclass\n+class DagImportWarning:\n+    \"\"\"Warning information for non-fatal issues during DAG import.\"\"\"\n+\n+    file_path: str\n+    message: str\n+    warning_type: str = \"general\"\n+    line_number: int | None = None\n+\n+\n+@dataclass\n+class DagImportResult:\n+    \"\"\"Result of importing DAGs from a file.\"\"\"\n+\n+    file_path: str\n+    dags: list[DAG] = field(default_factory=list)\n+    errors: list[DagImportError] = field(default_factory=list)\n+    skipped_files: list[str] = field(default_factory=list)\n+    warnings: list[DagImportWarning] = field(default_factory=list)\n+\n+    @property\n+    def success(self) -> bool:\n+        \"\"\"Return True if no fatal errors occurred.\"\"\"\n+        return len(self.errors) == 0\n+\n+\n+class AbstractDagImporter(ABC):\n+    \"\"\"Abstract base class for DAG importers.\"\"\"\n+\n+    @classmethod\n+    @abstractmethod\n+    def supported_extensions(cls) -> list[str]:\n+        \"\"\"Return file extensions this importer handles (e.g., ['.py', '.zip']).\"\"\"\n+\n+    @abstractmethod\n+    def import_file(\n+        self,\n+        file_path: str | Path,\n+        *,\n+        bundle_path: Path | None = None,\n+        bundle_name: str | None = None,\n+        safe_mode: bool = True,\n+    ) -> DagImportResult:\n+        \"\"\"Import DAGs from a file.\"\"\"\n+\n+    def can_handle(self, file_path: str | Path) -> bool:\n+        \"\"\"Check if this importer can handle the given file.\"\"\"\n+        path = Path(file_path) if isinstance(file_path, str) else file_path\n+        return path.suffix.lower() in self.supported_extensions()\n+\n+    def get_relative_path(self, file_path: str | Path, bundle_path: Path | None) -> str:",
      "comment": "Is the goal of this method is to allow importer to override file_path/bundle_path relation resolution? If not, it can probably be an independent function.",
      "comment_id": 2662154326,
      "user": "ikholopov-omni",
      "created_at": "2026-01-05T16:48:41Z",
      "url": "https://github.com/apache/airflow/pull/60127#discussion_r2662154326"
    },
    {
      "repo": "apache/airflow",
      "pr_number": 60127,
      "file_path": "airflow-core/src/airflow/dag_processing/importers/base.py",
      "line": 143,
      "side": "RIGHT",
      "diff_hunk": "@@ -0,0 +1,163 @@\n+# Licensed to the Apache Software Foundation (ASF) under one\n+# or more contributor license agreements.  See the NOTICE file\n+# distributed with this work for additional information\n+# regarding copyright ownership.  The ASF licenses this file\n+# to you under the Apache License, Version 2.0 (the\n+# \"License\"); you may not use this file except in compliance\n+# with the License.  You may obtain a copy of the License at\n+#\n+#   http://www.apache.org/licenses/LICENSE-2.0\n+#\n+# Unless required by applicable law or agreed to in writing,\n+# software distributed under the License is distributed on an\n+# \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+# KIND, either express or implied.  See the License for the\n+# specific language governing permissions and limitations\n+# under the License.\n+\"\"\"Abstract base class for DAG importers.\"\"\"\n+\n+from __future__ import annotations\n+\n+from abc import ABC, abstractmethod\n+from dataclasses import dataclass, field\n+from pathlib import Path\n+from typing import TYPE_CHECKING\n+\n+if TYPE_CHECKING:\n+    from airflow.sdk import DAG\n+\n+\n+@dataclass\n+class DagImportError:\n+    \"\"\"Structured error information for DAG import failures.\"\"\"\n+\n+    file_path: str\n+    message: str\n+    error_type: str = \"import\"\n+    line_number: int | None = None\n+    column_number: int | None = None\n+    context: str | None = None\n+    suggestion: str | None = None\n+    stacktrace: str | None = None\n+\n+    def format_message(self) -> str:\n+        \"\"\"Format the error as a human-readable string.\"\"\"\n+        parts = [f\"Error in {self.file_path}\"]\n+        if self.line_number is not None:\n+            loc = f\"line {self.line_number}\"\n+            if self.column_number is not None:\n+                loc += f\", column {self.column_number}\"\n+            parts.append(f\"Location: {loc}\")\n+        parts.append(f\"Error ({self.error_type}): {self.message}\")\n+        if self.context:\n+            parts.append(f\"Context:\\n{self.context}\")\n+        if self.suggestion:\n+            parts.append(f\"Suggestion: {self.suggestion}\")\n+        return \"\\n\".join(parts)\n+\n+\n+@dataclass\n+class DagImportWarning:\n+    \"\"\"Warning information for non-fatal issues during DAG import.\"\"\"\n+\n+    file_path: str\n+    message: str\n+    warning_type: str = \"general\"\n+    line_number: int | None = None\n+\n+\n+@dataclass\n+class DagImportResult:\n+    \"\"\"Result of importing DAGs from a file.\"\"\"\n+\n+    file_path: str\n+    dags: list[DAG] = field(default_factory=list)\n+    errors: list[DagImportError] = field(default_factory=list)\n+    skipped_files: list[str] = field(default_factory=list)\n+    warnings: list[DagImportWarning] = field(default_factory=list)\n+\n+    @property\n+    def success(self) -> bool:\n+        \"\"\"Return True if no fatal errors occurred.\"\"\"\n+        return len(self.errors) == 0\n+\n+\n+class AbstractDagImporter(ABC):\n+    \"\"\"Abstract base class for DAG importers.\"\"\"\n+\n+    @classmethod\n+    @abstractmethod\n+    def supported_extensions(cls) -> list[str]:\n+        \"\"\"Return file extensions this importer handles (e.g., ['.py', '.zip']).\"\"\"\n+\n+    @abstractmethod\n+    def import_file(\n+        self,\n+        file_path: str | Path,\n+        *,\n+        bundle_path: Path | None = None,\n+        bundle_name: str | None = None,\n+        safe_mode: bool = True,\n+    ) -> DagImportResult:\n+        \"\"\"Import DAGs from a file.\"\"\"\n+\n+    def can_handle(self, file_path: str | Path) -> bool:\n+        \"\"\"Check if this importer can handle the given file.\"\"\"\n+        path = Path(file_path) if isinstance(file_path, str) else file_path\n+        return path.suffix.lower() in self.supported_extensions()\n+\n+    def get_relative_path(self, file_path: str | Path, bundle_path: Path | None) -> str:\n+        \"\"\"Get the relative file path from the bundle root.\"\"\"\n+        if bundle_path is None:\n+            return str(file_path)\n+        try:\n+            return str(Path(file_path).relative_to(bundle_path))\n+        except ValueError:\n+            return str(file_path)\n+\n+\n+class DagImporterRegistry:\n+    \"\"\"Registry for DAG importers. Singleton that manages importers by file extension.\"\"\"\n+\n+    _instance: DagImporterRegistry | None = None\n+    _importers: dict[str, AbstractDagImporter]\n+\n+    def __new__(cls) -> DagImporterRegistry:\n+        if cls._instance is None:\n+            cls._instance = super().__new__(cls)\n+            cls._instance._importers = {}\n+            cls._instance._register_default_importers()\n+        return cls._instance\n+\n+    def _register_default_importers(self) -> None:\n+        from airflow.dag_processing.importers.python_importer import PythonDagImporter\n+\n+        self.register(PythonDagImporter())\n+\n+    def register(self, importer: AbstractDagImporter) -> None:\n+        \"\"\"Register an importer for its supported extensions.\"\"\"\n+        for ext in importer.supported_extensions():\n+            self._importers[ext.lower()] = importer",
      "comment": "From what I understand, the idea is to use file extensions for automatic deduction of the required importer. While this is viable, things will get messy almost immediately - for ex. `.zip` importer will be claimed by Python importer, but I believe other formats (like YamlImporter) should also be able to handle it.\r\n\r\nAt the very least we need to put some protection here that would prevent the accidental overrides of the extension that already got claimed by another registered importer.\r\n\r\nOverall, keeping importer independent of other configurations (like Bundles) seems like a reasonable \"default\", if we want to allow per-bundle customization (like only import Python and ignore YAML files for the bundle A, only import YAML for the bundle B) , we can always add it later.",
      "comment_id": 2662174544,
      "user": "ikholopov-omni",
      "created_at": "2026-01-05T16:55:43Z",
      "url": "https://github.com/apache/airflow/pull/60127#discussion_r2662174544"
    },
    {
      "repo": "apache/airflow",
      "pr_number": 60127,
      "file_path": "airflow-core/src/airflow/dag_processing/importers/base.py",
      "line": 119,
      "side": "RIGHT",
      "diff_hunk": "@@ -0,0 +1,163 @@\n+# Licensed to the Apache Software Foundation (ASF) under one\n+# or more contributor license agreements.  See the NOTICE file\n+# distributed with this work for additional information\n+# regarding copyright ownership.  The ASF licenses this file\n+# to you under the Apache License, Version 2.0 (the\n+# \"License\"); you may not use this file except in compliance\n+# with the License.  You may obtain a copy of the License at\n+#\n+#   http://www.apache.org/licenses/LICENSE-2.0\n+#\n+# Unless required by applicable law or agreed to in writing,\n+# software distributed under the License is distributed on an\n+# \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+# KIND, either express or implied.  See the License for the\n+# specific language governing permissions and limitations\n+# under the License.\n+\"\"\"Abstract base class for DAG importers.\"\"\"\n+\n+from __future__ import annotations\n+\n+from abc import ABC, abstractmethod\n+from dataclasses import dataclass, field\n+from pathlib import Path\n+from typing import TYPE_CHECKING\n+\n+if TYPE_CHECKING:\n+    from airflow.sdk import DAG\n+\n+\n+@dataclass\n+class DagImportError:\n+    \"\"\"Structured error information for DAG import failures.\"\"\"\n+\n+    file_path: str\n+    message: str\n+    error_type: str = \"import\"\n+    line_number: int | None = None\n+    column_number: int | None = None\n+    context: str | None = None\n+    suggestion: str | None = None\n+    stacktrace: str | None = None\n+\n+    def format_message(self) -> str:\n+        \"\"\"Format the error as a human-readable string.\"\"\"\n+        parts = [f\"Error in {self.file_path}\"]\n+        if self.line_number is not None:\n+            loc = f\"line {self.line_number}\"\n+            if self.column_number is not None:\n+                loc += f\", column {self.column_number}\"\n+            parts.append(f\"Location: {loc}\")\n+        parts.append(f\"Error ({self.error_type}): {self.message}\")\n+        if self.context:\n+            parts.append(f\"Context:\\n{self.context}\")\n+        if self.suggestion:\n+            parts.append(f\"Suggestion: {self.suggestion}\")\n+        return \"\\n\".join(parts)\n+\n+\n+@dataclass\n+class DagImportWarning:\n+    \"\"\"Warning information for non-fatal issues during DAG import.\"\"\"\n+\n+    file_path: str\n+    message: str\n+    warning_type: str = \"general\"\n+    line_number: int | None = None\n+\n+\n+@dataclass\n+class DagImportResult:\n+    \"\"\"Result of importing DAGs from a file.\"\"\"\n+\n+    file_path: str\n+    dags: list[DAG] = field(default_factory=list)\n+    errors: list[DagImportError] = field(default_factory=list)\n+    skipped_files: list[str] = field(default_factory=list)\n+    warnings: list[DagImportWarning] = field(default_factory=list)\n+\n+    @property\n+    def success(self) -> bool:\n+        \"\"\"Return True if no fatal errors occurred.\"\"\"\n+        return len(self.errors) == 0\n+\n+\n+class AbstractDagImporter(ABC):\n+    \"\"\"Abstract base class for DAG importers.\"\"\"\n+\n+    @classmethod\n+    @abstractmethod\n+    def supported_extensions(cls) -> list[str]:\n+        \"\"\"Return file extensions this importer handles (e.g., ['.py', '.zip']).\"\"\"\n+\n+    @abstractmethod\n+    def import_file(\n+        self,\n+        file_path: str | Path,\n+        *,\n+        bundle_path: Path | None = None,\n+        bundle_name: str | None = None,\n+        safe_mode: bool = True,\n+    ) -> DagImportResult:\n+        \"\"\"Import DAGs from a file.\"\"\"\n+\n+    def can_handle(self, file_path: str | Path) -> bool:\n+        \"\"\"Check if this importer can handle the given file.\"\"\"\n+        path = Path(file_path) if isinstance(file_path, str) else file_path\n+        return path.suffix.lower() in self.supported_extensions()\n+\n+    def get_relative_path(self, file_path: str | Path, bundle_path: Path | None) -> str:",
      "comment": "You are right that it could be a standalone function. I kept it as a method for two reasons:\r\n1. Extensibility: Some importers might need custom path resolution (e.g., nested archives, virtual file systems)\r\n2. Encapsulation: Keeps the path-related logic close to the importer that uses it\r\n\r\nThat said, happy to extract it to a utility function if you feel strongly about it - the default implementation is generic enough",
      "comment_id": 2662417533,
      "user": "kaxil",
      "created_at": "2026-01-05T18:22:51Z",
      "url": "https://github.com/apache/airflow/pull/60127#discussion_r2662417533"
    },
    {
      "repo": "apache/airflow",
      "pr_number": 60127,
      "file_path": "airflow-core/src/airflow/dag_processing/importers/base.py",
      "line": 143,
      "side": "RIGHT",
      "diff_hunk": "@@ -0,0 +1,163 @@\n+# Licensed to the Apache Software Foundation (ASF) under one\n+# or more contributor license agreements.  See the NOTICE file\n+# distributed with this work for additional information\n+# regarding copyright ownership.  The ASF licenses this file\n+# to you under the Apache License, Version 2.0 (the\n+# \"License\"); you may not use this file except in compliance\n+# with the License.  You may obtain a copy of the License at\n+#\n+#   http://www.apache.org/licenses/LICENSE-2.0\n+#\n+# Unless required by applicable law or agreed to in writing,\n+# software distributed under the License is distributed on an\n+# \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+# KIND, either express or implied.  See the License for the\n+# specific language governing permissions and limitations\n+# under the License.\n+\"\"\"Abstract base class for DAG importers.\"\"\"\n+\n+from __future__ import annotations\n+\n+from abc import ABC, abstractmethod\n+from dataclasses import dataclass, field\n+from pathlib import Path\n+from typing import TYPE_CHECKING\n+\n+if TYPE_CHECKING:\n+    from airflow.sdk import DAG\n+\n+\n+@dataclass\n+class DagImportError:\n+    \"\"\"Structured error information for DAG import failures.\"\"\"\n+\n+    file_path: str\n+    message: str\n+    error_type: str = \"import\"\n+    line_number: int | None = None\n+    column_number: int | None = None\n+    context: str | None = None\n+    suggestion: str | None = None\n+    stacktrace: str | None = None\n+\n+    def format_message(self) -> str:\n+        \"\"\"Format the error as a human-readable string.\"\"\"\n+        parts = [f\"Error in {self.file_path}\"]\n+        if self.line_number is not None:\n+            loc = f\"line {self.line_number}\"\n+            if self.column_number is not None:\n+                loc += f\", column {self.column_number}\"\n+            parts.append(f\"Location: {loc}\")\n+        parts.append(f\"Error ({self.error_type}): {self.message}\")\n+        if self.context:\n+            parts.append(f\"Context:\\n{self.context}\")\n+        if self.suggestion:\n+            parts.append(f\"Suggestion: {self.suggestion}\")\n+        return \"\\n\".join(parts)\n+\n+\n+@dataclass\n+class DagImportWarning:\n+    \"\"\"Warning information for non-fatal issues during DAG import.\"\"\"\n+\n+    file_path: str\n+    message: str\n+    warning_type: str = \"general\"\n+    line_number: int | None = None\n+\n+\n+@dataclass\n+class DagImportResult:\n+    \"\"\"Result of importing DAGs from a file.\"\"\"\n+\n+    file_path: str\n+    dags: list[DAG] = field(default_factory=list)\n+    errors: list[DagImportError] = field(default_factory=list)\n+    skipped_files: list[str] = field(default_factory=list)\n+    warnings: list[DagImportWarning] = field(default_factory=list)\n+\n+    @property\n+    def success(self) -> bool:\n+        \"\"\"Return True if no fatal errors occurred.\"\"\"\n+        return len(self.errors) == 0\n+\n+\n+class AbstractDagImporter(ABC):\n+    \"\"\"Abstract base class for DAG importers.\"\"\"\n+\n+    @classmethod\n+    @abstractmethod\n+    def supported_extensions(cls) -> list[str]:\n+        \"\"\"Return file extensions this importer handles (e.g., ['.py', '.zip']).\"\"\"\n+\n+    @abstractmethod\n+    def import_file(\n+        self,\n+        file_path: str | Path,\n+        *,\n+        bundle_path: Path | None = None,\n+        bundle_name: str | None = None,\n+        safe_mode: bool = True,\n+    ) -> DagImportResult:\n+        \"\"\"Import DAGs from a file.\"\"\"\n+\n+    def can_handle(self, file_path: str | Path) -> bool:\n+        \"\"\"Check if this importer can handle the given file.\"\"\"\n+        path = Path(file_path) if isinstance(file_path, str) else file_path\n+        return path.suffix.lower() in self.supported_extensions()\n+\n+    def get_relative_path(self, file_path: str | Path, bundle_path: Path | None) -> str:\n+        \"\"\"Get the relative file path from the bundle root.\"\"\"\n+        if bundle_path is None:\n+            return str(file_path)\n+        try:\n+            return str(Path(file_path).relative_to(bundle_path))\n+        except ValueError:\n+            return str(file_path)\n+\n+\n+class DagImporterRegistry:\n+    \"\"\"Registry for DAG importers. Singleton that manages importers by file extension.\"\"\"\n+\n+    _instance: DagImporterRegistry | None = None\n+    _importers: dict[str, AbstractDagImporter]\n+\n+    def __new__(cls) -> DagImporterRegistry:\n+        if cls._instance is None:\n+            cls._instance = super().__new__(cls)\n+            cls._instance._importers = {}\n+            cls._instance._register_default_importers()\n+        return cls._instance\n+\n+    def _register_default_importers(self) -> None:\n+        from airflow.dag_processing.importers.python_importer import PythonDagImporter\n+\n+        self.register(PythonDagImporter())\n+\n+    def register(self, importer: AbstractDagImporter) -> None:\n+        \"\"\"Register an importer for its supported extensions.\"\"\"\n+        for ext in importer.supported_extensions():\n+            self._importers[ext.lower()] = importer",
      "comment": "Just added warning on override: When registering an importer for an extension that's already claimed, we now log a warning: \"Extension '.zip' already registered by PythonDagImporter, overriding with YamlImporter\"\r\n\r\nand documented the limitation in `PythonDagImporter`'s docstring to explain that `.zip` is exclusively owned by it, and notes that handling other formats inside ZIP would require extending this importer or creating a composite importer. Although I do not want to advertise this as a feature until AIP-85 is done anyway :) \r\n\r\nFor now, I think the single-importer-per-extension model is simpler and sufficient. If we need multi-importer support for ZIP archives in the future, we could add a delegation mechanism where `PythonDagImporter` inspects the ZIP contents and delegates to other importers. ",
      "comment_id": 2662421646,
      "user": "kaxil",
      "created_at": "2026-01-05T18:24:39Z",
      "url": "https://github.com/apache/airflow/pull/60127#discussion_r2662421646"
    },
    {
      "repo": "apache/airflow",
      "pr_number": 60127,
      "file_path": "airflow-core/src/airflow/dag_processing/importers/base.py",
      "line": 143,
      "side": "RIGHT",
      "diff_hunk": "@@ -0,0 +1,163 @@\n+# Licensed to the Apache Software Foundation (ASF) under one\n+# or more contributor license agreements.  See the NOTICE file\n+# distributed with this work for additional information\n+# regarding copyright ownership.  The ASF licenses this file\n+# to you under the Apache License, Version 2.0 (the\n+# \"License\"); you may not use this file except in compliance\n+# with the License.  You may obtain a copy of the License at\n+#\n+#   http://www.apache.org/licenses/LICENSE-2.0\n+#\n+# Unless required by applicable law or agreed to in writing,\n+# software distributed under the License is distributed on an\n+# \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+# KIND, either express or implied.  See the License for the\n+# specific language governing permissions and limitations\n+# under the License.\n+\"\"\"Abstract base class for DAG importers.\"\"\"\n+\n+from __future__ import annotations\n+\n+from abc import ABC, abstractmethod\n+from dataclasses import dataclass, field\n+from pathlib import Path\n+from typing import TYPE_CHECKING\n+\n+if TYPE_CHECKING:\n+    from airflow.sdk import DAG\n+\n+\n+@dataclass\n+class DagImportError:\n+    \"\"\"Structured error information for DAG import failures.\"\"\"\n+\n+    file_path: str\n+    message: str\n+    error_type: str = \"import\"\n+    line_number: int | None = None\n+    column_number: int | None = None\n+    context: str | None = None\n+    suggestion: str | None = None\n+    stacktrace: str | None = None\n+\n+    def format_message(self) -> str:\n+        \"\"\"Format the error as a human-readable string.\"\"\"\n+        parts = [f\"Error in {self.file_path}\"]\n+        if self.line_number is not None:\n+            loc = f\"line {self.line_number}\"\n+            if self.column_number is not None:\n+                loc += f\", column {self.column_number}\"\n+            parts.append(f\"Location: {loc}\")\n+        parts.append(f\"Error ({self.error_type}): {self.message}\")\n+        if self.context:\n+            parts.append(f\"Context:\\n{self.context}\")\n+        if self.suggestion:\n+            parts.append(f\"Suggestion: {self.suggestion}\")\n+        return \"\\n\".join(parts)\n+\n+\n+@dataclass\n+class DagImportWarning:\n+    \"\"\"Warning information for non-fatal issues during DAG import.\"\"\"\n+\n+    file_path: str\n+    message: str\n+    warning_type: str = \"general\"\n+    line_number: int | None = None\n+\n+\n+@dataclass\n+class DagImportResult:\n+    \"\"\"Result of importing DAGs from a file.\"\"\"\n+\n+    file_path: str\n+    dags: list[DAG] = field(default_factory=list)\n+    errors: list[DagImportError] = field(default_factory=list)\n+    skipped_files: list[str] = field(default_factory=list)\n+    warnings: list[DagImportWarning] = field(default_factory=list)\n+\n+    @property\n+    def success(self) -> bool:\n+        \"\"\"Return True if no fatal errors occurred.\"\"\"\n+        return len(self.errors) == 0\n+\n+\n+class AbstractDagImporter(ABC):\n+    \"\"\"Abstract base class for DAG importers.\"\"\"\n+\n+    @classmethod\n+    @abstractmethod\n+    def supported_extensions(cls) -> list[str]:\n+        \"\"\"Return file extensions this importer handles (e.g., ['.py', '.zip']).\"\"\"\n+\n+    @abstractmethod\n+    def import_file(\n+        self,\n+        file_path: str | Path,\n+        *,\n+        bundle_path: Path | None = None,\n+        bundle_name: str | None = None,\n+        safe_mode: bool = True,\n+    ) -> DagImportResult:\n+        \"\"\"Import DAGs from a file.\"\"\"\n+\n+    def can_handle(self, file_path: str | Path) -> bool:\n+        \"\"\"Check if this importer can handle the given file.\"\"\"\n+        path = Path(file_path) if isinstance(file_path, str) else file_path\n+        return path.suffix.lower() in self.supported_extensions()\n+\n+    def get_relative_path(self, file_path: str | Path, bundle_path: Path | None) -> str:\n+        \"\"\"Get the relative file path from the bundle root.\"\"\"\n+        if bundle_path is None:\n+            return str(file_path)\n+        try:\n+            return str(Path(file_path).relative_to(bundle_path))\n+        except ValueError:\n+            return str(file_path)\n+\n+\n+class DagImporterRegistry:\n+    \"\"\"Registry for DAG importers. Singleton that manages importers by file extension.\"\"\"\n+\n+    _instance: DagImporterRegistry | None = None\n+    _importers: dict[str, AbstractDagImporter]\n+\n+    def __new__(cls) -> DagImporterRegistry:\n+        if cls._instance is None:\n+            cls._instance = super().__new__(cls)\n+            cls._instance._importers = {}\n+            cls._instance._register_default_importers()\n+        return cls._instance\n+\n+    def _register_default_importers(self) -> None:\n+        from airflow.dag_processing.importers.python_importer import PythonDagImporter\n+\n+        self.register(PythonDagImporter())\n+\n+    def register(self, importer: AbstractDagImporter) -> None:\n+        \"\"\"Register an importer for its supported extensions.\"\"\"\n+        for ext in importer.supported_extensions():\n+            self._importers[ext.lower()] = importer",
      "comment": ">One deviation from AIP-85 is that filepaths are still handled by DagBag (and list_py_file_paths only lists py/zip paths). Do we have a definitive plan on how we want to handle it? Should it be handled by importer (somewhat makes sense, as it knows what extensions to look for) as was proposed in AIP-85 as well or by something else?\r\n\r\nAlso migrated file discovery to the importer layer too",
      "comment_id": 2662423612,
      "user": "kaxil",
      "created_at": "2026-01-05T18:25:28Z",
      "url": "https://github.com/apache/airflow/pull/60127#discussion_r2662423612"
    },
    {
      "repo": "apache/airflow",
      "pr_number": 60127,
      "file_path": "airflow-core/src/airflow/dag_processing/importers/base.py",
      "line": 173,
      "side": "RIGHT",
      "diff_hunk": "@@ -0,0 +1,266 @@\n+# Licensed to the Apache Software Foundation (ASF) under one\n+# or more contributor license agreements.  See the NOTICE file\n+# distributed with this work for additional information\n+# regarding copyright ownership.  The ASF licenses this file\n+# to you under the Apache License, Version 2.0 (the\n+# \"License\"); you may not use this file except in compliance\n+# with the License.  You may obtain a copy of the License at\n+#\n+#   http://www.apache.org/licenses/LICENSE-2.0\n+#\n+# Unless required by applicable law or agreed to in writing,\n+# software distributed under the License is distributed on an\n+# \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+# KIND, either express or implied.  See the License for the\n+# specific language governing permissions and limitations\n+# under the License.\n+\"\"\"Abstract base class for DAG importers.\"\"\"\n+\n+from __future__ import annotations\n+\n+import logging\n+import os\n+import threading\n+from abc import ABC, abstractmethod\n+from collections.abc import Iterator\n+from dataclasses import dataclass, field\n+from pathlib import Path\n+from typing import TYPE_CHECKING\n+\n+if TYPE_CHECKING:\n+    from airflow.sdk import DAG\n+\n+log = logging.getLogger(__name__)\n+\n+\n+@dataclass\n+class DagImportError:\n+    \"\"\"Structured error information for DAG import failures.\"\"\"\n+\n+    file_path: str\n+    message: str\n+    error_type: str = \"import\"\n+    line_number: int | None = None\n+    column_number: int | None = None\n+    context: str | None = None\n+    suggestion: str | None = None\n+    stacktrace: str | None = None\n+\n+    def format_message(self) -> str:\n+        \"\"\"Format the error as a human-readable string.\"\"\"\n+        parts = [f\"Error in {self.file_path}\"]\n+        if self.line_number is not None:\n+            loc = f\"line {self.line_number}\"\n+            if self.column_number is not None:\n+                loc += f\", column {self.column_number}\"\n+            parts.append(f\"Location: {loc}\")\n+        parts.append(f\"Error ({self.error_type}): {self.message}\")\n+        if self.context:\n+            parts.append(f\"Context:\\n{self.context}\")\n+        if self.suggestion:\n+            parts.append(f\"Suggestion: {self.suggestion}\")\n+        return \"\\n\".join(parts)\n+\n+\n+@dataclass\n+class DagImportWarning:\n+    \"\"\"Warning information for non-fatal issues during DAG import.\"\"\"\n+\n+    file_path: str\n+    message: str\n+    warning_type: str = \"general\"\n+    line_number: int | None = None\n+\n+\n+@dataclass\n+class DagImportResult:\n+    \"\"\"Result of importing DAGs from a file.\"\"\"\n+\n+    file_path: str\n+    dags: list[DAG] = field(default_factory=list)\n+    errors: list[DagImportError] = field(default_factory=list)\n+    skipped_files: list[str] = field(default_factory=list)\n+    warnings: list[DagImportWarning] = field(default_factory=list)\n+\n+    @property\n+    def success(self) -> bool:\n+        \"\"\"Return True if no fatal errors occurred.\"\"\"\n+        return len(self.errors) == 0\n+\n+\n+class AbstractDagImporter(ABC):\n+    \"\"\"Abstract base class for DAG importers.\"\"\"\n+\n+    @classmethod\n+    @abstractmethod\n+    def supported_extensions(cls) -> list[str]:\n+        \"\"\"Return file extensions this importer handles (e.g., ['.py', '.zip']).\"\"\"\n+\n+    @abstractmethod\n+    def import_file(\n+        self,\n+        file_path: str | Path,\n+        *,\n+        bundle_path: Path | None = None,\n+        bundle_name: str | None = None,\n+        safe_mode: bool = True,\n+    ) -> DagImportResult:\n+        \"\"\"Import DAGs from a file.\"\"\"\n+\n+    def can_handle(self, file_path: str | Path) -> bool:\n+        \"\"\"Check if this importer can handle the given file.\"\"\"\n+        path = Path(file_path) if isinstance(file_path, str) else file_path\n+        return path.suffix.lower() in self.supported_extensions()\n+\n+    def get_relative_path(self, file_path: str | Path, bundle_path: Path | None) -> str:\n+        \"\"\"Get the relative file path from the bundle root.\"\"\"\n+        if bundle_path is None:\n+            return str(file_path)\n+        try:\n+            return str(Path(file_path).relative_to(bundle_path))\n+        except ValueError:\n+            return str(file_path)\n+\n+    def list_dag_files(\n+        self,\n+        directory: str | os.PathLike[str],\n+        safe_mode: bool = True,\n+    ) -> Iterator[str]:\n+        \"\"\"\n+        List DAG files in a directory that this importer can handle.\n+\n+        Override this method to customize file discovery for your importer.\n+        The default implementation finds files matching supported_extensions()\n+        and respects .airflowignore files.\n+\n+        :param directory: Directory to search for DAG files\n+        :param safe_mode: Whether to use heuristics to filter non-DAG files\n+        :return: Iterator of file paths\n+        \"\"\"\n+        from airflow._shared.module_loading.file_discovery import find_path_from_directory\n+        from airflow.configuration import conf\n+        from airflow.utils.file import might_contain_dag\n+\n+        ignore_file_syntax = conf.get_mandatory_value(\"core\", \"DAG_IGNORE_FILE_SYNTAX\", fallback=\"glob\")\n+        supported_exts = [ext.lower() for ext in self.supported_extensions()]\n+\n+        for file_path in find_path_from_directory(directory, \".airflowignore\", ignore_file_syntax):\n+            path = Path(file_path)\n+\n+            if not path.is_file():\n+                continue\n+\n+            # Check if this importer handles this file extension\n+            if path.suffix.lower() not in supported_exts:\n+                continue\n+\n+            # Apply safe_mode heuristic if enabled\n+            if safe_mode and not might_contain_dag(file_path, safe_mode):\n+                continue\n+\n+            yield file_path\n+\n+\n+class DagImporterRegistry:\n+    \"\"\"\n+    Registry for DAG importers. Singleton that manages importers by file extension.\n+\n+    Each file extension can only be handled by one importer at a time. If multiple\n+    importers claim the same extension, the last registered one wins and a warning\n+    is logged. The built-in PythonDagImporter handles .py and .zip extensions.\n+    \"\"\"\n+\n+    _instance: DagImporterRegistry | None = None",
      "comment": "Class variable `_instance` should be defined inside `__init__` or have a proper type annotation at class level. Current placement after the docstring but before `__new__` is unconventional. Consider moving it to be the first class variable or initializing it properly in `__new__`.",
      "comment_id": 2662429068,
      "user": "Copilot",
      "created_at": "2026-01-05T18:27:44Z",
      "url": "https://github.com/apache/airflow/pull/60127#discussion_r2662429068"
    },
    {
      "repo": "apache/airflow",
      "pr_number": 60127,
      "file_path": "airflow-core/src/airflow/dag_processing/dagbag.py",
      "line": 391,
      "side": "RIGHT",
      "diff_hunk": "@@ -403,187 +367,29 @@ def _get_relative_fileloc(self, filepath: str) -> str:\n             return str(Path(filepath).relative_to(self.bundle_path))\n         return filepath\n \n-    def _load_modules_from_file(self, filepath, safe_mode):\n-        from airflow.sdk.definitions._internal.contextmanager import DagContext\n-\n-        def handler(signum, frame):\n-            \"\"\"Handle SIGSEGV signal and let the user know that the import failed.\"\"\"\n-            msg = f\"Received SIGSEGV signal while processing {filepath}.\"\n-            self.log.error(msg)\n-            relative_filepath = self._get_relative_fileloc(filepath)\n-            self.import_errors[relative_filepath] = msg\n-\n-        try:\n-            signal.signal(signal.SIGSEGV, handler)\n-        except ValueError:\n-            self.log.warning(\"SIGSEGV signal handler registration failed. Not in the main thread\")\n-\n-        if not might_contain_dag(filepath, safe_mode):\n-            # Don't want to spam user with skip messages\n-            if not self.has_logged:\n-                self.has_logged = True\n-                self.log.info(\"File %s assumed to contain no DAGs. Skipping.\", filepath)\n-            return []\n-\n-        self.log.debug(\"Importing %s\", filepath)\n-        mod_name = get_unique_dag_module_name(filepath)\n-\n-        if mod_name in sys.modules:\n-            del sys.modules[mod_name]\n-\n-        DagContext.current_autoregister_module_name = mod_name\n-\n-        def parse(mod_name, filepath):\n-            try:\n-                loader = importlib.machinery.SourceFileLoader(mod_name, filepath)\n-                spec = importlib.util.spec_from_loader(mod_name, loader)\n-                new_module = importlib.util.module_from_spec(spec)\n-                sys.modules[spec.name] = new_module\n-                loader.exec_module(new_module)\n-                return [new_module]\n-            except KeyboardInterrupt:\n-                # re-raise ctrl-c\n-                raise\n-            except BaseException as e:\n-                # Normally you shouldn't catch BaseException, but in this case we want to, as, pytest.skip\n-                # raises an exception which does not inherit from Exception, and we want to catch that here.\n-                # This would also catch `exit()` in a dag file\n-                DagContext.autoregistered_dags.clear()\n-                self.log.exception(\"Failed to import: %s\", filepath)\n-                relative_filepath = self._get_relative_fileloc(filepath)\n-                if self.dagbag_import_error_tracebacks:\n-                    self.import_errors[relative_filepath] = traceback.format_exc(\n-                        limit=-self.dagbag_import_error_traceback_depth\n-                    )\n-                else:\n-                    self.import_errors[relative_filepath] = str(e)\n-                return []\n-\n-        dagbag_import_timeout = settings.get_dagbag_import_timeout(filepath)\n-\n-        if not isinstance(dagbag_import_timeout, (int, float)):\n-            raise TypeError(\n-                f\"Value ({dagbag_import_timeout}) from get_dagbag_import_timeout must be int or float\"\n-            )\n-\n-        if dagbag_import_timeout <= 0:  # no parsing timeout\n-            return parse(mod_name, filepath)\n-\n-        timeout_msg = (\n-            f\"DagBag import timeout for {filepath} after {dagbag_import_timeout}s.\\n\"\n-            \"Please take a look at these docs to improve your DAG import time:\\n\"\n-            f\"* {get_docs_url('best-practices.html#top-level-python-code')}\\n\"\n-            f\"* {get_docs_url('best-practices.html#reducing-dag-complexity')}\"\n-        )\n-        with timeout(dagbag_import_timeout, error_message=timeout_msg):\n-            return parse(mod_name, filepath)\n-\n-    def _load_modules_from_zip(self, filepath, safe_mode):\n-        from airflow.sdk.definitions._internal.contextmanager import DagContext\n-\n-        mods = []\n-        with zipfile.ZipFile(filepath) as current_zip_file:\n-            for zip_info in current_zip_file.infolist():\n-                zip_path = Path(zip_info.filename)\n-                if zip_path.suffix not in [\".py\", \".pyc\"] or len(zip_path.parts) > 1:\n-                    continue\n-\n-                if zip_path.stem == \"__init__\":\n-                    self.log.warning(\"Found %s at root of %s\", zip_path.name, filepath)\n-\n-                self.log.debug(\"Reading %s from %s\", zip_info.filename, filepath)\n-\n-                if not might_contain_dag(zip_info.filename, safe_mode, current_zip_file):\n-                    # todo: create ignore list\n-                    # Don't want to spam user with skip messages\n-                    if not self.has_logged:\n-                        self.has_logged = True\n-                        self.log.info(\n-                            \"File %s:%s assumed to contain no DAGs. Skipping.\", filepath, zip_info.filename\n-                        )\n-                    continue\n-\n-                mod_name = zip_path.stem\n-                if mod_name in sys.modules:\n-                    del sys.modules[mod_name]\n-\n-                DagContext.current_autoregister_module_name = mod_name\n-                try:\n-                    sys.path.insert(0, filepath)\n-                    current_module = importlib.import_module(mod_name)\n-                    mods.append(current_module)\n-                except Exception as e:\n-                    DagContext.autoregistered_dags.clear()\n-                    fileloc = os.path.join(filepath, zip_info.filename)\n-                    self.log.exception(\"Failed to import: %s\", fileloc)\n-                    relative_fileloc = self._get_relative_fileloc(fileloc)\n-                    if self.dagbag_import_error_tracebacks:\n-                        self.import_errors[relative_fileloc] = traceback.format_exc(\n-                            limit=-self.dagbag_import_error_traceback_depth\n-                        )\n-                    else:\n-                        self.import_errors[relative_fileloc] = str(e)\n-                finally:\n-                    if sys.path[0] == filepath:\n-                        del sys.path[0]\n-        return mods\n-\n-    def _process_modules(self, filepath, mods, file_last_changed_on_disk):\n-        from airflow.sdk import DAG\n-        from airflow.sdk.definitions._internal.contextmanager import DagContext\n-\n-        top_level_dags = {(o, m) for m in mods for o in m.__dict__.values() if isinstance(o, DAG)}\n-\n-        top_level_dags.update(DagContext.autoregistered_dags)\n-\n-        DagContext.current_autoregister_module_name = None\n-        DagContext.autoregistered_dags.clear()\n-\n-        found_dags = []\n-\n-        for dag, mod in top_level_dags:\n-            dag.fileloc = mod.__file__\n-            relative_fileloc = self._get_relative_fileloc(dag.fileloc)\n-            dag.relative_fileloc = relative_fileloc\n-            try:\n-                dag.validate()\n-                _validate_executor_fields(dag, self.bundle_name)\n-                self.bag_dag(dag=dag)\n-            except AirflowClusterPolicySkipDag:\n-                pass\n-            except Exception as e:\n-                self.log.exception(\"Failed to bag_dag: %s\", dag.fileloc)\n-                self.import_errors[relative_fileloc] = f\"{type(e).__name__}: {e}\"\n-                self.file_last_changed[dag.fileloc] = file_last_changed_on_disk\n-            else:\n-                found_dags.append(dag)\n-        return found_dags\n-\n     def bag_dag(self, dag: DAG):\n         \"\"\"\n         Add the DAG into the bag.\n \n         :raises: AirflowDagCycleException if a cycle is detected.\n         :raises: AirflowDagDuplicatedIdException if this dag already exists in the bag.\n         \"\"\"\n-        dag.check_cycle()  # throws exception if a task cycle is found\n-\n+        dag.validate()\n+        dag.check_cycle()\n         dag.resolve_template_files()\n         dag.last_loaded = timezone.utcnow()\n \n+        _validate_executor_fields(dag, self.bundle_name)\n+\n         try:\n-            # Check policies\n             settings.dag_policy(dag)\n \n             for task in dag.tasks:\n-                # The listeners are not supported when ending a task via a trigger on asynchronous operators.\n                 if getattr(task, \"end_from_trigger\", False) and get_listener_manager().has_listeners:\n-                    raise AirflowException(\n-                        \"Listeners are not supported with end_from_trigger=True for deferrable operators. \"\n-                        \"Task %s in DAG %s has end_from_trigger=True with listeners from plugins. \"\n-                        \"Set end_from_trigger=False to use listeners.\",\n-                        task.task_id,\n-                        dag.dag_id,\n+                    raise AirflowClusterPolicyViolation(\n+                        f\"Listeners are not supported with end_from_trigger=True for deferrable operators. \"\n+                        f\"Task {task.task_id} in DAG {dag.dag_id} has end_from_trigger=True with listeners from plugins. \"\n+                        \"Set end_from_trigger=False to use listeners.\"",
      "comment": "Changed exception type from `AirflowException` to `AirflowClusterPolicyViolation`, but this error is not related to cluster policy - it's about an incompatible feature combination (listeners + end_from_trigger). This should remain as `AirflowException` or use a more appropriate exception type.",
      "comment_id": 2662429079,
      "user": "Copilot",
      "created_at": "2026-01-05T18:27:44Z",
      "url": "https://github.com/apache/airflow/pull/60127#discussion_r2662429079"
    },
    {
      "repo": "apache/airflow",
      "pr_number": 60127,
      "file_path": "airflow-core/tests/unit/dag_processing/test_dagbag.py",
      "line": 842,
      "side": "RIGHT",
      "diff_hunk": "@@ -842,41 +831,27 @@ def test_timeout_dag_errors_are_import_errors(self, tmp_path, caplog):\n         \"\"\"\n         Test that if the DAG contains Timeout error it will be still loaded to DB as import_errors\n         \"\"\"\n-        code_to_save = \"\"\"\n-# Define Dag to load\n+        dag_file = tmp_path / \"timeout_dag.py\"\n+        dag_file.write_text(\"\"\"\n import datetime\n import time\n \n import airflow\n from airflow.providers.standard.operators.python import PythonOperator\n \n-time.sleep(1)\n+time.sleep(1)  # This will cause timeout during import",
      "comment": "Comment incorrectly states this will cause timeout during import, but the actual timeout is configured as 0.01 seconds (line 851) while the sleep is 1 second. The comment should reflect that this sleep exceeds the configured timeout threshold.\n```suggestion\ntime.sleep(1)  # This sleep exceeds the configured DAGBAG_IMPORT_TIMEOUT during import\n```",
      "comment_id": 2662429101,
      "user": "Copilot",
      "created_at": "2026-01-05T18:27:45Z",
      "url": "https://github.com/apache/airflow/pull/60127#discussion_r2662429101"
    },
    {
      "repo": "apache/airflow",
      "pr_number": 60127,
      "file_path": "airflow-core/src/airflow/dag_processing/importers/python_importer.py",
      "line": 157,
      "side": "RIGHT",
      "diff_hunk": "@@ -0,0 +1,376 @@\n+# Licensed to the Apache Software Foundation (ASF) under one\n+# or more contributor license agreements.  See the NOTICE file\n+# distributed with this work for additional information\n+# regarding copyright ownership.  The ASF licenses this file\n+# to you under the Apache License, Version 2.0 (the\n+# \"License\"); you may not use this file except in compliance\n+# with the License.  You may obtain a copy of the License at\n+#\n+#   http://www.apache.org/licenses/LICENSE-2.0\n+#\n+# Unless required by applicable law or agreed to in writing,\n+# software distributed under the License is distributed on an\n+# \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+# KIND, either express or implied.  See the License for the\n+# specific language governing permissions and limitations\n+# under the License.\n+\"\"\"Python DAG importer - imports DAGs from Python files.\"\"\"\n+\n+from __future__ import annotations\n+\n+import contextlib\n+import importlib\n+import importlib.machinery\n+import importlib.util\n+import logging\n+import os\n+import signal\n+import sys\n+import traceback\n+import warnings\n+import zipfile\n+from collections.abc import Iterator\n+from pathlib import Path\n+from typing import TYPE_CHECKING, Any\n+\n+from airflow import settings\n+from airflow.configuration import conf\n+from airflow.dag_processing.importers.base import (\n+    AbstractDagImporter,\n+    DagImportError,\n+    DagImportResult,\n+    DagImportWarning,\n+)\n+from airflow.utils.docs import get_docs_url\n+from airflow.utils.file import get_unique_dag_module_name, might_contain_dag\n+\n+if TYPE_CHECKING:\n+    from types import ModuleType\n+\n+    from airflow.sdk import DAG\n+\n+log = logging.getLogger(__name__)\n+\n+\n+@contextlib.contextmanager\n+def _timeout(seconds: float = 1, error_message: str = \"Timeout\"):\n+    \"\"\"Context manager for timing out operations.\"\"\"\n+    error_message = error_message + \", PID: \" + str(os.getpid())\n+\n+    def handle_timeout(signum, frame):\n+        log.error(\"Process timed out, PID: %s\", str(os.getpid()))\n+        from airflow.sdk.exceptions import AirflowTaskTimeout\n+\n+        raise AirflowTaskTimeout(error_message)\n+\n+    try:\n+        try:\n+            signal.signal(signal.SIGALRM, handle_timeout)\n+            signal.setitimer(signal.ITIMER_REAL, seconds)\n+        except ValueError:\n+            log.warning(\"timeout can't be used in the current context\", exc_info=True)\n+        yield\n+    finally:\n+        with contextlib.suppress(ValueError):\n+            signal.setitimer(signal.ITIMER_REAL, 0)\n+\n+\n+class PythonDagImporter(AbstractDagImporter):\n+    \"\"\"\n+    Importer for Python DAG files and zip archives containing Python DAGs.\n+\n+    This is the default importer registered with the DagImporterRegistry. It handles:\n+    - .py files: Standard Python DAG files\n+    - .zip files: ZIP archives containing Python DAG files\n+\n+    Note: The .zip extension is exclusively owned by this importer. If you need to\n+    support other file formats inside ZIP archives (e.g., YAML), you would need to\n+    either extend this importer or create a composite importer that delegates based\n+    on the contents of the archive.\n+    \"\"\"\n+\n+    @classmethod\n+    def supported_extensions(cls) -> list[str]:\n+        \"\"\"Return file extensions handled by this importer (.py and .zip).\"\"\"\n+        return [\".py\", \".zip\"]\n+\n+    def list_dag_files(\n+        self,\n+        directory: str | os.PathLike[str],\n+        safe_mode: bool = True,\n+    ) -> Iterator[str]:\n+        \"\"\"\n+        List Python DAG files in a directory.\n+\n+        Handles both .py files and .zip archives containing Python DAGs.\n+        Respects .airflowignore files in the directory tree.\n+        \"\"\"\n+        from airflow._shared.module_loading.file_discovery import find_path_from_directory\n+        from airflow.utils.file import might_contain_dag\n+\n+        ignore_file_syntax = conf.get_mandatory_value(\"core\", \"DAG_IGNORE_FILE_SYNTAX\", fallback=\"glob\")\n+\n+        for file_path in find_path_from_directory(directory, \".airflowignore\", ignore_file_syntax):\n+            path = Path(file_path)\n+            try:\n+                if path.is_file() and (path.suffix.lower() == \".py\" or zipfile.is_zipfile(path)):\n+                    if might_contain_dag(file_path, safe_mode):\n+                        yield file_path\n+            except Exception:\n+                log.exception(\"Error while examining %s\", file_path)\n+\n+    def import_file(\n+        self,\n+        file_path: str | Path,\n+        *,\n+        bundle_path: Path | None = None,\n+        bundle_name: str | None = None,\n+        safe_mode: bool = True,\n+    ) -> DagImportResult:\n+        \"\"\"\n+        Import DAGs from a Python file or zip archive.\n+\n+        :param file_path: Path to the Python file to import.\n+        :param bundle_path: Path to the bundle root.\n+        :param bundle_name: Name of the bundle.\n+        :param safe_mode: If True, skip files that don't appear to contain DAGs.\n+        :return: DagImportResult with imported DAGs and any errors.\n+        \"\"\"\n+        from airflow.sdk.definitions._internal.contextmanager import DagContext\n+\n+        filepath = str(file_path)\n+        relative_path = self.get_relative_path(filepath, bundle_path)\n+        result = DagImportResult(file_path=relative_path)\n+\n+        if not os.path.isfile(filepath):\n+            result.errors.append(\n+                DagImportError(\n+                    file_path=relative_path,\n+                    message=f\"File not found: {filepath}\",\n+                    error_type=\"file_not_found\",\n+                )\n+            )\n+            return result\n+\n+        # Clear any autoregistered dags from previous imports\n+        DagContext.autoregistered_dags.clear()\n+\n+        # Capture warnings during import\n+        captured_warnings: list[warnings.WarningMessage] = []",
      "comment": "The variable `captured_warnings` is initialized as an empty list but then immediately reassigned in the context manager. The initial assignment on line 159 is unnecessary and could be confusing. Remove the initialization and rely on the context manager assignment.\n```suggestion\n\n```",
      "comment_id": 2662429120,
      "user": "Copilot",
      "created_at": "2026-01-05T18:27:45Z",
      "url": "https://github.com/apache/airflow/pull/60127#discussion_r2662429120"
    },
    {
      "repo": "apache/airflow",
      "pr_number": 60127,
      "file_path": "airflow-core/tests/unit/dag_processing/test_dagbag.py",
      "line": 449,
      "side": "RIGHT",
      "diff_hunk": "@@ -452,7 +441,7 @@ def test_process_file_that_contains_multi_bytes_char(self, tmp_path):\n         \"\"\"\n         test that we're able to parse file that contains multi-byte char\n         \"\"\"\n-        path = tmp_path / \"testfile\"\n+        path = tmp_path / \"testfile.py\"",
      "comment": "Does this mean that files without explicit py extension won't be parsed? Maybe those files should be assumed to be python files and parsed with python importer?",
      "comment_id": 2668795193,
      "user": "ephraimbuddy",
      "created_at": "2026-01-07T14:56:28Z",
      "url": "https://github.com/apache/airflow/pull/60127#discussion_r2668795193"
    },
    {
      "repo": "apache/airflow",
      "pr_number": 60127,
      "file_path": "airflow-core/src/airflow/dag_processing/importers/python_importer.py",
      "line": 323,
      "side": "RIGHT",
      "diff_hunk": "@@ -0,0 +1,360 @@\n+# Licensed to the Apache Software Foundation (ASF) under one\n+# or more contributor license agreements.  See the NOTICE file\n+# distributed with this work for additional information\n+# regarding copyright ownership.  The ASF licenses this file\n+# to you under the Apache License, Version 2.0 (the\n+# \"License\"); you may not use this file except in compliance\n+# with the License.  You may obtain a copy of the License at\n+#\n+#   http://www.apache.org/licenses/LICENSE-2.0\n+#\n+# Unless required by applicable law or agreed to in writing,\n+# software distributed under the License is distributed on an\n+# \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+# KIND, either express or implied.  See the License for the\n+# specific language governing permissions and limitations\n+# under the License.\n+\"\"\"Python DAG importer - imports DAGs from Python files.\"\"\"\n+\n+from __future__ import annotations\n+\n+import contextlib\n+import importlib\n+import importlib.machinery\n+import importlib.util\n+import logging\n+import os\n+import signal\n+import sys\n+import traceback\n+import warnings\n+import zipfile\n+from collections.abc import Iterator\n+from pathlib import Path\n+from typing import TYPE_CHECKING, Any\n+\n+from airflow import settings\n+from airflow._shared.module_loading.file_discovery import find_path_from_directory\n+from airflow.configuration import conf\n+from airflow.dag_processing.importers.base import (\n+    AbstractDagImporter,\n+    DagImportError,\n+    DagImportResult,\n+    DagImportWarning,\n+)\n+from airflow.utils.docs import get_docs_url\n+from airflow.utils.file import get_unique_dag_module_name, might_contain_dag\n+\n+if TYPE_CHECKING:\n+    from types import ModuleType\n+\n+    from airflow.sdk import DAG\n+\n+log = logging.getLogger(__name__)\n+\n+\n+@contextlib.contextmanager\n+def _timeout(seconds: float = 1, error_message: str = \"Timeout\"):\n+    \"\"\"Context manager for timing out operations.\"\"\"\n+    error_message = error_message + \", PID: \" + str(os.getpid())\n+\n+    def handle_timeout(signum, frame):\n+        log.error(\"Process timed out, PID: %s\", str(os.getpid()))\n+        from airflow.sdk.exceptions import AirflowTaskTimeout\n+\n+        raise AirflowTaskTimeout(error_message)\n+\n+    try:\n+        try:\n+            signal.signal(signal.SIGALRM, handle_timeout)\n+            signal.setitimer(signal.ITIMER_REAL, seconds)\n+        except ValueError:\n+            log.warning(\"timeout can't be used in the current context\", exc_info=True)\n+        yield\n+    finally:\n+        with contextlib.suppress(ValueError):\n+            signal.setitimer(signal.ITIMER_REAL, 0)\n+\n+\n+class PythonDagImporter(AbstractDagImporter):\n+    \"\"\"\n+    Importer for Python DAG files and zip archives containing Python DAGs.\n+\n+    This is the default importer registered with the DagImporterRegistry. It handles:\n+    - .py files: Standard Python DAG files\n+    - .zip files: ZIP archives containing Python DAG files\n+\n+    Note: The .zip extension is exclusively owned by this importer. If you need to\n+    support other file formats inside ZIP archives (e.g., YAML), you would need to\n+    either extend this importer or create a composite importer that delegates based\n+    on the contents of the archive.\n+    \"\"\"\n+\n+    @classmethod\n+    def supported_extensions(cls) -> list[str]:\n+        \"\"\"Return file extensions handled by this importer (.py and .zip).\"\"\"\n+        return [\".py\", \".zip\"]\n+\n+    def list_dag_files(\n+        self,\n+        directory: str | os.PathLike[str],\n+        safe_mode: bool = True,\n+    ) -> Iterator[str]:\n+        \"\"\"\n+        List Python DAG files in a directory.\n+\n+        Handles both .py files and .zip archives containing Python DAGs.\n+        Respects .airflowignore files in the directory tree.\n+        \"\"\"\n+        ignore_file_syntax = conf.get_mandatory_value(\"core\", \"DAG_IGNORE_FILE_SYNTAX\", fallback=\"glob\")\n+\n+        for file_path in find_path_from_directory(directory, \".airflowignore\", ignore_file_syntax):\n+            path = Path(file_path)\n+            try:\n+                if path.is_file() and (path.suffix.lower() == \".py\" or zipfile.is_zipfile(path)):\n+                    if might_contain_dag(file_path, safe_mode):\n+                        yield file_path\n+            except Exception:\n+                log.exception(\"Error while examining %s\", file_path)\n+\n+    def import_file(\n+        self,\n+        file_path: str | Path,\n+        *,\n+        bundle_path: Path | None = None,\n+        bundle_name: str | None = None,\n+        safe_mode: bool = True,\n+    ) -> DagImportResult:\n+        \"\"\"\n+        Import DAGs from a Python file or zip archive.\n+\n+        :param file_path: Path to the Python file to import.\n+        :param bundle_path: Path to the bundle root.\n+        :param bundle_name: Name of the bundle.\n+        :param safe_mode: If True, skip files that don't appear to contain DAGs.\n+        :return: DagImportResult with imported DAGs and any errors.\n+        \"\"\"\n+        from airflow.sdk.definitions._internal.contextmanager import DagContext\n+\n+        filepath = str(file_path)\n+        relative_path = self.get_relative_path(filepath, bundle_path)\n+        result = DagImportResult(file_path=relative_path)\n+\n+        if not os.path.isfile(filepath):\n+            result.errors.append(\n+                DagImportError(\n+                    file_path=relative_path,\n+                    message=f\"File not found: {filepath}\",\n+                    error_type=\"file_not_found\",\n+                )\n+            )\n+            return result\n+\n+        # Clear any autoregistered dags from previous imports\n+        DagContext.autoregistered_dags.clear()\n+\n+        # Capture warnings during import\n+        captured_warnings: list[warnings.WarningMessage] = []\n+\n+        try:\n+            with warnings.catch_warnings(record=True) as captured_warnings:\n+                if filepath.endswith(\".py\") or not zipfile.is_zipfile(filepath):\n+                    modules = self._load_modules_from_file(filepath, safe_mode, result)\n+                else:\n+                    modules = self._load_modules_from_zip(filepath, safe_mode, result)\n+        except TypeError:\n+            # Configuration errors (e.g., invalid timeout type) should propagate\n+            raise\n+        except Exception as e:\n+            result.errors.append(\n+                DagImportError(\n+                    file_path=relative_path,\n+                    message=str(e),\n+                    error_type=\"import\",\n+                    stacktrace=traceback.format_exc(),\n+                )\n+            )\n+            return result\n+\n+        # Convert captured warnings to DagImportWarning\n+        for warn_msg in captured_warnings:\n+            category = warn_msg.category.__name__\n+            if (module := warn_msg.category.__module__) != \"builtins\":\n+                category = f\"{module}.{category}\"\n+            result.warnings.append(\n+                DagImportWarning(\n+                    file_path=warn_msg.filename,\n+                    message=str(warn_msg.message),\n+                    warning_type=category,\n+                    line_number=warn_msg.lineno,\n+                )\n+            )\n+\n+        # Process imported modules to extract DAGs\n+        self._process_modules(filepath, modules, bundle_name, bundle_path, result)\n+\n+        return result\n+\n+    def _load_modules_from_file(\n+        self, filepath: str, safe_mode: bool, result: DagImportResult\n+    ) -> list[ModuleType]:\n+        from airflow.sdk.definitions._internal.contextmanager import DagContext\n+\n+        def sigsegv_handler(signum, frame):\n+            msg = f\"Received SIGSEGV signal while processing {filepath}.\"\n+            log.error(msg)\n+            result.errors.append(\n+                DagImportError(\n+                    file_path=result.file_path,\n+                    message=msg,\n+                    error_type=\"segfault\",\n+                )\n+            )\n+\n+        try:\n+            signal.signal(signal.SIGSEGV, sigsegv_handler)\n+        except ValueError:\n+            log.warning(\"SIGSEGV signal handler registration failed. Not in the main thread\")\n+\n+        if not might_contain_dag(filepath, safe_mode):\n+            log.debug(\"File %s assumed to contain no DAGs. Skipping.\", filepath)\n+            result.skipped_files.append(filepath)\n+            return []\n+\n+        log.debug(\"Importing %s\", filepath)\n+        mod_name = get_unique_dag_module_name(filepath)\n+\n+        if mod_name in sys.modules:\n+            del sys.modules[mod_name]\n+\n+        DagContext.current_autoregister_module_name = mod_name\n+\n+        def parse(mod_name: str, filepath: str) -> list[ModuleType]:\n+            try:\n+                loader = importlib.machinery.SourceFileLoader(mod_name, filepath)\n+                spec = importlib.util.spec_from_loader(mod_name, loader)\n+                new_module = importlib.util.module_from_spec(spec)  # type: ignore[arg-type]\n+                sys.modules[spec.name] = new_module  # type: ignore[union-attr]\n+                loader.exec_module(new_module)\n+                return [new_module]\n+            except KeyboardInterrupt:\n+                raise\n+            except BaseException as e:\n+                DagContext.autoregistered_dags.clear()\n+                log.exception(\"Failed to import: %s\", filepath)\n+                if conf.getboolean(\"core\", \"dagbag_import_error_tracebacks\"):\n+                    stacktrace = traceback.format_exc(\n+                        limit=-conf.getint(\"core\", \"dagbag_import_error_traceback_depth\")\n+                    )\n+                else:\n+                    stacktrace = None\n+                result.errors.append(\n+                    DagImportError(\n+                        file_path=result.file_path,\n+                        message=str(e),\n+                        error_type=\"import\",\n+                        stacktrace=stacktrace,\n+                    )\n+                )\n+                return []\n+\n+        dagbag_import_timeout = settings.get_dagbag_import_timeout(filepath)\n+\n+        if not isinstance(dagbag_import_timeout, (int, float)):\n+            raise TypeError(\n+                f\"Value ({dagbag_import_timeout}) from get_dagbag_import_timeout must be int or float\"\n+            )\n+\n+        if dagbag_import_timeout <= 0:\n+            return parse(mod_name, filepath)\n+\n+        timeout_msg = (\n+            f\"DagBag import timeout for {filepath} after {dagbag_import_timeout}s.\\n\"\n+            \"Please take a look at these docs to improve your DAG import time:\\n\"\n+            f\"* {get_docs_url('best-practices.html#top-level-python-code')}\\n\"\n+            f\"* {get_docs_url('best-practices.html#reducing-dag-complexity')}\"\n+        )\n+        with _timeout(dagbag_import_timeout, error_message=timeout_msg):\n+            return parse(mod_name, filepath)\n+\n+    def _load_modules_from_zip(\n+        self, filepath: str, safe_mode: bool, result: DagImportResult\n+    ) -> list[ModuleType]:\n+        \"\"\"Load Python modules from a zip archive.\"\"\"\n+        from airflow.sdk.definitions._internal.contextmanager import DagContext\n+\n+        mods: list[ModuleType] = []\n+        with zipfile.ZipFile(filepath) as current_zip_file:\n+            for zip_info in current_zip_file.infolist():\n+                zip_path = Path(zip_info.filename)\n+                if zip_path.suffix not in [\".py\", \".pyc\"] or len(zip_path.parts) > 1:\n+                    continue\n+\n+                if zip_path.stem == \"__init__\":\n+                    log.warning(\"Found %s at root of %s\", zip_path.name, filepath)\n+\n+                log.debug(\"Reading %s from %s\", zip_info.filename, filepath)\n+\n+                if not might_contain_dag(zip_info.filename, safe_mode, current_zip_file):\n+                    result.skipped_files.append(f\"{filepath}:{zip_info.filename}\")\n+                    continue\n+\n+                mod_name = zip_path.stem\n+                if mod_name in sys.modules:\n+                    del sys.modules[mod_name]\n+\n+                DagContext.current_autoregister_module_name = mod_name\n+                try:\n+                    sys.path.insert(0, filepath)\n+                    current_module = importlib.import_module(mod_name)\n+                    mods.append(current_module)\n+                except Exception as e:\n+                    DagContext.autoregistered_dags.clear()\n+                    fileloc = os.path.join(filepath, zip_info.filename)\n+                    log.exception(\"Failed to import: %s\", fileloc)\n+                    if conf.getboolean(\"core\", \"dagbag_import_error_tracebacks\"):\n+                        stacktrace = traceback.format_exc(\n+                            limit=-conf.getint(\"core\", \"dagbag_import_error_traceback_depth\")\n+                        )\n+                    else:\n+                        stacktrace = None\n+                    result.errors.append(\n+                        DagImportError(\n+                            file_path=fileloc,  # Use the file path inside the ZIP",
      "comment": "This looks like the full file path instead of relative path?",
      "comment_id": 2668824035,
      "user": "ephraimbuddy",
      "created_at": "2026-01-07T15:04:17Z",
      "url": "https://github.com/apache/airflow/pull/60127#discussion_r2668824035"
    },
    {
      "repo": "apache/airflow",
      "pr_number": 60127,
      "file_path": "airflow-core/tests/unit/dag_processing/test_dagbag.py",
      "line": 449,
      "side": "RIGHT",
      "diff_hunk": "@@ -452,7 +441,7 @@ def test_process_file_that_contains_multi_bytes_char(self, tmp_path):\n         \"\"\"\n         test that we're able to parse file that contains multi-byte char\n         \"\"\"\n-        path = tmp_path / \"testfile\"\n+        path = tmp_path / \"testfile.py\"",
      "comment": ">Maybe those files should be assumed to be python files and parsed with python importer?\r\n\r\nNot really, those were test issues -- not something we have supported officially",
      "comment_id": 2668974857,
      "user": "kaxil",
      "created_at": "2026-01-07T15:41:46Z",
      "url": "https://github.com/apache/airflow/pull/60127#discussion_r2668974857"
    },
    {
      "repo": "apache/airflow",
      "pr_number": 59339,
      "file_path": "airflow-core/tests/unit/models/test_connection.py",
      "line": 161,
      "side": "RIGHT",
      "diff_hunk": "@@ -148,6 +148,17 @@ def clear_fernet_cache(self):\n                 None,\n                 r\"Invalid connection string: type://user:pass@protocol://host:port?param=value.\",\n             ),\n+            (\n+                \"type://host?int_param=123&bool_param=true&float_param=1.5&str_param=some_str\",\n+                \"type\",\n+                \"host\",\n+                None,\n+                None,\n+                None,\n+                \"\",\n+                {\"int_param\": 123, \"bool_param\": True, \"float_param\": 1.5, \"str_param\": \"some_str\"},\n+                None,\n+            ),",
      "comment": "Could we add another case that include `__extra__` in the URI to check whether the `parse_from_uri` are still able to parse the new encoding logic?",
      "comment_id": 2625560498,
      "user": "jason810496",
      "created_at": "2025-12-17T04:32:51Z",
      "url": "https://github.com/apache/airflow/pull/59339#discussion_r2625560498"
    },
    {
      "repo": "apache/airflow",
      "pr_number": 59339,
      "file_path": "airflow-core/src/airflow/models/connection.py",
      "line": 480,
      "side": "RIGHT",
      "diff_hunk": "@@ -457,14 +470,14 @@ def get_extra_dejson(self, nested: bool = False) -> dict:\n \n         if self.extra:\n             try:\n+                extra = json.loads(self.extra)\n                 if nested:\n-                    for key, value in json.loads(self.extra).items():\n-                        extra[key] = value\n+                    for key, value in extra.items():\n                         if isinstance(value, str):\n-                            with suppress(JSONDecodeError):\n+                            try:\n                                 extra[key] = json.loads(value)\n-                else:\n-                    extra = json.loads(self.extra)\n+                            except (JSONDecodeError, TypeError):\n+                                pass",
      "comment": "Sorry for pointing you in the wrong direction in my last review.\nAfter double-checking, we don\u2019t need to change `get_extra_dejson` at all.",
      "comment_id": 2625571312,
      "user": "jason810496",
      "created_at": "2025-12-17T04:39:20Z",
      "url": "https://github.com/apache/airflow/pull/59339#discussion_r2625571312"
    },
    {
      "repo": "apache/airflow",
      "pr_number": 59339,
      "file_path": "airflow-core/src/airflow/models/connection.py",
      "line": 343,
      "side": "RIGHT",
      "diff_hunk": "@@ -331,14 +335,23 @@ def get_uri(self) -> str:\n \n         if self.extra:\n             try:\n-                query: str | None = urlencode(self.extra_dejson)\n-            except TypeError:\n-                query = None\n-            if query and self.extra_dejson == dict(parse_qsl(query, keep_blank_values=True)):\n-                uri += (\"?\" if self.schema else \"/?\") + query\n-            else:\n+                extra_dict = self.extra_dejson\n+                can_flatten = True\n+                for _, value in extra_dict.items():\n+                    if not isinstance(value, str):\n+                        can_flatten = False\n+                        break",
      "comment": "How about moving the `can_flatten` logic before the `try` block, as it _should_ not raise any `TypeError, AttributeError` exception.",
      "comment_id": 2625575450,
      "user": "jason810496",
      "created_at": "2025-12-17T04:42:07Z",
      "url": "https://github.com/apache/airflow/pull/59339#discussion_r2625575450"
    },
    {
      "repo": "apache/airflow",
      "pr_number": 59339,
      "file_path": "airflow-core/src/airflow/models/connection.py",
      "line": 353,
      "side": "RIGHT",
      "diff_hunk": "@@ -331,14 +335,23 @@ def get_uri(self) -> str:\n \n         if self.extra:\n             try:\n-                query: str | None = urlencode(self.extra_dejson)\n-            except TypeError:\n-                query = None\n-            if query and self.extra_dejson == dict(parse_qsl(query, keep_blank_values=True)):\n-                uri += (\"?\" if self.schema else \"/?\") + query\n-            else:\n+                extra_dict = self.extra_dejson\n+                can_flatten = True\n+                for _, value in extra_dict.items():\n+                    if not isinstance(value, str):\n+                        can_flatten = False\n+                        break\n+\n+                if can_flatten:\n+                    query = urlencode(extra_dict)\n+                    if extra_dict == dict(parse_qsl(query, keep_blank_values=True)):\n+                        uri += (\"?\" if self.schema else \"/?\") + query\n+                    else:\n+                        uri += (\"?\" if self.schema else \"/?\") + urlencode({self.EXTRA_KEY: self.extra})\n+                else:\n+                    uri += (\"?\" if self.schema else \"/?\") + urlencode({self.EXTRA_KEY: self.extra})\n+            except (TypeError, AttributeError):",
      "comment": "It seems the whole flow could be simplify as:\n\n```python\ncan_flatten = True\n# the for loop to check whether could we flatten \n\ntry:\n    query: str | None = urlencode(self.extra_dejson)\nexcept TypeError:\n    query = None\n\n# we just need to add can_flatten condition check\nif can_flatten and query and self.extra_dejson == dict(parse_qsl(query, keep_blank_values=True)):\n    uri += (\"?\" if self.schema else \"/?\") + query\nelse:\n# fallback to nested EXTRA_KEY\n    uri += (\"?\" if self.schema else \"/?\") + urlencode({self.EXTRA_KEY: self.extra})\n```\n\nwhich also minimized the change.",
      "comment_id": 2625584065,
      "user": "jason810496",
      "created_at": "2025-12-17T04:47:58Z",
      "url": "https://github.com/apache/airflow/pull/59339#discussion_r2625584065"
    },
    {
      "repo": "apache/airflow",
      "pr_number": 59339,
      "file_path": "airflow-core/src/airflow/models/connection.py",
      "line": 340,
      "side": "RIGHT",
      "diff_hunk": "@@ -331,14 +335,23 @@ def get_uri(self) -> str:\n \n         if self.extra:\n             try:\n-                query: str | None = urlencode(self.extra_dejson)\n-            except TypeError:\n-                query = None\n-            if query and self.extra_dejson == dict(parse_qsl(query, keep_blank_values=True)):\n-                uri += (\"?\" if self.schema else \"/?\") + query\n-            else:\n+                extra_dict = self.extra_dejson\n+                can_flatten = True\n+                for _, value in extra_dict.items():",
      "comment": "```suggestion\n                for value in extra_dict.values():\n```",
      "comment_id": 2626174989,
      "user": "Lee-W",
      "created_at": "2025-12-17T09:02:28Z",
      "url": "https://github.com/apache/airflow/pull/59339#discussion_r2626174989"
    },
    {
      "repo": "apache/airflow",
      "pr_number": 59339,
      "file_path": "airflow-core/src/airflow/models/connection.py",
      "line": 345,
      "side": "RIGHT",
      "diff_hunk": "@@ -330,15 +334,22 @@ def get_uri(self) -> str:\n         uri += host_block\n \n         if self.extra:\n+            extra_dict = self.extra_dejson\n+            can_flatten = True\n+            for value in extra_dict.values():\n+                if not isinstance(value, str):\n+                    can_flatten = False\n+                    break\n+\n             try:\n-                query: str | None = urlencode(self.extra_dejson)\n+                query = urlencode(extra_dict)",
      "comment": "would like to know why did we remove type annotation",
      "comment_id": 2639136257,
      "user": "Lee-W",
      "created_at": "2025-12-22T08:57:28Z",
      "url": "https://github.com/apache/airflow/pull/59339#discussion_r2639136257"
    },
    {
      "repo": "apache/airflow",
      "pr_number": 59339,
      "file_path": "airflow-core/src/airflow/models/connection.py",
      "line": 480,
      "side": "RIGHT",
      "diff_hunk": "@@ -457,14 +470,14 @@ def get_extra_dejson(self, nested: bool = False) -> dict:\n \n         if self.extra:\n             try:\n+                extra = json.loads(self.extra)\n                 if nested:\n-                    for key, value in json.loads(self.extra).items():\n-                        extra[key] = value\n+                    for key, value in extra.items():\n                         if isinstance(value, str):\n-                            with suppress(JSONDecodeError):\n+                            try:\n                                 extra[key] = json.loads(value)\n-                else:\n-                    extra = json.loads(self.extra)\n+                            except (JSONDecodeError, TypeError):\n+                                pass",
      "comment": "I think we could revert the change of `get_extra_dejson`, as  current change doesn't impact the behavior.Thanks!",
      "comment_id": 2639805649,
      "user": "jason810496",
      "created_at": "2025-12-22T12:58:00Z",
      "url": "https://github.com/apache/airflow/pull/59339#discussion_r2639805649"
    },
    {
      "repo": "apache/airflow",
      "pr_number": 59477,
      "file_path": "airflow-core/src/airflow/api_fastapi/core_api/datamodels/dag_run.py",
      "line": 129,
      "side": "RIGHT",
      "diff_hunk": "@@ -126,10 +126,7 @@ def validate_context(self, dag: SerializedDAG) -> dict:\n                     end=timezone.coerce_datetime(self.data_interval_end),\n                 )\n             else:\n-                data_interval = dag.timetable.infer_manual_data_interval(\n-                    run_after=coerced_logical_date or timezone.coerce_datetime(run_after)\n-                )\n-                run_after = data_interval.end\n+                data_interval = dag.timetable.infer_manual_data_interval(run_after=coerced_logical_date)",
      "comment": "Can you explain why you removed the `data_interval` being inferred from the `run_after` date if the `coerced_logical_date` is None?\r\n\r\nThis piece doesn't seem directly related to the fix. (just removing the `run_after = data_interval.end` should be enough)?",
      "comment_id": 2631654573,
      "user": "pierrejeambrun",
      "created_at": "2025-12-18T15:58:34Z",
      "url": "https://github.com/apache/airflow/pull/59477#discussion_r2631654573"
    },
    {
      "repo": "apache/airflow",
      "pr_number": 59477,
      "file_path": "airflow-core/src/airflow/api_fastapi/core_api/datamodels/dag_run.py",
      "line": 129,
      "side": "RIGHT",
      "diff_hunk": "@@ -126,10 +126,7 @@ def validate_context(self, dag: SerializedDAG) -> dict:\n                     end=timezone.coerce_datetime(self.data_interval_end),\n                 )\n             else:\n-                data_interval = dag.timetable.infer_manual_data_interval(\n-                    run_after=coerced_logical_date or timezone.coerce_datetime(run_after)\n-                )\n-                run_after = data_interval.end\n+                data_interval = dag.timetable.infer_manual_data_interval(run_after=coerced_logical_date)",
      "comment": "We are under ```if coerced_logical_date:``` conditional, therefore ```coerced_logical_date``` is guaranteed to exist so I removed the remaining dead code from the or statement and cleaned up the variable assignment. The actual fix is removing run_after = data_interval.end.",
      "comment_id": 2649453537,
      "user": "steveahnahn",
      "created_at": "2025-12-28T03:34:59Z",
      "url": "https://github.com/apache/airflow/pull/59477#discussion_r2649453537"
    },
    {
      "repo": "apache/airflow",
      "pr_number": 60314,
      "file_path": "airflow-core/tests/unit/api_fastapi/core_api/routes/ui/test_grid.py",
      "line": 936,
      "side": "RIGHT",
      "diff_hunk": "@@ -933,3 +933,78 @@ def test_nonlinear_structure_intermediate_with_both_directions(self, test_client\n         # Should return intermediate, its upstream path, and downstream path\n         # upstream: branch_a, start; downstream: merge, end\n         assert task_ids == [\"branch_a\", \"end\", \"intermediate\", \"merge\", \"start\"]\n+\n+    # Tests for depth parameter",
      "comment": "Would it be better to add `pytest.mark.parametrize` to reuse the test method?",
      "comment_id": 2678611891,
      "user": "jason810496",
      "created_at": "2026-01-10T12:21:44Z",
      "url": "https://github.com/apache/airflow/pull/60314#discussion_r2678611891"
    },
    {
      "repo": "apache/airflow",
      "pr_number": 60314,
      "file_path": "airflow-core/tests/unit/api_fastapi/core_api/routes/ui/test_structure.py",
      "line": 770,
      "side": "RIGHT",
      "diff_hunk": "@@ -729,3 +767,112 @@ def test_mapped_operator_in_task_group(self, dag_maker, test_client, session):\n         )\n         assert mapped_in_group[\"is_mapped\"] is True\n         assert mapped_in_group[\"operator\"] == \"PythonOperator\"\n+",
      "comment": "Some for some of the test method of test structure.",
      "comment_id": 2678614082,
      "user": "jason810496",
      "created_at": "2026-01-10T12:25:15Z",
      "url": "https://github.com/apache/airflow/pull/60314#discussion_r2678614082"
    },
    {
      "repo": "apache/airflow",
      "pr_number": 60254,
      "file_path": "providers/cncf/kubernetes/src/airflow/providers/cncf/kubernetes/hooks/kubernetes.py",
      "line": 1083,
      "side": "RIGHT",
      "diff_hunk": "@@ -1069,6 +1080,7 @@ async def get_job_status(self, name: str, namespace: str) -> V1Job:\n             job: V1Job = await v1_api.read_namespaced_job_status(\n                 name=name,\n                 namespace=namespace,\n+                **with_timeout(),",
      "comment": "I think adding missing timeout is reasonable - but can you maybe find a way that is on one global place and not scattert across many places where calls are being made? Otherwise I fear this looks very complex and future extensions have the risk missing one or the other place.",
      "comment_id": 2673941337,
      "user": "jscheffl",
      "created_at": "2026-01-08T21:19:34Z",
      "url": "https://github.com/apache/airflow/pull/60254#discussion_r2673941337"
    },
    {
      "repo": "apache/airflow",
      "pr_number": 60254,
      "file_path": "providers/cncf/kubernetes/src/airflow/providers/cncf/kubernetes/hooks/kubernetes.py",
      "line": 1083,
      "side": "RIGHT",
      "diff_hunk": "@@ -1069,6 +1080,7 @@ async def get_job_status(self, name: str, namespace: str) -> V1Job:\n             job: V1Job = await v1_api.read_namespaced_job_status(\n                 name=name,\n                 namespace=namespace,\n+                **with_timeout(),",
      "comment": "@jscheffl  Thank you for the response. After reconsidering overnight, I realized that setting a default timeout this way isn\u2019t ideal. I\u2019ve implemented a different approach: a wrapper around both the sync and async API clients that injects a client-side timeout into all API calls.",
      "comment_id": 2675593986,
      "user": "AutomationDev85",
      "created_at": "2026-01-09T10:09:14Z",
      "url": "https://github.com/apache/airflow/pull/60254#discussion_r2675593986"
    },
    {
      "repo": "apache/airflow",
      "pr_number": 60254,
      "file_path": "providers/cncf/kubernetes/src/airflow/providers/cncf/kubernetes/hooks/kubernetes.py",
      "line": 261,
      "side": "RIGHT",
      "diff_hunk": "@@ -239,7 +258,7 @@ def _get_field(self, field_name):\n         prefixed_name = f\"extra__kubernetes__{field_name}\"\n         return self.conn_extras.get(prefixed_name) or None\n \n-    def get_conn(self) -> client.ApiClient:\n+    def get_conn(self) -> _TimeoutK8sApiClient:",
      "comment": "I'd propose NOT changing the signature of the method as the class passed as return is a private wrapper. Then people looking at type hints are not wondering what this is. As well as the timeout wrapper is not adding any interface of benefit to expose.\n```suggestion\n    def get_conn(self) -> client.ApiClient:\n```",
      "comment_id": 2677651649,
      "user": "jscheffl",
      "created_at": "2026-01-09T21:19:00Z",
      "url": "https://github.com/apache/airflow/pull/60254#discussion_r2677651649"
    },
    {
      "repo": "apache/airflow",
      "pr_number": 60254,
      "file_path": "providers/cncf/kubernetes/src/airflow/providers/cncf/kubernetes/hooks/kubernetes.py",
      "line": 333,
      "side": "RIGHT",
      "diff_hunk": "@@ -307,11 +326,11 @@ def get_conn(self) -> client.ApiClient:\n                 client_configuration=self.client_configuration,\n                 context=cluster_context,\n             )\n-            return client.ApiClient()\n+            return _TimeoutK8sApiClient()\n \n         return self._get_default_client(cluster_context=cluster_context)\n \n-    def _get_default_client(self, *, cluster_context: str | None = None) -> client.ApiClient:\n+    def _get_default_client(self, *, cluster_context: str | None = None) -> _TimeoutK8sApiClient:",
      "comment": "Same as above: Recommend to keep return declaration compatible\n```suggestion\n    def _get_default_client(self, *, cluster_context: str | None = None) -> client.ApiClient:\n```",
      "comment_id": 2677653077,
      "user": "jscheffl",
      "created_at": "2026-01-09T21:19:36Z",
      "url": "https://github.com/apache/airflow/pull/60254#discussion_r2677653077"
    },
    {
      "repo": "apache/airflow",
      "pr_number": 60254,
      "file_path": "providers/cncf/kubernetes/src/airflow/providers/cncf/kubernetes/hooks/kubernetes.py",
      "line": 896,
      "side": "RIGHT",
      "diff_hunk": "@@ -874,10 +893,10 @@ async def _get_field(self, field_name):\n         return extras.get(prefixed_name)\n \n     @contextlib.asynccontextmanager\n-    async def get_conn(self) -> async_client.ApiClient:\n+    async def get_conn(self) -> AsyncIterator[_TimeoutAsyncK8sApiClient]:  # type: ignore[override]",
      "comment": "I assume staying compatible should also prevent the need of the type ignore.\n```suggestion\n    async def get_conn(self) -> async_client.ApiClient:\n```",
      "comment_id": 2677655093,
      "user": "jscheffl",
      "created_at": "2026-01-09T21:20:39Z",
      "url": "https://github.com/apache/airflow/pull/60254#discussion_r2677655093"
    },
    {
      "repo": "apache/airflow",
      "pr_number": 60254,
      "file_path": "providers/google/src/airflow/providers/google/cloud/hooks/kubernetes_engine.py",
      "line": 501,
      "side": "RIGHT",
      "diff_hunk": "@@ -498,7 +498,7 @@ def __init__(\n         )\n \n     @contextlib.asynccontextmanager\n-    async def get_conn(self) -> async_client.ApiClient:\n+    async def get_conn(self) -> async_client.ApiClient:  # type: ignore[override]",
      "comment": "I assume this change is not needed if comments above are considered.",
      "comment_id": 2677656646,
      "user": "jscheffl",
      "created_at": "2026-01-09T21:21:21Z",
      "url": "https://github.com/apache/airflow/pull/60254#discussion_r2677656646"
    },
    {
      "repo": "apache/airflow",
      "pr_number": 59217,
      "file_path": "providers/databricks/src/airflow/providers/databricks/hooks/databricks.py",
      "line": 65,
      "side": "RIGHT",
      "diff_hunk": "@@ -37,37 +37,37 @@\n from airflow.providers.common.compat.sdk import AirflowException\n from airflow.providers.databricks.hooks.databricks_base import BaseDatabricksHook\n \n-GET_CLUSTER_ENDPOINT = (\"GET\", \"2.0/clusters/get\")\n-RESTART_CLUSTER_ENDPOINT = (\"POST\", \"2.0/clusters/restart\")\n-START_CLUSTER_ENDPOINT = (\"POST\", \"2.0/clusters/start\")\n-TERMINATE_CLUSTER_ENDPOINT = (\"POST\", \"2.0/clusters/delete\")\n+GET_CLUSTER_ENDPOINT = (\"GET\", \"2.2/clusters/get\")\n+RESTART_CLUSTER_ENDPOINT = (\"POST\", \"2.2/clusters/restart\")\n+START_CLUSTER_ENDPOINT = (\"POST\", \"2.2/clusters/start\")\n+TERMINATE_CLUSTER_ENDPOINT = (\"POST\", \"2.2/clusters/delete\")\n \n-CREATE_ENDPOINT = (\"POST\", \"2.1/jobs/create\")\n-RESET_ENDPOINT = (\"POST\", \"2.1/jobs/reset\")\n-UPDATE_ENDPOINT = (\"POST\", \"2.1/jobs/update\")\n-RUN_NOW_ENDPOINT = (\"POST\", \"2.1/jobs/run-now\")\n-SUBMIT_RUN_ENDPOINT = (\"POST\", \"2.1/jobs/runs/submit\")\n-GET_RUN_ENDPOINT = (\"GET\", \"2.1/jobs/runs/get\")\n-CANCEL_RUN_ENDPOINT = (\"POST\", \"2.1/jobs/runs/cancel\")\n-DELETE_RUN_ENDPOINT = (\"POST\", \"2.1/jobs/runs/delete\")\n-REPAIR_RUN_ENDPOINT = (\"POST\", \"2.1/jobs/runs/repair\")\n-OUTPUT_RUNS_JOB_ENDPOINT = (\"GET\", \"2.1/jobs/runs/get-output\")\n-CANCEL_ALL_RUNS_ENDPOINT = (\"POST\", \"2.1/jobs/runs/cancel-all\")\n+CREATE_ENDPOINT = (\"POST\", \"2.2/jobs/create\")\n+RESET_ENDPOINT = (\"POST\", \"2.2/jobs/reset\")\n+UPDATE_ENDPOINT = (\"POST\", \"2.2/jobs/update\")\n+RUN_NOW_ENDPOINT = (\"POST\", \"2.2/jobs/run-now\")\n+SUBMIT_RUN_ENDPOINT = (\"POST\", \"2.2/jobs/runs/submit\")\n+GET_RUN_ENDPOINT = (\"GET\", \"2.2/jobs/runs/get\")\n+CANCEL_RUN_ENDPOINT = (\"POST\", \"2.2/jobs/runs/cancel\")\n+DELETE_RUN_ENDPOINT = (\"POST\", \"2.2/jobs/runs/delete\")\n+REPAIR_RUN_ENDPOINT = (\"POST\", \"2.2/jobs/runs/repair\")\n+OUTPUT_RUNS_JOB_ENDPOINT = (\"GET\", \"2.2/jobs/runs/get-output\")\n+CANCEL_ALL_RUNS_ENDPOINT = (\"POST\", \"2.2/jobs/runs/cancel-all\")\n \n-INSTALL_LIBS_ENDPOINT = (\"POST\", \"2.0/libraries/install\")\n-UNINSTALL_LIBS_ENDPOINT = (\"POST\", \"2.0/libraries/uninstall\")\n-UPDATE_REPO_ENDPOINT = (\"PATCH\", \"2.0/repos/\")\n-DELETE_REPO_ENDPOINT = (\"DELETE\", \"2.0/repos/\")\n-CREATE_REPO_ENDPOINT = (\"POST\", \"2.0/repos\")\n+INSTALL_LIBS_ENDPOINT = (\"POST\", \"2.2/libraries/install\")\n+UNINSTALL_LIBS_ENDPOINT = (\"POST\", \"2.2/libraries/uninstall\")\n+UPDATE_REPO_ENDPOINT = (\"PATCH\", \"2.2/repos/\")\n+DELETE_REPO_ENDPOINT = (\"DELETE\", \"2.2/repos/\")\n+CREATE_REPO_ENDPOINT = (\"POST\", \"2.2/repos\")\n \n-LIST_JOBS_ENDPOINT = (\"GET\", \"2.1/jobs/list\")\n-LIST_PIPELINES_ENDPOINT = (\"GET\", \"2.0/pipelines\")\n-LIST_SQL_ENDPOINTS_ENDPOINT = (\"GET\", \"2.0/sql/endpoints\")\n+LIST_JOBS_ENDPOINT = (\"GET\", \"2.2/jobs/list\")\n+LIST_PIPELINES_ENDPOINT = (\"GET\", \"2.2/pipelines\")\n+LIST_SQL_ENDPOINTS_ENDPOINT = (\"GET\", \"2.2/sql/endpoints\")",
      "comment": "This endpoint unfortunately does not exist and I even do think that has been migrated to: https://docs.databricks.com/api/workspace/warehouses/list\r\n```\r\n[2026-01-13 03:32:41] ERROR - Task failed with exception source=task loc=task_runner.py:986\r\nAirflowException: Response: {\"error\":\"Bad Target: /api/2.2/sql/endpoints\"}\r\n, Status Code: 404\r\n\r\nHTTPError: 404 Client Error: Not Found for url: https://dbc-instance-random.cloud.databricks.com/api/2.2/sql/endpoints\r\n\r\nFile \"/home/airflow/.local/lib/python3.12/site-packages/airflow/providers/databricks/hooks/databricks_base.py\", line 704 in _do_api_call\r\nFile \"/home/airflow/.local/lib/python3.12/site-packages/tenacity/__init__.py\", line 445 in __iter__\r\nFile \"/home/airflow/.local/lib/python3.12/site-packages/tenacity/__init__.py\", line 378 in iter\r\nFile \"/home/airflow/.local/lib/python3.12/site-packages/tenacity/__init__.py\", line 400 in <lambda>\r\nFile \"/usr/python/lib/python3.12/concurrent/futures/_base.py\", line 449 in result\r\nFile \"/usr/python/lib/python3.12/concurrent/futures/_base.py\", line 401 in __get_result\r\nFile \"/home/airflow/.local/lib/python3.12/site-packages/airflow/providers/databricks/hooks/databricks_base.py\", line 723 in _do_api_call\r\nFile \"/home/airflow/.local/lib/python3.12/site-packages/requests/models.py\", line 1026 in raise_for_status\r\n```\r\n\r\nPrevious version `api/2.0/sql/endpoints` works is there even though is not listed in the Databricks documentation.",
      "comment_id": 2685328650,
      "user": "aru-trackunit",
      "created_at": "2026-01-13T08:14:55Z",
      "url": "https://github.com/apache/airflow/pull/59217#discussion_r2685328650"
    },
    {
      "repo": "apache/airflow",
      "pr_number": 59639,
      "file_path": "airflow-core/src/airflow/jobs/scheduler_job_runner.py",
      "line": 2596,
      "side": "RIGHT",
      "diff_hunk": "@@ -2584,8 +2584,16 @@ def adopt_or_reset_orphaned_tasks(self, session: Session = NEW_SESSION) -> int:\n                     reset_tis_message = []\n                     for ti in to_reset:\n                         reset_tis_message.append(repr(ti))\n+                        # If we reset a TI, it will be eligible to be scheduled again.\n+                        # This can cause the scheduler to increase the try_number on the TI.\n+                        # Record the current try to TaskInstanceHistory first so users have an audit trail for\n+                        # the attempt that was abandoned.\n+                        ti.prepare_db_for_next_try(session=session)\n+\n                         ti.state = None\n                         ti.queued_by_job_id = None\n+                        ti.external_executor_id = None\n+                        ti.clear_next_method_args()",
      "comment": "We need to reset the external_executor_id so that in k8s, the pod will have a different ID and not interfere with adoption/cleanup. Typically treating this as a new attempt. \r\nclear_next_method_args is called too so this doesn't behave like it's resuming from deferred but a new attempt",
      "comment_id": 2635107226,
      "user": "ephraimbuddy",
      "created_at": "2025-12-19T13:29:10Z",
      "url": "https://github.com/apache/airflow/pull/59639#discussion_r2635107226"
    },
    {
      "repo": "apache/airflow",
      "pr_number": 60166,
      "file_path": "airflow-core/src/airflow/models/asset.py",
      "line": 115,
      "side": "RIGHT",
      "diff_hunk": "@@ -112,12 +112,14 @@ def remove_references_to_deleted_dags(session: Session):\n         DagScheduleAssetAliasReference,\n         TaskOutletAssetReference,\n     ]\n-    for model in models_to_check:\n-        session.execute(\n-            delete(model)\n-            .where(model.dag_id.in_(select(DagModel.dag_id).where(DagModel.is_stale)))\n-            .execution_options(synchronize_session=\"fetch\")\n-        )\n+",
      "comment": "```suggestion\n\n# The queries need to be done in separate steps, because in case of multiple dag processors on\n# MySQL there could be a deadlock caused by acquiring both exclusive lock for deletion and\n# shared lock for query in reverse sequence\n```",
      "comment_id": 2667606357,
      "user": "potiuk",
      "created_at": "2026-01-07T09:04:12Z",
      "url": "https://github.com/apache/airflow/pull/60166#discussion_r2667606357"
    },
    {
      "repo": "apache/airflow",
      "pr_number": 60166,
      "file_path": "airflow-core/src/airflow/models/asset.py",
      "line": 115,
      "side": "RIGHT",
      "diff_hunk": "@@ -112,12 +112,14 @@ def remove_references_to_deleted_dags(session: Session):\n         DagScheduleAssetAliasReference,\n         TaskOutletAssetReference,\n     ]\n-    for model in models_to_check:\n-        session.execute(\n-            delete(model)\n-            .where(model.dag_id.in_(select(DagModel.dag_id).where(DagModel.is_stale)))\n-            .execution_options(synchronize_session=\"fetch\")\n-        )\n+",
      "comment": "I'd add a comment here for posterity (also preventing future us trying to \"optimise\" this and make it into single query.",
      "comment_id": 2667608259,
      "user": "potiuk",
      "created_at": "2026-01-07T09:04:51Z",
      "url": "https://github.com/apache/airflow/pull/60166#discussion_r2667608259"
    },
    {
      "repo": "apache/airflow",
      "pr_number": 59097,
      "file_path": "providers/cncf/kubernetes/src/airflow/providers/cncf/kubernetes/operators/pod.py",
      "line": 1439,
      "side": "RIGHT",
      "diff_hunk": "@@ -1390,6 +1390,17 @@ def _get_most_recent_pod_index(pod_list: list[k8s.V1Pod]) -> int:\n         pod_start_times: list[datetime.datetime] = [\n             pod.to_dict().get(\"status\").get(\"start_time\") for pod in pod_list\n         ]\n+        if not all(pod_start_times):\n+            pod_start_times: list[datetime.datetime] = [  # type: ignore[no-redef]\n+                pod_start_time\n+                if (\n+                    pod_start_time := pod.to_dict()\n+                    .get(\"metadata\", {})\n+                    .get(\"creation_timestamp\", datetime.datetime.now(tz=datetime.timezone.utc))\n+                )\n+                else datetime.datetime.now(tz=datetime.timezone.utc)",
      "comment": "The fallback logic has a flaw. The walrus operator on line 1397 assigns the result of `.get(\"creation_timestamp\", datetime.datetime.now(tz=datetime.timezone.utc))`, which will always return a non-None value due to the default argument in get(). This means the condition on line 1395 (`if pod_start_time`) will always be True, making the `else datetime.datetime.now(tz=datetime.timezone.utc)` branch on line 1401 unreachable.\n\nThe code should check if `creation_timestamp` exists before using it, or remove the redundant else clause since the default is already handled by the get() call on line 1399.\n```suggestion\n            pod_start_times: list[datetime.datetime] = [\n                pod.to_dict()\n                .get(\"metadata\", {})\n                .get(\"creation_timestamp\", datetime.datetime.now(tz=datetime.timezone.utc))\n```",
      "comment_id": 2615172738,
      "user": "Copilot",
      "created_at": "2025-12-12T18:22:28Z",
      "url": "https://github.com/apache/airflow/pull/59097#discussion_r2615172738"
    },
    {
      "repo": "apache/airflow",
      "pr_number": 59097,
      "file_path": "providers/cncf/kubernetes/src/airflow/providers/cncf/kubernetes/operators/pod.py",
      "line": 1428,
      "side": "RIGHT",
      "diff_hunk": "@@ -1390,6 +1390,17 @@ def _get_most_recent_pod_index(pod_list: list[k8s.V1Pod]) -> int:\n         pod_start_times: list[datetime.datetime] = [\n             pod.to_dict().get(\"status\").get(\"start_time\") for pod in pod_list",
      "comment": "This code will raise an AttributeError if `pod.to_dict().get(\"status\")` returns None, since you cannot call `.get(\"start_time\")` on None. The code should use chained get() calls with a default dictionary to handle the case where status is None, for example: `pod.to_dict().get(\"status\", {}).get(\"start_time\")`.\n```suggestion\n            pod.to_dict().get(\"status\", {}).get(\"start_time\") for pod in pod_list\n```",
      "comment_id": 2615172762,
      "user": "Copilot",
      "created_at": "2025-12-12T18:22:29Z",
      "url": "https://github.com/apache/airflow/pull/59097#discussion_r2615172762"
    },
    {
      "repo": "apache/airflow",
      "pr_number": 59097,
      "file_path": "providers/cncf/kubernetes/tests/unit/cncf/kubernetes/operators/test_pod.py",
      "line": 2261,
      "side": "RIGHT",
      "diff_hunk": "@@ -2199,6 +2199,83 @@ def test_process_duplicate_label_pods__label_patched_if_action_is_not_delete_pod\n         process_pod_deletion_mock.assert_not_called()\n         assert result.metadata.name == pod_2.metadata.name\n \n+    @pytest.mark.parametrize(\n+        \"on_finish_action\", [OnFinishAction.KEEP_POD, OnFinishAction.DELETE_SUCCEEDED_POD]\n+    )\n+    @patch(KUB_OP_PATH.format(\"patch_already_checked\"))\n+    @patch(KUB_OP_PATH.format(\"process_pod_deletion\"))\n+    def test_process_duplicate_label_pods_with_start_time_none(",
      "comment": "The test name `test_process_duplicate_label_pods_with_start_time_none` could be more descriptive. Consider renaming to `test_process_duplicate_label_pods_falls_back_to_creation_timestamp_when_start_time_is_none` to make it clearer what behavior is being tested.\n```suggestion\n    def test_process_duplicate_label_pods_falls_back_to_creation_timestamp_when_start_time_is_none(\n```",
      "comment_id": 2615172777,
      "user": "Copilot",
      "created_at": "2025-12-12T18:22:29Z",
      "url": "https://github.com/apache/airflow/pull/59097#discussion_r2615172777"
    },
    {
      "repo": "apache/airflow",
      "pr_number": 59097,
      "file_path": "providers/cncf/kubernetes/tests/unit/cncf/kubernetes/operators/test_pod.py",
      "line": 2284,
      "side": "RIGHT",
      "diff_hunk": "@@ -2199,6 +2199,83 @@ def test_process_duplicate_label_pods__label_patched_if_action_is_not_delete_pod\n         process_pod_deletion_mock.assert_not_called()\n         assert result.metadata.name == pod_2.metadata.name\n \n+    @pytest.mark.parametrize(\n+        \"on_finish_action\", [OnFinishAction.KEEP_POD, OnFinishAction.DELETE_SUCCEEDED_POD]\n+    )\n+    @patch(KUB_OP_PATH.format(\"patch_already_checked\"))\n+    @patch(KUB_OP_PATH.format(\"process_pod_deletion\"))\n+    def test_process_duplicate_label_pods_with_start_time_none(\n+        self,\n+        process_pod_deletion_mock,\n+        patch_already_checked_mock,\n+        on_finish_action,\n+    ):\n+        now = datetime.datetime.now()\n+        k = KubernetesPodOperator(\n+            namespace=\"default\",\n+            image=\"ubuntu:22.04\",\n+            cmds=[\"bash\", \"-cx\"],\n+            arguments=[\"echo 12\"],\n+            name=\"test\",\n+            task_id=\"task\",\n+            do_xcom_push=False,\n+            reattach_on_restart=False,\n+            on_finish_action=on_finish_action,\n+        )\n+        context = create_context(k)\n+        pod_1 = k.get_or_create_pod(pod_request_obj=k.build_pod_request_obj(context), context=context)\n+        pod_2 = k.get_or_create_pod(pod_request_obj=k.build_pod_request_obj(context), context=context)\n+\n+        pod_1.status = {\"start_time\": None}\n+        pod_2.status = {\"start_time\": None}",
      "comment": "Setting `pod.status` to a plain dictionary may not correctly mock the V1Pod object's status attribute. The kubernetes client's V1Pod expects a V1PodStatus object. Consider using `V1PodStatus(start_time=None)` instead to ensure the test accurately represents the actual API behavior when serialized with `to_dict()`.\n```suggestion\n        pod_1.status = V1PodStatus(start_time=None)\n        pod_2.status = V1PodStatus(start_time=None)\n```",
      "comment_id": 2615172791,
      "user": "Copilot",
      "created_at": "2025-12-12T18:22:29Z",
      "url": "https://github.com/apache/airflow/pull/59097#discussion_r2615172791"
    },
    {
      "repo": "apache/airflow",
      "pr_number": 59097,
      "file_path": "providers/cncf/kubernetes/tests/unit/cncf/kubernetes/operators/test_pod.py",
      "line": 2322,
      "side": "RIGHT",
      "diff_hunk": "@@ -2199,6 +2199,83 @@ def test_process_duplicate_label_pods__label_patched_if_action_is_not_delete_pod\n         process_pod_deletion_mock.assert_not_called()\n         assert result.metadata.name == pod_2.metadata.name\n \n+    @pytest.mark.parametrize(\n+        \"on_finish_action\", [OnFinishAction.KEEP_POD, OnFinishAction.DELETE_SUCCEEDED_POD]\n+    )\n+    @patch(KUB_OP_PATH.format(\"patch_already_checked\"))\n+    @patch(KUB_OP_PATH.format(\"process_pod_deletion\"))\n+    def test_process_duplicate_label_pods_with_start_time_none(\n+        self,\n+        process_pod_deletion_mock,\n+        patch_already_checked_mock,\n+        on_finish_action,\n+    ):\n+        now = datetime.datetime.now()\n+        k = KubernetesPodOperator(\n+            namespace=\"default\",\n+            image=\"ubuntu:22.04\",\n+            cmds=[\"bash\", \"-cx\"],\n+            arguments=[\"echo 12\"],\n+            name=\"test\",\n+            task_id=\"task\",\n+            do_xcom_push=False,\n+            reattach_on_restart=False,\n+            on_finish_action=on_finish_action,\n+        )\n+        context = create_context(k)\n+        pod_1 = k.get_or_create_pod(pod_request_obj=k.build_pod_request_obj(context), context=context)\n+        pod_2 = k.get_or_create_pod(pod_request_obj=k.build_pod_request_obj(context), context=context)\n+\n+        pod_1.status = {\"start_time\": None}\n+        pod_2.status = {\"start_time\": None}\n+        pod_1.metadata.creation_timestamp = now\n+        pod_2.metadata.creation_timestamp = now + datetime.timedelta(seconds=60)\n+        pod_2.metadata.labels.update({\"try_number\": \"2\"})\n+\n+        result = k.process_duplicate_label_pods([pod_1, pod_2])\n+\n+        patch_already_checked_mock.assert_called_once_with(pod_1, reraise=False)\n+        process_pod_deletion_mock.assert_not_called()\n+        assert result.metadata.name == pod_2.metadata.name\n+\n+    @pytest.mark.parametrize(\n+        \"on_finish_action\", [OnFinishAction.KEEP_POD, OnFinishAction.DELETE_SUCCEEDED_POD]\n+    )\n+    @patch(KUB_OP_PATH.format(\"patch_already_checked\"))\n+    @patch(KUB_OP_PATH.format(\"process_pod_deletion\"))\n+    def test_process_duplicate_label_pods_with_no_start_time_or_creation_timestamp(\n+        self,\n+        process_pod_deletion_mock,\n+        patch_already_checked_mock,\n+        on_finish_action,\n+    ):\n+        k = KubernetesPodOperator(\n+            namespace=\"default\",\n+            image=\"ubuntu:22.04\",\n+            cmds=[\"bash\", \"-cx\"],\n+            arguments=[\"echo 12\"],\n+            name=\"test\",\n+            task_id=\"task\",\n+            do_xcom_push=False,\n+            reattach_on_restart=False,\n+            on_finish_action=on_finish_action,\n+        )\n+        context = create_context(k)\n+        pod_1 = k.get_or_create_pod(pod_request_obj=k.build_pod_request_obj(context), context=context)\n+        pod_2 = k.get_or_create_pod(pod_request_obj=k.build_pod_request_obj(context), context=context)\n+\n+        pod_1.status = {\"start_time\": None}\n+        pod_2.status = {\"start_time\": None}",
      "comment": "Setting `pod.status` to a plain dictionary may not correctly mock the V1Pod object's status attribute. The kubernetes client's V1Pod expects a V1PodStatus object. Consider using `V1PodStatus(start_time=None)` instead to ensure the test accurately represents the actual API behavior when serialized with `to_dict()`.\n```suggestion\n        pod_1.status = V1PodStatus(start_time=None)\n        pod_2.status = V1PodStatus(start_time=None)\n```",
      "comment_id": 2615172805,
      "user": "Copilot",
      "created_at": "2025-12-12T18:22:30Z",
      "url": "https://github.com/apache/airflow/pull/59097#discussion_r2615172805"
    },
    {
      "repo": "apache/airflow",
      "pr_number": 59097,
      "file_path": "providers/cncf/kubernetes/src/airflow/providers/cncf/kubernetes/operators/pod.py",
      "line": 1439,
      "side": "RIGHT",
      "diff_hunk": "@@ -1390,6 +1390,17 @@ def _get_most_recent_pod_index(pod_list: list[k8s.V1Pod]) -> int:\n         pod_start_times: list[datetime.datetime] = [\n             pod.to_dict().get(\"status\").get(\"start_time\") for pod in pod_list\n         ]\n+        if not all(pod_start_times):\n+            pod_start_times: list[datetime.datetime] = [  # type: ignore[no-redef]\n+                pod_start_time\n+                if (\n+                    pod_start_time := pod.to_dict()\n+                    .get(\"metadata\", {})\n+                    .get(\"creation_timestamp\", datetime.datetime.now(tz=datetime.timezone.utc))\n+                )\n+                else datetime.datetime.now(tz=datetime.timezone.utc)",
      "comment": "No, because .get(\"creation_timestamp\", datetime.datetime.now(tz=datetime.timezone.utc) will return datetime.now only in case when creation_timestamp field is not presented in the metadata. For this cases else statement in the line 1401 was added. ",
      "comment_id": 2673872633,
      "user": "Crowiant",
      "created_at": "2026-01-08T20:55:54Z",
      "url": "https://github.com/apache/airflow/pull/59097#discussion_r2673872633"
    },
    {
      "repo": "apache/airflow",
      "pr_number": 59097,
      "file_path": "providers/cncf/kubernetes/src/airflow/providers/cncf/kubernetes/operators/pod.py",
      "line": 1428,
      "side": "RIGHT",
      "diff_hunk": "@@ -1390,6 +1390,17 @@ def _get_most_recent_pod_index(pod_list: list[k8s.V1Pod]) -> int:\n         pod_start_times: list[datetime.datetime] = [\n             pod.to_dict().get(\"status\").get(\"start_time\") for pod in pod_list",
      "comment": "I don\u00b4t think that this case is relevant, because the status field should be handled by Kubernetes API. ",
      "comment_id": 2673878213,
      "user": "Crowiant",
      "created_at": "2026-01-08T20:57:30Z",
      "url": "https://github.com/apache/airflow/pull/59097#discussion_r2673878213"
    },
    {
      "repo": "apache/airflow",
      "pr_number": 59097,
      "file_path": "providers/cncf/kubernetes/tests/unit/cncf/kubernetes/operators/test_pod.py",
      "line": 2284,
      "side": "RIGHT",
      "diff_hunk": "@@ -2199,6 +2199,83 @@ def test_process_duplicate_label_pods__label_patched_if_action_is_not_delete_pod\n         process_pod_deletion_mock.assert_not_called()\n         assert result.metadata.name == pod_2.metadata.name\n \n+    @pytest.mark.parametrize(\n+        \"on_finish_action\", [OnFinishAction.KEEP_POD, OnFinishAction.DELETE_SUCCEEDED_POD]\n+    )\n+    @patch(KUB_OP_PATH.format(\"patch_already_checked\"))\n+    @patch(KUB_OP_PATH.format(\"process_pod_deletion\"))\n+    def test_process_duplicate_label_pods_with_start_time_none(\n+        self,\n+        process_pod_deletion_mock,\n+        patch_already_checked_mock,\n+        on_finish_action,\n+    ):\n+        now = datetime.datetime.now()\n+        k = KubernetesPodOperator(\n+            namespace=\"default\",\n+            image=\"ubuntu:22.04\",\n+            cmds=[\"bash\", \"-cx\"],\n+            arguments=[\"echo 12\"],\n+            name=\"test\",\n+            task_id=\"task\",\n+            do_xcom_push=False,\n+            reattach_on_restart=False,\n+            on_finish_action=on_finish_action,\n+        )\n+        context = create_context(k)\n+        pod_1 = k.get_or_create_pod(pod_request_obj=k.build_pod_request_obj(context), context=context)\n+        pod_2 = k.get_or_create_pod(pod_request_obj=k.build_pod_request_obj(context), context=context)\n+\n+        pod_1.status = {\"start_time\": None}\n+        pod_2.status = {\"start_time\": None}",
      "comment": "Previous tests use the same way to define the status. ",
      "comment_id": 2673883326,
      "user": "Crowiant",
      "created_at": "2026-01-08T20:59:28Z",
      "url": "https://github.com/apache/airflow/pull/59097#discussion_r2673883326"
    },
    {
      "repo": "apache/airflow",
      "pr_number": 59097,
      "file_path": "providers/cncf/kubernetes/tests/unit/cncf/kubernetes/operators/test_pod.py",
      "line": 2322,
      "side": "RIGHT",
      "diff_hunk": "@@ -2199,6 +2199,83 @@ def test_process_duplicate_label_pods__label_patched_if_action_is_not_delete_pod\n         process_pod_deletion_mock.assert_not_called()\n         assert result.metadata.name == pod_2.metadata.name\n \n+    @pytest.mark.parametrize(\n+        \"on_finish_action\", [OnFinishAction.KEEP_POD, OnFinishAction.DELETE_SUCCEEDED_POD]\n+    )\n+    @patch(KUB_OP_PATH.format(\"patch_already_checked\"))\n+    @patch(KUB_OP_PATH.format(\"process_pod_deletion\"))\n+    def test_process_duplicate_label_pods_with_start_time_none(\n+        self,\n+        process_pod_deletion_mock,\n+        patch_already_checked_mock,\n+        on_finish_action,\n+    ):\n+        now = datetime.datetime.now()\n+        k = KubernetesPodOperator(\n+            namespace=\"default\",\n+            image=\"ubuntu:22.04\",\n+            cmds=[\"bash\", \"-cx\"],\n+            arguments=[\"echo 12\"],\n+            name=\"test\",\n+            task_id=\"task\",\n+            do_xcom_push=False,\n+            reattach_on_restart=False,\n+            on_finish_action=on_finish_action,\n+        )\n+        context = create_context(k)\n+        pod_1 = k.get_or_create_pod(pod_request_obj=k.build_pod_request_obj(context), context=context)\n+        pod_2 = k.get_or_create_pod(pod_request_obj=k.build_pod_request_obj(context), context=context)\n+\n+        pod_1.status = {\"start_time\": None}\n+        pod_2.status = {\"start_time\": None}\n+        pod_1.metadata.creation_timestamp = now\n+        pod_2.metadata.creation_timestamp = now + datetime.timedelta(seconds=60)\n+        pod_2.metadata.labels.update({\"try_number\": \"2\"})\n+\n+        result = k.process_duplicate_label_pods([pod_1, pod_2])\n+\n+        patch_already_checked_mock.assert_called_once_with(pod_1, reraise=False)\n+        process_pod_deletion_mock.assert_not_called()\n+        assert result.metadata.name == pod_2.metadata.name\n+\n+    @pytest.mark.parametrize(\n+        \"on_finish_action\", [OnFinishAction.KEEP_POD, OnFinishAction.DELETE_SUCCEEDED_POD]\n+    )\n+    @patch(KUB_OP_PATH.format(\"patch_already_checked\"))\n+    @patch(KUB_OP_PATH.format(\"process_pod_deletion\"))\n+    def test_process_duplicate_label_pods_with_no_start_time_or_creation_timestamp(\n+        self,\n+        process_pod_deletion_mock,\n+        patch_already_checked_mock,\n+        on_finish_action,\n+    ):\n+        k = KubernetesPodOperator(\n+            namespace=\"default\",\n+            image=\"ubuntu:22.04\",\n+            cmds=[\"bash\", \"-cx\"],\n+            arguments=[\"echo 12\"],\n+            name=\"test\",\n+            task_id=\"task\",\n+            do_xcom_push=False,\n+            reattach_on_restart=False,\n+            on_finish_action=on_finish_action,\n+        )\n+        context = create_context(k)\n+        pod_1 = k.get_or_create_pod(pod_request_obj=k.build_pod_request_obj(context), context=context)\n+        pod_2 = k.get_or_create_pod(pod_request_obj=k.build_pod_request_obj(context), context=context)\n+\n+        pod_1.status = {\"start_time\": None}\n+        pod_2.status = {\"start_time\": None}",
      "comment": "Previous tests use the same way to define the status field.",
      "comment_id": 2673884597,
      "user": "Crowiant",
      "created_at": "2026-01-08T20:59:55Z",
      "url": "https://github.com/apache/airflow/pull/59097#discussion_r2673884597"
    },
    {
      "repo": "apache/airflow",
      "pr_number": 59097,
      "file_path": "providers/cncf/kubernetes/src/airflow/providers/cncf/kubernetes/operators/pod.py",
      "line": 1428,
      "side": "RIGHT",
      "diff_hunk": "@@ -1390,6 +1390,17 @@ def _get_most_recent_pod_index(pod_list: list[k8s.V1Pod]) -> int:\n         pod_start_times: list[datetime.datetime] = [\n             pod.to_dict().get(\"status\").get(\"start_time\") for pod in pod_list",
      "comment": "Do you mean `status` should always be available? In that case you should not use `get()` but `[\"status\"]` instead.",
      "comment_id": 2674304917,
      "user": "uranusjr",
      "created_at": "2026-01-09T00:04:42Z",
      "url": "https://github.com/apache/airflow/pull/59097#discussion_r2674304917"
    },
    {
      "repo": "apache/airflow",
      "pr_number": 59097,
      "file_path": "providers/cncf/kubernetes/src/airflow/providers/cncf/kubernetes/operators/pod.py",
      "line": 1439,
      "side": "RIGHT",
      "diff_hunk": "@@ -1390,6 +1390,17 @@ def _get_most_recent_pod_index(pod_list: list[k8s.V1Pod]) -> int:\n         pod_start_times: list[datetime.datetime] = [\n             pod.to_dict().get(\"status\").get(\"start_time\") for pod in pod_list\n         ]\n+        if not all(pod_start_times):\n+            pod_start_times: list[datetime.datetime] = [  # type: ignore[no-redef]\n+                pod_start_time\n+                if (\n+                    pod_start_time := pod.to_dict()\n+                    .get(\"metadata\", {})\n+                    .get(\"creation_timestamp\", datetime.datetime.now(tz=datetime.timezone.utc))\n+                )\n+                else datetime.datetime.now(tz=datetime.timezone.utc)",
      "comment": "Do you mean the value to `\"create_timestamp\"` could contain None? That does not feel right to me.",
      "comment_id": 2674306609,
      "user": "uranusjr",
      "created_at": "2026-01-09T00:05:52Z",
      "url": "https://github.com/apache/airflow/pull/59097#discussion_r2674306609"
    },
    {
      "repo": "apache/airflow",
      "pr_number": 59097,
      "file_path": "providers/cncf/kubernetes/tests/unit/cncf/kubernetes/operators/test_pod.py",
      "line": 2284,
      "side": "RIGHT",
      "diff_hunk": "@@ -2199,6 +2199,83 @@ def test_process_duplicate_label_pods__label_patched_if_action_is_not_delete_pod\n         process_pod_deletion_mock.assert_not_called()\n         assert result.metadata.name == pod_2.metadata.name\n \n+    @pytest.mark.parametrize(\n+        \"on_finish_action\", [OnFinishAction.KEEP_POD, OnFinishAction.DELETE_SUCCEEDED_POD]\n+    )\n+    @patch(KUB_OP_PATH.format(\"patch_already_checked\"))\n+    @patch(KUB_OP_PATH.format(\"process_pod_deletion\"))\n+    def test_process_duplicate_label_pods_with_start_time_none(\n+        self,\n+        process_pod_deletion_mock,\n+        patch_already_checked_mock,\n+        on_finish_action,\n+    ):\n+        now = datetime.datetime.now()\n+        k = KubernetesPodOperator(\n+            namespace=\"default\",\n+            image=\"ubuntu:22.04\",\n+            cmds=[\"bash\", \"-cx\"],\n+            arguments=[\"echo 12\"],\n+            name=\"test\",\n+            task_id=\"task\",\n+            do_xcom_push=False,\n+            reattach_on_restart=False,\n+            on_finish_action=on_finish_action,\n+        )\n+        context = create_context(k)\n+        pod_1 = k.get_or_create_pod(pod_request_obj=k.build_pod_request_obj(context), context=context)\n+        pod_2 = k.get_or_create_pod(pod_request_obj=k.build_pod_request_obj(context), context=context)\n+\n+        pod_1.status = {\"start_time\": None}\n+        pod_2.status = {\"start_time\": None}",
      "comment": "I\u2019d argue other tests should use this pattern too.",
      "comment_id": 2674307959,
      "user": "uranusjr",
      "created_at": "2026-01-09T00:06:51Z",
      "url": "https://github.com/apache/airflow/pull/59097#discussion_r2674307959"
    },
    {
      "repo": "apache/airflow",
      "pr_number": 59097,
      "file_path": "providers/cncf/kubernetes/src/airflow/providers/cncf/kubernetes/operators/pod.py",
      "line": 1428,
      "side": "RIGHT",
      "diff_hunk": "@@ -1390,6 +1390,17 @@ def _get_most_recent_pod_index(pod_list: list[k8s.V1Pod]) -> int:\n         pod_start_times: list[datetime.datetime] = [\n             pod.to_dict().get(\"status\").get(\"start_time\") for pod in pod_list",
      "comment": "Generally I agree with TP, but in any case it seems out of the scope of this PR :)",
      "comment_id": 2678782503,
      "user": "shahar1",
      "created_at": "2026-01-10T16:05:34Z",
      "url": "https://github.com/apache/airflow/pull/59097#discussion_r2678782503"
    },
    {
      "repo": "apache/airflow",
      "pr_number": 59097,
      "file_path": "providers/cncf/kubernetes/src/airflow/providers/cncf/kubernetes/operators/pod.py",
      "line": 1439,
      "side": "RIGHT",
      "diff_hunk": "@@ -1390,6 +1390,17 @@ def _get_most_recent_pod_index(pod_list: list[k8s.V1Pod]) -> int:\n         pod_start_times: list[datetime.datetime] = [\n             pod.to_dict().get(\"status\").get(\"start_time\") for pod in pod_list\n         ]\n+        if not all(pod_start_times):\n+            pod_start_times: list[datetime.datetime] = [  # type: ignore[no-redef]\n+                pod_start_time\n+                if (\n+                    pod_start_time := pod.to_dict()\n+                    .get(\"metadata\", {})\n+                    .get(\"creation_timestamp\", datetime.datetime.now(tz=datetime.timezone.utc))\n+                )\n+                else datetime.datetime.now(tz=datetime.timezone.utc)",
      "comment": "If `creation_timestamp` is not in `metadata`, it will return `datetime.datetime.now()` due to the `.get(..., datetime.datetime.now(...)).` - not due to the `if`.\nThe `else` statement seems to be unreachable (because the latter `get` always returns not-`None`).",
      "comment_id": 2678792511,
      "user": "shahar1",
      "created_at": "2026-01-10T16:18:36Z",
      "url": "https://github.com/apache/airflow/pull/59097#discussion_r2678792511"
    },
    {
      "repo": "apache/airflow",
      "pr_number": 59097,
      "file_path": "providers/cncf/kubernetes/tests/unit/cncf/kubernetes/operators/test_pod.py",
      "line": 2284,
      "side": "RIGHT",
      "diff_hunk": "@@ -2199,6 +2199,83 @@ def test_process_duplicate_label_pods__label_patched_if_action_is_not_delete_pod\n         process_pod_deletion_mock.assert_not_called()\n         assert result.metadata.name == pod_2.metadata.name\n \n+    @pytest.mark.parametrize(\n+        \"on_finish_action\", [OnFinishAction.KEEP_POD, OnFinishAction.DELETE_SUCCEEDED_POD]\n+    )\n+    @patch(KUB_OP_PATH.format(\"patch_already_checked\"))\n+    @patch(KUB_OP_PATH.format(\"process_pod_deletion\"))\n+    def test_process_duplicate_label_pods_with_start_time_none(\n+        self,\n+        process_pod_deletion_mock,\n+        patch_already_checked_mock,\n+        on_finish_action,\n+    ):\n+        now = datetime.datetime.now()\n+        k = KubernetesPodOperator(\n+            namespace=\"default\",\n+            image=\"ubuntu:22.04\",\n+            cmds=[\"bash\", \"-cx\"],\n+            arguments=[\"echo 12\"],\n+            name=\"test\",\n+            task_id=\"task\",\n+            do_xcom_push=False,\n+            reattach_on_restart=False,\n+            on_finish_action=on_finish_action,\n+        )\n+        context = create_context(k)\n+        pod_1 = k.get_or_create_pod(pod_request_obj=k.build_pod_request_obj(context), context=context)\n+        pod_2 = k.get_or_create_pod(pod_request_obj=k.build_pod_request_obj(context), context=context)\n+\n+        pod_1.status = {\"start_time\": None}\n+        pod_2.status = {\"start_time\": None}",
      "comment": "I agree with TP, but I wouldn't be too picky about it tbh",
      "comment_id": 2678794196,
      "user": "shahar1",
      "created_at": "2026-01-10T16:20:39Z",
      "url": "https://github.com/apache/airflow/pull/59097#discussion_r2678794196"
    },
    {
      "repo": "apache/airflow",
      "pr_number": 59097,
      "file_path": "providers/cncf/kubernetes/src/airflow/providers/cncf/kubernetes/operators/pod.py",
      "line": 1433,
      "side": "RIGHT",
      "diff_hunk": "@@ -1422,12 +1422,21 @@ def process_duplicate_label_pods(self, pod_list: list[k8s.V1Pod]) -> k8s.V1Pod:\n             self.process_pod_deletion(old_pod)\n         return new_pod\n \n-    @staticmethod\n-    def _get_most_recent_pod_index(pod_list: list[k8s.V1Pod]) -> int:\n+    def _get_most_recent_pod_index(self, pod_list: list[k8s.V1Pod]) -> int:\n         \"\"\"Loop through a list of V1Pod objects and get the index of the most recent one.\"\"\"\n         pod_start_times: list[datetime.datetime] = [\n             pod.to_dict().get(\"status\").get(\"start_time\") for pod in pod_list\n         ]\n+        if not all(pod_start_times):\n+            self.log.info(\n+                \"Some of the start_time values are None, switch to creation_timestamp to choose most recent pod\"\n+            )",
      "comment": "```suggestion\n            self.log.info(\n                \"Unable to determine most recent pod using start_time (some pods have not started yet). Falling back to creation_timestamp from pod metadata.\"\n            )\n```",
      "comment_id": 2683335208,
      "user": "shahar1",
      "created_at": "2026-01-12T18:06:23Z",
      "url": "https://github.com/apache/airflow/pull/59097#discussion_r2683335208"
    },
    {
      "repo": "apache/airflow",
      "pr_number": 58547,
      "file_path": "helm-tests/tests/helm_tests/airflow_core/test_worker.py",
      "line": 1522,
      "side": "RIGHT",
      "diff_hunk": "@@ -1519,7 +1519,7 @@ def test_worker_template_storage_class_name(self, workers_values):\n             ({\"celery\": {\"replicas\": 2}}, 2),\n             ({\"celery\": {\"replicas\": None}}, 1),\n             ({\"replicas\": 2, \"celery\": {\"replicas\": 3}}, 3),\n-            ({\"replicas\": 2, \"celery\": {\"replicas\": None}}, 2),\n+            ({\"replicas\": 2, \"celery\": {\"replicas\": 2}}, 2),",
      "comment": "With moving from `workers.replicas` to `workers.celery.replicas`, we want to make sure that when users unset the `workers.celery.replicas` field, the behaviour will be as in previous releases (because we changed how chart behaves in replicas handling). Why was this change made?\r\n\r\nI see now locally that this was changed as the default behaviour was changed. `workers.replicas`, if `workers.celery.replicas` is unset, does't change the value of replicas. I think it should be fixed in the template logic, not in the test case itself",
      "comment_id": 2683383930,
      "user": "Miretpl",
      "created_at": "2026-01-12T18:19:57Z",
      "url": "https://github.com/apache/airflow/pull/58547#discussion_r2683383930"
    },
    {
      "repo": "apache/airflow",
      "pr_number": 58547,
      "file_path": "helm-tests/tests/helm_tests/airflow_core/test_worker.py",
      "line": 1522,
      "side": "RIGHT",
      "diff_hunk": "@@ -1519,7 +1519,7 @@ def test_worker_template_storage_class_name(self, workers_values):\n             ({\"celery\": {\"replicas\": 2}}, 2),\n             ({\"celery\": {\"replicas\": None}}, 1),\n             ({\"replicas\": 2, \"celery\": {\"replicas\": 3}}, 3),\n-            ({\"replicas\": 2, \"celery\": {\"replicas\": None}}, 2),\n+            ({\"replicas\": 2, \"celery\": {\"replicas\": 2}}, 2),",
      "comment": "I think I've managed to fix it. @glennhsh, could you do a review of the change https://github.com/apache/airflow/pull/60420? For making sure that `workers.celery.sets` are working correctly, I've only used the current unit tests",
      "comment_id": 2683506961,
      "user": "Miretpl",
      "created_at": "2026-01-12T18:57:55Z",
      "url": "https://github.com/apache/airflow/pull/58547#discussion_r2683506961"
    },
    {
      "repo": "apache/airflow",
      "pr_number": 58852,
      "file_path": "airflow-core/src/airflow/dag_processing/collection.py",
      "line": 543,
      "side": "RIGHT",
      "diff_hunk": "@@ -540,6 +540,7 @@ def update_dags(\n             dm.timetable_description = dag.timetable.description\n             dm.fail_fast = dag.fail_fast if dag.fail_fast is not None else False\n \n+            dm.timetable_type = dag.timetable.type_name",
      "comment": "Would it be better to move the line under `540`? As line `539, 540` are both realted with Timetable.",
      "comment_id": 2575426961,
      "user": "jason810496",
      "created_at": "2025-12-01T02:06:48Z",
      "url": "https://github.com/apache/airflow/pull/58852#discussion_r2575426961"
    },
    {
      "repo": "apache/airflow",
      "pr_number": 58852,
      "file_path": "airflow-core/src/airflow/api_fastapi/core_api/routes/public/dags.py",
      "line": 135,
      "side": "RIGHT",
      "diff_hunk": "@@ -129,6 +129,10 @@ def get_dags(\n     readable_dags_filter: ReadableDagsFilterDep,\n     session: SessionDep,\n     is_favorite: QueryFavoriteFilter,\n+    timetable_type: Annotated[\n+        FilterParam[list[str] | None],\n+        Depends(filter_param_factory(DagModel.timetable_type, list[str], FilterOptionEnum.IN)),\n+    ],",
      "comment": "How about calling this simply `timetable`? (No strong preference)",
      "comment_id": 2609900187,
      "user": "uranusjr",
      "created_at": "2025-12-11T09:45:48Z",
      "url": "https://github.com/apache/airflow/pull/58852#discussion_r2609900187"
    },
    {
      "repo": "apache/airflow",
      "pr_number": 58852,
      "file_path": "airflow-core/src/airflow/timetables/base.py",
      "line": 264,
      "side": "RIGHT",
      "diff_hunk": "@@ -206,6 +206,34 @@ def summary(self) -> str:\n         \"\"\"\n         return type(self).__name__\n \n+    @property\n+    def type_name(self) -> str:\n+        \"\"\"\n+        This is primarily intended for filtering dags based on timetable type.\n+\n+        For built-in timetables (defined in airflow.timetables or\n+        airflow.sdk.definitions.timetables), this returns the class name only.\n+        For custom timetables (user-defined via plugins), this returns the full\n+        import path to avoid confusion between multiple implementations with the\n+        same class name.\n+\n+        For example, built-in timetables return:\n+        ``\"NullTimetable\"`` or ``\"CronDataIntervalTimetable\"``\n+        while custom timetables return the full path:\n+        ``\"my_company.timetables.CustomTimetable\"``\n+        \"\"\"\n+        module = self.__class__.__module__\n+        class_name = self.__class__.__name__\n+\n+        # Built-in timetables from Core or SDK use class name only\n+        if module.startswith(\"airflow.timetables.\") or module.startswith(\n+            \"airflow.sdk.definitions.timetables.\"\n+        ):\n+            return class_name",
      "comment": "This would not work for types in `airflow.sdk.definitions.timetables` since they don\u2019t inherit from this class. I also feel there\u2019s probably a better way to do this than string manipulation (which can break too easily if we move the classes around).",
      "comment_id": 2609906840,
      "user": "uranusjr",
      "created_at": "2025-12-11T09:47:46Z",
      "url": "https://github.com/apache/airflow/pull/58852#discussion_r2609906840"
    },
    {
      "repo": "apache/airflow",
      "pr_number": 58852,
      "file_path": "airflow-core/src/airflow/timetables/base.py",
      "line": 264,
      "side": "RIGHT",
      "diff_hunk": "@@ -206,6 +206,34 @@ def summary(self) -> str:\n         \"\"\"\n         return type(self).__name__\n \n+    @property\n+    def type_name(self) -> str:\n+        \"\"\"\n+        This is primarily intended for filtering dags based on timetable type.\n+\n+        For built-in timetables (defined in airflow.timetables or\n+        airflow.sdk.definitions.timetables), this returns the class name only.\n+        For custom timetables (user-defined via plugins), this returns the full\n+        import path to avoid confusion between multiple implementations with the\n+        same class name.\n+\n+        For example, built-in timetables return:\n+        ``\"NullTimetable\"`` or ``\"CronDataIntervalTimetable\"``\n+        while custom timetables return the full path:\n+        ``\"my_company.timetables.CustomTimetable\"``\n+        \"\"\"\n+        module = self.__class__.__module__\n+        class_name = self.__class__.__name__\n+\n+        # Built-in timetables from Core or SDK use class name only\n+        if module.startswith(\"airflow.timetables.\") or module.startswith(\n+            \"airflow.sdk.definitions.timetables.\"\n+        ):\n+            return class_name",
      "comment": "> This would not work for types in `airflow.sdk.definitions.timetables` since they don\u2019t inherit from this class. I also feel there\u2019s probably a better way to do this than string manipulation (which can break too easily if we move the classes around).\r\n\r\nI agree. Relying on raw strings is fragile.\r\n\r\nThanks for the catch regarding the SDK inheritance and the fragility of string parsing.\r\n\r\nI propose moving this logic to a standalone utility function to handle both Core and SDK objects. Regarding the string manipulation, would checking if the class module is within the airflow package be acceptable, or should we maintain a set of allowed built-in modules/classes to be explicit?",
      "comment_id": 2620290777,
      "user": "henry3260",
      "created_at": "2025-12-15T17:39:57Z",
      "url": "https://github.com/apache/airflow/pull/58852#discussion_r2620290777"
    },
    {
      "repo": "apache/airflow",
      "pr_number": 58852,
      "file_path": "airflow-core/src/airflow/api_fastapi/core_api/routes/public/dags.py",
      "line": 135,
      "side": "RIGHT",
      "diff_hunk": "@@ -129,6 +129,10 @@ def get_dags(\n     readable_dags_filter: ReadableDagsFilterDep,\n     session: SessionDep,\n     is_favorite: QueryFavoriteFilter,\n+    timetable_type: Annotated[\n+        FilterParam[list[str] | None],\n+        Depends(filter_param_factory(DagModel.timetable_type, list[str], FilterOptionEnum.IN)),\n+    ],",
      "comment": "Or `timetable_type_name` (probably unnecessarily long?)",
      "comment_id": 2633528601,
      "user": "uranusjr",
      "created_at": "2025-12-19T03:59:29Z",
      "url": "https://github.com/apache/airflow/pull/58852#discussion_r2633528601"
    },
    {
      "repo": "apache/airflow",
      "pr_number": 58852,
      "file_path": "airflow-core/src/airflow/timetables/base.py",
      "line": 264,
      "side": "RIGHT",
      "diff_hunk": "@@ -238,6 +238,34 @@ def summary(self) -> str:\n         \"\"\"\n         return type(self).__name__\n \n+    @property\n+    def type_name(self) -> str:\n+        \"\"\"\n+        This is primarily intended for filtering dags based on timetable type.\n+\n+        For built-in timetables (defined in airflow.timetables or\n+        airflow.sdk.definitions.timetables), this returns the class name only.\n+        For custom timetables (user-defined via plugins), this returns the full\n+        import path to avoid confusion between multiple implementations with the\n+        same class name.\n+\n+        For example, built-in timetables return:\n+        ``\"NullTimetable\"`` or ``\"CronDataIntervalTimetable\"``\n+        while custom timetables return the full path:\n+        ``\"my_company.timetables.CustomTimetable\"``\n+        \"\"\"\n+        module = self.__class__.__module__\n+        class_name = self.__class__.__name__\n+\n+        # Built-in timetables from Core or SDK use class name only\n+        if module.startswith(\"airflow.timetables.\") or module.startswith(\n+            \"airflow.sdk.definitions.timetables.\"\n+        ):\n+            return class_name",
      "comment": "Maybe this can just do `module.startswith(\"airflow.\")`?",
      "comment_id": 2633530369,
      "user": "uranusjr",
      "created_at": "2025-12-19T04:01:02Z",
      "url": "https://github.com/apache/airflow/pull/58852#discussion_r2633530369"
    },
    {
      "repo": "apache/airflow",
      "pr_number": 58852,
      "file_path": "airflow-core/src/airflow/timetables/base.py",
      "line": 258,
      "side": "RIGHT",
      "diff_hunk": "@@ -238,6 +238,34 @@ def summary(self) -> str:\n         \"\"\"\n         return type(self).__name__\n \n+    @property\n+    def type_name(self) -> str:\n+        \"\"\"\n+        This is primarily intended for filtering dags based on timetable type.\n+\n+        For built-in timetables (defined in airflow.timetables or\n+        airflow.sdk.definitions.timetables), this returns the class name only.\n+        For custom timetables (user-defined via plugins), this returns the full\n+        import path to avoid confusion between multiple implementations with the\n+        same class name.\n+\n+        For example, built-in timetables return:\n+        ``\"NullTimetable\"`` or ``\"CronDataIntervalTimetable\"``\n+        while custom timetables return the full path:\n+        ``\"my_company.timetables.CustomTimetable\"``\n+        \"\"\"\n+        module = self.__class__.__module__\n+        class_name = self.__class__.__name__",
      "comment": "We have a helper for this `qualname`. Not exactly the same, but should be equivalent enough for this purpose.",
      "comment_id": 2633531539,
      "user": "uranusjr",
      "created_at": "2025-12-19T04:02:02Z",
      "url": "https://github.com/apache/airflow/pull/58852#discussion_r2633531539"
    },
    {
      "repo": "apache/airflow",
      "pr_number": 58852,
      "file_path": "airflow-core/src/airflow/timetables/base.py",
      "line": 264,
      "side": "RIGHT",
      "diff_hunk": "@@ -238,6 +238,34 @@ def summary(self) -> str:\n         \"\"\"\n         return type(self).__name__\n \n+    @property\n+    def type_name(self) -> str:\n+        \"\"\"\n+        This is primarily intended for filtering dags based on timetable type.\n+\n+        For built-in timetables (defined in airflow.timetables or\n+        airflow.sdk.definitions.timetables), this returns the class name only.\n+        For custom timetables (user-defined via plugins), this returns the full\n+        import path to avoid confusion between multiple implementations with the\n+        same class name.\n+\n+        For example, built-in timetables return:\n+        ``\"NullTimetable\"`` or ``\"CronDataIntervalTimetable\"``\n+        while custom timetables return the full path:\n+        ``\"my_company.timetables.CustomTimetable\"``\n+        \"\"\"\n+        module = self.__class__.__module__\n+        class_name = self.__class__.__name__\n+\n+        # Built-in timetables from Core or SDK use class name only\n+        if module.startswith(\"airflow.timetables.\") or module.startswith(\n+            \"airflow.sdk.definitions.timetables.\"\n+        ):\n+            return class_name",
      "comment": "> Maybe this can just do `module.startswith(\"airflow.\")`?\r\n\r\nIt is not recommended to change this to `module.startswith('airflow.')`, as it would treat all `airflow.*` modules (including `airflow.providers.*` and third-party/custom modules) as 'built-in'. This would make it impossible to distinguish between Timetable classes with the same name. WDYT?",
      "comment_id": 2653065892,
      "user": "henry3260",
      "created_at": "2025-12-30T13:57:31Z",
      "url": "https://github.com/apache/airflow/pull/58852#discussion_r2653065892"
    },
    {
      "repo": "apache/airflow",
      "pr_number": 58852,
      "file_path": "airflow-core/src/airflow/timetables/base.py",
      "line": 258,
      "side": "RIGHT",
      "diff_hunk": "@@ -238,6 +238,34 @@ def summary(self) -> str:\n         \"\"\"\n         return type(self).__name__\n \n+    @property\n+    def type_name(self) -> str:\n+        \"\"\"\n+        This is primarily intended for filtering dags based on timetable type.\n+\n+        For built-in timetables (defined in airflow.timetables or\n+        airflow.sdk.definitions.timetables), this returns the class name only.\n+        For custom timetables (user-defined via plugins), this returns the full\n+        import path to avoid confusion between multiple implementations with the\n+        same class name.\n+\n+        For example, built-in timetables return:\n+        ``\"NullTimetable\"`` or ``\"CronDataIntervalTimetable\"``\n+        while custom timetables return the full path:\n+        ``\"my_company.timetables.CustomTimetable\"``\n+        \"\"\"\n+        module = self.__class__.__module__\n+        class_name = self.__class__.__name__",
      "comment": "> We have a helper for this `qualname`. Not exactly the same, but should be equivalent enough for this purpose.\r\n\r\nApplied!",
      "comment_id": 2653800394,
      "user": "henry3260",
      "created_at": "2025-12-30T20:03:56Z",
      "url": "https://github.com/apache/airflow/pull/58852#discussion_r2653800394"
    },
    {
      "repo": "apache/airflow",
      "pr_number": 58852,
      "file_path": "airflow-core/src/airflow/timetables/base.py",
      "line": 264,
      "side": "RIGHT",
      "diff_hunk": "@@ -238,6 +238,34 @@ def summary(self) -> str:\n         \"\"\"\n         return type(self).__name__\n \n+    @property\n+    def type_name(self) -> str:\n+        \"\"\"\n+        This is primarily intended for filtering dags based on timetable type.\n+\n+        For built-in timetables (defined in airflow.timetables or\n+        airflow.sdk.definitions.timetables), this returns the class name only.\n+        For custom timetables (user-defined via plugins), this returns the full\n+        import path to avoid confusion between multiple implementations with the\n+        same class name.\n+\n+        For example, built-in timetables return:\n+        ``\"NullTimetable\"`` or ``\"CronDataIntervalTimetable\"``\n+        while custom timetables return the full path:\n+        ``\"my_company.timetables.CustomTimetable\"``\n+        \"\"\"\n+        module = self.__class__.__module__\n+        class_name = self.__class__.__name__\n+\n+        # Built-in timetables from Core or SDK use class name only\n+        if module.startswith(\"airflow.timetables.\") or module.startswith(\n+            \"airflow.sdk.definitions.timetables.\"\n+        ):\n+            return class_name",
      "comment": "> as it would treat all airflow.* modules (including airflow.providers.* and third-party/custom modules) as 'built-in'. \r\n\r\nMake sense to me.",
      "comment_id": 2660136092,
      "user": "jason810496",
      "created_at": "2026-01-05T02:29:53Z",
      "url": "https://github.com/apache/airflow/pull/58852#discussion_r2660136092"
    },
    {
      "repo": "apache/airflow",
      "pr_number": 58852,
      "file_path": "airflow-core/src/airflow/models/dag.py",
      "line": 367,
      "side": "RIGHT",
      "diff_hunk": "@@ -365,6 +365,8 @@ class DagModel(Base):\n     timetable_summary: Mapped[str | None] = mapped_column(Text, nullable=True)\n     # Timetable description\n     timetable_description: Mapped[str | None] = mapped_column(String(1000), nullable=True)\n+    # Timetable Type\n+    timetable_type: Mapped[str | None] = mapped_column(String(255), nullable=True)",
      "comment": "It seems we could set the type as `str` instead of `str | None`, as we can ensure `dm.timetable_type` will not be none while dag_processing. Additionally, the `type_name` property will never be `None`.\r\n\r\nhttps://github.com/apache/airflow/pull/58852/changes#diff-8640613973be948ed8c50ee1eb85cb1f8f3f18df7c17b54057b550142bc4f133R540",
      "comment_id": 2660138201,
      "user": "jason810496",
      "created_at": "2026-01-05T02:31:57Z",
      "url": "https://github.com/apache/airflow/pull/58852#discussion_r2660138201"
    },
    {
      "repo": "apache/airflow",
      "pr_number": 58852,
      "file_path": "airflow-core/src/airflow/models/dag.py",
      "line": 367,
      "side": "RIGHT",
      "diff_hunk": "@@ -363,6 +363,8 @@ class DagModel(Base):\n     timetable_summary: Mapped[str | None] = mapped_column(Text, nullable=True)\n     # Timetable description\n     timetable_description: Mapped[str | None] = mapped_column(String(1000), nullable=True)\n+    # Timetable Type\n+    timetable_type: Mapped[str] = mapped_column(String(255), nullable=False, server_default=\"\")",
      "comment": "The nullable definition here is now inconsistent between the table spec which is being used when the schema is freshly created and the alembic migration. Migration allows to have Nullable-values. This would be inconsistent.\n\nI understand that during migration we can not (easily) de-serialize existing Dags and fill the value for I understand that during migration time we can fill it. It will be filled implicitly with then next Dag parsing during running post-migration.\n\nTherefore I propose to fill the value during migration with a placeholder so that the field is not-nullable and filled and assume it is updated on next Dag parsing.\n\nI'd propose _not_ to define a server default, because the field should be filled by Dag parser (forced).\n```suggestion\n    timetable_type: Mapped[str] = mapped_column(String(255), nullable=False)\n```",
      "comment_id": 2660460651,
      "user": "jscheffl",
      "created_at": "2026-01-05T06:51:55Z",
      "url": "https://github.com/apache/airflow/pull/58852#discussion_r2660460651"
    },
    {
      "repo": "apache/airflow",
      "pr_number": 58852,
      "file_path": "airflow-core/src/airflow/migrations/versions/0097_3_2_0_add_timetable_type_to_dag_table_for_.py",
      "line": 46,
      "side": "RIGHT",
      "diff_hunk": "@@ -0,0 +1,65 @@\n+#\n+# Licensed to the Apache Software Foundation (ASF) under one\n+# or more contributor license agreements.  See the NOTICE file\n+# distributed with this work for additional information\n+# regarding copyright ownership.  The ASF licenses this file\n+# to you under the Apache License, Version 2.0 (the\n+# \"License\"); you may not use this file except in compliance\n+# with the License.  You may obtain a copy of the License at\n+#\n+#   http://www.apache.org/licenses/LICENSE-2.0\n+#\n+# Unless required by applicable law or agreed to in writing,\n+# software distributed under the License is distributed on an\n+# \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+# KIND, either express or implied.  See the License for the\n+# specific language governing permissions and limitations\n+# under the License.\n+\n+\"\"\"\n+add timetable_type to dag table for filtering.\n+\n+Revision ID: e79fc784f145\n+Revises: c47f2e1ab9d4\n+Create Date: 2026-01-04 14:36:04.648869\n+\n+\"\"\"\n+\n+from __future__ import annotations\n+\n+import sqlalchemy as sa\n+from alembic import op\n+\n+# revision identifiers, used by Alembic.\n+revision = \"e79fc784f145\"\n+down_revision = \"c47f2e1ab9d4\"\n+branch_labels = None\n+depends_on = None\n+airflow_version = \"3.2.0\"\n+\n+\n+def upgrade():\n+    \"\"\"Apply add timetable_type to dag table for filtering.\"\"\"\n+    # ### commands auto generated by Alembic - please adjust! ###\n+    with op.batch_alter_table(\"dag\", schema=None) as batch_op:\n+        # Add column as nullable first to allow filling existing rows\n+        batch_op.add_column(sa.Column(\"timetable_type\", sa.String(length=255), nullable=True))",
      "comment": "...but alongside with https://github.com/apache/airflow/pull/58852#discussion_r2660460651 I was referring to the inconsistency that the column is defined nullable in migration and if table is created fresh it is non-nullable. This still inconsistent.\n```suggestion\n        batch_op.add_column(sa.Column(\"timetable_type\", sa.String(length=255)))\n```",
      "comment_id": 2661428496,
      "user": "jscheffl",
      "created_at": "2026-01-05T13:01:52Z",
      "url": "https://github.com/apache/airflow/pull/58852#discussion_r2661428496"
    },
    {
      "repo": "apache/airflow",
      "pr_number": 58852,
      "file_path": "airflow-core/src/airflow/migrations/versions/0097_3_2_0_add_timetable_type_to_dag_table_for_.py",
      "line": 46,
      "side": "RIGHT",
      "diff_hunk": "@@ -0,0 +1,65 @@\n+#\n+# Licensed to the Apache Software Foundation (ASF) under one\n+# or more contributor license agreements.  See the NOTICE file\n+# distributed with this work for additional information\n+# regarding copyright ownership.  The ASF licenses this file\n+# to you under the Apache License, Version 2.0 (the\n+# \"License\"); you may not use this file except in compliance\n+# with the License.  You may obtain a copy of the License at\n+#\n+#   http://www.apache.org/licenses/LICENSE-2.0\n+#\n+# Unless required by applicable law or agreed to in writing,\n+# software distributed under the License is distributed on an\n+# \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+# KIND, either express or implied.  See the License for the\n+# specific language governing permissions and limitations\n+# under the License.\n+\n+\"\"\"\n+add timetable_type to dag table for filtering.\n+\n+Revision ID: e79fc784f145\n+Revises: c47f2e1ab9d4\n+Create Date: 2026-01-04 14:36:04.648869\n+\n+\"\"\"\n+\n+from __future__ import annotations\n+\n+import sqlalchemy as sa\n+from alembic import op\n+\n+# revision identifiers, used by Alembic.\n+revision = \"e79fc784f145\"\n+down_revision = \"c47f2e1ab9d4\"\n+branch_labels = None\n+depends_on = None\n+airflow_version = \"3.2.0\"\n+\n+\n+def upgrade():\n+    \"\"\"Apply add timetable_type to dag table for filtering.\"\"\"\n+    # ### commands auto generated by Alembic - please adjust! ###\n+    with op.batch_alter_table(\"dag\", schema=None) as batch_op:\n+        # Add column as nullable first to allow filling existing rows\n+        batch_op.add_column(sa.Column(\"timetable_type\", sa.String(length=255), nullable=True))",
      "comment": "...or explicit\n```suggestion\n        batch_op.add_column(sa.Column(\"timetable_type\", sa.String(length=255), nullable=False))\n```",
      "comment_id": 2661429320,
      "user": "jscheffl",
      "created_at": "2026-01-05T13:02:11Z",
      "url": "https://github.com/apache/airflow/pull/58852#discussion_r2661429320"
    },
    {
      "repo": "apache/airflow",
      "pr_number": 58852,
      "file_path": "airflow-core/src/airflow/migrations/versions/0097_3_2_0_add_timetable_type_to_dag_table_for_.py",
      "line": 46,
      "side": "RIGHT",
      "diff_hunk": "@@ -0,0 +1,65 @@\n+#\n+# Licensed to the Apache Software Foundation (ASF) under one\n+# or more contributor license agreements.  See the NOTICE file\n+# distributed with this work for additional information\n+# regarding copyright ownership.  The ASF licenses this file\n+# to you under the Apache License, Version 2.0 (the\n+# \"License\"); you may not use this file except in compliance\n+# with the License.  You may obtain a copy of the License at\n+#\n+#   http://www.apache.org/licenses/LICENSE-2.0\n+#\n+# Unless required by applicable law or agreed to in writing,\n+# software distributed under the License is distributed on an\n+# \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+# KIND, either express or implied.  See the License for the\n+# specific language governing permissions and limitations\n+# under the License.\n+\n+\"\"\"\n+add timetable_type to dag table for filtering.\n+\n+Revision ID: e79fc784f145\n+Revises: c47f2e1ab9d4\n+Create Date: 2026-01-04 14:36:04.648869\n+\n+\"\"\"\n+\n+from __future__ import annotations\n+\n+import sqlalchemy as sa\n+from alembic import op\n+\n+# revision identifiers, used by Alembic.\n+revision = \"e79fc784f145\"\n+down_revision = \"c47f2e1ab9d4\"\n+branch_labels = None\n+depends_on = None\n+airflow_version = \"3.2.0\"\n+\n+\n+def upgrade():\n+    \"\"\"Apply add timetable_type to dag table for filtering.\"\"\"\n+    # ### commands auto generated by Alembic - please adjust! ###\n+    with op.batch_alter_table(\"dag\", schema=None) as batch_op:\n+        # Add column as nullable first to allow filling existing rows\n+        batch_op.add_column(sa.Column(\"timetable_type\", sa.String(length=255), nullable=False))",
      "comment": "Okay, now as a follow-up you only have a problem if Dags are existing (wich probably are) that a non nullable column will miss values. So most probably you (1) need to add the column nullable, then (2) fill some data which is transient and over-written by next dag parsing cycle and finally (3) make the column non null.",
      "comment_id": 2661646908,
      "user": "jscheffl",
      "created_at": "2026-01-05T14:12:20Z",
      "url": "https://github.com/apache/airflow/pull/58852#discussion_r2661646908"
    },
    {
      "repo": "apache/airflow",
      "pr_number": 58852,
      "file_path": "airflow-core/src/airflow/migrations/versions/0097_3_2_0_add_timetable_type_to_dag_table_for_.py",
      "line": 46,
      "side": "RIGHT",
      "diff_hunk": "@@ -0,0 +1,65 @@\n+#\n+# Licensed to the Apache Software Foundation (ASF) under one\n+# or more contributor license agreements.  See the NOTICE file\n+# distributed with this work for additional information\n+# regarding copyright ownership.  The ASF licenses this file\n+# to you under the Apache License, Version 2.0 (the\n+# \"License\"); you may not use this file except in compliance\n+# with the License.  You may obtain a copy of the License at\n+#\n+#   http://www.apache.org/licenses/LICENSE-2.0\n+#\n+# Unless required by applicable law or agreed to in writing,\n+# software distributed under the License is distributed on an\n+# \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+# KIND, either express or implied.  See the License for the\n+# specific language governing permissions and limitations\n+# under the License.\n+\n+\"\"\"\n+add timetable_type to dag table for filtering.\n+\n+Revision ID: e79fc784f145\n+Revises: c47f2e1ab9d4\n+Create Date: 2026-01-04 14:36:04.648869\n+\n+\"\"\"\n+\n+from __future__ import annotations\n+\n+import sqlalchemy as sa\n+from alembic import op\n+\n+# revision identifiers, used by Alembic.\n+revision = \"e79fc784f145\"\n+down_revision = \"c47f2e1ab9d4\"\n+branch_labels = None\n+depends_on = None\n+airflow_version = \"3.2.0\"\n+\n+\n+def upgrade():\n+    \"\"\"Apply add timetable_type to dag table for filtering.\"\"\"\n+    # ### commands auto generated by Alembic - please adjust! ###\n+    with op.batch_alter_table(\"dag\", schema=None) as batch_op:\n+        # Add column as nullable first to allow filling existing rows\n+        batch_op.add_column(sa.Column(\"timetable_type\", sa.String(length=255), nullable=False))",
      "comment": "> Okay, now as a follow-up you only have a problem if Dags are existing (wich probably are) that a non nullable column will miss values. So most probably you (1) need to add the column nullable, then (2) fill some data which is transient and over-written by next dag parsing cycle and finally (3) make the column non null.\r\n\r\nAppreciate your guidance, I really learned a lot from this.",
      "comment_id": 2662408281,
      "user": "henry3260",
      "created_at": "2026-01-05T18:19:14Z",
      "url": "https://github.com/apache/airflow/pull/58852#discussion_r2662408281"
    },
    {
      "repo": "apache/airflow",
      "pr_number": 58852,
      "file_path": "airflow-core/tests/unit/jobs/test_triggerer_job.py",
      "line": 116,
      "side": "RIGHT",
      "diff_hunk": "@@ -113,6 +113,7 @@ def create_trigger_in_db(session, trigger, operator=None):\n     session.flush()\n \n     dag_model = DagModel(dag_id=\"test_dag\", bundle_name=bundle_name)\n+    dag_model.timetable_type = \"\"",
      "comment": "Rather adding this to constructor like in the file above?\n```suggestion\n    dag_model = DagModel(dag_id=\"test_dag\", bundle_name=bundle_name, timetable_type=\"\")\n```",
      "comment_id": 2664325930,
      "user": "jscheffl",
      "created_at": "2026-01-06T09:49:13Z",
      "url": "https://github.com/apache/airflow/pull/58852#discussion_r2664325930"
    },
    {
      "repo": "apache/airflow",
      "pr_number": 58852,
      "file_path": "providers/fab/tests/unit/fab/auth_manager/test_security.py",
      "line": 1106,
      "side": "RIGHT",
      "diff_hunk": "@@ -1096,7 +1101,9 @@ def test_permissions_work_for_dags_with_dot_in_dagname(\n             role_name=role_name,\n         ) as user:\n             dag1 = DagModel(dag_id=dag_id, bundle_name=bundle_name)\n+            dag1.timetable_type = \"\"\n             dag2 = DagModel(dag_id=dag_id_2, bundle_name=bundle_name)\n+            dag2.timetable_type = \"\"",
      "comment": "...or as this seems to be a tideus job making this for all hundrets of tests.. if no `schedule` attribute is given in DagModel constructor how about setting the timetable_type in the constructor directly such that not all tests need to be adjusted?",
      "comment_id": 2664331789,
      "user": "jscheffl",
      "created_at": "2026-01-06T09:51:12Z",
      "url": "https://github.com/apache/airflow/pull/58852#discussion_r2664331789"
    },
    {
      "repo": "apache/airflow",
      "pr_number": 58852,
      "file_path": "airflow-core/tests/unit/jobs/test_triggerer_job.py",
      "line": 116,
      "side": "RIGHT",
      "diff_hunk": "@@ -113,6 +113,7 @@ def create_trigger_in_db(session, trigger, operator=None):\n     session.flush()\n \n     dag_model = DagModel(dag_id=\"test_dag\", bundle_name=bundle_name)\n+    dag_model.timetable_type = \"\"",
      "comment": "> And the same for below?\r\n\r\nShould We implement it like this: `timetable_type: Mapped[str] = mapped_column(String(255), nullable=False, default=\"\")`? This can add timetable_type to the constructor ",
      "comment_id": 2664369425,
      "user": "henry3260",
      "created_at": "2026-01-06T10:04:22Z",
      "url": "https://github.com/apache/airflow/pull/58852#discussion_r2664369425"
    },
    {
      "repo": "apache/airflow",
      "pr_number": 58852,
      "file_path": "airflow-core/src/airflow/migrations/versions/0097_3_2_0_add_timetable_type_to_dag_table_for_.py",
      "line": 55,
      "side": "RIGHT",
      "diff_hunk": "@@ -0,0 +1,64 @@\n+#\n+# Licensed to the Apache Software Foundation (ASF) under one\n+# or more contributor license agreements.  See the NOTICE file\n+# distributed with this work for additional information\n+# regarding copyright ownership.  The ASF licenses this file\n+# to you under the Apache License, Version 2.0 (the\n+# \"License\"); you may not use this file except in compliance\n+# with the License.  You may obtain a copy of the License at\n+#\n+#   http://www.apache.org/licenses/LICENSE-2.0\n+#\n+# Unless required by applicable law or agreed to in writing,\n+# software distributed under the License is distributed on an\n+# \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+# KIND, either express or implied.  See the License for the\n+# specific language governing permissions and limitations\n+# under the License.\n+\n+\"\"\"\n+add timetable_type to dag table for filtering.\n+\n+Revision ID: e79fc784f145\n+Revises: c47f2e1ab9d4\n+Create Date: 2026-01-04 14:36:04.648869\n+\n+\"\"\"\n+\n+from __future__ import annotations\n+\n+import sqlalchemy as sa\n+from alembic import op\n+\n+# revision identifiers, used by Alembic.\n+revision = \"e79fc784f145\"\n+down_revision = \"c47f2e1ab9d4\"\n+branch_labels = None\n+depends_on = None\n+airflow_version = \"3.2.0\"\n+\n+\n+def upgrade():\n+    \"\"\"Apply add timetable_type to dag table for filtering.\"\"\"\n+    # ### commands auto generated by Alembic - please adjust! ###\n+    # Step 1: Add column as nullable to allow filling existing rows\n+    with op.batch_alter_table(\"dag\", schema=None) as batch_op:\n+        batch_op.add_column(sa.Column(\"timetable_type\", sa.String(length=255)))\n+\n+    # Step 2: Fill existing rows with empty string (transient data, will be overwritten by next DAG parsing)\n+    op.execute(\"UPDATE dag SET timetable_type = '' WHERE timetable_type IS NULL\")\n+\n+    # Step 3: Make the column non-nullable\n+    with op.batch_alter_table(\"dag\", schema=None) as batch_op:\n+        batch_op.alter_column(\"timetable_type\", existing_type=sa.String(length=255), nullable=False)\n+\n+    # ### end Alembic commands ###",
      "comment": "```suggestion\r\n    with op.batch_alter_table(\"dag\", schema=None) as batch_op:\r\n        batch_op.alter_column(\"timetable_type\", existing_type=sa.String(length=255), nullable=False, server_default=\"\")\r\n```\r\n\r\nI think using server_default will suffix. \r\nYou can also remove the comments in the downgrade function",
      "comment_id": 2664955541,
      "user": "ephraimbuddy",
      "created_at": "2026-01-06T13:37:23Z",
      "url": "https://github.com/apache/airflow/pull/58852#discussion_r2664955541"
    },
    {
      "repo": "apache/airflow",
      "pr_number": 58852,
      "file_path": "airflow-core/src/airflow/migrations/versions/0097_3_2_0_add_timetable_type_to_dag_table_for_.py",
      "line": 55,
      "side": "RIGHT",
      "diff_hunk": "@@ -0,0 +1,64 @@\n+#\n+# Licensed to the Apache Software Foundation (ASF) under one\n+# or more contributor license agreements.  See the NOTICE file\n+# distributed with this work for additional information\n+# regarding copyright ownership.  The ASF licenses this file\n+# to you under the Apache License, Version 2.0 (the\n+# \"License\"); you may not use this file except in compliance\n+# with the License.  You may obtain a copy of the License at\n+#\n+#   http://www.apache.org/licenses/LICENSE-2.0\n+#\n+# Unless required by applicable law or agreed to in writing,\n+# software distributed under the License is distributed on an\n+# \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+# KIND, either express or implied.  See the License for the\n+# specific language governing permissions and limitations\n+# under the License.\n+\n+\"\"\"\n+add timetable_type to dag table for filtering.\n+\n+Revision ID: e79fc784f145\n+Revises: c47f2e1ab9d4\n+Create Date: 2026-01-04 14:36:04.648869\n+\n+\"\"\"\n+\n+from __future__ import annotations\n+\n+import sqlalchemy as sa\n+from alembic import op\n+\n+# revision identifiers, used by Alembic.\n+revision = \"e79fc784f145\"\n+down_revision = \"c47f2e1ab9d4\"\n+branch_labels = None\n+depends_on = None\n+airflow_version = \"3.2.0\"\n+\n+\n+def upgrade():\n+    \"\"\"Apply add timetable_type to dag table for filtering.\"\"\"\n+    # ### commands auto generated by Alembic - please adjust! ###\n+    # Step 1: Add column as nullable to allow filling existing rows\n+    with op.batch_alter_table(\"dag\", schema=None) as batch_op:\n+        batch_op.add_column(sa.Column(\"timetable_type\", sa.String(length=255)))\n+\n+    # Step 2: Fill existing rows with empty string (transient data, will be overwritten by next DAG parsing)\n+    op.execute(\"UPDATE dag SET timetable_type = '' WHERE timetable_type IS NULL\")\n+\n+    # Step 3: Make the column non-nullable\n+    with op.batch_alter_table(\"dag\", schema=None) as batch_op:\n+        batch_op.alter_column(\"timetable_type\", existing_type=sa.String(length=255), nullable=False)\n+\n+    # ### end Alembic commands ###",
      "comment": "> I think using server_default will suffix. You can also remove the comments in the downgrade function\r\n\r\nI think it should be?\r\n```\r\nwith op.batch_alter_table(\"dag\", schema=None) as batch_op:\r\n    batch_op.add_column(\r\n        sa.Column(\"timetable_type\", sa.String(255), nullable=False, server_default=\"\")\r\n    )\r\n```",
      "comment_id": 2664990822,
      "user": "henry3260",
      "created_at": "2026-01-06T13:49:26Z",
      "url": "https://github.com/apache/airflow/pull/58852#discussion_r2664990822"
    },
    {
      "repo": "apache/airflow",
      "pr_number": 58852,
      "file_path": "airflow-core/src/airflow/migrations/versions/0097_3_2_0_add_timetable_type_to_dag_table_for_.py",
      "line": 55,
      "side": "RIGHT",
      "diff_hunk": "@@ -0,0 +1,64 @@\n+#\n+# Licensed to the Apache Software Foundation (ASF) under one\n+# or more contributor license agreements.  See the NOTICE file\n+# distributed with this work for additional information\n+# regarding copyright ownership.  The ASF licenses this file\n+# to you under the Apache License, Version 2.0 (the\n+# \"License\"); you may not use this file except in compliance\n+# with the License.  You may obtain a copy of the License at\n+#\n+#   http://www.apache.org/licenses/LICENSE-2.0\n+#\n+# Unless required by applicable law or agreed to in writing,\n+# software distributed under the License is distributed on an\n+# \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+# KIND, either express or implied.  See the License for the\n+# specific language governing permissions and limitations\n+# under the License.\n+\n+\"\"\"\n+add timetable_type to dag table for filtering.\n+\n+Revision ID: e79fc784f145\n+Revises: c47f2e1ab9d4\n+Create Date: 2026-01-04 14:36:04.648869\n+\n+\"\"\"\n+\n+from __future__ import annotations\n+\n+import sqlalchemy as sa\n+from alembic import op\n+\n+# revision identifiers, used by Alembic.\n+revision = \"e79fc784f145\"\n+down_revision = \"c47f2e1ab9d4\"\n+branch_labels = None\n+depends_on = None\n+airflow_version = \"3.2.0\"\n+\n+\n+def upgrade():\n+    \"\"\"Apply add timetable_type to dag table for filtering.\"\"\"\n+    # ### commands auto generated by Alembic - please adjust! ###\n+    # Step 1: Add column as nullable to allow filling existing rows\n+    with op.batch_alter_table(\"dag\", schema=None) as batch_op:\n+        batch_op.add_column(sa.Column(\"timetable_type\", sa.String(length=255)))\n+\n+    # Step 2: Fill existing rows with empty string (transient data, will be overwritten by next DAG parsing)\n+    op.execute(\"UPDATE dag SET timetable_type = '' WHERE timetable_type IS NULL\")\n+\n+    # Step 3: Make the column non-nullable\n+    with op.batch_alter_table(\"dag\", schema=None) as batch_op:\n+        batch_op.alter_column(\"timetable_type\", existing_type=sa.String(length=255), nullable=False)\n+\n+    # ### end Alembic commands ###",
      "comment": "@ephraimbuddy But if it is defined with server_default this means the Database engine will always fill the default which effectively makes the field not required. That means if code \"misses\" to fill we have \"bad data\". Not really happy about this. I'd rather prefer a \"fail fast and explicit\" if the field is not filled.\n\n(In terms of votis I'd be a -0 on this, will not block the PR but do not like the style because raises risks in missing consistency in application logic. As it is just a field to filter on UI that will \"just\" raise minor risk of follow-up bugs, no major)",
      "comment_id": 2666087841,
      "user": "jscheffl",
      "created_at": "2026-01-06T19:47:56Z",
      "url": "https://github.com/apache/airflow/pull/58852#discussion_r2666087841"
    },
    {
      "repo": "apache/airflow",
      "pr_number": 58852,
      "file_path": "airflow-core/src/airflow/migrations/versions/0097_3_2_0_add_timetable_type_to_dag_table_for_.py",
      "line": 55,
      "side": "RIGHT",
      "diff_hunk": "@@ -0,0 +1,64 @@\n+#\n+# Licensed to the Apache Software Foundation (ASF) under one\n+# or more contributor license agreements.  See the NOTICE file\n+# distributed with this work for additional information\n+# regarding copyright ownership.  The ASF licenses this file\n+# to you under the Apache License, Version 2.0 (the\n+# \"License\"); you may not use this file except in compliance\n+# with the License.  You may obtain a copy of the License at\n+#\n+#   http://www.apache.org/licenses/LICENSE-2.0\n+#\n+# Unless required by applicable law or agreed to in writing,\n+# software distributed under the License is distributed on an\n+# \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+# KIND, either express or implied.  See the License for the\n+# specific language governing permissions and limitations\n+# under the License.\n+\n+\"\"\"\n+add timetable_type to dag table for filtering.\n+\n+Revision ID: e79fc784f145\n+Revises: c47f2e1ab9d4\n+Create Date: 2026-01-04 14:36:04.648869\n+\n+\"\"\"\n+\n+from __future__ import annotations\n+\n+import sqlalchemy as sa\n+from alembic import op\n+\n+# revision identifiers, used by Alembic.\n+revision = \"e79fc784f145\"\n+down_revision = \"c47f2e1ab9d4\"\n+branch_labels = None\n+depends_on = None\n+airflow_version = \"3.2.0\"\n+\n+\n+def upgrade():\n+    \"\"\"Apply add timetable_type to dag table for filtering.\"\"\"\n+    # ### commands auto generated by Alembic - please adjust! ###\n+    # Step 1: Add column as nullable to allow filling existing rows\n+    with op.batch_alter_table(\"dag\", schema=None) as batch_op:\n+        batch_op.add_column(sa.Column(\"timetable_type\", sa.String(length=255)))\n+\n+    # Step 2: Fill existing rows with empty string (transient data, will be overwritten by next DAG parsing)\n+    op.execute(\"UPDATE dag SET timetable_type = '' WHERE timetable_type IS NULL\")\n+\n+    # Step 3: Make the column non-nullable\n+    with op.batch_alter_table(\"dag\", schema=None) as batch_op:\n+        batch_op.alter_column(\"timetable_type\", existing_type=sa.String(length=255), nullable=False)\n+\n+    # ### end Alembic commands ###",
      "comment": "@henry3260 , the comments there can still be removed. Especially the alembic autogenerated comments",
      "comment_id": 2668687949,
      "user": "ephraimbuddy",
      "created_at": "2026-01-07T14:31:54Z",
      "url": "https://github.com/apache/airflow/pull/58852#discussion_r2668687949"
    },
    {
      "repo": "apache/airflow",
      "pr_number": 58852,
      "file_path": "airflow-core/src/airflow/migrations/versions/0097_3_2_0_add_timetable_type_to_dag_table_for_.py",
      "line": 55,
      "side": "RIGHT",
      "diff_hunk": "@@ -0,0 +1,64 @@\n+#\n+# Licensed to the Apache Software Foundation (ASF) under one\n+# or more contributor license agreements.  See the NOTICE file\n+# distributed with this work for additional information\n+# regarding copyright ownership.  The ASF licenses this file\n+# to you under the Apache License, Version 2.0 (the\n+# \"License\"); you may not use this file except in compliance\n+# with the License.  You may obtain a copy of the License at\n+#\n+#   http://www.apache.org/licenses/LICENSE-2.0\n+#\n+# Unless required by applicable law or agreed to in writing,\n+# software distributed under the License is distributed on an\n+# \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+# KIND, either express or implied.  See the License for the\n+# specific language governing permissions and limitations\n+# under the License.\n+\n+\"\"\"\n+add timetable_type to dag table for filtering.\n+\n+Revision ID: e79fc784f145\n+Revises: c47f2e1ab9d4\n+Create Date: 2026-01-04 14:36:04.648869\n+\n+\"\"\"\n+\n+from __future__ import annotations\n+\n+import sqlalchemy as sa\n+from alembic import op\n+\n+# revision identifiers, used by Alembic.\n+revision = \"e79fc784f145\"\n+down_revision = \"c47f2e1ab9d4\"\n+branch_labels = None\n+depends_on = None\n+airflow_version = \"3.2.0\"\n+\n+\n+def upgrade():\n+    \"\"\"Apply add timetable_type to dag table for filtering.\"\"\"\n+    # ### commands auto generated by Alembic - please adjust! ###\n+    # Step 1: Add column as nullable to allow filling existing rows\n+    with op.batch_alter_table(\"dag\", schema=None) as batch_op:\n+        batch_op.add_column(sa.Column(\"timetable_type\", sa.String(length=255)))\n+\n+    # Step 2: Fill existing rows with empty string (transient data, will be overwritten by next DAG parsing)\n+    op.execute(\"UPDATE dag SET timetable_type = '' WHERE timetable_type IS NULL\")\n+\n+    # Step 3: Make the column non-nullable\n+    with op.batch_alter_table(\"dag\", schema=None) as batch_op:\n+        batch_op.alter_column(\"timetable_type\", existing_type=sa.String(length=255), nullable=False)\n+\n+    # ### end Alembic commands ###",
      "comment": "> @henry3260 , the comments there can still be removed. Especially the alembic autogenerated comments\r\n\r\nApplied!",
      "comment_id": 2669320473,
      "user": "henry3260",
      "created_at": "2026-01-07T17:14:55Z",
      "url": "https://github.com/apache/airflow/pull/58852#discussion_r2669320473"
    },
    {
      "repo": "apache/airflow",
      "pr_number": 59866,
      "file_path": "providers/google/src/airflow/providers/google/cloud/operators/bigquery.py",
      "line": 1096,
      "side": "RIGHT",
      "diff_hunk": "@@ -1091,14 +1091,14 @@ def generate_query(self, hook: BigQueryHook) -> str:\n \n     def execute(self, context: Context):\n         if self.project_id:\n-            self.log.warning(\n+            warnings.warn(\n                 \"The project_id parameter is deprecated, and will be removed in a future release.\"\n-                \" Please use table_project_id instead.\",\n+                \" Please use table_project_id instead.\",AirflowDeprecationWarning",
      "comment": " Google Provider has it's own deprecation mechanism with depraction date - see https://github.com/apache/airflow/blob/main/providers/google/docs/deprecation-policy.rst - cc: @VladaZakharova ",
      "comment_id": 2649663276,
      "user": "potiuk",
      "created_at": "2025-12-28T12:10:31Z",
      "url": "https://github.com/apache/airflow/pull/59866#discussion_r2649663276"
    },
    {
      "repo": "apache/airflow",
      "pr_number": 59866,
      "file_path": "providers/google/src/airflow/providers/google/cloud/operators/bigquery.py",
      "line": 1096,
      "side": "RIGHT",
      "diff_hunk": "@@ -1091,14 +1091,14 @@ def generate_query(self, hook: BigQueryHook) -> str:\n \n     def execute(self, context: Context):\n         if self.project_id:\n-            self.log.warning(\n+            warnings.warn(\n                 \"The project_id parameter is deprecated, and will be removed in a future release.\"\n-                \" Please use table_project_id instead.\",\n+                \" Please use table_project_id instead.\",AirflowDeprecationWarning",
      "comment": "Thanks for pointing out I have read the document and modified it accordingly\r\n",
      "comment_id": 2649729155,
      "user": "KamranImaaz",
      "created_at": "2025-12-28T14:19:39Z",
      "url": "https://github.com/apache/airflow/pull/59866#discussion_r2649729155"
    },
    {
      "repo": "apache/airflow",
      "pr_number": 59866,
      "file_path": "providers/google/src/airflow/providers/google/cloud/operators/bigquery.py",
      "line": 1022,
      "side": "RIGHT",
      "diff_hunk": "@@ -1018,6 +1019,9 @@ class BigQueryGetDataOperator(GoogleCloudBaseOperator, _BigQueryOperatorsEncrypt\n     )\n     ui_color = BigQueryUIColors.QUERY.value\n \n+    @deprecated(planned_removal_date = \"June 30, 2026\", use_instead = \"table_project_id\", ",
      "comment": "I don't think it's going to wrk as expected - it will raise deprecation **always** not only when project_id is used/",
      "comment_id": 2649884646,
      "user": "potiuk",
      "created_at": "2025-12-28T19:28:25Z",
      "url": "https://github.com/apache/airflow/pull/59866#discussion_r2649884646"
    },
    {
      "repo": "apache/airflow",
      "pr_number": 59866,
      "file_path": "providers/google/src/airflow/providers/google/cloud/operators/bigquery.py",
      "line": 1022,
      "side": "RIGHT",
      "diff_hunk": "@@ -1018,6 +1019,9 @@ class BigQueryGetDataOperator(GoogleCloudBaseOperator, _BigQueryOperatorsEncrypt\n     )\n     ui_color = BigQueryUIColors.QUERY.value\n \n+    @deprecated(planned_removal_date = \"June 30, 2026\", use_instead = \"table_project_id\", ",
      "comment": "Hi @potiuk, I checked and learned that @deprecated only works for methods, functions, class. But not an individual parameter. so for parameters it is better to use warnings.warn i guess. Or can you pls suggest me on this",
      "comment_id": 2650221351,
      "user": "KamranImaaz",
      "created_at": "2025-12-29T05:32:23Z",
      "url": "https://github.com/apache/airflow/pull/59866#discussion_r2650221351"
    },
    {
      "repo": "apache/airflow",
      "pr_number": 59866,
      "file_path": "providers/google/src/airflow/providers/google/cloud/operators/bigquery.py",
      "line": 1022,
      "side": "RIGHT",
      "diff_hunk": "@@ -1018,6 +1019,9 @@ class BigQueryGetDataOperator(GoogleCloudBaseOperator, _BigQueryOperatorsEncrypt\n     )\n     ui_color = BigQueryUIColors.QUERY.value\n \n+    @deprecated(planned_removal_date = \"June 30, 2026\", use_instead = \"table_project_id\", ",
      "comment": "Or possibly extract assigning the project to separate method and mark it with deprecated ?",
      "comment_id": 2650645619,
      "user": "potiuk",
      "created_at": "2025-12-29T10:19:44Z",
      "url": "https://github.com/apache/airflow/pull/59866#discussion_r2650645619"
    },
    {
      "repo": "apache/airflow",
      "pr_number": 59866,
      "file_path": "providers/google/src/airflow/providers/google/cloud/operators/bigquery.py",
      "line": 1022,
      "side": "RIGHT",
      "diff_hunk": "@@ -1018,6 +1019,9 @@ class BigQueryGetDataOperator(GoogleCloudBaseOperator, _BigQueryOperatorsEncrypt\n     )\n     ui_color = BigQueryUIColors.QUERY.value\n \n+    @deprecated(planned_removal_date = \"June 30, 2026\", use_instead = \"table_project_id\", ",
      "comment": "Or maybe add/extract a separate context manager from the deprecated decorator and use it ?  ",
      "comment_id": 2650647102,
      "user": "potiuk",
      "created_at": "2025-12-29T10:20:31Z",
      "url": "https://github.com/apache/airflow/pull/59866#discussion_r2650647102"
    },
    {
      "repo": "apache/airflow",
      "pr_number": 59866,
      "file_path": "providers/google/src/airflow/providers/google/cloud/operators/bigquery.py",
      "line": 1022,
      "side": "RIGHT",
      "diff_hunk": "@@ -1018,6 +1019,9 @@ class BigQueryGetDataOperator(GoogleCloudBaseOperator, _BigQueryOperatorsEncrypt\n     )\n     ui_color = BigQueryUIColors.QUERY.value\n \n+    @deprecated(planned_removal_date = \"June 30, 2026\", use_instead = \"table_project_id\", ",
      "comment": "Or maybe add/extract a separate context manager from the deprecated decorator and use it ?  ",
      "comment_id": 2650647185,
      "user": "potiuk",
      "created_at": "2025-12-29T10:20:33Z",
      "url": "https://github.com/apache/airflow/pull/59866#discussion_r2650647185"
    },
    {
      "repo": "apache/airflow",
      "pr_number": 59866,
      "file_path": "providers/google/src/airflow/providers/google/cloud/operators/bigquery.py",
      "line": 1022,
      "side": "RIGHT",
      "diff_hunk": "@@ -1018,6 +1019,9 @@ class BigQueryGetDataOperator(GoogleCloudBaseOperator, _BigQueryOperatorsEncrypt\n     )\n     ui_color = BigQueryUIColors.QUERY.value\n \n+    @deprecated(planned_removal_date = \"June 30, 2026\", use_instead = \"table_project_id\", ",
      "comment": "> Or possibly extract assigning the project to separate method and mark it with deprecated ?\r\n\r\n@potiuk, I\u2019ll extract the project_id to table_project_id assignment into a small helper method and mark it with @deprecated, and call it from execute() when project_id is explicitly used.",
      "comment_id": 2650699946,
      "user": "KamranImaaz",
      "created_at": "2025-12-29T10:47:36Z",
      "url": "https://github.com/apache/airflow/pull/59866#discussion_r2650699946"
    },
    {
      "repo": "apache/airflow",
      "pr_number": 59866,
      "file_path": "providers/google/src/airflow/providers/google/cloud/operators/bigquery.py",
      "line": 1107,
      "side": "RIGHT",
      "diff_hunk": "@@ -1089,17 +1090,21 @@ def generate_query(self, hook: BigQueryHook) -> str:\n         )\n         return query\n \n-    def execute(self, context: Context):\n-        if self.project_id:\n-            self.log.warning(\n-                \"The project_id parameter is deprecated, and will be removed in a future release.\"\n-                \" Please use table_project_id instead.\",\n-            )\n-            if not self.table_project_id:\n-                self.table_project_id = self.project_id\n-            else:\n-                self.log.info(\"Ignoring 'project_id' parameter, as 'table_project_id' is found.\")\n+    \"\"\"Deprecated method to assign project_id to table_project_id.\"\"\"\n \n+    @deprecated(\n+        planned_removal_date=\"June 30, 2026\",\n+        use_instead=\"table_project_id\",\n+        category=AirflowProviderDeprecationWarning,\n+    )\n+    def _assign_project_id(self, project_id: str) -> str:\n+        return project_id\n+\n+    def execute(self, context: Context):\n+        if self.project_id != PROVIDE_PROJECT_ID and not self.table_project_id:\n+            self.table_project_id = self._assign_project_id(self.project_id)\n+        elif self.project_id != PROVIDE_PROJECT_ID and self.table_project_id:\n+            self.log.info(\"The 'project_id' parameter is deprecated. Please use 'table_project_id' instead.\")",
      "comment": "Hello @Kamran-imaz, thank you for your PR!\nFor me it looks like on this row we should have this log message `self.log.info(\"Ignoring 'project_id' parameter, as 'table_project_id' is found.\")` instead of `self.log.info(\"The 'project_id' parameter is deprecated. Please use 'table_project_id' instead.\")`, am I correct?",
      "comment_id": 2657199348,
      "user": "MaksYermak",
      "created_at": "2026-01-02T09:22:00Z",
      "url": "https://github.com/apache/airflow/pull/59866#discussion_r2657199348"
    },
    {
      "repo": "apache/airflow",
      "pr_number": 59866,
      "file_path": "providers/google/src/airflow/providers/google/cloud/operators/bigquery.py",
      "line": 1107,
      "side": "RIGHT",
      "diff_hunk": "@@ -1089,17 +1090,21 @@ def generate_query(self, hook: BigQueryHook) -> str:\n         )\n         return query\n \n-    def execute(self, context: Context):\n-        if self.project_id:\n-            self.log.warning(\n-                \"The project_id parameter is deprecated, and will be removed in a future release.\"\n-                \" Please use table_project_id instead.\",\n-            )\n-            if not self.table_project_id:\n-                self.table_project_id = self.project_id\n-            else:\n-                self.log.info(\"Ignoring 'project_id' parameter, as 'table_project_id' is found.\")\n+    \"\"\"Deprecated method to assign project_id to table_project_id.\"\"\"\n \n+    @deprecated(\n+        planned_removal_date=\"June 30, 2026\",\n+        use_instead=\"table_project_id\",\n+        category=AirflowProviderDeprecationWarning,\n+    )\n+    def _assign_project_id(self, project_id: str) -> str:\n+        return project_id\n+\n+    def execute(self, context: Context):\n+        if self.project_id != PROVIDE_PROJECT_ID and not self.table_project_id:\n+            self.table_project_id = self._assign_project_id(self.project_id)\n+        elif self.project_id != PROVIDE_PROJECT_ID and self.table_project_id:\n+            self.log.info(\"The 'project_id' parameter is deprecated. Please use 'table_project_id' instead.\")",
      "comment": "Thanks for pointing this out, @MaksYermak. I\u2019ll update it.",
      "comment_id": 2657434672,
      "user": "KamranImaaz",
      "created_at": "2026-01-02T10:06:02Z",
      "url": "https://github.com/apache/airflow/pull/59866#discussion_r2657434672"
    },
    {
      "repo": "apache/airflow",
      "pr_number": 59467,
      "file_path": "airflow-core/src/airflow/listeners/spec/taskinstance.py",
      "line": 68,
      "side": "RIGHT",
      "diff_hunk": "@@ -48,3 +48,29 @@ def on_task_instance_failed(\n     error: None | str | BaseException,\n ):\n     \"\"\"Execute when task state changes to FAIL. previous_state can be None.\"\"\"\n+\n+\n+@hookspec\n+def on_task_instance_skipped(\n+    previous_state: TaskInstanceState | None,\n+    task_instance: RuntimeTaskInstance | TaskInstance,\n+):\n+    \"\"\"\n+    Execute when a task instance skips itself by raising AirflowSkipException.\n+\n+    This hook is called only when a task has started execution and then\n+    intentionally skips itself by raising AirflowSkipException.\n+\n+    Note: This does NOT cover tasks skipped by:\n+        - Trigger rules (e.g., upstream failures)\n+        - BranchPythonOperator (tasks not in selected branch)\n+        - ShortCircuitOperator\n+        - Scheduler-level decisions",
      "comment": "```suggestion\n    Note: This function will NOT cover tasks that were skipped by scheduler, before execution began, such as:\n        - Skips due to trigger rules (e.g., upstream failures)\n        - Skips from operators like BranchPythonOperator, ShortCircuitOperator, or similar mechanisms\n        - Any other situation in which the scheduler decides not to schedule a task for execution\n```",
      "comment_id": 2619814945,
      "user": "kacpermuda",
      "created_at": "2025-12-15T15:07:43Z",
      "url": "https://github.com/apache/airflow/pull/59467#discussion_r2619814945"
    },
    {
      "repo": "apache/airflow",
      "pr_number": 59467,
      "file_path": "airflow-core/src/airflow/listeners/spec/taskinstance.py",
      "line": 70,
      "side": "RIGHT",
      "diff_hunk": "@@ -48,3 +48,29 @@ def on_task_instance_failed(\n     error: None | str | BaseException,\n ):\n     \"\"\"Execute when task state changes to FAIL. previous_state can be None.\"\"\"\n+\n+\n+@hookspec\n+def on_task_instance_skipped(\n+    previous_state: TaskInstanceState | None,\n+    task_instance: RuntimeTaskInstance | TaskInstance,\n+):\n+    \"\"\"\n+    Execute when a task instance skips itself by raising AirflowSkipException.\n+\n+    This hook is called only when a task has started execution and then\n+    intentionally skips itself by raising AirflowSkipException.\n+\n+    Note: This does NOT cover tasks skipped by:\n+        - Trigger rules (e.g., upstream failures)\n+        - BranchPythonOperator (tasks not in selected branch)\n+        - ShortCircuitOperator\n+        - Scheduler-level decisions\n+\n+    For comprehensive skip tracking, use DAG-level listeners",
      "comment": "```suggestion\n    For comprehensive tracking of skipped tasks, use DAG-level listeners\n```",
      "comment_id": 2619816175,
      "user": "kacpermuda",
      "created_at": "2025-12-15T15:08:04Z",
      "url": "https://github.com/apache/airflow/pull/59467#discussion_r2619816175"
    },
    {
      "repo": "apache/airflow",
      "pr_number": 59467,
      "file_path": "airflow-core/src/airflow/listeners/spec/taskinstance.py",
      "line": 71,
      "side": "RIGHT",
      "diff_hunk": "@@ -48,3 +48,29 @@ def on_task_instance_failed(\n     error: None | str | BaseException,\n ):\n     \"\"\"Execute when task state changes to FAIL. previous_state can be None.\"\"\"\n+\n+\n+@hookspec\n+def on_task_instance_skipped(\n+    previous_state: TaskInstanceState | None,\n+    task_instance: RuntimeTaskInstance | TaskInstance,\n+):\n+    \"\"\"\n+    Execute when a task instance skips itself by raising AirflowSkipException.\n+\n+    This hook is called only when a task has started execution and then\n+    intentionally skips itself by raising AirflowSkipException.\n+\n+    Note: This does NOT cover tasks skipped by:\n+        - Trigger rules (e.g., upstream failures)\n+        - BranchPythonOperator (tasks not in selected branch)\n+        - ShortCircuitOperator\n+        - Scheduler-level decisions\n+\n+    For comprehensive skip tracking, use DAG-level listeners\n+    (on_dag_run_success/on_dag_run_failed) which provide complete task state.",
      "comment": "```suggestion\n    (on_dag_run_success/on_dag_run_failed) which may have access to all task states.\n```",
      "comment_id": 2619818092,
      "user": "kacpermuda",
      "created_at": "2025-12-15T15:08:32Z",
      "url": "https://github.com/apache/airflow/pull/59467#discussion_r2619818092"
    },
    {
      "repo": "apache/airflow",
      "pr_number": 59467,
      "file_path": "airflow-core/src/airflow/listeners/spec/taskinstance.py",
      "line": 59,
      "side": "RIGHT",
      "diff_hunk": "@@ -48,3 +48,29 @@ def on_task_instance_failed(\n     error: None | str | BaseException,\n ):\n     \"\"\"Execute when task state changes to FAIL. previous_state can be None.\"\"\"\n+\n+\n+@hookspec\n+def on_task_instance_skipped(\n+    previous_state: TaskInstanceState | None,\n+    task_instance: RuntimeTaskInstance | TaskInstance,\n+):\n+    \"\"\"\n+    Execute when a task instance skips itself by raising AirflowSkipException.",
      "comment": "```suggestion\n    Execute when a task instance skips itself during execution.\n```",
      "comment_id": 2619819381,
      "user": "kacpermuda",
      "created_at": "2025-12-15T15:08:54Z",
      "url": "https://github.com/apache/airflow/pull/59467#discussion_r2619819381"
    },
    {
      "repo": "apache/airflow",
      "pr_number": 59467,
      "file_path": "airflow-core/src/airflow/listeners/spec/taskinstance.py",
      "line": 62,
      "side": "RIGHT",
      "diff_hunk": "@@ -48,3 +48,29 @@ def on_task_instance_failed(\n     error: None | str | BaseException,\n ):\n     \"\"\"Execute when task state changes to FAIL. previous_state can be None.\"\"\"\n+\n+\n+@hookspec\n+def on_task_instance_skipped(\n+    previous_state: TaskInstanceState | None,\n+    task_instance: RuntimeTaskInstance | TaskInstance,\n+):\n+    \"\"\"\n+    Execute when a task instance skips itself by raising AirflowSkipException.\n+\n+    This hook is called only when a task has started execution and then\n+    intentionally skips itself by raising AirflowSkipException.",
      "comment": "```suggestion\n    intentionally skips itself (e.g., by raising AirflowSkipException).\n```",
      "comment_id": 2619820740,
      "user": "kacpermuda",
      "created_at": "2025-12-15T15:09:16Z",
      "url": "https://github.com/apache/airflow/pull/59467#discussion_r2619820740"
    },
    {
      "repo": "apache/airflow",
      "pr_number": 60327,
      "file_path": "airflow-core/src/airflow/utils/singleton.py",
      "line": 33,
      "side": "LEFT",
      "diff_hunk": "@@ -1,33 +0,0 @@\n-#\n-# Licensed to the Apache Software Foundation (ASF) under one\n-# or more contributor license agreements.  See the NOTICE file\n-# distributed with this work for additional information\n-# regarding copyright ownership.  The ASF licenses this file\n-# to you under the Apache License, Version 2.0 (the\n-# \"License\"); you may not use this file except in compliance\n-# with the License.  You may obtain a copy of the License at\n-#\n-#   http://www.apache.org/licenses/LICENSE-2.0\n-#\n-# Unless required by applicable law or agreed to in writing,\n-# software distributed under the License is distributed on an\n-# \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n-# KIND, either express or implied.  See the License for the\n-# specific language governing permissions and limitations\n-# under the License.\n-from __future__ import annotations\n-\n-from typing import Generic, TypeVar\n-\n-T = TypeVar(\"T\")\n-\n-\n-class Singleton(type, Generic[T]):\n-    \"\"\"Metaclass that allows to implement singleton pattern.\"\"\"\n-\n-    _instances: dict[Singleton[T], T] = {}\n-\n-    def __call__(cls: Singleton[T], *args, **kwargs) -> T:\n-        if cls not in cls._instances:\n-            cls._instances[cls] = super().__call__(*args, **kwargs)\n-        return cls._instances[cls]",
      "comment": "This does mean that older KE versions won't work with Airflow 3.2. Which should be ok with constraints file.",
      "comment_id": 2676255562,
      "user": "kaxil",
      "created_at": "2026-01-09T13:46:53Z",
      "url": "https://github.com/apache/airflow/pull/60327#discussion_r2676255562"
    },
    {
      "repo": "apache/airflow",
      "pr_number": 60177,
      "file_path": "providers/vertica/src/airflow/providers/vertica/hooks/vertica.py",
      "line": 141,
      "side": "RIGHT",
      "diff_hunk": "@@ -137,6 +142,11 @@ def get_conn(self) -> connect:\n     @property\n     def sqlalchemy_url(self) -> URL:",
      "comment": "I think it will fail `mypy` tests now that we moved to sqlalchemy 2. We need to add typechecking exclusion likely.",
      "comment_id": 2665624752,
      "user": "potiuk",
      "created_at": "2026-01-06T17:05:10Z",
      "url": "https://github.com/apache/airflow/pull/60177#discussion_r2665624752"
    },
    {
      "repo": "apache/airflow",
      "pr_number": 60177,
      "file_path": "providers/vertica/src/airflow/providers/vertica/hooks/vertica.py",
      "line": 141,
      "side": "RIGHT",
      "diff_hunk": "@@ -137,6 +142,11 @@ def get_conn(self) -> connect:\n     @property\n     def sqlalchemy_url(self) -> URL:",
      "comment": "Okay I'll do this but \r\nwhy it didn't fail in local mypy check ? (when running prek ? )",
      "comment_id": 2665647601,
      "user": "Prab-27",
      "created_at": "2026-01-06T17:13:16Z",
      "url": "https://github.com/apache/airflow/pull/60177#discussion_r2665647601"
    },
    {
      "repo": "apache/airflow",
      "pr_number": 60177,
      "file_path": "providers/vertica/src/airflow/providers/vertica/hooks/vertica.py",
      "line": 141,
      "side": "RIGHT",
      "diff_hunk": "@@ -137,6 +142,11 @@ def get_conn(self) -> connect:\n     @property\n     def sqlalchemy_url(self) -> URL:",
      "comment": "local prek does not run mypy - unless you run it with `--hook-stage manual`. It takes long to run so we do not want it to happen locally for all changes. ",
      "comment_id": 2665897735,
      "user": "potiuk",
      "created_at": "2026-01-06T18:34:45Z",
      "url": "https://github.com/apache/airflow/pull/60177#discussion_r2665897735"
    },
    {
      "repo": "apache/airflow",
      "pr_number": 59418,
      "file_path": "helm-tests/tests/helm_tests/airflow_aux/test_configmap.py",
      "line": 337,
      "side": "RIGHT",
      "diff_hunk": "@@ -302,6 +302,40 @@ def test_execution_api_server_url(\n                 \"execution_api_server_url should not be set for Airflow 2.x versions\"\n             )\n \n+    @pytest.mark.parametrize(\n+        (\"git_sync_enabled\", \"ssh_key_secret\", \"ssh_key\", \"expected_volume\"),\n+        [\n+            (True, \"my-secret\", None, True),\n+            (True, None, \"my-key\", True),\n+            (True, \"my-secret\", \"my-key\", True),\n+            (True, None, None, False),\n+            (False, \"my-secret\", None, False),\n+            (False, None, \"my-key\", False),\n+        ],\n+    )\n+    def test_pod_template_git_sync_ssh_key_volume(\n+        self, git_sync_enabled, ssh_key_secret, ssh_key, expected_volume\n+    ):\n+        dag_values = {\"gitSync\": {\"enabled\": git_sync_enabled}}\n+        if ssh_key_secret:\n+            dag_values[\"gitSync\"][\"sshKeySecret\"] = ssh_key_secret\n+        if ssh_key:\n+            dag_values[\"gitSync\"][\"sshKey\"] = ssh_key\n+\n+        docs = render_chart(\n+            values={\n+                \"executor\": \"KubernetesExecutor\",\n+                \"dags\": dag_values,\n+            },\n+            show_only=[\"templates/configmaps/configmap.yaml\"],\n+        )\n+\n+        pod_template_file = jmespath.search('data.\"pod_template_file.yaml\"', docs[0])\n+        if expected_volume:\n+            assert \"git-sync-ssh-key\" in pod_template_file\n+        else:\n+            assert \"git-sync-ssh-key\" not in pod_template_file",
      "comment": "```suggestion\r\n        assert (\"git-sync-ssh-key\" in pod_template_file) == expected_volume\r\n```",
      "comment_id": 2624637434,
      "user": "Miretpl",
      "created_at": "2025-12-16T20:28:12Z",
      "url": "https://github.com/apache/airflow/pull/59418#discussion_r2624637434"
    },
    {
      "repo": "apache/airflow",
      "pr_number": 59418,
      "file_path": "helm-tests/tests/helm_tests/airflow_aux/test_configmap.py",
      "line": 323,
      "side": "RIGHT",
      "diff_hunk": "@@ -302,6 +302,40 @@ def test_execution_api_server_url(\n                 \"execution_api_server_url should not be set for Airflow 2.x versions\"\n             )\n \n+    @pytest.mark.parametrize(\n+        (\"git_sync_enabled\", \"ssh_key_secret\", \"ssh_key\", \"expected_volume\"),\n+        [\n+            (True, \"my-secret\", None, True),\n+            (True, None, \"my-key\", True),\n+            (True, \"my-secret\", \"my-key\", True),\n+            (True, None, None, False),\n+            (False, \"my-secret\", None, False),\n+            (False, None, \"my-key\", False),\n+        ],\n+    )\n+    def test_pod_template_git_sync_ssh_key_volume(\n+        self, git_sync_enabled, ssh_key_secret, ssh_key, expected_volume\n+    ):\n+        dag_values = {\"gitSync\": {\"enabled\": git_sync_enabled}}\n+        if ssh_key_secret:\n+            dag_values[\"gitSync\"][\"sshKeySecret\"] = ssh_key_secret\n+        if ssh_key:\n+            dag_values[\"gitSync\"][\"sshKey\"] = ssh_key",
      "comment": "Let's split this test into two test cases based on the settings (`sshKeySecret` or `sshKey`) that we set. It will be more readable, and in general, there should be no logic in tests",
      "comment_id": 2624643825,
      "user": "Miretpl",
      "created_at": "2025-12-16T20:30:49Z",
      "url": "https://github.com/apache/airflow/pull/59418#discussion_r2624643825"
    },
    {
      "repo": "apache/airflow",
      "pr_number": 59418,
      "file_path": "helm-tests/tests/helm_tests/airflow_aux/test_configmap.py",
      "line": 337,
      "side": "RIGHT",
      "diff_hunk": "@@ -302,6 +302,40 @@ def test_execution_api_server_url(\n                 \"execution_api_server_url should not be set for Airflow 2.x versions\"\n             )\n \n+    @pytest.mark.parametrize(\n+        (\"git_sync_enabled\", \"ssh_key_secret\", \"ssh_key\", \"expected_volume\"),\n+        [\n+            (True, \"my-secret\", None, True),\n+            (True, None, \"my-key\", True),\n+            (True, \"my-secret\", \"my-key\", True),\n+            (True, None, None, False),\n+            (False, \"my-secret\", None, False),\n+            (False, None, \"my-key\", False),\n+        ],\n+    )\n+    def test_pod_template_git_sync_ssh_key_volume(\n+        self, git_sync_enabled, ssh_key_secret, ssh_key, expected_volume\n+    ):\n+        dag_values = {\"gitSync\": {\"enabled\": git_sync_enabled}}\n+        if ssh_key_secret:\n+            dag_values[\"gitSync\"][\"sshKeySecret\"] = ssh_key_secret\n+        if ssh_key:\n+            dag_values[\"gitSync\"][\"sshKey\"] = ssh_key\n+\n+        docs = render_chart(\n+            values={\n+                \"executor\": \"KubernetesExecutor\",\n+                \"dags\": dag_values,\n+            },\n+            show_only=[\"templates/configmaps/configmap.yaml\"],\n+        )\n+\n+        pod_template_file = jmespath.search('data.\"pod_template_file.yaml\"', docs[0])\n+        if expected_volume:\n+            assert \"git-sync-ssh-key\" in pod_template_file\n+        else:\n+            assert \"git-sync-ssh-key\" not in pod_template_file",
      "comment": "https://github.com/apache/airflow/pull/59418/changes/6c62a0339a640a914aeafa723750ff9229614e87",
      "comment_id": 2624976256,
      "user": "zezaeoh",
      "created_at": "2025-12-16T22:36:53Z",
      "url": "https://github.com/apache/airflow/pull/59418#discussion_r2624976256"
    },
    {
      "repo": "apache/airflow",
      "pr_number": 59418,
      "file_path": "helm-tests/tests/helm_tests/airflow_aux/test_configmap.py",
      "line": 323,
      "side": "RIGHT",
      "diff_hunk": "@@ -302,6 +302,40 @@ def test_execution_api_server_url(\n                 \"execution_api_server_url should not be set for Airflow 2.x versions\"\n             )\n \n+    @pytest.mark.parametrize(\n+        (\"git_sync_enabled\", \"ssh_key_secret\", \"ssh_key\", \"expected_volume\"),\n+        [\n+            (True, \"my-secret\", None, True),\n+            (True, None, \"my-key\", True),\n+            (True, \"my-secret\", \"my-key\", True),\n+            (True, None, None, False),\n+            (False, \"my-secret\", None, False),\n+            (False, None, \"my-key\", False),\n+        ],\n+    )\n+    def test_pod_template_git_sync_ssh_key_volume(\n+        self, git_sync_enabled, ssh_key_secret, ssh_key, expected_volume\n+    ):\n+        dag_values = {\"gitSync\": {\"enabled\": git_sync_enabled}}\n+        if ssh_key_secret:\n+            dag_values[\"gitSync\"][\"sshKeySecret\"] = ssh_key_secret\n+        if ssh_key:\n+            dag_values[\"gitSync\"][\"sshKey\"] = ssh_key",
      "comment": "https://github.com/apache/airflow/pull/59418/changes/6c62a0339a640a914aeafa723750ff9229614e87\r\n\r\nThanks for the good feedback!",
      "comment_id": 2624981279,
      "user": "zezaeoh",
      "created_at": "2025-12-16T22:38:48Z",
      "url": "https://github.com/apache/airflow/pull/59418#discussion_r2624981279"
    },
    {
      "repo": "apache/airflow",
      "pr_number": 53368,
      "file_path": "providers/cncf/kubernetes/src/airflow/providers/cncf/kubernetes/operators/job.py",
      "line": 177,
      "side": "RIGHT",
      "diff_hunk": "@@ -147,6 +152,33 @@ def create_job(self, job_request_obj: k8s.V1Job) -> k8s.V1Job:\n \n         return job_request_obj\n \n+    def get_or_create_pod(self, pod_request_obj, context):\n+        \"\"\"Polls for pods created by the job object\n+\n+        Parameters\n+        ----------\n+        pod_request_obj : V1Pod\n+            Kubernetes Pod object definition\n+        context : Context\n+            Airflow context\n+\n+        Returns\n+        -------\n+        V1Pod\n+            Kubernetes Pod object from cluster hook\n+        \"\"\"\n+        pod = None\n+        with timeout(seconds=self.pod_creation_timeout, error_message=\"Exceeded pod_creation_timeout.\"):\n+            while pod is None:\n+                try:\n+                    pod = self.find_pod(self.namespace or pod_request_obj.metadata.namespace, context=context)\n+                except ApiException:\n+                    log.exception(\"Error getting pod - retrying\")\n+                    time.sleep(1)",
      "comment": "added `pod_poll_interval` parameter to configure this",
      "comment_id": 2222578414,
      "user": "stephen-bracken",
      "created_at": "2025-07-22T13:40:20Z",
      "url": "https://github.com/apache/airflow/pull/53368#discussion_r2222578414"
    },
    {
      "repo": "apache/airflow",
      "pr_number": 53368,
      "file_path": "providers/cncf/kubernetes/src/airflow/providers/cncf/kubernetes/operators/job.py",
      "line": 455,
      "side": "RIGHT",
      "diff_hunk": "@@ -459,8 +450,9 @@ def get_pods(\n         label_selector = self._build_find_pod_label_selector(context, exclude_checked=exclude_checked)\n         pod_list: Sequence[k8s.V1Pod] = []\n         retry_number: int = 0\n+        parallelism = self.parallelism or 1  # Default to using single pod parallelism\n \n-        while len(pod_list) != self.parallelism or retry_number <= self.discover_pods_retry_number:\n+        while len(pod_list) != parallelism or retry_number <= self.discover_pods_retry_number:",
      "comment": "The while loop condition uses `or` but should use `and`. With the current logic, the loop will continue as long as either `len(pod_list) != parallelism` OR `retry_number <= self.discover_pods_retry_number` is true. This means:\n1. If pods are found matching the parallelism count, the loop continues as long as `retry_number <= self.discover_pods_retry_number`\n2. If the retry number exceeds the limit but pods don't match, it still continues\n\nThe correct logic should be: `while len(pod_list) != parallelism and retry_number <= self.discover_pods_retry_number:` to retry finding pods until either the expected count is found OR the retry limit is reached.\n```suggestion\n        while len(pod_list) != parallelism and retry_number <= self.discover_pods_retry_number:\n```",
      "comment_id": 2594686671,
      "user": "Copilot",
      "created_at": "2025-12-06T09:42:43Z",
      "url": "https://github.com/apache/airflow/pull/53368#discussion_r2594686671"
    },
    {
      "repo": "apache/airflow",
      "pr_number": 53368,
      "file_path": "providers/cncf/kubernetes/src/airflow/providers/cncf/kubernetes/operators/job.py",
      "line": 455,
      "side": "RIGHT",
      "diff_hunk": "@@ -459,8 +450,9 @@ def get_pods(\n         label_selector = self._build_find_pod_label_selector(context, exclude_checked=exclude_checked)\n         pod_list: Sequence[k8s.V1Pod] = []\n         retry_number: int = 0\n+        parallelism = self.parallelism or 1  # Default to using single pod parallelism\n \n-        while len(pod_list) != self.parallelism or retry_number <= self.discover_pods_retry_number:\n+        while len(pod_list) != parallelism or retry_number <= self.discover_pods_retry_number:",
      "comment": "I've fixed the loop invariant by splitting out the break condition here.",
      "comment_id": 2618780390,
      "user": "stephen-bracken",
      "created_at": "2025-12-15T10:10:28Z",
      "url": "https://github.com/apache/airflow/pull/53368#discussion_r2618780390"
    },
    {
      "repo": "apache/airflow",
      "pr_number": 53368,
      "file_path": "providers/cncf/kubernetes/src/airflow/providers/cncf/kubernetes/operators/job.py",
      "line": 465,
      "side": "RIGHT",
      "diff_hunk": "@@ -461,7 +452,9 @@ def get_pods(\n         pod_list: Sequence[k8s.V1Pod] = []\n         retry_number: int = 0\n \n-        while len(pod_list) != self.parallelism or retry_number <= self.discover_pods_retry_number:\n+        while retry_number <= self.discover_pods_retry_number:",
      "comment": "First off, thank you @stephen-bracken for looking into this!\r\n\r\nMy question here is for clusters with limited resources and have Kueue enabled. The k8s Job will eventually spool up the pods but it will take a while if there is resource contention. In our case, it's a GPU cluster and many jobs reserve GPUs with potentially long runtimes. Could a configurable timeout instead of a retry number be used here? Or, don't have a retry number / timeout, and rely on DAG / task timeout instead (which is what my team preferred and is inherent in the solution I applied locally).\r\n\r\nThanks again!",
      "comment_id": 2624402228,
      "user": "rachthree",
      "created_at": "2025-12-16T18:59:13Z",
      "url": "https://github.com/apache/airflow/pull/53368#discussion_r2624402228"
    },
    {
      "repo": "apache/airflow",
      "pr_number": 53368,
      "file_path": "providers/cncf/kubernetes/src/airflow/providers/cncf/kubernetes/operators/job.py",
      "line": 465,
      "side": "RIGHT",
      "diff_hunk": "@@ -461,7 +452,9 @@ def get_pods(\n         pod_list: Sequence[k8s.V1Pod] = []\n         retry_number: int = 0\n \n-        while len(pod_list) != self.parallelism or retry_number <= self.discover_pods_retry_number:\n+        while retry_number <= self.discover_pods_retry_number:",
      "comment": "Hi @rachthree, good question. I think this sounds reasonable but is outside of the scope of this PR. My suggestion is that there should be a timeout on `get_pods()` that is similar to the timeout in the `KubernetesPodOperator` for pods not being ready.",
      "comment_id": 2626369806,
      "user": "stephen-bracken",
      "created_at": "2025-12-17T09:56:58Z",
      "url": "https://github.com/apache/airflow/pull/53368#discussion_r2626369806"
    },
    {
      "repo": "apache/airflow",
      "pr_number": 53368,
      "file_path": "providers/cncf/kubernetes/src/airflow/providers/cncf/kubernetes/operators/job.py",
      "line": 465,
      "side": "RIGHT",
      "diff_hunk": "@@ -461,7 +452,9 @@ def get_pods(\n         pod_list: Sequence[k8s.V1Pod] = []\n         retry_number: int = 0\n \n-        while len(pod_list) != self.parallelism or retry_number <= self.discover_pods_retry_number:\n+        while retry_number <= self.discover_pods_retry_number:",
      "comment": "Sounds good, thanks! Will there be a follow up PR for that? If not, no worries, I can try picking that up if that's alright.",
      "comment_id": 2637298614,
      "user": "rachthree",
      "created_at": "2025-12-20T19:49:58Z",
      "url": "https://github.com/apache/airflow/pull/53368#discussion_r2637298614"
    },
    {
      "repo": "apache/airflow",
      "pr_number": 53368,
      "file_path": "providers/cncf/kubernetes/src/airflow/providers/cncf/kubernetes/operators/job.py",
      "line": 118,
      "side": "RIGHT",
      "diff_hunk": "@@ -115,7 +115,7 @@ def __init__(\n         completion_mode: str | None = None,\n         completions: int | None = None,\n         manual_selector: bool | None = None,\n-        parallelism: int | None = None,\n+        parallelism: int = 1,",
      "comment": "Changing the default value of `parallelism` from `None` to `1` is a breaking change that could affect existing users. Users who previously relied on `parallelism=None` to have different behavior may experience unexpected changes. This should be documented in a newsfragment file as mentioned in the PR guidelines, particularly in a `.significant.rst` file to notify users of backwards incompatible changes.",
      "comment_id": 2644067916,
      "user": "Copilot",
      "created_at": "2025-12-23T19:16:23Z",
      "url": "https://github.com/apache/airflow/pull/53368#discussion_r2644067916"
    },
    {
      "repo": "apache/airflow",
      "pr_number": 53368,
      "file_path": "providers/cncf/kubernetes/src/airflow/providers/cncf/kubernetes/operators/job.py",
      "line": 470,
      "side": "RIGHT",
      "diff_hunk": "@@ -461,7 +452,9 @@ def get_pods(\n         pod_list: Sequence[k8s.V1Pod] = []\n         retry_number: int = 0\n \n-        while len(pod_list) != self.parallelism or retry_number <= self.discover_pods_retry_number:\n+        while retry_number <= self.discover_pods_retry_number:\n+            if len(pod_list) == self.parallelism:\n+                break\n             pod_list = self.client.list_namespaced_pod(\n                 namespace=pod_request_obj.metadata.namespace,\n                 label_selector=label_selector,",
      "comment": "The loop logic has a potential issue where `pod_list` is assigned inside the loop after checking its length. This means that if the initial `pod_list` is empty (as initialized on line 452), the first iteration will always execute the list operation, which is correct. However, if fewer pods than expected are found, the loop continues retrying without any delay, which could result in rapid API calls. Consider adding a sleep between iterations to avoid overwhelming the Kubernetes API server.",
      "comment_id": 2644067927,
      "user": "Copilot",
      "created_at": "2025-12-23T19:16:23Z",
      "url": "https://github.com/apache/airflow/pull/53368#discussion_r2644067927"
    },
    {
      "repo": "apache/airflow",
      "pr_number": 53368,
      "file_path": "providers/cncf/kubernetes/src/airflow/providers/cncf/kubernetes/operators/job.py",
      "line": 470,
      "side": "RIGHT",
      "diff_hunk": "@@ -461,7 +452,9 @@ def get_pods(\n         pod_list: Sequence[k8s.V1Pod] = []\n         retry_number: int = 0\n \n-        while len(pod_list) != self.parallelism or retry_number <= self.discover_pods_retry_number:\n+        while retry_number <= self.discover_pods_retry_number:\n+            if len(pod_list) == self.parallelism:\n+                break\n             pod_list = self.client.list_namespaced_pod(\n                 namespace=pod_request_obj.metadata.namespace,\n                 label_selector=label_selector,",
      "comment": "The error message at line 465 states \"No pods running with labels\" but this might not be accurate. The pods could exist but not be in a running state yet (e.g., pending, initializing). Consider updating the error message to be more accurate, such as \"Failed to find expected number of pods with labels\" or \"No pods found with labels\" to avoid confusion.",
      "comment_id": 2644067942,
      "user": "Copilot",
      "created_at": "2025-12-23T19:16:24Z",
      "url": "https://github.com/apache/airflow/pull/53368#discussion_r2644067942"
    },
    {
      "repo": "apache/airflow",
      "pr_number": 53368,
      "file_path": "providers/cncf/kubernetes/src/airflow/providers/cncf/kubernetes/operators/job.py",
      "line": 118,
      "side": "RIGHT",
      "diff_hunk": "@@ -115,7 +115,7 @@ def __init__(\n         completion_mode: str | None = None,\n         completions: int | None = None,\n         manual_selector: bool | None = None,\n-        parallelism: int | None = None,\n+        parallelism: int = 1,",
      "comment": "+1 for that.\r\nAlso, I would like to revise my earlier review: setting `parallelism = 0` as an equivalent for `parallelism = 1` seems to be confusing. \r\nIf we take `parallism = 0` meaning as-is, it means that no pods should start at all, and I don't find it practical.\r\nFor that reason:\r\n1. I suggest to throw an error when `parallelism < 1`.\r\n2. If `paralelism is None` - set it to `1` and raise a `DeprecationWarning`.",
      "comment_id": 2644092018,
      "user": "shahar1",
      "created_at": "2025-12-23T19:28:00Z",
      "url": "https://github.com/apache/airflow/pull/53368#discussion_r2644092018"
    },
    {
      "repo": "apache/airflow",
      "pr_number": 53368,
      "file_path": "providers/cncf/kubernetes/src/airflow/providers/cncf/kubernetes/operators/job.py",
      "line": 83,
      "side": "RIGHT",
      "diff_hunk": "@@ -81,7 +81,7 @@ class KubernetesJobOperator(KubernetesPodOperator):\n     :param completion_mode: CompletionMode specifies how Pod completions are tracked. It can be `NonIndexed` (default) or `Indexed`.\n     :param completions: Specifies the desired number of successfully finished pods the job should be run with.\n     :param manual_selector: manualSelector controls generation of pod labels and pod selectors.\n-    :param parallelism: Specifies the maximum desired number of pods the job should run at any given time.\n+    :param parallelism: Specifies the maximum desired number of pods the job should run at any given time. Defaults to 1",
      "comment": "See my other comments - it should be mentioned that the value should be `1` (default) or larger",
      "comment_id": 2644093472,
      "user": "shahar1",
      "created_at": "2025-12-23T19:28:28Z",
      "url": "https://github.com/apache/airflow/pull/53368#discussion_r2644093472"
    },
    {
      "repo": "apache/airflow",
      "pr_number": 60297,
      "file_path": "providers/ssh/src/airflow/providers/ssh/operators/ssh_remote_job.py",
      "line": 276,
      "side": "RIGHT",
      "diff_hunk": "@@ -0,0 +1,456 @@\n+#\n+# Licensed to the Apache Software Foundation (ASF) under one\n+# or more contributor license agreements.  See the NOTICE file\n+# distributed with this work for additional information\n+# regarding copyright ownership.  The ASF licenses this file\n+# to you under the Apache License, Version 2.0 (the\n+# \"License\"); you may not use this file except in compliance\n+# with the License.  You may obtain a copy of the License at\n+#\n+#   http://www.apache.org/licenses/LICENSE-2.0\n+#\n+# Unless required by applicable law or agreed to in writing,\n+# software distributed under the License is distributed on an\n+# \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+# KIND, either express or implied.  See the License for the\n+# specific language governing permissions and limitations\n+# under the License.\n+\"\"\"SSH Remote Job Operator for deferrable remote command execution.\"\"\"\n+\n+from __future__ import annotations\n+\n+from collections.abc import Container, Sequence\n+from datetime import timedelta\n+from functools import cached_property\n+from typing import TYPE_CHECKING, Any, Literal\n+\n+from airflow.providers.common.compat.sdk import AirflowException, AirflowSkipException, BaseOperator\n+from airflow.providers.ssh.hooks.ssh import SSHHook\n+from airflow.providers.ssh.triggers.ssh_remote_job import SSHRemoteJobTrigger\n+from airflow.providers.ssh.utils.remote_job import (\n+    RemoteJobPaths,\n+    build_posix_cleanup_command,\n+    build_posix_kill_command,\n+    build_posix_os_detection_command,\n+    build_posix_wrapper_command,\n+    build_windows_cleanup_command,\n+    build_windows_kill_command,\n+    build_windows_os_detection_command,\n+    build_windows_wrapper_command,\n+    generate_job_id,\n+)\n+\n+if TYPE_CHECKING:\n+    from airflow.utils.context import Context\n+\n+\n+class SSHRemoteJobOperator(BaseOperator):\n+    r\"\"\"\n+    Execute a command on a remote host via SSH with deferrable monitoring.\n+\n+    This operator submits a job to run detached on the remote host, then\n+    uses a trigger to asynchronously monitor the job status and stream logs.\n+    This approach is resilient to network interruptions as the remote job\n+    continues running independently of the SSH connection.\n+\n+    The remote job is wrapped to:\n+    - Run detached from the SSH session (via nohup on POSIX, Start-Process on Windows)\n+    - Redirect stdout/stderr to a log file\n+    - Write the exit code to a file on completion\n+\n+    :param ssh_conn_id: SSH connection ID from Airflow Connections\n+    :param command: Command to execute on the remote host (templated)\n+    :param remote_host: Override the host from the connection (templated)\n+    :param environment: Environment variables to set for the command (templated)\n+    :param remote_base_dir: Base directory for job artifacts (templated).\n+        Defaults to /tmp/airflow-ssh-jobs on POSIX, C:\\\\Windows\\\\Temp\\\\airflow-ssh-jobs on Windows\n+    :param poll_interval: Seconds between status polls (default: 5)\n+    :param log_chunk_size: Max bytes to read per poll (default: 65536)\n+    :param timeout: Hard timeout in seconds for the entire operation\n+    :param cleanup: When to clean up remote job directory:\n+        'never', 'on_success', or 'always' (default: 'never')\n+    :param remote_os: Remote operating system: 'auto', 'posix', or 'windows' (default: 'auto')\n+    :param skip_on_exit_code: Exit codes that should skip the task instead of failing\n+    :param conn_timeout: SSH connection timeout in seconds\n+    :param banner_timeout: Timeout waiting for SSH banner in seconds\n+    \"\"\"\n+\n+    template_fields: Sequence[str] = (\"command\", \"environment\", \"remote_host\", \"remote_base_dir\")\n+    template_ext: Sequence[str] = (\n+        \".sh\",\n+        \".bash\",\n+        \".ps1\",\n+    )\n+    template_fields_renderers = {\n+        \"command\": \"bash\",\n+        \"environment\": \"python\",\n+    }\n+    ui_color = \"#e4f0e8\"\n+\n+    def __init__(\n+        self,\n+        *,\n+        ssh_conn_id: str,\n+        command: str,\n+        remote_host: str | None = None,\n+        environment: dict[str, str] | None = None,\n+        remote_base_dir: str | None = None,\n+        poll_interval: int = 5,\n+        log_chunk_size: int = 65536,\n+        timeout: int | None = None,\n+        cleanup: Literal[\"never\", \"on_success\", \"always\"] = \"never\",\n+        remote_os: Literal[\"auto\", \"posix\", \"windows\"] = \"auto\",\n+        skip_on_exit_code: int | Container[int] | None = None,\n+        conn_timeout: int | None = None,\n+        banner_timeout: float = 30.0,\n+        **kwargs,\n+    ) -> None:\n+        super().__init__(**kwargs)\n+        self.ssh_conn_id = ssh_conn_id\n+        self.command = command\n+        self.remote_host = remote_host\n+        self.environment = environment\n+\n+        if remote_base_dir is not None:\n+            self._validate_base_dir(remote_base_dir)\n+        self.remote_base_dir = remote_base_dir\n+\n+        self.poll_interval = poll_interval\n+        self.log_chunk_size = log_chunk_size\n+        self.timeout = timeout\n+        self.cleanup = cleanup\n+        self.remote_os = remote_os\n+        self.conn_timeout = conn_timeout\n+        self.banner_timeout = banner_timeout\n+        self.skip_on_exit_code = (\n+            skip_on_exit_code\n+            if isinstance(skip_on_exit_code, Container)\n+            else [skip_on_exit_code]\n+            if skip_on_exit_code is not None\n+            else []\n+        )\n+\n+        self._job_id: str | None = None\n+        self._paths: RemoteJobPaths | None = None\n+        self._detected_os: Literal[\"posix\", \"windows\"] | None = None\n+\n+    @staticmethod\n+    def _validate_base_dir(path: str) -> None:\n+        \"\"\"\n+        Validate the remote base directory path for security.\n+\n+        :param path: Path to validate\n+        :raises ValueError: If path contains dangerous patterns\n+        \"\"\"\n+        if not path:\n+            raise ValueError(\"remote_base_dir cannot be empty\")\n+\n+        if \"..\" in path:\n+            raise ValueError(f\"remote_base_dir cannot contain '..' (path traversal not allowed). Got: {path}\")\n+\n+        if \"\\x00\" in path:\n+            raise ValueError(\"remote_base_dir cannot contain null bytes\")\n+\n+        dangerous_patterns = [\"/etc\", \"/bin\", \"/sbin\", \"/boot\", \"C:\\\\Windows\", \"C:\\\\Program Files\"]\n+        for pattern in dangerous_patterns:\n+            if pattern in path:\n+                import warnings\n+\n+                warnings.warn(\n+                    f\"remote_base_dir '{path}' contains potentially sensitive path '{pattern}'. \"\n+                    \"Ensure you have appropriate permissions.\",\n+                    UserWarning,\n+                    stacklevel=3,\n+                )\n+\n+    @cached_property\n+    def ssh_hook(self) -> SSHHook:\n+        \"\"\"Create the SSH hook for command submission.\"\"\"\n+        return SSHHook(\n+            ssh_conn_id=self.ssh_conn_id,\n+            remote_host=self.remote_host or \"\",\n+            conn_timeout=self.conn_timeout,\n+            banner_timeout=self.banner_timeout,\n+        )\n+\n+    def _detect_remote_os(self) -> Literal[\"posix\", \"windows\"]:\n+        \"\"\"\n+        Detect the remote operating system.\n+\n+        Uses a two-stage detection:\n+        1. Try POSIX detection via `uname` (works on Linux, macOS, BSD, Solaris, AIX, etc.)\n+        2. Try Windows detection via PowerShell\n+        3. Raise error if both fail\n+        \"\"\"\n+        if self.remote_os != \"auto\":\n+            return self.remote_os\n+\n+        self.log.info(\"Auto-detecting remote operating system...\")\n+        with self.ssh_hook.get_conn() as ssh_client:\n+            try:\n+                exit_status, stdout, _ = self.ssh_hook.exec_ssh_client_command(\n+                    ssh_client,\n+                    build_posix_os_detection_command(),\n+                    get_pty=False,\n+                    environment=None,\n+                    timeout=10,\n+                )\n+                if exit_status == 0 and stdout:\n+                    output = stdout.decode(\"utf-8\", errors=\"replace\").strip().lower()\n+                    posix_systems = [\n+                        \"linux\",\n+                        \"darwin\",\n+                        \"freebsd\",\n+                        \"openbsd\",\n+                        \"netbsd\",\n+                        \"sunos\",\n+                        \"aix\",\n+                        \"hp-ux\",\n+                    ]\n+                    if any(system in output for system in posix_systems):\n+                        self.log.info(\"Detected POSIX system: %s\", output)\n+                        return \"posix\"\n+            except Exception as e:\n+                self.log.debug(\"POSIX detection failed: %s\", e)\n+\n+            try:\n+                exit_status, stdout, _ = self.ssh_hook.exec_ssh_client_command(\n+                    ssh_client,\n+                    build_windows_os_detection_command(),\n+                    get_pty=False,\n+                    environment=None,\n+                    timeout=10,\n+                )\n+                if exit_status == 0 and stdout:\n+                    output = stdout.decode(\"utf-8\", errors=\"replace\").strip()\n+                    if \"WINDOWS\" in output.upper():\n+                        self.log.info(\"Detected Windows system\")\n+                        return \"windows\"\n+            except Exception as e:\n+                self.log.debug(\"Windows detection failed: %s\", e)\n+\n+            raise AirflowException(\n+                \"Could not auto-detect remote OS. Please explicitly set remote_os='posix' or 'windows'\"\n+            )\n+\n+    def execute(self, context: Context) -> None:\n+        \"\"\"\n+        Submit the remote job and defer to the trigger for monitoring.\n+\n+        :param context: Airflow task context\n+        \"\"\"\n+        if not self.command:\n+            raise AirflowException(\"SSH operator error: command not specified.\")\n+\n+        self._detected_os = self._detect_remote_os()\n+        self.log.info(\"Remote OS: %s\", self._detected_os)\n+\n+        ti = context[\"ti\"]\n+        self._job_id = generate_job_id(\n+            dag_id=ti.dag_id,\n+            task_id=ti.task_id,\n+            run_id=ti.run_id,\n+            try_number=ti.try_number,\n+        )\n+        self.log.info(\"Generated job ID: %s\", self._job_id)\n+\n+        self._paths = RemoteJobPaths(\n+            job_id=self._job_id,\n+            remote_os=self._detected_os,\n+            base_dir=self.remote_base_dir,\n+        )\n+\n+        if self._detected_os == \"posix\":\n+            wrapper_cmd = build_posix_wrapper_command(\n+                command=self.command,\n+                paths=self._paths,\n+                environment=self.environment,\n+            )\n+        else:\n+            wrapper_cmd = build_windows_wrapper_command(\n+                command=self.command,\n+                paths=self._paths,\n+                environment=self.environment,\n+            )\n+\n+        self.log.info(\"Submitting remote job to %s\", self.ssh_hook.remote_host or \"configured host\")",
      "comment": "Is it even possible to have an empty `remote_host` at this point?",
      "comment_id": 2675984454,
      "user": "BasPH",
      "created_at": "2026-01-09T12:17:24Z",
      "url": "https://github.com/apache/airflow/pull/60297#discussion_r2675984454"
    },
    {
      "repo": "apache/airflow",
      "pr_number": 60297,
      "file_path": "providers/ssh/src/airflow/providers/ssh/utils/remote_job.py",
      "line": 267,
      "side": "RIGHT",
      "diff_hunk": "@@ -0,0 +1,433 @@\n+#\n+# Licensed to the Apache Software Foundation (ASF) under one\n+# or more contributor license agreements.  See the NOTICE file\n+# distributed with this work for additional information\n+# regarding copyright ownership.  The ASF licenses this file\n+# to you under the Apache License, Version 2.0 (the\n+# \"License\"); you may not use this file except in compliance\n+# with the License.  You may obtain a copy of the License at\n+#\n+#   http://www.apache.org/licenses/LICENSE-2.0\n+#\n+# Unless required by applicable law or agreed to in writing,\n+# software distributed under the License is distributed on an\n+# \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+# KIND, either express or implied.  See the License for the\n+# specific language governing permissions and limitations\n+# under the License.\n+\"\"\"Utilities for SSH remote job execution.\"\"\"\n+\n+from __future__ import annotations\n+\n+import re\n+import secrets\n+import string\n+from dataclasses import dataclass\n+from typing import Literal\n+\n+\n+def _validate_env_var_name(name: str) -> None:\n+    \"\"\"\n+    Validate environment variable name for security.\n+\n+    :param name: Environment variable name\n+    :raises ValueError: If name contains dangerous characters\n+    \"\"\"\n+    if not name:\n+        raise ValueError(\"Environment variable name cannot be empty\")\n+\n+    if not re.match(r\"^[a-zA-Z_][a-zA-Z0-9_]*$\", name):\n+        raise ValueError(\n+            f\"Invalid environment variable name '{name}'. \"\n+            \"Only alphanumeric characters and underscores are allowed, \"\n+            \"and the name must start with a letter or underscore.\"\n+        )\n+\n+\n+def generate_job_id(\n+    dag_id: str,\n+    task_id: str,\n+    run_id: str,\n+    try_number: int,\n+    suffix_length: int = 8,\n+) -> str:\n+    \"\"\"\n+    Generate a unique job ID for remote execution.\n+\n+    Creates a deterministic identifier from the task context with a random suffix\n+    to ensure uniqueness across retries and potential race conditions.\n+\n+    :param dag_id: The DAG identifier\n+    :param task_id: The task identifier\n+    :param run_id: The run identifier\n+    :param try_number: The attempt number\n+    :param suffix_length: Length of random suffix (default 8)\n+    :return: Sanitized job ID string\n+    \"\"\"\n+\n+    def sanitize(value: str) -> str:\n+        return re.sub(r\"[^a-zA-Z0-9]\", \"_\", value)[:50]\n+\n+    sanitized_dag = sanitize(dag_id)\n+    sanitized_task = sanitize(task_id)\n+    sanitized_run = sanitize(run_id)\n+\n+    alphabet = string.ascii_lowercase + string.digits\n+    suffix = \"\".join(secrets.choice(alphabet) for _ in range(suffix_length))\n+\n+    return f\"af_{sanitized_dag}_{sanitized_task}_{sanitized_run}_try{try_number}_{suffix}\"\n+\n+\n+@dataclass\n+class RemoteJobPaths:\n+    \"\"\"Paths for remote job artifacts on the target system.\"\"\"\n+\n+    job_id: str\n+    remote_os: Literal[\"posix\", \"windows\"]\n+    base_dir: str | None = None\n+\n+    def __post_init__(self):\n+        if self.base_dir is None:\n+            if self.remote_os == \"posix\":\n+                self.base_dir = \"/tmp/airflow-ssh-jobs\"\n+            else:\n+                self.base_dir = \"$env:TEMP\\\\airflow-ssh-jobs\"\n+\n+    @property\n+    def sep(self) -> str:\n+        \"\"\"Path separator for the remote OS.\"\"\"\n+        return \"\\\\\" if self.remote_os == \"windows\" else \"/\"\n+\n+    @property\n+    def job_dir(self) -> str:\n+        \"\"\"Directory containing all job artifacts.\"\"\"\n+        return f\"{self.base_dir}{self.sep}{self.job_id}\"\n+\n+    @property\n+    def log_file(self) -> str:\n+        \"\"\"Path to stdout/stderr log file.\"\"\"\n+        return f\"{self.job_dir}{self.sep}stdout.log\"\n+\n+    @property\n+    def exit_code_file(self) -> str:\n+        \"\"\"Path to exit code file (written on completion).\"\"\"\n+        return f\"{self.job_dir}{self.sep}exit_code\"\n+\n+    @property\n+    def exit_code_tmp_file(self) -> str:\n+        \"\"\"Temporary exit code file (for atomic write).\"\"\"\n+        return f\"{self.job_dir}{self.sep}exit_code.tmp\"\n+\n+    @property\n+    def pid_file(self) -> str:\n+        \"\"\"Path to PID file for the background process.\"\"\"\n+        return f\"{self.job_dir}{self.sep}pid\"\n+\n+    @property\n+    def status_file(self) -> str:\n+        \"\"\"Path to optional status file for progress updates.\"\"\"\n+        return f\"{self.job_dir}{self.sep}status\"\n+\n+\n+def build_posix_wrapper_command(\n+    command: str,\n+    paths: RemoteJobPaths,\n+    environment: dict[str, str] | None = None,\n+) -> str:\n+    \"\"\"\n+    Build a POSIX shell wrapper that runs the command detached via nohup.\n+\n+    The wrapper:\n+    - Creates the job directory\n+    - Starts the command in the background with nohup\n+    - Redirects stdout/stderr to the log file\n+    - Writes the exit code atomically on completion\n+    - Writes the PID for potential cancellation\n+\n+    :param command: The command to execute\n+    :param paths: RemoteJobPaths instance with all paths\n+    :param environment: Optional environment variables to set\n+    :return: Shell command string to submit via SSH\n+    \"\"\"\n+    env_exports = \"\"\n+    if environment:\n+        for key, value in environment.items():\n+            _validate_env_var_name(key)\n+            escaped_value = value.replace(\"'\", \"'\\\"'\\\"'\")\n+            env_exports += f\"export {key}='{escaped_value}'\\n\"\n+\n+    escaped_command = command.replace(\"'\", \"'\\\"'\\\"'\")\n+\n+    wrapper = f\"\"\"set -euo pipefail\n+job_dir='{paths.job_dir}'\n+log_file='{paths.log_file}'\n+exit_code_file='{paths.exit_code_file}'\n+exit_code_tmp='{paths.exit_code_tmp_file}'\n+pid_file='{paths.pid_file}'\n+status_file='{paths.status_file}'\n+\n+mkdir -p \"$job_dir\"\n+: > \"$log_file\"\n+\n+nohup bash -c '\n+set +e\n+export LOG_FILE=\"'\"$log_file\"'\"\n+export STATUS_FILE=\"'\"$status_file\"'\"\n+{env_exports}{escaped_command} >>\"'\"$log_file\"'\" 2>&1\n+ec=$?\n+echo -n \"$ec\" > \"'\"$exit_code_tmp\"'\"\n+mv \"'\"$exit_code_tmp\"'\" \"'\"$exit_code_file\"'\"\n+exit 0\n+' >/dev/null 2>&1 &\n+\n+echo -n $! > \"$pid_file\"\n+echo \"{paths.job_id}\"\n+\"\"\"\n+    return wrapper\n+\n+\n+def build_windows_wrapper_command(\n+    command: str,\n+    paths: RemoteJobPaths,\n+    environment: dict[str, str] | None = None,\n+) -> str:\n+    \"\"\"\n+    Build a PowerShell wrapper that runs the command detached via Start-Process.\n+\n+    The wrapper:\n+    - Creates the job directory\n+    - Starts the command in a new detached PowerShell process\n+    - Redirects stdout/stderr to the log file\n+    - Writes the exit code atomically on completion\n+    - Writes the PID for potential cancellation\n+\n+    :param command: The command to execute (PowerShell script path or command)\n+    :param paths: RemoteJobPaths instance with all paths\n+    :param environment: Optional environment variables to set\n+    :return: PowerShell command string to submit via SSH\n+    \"\"\"\n+    env_setup = \"\"\n+    if environment:\n+        for key, value in environment.items():\n+            _validate_env_var_name(key)\n+            escaped_value = value.replace(\"'\", \"''\")\n+            env_setup += f\"$env:{key} = '{escaped_value}'; \"\n+\n+    def ps_escape(s: str) -> str:\n+        return s.replace(\"'\", \"''\")\n+\n+    job_dir = ps_escape(paths.job_dir)\n+    log_file = ps_escape(paths.log_file)\n+    exit_code_file = ps_escape(paths.exit_code_file)\n+    exit_code_tmp = ps_escape(paths.exit_code_tmp_file)\n+    pid_file = ps_escape(paths.pid_file)\n+    status_file = ps_escape(paths.status_file)\n+    escaped_command = ps_escape(command)\n+    job_id = ps_escape(paths.job_id)\n+\n+    child_script = f\"\"\"$ErrorActionPreference = 'Continue'\n+$env:LOG_FILE = '{log_file}'\n+$env:STATUS_FILE = '{status_file}'\n+{env_setup}\n+{escaped_command}\n+$ec = $LASTEXITCODE\n+if ($null -eq $ec) {{ $ec = 0 }}\n+Set-Content -NoNewline -Path '{exit_code_tmp}' -Value $ec\n+Move-Item -Force -Path '{exit_code_tmp}' -Destination '{exit_code_file}'\n+\"\"\"\n+    import base64\n+\n+    child_script_bytes = child_script.encode(\"utf-16-le\")\n+    encoded_script = base64.b64encode(child_script_bytes).decode(\"ascii\")\n+\n+    wrapper = f\"\"\"$jobDir = '{job_dir}'\n+New-Item -ItemType Directory -Force -Path $jobDir | Out-Null\n+$log = '{log_file}'\n+'' | Set-Content -Path $log\n+\n+$p = Start-Process -FilePath 'powershell.exe' -ArgumentList @('-NoProfile', '-NonInteractive', '-EncodedCommand', '{encoded_script}') -RedirectStandardOutput $log -RedirectStandardError $log -PassThru -WindowStyle Hidden\n+Set-Content -NoNewline -Path '{pid_file}' -Value $p.Id\n+Write-Output '{job_id}'\n+\"\"\"\n+    wrapper_bytes = wrapper.encode(\"utf-16-le\")\n+    encoded_wrapper = base64.b64encode(wrapper_bytes).decode(\"ascii\")\n+\n+    return f\"powershell.exe -NoProfile -NonInteractive -EncodedCommand {encoded_wrapper}\"\n+\n+\n+def build_posix_log_tail_command(log_file: str, offset: int, max_bytes: int) -> str:\n+    \"\"\"\n+    Build a POSIX command to read log bytes from offset.\n+\n+    :param log_file: Path to the log file\n+    :param offset: Byte offset to start reading from\n+    :param max_bytes: Maximum bytes to read\n+    :return: Shell command that outputs the log chunk\n+    \"\"\"\n+    return f\"dd if='{log_file}' bs=1 skip={offset} count={max_bytes} 2>/dev/null || true\"",
      "comment": "`bs=1` will require 1M read/write system context switches to read a 1MB log file. Should we bump it to e.g. 4096?\r\n\r\nSmall example:\r\n```bash\r\n$ dd if=/dev/zero of=perf_test_1mb.tmp bs=1M count=1 status=none\r\n\r\n$ time dd if=perf_test_1mb.tmp of=/dev/null bs=1 2>/dev/null\r\n\r\nreal\t0m0.947s\r\nuser\t0m0.250s\r\nsys\t0m0.691s\r\n\r\n$ time dd if=perf_test_1mb.tmp of=/dev/null bs=4096 2>/dev/null\r\n\r\nreal\t0m0.013s\r\nuser\t0m0.003s\r\nsys\t0m0.007s\r\n```",
      "comment_id": 2676015339,
      "user": "BasPH",
      "created_at": "2026-01-09T12:28:15Z",
      "url": "https://github.com/apache/airflow/pull/60297#discussion_r2676015339"
    },
    {
      "repo": "apache/airflow",
      "pr_number": 60297,
      "file_path": "providers/ssh/src/airflow/providers/ssh/utils/remote_job.py",
      "line": 267,
      "side": "RIGHT",
      "diff_hunk": "@@ -0,0 +1,433 @@\n+#\n+# Licensed to the Apache Software Foundation (ASF) under one\n+# or more contributor license agreements.  See the NOTICE file\n+# distributed with this work for additional information\n+# regarding copyright ownership.  The ASF licenses this file\n+# to you under the Apache License, Version 2.0 (the\n+# \"License\"); you may not use this file except in compliance\n+# with the License.  You may obtain a copy of the License at\n+#\n+#   http://www.apache.org/licenses/LICENSE-2.0\n+#\n+# Unless required by applicable law or agreed to in writing,\n+# software distributed under the License is distributed on an\n+# \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+# KIND, either express or implied.  See the License for the\n+# specific language governing permissions and limitations\n+# under the License.\n+\"\"\"Utilities for SSH remote job execution.\"\"\"\n+\n+from __future__ import annotations\n+\n+import re\n+import secrets\n+import string\n+from dataclasses import dataclass\n+from typing import Literal\n+\n+\n+def _validate_env_var_name(name: str) -> None:\n+    \"\"\"\n+    Validate environment variable name for security.\n+\n+    :param name: Environment variable name\n+    :raises ValueError: If name contains dangerous characters\n+    \"\"\"\n+    if not name:\n+        raise ValueError(\"Environment variable name cannot be empty\")\n+\n+    if not re.match(r\"^[a-zA-Z_][a-zA-Z0-9_]*$\", name):\n+        raise ValueError(\n+            f\"Invalid environment variable name '{name}'. \"\n+            \"Only alphanumeric characters and underscores are allowed, \"\n+            \"and the name must start with a letter or underscore.\"\n+        )\n+\n+\n+def generate_job_id(\n+    dag_id: str,\n+    task_id: str,\n+    run_id: str,\n+    try_number: int,\n+    suffix_length: int = 8,\n+) -> str:\n+    \"\"\"\n+    Generate a unique job ID for remote execution.\n+\n+    Creates a deterministic identifier from the task context with a random suffix\n+    to ensure uniqueness across retries and potential race conditions.\n+\n+    :param dag_id: The DAG identifier\n+    :param task_id: The task identifier\n+    :param run_id: The run identifier\n+    :param try_number: The attempt number\n+    :param suffix_length: Length of random suffix (default 8)\n+    :return: Sanitized job ID string\n+    \"\"\"\n+\n+    def sanitize(value: str) -> str:\n+        return re.sub(r\"[^a-zA-Z0-9]\", \"_\", value)[:50]\n+\n+    sanitized_dag = sanitize(dag_id)\n+    sanitized_task = sanitize(task_id)\n+    sanitized_run = sanitize(run_id)\n+\n+    alphabet = string.ascii_lowercase + string.digits\n+    suffix = \"\".join(secrets.choice(alphabet) for _ in range(suffix_length))\n+\n+    return f\"af_{sanitized_dag}_{sanitized_task}_{sanitized_run}_try{try_number}_{suffix}\"\n+\n+\n+@dataclass\n+class RemoteJobPaths:\n+    \"\"\"Paths for remote job artifacts on the target system.\"\"\"\n+\n+    job_id: str\n+    remote_os: Literal[\"posix\", \"windows\"]\n+    base_dir: str | None = None\n+\n+    def __post_init__(self):\n+        if self.base_dir is None:\n+            if self.remote_os == \"posix\":\n+                self.base_dir = \"/tmp/airflow-ssh-jobs\"\n+            else:\n+                self.base_dir = \"$env:TEMP\\\\airflow-ssh-jobs\"\n+\n+    @property\n+    def sep(self) -> str:\n+        \"\"\"Path separator for the remote OS.\"\"\"\n+        return \"\\\\\" if self.remote_os == \"windows\" else \"/\"\n+\n+    @property\n+    def job_dir(self) -> str:\n+        \"\"\"Directory containing all job artifacts.\"\"\"\n+        return f\"{self.base_dir}{self.sep}{self.job_id}\"\n+\n+    @property\n+    def log_file(self) -> str:\n+        \"\"\"Path to stdout/stderr log file.\"\"\"\n+        return f\"{self.job_dir}{self.sep}stdout.log\"\n+\n+    @property\n+    def exit_code_file(self) -> str:\n+        \"\"\"Path to exit code file (written on completion).\"\"\"\n+        return f\"{self.job_dir}{self.sep}exit_code\"\n+\n+    @property\n+    def exit_code_tmp_file(self) -> str:\n+        \"\"\"Temporary exit code file (for atomic write).\"\"\"\n+        return f\"{self.job_dir}{self.sep}exit_code.tmp\"\n+\n+    @property\n+    def pid_file(self) -> str:\n+        \"\"\"Path to PID file for the background process.\"\"\"\n+        return f\"{self.job_dir}{self.sep}pid\"\n+\n+    @property\n+    def status_file(self) -> str:\n+        \"\"\"Path to optional status file for progress updates.\"\"\"\n+        return f\"{self.job_dir}{self.sep}status\"\n+\n+\n+def build_posix_wrapper_command(\n+    command: str,\n+    paths: RemoteJobPaths,\n+    environment: dict[str, str] | None = None,\n+) -> str:\n+    \"\"\"\n+    Build a POSIX shell wrapper that runs the command detached via nohup.\n+\n+    The wrapper:\n+    - Creates the job directory\n+    - Starts the command in the background with nohup\n+    - Redirects stdout/stderr to the log file\n+    - Writes the exit code atomically on completion\n+    - Writes the PID for potential cancellation\n+\n+    :param command: The command to execute\n+    :param paths: RemoteJobPaths instance with all paths\n+    :param environment: Optional environment variables to set\n+    :return: Shell command string to submit via SSH\n+    \"\"\"\n+    env_exports = \"\"\n+    if environment:\n+        for key, value in environment.items():\n+            _validate_env_var_name(key)\n+            escaped_value = value.replace(\"'\", \"'\\\"'\\\"'\")\n+            env_exports += f\"export {key}='{escaped_value}'\\n\"\n+\n+    escaped_command = command.replace(\"'\", \"'\\\"'\\\"'\")\n+\n+    wrapper = f\"\"\"set -euo pipefail\n+job_dir='{paths.job_dir}'\n+log_file='{paths.log_file}'\n+exit_code_file='{paths.exit_code_file}'\n+exit_code_tmp='{paths.exit_code_tmp_file}'\n+pid_file='{paths.pid_file}'\n+status_file='{paths.status_file}'\n+\n+mkdir -p \"$job_dir\"\n+: > \"$log_file\"\n+\n+nohup bash -c '\n+set +e\n+export LOG_FILE=\"'\"$log_file\"'\"\n+export STATUS_FILE=\"'\"$status_file\"'\"\n+{env_exports}{escaped_command} >>\"'\"$log_file\"'\" 2>&1\n+ec=$?\n+echo -n \"$ec\" > \"'\"$exit_code_tmp\"'\"\n+mv \"'\"$exit_code_tmp\"'\" \"'\"$exit_code_file\"'\"\n+exit 0\n+' >/dev/null 2>&1 &\n+\n+echo -n $! > \"$pid_file\"\n+echo \"{paths.job_id}\"\n+\"\"\"\n+    return wrapper\n+\n+\n+def build_windows_wrapper_command(\n+    command: str,\n+    paths: RemoteJobPaths,\n+    environment: dict[str, str] | None = None,\n+) -> str:\n+    \"\"\"\n+    Build a PowerShell wrapper that runs the command detached via Start-Process.\n+\n+    The wrapper:\n+    - Creates the job directory\n+    - Starts the command in a new detached PowerShell process\n+    - Redirects stdout/stderr to the log file\n+    - Writes the exit code atomically on completion\n+    - Writes the PID for potential cancellation\n+\n+    :param command: The command to execute (PowerShell script path or command)\n+    :param paths: RemoteJobPaths instance with all paths\n+    :param environment: Optional environment variables to set\n+    :return: PowerShell command string to submit via SSH\n+    \"\"\"\n+    env_setup = \"\"\n+    if environment:\n+        for key, value in environment.items():\n+            _validate_env_var_name(key)\n+            escaped_value = value.replace(\"'\", \"''\")\n+            env_setup += f\"$env:{key} = '{escaped_value}'; \"\n+\n+    def ps_escape(s: str) -> str:\n+        return s.replace(\"'\", \"''\")\n+\n+    job_dir = ps_escape(paths.job_dir)\n+    log_file = ps_escape(paths.log_file)\n+    exit_code_file = ps_escape(paths.exit_code_file)\n+    exit_code_tmp = ps_escape(paths.exit_code_tmp_file)\n+    pid_file = ps_escape(paths.pid_file)\n+    status_file = ps_escape(paths.status_file)\n+    escaped_command = ps_escape(command)\n+    job_id = ps_escape(paths.job_id)\n+\n+    child_script = f\"\"\"$ErrorActionPreference = 'Continue'\n+$env:LOG_FILE = '{log_file}'\n+$env:STATUS_FILE = '{status_file}'\n+{env_setup}\n+{escaped_command}\n+$ec = $LASTEXITCODE\n+if ($null -eq $ec) {{ $ec = 0 }}\n+Set-Content -NoNewline -Path '{exit_code_tmp}' -Value $ec\n+Move-Item -Force -Path '{exit_code_tmp}' -Destination '{exit_code_file}'\n+\"\"\"\n+    import base64\n+\n+    child_script_bytes = child_script.encode(\"utf-16-le\")\n+    encoded_script = base64.b64encode(child_script_bytes).decode(\"ascii\")\n+\n+    wrapper = f\"\"\"$jobDir = '{job_dir}'\n+New-Item -ItemType Directory -Force -Path $jobDir | Out-Null\n+$log = '{log_file}'\n+'' | Set-Content -Path $log\n+\n+$p = Start-Process -FilePath 'powershell.exe' -ArgumentList @('-NoProfile', '-NonInteractive', '-EncodedCommand', '{encoded_script}') -RedirectStandardOutput $log -RedirectStandardError $log -PassThru -WindowStyle Hidden\n+Set-Content -NoNewline -Path '{pid_file}' -Value $p.Id\n+Write-Output '{job_id}'\n+\"\"\"\n+    wrapper_bytes = wrapper.encode(\"utf-16-le\")\n+    encoded_wrapper = base64.b64encode(wrapper_bytes).decode(\"ascii\")\n+\n+    return f\"powershell.exe -NoProfile -NonInteractive -EncodedCommand {encoded_wrapper}\"\n+\n+\n+def build_posix_log_tail_command(log_file: str, offset: int, max_bytes: int) -> str:\n+    \"\"\"\n+    Build a POSIX command to read log bytes from offset.\n+\n+    :param log_file: Path to the log file\n+    :param offset: Byte offset to start reading from\n+    :param max_bytes: Maximum bytes to read\n+    :return: Shell command that outputs the log chunk\n+    \"\"\"\n+    return f\"dd if='{log_file}' bs=1 skip={offset} count={max_bytes} 2>/dev/null || true\"",
      "comment": "Yeah, we could -- updated to use tail instead:  https://github.com/apache/airflow/pull/60297/commits/c705a4180fd7b42624c761d7e9189b9ff77cbd93",
      "comment_id": 2676746500,
      "user": "kaxil",
      "created_at": "2026-01-09T16:05:05Z",
      "url": "https://github.com/apache/airflow/pull/60297#discussion_r2676746500"
    },
    {
      "repo": "apache/airflow",
      "pr_number": 60297,
      "file_path": "providers/ssh/src/airflow/providers/ssh/operators/ssh_remote_job.py",
      "line": 417,
      "side": "RIGHT",
      "diff_hunk": "@@ -0,0 +1,456 @@\n+#\n+# Licensed to the Apache Software Foundation (ASF) under one\n+# or more contributor license agreements.  See the NOTICE file\n+# distributed with this work for additional information\n+# regarding copyright ownership.  The ASF licenses this file\n+# to you under the Apache License, Version 2.0 (the\n+# \"License\"); you may not use this file except in compliance\n+# with the License.  You may obtain a copy of the License at\n+#\n+#   http://www.apache.org/licenses/LICENSE-2.0\n+#\n+# Unless required by applicable law or agreed to in writing,\n+# software distributed under the License is distributed on an\n+# \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+# KIND, either express or implied.  See the License for the\n+# specific language governing permissions and limitations\n+# under the License.\n+\"\"\"SSH Remote Job Operator for deferrable remote command execution.\"\"\"\n+\n+from __future__ import annotations\n+\n+from collections.abc import Container, Sequence\n+from datetime import timedelta\n+from functools import cached_property\n+from typing import TYPE_CHECKING, Any, Literal\n+\n+from airflow.providers.common.compat.sdk import AirflowException, AirflowSkipException, BaseOperator\n+from airflow.providers.ssh.hooks.ssh import SSHHook\n+from airflow.providers.ssh.triggers.ssh_remote_job import SSHRemoteJobTrigger\n+from airflow.providers.ssh.utils.remote_job import (\n+    RemoteJobPaths,\n+    build_posix_cleanup_command,\n+    build_posix_kill_command,\n+    build_posix_os_detection_command,\n+    build_posix_wrapper_command,\n+    build_windows_cleanup_command,\n+    build_windows_kill_command,\n+    build_windows_os_detection_command,\n+    build_windows_wrapper_command,\n+    generate_job_id,\n+)\n+\n+if TYPE_CHECKING:\n+    from airflow.utils.context import Context\n+\n+\n+class SSHRemoteJobOperator(BaseOperator):\n+    r\"\"\"\n+    Execute a command on a remote host via SSH with deferrable monitoring.\n+\n+    This operator submits a job to run detached on the remote host, then\n+    uses a trigger to asynchronously monitor the job status and stream logs.\n+    This approach is resilient to network interruptions as the remote job\n+    continues running independently of the SSH connection.\n+\n+    The remote job is wrapped to:\n+    - Run detached from the SSH session (via nohup on POSIX, Start-Process on Windows)\n+    - Redirect stdout/stderr to a log file\n+    - Write the exit code to a file on completion\n+\n+    :param ssh_conn_id: SSH connection ID from Airflow Connections\n+    :param command: Command to execute on the remote host (templated)\n+    :param remote_host: Override the host from the connection (templated)\n+    :param environment: Environment variables to set for the command (templated)\n+    :param remote_base_dir: Base directory for job artifacts (templated).\n+        Defaults to /tmp/airflow-ssh-jobs on POSIX, C:\\\\Windows\\\\Temp\\\\airflow-ssh-jobs on Windows\n+    :param poll_interval: Seconds between status polls (default: 5)\n+    :param log_chunk_size: Max bytes to read per poll (default: 65536)\n+    :param timeout: Hard timeout in seconds for the entire operation\n+    :param cleanup: When to clean up remote job directory:\n+        'never', 'on_success', or 'always' (default: 'never')\n+    :param remote_os: Remote operating system: 'auto', 'posix', or 'windows' (default: 'auto')\n+    :param skip_on_exit_code: Exit codes that should skip the task instead of failing\n+    :param conn_timeout: SSH connection timeout in seconds\n+    :param banner_timeout: Timeout waiting for SSH banner in seconds\n+    \"\"\"\n+\n+    template_fields: Sequence[str] = (\"command\", \"environment\", \"remote_host\", \"remote_base_dir\")\n+    template_ext: Sequence[str] = (\n+        \".sh\",\n+        \".bash\",\n+        \".ps1\",\n+    )\n+    template_fields_renderers = {\n+        \"command\": \"bash\",\n+        \"environment\": \"python\",\n+    }\n+    ui_color = \"#e4f0e8\"\n+\n+    def __init__(\n+        self,\n+        *,\n+        ssh_conn_id: str,\n+        command: str,\n+        remote_host: str | None = None,\n+        environment: dict[str, str] | None = None,\n+        remote_base_dir: str | None = None,\n+        poll_interval: int = 5,\n+        log_chunk_size: int = 65536,\n+        timeout: int | None = None,\n+        cleanup: Literal[\"never\", \"on_success\", \"always\"] = \"never\",\n+        remote_os: Literal[\"auto\", \"posix\", \"windows\"] = \"auto\",\n+        skip_on_exit_code: int | Container[int] | None = None,\n+        conn_timeout: int | None = None,\n+        banner_timeout: float = 30.0,\n+        **kwargs,\n+    ) -> None:\n+        super().__init__(**kwargs)\n+        self.ssh_conn_id = ssh_conn_id\n+        self.command = command\n+        self.remote_host = remote_host\n+        self.environment = environment\n+\n+        if remote_base_dir is not None:\n+            self._validate_base_dir(remote_base_dir)\n+        self.remote_base_dir = remote_base_dir\n+\n+        self.poll_interval = poll_interval\n+        self.log_chunk_size = log_chunk_size\n+        self.timeout = timeout\n+        self.cleanup = cleanup\n+        self.remote_os = remote_os\n+        self.conn_timeout = conn_timeout\n+        self.banner_timeout = banner_timeout\n+        self.skip_on_exit_code = (\n+            skip_on_exit_code\n+            if isinstance(skip_on_exit_code, Container)\n+            else [skip_on_exit_code]\n+            if skip_on_exit_code is not None\n+            else []\n+        )\n+\n+        self._job_id: str | None = None\n+        self._paths: RemoteJobPaths | None = None\n+        self._detected_os: Literal[\"posix\", \"windows\"] | None = None\n+\n+    @staticmethod\n+    def _validate_base_dir(path: str) -> None:\n+        \"\"\"\n+        Validate the remote base directory path for security.\n+\n+        :param path: Path to validate\n+        :raises ValueError: If path contains dangerous patterns\n+        \"\"\"\n+        if not path:\n+            raise ValueError(\"remote_base_dir cannot be empty\")\n+\n+        if \"..\" in path:\n+            raise ValueError(f\"remote_base_dir cannot contain '..' (path traversal not allowed). Got: {path}\")\n+\n+        if \"\\x00\" in path:\n+            raise ValueError(\"remote_base_dir cannot contain null bytes\")\n+\n+        dangerous_patterns = [\"/etc\", \"/bin\", \"/sbin\", \"/boot\", \"C:\\\\Windows\", \"C:\\\\Program Files\"]\n+        for pattern in dangerous_patterns:\n+            if pattern in path:\n+                import warnings\n+\n+                warnings.warn(\n+                    f\"remote_base_dir '{path}' contains potentially sensitive path '{pattern}'. \"\n+                    \"Ensure you have appropriate permissions.\",\n+                    UserWarning,\n+                    stacklevel=3,\n+                )\n+\n+    @cached_property\n+    def ssh_hook(self) -> SSHHook:\n+        \"\"\"Create the SSH hook for command submission.\"\"\"\n+        return SSHHook(\n+            ssh_conn_id=self.ssh_conn_id,\n+            remote_host=self.remote_host or \"\",\n+            conn_timeout=self.conn_timeout,\n+            banner_timeout=self.banner_timeout,\n+        )\n+\n+    def _detect_remote_os(self) -> Literal[\"posix\", \"windows\"]:\n+        \"\"\"\n+        Detect the remote operating system.\n+\n+        Uses a two-stage detection:\n+        1. Try POSIX detection via `uname` (works on Linux, macOS, BSD, Solaris, AIX, etc.)\n+        2. Try Windows detection via PowerShell\n+        3. Raise error if both fail\n+        \"\"\"\n+        if self.remote_os != \"auto\":\n+            return self.remote_os\n+\n+        self.log.info(\"Auto-detecting remote operating system...\")\n+        with self.ssh_hook.get_conn() as ssh_client:\n+            try:\n+                exit_status, stdout, _ = self.ssh_hook.exec_ssh_client_command(\n+                    ssh_client,\n+                    build_posix_os_detection_command(),\n+                    get_pty=False,\n+                    environment=None,\n+                    timeout=10,\n+                )\n+                if exit_status == 0 and stdout:\n+                    output = stdout.decode(\"utf-8\", errors=\"replace\").strip().lower()\n+                    posix_systems = [\n+                        \"linux\",\n+                        \"darwin\",\n+                        \"freebsd\",\n+                        \"openbsd\",\n+                        \"netbsd\",\n+                        \"sunos\",\n+                        \"aix\",\n+                        \"hp-ux\",\n+                    ]\n+                    if any(system in output for system in posix_systems):\n+                        self.log.info(\"Detected POSIX system: %s\", output)\n+                        return \"posix\"\n+            except Exception as e:\n+                self.log.debug(\"POSIX detection failed: %s\", e)\n+\n+            try:\n+                exit_status, stdout, _ = self.ssh_hook.exec_ssh_client_command(\n+                    ssh_client,\n+                    build_windows_os_detection_command(),\n+                    get_pty=False,\n+                    environment=None,\n+                    timeout=10,\n+                )\n+                if exit_status == 0 and stdout:\n+                    output = stdout.decode(\"utf-8\", errors=\"replace\").strip()\n+                    if \"WINDOWS\" in output.upper():\n+                        self.log.info(\"Detected Windows system\")\n+                        return \"windows\"\n+            except Exception as e:\n+                self.log.debug(\"Windows detection failed: %s\", e)\n+\n+            raise AirflowException(\n+                \"Could not auto-detect remote OS. Please explicitly set remote_os='posix' or 'windows'\"\n+            )\n+\n+    def execute(self, context: Context) -> None:\n+        \"\"\"\n+        Submit the remote job and defer to the trigger for monitoring.\n+\n+        :param context: Airflow task context\n+        \"\"\"\n+        if not self.command:\n+            raise AirflowException(\"SSH operator error: command not specified.\")\n+\n+        self._detected_os = self._detect_remote_os()\n+        self.log.info(\"Remote OS: %s\", self._detected_os)\n+\n+        ti = context[\"ti\"]\n+        self._job_id = generate_job_id(\n+            dag_id=ti.dag_id,\n+            task_id=ti.task_id,\n+            run_id=ti.run_id,\n+            try_number=ti.try_number,\n+        )\n+        self.log.info(\"Generated job ID: %s\", self._job_id)\n+\n+        self._paths = RemoteJobPaths(\n+            job_id=self._job_id,\n+            remote_os=self._detected_os,\n+            base_dir=self.remote_base_dir,\n+        )\n+\n+        if self._detected_os == \"posix\":\n+            wrapper_cmd = build_posix_wrapper_command(\n+                command=self.command,\n+                paths=self._paths,\n+                environment=self.environment,\n+            )\n+        else:\n+            wrapper_cmd = build_windows_wrapper_command(\n+                command=self.command,\n+                paths=self._paths,\n+                environment=self.environment,\n+            )\n+\n+        self.log.info(\"Submitting remote job to %s\", self.ssh_hook.remote_host or \"configured host\")\n+        with self.ssh_hook.get_conn() as ssh_client:\n+            exit_status, stdout, stderr = self.ssh_hook.exec_ssh_client_command(\n+                ssh_client,\n+                wrapper_cmd,\n+                get_pty=False,\n+                environment=None,\n+                timeout=60,\n+            )\n+\n+            if exit_status != 0:\n+                stderr_str = stderr.decode(\"utf-8\", errors=\"replace\") if stderr else \"\"\n+                raise AirflowException(\n+                    f\"Failed to submit remote job. Exit code: {exit_status}. Error: {stderr_str}\"\n+                )\n+\n+            returned_job_id = stdout.decode(\"utf-8\", errors=\"replace\").strip() if stdout else \"\"\n+            if returned_job_id != self._job_id:\n+                self.log.warning(\"Job ID mismatch. Expected: %s, Got: %s\", self._job_id, returned_job_id)\n+\n+        self.log.info(\"Remote job submitted successfully. Job ID: %s\", self._job_id)\n+        self.log.info(\"Job directory: %s\", self._paths.job_dir)\n+\n+        if self.do_xcom_push:\n+            ti.xcom_push(\n+                key=\"ssh_remote_job\",\n+                value={\n+                    \"job_id\": self._job_id,\n+                    \"job_dir\": self._paths.job_dir,\n+                    \"log_file\": self._paths.log_file,\n+                    \"exit_code_file\": self._paths.exit_code_file,\n+                    \"pid_file\": self._paths.pid_file,\n+                    \"remote_os\": self._detected_os,\n+                },\n+            )\n+\n+        self.defer(\n+            trigger=SSHRemoteJobTrigger(\n+                ssh_conn_id=self.ssh_conn_id,\n+                remote_host=self.remote_host,\n+                job_id=self._job_id,\n+                job_dir=self._paths.job_dir,\n+                log_file=self._paths.log_file,\n+                exit_code_file=self._paths.exit_code_file,\n+                remote_os=self._detected_os,\n+                poll_interval=self.poll_interval,\n+                log_chunk_size=self.log_chunk_size,\n+                log_offset=0,\n+            ),\n+            method_name=\"execute_complete\",\n+            timeout=timedelta(seconds=self.timeout) if self.timeout else None,\n+        )\n+\n+    def execute_complete(self, context: Context, event: dict[str, Any]) -> None:\n+        \"\"\"\n+        Handle trigger events and re-defer if job is still running.\n+\n+        :param context: Airflow task context\n+        :param event: Event data from the trigger\n+        \"\"\"\n+        if not event:\n+            raise AirflowException(\"Received null event from trigger\")\n+\n+        required_keys = [\"job_id\", \"job_dir\", \"log_file\", \"exit_code_file\", \"remote_os\", \"done\"]\n+        missing_keys = [key for key in required_keys if key not in event]\n+        if missing_keys:\n+            raise AirflowException(\n+                f\"Invalid trigger event: missing required keys {missing_keys}. Event: {event}\"\n+            )\n+\n+        log_chunk = event.get(\"log_chunk\", \"\")\n+        if log_chunk:\n+            for line in log_chunk.splitlines():\n+                self.log.info(\"[remote] %s\", line)\n+\n+        if not event.get(\"done\", False):\n+            self.log.debug(\"Job still running, continuing to monitor...\")\n+            self.defer(\n+                trigger=SSHRemoteJobTrigger(\n+                    ssh_conn_id=self.ssh_conn_id,\n+                    remote_host=self.remote_host,\n+                    job_id=event[\"job_id\"],\n+                    job_dir=event[\"job_dir\"],\n+                    log_file=event[\"log_file\"],\n+                    exit_code_file=event[\"exit_code_file\"],\n+                    remote_os=event[\"remote_os\"],\n+                    poll_interval=self.poll_interval,\n+                    log_chunk_size=self.log_chunk_size,\n+                    log_offset=event.get(\"log_offset\", 0),\n+                ),\n+                method_name=\"execute_complete\",\n+                timeout=timedelta(seconds=self.timeout) if self.timeout else None,\n+            )\n+            return\n+\n+        exit_code = event.get(\"exit_code\")\n+        job_dir = event.get(\"job_dir\", \"\")\n+        remote_os = event.get(\"remote_os\", \"posix\")\n+\n+        self.log.info(\"Remote job completed with exit code: %s\", exit_code)\n+\n+        should_cleanup = self.cleanup == \"always\" or (self.cleanup == \"on_success\" and exit_code == 0)\n+        if should_cleanup and job_dir:\n+            self._cleanup_remote_job(job_dir, remote_os)\n+\n+        if exit_code is None:\n+            raise AirflowException(f\"Remote job failed: {event.get('message', 'Unknown error')}\")\n+\n+        if exit_code in self.skip_on_exit_code:\n+            raise AirflowSkipException(f\"Remote job returned skip exit code: {exit_code}\")\n+\n+        if exit_code != 0:\n+            raise AirflowException(f\"Remote job failed with exit code: {exit_code}\")\n+\n+        self.log.info(\"Remote job completed successfully\")\n+\n+    def _cleanup_remote_job(self, job_dir: str, remote_os: str) -> None:\n+        \"\"\"Clean up the remote job directory.\"\"\"\n+        self.log.info(\"Cleaning up remote job directory: %s\", job_dir)\n+        try:\n+            if remote_os == \"posix\":\n+                cleanup_cmd = build_posix_cleanup_command(job_dir)\n+            else:\n+                cleanup_cmd = build_windows_cleanup_command(job_dir)\n+\n+            with self.ssh_hook.get_conn() as ssh_client:\n+                self.ssh_hook.exec_ssh_client_command(\n+                    ssh_client,\n+                    cleanup_cmd,\n+                    get_pty=False,\n+                    environment=None,\n+                    timeout=30,\n+                )\n+            self.log.info(\"Remote cleanup completed\")\n+        except Exception as e:\n+            self.log.warning(\"Failed to clean up remote job directory: %s\", e)\n+\n+    def on_kill(self) -> None:\n+        \"\"\"\n+        Attempt to kill the remote process when the task is killed.\n+\n+        Since the operator instance may have been rehydrated after deferral,",
      "comment": "Changed it to say \"Since the operator is recreated after deferral\"",
      "comment_id": 2676756347,
      "user": "kaxil",
      "created_at": "2026-01-09T16:07:26Z",
      "url": "https://github.com/apache/airflow/pull/60297#discussion_r2676756347"
    },
    {
      "repo": "apache/airflow",
      "pr_number": 60297,
      "file_path": "providers/ssh/src/airflow/providers/ssh/triggers/ssh_remote_job.py",
      "line": 250,
      "side": "RIGHT",
      "diff_hunk": "@@ -0,0 +1,280 @@\n+#\n+# Licensed to the Apache Software Foundation (ASF) under one\n+# or more contributor license agreements.  See the NOTICE file\n+# distributed with this work for additional information\n+# regarding copyright ownership.  The ASF licenses this file\n+# to you under the Apache License, Version 2.0 (the\n+# \"License\"); you may not use this file except in compliance\n+# with the License.  You may obtain a copy of the License at\n+#\n+#   http://www.apache.org/licenses/LICENSE-2.0\n+#\n+# Unless required by applicable law or agreed to in writing,\n+# software distributed under the License is distributed on an\n+# \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+# KIND, either express or implied.  See the License for the\n+# specific language governing permissions and limitations\n+# under the License.\n+\"\"\"SSH Remote Job Trigger for deferrable execution.\"\"\"\n+\n+from __future__ import annotations\n+\n+import asyncio\n+from collections.abc import AsyncIterator\n+from typing import Any, Literal\n+\n+import tenacity\n+\n+from airflow.providers.ssh.hooks.ssh import SSHHookAsync\n+from airflow.providers.ssh.utils.remote_job import (\n+    build_posix_completion_check_command,\n+    build_posix_file_size_command,\n+    build_posix_log_tail_command,\n+    build_windows_completion_check_command,\n+    build_windows_file_size_command,\n+    build_windows_log_tail_command,\n+)\n+from airflow.triggers.base import BaseTrigger, TriggerEvent\n+\n+\n+class SSHRemoteJobTrigger(BaseTrigger):\n+    \"\"\"\n+    Trigger that monitors a remote SSH job and streams logs.\n+\n+    This trigger polls the remote host to check job completion status\n+    and reads log output incrementally.\n+\n+    :param ssh_conn_id: SSH connection ID from Airflow Connections\n+    :param remote_host: Optional override for the remote host\n+    :param job_id: Unique identifier for the remote job\n+    :param job_dir: Remote directory containing job artifacts\n+    :param log_file: Path to the log file on the remote host\n+    :param exit_code_file: Path to the exit code file on the remote host\n+    :param remote_os: Operating system of the remote host ('posix' or 'windows')\n+    :param poll_interval: Seconds between polling attempts\n+    :param log_chunk_size: Maximum bytes to read per poll\n+    :param log_offset: Current byte offset in the log file\n+    \"\"\"\n+\n+    def __init__(\n+        self,\n+        ssh_conn_id: str,\n+        remote_host: str | None,\n+        job_id: str,\n+        job_dir: str,\n+        log_file: str,\n+        exit_code_file: str,\n+        remote_os: Literal[\"posix\", \"windows\"],\n+        poll_interval: int = 5,\n+        log_chunk_size: int = 65536,\n+        log_offset: int = 0,\n+        command_timeout: float = 30.0,\n+    ) -> None:\n+        super().__init__()\n+        self.ssh_conn_id = ssh_conn_id\n+        self.remote_host = remote_host\n+        self.job_id = job_id\n+        self.job_dir = job_dir\n+        self.log_file = log_file\n+        self.exit_code_file = exit_code_file\n+        self.remote_os = remote_os\n+        self.poll_interval = poll_interval\n+        self.log_chunk_size = log_chunk_size\n+        self.log_offset = log_offset\n+        self.command_timeout = command_timeout\n+\n+    def serialize(self) -> tuple[str, dict[str, Any]]:\n+        \"\"\"Serialize the trigger for storage.\"\"\"\n+        return (\n+            \"airflow.providers.ssh.triggers.ssh_remote_job.SSHRemoteJobTrigger\",\n+            {\n+                \"ssh_conn_id\": self.ssh_conn_id,\n+                \"remote_host\": self.remote_host,\n+                \"job_id\": self.job_id,\n+                \"job_dir\": self.job_dir,\n+                \"log_file\": self.log_file,\n+                \"exit_code_file\": self.exit_code_file,\n+                \"remote_os\": self.remote_os,\n+                \"poll_interval\": self.poll_interval,\n+                \"log_chunk_size\": self.log_chunk_size,\n+                \"log_offset\": self.log_offset,\n+                \"command_timeout\": self.command_timeout,\n+            },\n+        )\n+\n+    def _get_hook(self) -> SSHHookAsync:\n+        \"\"\"Create the async SSH hook.\"\"\"\n+        return SSHHookAsync(\n+            ssh_conn_id=self.ssh_conn_id,\n+            host=self.remote_host,\n+        )\n+\n+    @tenacity.retry(\n+        stop=tenacity.stop_after_attempt(3),\n+        wait=tenacity.wait_exponential(multiplier=1, min=1, max=10),\n+        retry=tenacity.retry_if_exception_type((OSError, TimeoutError, ConnectionError)),\n+        reraise=True,\n+    )\n+    async def _check_completion(self, hook: SSHHookAsync) -> int | None:\n+        \"\"\"\n+        Check if the remote job has completed.\n+\n+        Retries transient network errors up to 3 times with exponential backoff.\n+\n+        :return: Exit code if completed, None if still running\n+        \"\"\"\n+        if self.remote_os == \"posix\":\n+            cmd = build_posix_completion_check_command(self.exit_code_file)\n+        else:\n+            cmd = build_windows_completion_check_command(self.exit_code_file)\n+\n+        try:\n+            _, stdout, _ = await hook.run_command(cmd, timeout=self.command_timeout)\n+            stdout = stdout.strip()\n+            if stdout and stdout.isdigit():\n+                return int(stdout)\n+        except (OSError, TimeoutError, ConnectionError) as e:\n+            self.log.warning(\"Transient error checking completion (will retry): %s\", e)\n+            raise\n+        except Exception as e:\n+            self.log.warning(\"Error checking completion status: %s\", e)\n+        return None\n+\n+    @tenacity.retry(\n+        stop=tenacity.stop_after_attempt(3),\n+        wait=tenacity.wait_exponential(multiplier=1, min=1, max=10),\n+        retry=tenacity.retry_if_exception_type((OSError, TimeoutError, ConnectionError)),\n+        reraise=True,\n+    )\n+    async def _get_log_size(self, hook: SSHHookAsync) -> int:\n+        \"\"\"\n+        Get the current size of the log file in bytes.\n+\n+        Retries transient network errors up to 3 times with exponential backoff.\n+        \"\"\"\n+        if self.remote_os == \"posix\":\n+            cmd = build_posix_file_size_command(self.log_file)\n+        else:\n+            cmd = build_windows_file_size_command(self.log_file)\n+\n+        try:\n+            _, stdout, _ = await hook.run_command(cmd, timeout=self.command_timeout)\n+            stdout = stdout.strip()\n+            if stdout and stdout.isdigit():\n+                return int(stdout)\n+        except (OSError, TimeoutError, ConnectionError) as e:\n+            self.log.warning(\"Transient error getting log size (will retry): %s\", e)\n+            raise\n+        except Exception as e:\n+            self.log.warning(\"Error getting log file size: %s\", e)\n+        return 0\n+\n+    @tenacity.retry(\n+        stop=tenacity.stop_after_attempt(3),\n+        wait=tenacity.wait_exponential(multiplier=1, min=1, max=10),\n+        retry=tenacity.retry_if_exception_type((OSError, TimeoutError, ConnectionError)),\n+        reraise=True,\n+    )\n+    async def _read_log_chunk(self, hook: SSHHookAsync) -> tuple[str, int]:\n+        \"\"\"\n+        Read a chunk of logs from the current offset.\n+\n+        Retries transient network errors up to 3 times with exponential backoff.\n+\n+        :return: Tuple of (log_chunk, new_offset)\n+        \"\"\"\n+        file_size = await self._get_log_size(hook)\n+        if file_size <= self.log_offset:\n+            return \"\", self.log_offset\n+\n+        bytes_available = file_size - self.log_offset\n+        bytes_to_read = min(bytes_available, self.log_chunk_size)\n+\n+        if self.remote_os == \"posix\":\n+            cmd = build_posix_log_tail_command(self.log_file, self.log_offset, bytes_to_read)\n+        else:\n+            cmd = build_windows_log_tail_command(self.log_file, self.log_offset, bytes_to_read)\n+\n+        try:\n+            exit_code, stdout, _ = await hook.run_command(cmd, timeout=self.command_timeout)\n+\n+            # Advance offset by bytes requested, not decoded string length\n+            new_offset = self.log_offset + bytes_to_read if stdout else self.log_offset\n+\n+            return stdout, new_offset\n+        except (OSError, TimeoutError, ConnectionError) as e:\n+            self.log.warning(\"Transient error reading logs (will retry): %s\", e)\n+            raise\n+        except Exception as e:\n+            self.log.warning(\"Error reading log chunk: %s\", e)\n+            return \"\", self.log_offset\n+\n+    async def run(self) -> AsyncIterator[TriggerEvent]:\n+        \"\"\"\n+        Poll the remote job status and yield events with log chunks.\n+\n+        This method runs in a loop, checking the job status and reading\n+        logs at each poll interval. It yields a TriggerEvent each time\n+        with the current status and any new log output.\n+        \"\"\"\n+        hook = self._get_hook()\n+\n+        while True:\n+            try:\n+                exit_code = await self._check_completion(hook)\n+                log_chunk, new_offset = await self._read_log_chunk(hook)\n+\n+                base_event = {\n+                    \"job_id\": self.job_id,\n+                    \"job_dir\": self.job_dir,\n+                    \"log_file\": self.log_file,\n+                    \"exit_code_file\": self.exit_code_file,\n+                    \"remote_os\": self.remote_os,\n+                }\n+\n+                if exit_code is not None:\n+                    yield TriggerEvent(\n+                        {\n+                            **base_event,\n+                            \"status\": \"success\" if exit_code == 0 else \"failed\",\n+                            \"done\": True,\n+                            \"exit_code\": exit_code,\n+                            \"log_chunk\": log_chunk,\n+                            \"log_offset\": new_offset,\n+                            \"message\": f\"Job completed with exit code {exit_code}\",\n+                        }\n+                    )\n+                    return\n+\n+                self.log_offset = new_offset\n+                yield TriggerEvent(",
      "comment": "do we need to yield event here ? as the job is still running, just logging and sleep is sufficient ?",
      "comment_id": 2677817053,
      "user": "gopidesupavan",
      "created_at": "2026-01-09T22:39:26Z",
      "url": "https://github.com/apache/airflow/pull/60297#discussion_r2677817053"
    },
    {
      "repo": "apache/airflow",
      "pr_number": 60297,
      "file_path": "providers/ssh/src/airflow/providers/ssh/utils/remote_job.py",
      "line": 415,
      "side": "RIGHT",
      "diff_hunk": "@@ -0,0 +1,422 @@\n+#\n+# Licensed to the Apache Software Foundation (ASF) under one\n+# or more contributor license agreements.  See the NOTICE file\n+# distributed with this work for additional information\n+# regarding copyright ownership.  The ASF licenses this file\n+# to you under the Apache License, Version 2.0 (the\n+# \"License\"); you may not use this file except in compliance\n+# with the License.  You may obtain a copy of the License at\n+#\n+#   http://www.apache.org/licenses/LICENSE-2.0\n+#\n+# Unless required by applicable law or agreed to in writing,\n+# software distributed under the License is distributed on an\n+# \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+# KIND, either express or implied.  See the License for the\n+# specific language governing permissions and limitations\n+# under the License.\n+\"\"\"Utilities for SSH remote job execution.\"\"\"\n+\n+from __future__ import annotations\n+\n+import base64\n+import re\n+import secrets\n+import string\n+from dataclasses import dataclass\n+from typing import Literal\n+\n+\n+def _validate_env_var_name(name: str) -> None:\n+    \"\"\"\n+    Validate environment variable name for security.\n+\n+    :param name: Environment variable name\n+    :raises ValueError: If name contains dangerous characters\n+    \"\"\"\n+    if not name:\n+        raise ValueError(\"Environment variable name cannot be empty\")\n+\n+    if not re.match(r\"^[a-zA-Z_][a-zA-Z0-9_]*$\", name):\n+        raise ValueError(\n+            f\"Invalid environment variable name '{name}'. \"\n+            \"Only alphanumeric characters and underscores are allowed, \"\n+            \"and the name must start with a letter or underscore.\"\n+        )\n+\n+\n+def generate_job_id(\n+    dag_id: str,\n+    task_id: str,\n+    run_id: str,\n+    try_number: int,\n+    suffix_length: int = 8,\n+) -> str:\n+    \"\"\"\n+    Generate a unique job ID for remote execution.\n+\n+    Creates a deterministic identifier from the task context with a random suffix\n+    to ensure uniqueness across retries and potential race conditions.\n+\n+    :param dag_id: The DAG identifier\n+    :param task_id: The task identifier\n+    :param run_id: The run identifier\n+    :param try_number: The attempt number\n+    :param suffix_length: Length of random suffix (default 8)\n+    :return: Sanitized job ID string\n+    \"\"\"\n+\n+    def sanitize(value: str) -> str:\n+        return re.sub(r\"[^a-zA-Z0-9]\", \"_\", value)[:50]\n+\n+    sanitized_dag = sanitize(dag_id)\n+    sanitized_task = sanitize(task_id)\n+    sanitized_run = sanitize(run_id)\n+\n+    alphabet = string.ascii_lowercase + string.digits\n+    suffix = \"\".join(secrets.choice(alphabet) for _ in range(suffix_length))\n+\n+    return f\"af_{sanitized_dag}_{sanitized_task}_{sanitized_run}_try{try_number}_{suffix}\"\n+\n+\n+@dataclass\n+class RemoteJobPaths:\n+    \"\"\"Paths for remote job artifacts on the target system.\"\"\"\n+\n+    job_id: str\n+    remote_os: Literal[\"posix\", \"windows\"]\n+    base_dir: str | None = None\n+\n+    def __post_init__(self):\n+        if self.base_dir is None:\n+            if self.remote_os == \"posix\":\n+                self.base_dir = \"/tmp/airflow-ssh-jobs\"\n+            else:\n+                self.base_dir = \"$env:TEMP\\\\airflow-ssh-jobs\"\n+\n+    @property\n+    def sep(self) -> str:\n+        \"\"\"Path separator for the remote OS.\"\"\"\n+        return \"\\\\\" if self.remote_os == \"windows\" else \"/\"\n+\n+    @property\n+    def job_dir(self) -> str:\n+        \"\"\"Directory containing all job artifacts.\"\"\"\n+        return f\"{self.base_dir}{self.sep}{self.job_id}\"\n+\n+    @property\n+    def log_file(self) -> str:\n+        \"\"\"Path to stdout/stderr log file.\"\"\"\n+        return f\"{self.job_dir}{self.sep}stdout.log\"\n+\n+    @property\n+    def exit_code_file(self) -> str:\n+        \"\"\"Path to exit code file (written on completion).\"\"\"\n+        return f\"{self.job_dir}{self.sep}exit_code\"\n+\n+    @property\n+    def exit_code_tmp_file(self) -> str:\n+        \"\"\"Temporary exit code file (for atomic write).\"\"\"\n+        return f\"{self.job_dir}{self.sep}exit_code.tmp\"\n+\n+    @property\n+    def pid_file(self) -> str:\n+        \"\"\"Path to PID file for the background process.\"\"\"\n+        return f\"{self.job_dir}{self.sep}pid\"\n+\n+    @property\n+    def status_file(self) -> str:\n+        \"\"\"Path to optional status file for progress updates.\"\"\"\n+        return f\"{self.job_dir}{self.sep}status\"\n+\n+\n+def build_posix_wrapper_command(\n+    command: str,\n+    paths: RemoteJobPaths,\n+    environment: dict[str, str] | None = None,\n+) -> str:\n+    \"\"\"\n+    Build a POSIX shell wrapper that runs the command detached via nohup.\n+\n+    The wrapper:\n+    - Creates the job directory\n+    - Starts the command in the background with nohup\n+    - Redirects stdout/stderr to the log file\n+    - Writes the exit code atomically on completion\n+    - Writes the PID for potential cancellation\n+\n+    :param command: The command to execute\n+    :param paths: RemoteJobPaths instance with all paths\n+    :param environment: Optional environment variables to set\n+    :return: Shell command string to submit via SSH\n+    \"\"\"\n+    env_exports = \"\"\n+    if environment:\n+        for key, value in environment.items():\n+            _validate_env_var_name(key)\n+            escaped_value = value.replace(\"'\", \"'\\\"'\\\"'\")\n+            env_exports += f\"export {key}='{escaped_value}'\\n\"\n+\n+    escaped_command = command.replace(\"'\", \"'\\\"'\\\"'\")\n+\n+    wrapper = f\"\"\"set -euo pipefail\n+job_dir='{paths.job_dir}'\n+log_file='{paths.log_file}'\n+exit_code_file='{paths.exit_code_file}'\n+exit_code_tmp='{paths.exit_code_tmp_file}'\n+pid_file='{paths.pid_file}'\n+status_file='{paths.status_file}'\n+\n+mkdir -p \"$job_dir\"\n+: > \"$log_file\"\n+\n+nohup bash -c '\n+set +e\n+export LOG_FILE=\"'\"$log_file\"'\"\n+export STATUS_FILE=\"'\"$status_file\"'\"\n+{env_exports}{escaped_command} >>\"'\"$log_file\"'\" 2>&1\n+ec=$?\n+echo -n \"$ec\" > \"'\"$exit_code_tmp\"'\"\n+mv \"'\"$exit_code_tmp\"'\" \"'\"$exit_code_file\"'\"\n+exit 0\n+' >/dev/null 2>&1 &\n+\n+echo -n $! > \"$pid_file\"\n+echo \"{paths.job_id}\"\n+\"\"\"\n+    return wrapper\n+\n+\n+def build_windows_wrapper_command(\n+    command: str,\n+    paths: RemoteJobPaths,\n+    environment: dict[str, str] | None = None,\n+) -> str:\n+    \"\"\"\n+    Build a PowerShell wrapper that runs the command detached via Start-Process.\n+\n+    The wrapper:\n+    - Creates the job directory\n+    - Starts the command in a new detached PowerShell process\n+    - Redirects stdout/stderr to the log file\n+    - Writes the exit code atomically on completion\n+    - Writes the PID for potential cancellation\n+\n+    :param command: The command to execute (PowerShell script path or command)\n+    :param paths: RemoteJobPaths instance with all paths\n+    :param environment: Optional environment variables to set\n+    :return: PowerShell command string to submit via SSH\n+    \"\"\"\n+    env_setup = \"\"\n+    if environment:\n+        for key, value in environment.items():\n+            _validate_env_var_name(key)\n+            escaped_value = value.replace(\"'\", \"''\")\n+            env_setup += f\"$env:{key} = '{escaped_value}'; \"\n+\n+    def ps_escape(s: str) -> str:\n+        return s.replace(\"'\", \"''\")\n+\n+    job_dir = ps_escape(paths.job_dir)\n+    log_file = ps_escape(paths.log_file)\n+    exit_code_file = ps_escape(paths.exit_code_file)\n+    exit_code_tmp = ps_escape(paths.exit_code_tmp_file)\n+    pid_file = ps_escape(paths.pid_file)\n+    status_file = ps_escape(paths.status_file)\n+    escaped_command = ps_escape(command)\n+    job_id = ps_escape(paths.job_id)\n+\n+    child_script = f\"\"\"$ErrorActionPreference = 'Continue'\n+$env:LOG_FILE = '{log_file}'\n+$env:STATUS_FILE = '{status_file}'\n+{env_setup}\n+{escaped_command}\n+$ec = $LASTEXITCODE\n+if ($null -eq $ec) {{ $ec = 0 }}\n+Set-Content -NoNewline -Path '{exit_code_tmp}' -Value $ec\n+Move-Item -Force -Path '{exit_code_tmp}' -Destination '{exit_code_file}'\n+\"\"\"\n+    child_script_bytes = child_script.encode(\"utf-16-le\")\n+    encoded_script = base64.b64encode(child_script_bytes).decode(\"ascii\")\n+\n+    wrapper = f\"\"\"$jobDir = '{job_dir}'\n+New-Item -ItemType Directory -Force -Path $jobDir | Out-Null\n+$log = '{log_file}'\n+'' | Set-Content -Path $log\n+\n+$p = Start-Process -FilePath 'powershell.exe' -ArgumentList @('-NoProfile', '-NonInteractive', '-EncodedCommand', '{encoded_script}') -RedirectStandardOutput $log -RedirectStandardError $log -PassThru -WindowStyle Hidden\n+Set-Content -NoNewline -Path '{pid_file}' -Value $p.Id\n+Write-Output '{job_id}'\n+\"\"\"\n+    wrapper_bytes = wrapper.encode(\"utf-16-le\")\n+    encoded_wrapper = base64.b64encode(wrapper_bytes).decode(\"ascii\")\n+\n+    return f\"powershell.exe -NoProfile -NonInteractive -EncodedCommand {encoded_wrapper}\"\n+\n+\n+def build_posix_log_tail_command(log_file: str, offset: int, max_bytes: int) -> str:\n+    \"\"\"\n+    Build a POSIX command to read log bytes from offset.\n+\n+    :param log_file: Path to the log file\n+    :param offset: Byte offset to start reading from\n+    :param max_bytes: Maximum bytes to read\n+    :return: Shell command that outputs the log chunk\n+    \"\"\"\n+    # tail -c +N is 1-indexed, so offset 0 means start at byte 1\n+    tail_offset = offset + 1\n+    return f\"tail -c +{tail_offset} '{log_file}' 2>/dev/null | head -c {max_bytes} || true\"\n+\n+\n+def build_windows_log_tail_command(log_file: str, offset: int, max_bytes: int) -> str:\n+    \"\"\"\n+    Build a PowerShell command to read log bytes from offset.\n+\n+    :param log_file: Path to the log file\n+    :param offset: Byte offset to start reading from\n+    :param max_bytes: Maximum bytes to read\n+    :return: PowerShell command that outputs the log chunk\n+    \"\"\"\n+    escaped_path = log_file.replace(\"'\", \"''\")\n+    script = f\"\"\"$path = '{escaped_path}'\n+if (Test-Path $path) {{\n+  try {{\n+    $fs = [System.IO.File]::Open($path, 'Open', 'Read', 'ReadWrite')\n+    $fs.Seek({offset}, [System.IO.SeekOrigin]::Begin) | Out-Null\n+    $buf = New-Object byte[] {max_bytes}\n+    $n = $fs.Read($buf, 0, $buf.Length)\n+    $fs.Close()\n+    if ($n -gt 0) {{\n+      [System.Text.Encoding]::UTF8.GetString($buf, 0, $n)\n+    }}\n+  }} catch {{}}\n+}}\"\"\"\n+    script_bytes = script.encode(\"utf-16-le\")\n+    encoded_script = base64.b64encode(script_bytes).decode(\"ascii\")\n+    return f\"powershell.exe -NoProfile -NonInteractive -EncodedCommand {encoded_script}\"\n+\n+\n+def build_posix_file_size_command(file_path: str) -> str:\n+    \"\"\"\n+    Build a POSIX command to get file size in bytes.\n+\n+    :param file_path: Path to the file\n+    :return: Shell command that outputs the file size\n+    \"\"\"\n+    return f\"stat -c%s '{file_path}' 2>/dev/null || stat -f%z '{file_path}' 2>/dev/null || echo 0\"\n+\n+\n+def build_windows_file_size_command(file_path: str) -> str:\n+    \"\"\"\n+    Build a PowerShell command to get file size in bytes.\n+\n+    :param file_path: Path to the file\n+    :return: PowerShell command that outputs the file size\n+    \"\"\"\n+    escaped_path = file_path.replace(\"'\", \"''\")\n+    script = f\"\"\"$path = '{escaped_path}'\n+if (Test-Path $path) {{\n+  (Get-Item $path).Length\n+}} else {{\n+  0\n+}}\"\"\"\n+    script_bytes = script.encode(\"utf-16-le\")\n+    encoded_script = base64.b64encode(script_bytes).decode(\"ascii\")\n+    return f\"powershell.exe -NoProfile -NonInteractive -EncodedCommand {encoded_script}\"\n+\n+\n+def build_posix_completion_check_command(exit_code_file: str) -> str:\n+    \"\"\"\n+    Build a POSIX command to check if job completed and get exit code.\n+\n+    :param exit_code_file: Path to the exit code file\n+    :return: Shell command that outputs exit code if done, empty otherwise\n+    \"\"\"\n+    return f\"test -s '{exit_code_file}' && cat '{exit_code_file}' || true\"\n+\n+\n+def build_windows_completion_check_command(exit_code_file: str) -> str:\n+    \"\"\"\n+    Build a PowerShell command to check if job completed and get exit code.\n+\n+    :param exit_code_file: Path to the exit code file\n+    :return: PowerShell command that outputs exit code if done, empty otherwise\n+    \"\"\"\n+    escaped_path = exit_code_file.replace(\"'\", \"''\")\n+    script = f\"\"\"$path = '{escaped_path}'\n+if (Test-Path $path) {{\n+  $txt = Get-Content -Raw -Path $path\n+  if ($txt -match '^[0-9]+$') {{ $txt.Trim() }}\n+}}\"\"\"\n+    script_bytes = script.encode(\"utf-16-le\")\n+    encoded_script = base64.b64encode(script_bytes).decode(\"ascii\")\n+    return f\"powershell.exe -NoProfile -NonInteractive -EncodedCommand {encoded_script}\"\n+\n+\n+def build_posix_kill_command(pid_file: str) -> str:\n+    \"\"\"\n+    Build a POSIX command to kill the remote process.\n+\n+    :param pid_file: Path to the PID file\n+    :return: Shell command to kill the process\n+    \"\"\"\n+    return f\"test -f '{pid_file}' && kill $(cat '{pid_file}') 2>/dev/null || true\"\n+\n+\n+def build_windows_kill_command(pid_file: str) -> str:\n+    \"\"\"\n+    Build a PowerShell command to kill the remote process.\n+\n+    :param pid_file: Path to the PID file\n+    :return: PowerShell command to kill the process\n+    \"\"\"\n+    escaped_path = pid_file.replace(\"'\", \"''\")\n+    script = f\"\"\"$path = '{escaped_path}'\n+if (Test-Path $path) {{\n+  $pid = Get-Content $path\n+  Stop-Process -Id $pid -Force -ErrorAction SilentlyContinue\n+}}\"\"\"\n+    script_bytes = script.encode(\"utf-16-le\")\n+    encoded_script = base64.b64encode(script_bytes).decode(\"ascii\")\n+    return f\"powershell.exe -NoProfile -NonInteractive -EncodedCommand {encoded_script}\"\n+\n+\n+def build_posix_cleanup_command(job_dir: str) -> str:\n+    \"\"\"\n+    Build a POSIX command to clean up the job directory.\n+\n+    :param job_dir: Path to the job directory\n+    :return: Shell command to remove the directory\n+    \"\"\"\n+    return f\"rm -rf '{job_dir}'\"",
      "comment": "may be some extra validations here ? :) \n\nas we already knew the job directory starts with `/tmp/airflow-ssh-jobs` or `$env:TEMP\\\\airflow-ssh-jobs` we can validate once?",
      "comment_id": 2677831312,
      "user": "gopidesupavan",
      "created_at": "2026-01-09T22:47:02Z",
      "url": "https://github.com/apache/airflow/pull/60297#discussion_r2677831312"
    },
    {
      "repo": "apache/airflow",
      "pr_number": 60237,
      "file_path": "airflow-core/src/airflow/api_fastapi/core_api/routes/ui/config.py",
      "line": 85,
      "side": "RIGHT",
      "diff_hunk": "@@ -82,6 +82,7 @@ def get_configs() -> ConfigResponse:\n         \"show_external_log_redirect\": task_log_reader.supports_external_link,\n         \"external_log_name\": getattr(task_log_reader.log_handler, \"log_name\", None),\n         \"theme\": loads(conf.get(\"api\", \"theme\", fallback=THEME_FALLBACK)),\n+        \"multi_team\": conf.get(\"core\", \"multi_team\"),",
      "comment": "```suggestion\r\n        \"multi_team\": conf.getboolean(\"core\", \"multi_team\"),\r\n```",
      "comment_id": 2671112988,
      "user": "ephraimbuddy",
      "created_at": "2026-01-08T06:57:34Z",
      "url": "https://github.com/apache/airflow/pull/60237#discussion_r2671112988"
    },
    {
      "repo": "apache/airflow",
      "pr_number": 57768,
      "file_path": "providers/databricks/src/airflow/providers/databricks/plugins/databricks_workflow.py",
      "line": 146,
      "side": "RIGHT",
      "diff_hunk": "@@ -143,7 +143,10 @@ def _get_dagrun(dag, run_id: str, session: Session) -> DagRun:\n         if not session:\n             raise AirflowException(\"Session not provided.\")\n \n-        return session.query(DagRun).filter(DagRun.dag_id == dag.dag_id, DagRun.run_id == run_id).first()\n+        dagrun = session.query(DagRun).filter(DagRun.dag_id == dag.dag_id, DagRun.run_id == run_id).first()",
      "comment": "How about just use `.one()` instead and let SQLAlchemy raise the error?",
      "comment_id": 2488747122,
      "user": "uranusjr",
      "created_at": "2025-11-04T05:25:29Z",
      "url": "https://github.com/apache/airflow/pull/57768#discussion_r2488747122"
    },
    {
      "repo": "apache/airflow",
      "pr_number": 59521,
      "file_path": "providers/openlineage/src/airflow/providers/openlineage/utils/utils.py",
      "line": 1122,
      "side": "RIGHT",
      "diff_hunk": "@@ -1000,6 +1003,358 @@ def get_task_duration(ti):\n     }\n \n \n+def is_dag_run_asset_triggered(\n+    dag_run: DagRun,\n+):\n+    \"\"\"Return whether the given DAG run was triggered by an asset.\"\"\"\n+    if AIRFLOW_V_3_0_PLUS:\n+        from airflow.utils.types import DagRunTriggeredByType\n+\n+        return dag_run.triggered_by == DagRunTriggeredByType.ASSET\n+\n+    # AF 2 Path\n+    from airflow.models.dagrun import DagRunType\n+\n+    return dag_run.run_type == DagRunType.DATASET_TRIGGERED  # type: ignore[attr-defined]  # This attr is available on AF2, but mypy can't see it\n+\n+\n+def build_task_instance_ol_run_id(\n+    dag_id: str,\n+    task_id: str,\n+    try_number: int,\n+    logical_date: datetime.datetime,\n+    map_index: int,\n+):\n+    \"\"\"\n+    Generate a deterministic OpenLineage run ID for a task instance.\n+\n+    Args:\n+        dag_id: The DAG identifier.\n+        task_id: The task identifier.\n+        try_number: The task try number.\n+        logical_date: The logical execution date from dagrun.\n+        map_index: The task map index.\n+\n+    Returns:\n+        A deterministic OpenLineage run ID for the task instance.\n+    \"\"\"\n+    return str(\n+        generate_static_uuid(\n+            instant=logical_date,\n+            data=f\"{conf.namespace()}.{dag_id}.{task_id}.{try_number}.{map_index}\".encode(),\n+        )\n+    )\n+\n+\n+def is_valid_uuid(uuid_string: str | None) -> bool:\n+    \"\"\"Validate that a string is a valid UUID format.\"\"\"\n+    if uuid_string is None:\n+        return False\n+    try:\n+        from uuid import UUID\n+\n+        UUID(uuid_string)\n+        return True\n+    except (ValueError, TypeError):\n+        return False\n+\n+\n+def build_dag_run_ol_run_id(dag_id: str, logical_date: datetime.datetime, clear_number: int) -> str:\n+    \"\"\"\n+    Generate a deterministic OpenLineage run ID for a DAG run.\n+\n+    Args:\n+        dag_id: The DAG identifier.\n+        logical_date: The logical execution date.\n+        clear_number: The DAG run clear number.\n+\n+    Returns:\n+        A deterministic OpenLineage run ID for the DAG run.\n+    \"\"\"\n+    return str(\n+        generate_static_uuid(\n+            instant=logical_date,\n+            data=f\"{conf.namespace()}.{dag_id}.{clear_number}\".encode(),\n+        )\n+    )\n+\n+\n+def _get_eagerly_loaded_dagrun_consumed_asset_events(dag_id: str, dag_run_id: str) -> list[AssetEvent]:\n+    \"\"\"\n+    Retrieve consumed asset events for a DagRun with relationships eagerly loaded.\n+\n+    Downstream code accesses source_task_instance, source_dag_run, and asset on each AssetEvent.\n+    These relationships are lazy-loaded by default, which could cause N+1 query problem\n+    (2 + 3*N queries for N events). Using `joinedload` fetches everything in a single query.\n+    The returned AssetEvent objects have all needed relationships pre-populated in memory,\n+    so they can be safely used after the session is closed.\n+\n+    Returns:\n+        AssetEvent objects with populated relationships, or empty list if DagRun not found.\n+    \"\"\"\n+    # This should only be used on scheduler, so DB access is allowed\n+    from sqlalchemy import select\n+    from sqlalchemy.orm import joinedload\n+\n+    from airflow.utils.session import create_session\n+\n+    if AIRFLOW_V_3_0_PLUS:\n+        from airflow.models.asset import AssetEvent\n+\n+        options = (\n+            joinedload(DagRun.consumed_asset_events).joinedload(AssetEvent.source_dag_run),\n+            joinedload(DagRun.consumed_asset_events).joinedload(AssetEvent.source_task_instance),\n+            joinedload(DagRun.consumed_asset_events).joinedload(AssetEvent.asset),\n+        )\n+\n+    else:  # AF2 path\n+        from airflow.models.dataset import DatasetEvent\n+\n+        options = (\n+            joinedload(DagRun.consumed_dataset_events).joinedload(DatasetEvent.source_dag_run),\n+            joinedload(DagRun.consumed_dataset_events).joinedload(DatasetEvent.source_task_instance),\n+            joinedload(DagRun.consumed_dataset_events).joinedload(DatasetEvent.dataset),\n+        )\n+\n+    with create_session() as session:\n+        dag_run_with_events = session.scalar(\n+            select(DagRun).where(DagRun.dag_id == dag_id).where(DagRun.run_id == dag_run_id).options(*options)\n+        )",
      "comment": "Should we always create session there?\r\n\r\nNot sure of the latest patterns wrt that",
      "comment_id": 2676295263,
      "user": "mobuchowski",
      "created_at": "2026-01-09T13:59:36Z",
      "url": "https://github.com/apache/airflow/pull/59521#discussion_r2676295263"
    },
    {
      "repo": "apache/airflow",
      "pr_number": 59521,
      "file_path": "providers/openlineage/src/airflow/providers/openlineage/utils/utils.py",
      "line": 1179,
      "side": "RIGHT",
      "diff_hunk": "@@ -1000,6 +1003,358 @@ def get_task_duration(ti):\n     }\n \n \n+def is_dag_run_asset_triggered(\n+    dag_run: DagRun,\n+):\n+    \"\"\"Return whether the given DAG run was triggered by an asset.\"\"\"\n+    if AIRFLOW_V_3_0_PLUS:\n+        from airflow.utils.types import DagRunTriggeredByType\n+\n+        return dag_run.triggered_by == DagRunTriggeredByType.ASSET\n+\n+    # AF 2 Path\n+    from airflow.models.dagrun import DagRunType\n+\n+    return dag_run.run_type == DagRunType.DATASET_TRIGGERED  # type: ignore[attr-defined]  # This attr is available on AF2, but mypy can't see it\n+\n+\n+def build_task_instance_ol_run_id(\n+    dag_id: str,\n+    task_id: str,\n+    try_number: int,\n+    logical_date: datetime.datetime,\n+    map_index: int,\n+):\n+    \"\"\"\n+    Generate a deterministic OpenLineage run ID for a task instance.\n+\n+    Args:\n+        dag_id: The DAG identifier.\n+        task_id: The task identifier.\n+        try_number: The task try number.\n+        logical_date: The logical execution date from dagrun.\n+        map_index: The task map index.\n+\n+    Returns:\n+        A deterministic OpenLineage run ID for the task instance.\n+    \"\"\"\n+    return str(\n+        generate_static_uuid(\n+            instant=logical_date,\n+            data=f\"{conf.namespace()}.{dag_id}.{task_id}.{try_number}.{map_index}\".encode(),\n+        )\n+    )\n+\n+\n+def is_valid_uuid(uuid_string: str | None) -> bool:\n+    \"\"\"Validate that a string is a valid UUID format.\"\"\"\n+    if uuid_string is None:\n+        return False\n+    try:\n+        from uuid import UUID\n+\n+        UUID(uuid_string)\n+        return True\n+    except (ValueError, TypeError):\n+        return False\n+\n+\n+def build_dag_run_ol_run_id(dag_id: str, logical_date: datetime.datetime, clear_number: int) -> str:\n+    \"\"\"\n+    Generate a deterministic OpenLineage run ID for a DAG run.\n+\n+    Args:\n+        dag_id: The DAG identifier.\n+        logical_date: The logical execution date.\n+        clear_number: The DAG run clear number.\n+\n+    Returns:\n+        A deterministic OpenLineage run ID for the DAG run.\n+    \"\"\"\n+    return str(\n+        generate_static_uuid(\n+            instant=logical_date,\n+            data=f\"{conf.namespace()}.{dag_id}.{clear_number}\".encode(),\n+        )\n+    )\n+\n+\n+def _get_eagerly_loaded_dagrun_consumed_asset_events(dag_id: str, dag_run_id: str) -> list[AssetEvent]:\n+    \"\"\"\n+    Retrieve consumed asset events for a DagRun with relationships eagerly loaded.\n+\n+    Downstream code accesses source_task_instance, source_dag_run, and asset on each AssetEvent.\n+    These relationships are lazy-loaded by default, which could cause N+1 query problem\n+    (2 + 3*N queries for N events). Using `joinedload` fetches everything in a single query.\n+    The returned AssetEvent objects have all needed relationships pre-populated in memory,\n+    so they can be safely used after the session is closed.\n+\n+    Returns:\n+        AssetEvent objects with populated relationships, or empty list if DagRun not found.\n+    \"\"\"\n+    # This should only be used on scheduler, so DB access is allowed\n+    from sqlalchemy import select\n+    from sqlalchemy.orm import joinedload\n+\n+    from airflow.utils.session import create_session\n+\n+    if AIRFLOW_V_3_0_PLUS:\n+        from airflow.models.asset import AssetEvent\n+\n+        options = (\n+            joinedload(DagRun.consumed_asset_events).joinedload(AssetEvent.source_dag_run),\n+            joinedload(DagRun.consumed_asset_events).joinedload(AssetEvent.source_task_instance),\n+            joinedload(DagRun.consumed_asset_events).joinedload(AssetEvent.asset),\n+        )\n+\n+    else:  # AF2 path\n+        from airflow.models.dataset import DatasetEvent\n+\n+        options = (\n+            joinedload(DagRun.consumed_dataset_events).joinedload(DatasetEvent.source_dag_run),\n+            joinedload(DagRun.consumed_dataset_events).joinedload(DatasetEvent.source_task_instance),\n+            joinedload(DagRun.consumed_dataset_events).joinedload(DatasetEvent.dataset),\n+        )\n+\n+    with create_session() as session:\n+        dag_run_with_events = session.scalar(\n+            select(DagRun).where(DagRun.dag_id == dag_id).where(DagRun.run_id == dag_run_id).options(*options)\n+        )\n+\n+    if not dag_run_with_events:\n+        return []\n+\n+    if AIRFLOW_V_3_0_PLUS:\n+        events = dag_run_with_events.consumed_asset_events\n+    else:  # AF2 path\n+        events = dag_run_with_events.consumed_dataset_events\n+\n+    return events\n+\n+\n+def _extract_ol_info_from_asset_event(asset_event: AssetEvent) -> dict[str, str] | None:\n+    \"\"\"\n+    Extract OpenLineage job information from an AssetEvent.\n+\n+    Information is gathered from multiple potential sources, checked in priority\n+    order:\n+    1. TaskInstance (primary): Provides the most complete and reliable context.\n+    2. AssetEvent source fields (fallback): Offers basic `dag_id.task_id` metadata.\n+    3. `asset_event.extra[\"openlineage\"]` (last resort): May include user provided OpenLineage details.\n+\n+    Args:\n+        asset_event: The AssetEvent from which to extract job information.\n+\n+    Returns:\n+        A dictionary containing `job_name`, `job_namespace`, and optionally\n+        `run_id`, or `None` if insufficient information is available.\n+    \"\"\"\n+    # First check for TaskInstance\n+    if ti := asset_event.source_task_instance:\n+        result = {\n+            \"job_name\": get_job_name(ti),\n+            \"job_namespace\": conf.namespace(),\n+        }\n+        source_dr = asset_event.source_dag_run\n+        if source_dr:\n+            logical_date = source_dr.logical_date  # Get logical date from DagRun for OL run_id generation\n+            if AIRFLOW_V_3_0_PLUS and logical_date is None:\n+                logical_date = source_dr.run_after\n+            if logical_date is not None:\n+                result[\"run_id\"] = build_task_instance_ol_run_id(\n+                    dag_id=ti.dag_id,\n+                    task_id=ti.task_id,\n+                    try_number=ti.try_number,\n+                    logical_date=logical_date,\n+                    map_index=ti.map_index,\n+                )\n+        return result\n+\n+    # Then, check AssetEvent source_* fields\n+    if asset_event.source_dag_id and asset_event.source_task_id:\n+        return {\n+            \"job_name\": f\"{asset_event.source_dag_id}.{asset_event.source_task_id}\",\n+            \"job_namespace\": conf.namespace(),\n+            # run_id cannot be constructed from these fields alone\n+        }",
      "comment": "Not sure how possible / common is that path, I assume for Airflow produced asset events we'll always go into the first one, but just kept it here as a backup. I think even this job correlation is worth to have, without specific run_id.",
      "comment_id": 2676561907,
      "user": "kacpermuda",
      "created_at": "2026-01-09T15:12:48Z",
      "url": "https://github.com/apache/airflow/pull/59521#discussion_r2676561907"
    },
    {
      "repo": "apache/airflow",
      "pr_number": 59521,
      "file_path": "providers/openlineage/src/airflow/providers/openlineage/utils/utils.py",
      "line": 1122,
      "side": "RIGHT",
      "diff_hunk": "@@ -1000,6 +1003,358 @@ def get_task_duration(ti):\n     }\n \n \n+def is_dag_run_asset_triggered(\n+    dag_run: DagRun,\n+):\n+    \"\"\"Return whether the given DAG run was triggered by an asset.\"\"\"\n+    if AIRFLOW_V_3_0_PLUS:\n+        from airflow.utils.types import DagRunTriggeredByType\n+\n+        return dag_run.triggered_by == DagRunTriggeredByType.ASSET\n+\n+    # AF 2 Path\n+    from airflow.models.dagrun import DagRunType\n+\n+    return dag_run.run_type == DagRunType.DATASET_TRIGGERED  # type: ignore[attr-defined]  # This attr is available on AF2, but mypy can't see it\n+\n+\n+def build_task_instance_ol_run_id(\n+    dag_id: str,\n+    task_id: str,\n+    try_number: int,\n+    logical_date: datetime.datetime,\n+    map_index: int,\n+):\n+    \"\"\"\n+    Generate a deterministic OpenLineage run ID for a task instance.\n+\n+    Args:\n+        dag_id: The DAG identifier.\n+        task_id: The task identifier.\n+        try_number: The task try number.\n+        logical_date: The logical execution date from dagrun.\n+        map_index: The task map index.\n+\n+    Returns:\n+        A deterministic OpenLineage run ID for the task instance.\n+    \"\"\"\n+    return str(\n+        generate_static_uuid(\n+            instant=logical_date,\n+            data=f\"{conf.namespace()}.{dag_id}.{task_id}.{try_number}.{map_index}\".encode(),\n+        )\n+    )\n+\n+\n+def is_valid_uuid(uuid_string: str | None) -> bool:\n+    \"\"\"Validate that a string is a valid UUID format.\"\"\"\n+    if uuid_string is None:\n+        return False\n+    try:\n+        from uuid import UUID\n+\n+        UUID(uuid_string)\n+        return True\n+    except (ValueError, TypeError):\n+        return False\n+\n+\n+def build_dag_run_ol_run_id(dag_id: str, logical_date: datetime.datetime, clear_number: int) -> str:\n+    \"\"\"\n+    Generate a deterministic OpenLineage run ID for a DAG run.\n+\n+    Args:\n+        dag_id: The DAG identifier.\n+        logical_date: The logical execution date.\n+        clear_number: The DAG run clear number.\n+\n+    Returns:\n+        A deterministic OpenLineage run ID for the DAG run.\n+    \"\"\"\n+    return str(\n+        generate_static_uuid(\n+            instant=logical_date,\n+            data=f\"{conf.namespace()}.{dag_id}.{clear_number}\".encode(),\n+        )\n+    )\n+\n+\n+def _get_eagerly_loaded_dagrun_consumed_asset_events(dag_id: str, dag_run_id: str) -> list[AssetEvent]:\n+    \"\"\"\n+    Retrieve consumed asset events for a DagRun with relationships eagerly loaded.\n+\n+    Downstream code accesses source_task_instance, source_dag_run, and asset on each AssetEvent.\n+    These relationships are lazy-loaded by default, which could cause N+1 query problem\n+    (2 + 3*N queries for N events). Using `joinedload` fetches everything in a single query.\n+    The returned AssetEvent objects have all needed relationships pre-populated in memory,\n+    so they can be safely used after the session is closed.\n+\n+    Returns:\n+        AssetEvent objects with populated relationships, or empty list if DagRun not found.\n+    \"\"\"\n+    # This should only be used on scheduler, so DB access is allowed\n+    from sqlalchemy import select\n+    from sqlalchemy.orm import joinedload\n+\n+    from airflow.utils.session import create_session\n+\n+    if AIRFLOW_V_3_0_PLUS:\n+        from airflow.models.asset import AssetEvent\n+\n+        options = (\n+            joinedload(DagRun.consumed_asset_events).joinedload(AssetEvent.source_dag_run),\n+            joinedload(DagRun.consumed_asset_events).joinedload(AssetEvent.source_task_instance),\n+            joinedload(DagRun.consumed_asset_events).joinedload(AssetEvent.asset),\n+        )\n+\n+    else:  # AF2 path\n+        from airflow.models.dataset import DatasetEvent\n+\n+        options = (\n+            joinedload(DagRun.consumed_dataset_events).joinedload(DatasetEvent.source_dag_run),\n+            joinedload(DagRun.consumed_dataset_events).joinedload(DatasetEvent.source_task_instance),\n+            joinedload(DagRun.consumed_dataset_events).joinedload(DatasetEvent.dataset),\n+        )\n+\n+    with create_session() as session:\n+        dag_run_with_events = session.scalar(\n+            select(DagRun).where(DagRun.dag_id == dag_id).where(DagRun.run_id == dag_run_id).options(*options)\n+        )",
      "comment": "Not sure as well, so I followed the generic path of creating the session. If some objections come along I'll adjust the code.",
      "comment_id": 2676568985,
      "user": "kacpermuda",
      "created_at": "2026-01-09T15:14:38Z",
      "url": "https://github.com/apache/airflow/pull/59521#discussion_r2676568985"
    },
    {
      "repo": "apache/airflow",
      "pr_number": 60323,
      "file_path": "airflow-core/src/airflow/exceptions.py",
      "line": 72,
      "side": "RIGHT",
      "diff_hunk": "@@ -68,6 +69,9 @@ def serialize(self):\n             cls = self.__class__\n             return f\"{cls.__module__}.{cls.__name__}\", (), {\"reschedule_date\": self.reschedule_date}\n \n+    class AirflowOptionalProviderFeatureException(AirflowException):  # type: ignore[no-redef]",
      "comment": "Is it needed here? We are already importing from sdk above",
      "comment_id": 2676154687,
      "user": "sunank200",
      "created_at": "2026-01-09T13:13:00Z",
      "url": "https://github.com/apache/airflow/pull/60323#discussion_r2676154687"
    },
    {
      "repo": "apache/airflow",
      "pr_number": 54421,
      "file_path": "task-sdk/src/airflow/sdk/definitions/context.py",
      "line": 48,
      "side": "RIGHT",
      "diff_hunk": "@@ -37,31 +37,31 @@\n     )\n \n \n-class Context(TypedDict, total=False):\n+class Context(TypedDict):\n     \"\"\"Jinja2 template context for task rendering.\"\"\"\n \n     conn: Any\n     dag: DAG\n     dag_run: DagRunProtocol\n-    data_interval_end: DateTime | None\n-    data_interval_start: DateTime | None\n+    data_interval_end: NotRequired[DateTime | None]",
      "comment": "Nice. However this was added in Python 3.11, so we'll have to pull this from `typing_extension` if it's not found in the `typing` module",
      "comment_id": 2304081116,
      "user": "ashb",
      "created_at": "2025-08-27T14:18:02Z",
      "url": "https://github.com/apache/airflow/pull/54421#discussion_r2304081116"
    },
    {
      "repo": "apache/airflow",
      "pr_number": 54421,
      "file_path": "task-sdk/src/airflow/sdk/definitions/context.py",
      "line": 40,
      "side": "LEFT",
      "diff_hunk": "@@ -37,31 +37,31 @@\n     )\n \n \n-class Context(TypedDict, total=False):",
      "comment": "I think we still want total=False as there could be other things in here?",
      "comment_id": 2304082525,
      "user": "ashb",
      "created_at": "2025-08-27T14:18:36Z",
      "url": "https://github.com/apache/airflow/pull/54421#discussion_r2304082525"
    },
    {
      "repo": "apache/airflow",
      "pr_number": 54421,
      "file_path": "task-sdk/src/airflow/sdk/definitions/context.py",
      "line": 40,
      "side": "LEFT",
      "diff_hunk": "@@ -37,31 +37,31 @@\n     )\n \n \n-class Context(TypedDict, total=False):",
      "comment": "I can add it back, it is just the  default, we may add a metaclass if I understood the question correctly",
      "comment_id": 2306249970,
      "user": "Nataneljpwd",
      "created_at": "2025-08-28T05:49:51Z",
      "url": "https://github.com/apache/airflow/pull/54421#discussion_r2306249970"
    },
    {
      "repo": "apache/airflow",
      "pr_number": 54421,
      "file_path": "task-sdk/src/airflow/sdk/definitions/context.py",
      "line": 25,
      "side": "RIGHT",
      "diff_hunk": "@@ -22,6 +22,8 @@\n from collections.abc import MutableMapping\n from typing import TYPE_CHECKING, Any, NamedTuple, TypedDict, cast\n \n+from typing_extensions import NotRequired",
      "comment": "```suggestion\r\ntry:\r\n    from typing import NotRequired\r\nexcept ImportError:\r\n    from typing_extensions import NotRequired\r\n```",
      "comment_id": 2307741444,
      "user": "ashb",
      "created_at": "2025-08-28T15:13:01Z",
      "url": "https://github.com/apache/airflow/pull/54421#discussion_r2307741444"
    },
    {
      "repo": "apache/airflow",
      "pr_number": 54421,
      "file_path": "task-sdk/src/airflow/sdk/definitions/context.py",
      "line": 25,
      "side": "RIGHT",
      "diff_hunk": "@@ -22,6 +22,8 @@\n from collections.abc import MutableMapping\n from typing import TYPE_CHECKING, Any, NamedTuple, TypedDict, cast\n \n+from typing_extensions import NotRequired",
      "comment": "Would also work, but might cause some overhead as an exception will be thrown, but only when porting so I guess its fine\nWill fix it soon",
      "comment_id": 2308047736,
      "user": "Nataneljpwd",
      "created_at": "2025-08-28T17:19:53Z",
      "url": "https://github.com/apache/airflow/pull/54421#discussion_r2308047736"
    },
    {
      "repo": "apache/airflow",
      "pr_number": 54421,
      "file_path": "task-sdk/src/airflow/sdk/definitions/context.py",
      "line": 81,
      "side": "RIGHT",
      "diff_hunk": "@@ -71,12 +77,12 @@ class Context(TypedDict, total=False):\n     task_instance: RuntimeTaskInstanceProtocol\n     task_instance_key_str: str\n     # `templates_dict` is only set in PythonOperator\n-    templates_dict: dict[str, Any] | None\n+    templates_dict: NotRequired[dict[str, Any] | None]\n     test_mode: bool\n     ti: RuntimeTaskInstanceProtocol\n     # triggering_asset_events: Mapping[str, Collection[AssetEvent | AssetEventPydantic]]\n     triggering_asset_events: Any\n-    try_number: int | None\n+    try_number: NotRequired[int | None]",
      "comment": "Not sure this one is NotRequired -- without looking at the rest of the code I would have thought this one is always present?",
      "comment_id": 2362235913,
      "user": "ashb",
      "created_at": "2025-09-19T08:58:15Z",
      "url": "https://github.com/apache/airflow/pull/54421#discussion_r2362235913"
    },
    {
      "repo": "apache/airflow",
      "pr_number": 54421,
      "file_path": "task-sdk/src/airflow/sdk/definitions/context.py",
      "line": 81,
      "side": "RIGHT",
      "diff_hunk": "@@ -71,12 +77,12 @@ class Context(TypedDict, total=False):\n     task_instance: RuntimeTaskInstanceProtocol\n     task_instance_key_str: str\n     # `templates_dict` is only set in PythonOperator\n-    templates_dict: dict[str, Any] | None\n+    templates_dict: NotRequired[dict[str, Any] | None]\n     test_mode: bool\n     ti: RuntimeTaskInstanceProtocol\n     # triggering_asset_events: Mapping[str, Collection[AssetEvent | AssetEventPydantic]]\n     triggering_asset_events: Any\n-    try_number: int | None\n+    try_number: NotRequired[int | None]",
      "comment": "Well, it seems correct, however, it can be none, meaning it can be not set, and so that is why I left it as not required, logically we always have a try number, however, maybe it is only updated right before we render the task, and so it can be not required",
      "comment_id": 2381460453,
      "user": "Nataneljpwd",
      "created_at": "2025-09-26T08:55:06Z",
      "url": "https://github.com/apache/airflow/pull/54421#discussion_r2381460453"
    },
    {
      "repo": "apache/airflow",
      "pr_number": 54421,
      "file_path": "task-sdk/src/airflow/sdk/definitions/context.py",
      "line": 81,
      "side": "RIGHT",
      "diff_hunk": "@@ -71,12 +77,12 @@ class Context(TypedDict, total=False):\n     task_instance: RuntimeTaskInstanceProtocol\n     task_instance_key_str: str\n     # `templates_dict` is only set in PythonOperator\n-    templates_dict: dict[str, Any] | None\n+    templates_dict: NotRequired[dict[str, Any] | None]\n     test_mode: bool\n     ti: RuntimeTaskInstanceProtocol\n     # triggering_asset_events: Mapping[str, Collection[AssetEvent | AssetEventPydantic]]\n     triggering_asset_events: Any\n-    try_number: int | None\n+    try_number: NotRequired[int | None]",
      "comment": "I didn't even think it should be none. By the time it gets to a worker, try number will always be a positive integer.",
      "comment_id": 2381514070,
      "user": "ashb",
      "created_at": "2025-09-26T09:06:14Z",
      "url": "https://github.com/apache/airflow/pull/54421#discussion_r2381514070"
    },
    {
      "repo": "apache/airflow",
      "pr_number": 54421,
      "file_path": "task-sdk/src/airflow/sdk/definitions/context.py",
      "line": 81,
      "side": "RIGHT",
      "diff_hunk": "@@ -71,12 +77,12 @@ class Context(TypedDict, total=False):\n     task_instance: RuntimeTaskInstanceProtocol\n     task_instance_key_str: str\n     # `templates_dict` is only set in PythonOperator\n-    templates_dict: dict[str, Any] | None\n+    templates_dict: NotRequired[dict[str, Any] | None]\n     test_mode: bool\n     ti: RuntimeTaskInstanceProtocol\n     # triggering_asset_events: Mapping[str, Collection[AssetEvent | AssetEventPydantic]]\n     triggering_asset_events: Any\n-    try_number: int | None\n+    try_number: NotRequired[int | None]",
      "comment": "ok, so I think it is a good idea to remove the | None part, and make it required ",
      "comment_id": 2381705909,
      "user": "Nataneljpwd",
      "created_at": "2025-09-26T09:48:57Z",
      "url": "https://github.com/apache/airflow/pull/54421#discussion_r2381705909"
    },
    {
      "repo": "apache/airflow",
      "pr_number": 54421,
      "file_path": "task-sdk/src/airflow/sdk/definitions/context.py",
      "line": 25,
      "side": "RIGHT",
      "diff_hunk": "@@ -22,6 +22,8 @@\n from collections.abc import MutableMapping\n from typing import TYPE_CHECKING, Any, NamedTuple, TypedDict, cast\n \n+from typing_extensions import NotRequired",
      "comment": "I think we can just use typing_extensions directly (not using try-except); typing_extensions imports from typing whenever possible anyway.",
      "comment_id": 2488985218,
      "user": "uranusjr",
      "created_at": "2025-11-04T07:26:23Z",
      "url": "https://github.com/apache/airflow/pull/54421#discussion_r2488985218"
    },
    {
      "repo": "apache/airflow",
      "pr_number": 54421,
      "file_path": "task-sdk/src/airflow/sdk/definitions/context.py",
      "line": 25,
      "side": "RIGHT",
      "diff_hunk": "@@ -22,6 +22,8 @@\n from collections.abc import MutableMapping\n from typing import TYPE_CHECKING, Any, NamedTuple, TypedDict, cast\n \n+from typing_extensions import NotRequired",
      "comment": "However we should add typing_extensions as an explicitly dependency to the task sdk.",
      "comment_id": 2488987284,
      "user": "uranusjr",
      "created_at": "2025-11-04T07:27:22Z",
      "url": "https://github.com/apache/airflow/pull/54421#discussion_r2488987284"
    },
    {
      "repo": "apache/airflow",
      "pr_number": 54421,
      "file_path": "task-sdk/src/airflow/sdk/definitions/context.py",
      "line": 40,
      "side": "LEFT",
      "diff_hunk": "@@ -37,31 +37,31 @@\n     )\n \n \n-class Context(TypedDict, total=False):",
      "comment": "If I recall correctly (not sure), `total=False` only affects if everything declared are in the dict; it does not affect if you can put other things in (type checker always flags, runtime always allows). So we don\u2019t need this if we mark all the optional keys with NotRequired (do we?)",
      "comment_id": 2488996754,
      "user": "uranusjr",
      "created_at": "2025-11-04T07:31:39Z",
      "url": "https://github.com/apache/airflow/pull/54421#discussion_r2488996754"
    },
    {
      "repo": "apache/airflow",
      "pr_number": 54421,
      "file_path": "task-sdk/src/airflow/sdk/definitions/context.py",
      "line": 25,
      "side": "RIGHT",
      "diff_hunk": "@@ -22,6 +22,8 @@\n from collections.abc import MutableMapping\n from typing import TYPE_CHECKING, Any, NamedTuple, TypedDict, cast\n \n+from typing_extensions import NotRequired",
      "comment": "Good then, it is the current situation, so I won't change it",
      "comment_id": 2490623677,
      "user": "Nataneljpwd",
      "created_at": "2025-11-04T13:56:41Z",
      "url": "https://github.com/apache/airflow/pull/54421#discussion_r2490623677"
    },
    {
      "repo": "apache/airflow",
      "pr_number": 59597,
      "file_path": "shared/secrets_backend/src/airflow_shared/secrets_backend/__init__.py",
      "line": 23,
      "side": "RIGHT",
      "diff_hunk": "@@ -18,4 +18,10 @@\n \n from .base import BaseSecretsBackend\n \n-__all__ = [\"BaseSecretsBackend\"]\n+__all__ = [\"BaseSecretsBackend\", \"DEFAULT_SECRETS_SEARCH_PATH\"]\n+\n+# Server side default secrets backend search path which is the default lookup chain used by server components (scheduler, API server)",
      "comment": "Just commentin on the \"injection\" pattern to be used here - so that it is not merged accidentally",
      "comment_id": 2634954410,
      "user": "potiuk",
      "created_at": "2025-12-19T12:31:13Z",
      "url": "https://github.com/apache/airflow/pull/59597#discussion_r2634954410"
    },
    {
      "repo": "apache/airflow",
      "pr_number": 59597,
      "file_path": "airflow-core/src/airflow/secrets/base_secrets.py",
      "line": 26,
      "side": "RIGHT",
      "diff_hunk": "@@ -18,3 +18,9 @@\n \n # Re export for compat\n from airflow._shared.secrets_backend.base import BaseSecretsBackend as BaseSecretsBackend\n+\n+# Server side default secrets backend search path used by server components (scheduler, API server)\n+DEFAULT_SECRETS_SEARCH_PATH = [\n+    \"airflow.secrets.environment_variables.EnvironmentVariablesBackend\",\n+    \"airflow.secrets.metastore.MetastoreBackend\",\n+]",
      "comment": "Does this and the one in SDK need to be kept in sync? We might want to add a comment to avoid people accidentally changing one but not the other.",
      "comment_id": 2671987582,
      "user": "uranusjr",
      "created_at": "2026-01-08T11:29:01Z",
      "url": "https://github.com/apache/airflow/pull/59597#discussion_r2671987582"
    },
    {
      "repo": "apache/airflow",
      "pr_number": 59597,
      "file_path": "airflow-core/src/airflow/secrets/base_secrets.py",
      "line": 26,
      "side": "RIGHT",
      "diff_hunk": "@@ -18,3 +18,9 @@\n \n # Re export for compat\n from airflow._shared.secrets_backend.base import BaseSecretsBackend as BaseSecretsBackend\n+\n+# Server side default secrets backend search path used by server components (scheduler, API server)\n+DEFAULT_SECRETS_SEARCH_PATH = [\n+    \"airflow.secrets.environment_variables.EnvironmentVariablesBackend\",\n+    \"airflow.secrets.metastore.MetastoreBackend\",\n+]",
      "comment": "Or better a prek hook to check/sync. Comments of that sort are pretty useless - people tend to develop blind spots for comments. ",
      "comment_id": 2672104437,
      "user": "potiuk",
      "created_at": "2026-01-08T12:09:16Z",
      "url": "https://github.com/apache/airflow/pull/59597#discussion_r2672104437"
    },
    {
      "repo": "apache/airflow",
      "pr_number": 59597,
      "file_path": "airflow-core/src/airflow/secrets/base_secrets.py",
      "line": 26,
      "side": "RIGHT",
      "diff_hunk": "@@ -18,3 +18,9 @@\n \n # Re export for compat\n from airflow._shared.secrets_backend.base import BaseSecretsBackend as BaseSecretsBackend\n+\n+# Server side default secrets backend search path used by server components (scheduler, API server)\n+DEFAULT_SECRETS_SEARCH_PATH = [\n+    \"airflow.secrets.environment_variables.EnvironmentVariablesBackend\",\n+    \"airflow.secrets.metastore.MetastoreBackend\",\n+]",
      "comment": "> Or better a prek hook to check/sync. Comments of that sort are pretty useless - people tend to develop blind spots for comments.\r\n\r\nAgree with this, having prek for checking whether the variables are same or not is pretty robust.\r\n",
      "comment_id": 2675296058,
      "user": "jason810496",
      "created_at": "2026-01-09T08:29:46Z",
      "url": "https://github.com/apache/airflow/pull/59597#discussion_r2675296058"
    },
    {
      "repo": "apache/airflow",
      "pr_number": 59087,
      "file_path": "task-sdk/src/airflow/sdk/execution_time/callback_runner.py",
      "line": 63,
      "side": "RIGHT",
      "diff_hunk": "@@ -49,6 +54,16 @@ def __call__(\n     ) -> _ExecutionCallableRunner[P, R]: ...\n \n \n+class AsyncExecutionCallableRunner(Protocol):\n+    def __call__(\n+        self,\n+        func: Callable[P, R],\n+        outlet_events: OutletEventAccessorsProtocol,\n+        *,\n+        logger: logging.Logger | logging.Logger,",
      "comment": "```suggestion\n        logger: logging.Logger | Logger,\n```",
      "comment_id": 2606925818,
      "user": "jason810496",
      "created_at": "2025-12-10T14:38:15Z",
      "url": "https://github.com/apache/airflow/pull/59087#discussion_r2606925818"
    },
    {
      "repo": "apache/airflow",
      "pr_number": 59087,
      "file_path": "task-sdk/src/airflow/sdk/bases/decorator.py",
      "line": 653,
      "side": "RIGHT",
      "diff_hunk": "@@ -636,6 +640,28 @@ def __call__(\n     def override(self, **kwargs: Any) -> Task[FParams, FReturn]: ...\n \n \n+def unwrap_callable(func):\n+    from airflow.sdk.bases.decorator import _TaskDecorator\n+    from airflow.sdk.definitions.mappedoperator import OperatorPartial\n+\n+    if isinstance(func, (_TaskDecorator, OperatorPartial)):\n+        # unwrap to the real underlying callable\n+        return getattr(func, \"function\", getattr(func, \"_func\", func))\n+    return func\n+\n+\n+def is_async_callable(func):",
      "comment": "You might take a look at fast-api implementation of the test. They implemented it in a bit different way at some point in time, which resulted in an issue - but they fixed it later:\n\nSee https://github.com/fastapi/fastapi/issues/14444",
      "comment_id": 2626812999,
      "user": "potiuk",
      "created_at": "2025-12-17T12:09:16Z",
      "url": "https://github.com/apache/airflow/pull/59087#discussion_r2626812999"
    },
    {
      "repo": "apache/airflow",
      "pr_number": 59087,
      "file_path": "task-sdk/src/airflow/sdk/bases/decorator.py",
      "line": 653,
      "side": "RIGHT",
      "diff_hunk": "@@ -636,6 +640,28 @@ def __call__(\n     def override(self, **kwargs: Any) -> Task[FParams, FReturn]: ...\n \n \n+def unwrap_callable(func):\n+    from airflow.sdk.bases.decorator import _TaskDecorator\n+    from airflow.sdk.definitions.mappedoperator import OperatorPartial\n+\n+    if isinstance(func, (_TaskDecorator, OperatorPartial)):\n+        # unwrap to the real underlying callable\n+        return getattr(func, \"function\", getattr(func, \"_func\", func))\n+    return func\n+\n+\n+def is_async_callable(func):",
      "comment": "Will do I also saw you mention this on the devlist, will check it, thanks for pointing this out.",
      "comment_id": 2626817052,
      "user": "dabla",
      "created_at": "2025-12-17T12:10:43Z",
      "url": "https://github.com/apache/airflow/pull/59087#discussion_r2626817052"
    },
    {
      "repo": "apache/airflow",
      "pr_number": 59087,
      "file_path": "task-sdk/src/airflow/sdk/bases/decorator.py",
      "line": 653,
      "side": "RIGHT",
      "diff_hunk": "@@ -636,6 +640,28 @@ def __call__(\n     def override(self, **kwargs: Any) -> Task[FParams, FReturn]: ...\n \n \n+def unwrap_callable(func):\n+    from airflow.sdk.bases.decorator import _TaskDecorator\n+    from airflow.sdk.definitions.mappedoperator import OperatorPartial\n+\n+    if isinstance(func, (_TaskDecorator, OperatorPartial)):\n+        # unwrap to the real underlying callable\n+        return getattr(func, \"function\", getattr(func, \"_func\", func))\n+    return func\n+\n+\n+def is_async_callable(func):",
      "comment": "I refactored the is_async_callable method to take into account more scenario's like with FastAPI, I also added different test cases documenting the methods behaviour.",
      "comment_id": 2627055980,
      "user": "dabla",
      "created_at": "2025-12-17T13:22:27Z",
      "url": "https://github.com/apache/airflow/pull/59087#discussion_r2627055980"
    },
    {
      "repo": "apache/airflow",
      "pr_number": 59087,
      "file_path": "task-sdk/src/airflow/sdk/execution_time/callback_runner.py",
      "line": 133,
      "side": "RIGHT",
      "diff_hunk": "@@ -109,3 +124,51 @@ def _run():\n             return result  # noqa: F821  # Ruff is not smart enough to know this is always set in _run().\n \n     return cast(\"_ExecutionCallableRunner[P, R]\", _ExecutionCallableRunnerImpl)\n+\n+\n+def create_async_executable_runner(\n+    func: Callable[P, Awaitable[R] | AsyncIterator],\n+    outlet_events: OutletEventAccessorsProtocol,\n+    *,\n+    logger: logging.Logger | logging.Logger,",
      "comment": "```suggestion\n    logger: logging.Logger | Logger,\n```",
      "comment_id": 2627546007,
      "user": "jason810496",
      "created_at": "2025-12-17T15:35:06Z",
      "url": "https://github.com/apache/airflow/pull/59087#discussion_r2627546007"
    },
    {
      "repo": "apache/airflow",
      "pr_number": 59087,
      "file_path": "providers/standard/tests/unit/standard/decorators/test_python.py",
      "line": 48,
      "side": "RIGHT",
      "diff_hunk": "@@ -24,18 +25,27 @@\n \n from airflow.models.taskinstance import TaskInstance\n from airflow.models.taskmap import TaskMap\n-from airflow.providers.common.compat.sdk import AirflowException, XComNotFound\n+from airflow.providers.common.compat.sdk import AirflowException, XComNotFound, task\n \n from tests_common.test_utils.version_compat import (\n     AIRFLOW_V_3_0_1,\n     AIRFLOW_V_3_0_PLUS,\n     AIRFLOW_V_3_1_PLUS,\n+    AIRFLOW_V_3_2_PLUS,\n     XCOM_RETURN_KEY,\n )\n from unit.standard.operators.test_python import BasePythonTest\n \n if AIRFLOW_V_3_0_PLUS:\n-    from airflow.sdk import DAG, BaseOperator, TaskGroup, XComArg, setup, task as task_decorator, teardown\n+    from airflow.sdk import (\n+        DAG,\n+        BaseOperator,\n+        TaskGroup,\n+        XComArg,\n+        setup,\n+        task as task_decorator,\n+        teardown,\n+    )",
      "comment": "This doesn\u2019t change right? (Just to make sure I\u2019m not reading this wrong)",
      "comment_id": 2634542072,
      "user": "uranusjr",
      "created_at": "2025-12-19T10:13:19Z",
      "url": "https://github.com/apache/airflow/pull/59087#discussion_r2634542072"
    },
    {
      "repo": "apache/airflow",
      "pr_number": 59087,
      "file_path": "providers/standard/src/airflow/providers/standard/operators/python.py",
      "line": 67,
      "side": "RIGHT",
      "diff_hunk": "@@ -54,11 +54,18 @@\n     prepare_virtualenv,\n     write_python_script,\n )\n-from airflow.providers.standard.version_compat import AIRFLOW_V_3_0_PLUS, BaseOperator\n+from airflow.providers.standard.version_compat import AIRFLOW_V_3_0_PLUS, AIRFLOW_V_3_2_PLUS, BaseOperator\n from airflow.utils import hashlib_wrapper\n from airflow.utils.file import get_unique_dag_module_name\n from airflow.utils.operator_helpers import KeywordParameters\n \n+if AIRFLOW_V_3_2_PLUS:\n+    from airflow.sdk.bases.decorator import is_async_callable\n+    from airflow.sdk.bases.operator import BaseAsyncOperator\n+\n+    if TYPE_CHECKING:\n+        from airflow.sdk.execution_time.callback_runner import AsyncExecutionCallableRunner",
      "comment": "This should not be inside `if AIRFLOW_V_3_2_PLUS` (and it doesn\u2019t work as you expect; conditionals are always visited in type checking)",
      "comment_id": 2634552453,
      "user": "uranusjr",
      "created_at": "2025-12-19T10:15:27Z",
      "url": "https://github.com/apache/airflow/pull/59087#discussion_r2634552453"
    },
    {
      "repo": "apache/airflow",
      "pr_number": 59087,
      "file_path": "providers/standard/tests/unit/standard/decorators/test_python.py",
      "line": 28,
      "side": "RIGHT",
      "diff_hunk": "@@ -24,18 +25,27 @@\n \n from airflow.models.taskinstance import TaskInstance\n from airflow.models.taskmap import TaskMap\n-from airflow.providers.common.compat.sdk import AirflowException, XComNotFound\n+from airflow.providers.common.compat.sdk import AirflowException, XComNotFound, task",
      "comment": "It's the same, except task_decorator  is not used as the @task decorator itself on a method, but it's referencing the decorator on which tests are being peformed.\r\n\r\nI added @task from the the common compat shared module to allow decorating a python function as Airflow task for testing purposes.",
      "comment_id": 2634571187,
      "user": "dabla",
      "created_at": "2025-12-19T10:19:05Z",
      "url": "https://github.com/apache/airflow/pull/59087#discussion_r2634571187"
    },
    {
      "repo": "apache/airflow",
      "pr_number": 59087,
      "file_path": "airflow-core/tests/unit/api_fastapi/core_api/routes/public/test_task_instances.py",
      "line": 1412,
      "side": "RIGHT",
      "diff_hunk": "@@ -1409,7 +1409,7 @@ class TestGetTaskInstances(TestTaskInstanceEndpoint):\n                 False,\n                 \"/dags/~/dagRuns/~/taskInstances\",\n                 {\"dag_id_pattern\": \"example_python_operator\"},\n-                9,  # Based on test failure - example_python_operator creates 9 task instances\n+                14,  # Based on test failure - example_python_operator creates 9 task instances",
      "comment": "I've asked the same on slack an apparently it's due to the new added tasks in example dags that I've added for async tasks.",
      "comment_id": 2671144197,
      "user": "dabla",
      "created_at": "2026-01-08T07:10:22Z",
      "url": "https://github.com/apache/airflow/pull/59087#discussion_r2671144197"
    },
    {
      "repo": "apache/airflow",
      "pr_number": 59087,
      "file_path": "providers/common/compat/src/airflow/providers/common/compat/standard/operators.py",
      "line": 164,
      "side": "RIGHT",
      "diff_hunk": "@@ -17,18 +17,230 @@\n \n from __future__ import annotations\n \n+from typing import TYPE_CHECKING\n+\n from airflow.providers.common.compat._compat_utils import create_module_getattr\n+from airflow.providers.common.compat.version_compat import (\n+    AIRFLOW_V_3_0_PLUS,\n+    AIRFLOW_V_3_1_PLUS,\n+    AIRFLOW_V_3_2_PLUS,\n+)\n \n _IMPORT_MAP: dict[str, str | tuple[str, ...]] = {\n     # Re-export from sdk (which handles Airflow 2.x/3.x fallbacks)\n+    \"AsyncExecutionCallableRunner\": \"airflow.providers.common.compat.sdk\",\n     \"BaseOperator\": \"airflow.providers.common.compat.sdk\",\n+    \"BaseAsyncOperator\": \"airflow.providers.common.compat.sdk\",\n+    \"create_async_executable_runner\": \"airflow.providers.common.compat.sdk\",\n     \"get_current_context\": \"airflow.providers.common.compat.sdk\",\n+    \"is_async_callable\": \"airflow.providers.common.compat.sdk\",\n     # Standard provider items with direct fallbacks\n     \"PythonOperator\": (\"airflow.providers.standard.operators.python\", \"airflow.operators.python\"),\n     \"ShortCircuitOperator\": (\"airflow.providers.standard.operators.python\", \"airflow.operators.python\"),\n     \"_SERIALIZERS\": (\"airflow.providers.standard.operators.python\", \"airflow.operators.python\"),\n }\n \n+if TYPE_CHECKING:\n+    from structlog.typing import FilteringBoundLogger as Logger\n+\n+    from airflow.sdk.bases.decorator import is_async_callable\n+    from airflow.sdk.bases.operator import BaseAsyncOperator\n+    from airflow.sdk.execution_time.callback_runner import (\n+        AsyncExecutionCallableRunner,\n+        create_async_executable_runner,\n+    )\n+    from airflow.sdk.types import OutletEventAccessorsProtocol\n+elif AIRFLOW_V_3_2_PLUS:\n+    from airflow.sdk.bases.decorator import is_async_callable\n+    from airflow.sdk.bases.operator import BaseAsyncOperator\n+    from airflow.sdk.execution_time.callback_runner import (\n+        AsyncExecutionCallableRunner,\n+        create_async_executable_runner,\n+    )\n+else:\n+    import asyncio\n+    import contextlib\n+    import inspect\n+    import logging\n+    from asyncio import AbstractEventLoop\n+    from collections.abc import AsyncIterator, Awaitable, Callable, Generator\n+    from contextlib import suppress\n+    from functools import partial\n+    from typing import TYPE_CHECKING, Any, Generic, Protocol, TypeVar, cast\n+\n+    from typing_extensions import ParamSpec\n+\n+    if AIRFLOW_V_3_0_PLUS:\n+        from airflow.sdk import BaseOperator\n+        from airflow.sdk.bases.decorator import _TaskDecorator\n+        from airflow.sdk.definitions.asset.metadata import Metadata\n+        from airflow.sdk.definitions.mappedoperator import OperatorPartial\n+    else:\n+        from airflow.datasets.metadata import Metadata\n+        from airflow.decorators.base import _TaskDecorator\n+        from airflow.models import BaseOperator\n+        from airflow.models.mappedoperator import OperatorPartial\n+\n+    P = ParamSpec(\"P\")\n+    R = TypeVar(\"R\")\n+\n+    @contextlib.contextmanager\n+    def event_loop() -> Generator[AbstractEventLoop]:\n+        new_event_loop = False\n+        loop = None\n+        try:\n+            try:\n+                loop = asyncio.get_event_loop()\n+                if loop.is_closed():\n+                    raise RuntimeError\n+            except RuntimeError:\n+                loop = asyncio.new_event_loop()\n+                asyncio.set_event_loop(loop)\n+                new_event_loop = True\n+            yield loop\n+        finally:\n+            if new_event_loop and loop is not None:\n+                with contextlib.suppress(AttributeError):\n+                    loop.close()\n+                    asyncio.set_event_loop(None)\n+\n+    def unwrap_partial(fn):\n+        while isinstance(fn, partial):\n+            fn = fn.func\n+        return fn\n+\n+    def unwrap_callable(func):\n+        # Airflow-specific unwrap\n+        if isinstance(func, (_TaskDecorator, OperatorPartial)):\n+            func = getattr(func, \"function\", getattr(func, \"_func\", func))\n+\n+        # Unwrap functools.partial\n+        func = unwrap_partial(func)\n+\n+        # Unwrap @functools.wraps chains\n+        with suppress(Exception):\n+            func = inspect.unwrap(func)\n+\n+        return func\n+\n+    def is_async_callable(func):\n+        \"\"\"Detect if a callable (possibly wrapped) is an async function.\"\"\"\n+        func = unwrap_callable(func)\n+\n+        if not callable(func):\n+            return False\n+\n+        # Direct async function\n+        if inspect.iscoroutinefunction(func):\n+            return True\n+\n+        # Callable object with async __call__\n+        if not inspect.isfunction(func):\n+            call = type(func).__call__  # Bandit-safe\n+            with suppress(Exception):\n+                call = inspect.unwrap(call)\n+            if inspect.iscoroutinefunction(call):\n+                return True\n+\n+        return False\n+\n+    class _AsyncExecutionCallableRunner(Generic[P, R]):\n+        @staticmethod\n+        async def run(*args: P.args, **kwargs: P.kwargs) -> R: ...  # type: ignore[empty-body]\n+\n+    class AsyncExecutionCallableRunner(Protocol):\n+        def __call__(\n+            self,\n+            func: Callable[P, R],\n+            outlet_events: OutletEventAccessorsProtocol,\n+            *,\n+            logger: logging.Logger | Logger,\n+        ) -> _AsyncExecutionCallableRunner[P, R]: ...\n+\n+    def create_async_executable_runner(\n+        func: Callable[P, Awaitable[R] | AsyncIterator],\n+        outlet_events: OutletEventAccessorsProtocol,\n+        *,\n+        logger: logging.Logger | logging.Logger,",
      "comment": "Yeah that's wrong will fix it, it was fixed in sdk but not in backward compat, thx @kaxil. ",
      "comment_id": 2671146395,
      "user": "dabla",
      "created_at": "2026-01-08T07:11:16Z",
      "url": "https://github.com/apache/airflow/pull/59087#discussion_r2671146395"
    },
    {
      "repo": "apache/airflow",
      "pr_number": 59087,
      "file_path": "airflow-core/tests/unit/api_fastapi/core_api/routes/public/test_task_instances.py",
      "line": 1412,
      "side": "RIGHT",
      "diff_hunk": "@@ -1409,7 +1409,7 @@ class TestGetTaskInstances(TestTaskInstanceEndpoint):\n                 False,\n                 \"/dags/~/dagRuns/~/taskInstances\",\n                 {\"dag_id_pattern\": \"example_python_operator\"},\n-                9,  # Based on test failure - example_python_operator creates 9 task instances\n+                14,  # Based on test failure - example_python_operator creates 9 task instances",
      "comment": "https://apache-airflow.slack.com/archives/C06K9Q5G2UA/p1767616587380139",
      "comment_id": 2671148205,
      "user": "dabla",
      "created_at": "2026-01-08T07:12:01Z",
      "url": "https://github.com/apache/airflow/pull/59087#discussion_r2671148205"
    },
    {
      "repo": "apache/airflow",
      "pr_number": 59087,
      "file_path": "task-sdk/src/airflow/sdk/execution_time/comms.py",
      "line": 218,
      "side": "RIGHT",
      "diff_hunk": "@@ -185,31 +187,69 @@ class CommsDecoder(Generic[ReceiveMsgType, SendMsgType]):\n \n     err_decoder: TypeAdapter[ErrorResponse] = attrs.field(factory=lambda: TypeAdapter(ToTask), repr=False)\n \n+    # Threading lock for sync operations\n+    _thread_lock: threading.Lock = attrs.field(factory=threading.Lock, repr=False)\n+    # Async lock for async operations\n+    _async_lock: asyncio.Lock = attrs.field(factory=asyncio.Lock, repr=False)\n+\n     def send(self, msg: SendMsgType) -> ReceiveMsgType | None:\n         \"\"\"Send a request to the parent and block until the response is received.\"\"\"\n         frame = _RequestFrame(id=next(self.id_counter), body=msg.model_dump())\n         frame_bytes = frame.as_bytes()\n \n-        self.socket.sendall(frame_bytes)\n-        if isinstance(msg, ResendLoggingFD):\n-            if recv_fds is None:\n-                return None\n-            # We need special handling here! The server can't send us the fd number, as the number on the\n-            # supervisor will be different to in this process, so we have to mutate the message ourselves here.\n-            frame, fds = self._read_frame(maxfds=1)\n-            resp = self._from_frame(frame)\n-            if TYPE_CHECKING:\n-                assert isinstance(resp, SentFDs)\n-            resp.fds = fds\n-            # Since we know this is an expliclt SendFDs, and since this class is generic SendFDs might not\n-            # always be in the return type union\n-            return resp  # type: ignore[return-value]\n+        # We must make sure sockets aren't intermixed between sync and async calls,\n+        # thus we need a dual locking mechanism to ensure that.\n+        with self._thread_lock:\n+            self.socket.sendall(frame_bytes)\n+            if isinstance(msg, ResendLoggingFD):\n+                if recv_fds is None:\n+                    return None\n+                # We need special handling here! The server can't send us the fd number, as the number on the\n+                # supervisor will be different to in this process, so we have to mutate the message ourselves here.\n+                frame, fds = self._read_frame(maxfds=1)\n+                resp = self._from_frame(frame)\n+                if TYPE_CHECKING:\n+                    assert isinstance(resp, SentFDs)\n+                resp.fds = fds\n+                # Since we know this is an expliclt SendFDs, and since this class is generic SendFDs might not\n+                # always be in the return type union\n+                return resp  # type: ignore[return-value]\n \n         return self._get_response()",
      "comment": "If a sync send() and async asend() are called concurrently (which is now possible with mixed sync/async code), could the response reads interleave? The async version you have keeps the read inside the lock, but the sync version doesn't so curious.",
      "comment_id": 2672627083,
      "user": "kaxil",
      "created_at": "2026-01-08T14:41:28Z",
      "url": "https://github.com/apache/airflow/pull/59087#discussion_r2672627083"
    },
    {
      "repo": "apache/airflow",
      "pr_number": 59087,
      "file_path": "task-sdk/src/airflow/sdk/execution_time/comms.py",
      "line": 193,
      "side": "RIGHT",
      "diff_hunk": "@@ -185,31 +187,69 @@ class CommsDecoder(Generic[ReceiveMsgType, SendMsgType]):\n \n     err_decoder: TypeAdapter[ErrorResponse] = attrs.field(factory=lambda: TypeAdapter(ToTask), repr=False)\n \n+    # Threading lock for sync operations\n+    _thread_lock: threading.Lock = attrs.field(factory=threading.Lock, repr=False)\n+    # Async lock for async operations\n+    _async_lock: asyncio.Lock = attrs.field(factory=asyncio.Lock, repr=False)",
      "comment": "This is worth consolidating with the async lock on Trigger since `TriggerCommsDecoder` inherits this\n\nhttps://github.com/apache/airflow/blob/0b341e6b92040360f86f5697da119c58a91aa4c2/airflow-core/src/airflow/jobs/triggerer_job_runner.py#L783",
      "comment_id": 2672640943,
      "user": "kaxil",
      "created_at": "2026-01-08T14:45:03Z",
      "url": "https://github.com/apache/airflow/pull/59087#discussion_r2672640943"
    },
    {
      "repo": "apache/airflow",
      "pr_number": 59087,
      "file_path": "providers/standard/src/airflow/providers/standard/operators/python.py",
      "line": 123,
      "side": "RIGHT",
      "diff_hunk": "@@ -115,9 +120,9 @@ def from_executable(cls, executable: str) -> _PythonVersionInfo:\n         return cls(*_parse_version_info(result.strip()))\n \n \n-class PythonOperator(BaseOperator):\n+class PythonOperator(BaseAsyncOperator):",
      "comment": "Should `BranchPythonOperator` and `ShortCircuitOperator` which inherit this Operator support or reject async callables?",
      "comment_id": 2672655455,
      "user": "kaxil",
      "created_at": "2026-01-08T14:48:43Z",
      "url": "https://github.com/apache/airflow/pull/59087#discussion_r2672655455"
    },
    {
      "repo": "apache/airflow",
      "pr_number": 59087,
      "file_path": "providers/common/compat/src/airflow/providers/common/compat/standard/operators.py",
      "line": 240,
      "side": "RIGHT",
      "diff_hunk": "@@ -17,18 +17,230 @@\n \n from __future__ import annotations\n \n+from typing import TYPE_CHECKING\n+\n from airflow.providers.common.compat._compat_utils import create_module_getattr\n+from airflow.providers.common.compat.version_compat import (\n+    AIRFLOW_V_3_0_PLUS,\n+    AIRFLOW_V_3_1_PLUS,\n+    AIRFLOW_V_3_2_PLUS,\n+)\n \n _IMPORT_MAP: dict[str, str | tuple[str, ...]] = {\n     # Re-export from sdk (which handles Airflow 2.x/3.x fallbacks)\n+    \"AsyncExecutionCallableRunner\": \"airflow.providers.common.compat.sdk\",\n     \"BaseOperator\": \"airflow.providers.common.compat.sdk\",\n+    \"BaseAsyncOperator\": \"airflow.providers.common.compat.sdk\",\n+    \"create_async_executable_runner\": \"airflow.providers.common.compat.sdk\",\n     \"get_current_context\": \"airflow.providers.common.compat.sdk\",\n+    \"is_async_callable\": \"airflow.providers.common.compat.sdk\",\n     # Standard provider items with direct fallbacks\n     \"PythonOperator\": (\"airflow.providers.standard.operators.python\", \"airflow.operators.python\"),\n     \"ShortCircuitOperator\": (\"airflow.providers.standard.operators.python\", \"airflow.operators.python\"),\n     \"_SERIALIZERS\": (\"airflow.providers.standard.operators.python\", \"airflow.operators.python\"),\n }\n \n+if TYPE_CHECKING:\n+    from structlog.typing import FilteringBoundLogger as Logger\n+\n+    from airflow.sdk.bases.decorator import is_async_callable\n+    from airflow.sdk.bases.operator import BaseAsyncOperator\n+    from airflow.sdk.execution_time.callback_runner import (\n+        AsyncExecutionCallableRunner,\n+        create_async_executable_runner,\n+    )\n+    from airflow.sdk.types import OutletEventAccessorsProtocol\n+elif AIRFLOW_V_3_2_PLUS:\n+    from airflow.sdk.bases.decorator import is_async_callable\n+    from airflow.sdk.bases.operator import BaseAsyncOperator\n+    from airflow.sdk.execution_time.callback_runner import (\n+        AsyncExecutionCallableRunner,\n+        create_async_executable_runner,\n+    )\n+else:\n+    import asyncio\n+    import contextlib\n+    import inspect\n+    import logging\n+    from asyncio import AbstractEventLoop\n+    from collections.abc import AsyncIterator, Awaitable, Callable, Generator\n+    from contextlib import suppress\n+    from functools import partial\n+    from typing import TYPE_CHECKING, Any, Generic, Protocol, TypeVar, cast\n+\n+    from typing_extensions import ParamSpec\n+\n+    if AIRFLOW_V_3_0_PLUS:\n+        from airflow.sdk import BaseOperator\n+        from airflow.sdk.bases.decorator import _TaskDecorator\n+        from airflow.sdk.definitions.asset.metadata import Metadata\n+        from airflow.sdk.definitions.mappedoperator import OperatorPartial\n+    else:\n+        from airflow.datasets.metadata import Metadata\n+        from airflow.decorators.base import _TaskDecorator\n+        from airflow.models import BaseOperator\n+        from airflow.models.mappedoperator import OperatorPartial\n+\n+    P = ParamSpec(\"P\")\n+    R = TypeVar(\"R\")\n+\n+    @contextlib.contextmanager\n+    def event_loop() -> Generator[AbstractEventLoop]:\n+        new_event_loop = False\n+        loop = None\n+        try:\n+            try:\n+                loop = asyncio.get_event_loop()\n+                if loop.is_closed():\n+                    raise RuntimeError\n+            except RuntimeError:\n+                loop = asyncio.new_event_loop()\n+                asyncio.set_event_loop(loop)\n+                new_event_loop = True\n+            yield loop\n+        finally:\n+            if new_event_loop and loop is not None:\n+                with contextlib.suppress(AttributeError):\n+                    loop.close()\n+                    asyncio.set_event_loop(None)\n+\n+    def unwrap_partial(fn):\n+        while isinstance(fn, partial):\n+            fn = fn.func\n+        return fn\n+\n+    def unwrap_callable(func):\n+        # Airflow-specific unwrap\n+        if isinstance(func, (_TaskDecorator, OperatorPartial)):\n+            func = getattr(func, \"function\", getattr(func, \"_func\", func))\n+\n+        # Unwrap functools.partial\n+        func = unwrap_partial(func)\n+\n+        # Unwrap @functools.wraps chains\n+        with suppress(Exception):\n+            func = inspect.unwrap(func)\n+\n+        return func\n+\n+    def is_async_callable(func):\n+        \"\"\"Detect if a callable (possibly wrapped) is an async function.\"\"\"\n+        func = unwrap_callable(func)\n+\n+        if not callable(func):\n+            return False\n+\n+        # Direct async function\n+        if inspect.iscoroutinefunction(func):\n+            return True\n+\n+        # Callable object with async __call__\n+        if not inspect.isfunction(func):\n+            call = type(func).__call__  # Bandit-safe\n+            with suppress(Exception):\n+                call = inspect.unwrap(call)\n+            if inspect.iscoroutinefunction(call):\n+                return True\n+\n+        return False\n+\n+    class _AsyncExecutionCallableRunner(Generic[P, R]):\n+        @staticmethod\n+        async def run(*args: P.args, **kwargs: P.kwargs) -> R: ...  # type: ignore[empty-body]\n+\n+    class AsyncExecutionCallableRunner(Protocol):\n+        def __call__(\n+            self,\n+            func: Callable[P, R],\n+            outlet_events: OutletEventAccessorsProtocol,\n+            *,\n+            logger: logging.Logger | Logger,\n+        ) -> _AsyncExecutionCallableRunner[P, R]: ...\n+\n+    def create_async_executable_runner(\n+        func: Callable[P, Awaitable[R] | AsyncIterator],\n+        outlet_events: OutletEventAccessorsProtocol,\n+        *,\n+        logger: logging.Logger | Logger,\n+    ) -> _AsyncExecutionCallableRunner[P, R]:\n+        \"\"\"\n+        Run an async execution callable against a task context and given arguments.\n+\n+        If the callable is a simple function, this simply calls it with the supplied\n+        arguments (including the context). If the callable is a generator function,\n+        the generator is exhausted here, with the yielded values getting fed back\n+        into the task context automatically for execution.\n+\n+        This convoluted implementation of inner class with closure is so *all*\n+        arguments passed to ``run()`` can be forwarded to the wrapped function. This\n+        is particularly important for the argument \"self\", which some use cases\n+        need to receive. This is not possible if this is implemented as a normal\n+        class, where \"self\" needs to point to the runner object, not the object\n+        bounded to the inner callable.\n+\n+        :meta private:\n+        \"\"\"\n+\n+        class _AsyncExecutionCallableRunnerImpl(_AsyncExecutionCallableRunner):\n+            @staticmethod\n+            async def run(*args: P.args, **kwargs: P.kwargs) -> R:\n+                if not inspect.isasyncgenfunction(func):\n+                    result = cast(\"Awaitable[R]\", func(*args, **kwargs))\n+                    return await result\n+\n+                results: list[Any] = []\n+\n+                async for result in func(*args, **kwargs):\n+                    if isinstance(result, Metadata):\n+                        outlet_events[result.asset].extra.update(result.extra)\n+                        if result.alias:\n+                            outlet_events[result.alias].add(result.asset, extra=result.extra)\n+\n+                    results.append(result)\n+\n+                return cast(\"R\", results)\n+\n+        return cast(\"_AsyncExecutionCallableRunner[P, R]\", _AsyncExecutionCallableRunnerImpl)\n+\n+    class BaseAsyncOperator(BaseOperator):\n+        \"\"\"\n+        Base class for async-capable operators.\n+\n+        As opposed to deferred operators which are executed on the triggerer, async operators are executed\n+        on the worker.\n+        \"\"\"\n+\n+        @property\n+        def is_async(self) -> bool:\n+            return True\n+\n+        if not AIRFLOW_V_3_1_PLUS:\n+\n+            @property\n+            def xcom_push(self) -> bool:\n+                return self.do_xcom_push\n+\n+            @xcom_push.setter\n+            def xcom_push(self, value: bool):\n+                self.do_xcom_push = value\n+\n+        async def aexecute(self, context):\n+            \"\"\"Async version of execute(). Subclasses should implement this.\"\"\"\n+            raise NotImplementedError()\n+\n+        def execute(self, context):\n+            \"\"\"Run `aexecute()` inside an event loop.\"\"\"\n+            with event_loop() as loop:\n+                if self.execution_timeout:\n+                    return loop.run_until_complete(\n+                        asyncio.wait_for(\n+                            self.aexecute(context),\n+                            timeout=self.execution_timeout.total_seconds(),\n+                        )\n+                    )",
      "comment": "Why do we need this code in Common Compat? This can't work without the Task SDK changes of the CommsDecoder in 3.2, no? So I do not these code here, we just error out if it <3.2",
      "comment_id": 2672675843,
      "user": "kaxil",
      "created_at": "2026-01-08T14:54:05Z",
      "url": "https://github.com/apache/airflow/pull/59087#discussion_r2672675843"
    },
    {
      "repo": "apache/airflow",
      "pr_number": 59087,
      "file_path": "task-sdk/src/airflow/sdk/bases/operator.py",
      "line": 1723,
      "side": "RIGHT",
      "diff_hunk": "@@ -1670,6 +1694,35 @@ def has_on_skipped_callback(self) -> bool:\n         return bool(self.on_skipped_callback)\n \n \n+class BaseAsyncOperator(BaseOperator):\n+    \"\"\"\n+    Base class for async-capable operators.\n+\n+    As opposed to deferred operators which are executed on the triggerer, async operators are executed\n+    on the worker.\n+    \"\"\"\n+\n+    @property\n+    def is_async(self) -> bool:\n+        return True\n+\n+    async def aexecute(self, context):\n+        \"\"\"Async version of execute(). Subclasses should implement this.\"\"\"\n+        raise NotImplementedError()\n+\n+    def execute(self, context):\n+        \"\"\"Run `aexecute()` inside an event loop.\"\"\"\n+        with event_loop() as loop:\n+            if self.execution_timeout:\n+                return loop.run_until_complete(\n+                    asyncio.wait_for(\n+                        self.aexecute(context),\n+                        timeout=self.execution_timeout.total_seconds(),\n+                    )\n+                )\n+            return loop.run_until_complete(self.aexecute(context))",
      "comment": "We should add a test for this case specifically tbh so that a regression won't make async tasks run indefinitely.",
      "comment_id": 2672681142,
      "user": "kaxil",
      "created_at": "2026-01-08T14:55:15Z",
      "url": "https://github.com/apache/airflow/pull/59087#discussion_r2672681142"
    },
    {
      "repo": "apache/airflow",
      "pr_number": 59087,
      "file_path": "task-sdk/src/airflow/sdk/execution_time/comms.py",
      "line": 218,
      "side": "RIGHT",
      "diff_hunk": "@@ -185,31 +187,69 @@ class CommsDecoder(Generic[ReceiveMsgType, SendMsgType]):\n \n     err_decoder: TypeAdapter[ErrorResponse] = attrs.field(factory=lambda: TypeAdapter(ToTask), repr=False)\n \n+    # Threading lock for sync operations\n+    _thread_lock: threading.Lock = attrs.field(factory=threading.Lock, repr=False)\n+    # Async lock for async operations\n+    _async_lock: asyncio.Lock = attrs.field(factory=asyncio.Lock, repr=False)\n+\n     def send(self, msg: SendMsgType) -> ReceiveMsgType | None:\n         \"\"\"Send a request to the parent and block until the response is received.\"\"\"\n         frame = _RequestFrame(id=next(self.id_counter), body=msg.model_dump())\n         frame_bytes = frame.as_bytes()\n \n-        self.socket.sendall(frame_bytes)\n-        if isinstance(msg, ResendLoggingFD):\n-            if recv_fds is None:\n-                return None\n-            # We need special handling here! The server can't send us the fd number, as the number on the\n-            # supervisor will be different to in this process, so we have to mutate the message ourselves here.\n-            frame, fds = self._read_frame(maxfds=1)\n-            resp = self._from_frame(frame)\n-            if TYPE_CHECKING:\n-                assert isinstance(resp, SentFDs)\n-            resp.fds = fds\n-            # Since we know this is an expliclt SendFDs, and since this class is generic SendFDs might not\n-            # always be in the return type union\n-            return resp  # type: ignore[return-value]\n+        # We must make sure sockets aren't intermixed between sync and async calls,\n+        # thus we need a dual locking mechanism to ensure that.\n+        with self._thread_lock:\n+            self.socket.sendall(frame_bytes)\n+            if isinstance(msg, ResendLoggingFD):\n+                if recv_fds is None:\n+                    return None\n+                # We need special handling here! The server can't send us the fd number, as the number on the\n+                # supervisor will be different to in this process, so we have to mutate the message ourselves here.\n+                frame, fds = self._read_frame(maxfds=1)\n+                resp = self._from_frame(frame)\n+                if TYPE_CHECKING:\n+                    assert isinstance(resp, SentFDs)\n+                resp.fds = fds\n+                # Since we know this is an expliclt SendFDs, and since this class is generic SendFDs might not\n+                # always be in the return type union\n+                return resp  # type: ignore[return-value]\n \n         return self._get_response()",
      "comment": "Normally it should behave correctly, unless I missed something, as the async version checks both async and sync lock, the sync version only checks the sync lock.  We are now running the async PythonOperator since right after the Summit and until today haven't experienced any issues with it, I had issues in the beginning and this is how I came up with this solution as indeed it could lead to mix-ups very quickly without those locks.",
      "comment_id": 2672685995,
      "user": "dabla",
      "created_at": "2026-01-08T14:56:37Z",
      "url": "https://github.com/apache/airflow/pull/59087#discussion_r2672685995"
    },
    {
      "repo": "apache/airflow",
      "pr_number": 59087,
      "file_path": "providers/common/compat/src/airflow/providers/common/compat/standard/operators.py",
      "line": 240,
      "side": "RIGHT",
      "diff_hunk": "@@ -17,18 +17,230 @@\n \n from __future__ import annotations\n \n+from typing import TYPE_CHECKING\n+\n from airflow.providers.common.compat._compat_utils import create_module_getattr\n+from airflow.providers.common.compat.version_compat import (\n+    AIRFLOW_V_3_0_PLUS,\n+    AIRFLOW_V_3_1_PLUS,\n+    AIRFLOW_V_3_2_PLUS,\n+)\n \n _IMPORT_MAP: dict[str, str | tuple[str, ...]] = {\n     # Re-export from sdk (which handles Airflow 2.x/3.x fallbacks)\n+    \"AsyncExecutionCallableRunner\": \"airflow.providers.common.compat.sdk\",\n     \"BaseOperator\": \"airflow.providers.common.compat.sdk\",\n+    \"BaseAsyncOperator\": \"airflow.providers.common.compat.sdk\",\n+    \"create_async_executable_runner\": \"airflow.providers.common.compat.sdk\",\n     \"get_current_context\": \"airflow.providers.common.compat.sdk\",\n+    \"is_async_callable\": \"airflow.providers.common.compat.sdk\",\n     # Standard provider items with direct fallbacks\n     \"PythonOperator\": (\"airflow.providers.standard.operators.python\", \"airflow.operators.python\"),\n     \"ShortCircuitOperator\": (\"airflow.providers.standard.operators.python\", \"airflow.operators.python\"),\n     \"_SERIALIZERS\": (\"airflow.providers.standard.operators.python\", \"airflow.operators.python\"),\n }\n \n+if TYPE_CHECKING:\n+    from structlog.typing import FilteringBoundLogger as Logger\n+\n+    from airflow.sdk.bases.decorator import is_async_callable\n+    from airflow.sdk.bases.operator import BaseAsyncOperator\n+    from airflow.sdk.execution_time.callback_runner import (\n+        AsyncExecutionCallableRunner,\n+        create_async_executable_runner,\n+    )\n+    from airflow.sdk.types import OutletEventAccessorsProtocol\n+elif AIRFLOW_V_3_2_PLUS:\n+    from airflow.sdk.bases.decorator import is_async_callable\n+    from airflow.sdk.bases.operator import BaseAsyncOperator\n+    from airflow.sdk.execution_time.callback_runner import (\n+        AsyncExecutionCallableRunner,\n+        create_async_executable_runner,\n+    )\n+else:\n+    import asyncio\n+    import contextlib\n+    import inspect\n+    import logging\n+    from asyncio import AbstractEventLoop\n+    from collections.abc import AsyncIterator, Awaitable, Callable, Generator\n+    from contextlib import suppress\n+    from functools import partial\n+    from typing import TYPE_CHECKING, Any, Generic, Protocol, TypeVar, cast\n+\n+    from typing_extensions import ParamSpec\n+\n+    if AIRFLOW_V_3_0_PLUS:\n+        from airflow.sdk import BaseOperator\n+        from airflow.sdk.bases.decorator import _TaskDecorator\n+        from airflow.sdk.definitions.asset.metadata import Metadata\n+        from airflow.sdk.definitions.mappedoperator import OperatorPartial\n+    else:\n+        from airflow.datasets.metadata import Metadata\n+        from airflow.decorators.base import _TaskDecorator\n+        from airflow.models import BaseOperator\n+        from airflow.models.mappedoperator import OperatorPartial\n+\n+    P = ParamSpec(\"P\")\n+    R = TypeVar(\"R\")\n+\n+    @contextlib.contextmanager\n+    def event_loop() -> Generator[AbstractEventLoop]:\n+        new_event_loop = False\n+        loop = None\n+        try:\n+            try:\n+                loop = asyncio.get_event_loop()\n+                if loop.is_closed():\n+                    raise RuntimeError\n+            except RuntimeError:\n+                loop = asyncio.new_event_loop()\n+                asyncio.set_event_loop(loop)\n+                new_event_loop = True\n+            yield loop\n+        finally:\n+            if new_event_loop and loop is not None:\n+                with contextlib.suppress(AttributeError):\n+                    loop.close()\n+                    asyncio.set_event_loop(None)\n+\n+    def unwrap_partial(fn):\n+        while isinstance(fn, partial):\n+            fn = fn.func\n+        return fn\n+\n+    def unwrap_callable(func):\n+        # Airflow-specific unwrap\n+        if isinstance(func, (_TaskDecorator, OperatorPartial)):\n+            func = getattr(func, \"function\", getattr(func, \"_func\", func))\n+\n+        # Unwrap functools.partial\n+        func = unwrap_partial(func)\n+\n+        # Unwrap @functools.wraps chains\n+        with suppress(Exception):\n+            func = inspect.unwrap(func)\n+\n+        return func\n+\n+    def is_async_callable(func):\n+        \"\"\"Detect if a callable (possibly wrapped) is an async function.\"\"\"\n+        func = unwrap_callable(func)\n+\n+        if not callable(func):\n+            return False\n+\n+        # Direct async function\n+        if inspect.iscoroutinefunction(func):\n+            return True\n+\n+        # Callable object with async __call__\n+        if not inspect.isfunction(func):\n+            call = type(func).__call__  # Bandit-safe\n+            with suppress(Exception):\n+                call = inspect.unwrap(call)\n+            if inspect.iscoroutinefunction(call):\n+                return True\n+\n+        return False\n+\n+    class _AsyncExecutionCallableRunner(Generic[P, R]):\n+        @staticmethod\n+        async def run(*args: P.args, **kwargs: P.kwargs) -> R: ...  # type: ignore[empty-body]\n+\n+    class AsyncExecutionCallableRunner(Protocol):\n+        def __call__(\n+            self,\n+            func: Callable[P, R],\n+            outlet_events: OutletEventAccessorsProtocol,\n+            *,\n+            logger: logging.Logger | Logger,\n+        ) -> _AsyncExecutionCallableRunner[P, R]: ...\n+\n+    def create_async_executable_runner(\n+        func: Callable[P, Awaitable[R] | AsyncIterator],\n+        outlet_events: OutletEventAccessorsProtocol,\n+        *,\n+        logger: logging.Logger | Logger,\n+    ) -> _AsyncExecutionCallableRunner[P, R]:\n+        \"\"\"\n+        Run an async execution callable against a task context and given arguments.\n+\n+        If the callable is a simple function, this simply calls it with the supplied\n+        arguments (including the context). If the callable is a generator function,\n+        the generator is exhausted here, with the yielded values getting fed back\n+        into the task context automatically for execution.\n+\n+        This convoluted implementation of inner class with closure is so *all*\n+        arguments passed to ``run()`` can be forwarded to the wrapped function. This\n+        is particularly important for the argument \"self\", which some use cases\n+        need to receive. This is not possible if this is implemented as a normal\n+        class, where \"self\" needs to point to the runner object, not the object\n+        bounded to the inner callable.\n+\n+        :meta private:\n+        \"\"\"\n+\n+        class _AsyncExecutionCallableRunnerImpl(_AsyncExecutionCallableRunner):\n+            @staticmethod\n+            async def run(*args: P.args, **kwargs: P.kwargs) -> R:\n+                if not inspect.isasyncgenfunction(func):\n+                    result = cast(\"Awaitable[R]\", func(*args, **kwargs))\n+                    return await result\n+\n+                results: list[Any] = []\n+\n+                async for result in func(*args, **kwargs):\n+                    if isinstance(result, Metadata):\n+                        outlet_events[result.asset].extra.update(result.extra)\n+                        if result.alias:\n+                            outlet_events[result.alias].add(result.asset, extra=result.extra)\n+\n+                    results.append(result)\n+\n+                return cast(\"R\", results)\n+\n+        return cast(\"_AsyncExecutionCallableRunner[P, R]\", _AsyncExecutionCallableRunnerImpl)\n+\n+    class BaseAsyncOperator(BaseOperator):\n+        \"\"\"\n+        Base class for async-capable operators.\n+\n+        As opposed to deferred operators which are executed on the triggerer, async operators are executed\n+        on the worker.\n+        \"\"\"\n+\n+        @property\n+        def is_async(self) -> bool:\n+            return True\n+\n+        if not AIRFLOW_V_3_1_PLUS:\n+\n+            @property\n+            def xcom_push(self) -> bool:\n+                return self.do_xcom_push\n+\n+            @xcom_push.setter\n+            def xcom_push(self, value: bool):\n+                self.do_xcom_push = value\n+\n+        async def aexecute(self, context):\n+            \"\"\"Async version of execute(). Subclasses should implement this.\"\"\"\n+            raise NotImplementedError()\n+\n+        def execute(self, context):\n+            \"\"\"Run `aexecute()` inside an event loop.\"\"\"\n+            with event_loop() as loop:\n+                if self.execution_timeout:\n+                    return loop.run_until_complete(\n+                        asyncio.wait_for(\n+                            self.aexecute(context),\n+                            timeout=self.execution_timeout.total_seconds(),\n+                        )\n+                    )",
      "comment": "@kaxil Do you propose to maybe add the check within the BaseAsyncOperator, and if callable is async but Airflow is < 3.2 then maybe raise NotImplementedError with appropriate message?  Also isn't it better to revert this merge and remerged it once it fixes all your remarks as those are important ones imho. ",
      "comment_id": 2672701671,
      "user": "dabla",
      "created_at": "2026-01-08T15:00:39Z",
      "url": "https://github.com/apache/airflow/pull/59087#discussion_r2672701671"
    },
    {
      "repo": "apache/airflow",
      "pr_number": 59087,
      "file_path": "providers/common/compat/src/airflow/providers/common/compat/standard/operators.py",
      "line": 240,
      "side": "RIGHT",
      "diff_hunk": "@@ -17,18 +17,230 @@\n \n from __future__ import annotations\n \n+from typing import TYPE_CHECKING\n+\n from airflow.providers.common.compat._compat_utils import create_module_getattr\n+from airflow.providers.common.compat.version_compat import (\n+    AIRFLOW_V_3_0_PLUS,\n+    AIRFLOW_V_3_1_PLUS,\n+    AIRFLOW_V_3_2_PLUS,\n+)\n \n _IMPORT_MAP: dict[str, str | tuple[str, ...]] = {\n     # Re-export from sdk (which handles Airflow 2.x/3.x fallbacks)\n+    \"AsyncExecutionCallableRunner\": \"airflow.providers.common.compat.sdk\",\n     \"BaseOperator\": \"airflow.providers.common.compat.sdk\",\n+    \"BaseAsyncOperator\": \"airflow.providers.common.compat.sdk\",\n+    \"create_async_executable_runner\": \"airflow.providers.common.compat.sdk\",\n     \"get_current_context\": \"airflow.providers.common.compat.sdk\",\n+    \"is_async_callable\": \"airflow.providers.common.compat.sdk\",\n     # Standard provider items with direct fallbacks\n     \"PythonOperator\": (\"airflow.providers.standard.operators.python\", \"airflow.operators.python\"),\n     \"ShortCircuitOperator\": (\"airflow.providers.standard.operators.python\", \"airflow.operators.python\"),\n     \"_SERIALIZERS\": (\"airflow.providers.standard.operators.python\", \"airflow.operators.python\"),\n }\n \n+if TYPE_CHECKING:\n+    from structlog.typing import FilteringBoundLogger as Logger\n+\n+    from airflow.sdk.bases.decorator import is_async_callable\n+    from airflow.sdk.bases.operator import BaseAsyncOperator\n+    from airflow.sdk.execution_time.callback_runner import (\n+        AsyncExecutionCallableRunner,\n+        create_async_executable_runner,\n+    )\n+    from airflow.sdk.types import OutletEventAccessorsProtocol\n+elif AIRFLOW_V_3_2_PLUS:\n+    from airflow.sdk.bases.decorator import is_async_callable\n+    from airflow.sdk.bases.operator import BaseAsyncOperator\n+    from airflow.sdk.execution_time.callback_runner import (\n+        AsyncExecutionCallableRunner,\n+        create_async_executable_runner,\n+    )\n+else:\n+    import asyncio\n+    import contextlib\n+    import inspect\n+    import logging\n+    from asyncio import AbstractEventLoop\n+    from collections.abc import AsyncIterator, Awaitable, Callable, Generator\n+    from contextlib import suppress\n+    from functools import partial\n+    from typing import TYPE_CHECKING, Any, Generic, Protocol, TypeVar, cast\n+\n+    from typing_extensions import ParamSpec\n+\n+    if AIRFLOW_V_3_0_PLUS:\n+        from airflow.sdk import BaseOperator\n+        from airflow.sdk.bases.decorator import _TaskDecorator\n+        from airflow.sdk.definitions.asset.metadata import Metadata\n+        from airflow.sdk.definitions.mappedoperator import OperatorPartial\n+    else:\n+        from airflow.datasets.metadata import Metadata\n+        from airflow.decorators.base import _TaskDecorator\n+        from airflow.models import BaseOperator\n+        from airflow.models.mappedoperator import OperatorPartial\n+\n+    P = ParamSpec(\"P\")\n+    R = TypeVar(\"R\")\n+\n+    @contextlib.contextmanager\n+    def event_loop() -> Generator[AbstractEventLoop]:\n+        new_event_loop = False\n+        loop = None\n+        try:\n+            try:\n+                loop = asyncio.get_event_loop()\n+                if loop.is_closed():\n+                    raise RuntimeError\n+            except RuntimeError:\n+                loop = asyncio.new_event_loop()\n+                asyncio.set_event_loop(loop)\n+                new_event_loop = True\n+            yield loop\n+        finally:\n+            if new_event_loop and loop is not None:\n+                with contextlib.suppress(AttributeError):\n+                    loop.close()\n+                    asyncio.set_event_loop(None)\n+\n+    def unwrap_partial(fn):\n+        while isinstance(fn, partial):\n+            fn = fn.func\n+        return fn\n+\n+    def unwrap_callable(func):\n+        # Airflow-specific unwrap\n+        if isinstance(func, (_TaskDecorator, OperatorPartial)):\n+            func = getattr(func, \"function\", getattr(func, \"_func\", func))\n+\n+        # Unwrap functools.partial\n+        func = unwrap_partial(func)\n+\n+        # Unwrap @functools.wraps chains\n+        with suppress(Exception):\n+            func = inspect.unwrap(func)\n+\n+        return func\n+\n+    def is_async_callable(func):\n+        \"\"\"Detect if a callable (possibly wrapped) is an async function.\"\"\"\n+        func = unwrap_callable(func)\n+\n+        if not callable(func):\n+            return False\n+\n+        # Direct async function\n+        if inspect.iscoroutinefunction(func):\n+            return True\n+\n+        # Callable object with async __call__\n+        if not inspect.isfunction(func):\n+            call = type(func).__call__  # Bandit-safe\n+            with suppress(Exception):\n+                call = inspect.unwrap(call)\n+            if inspect.iscoroutinefunction(call):\n+                return True\n+\n+        return False\n+\n+    class _AsyncExecutionCallableRunner(Generic[P, R]):\n+        @staticmethod\n+        async def run(*args: P.args, **kwargs: P.kwargs) -> R: ...  # type: ignore[empty-body]\n+\n+    class AsyncExecutionCallableRunner(Protocol):\n+        def __call__(\n+            self,\n+            func: Callable[P, R],\n+            outlet_events: OutletEventAccessorsProtocol,\n+            *,\n+            logger: logging.Logger | Logger,\n+        ) -> _AsyncExecutionCallableRunner[P, R]: ...\n+\n+    def create_async_executable_runner(\n+        func: Callable[P, Awaitable[R] | AsyncIterator],\n+        outlet_events: OutletEventAccessorsProtocol,\n+        *,\n+        logger: logging.Logger | Logger,\n+    ) -> _AsyncExecutionCallableRunner[P, R]:\n+        \"\"\"\n+        Run an async execution callable against a task context and given arguments.\n+\n+        If the callable is a simple function, this simply calls it with the supplied\n+        arguments (including the context). If the callable is a generator function,\n+        the generator is exhausted here, with the yielded values getting fed back\n+        into the task context automatically for execution.\n+\n+        This convoluted implementation of inner class with closure is so *all*\n+        arguments passed to ``run()`` can be forwarded to the wrapped function. This\n+        is particularly important for the argument \"self\", which some use cases\n+        need to receive. This is not possible if this is implemented as a normal\n+        class, where \"self\" needs to point to the runner object, not the object\n+        bounded to the inner callable.\n+\n+        :meta private:\n+        \"\"\"\n+\n+        class _AsyncExecutionCallableRunnerImpl(_AsyncExecutionCallableRunner):\n+            @staticmethod\n+            async def run(*args: P.args, **kwargs: P.kwargs) -> R:\n+                if not inspect.isasyncgenfunction(func):\n+                    result = cast(\"Awaitable[R]\", func(*args, **kwargs))\n+                    return await result\n+\n+                results: list[Any] = []\n+\n+                async for result in func(*args, **kwargs):\n+                    if isinstance(result, Metadata):\n+                        outlet_events[result.asset].extra.update(result.extra)\n+                        if result.alias:\n+                            outlet_events[result.alias].add(result.asset, extra=result.extra)\n+\n+                    results.append(result)\n+\n+                return cast(\"R\", results)\n+\n+        return cast(\"_AsyncExecutionCallableRunner[P, R]\", _AsyncExecutionCallableRunnerImpl)\n+\n+    class BaseAsyncOperator(BaseOperator):\n+        \"\"\"\n+        Base class for async-capable operators.\n+\n+        As opposed to deferred operators which are executed on the triggerer, async operators are executed\n+        on the worker.\n+        \"\"\"\n+\n+        @property\n+        def is_async(self) -> bool:\n+            return True\n+\n+        if not AIRFLOW_V_3_1_PLUS:\n+\n+            @property\n+            def xcom_push(self) -> bool:\n+                return self.do_xcom_push\n+\n+            @xcom_push.setter\n+            def xcom_push(self, value: bool):\n+                self.do_xcom_push = value\n+\n+        async def aexecute(self, context):\n+            \"\"\"Async version of execute(). Subclasses should implement this.\"\"\"\n+            raise NotImplementedError()\n+\n+        def execute(self, context):\n+            \"\"\"Run `aexecute()` inside an event loop.\"\"\"\n+            with event_loop() as loop:\n+                if self.execution_timeout:\n+                    return loop.run_until_complete(\n+                        asyncio.wait_for(\n+                            self.aexecute(context),\n+                            timeout=self.execution_timeout.total_seconds(),\n+                        )\n+                    )",
      "comment": "> Also isn't it better to revert this merge and remerged it once it fixes all your remarks as those are important ones imho.\r\n\r\nYup",
      "comment_id": 2672720506,
      "user": "kaxil",
      "created_at": "2026-01-08T15:05:43Z",
      "url": "https://github.com/apache/airflow/pull/59087#discussion_r2672720506"
    },
    {
      "repo": "apache/airflow",
      "pr_number": 59087,
      "file_path": "providers/common/compat/src/airflow/providers/common/compat/standard/operators.py",
      "line": 240,
      "side": "RIGHT",
      "diff_hunk": "@@ -17,18 +17,230 @@\n \n from __future__ import annotations\n \n+from typing import TYPE_CHECKING\n+\n from airflow.providers.common.compat._compat_utils import create_module_getattr\n+from airflow.providers.common.compat.version_compat import (\n+    AIRFLOW_V_3_0_PLUS,\n+    AIRFLOW_V_3_1_PLUS,\n+    AIRFLOW_V_3_2_PLUS,\n+)\n \n _IMPORT_MAP: dict[str, str | tuple[str, ...]] = {\n     # Re-export from sdk (which handles Airflow 2.x/3.x fallbacks)\n+    \"AsyncExecutionCallableRunner\": \"airflow.providers.common.compat.sdk\",\n     \"BaseOperator\": \"airflow.providers.common.compat.sdk\",\n+    \"BaseAsyncOperator\": \"airflow.providers.common.compat.sdk\",\n+    \"create_async_executable_runner\": \"airflow.providers.common.compat.sdk\",\n     \"get_current_context\": \"airflow.providers.common.compat.sdk\",\n+    \"is_async_callable\": \"airflow.providers.common.compat.sdk\",\n     # Standard provider items with direct fallbacks\n     \"PythonOperator\": (\"airflow.providers.standard.operators.python\", \"airflow.operators.python\"),\n     \"ShortCircuitOperator\": (\"airflow.providers.standard.operators.python\", \"airflow.operators.python\"),\n     \"_SERIALIZERS\": (\"airflow.providers.standard.operators.python\", \"airflow.operators.python\"),\n }\n \n+if TYPE_CHECKING:\n+    from structlog.typing import FilteringBoundLogger as Logger\n+\n+    from airflow.sdk.bases.decorator import is_async_callable\n+    from airflow.sdk.bases.operator import BaseAsyncOperator\n+    from airflow.sdk.execution_time.callback_runner import (\n+        AsyncExecutionCallableRunner,\n+        create_async_executable_runner,\n+    )\n+    from airflow.sdk.types import OutletEventAccessorsProtocol\n+elif AIRFLOW_V_3_2_PLUS:\n+    from airflow.sdk.bases.decorator import is_async_callable\n+    from airflow.sdk.bases.operator import BaseAsyncOperator\n+    from airflow.sdk.execution_time.callback_runner import (\n+        AsyncExecutionCallableRunner,\n+        create_async_executable_runner,\n+    )\n+else:\n+    import asyncio\n+    import contextlib\n+    import inspect\n+    import logging\n+    from asyncio import AbstractEventLoop\n+    from collections.abc import AsyncIterator, Awaitable, Callable, Generator\n+    from contextlib import suppress\n+    from functools import partial\n+    from typing import TYPE_CHECKING, Any, Generic, Protocol, TypeVar, cast\n+\n+    from typing_extensions import ParamSpec\n+\n+    if AIRFLOW_V_3_0_PLUS:\n+        from airflow.sdk import BaseOperator\n+        from airflow.sdk.bases.decorator import _TaskDecorator\n+        from airflow.sdk.definitions.asset.metadata import Metadata\n+        from airflow.sdk.definitions.mappedoperator import OperatorPartial\n+    else:\n+        from airflow.datasets.metadata import Metadata\n+        from airflow.decorators.base import _TaskDecorator\n+        from airflow.models import BaseOperator\n+        from airflow.models.mappedoperator import OperatorPartial\n+\n+    P = ParamSpec(\"P\")\n+    R = TypeVar(\"R\")\n+\n+    @contextlib.contextmanager\n+    def event_loop() -> Generator[AbstractEventLoop]:\n+        new_event_loop = False\n+        loop = None\n+        try:\n+            try:\n+                loop = asyncio.get_event_loop()\n+                if loop.is_closed():\n+                    raise RuntimeError\n+            except RuntimeError:\n+                loop = asyncio.new_event_loop()\n+                asyncio.set_event_loop(loop)\n+                new_event_loop = True\n+            yield loop\n+        finally:\n+            if new_event_loop and loop is not None:\n+                with contextlib.suppress(AttributeError):\n+                    loop.close()\n+                    asyncio.set_event_loop(None)\n+\n+    def unwrap_partial(fn):\n+        while isinstance(fn, partial):\n+            fn = fn.func\n+        return fn\n+\n+    def unwrap_callable(func):\n+        # Airflow-specific unwrap\n+        if isinstance(func, (_TaskDecorator, OperatorPartial)):\n+            func = getattr(func, \"function\", getattr(func, \"_func\", func))\n+\n+        # Unwrap functools.partial\n+        func = unwrap_partial(func)\n+\n+        # Unwrap @functools.wraps chains\n+        with suppress(Exception):\n+            func = inspect.unwrap(func)\n+\n+        return func\n+\n+    def is_async_callable(func):\n+        \"\"\"Detect if a callable (possibly wrapped) is an async function.\"\"\"\n+        func = unwrap_callable(func)\n+\n+        if not callable(func):\n+            return False\n+\n+        # Direct async function\n+        if inspect.iscoroutinefunction(func):\n+            return True\n+\n+        # Callable object with async __call__\n+        if not inspect.isfunction(func):\n+            call = type(func).__call__  # Bandit-safe\n+            with suppress(Exception):\n+                call = inspect.unwrap(call)\n+            if inspect.iscoroutinefunction(call):\n+                return True\n+\n+        return False\n+\n+    class _AsyncExecutionCallableRunner(Generic[P, R]):\n+        @staticmethod\n+        async def run(*args: P.args, **kwargs: P.kwargs) -> R: ...  # type: ignore[empty-body]\n+\n+    class AsyncExecutionCallableRunner(Protocol):\n+        def __call__(\n+            self,\n+            func: Callable[P, R],\n+            outlet_events: OutletEventAccessorsProtocol,\n+            *,\n+            logger: logging.Logger | Logger,\n+        ) -> _AsyncExecutionCallableRunner[P, R]: ...\n+\n+    def create_async_executable_runner(\n+        func: Callable[P, Awaitable[R] | AsyncIterator],\n+        outlet_events: OutletEventAccessorsProtocol,\n+        *,\n+        logger: logging.Logger | Logger,\n+    ) -> _AsyncExecutionCallableRunner[P, R]:\n+        \"\"\"\n+        Run an async execution callable against a task context and given arguments.\n+\n+        If the callable is a simple function, this simply calls it with the supplied\n+        arguments (including the context). If the callable is a generator function,\n+        the generator is exhausted here, with the yielded values getting fed back\n+        into the task context automatically for execution.\n+\n+        This convoluted implementation of inner class with closure is so *all*\n+        arguments passed to ``run()`` can be forwarded to the wrapped function. This\n+        is particularly important for the argument \"self\", which some use cases\n+        need to receive. This is not possible if this is implemented as a normal\n+        class, where \"self\" needs to point to the runner object, not the object\n+        bounded to the inner callable.\n+\n+        :meta private:\n+        \"\"\"\n+\n+        class _AsyncExecutionCallableRunnerImpl(_AsyncExecutionCallableRunner):\n+            @staticmethod\n+            async def run(*args: P.args, **kwargs: P.kwargs) -> R:\n+                if not inspect.isasyncgenfunction(func):\n+                    result = cast(\"Awaitable[R]\", func(*args, **kwargs))\n+                    return await result\n+\n+                results: list[Any] = []\n+\n+                async for result in func(*args, **kwargs):\n+                    if isinstance(result, Metadata):\n+                        outlet_events[result.asset].extra.update(result.extra)\n+                        if result.alias:\n+                            outlet_events[result.alias].add(result.asset, extra=result.extra)\n+\n+                    results.append(result)\n+\n+                return cast(\"R\", results)\n+\n+        return cast(\"_AsyncExecutionCallableRunner[P, R]\", _AsyncExecutionCallableRunnerImpl)\n+\n+    class BaseAsyncOperator(BaseOperator):\n+        \"\"\"\n+        Base class for async-capable operators.\n+\n+        As opposed to deferred operators which are executed on the triggerer, async operators are executed\n+        on the worker.\n+        \"\"\"\n+\n+        @property\n+        def is_async(self) -> bool:\n+            return True\n+\n+        if not AIRFLOW_V_3_1_PLUS:\n+\n+            @property\n+            def xcom_push(self) -> bool:\n+                return self.do_xcom_push\n+\n+            @xcom_push.setter\n+            def xcom_push(self, value: bool):\n+                self.do_xcom_push = value\n+\n+        async def aexecute(self, context):\n+            \"\"\"Async version of execute(). Subclasses should implement this.\"\"\"\n+            raise NotImplementedError()\n+\n+        def execute(self, context):\n+            \"\"\"Run `aexecute()` inside an event loop.\"\"\"\n+            with event_loop() as loop:\n+                if self.execution_timeout:\n+                    return loop.run_until_complete(\n+                        asyncio.wait_for(\n+                            self.aexecute(context),\n+                            timeout=self.execution_timeout.total_seconds(),\n+                        )\n+                    )",
      "comment": "Will revert this [merge ](https://github.com/apache/airflow/pull/60266)and reopen this PR once revert is done and do necessary changes.",
      "comment_id": 2672778807,
      "user": "dabla",
      "created_at": "2026-01-08T15:20:17Z",
      "url": "https://github.com/apache/airflow/pull/59087#discussion_r2672778807"
    },
    {
      "repo": "apache/airflow",
      "pr_number": 59087,
      "file_path": "providers/standard/src/airflow/providers/standard/operators/python.py",
      "line": 123,
      "side": "RIGHT",
      "diff_hunk": "@@ -115,9 +120,9 @@ def from_executable(cls, executable: str) -> _PythonVersionInfo:\n         return cls(*_parse_version_info(result.strip()))\n \n \n-class PythonOperator(BaseOperator):\n+class PythonOperator(BaseAsyncOperator):",
      "comment": "The do automatically as they inherit from PythonOperator which is an async operator by default.  The BaseBranchOperator operator should not be async.",
      "comment_id": 2672994103,
      "user": "dabla",
      "created_at": "2026-01-08T16:15:04Z",
      "url": "https://github.com/apache/airflow/pull/59087#discussion_r2672994103"
    },
    {
      "repo": "apache/airflow",
      "pr_number": 59087,
      "file_path": "providers/common/compat/src/airflow/providers/common/compat/standard/operators.py",
      "line": 240,
      "side": "RIGHT",
      "diff_hunk": "@@ -17,18 +17,230 @@\n \n from __future__ import annotations\n \n+from typing import TYPE_CHECKING\n+\n from airflow.providers.common.compat._compat_utils import create_module_getattr\n+from airflow.providers.common.compat.version_compat import (\n+    AIRFLOW_V_3_0_PLUS,\n+    AIRFLOW_V_3_1_PLUS,\n+    AIRFLOW_V_3_2_PLUS,\n+)\n \n _IMPORT_MAP: dict[str, str | tuple[str, ...]] = {\n     # Re-export from sdk (which handles Airflow 2.x/3.x fallbacks)\n+    \"AsyncExecutionCallableRunner\": \"airflow.providers.common.compat.sdk\",\n     \"BaseOperator\": \"airflow.providers.common.compat.sdk\",\n+    \"BaseAsyncOperator\": \"airflow.providers.common.compat.sdk\",\n+    \"create_async_executable_runner\": \"airflow.providers.common.compat.sdk\",\n     \"get_current_context\": \"airflow.providers.common.compat.sdk\",\n+    \"is_async_callable\": \"airflow.providers.common.compat.sdk\",\n     # Standard provider items with direct fallbacks\n     \"PythonOperator\": (\"airflow.providers.standard.operators.python\", \"airflow.operators.python\"),\n     \"ShortCircuitOperator\": (\"airflow.providers.standard.operators.python\", \"airflow.operators.python\"),\n     \"_SERIALIZERS\": (\"airflow.providers.standard.operators.python\", \"airflow.operators.python\"),\n }\n \n+if TYPE_CHECKING:\n+    from structlog.typing import FilteringBoundLogger as Logger\n+\n+    from airflow.sdk.bases.decorator import is_async_callable\n+    from airflow.sdk.bases.operator import BaseAsyncOperator\n+    from airflow.sdk.execution_time.callback_runner import (\n+        AsyncExecutionCallableRunner,\n+        create_async_executable_runner,\n+    )\n+    from airflow.sdk.types import OutletEventAccessorsProtocol\n+elif AIRFLOW_V_3_2_PLUS:\n+    from airflow.sdk.bases.decorator import is_async_callable\n+    from airflow.sdk.bases.operator import BaseAsyncOperator\n+    from airflow.sdk.execution_time.callback_runner import (\n+        AsyncExecutionCallableRunner,\n+        create_async_executable_runner,\n+    )\n+else:\n+    import asyncio\n+    import contextlib\n+    import inspect\n+    import logging\n+    from asyncio import AbstractEventLoop\n+    from collections.abc import AsyncIterator, Awaitable, Callable, Generator\n+    from contextlib import suppress\n+    from functools import partial\n+    from typing import TYPE_CHECKING, Any, Generic, Protocol, TypeVar, cast\n+\n+    from typing_extensions import ParamSpec\n+\n+    if AIRFLOW_V_3_0_PLUS:\n+        from airflow.sdk import BaseOperator\n+        from airflow.sdk.bases.decorator import _TaskDecorator\n+        from airflow.sdk.definitions.asset.metadata import Metadata\n+        from airflow.sdk.definitions.mappedoperator import OperatorPartial\n+    else:\n+        from airflow.datasets.metadata import Metadata\n+        from airflow.decorators.base import _TaskDecorator\n+        from airflow.models import BaseOperator\n+        from airflow.models.mappedoperator import OperatorPartial\n+\n+    P = ParamSpec(\"P\")\n+    R = TypeVar(\"R\")\n+\n+    @contextlib.contextmanager\n+    def event_loop() -> Generator[AbstractEventLoop]:\n+        new_event_loop = False\n+        loop = None\n+        try:\n+            try:\n+                loop = asyncio.get_event_loop()\n+                if loop.is_closed():\n+                    raise RuntimeError\n+            except RuntimeError:\n+                loop = asyncio.new_event_loop()\n+                asyncio.set_event_loop(loop)\n+                new_event_loop = True\n+            yield loop\n+        finally:\n+            if new_event_loop and loop is not None:\n+                with contextlib.suppress(AttributeError):\n+                    loop.close()\n+                    asyncio.set_event_loop(None)\n+\n+    def unwrap_partial(fn):\n+        while isinstance(fn, partial):\n+            fn = fn.func\n+        return fn\n+\n+    def unwrap_callable(func):\n+        # Airflow-specific unwrap\n+        if isinstance(func, (_TaskDecorator, OperatorPartial)):\n+            func = getattr(func, \"function\", getattr(func, \"_func\", func))\n+\n+        # Unwrap functools.partial\n+        func = unwrap_partial(func)\n+\n+        # Unwrap @functools.wraps chains\n+        with suppress(Exception):\n+            func = inspect.unwrap(func)\n+\n+        return func\n+\n+    def is_async_callable(func):\n+        \"\"\"Detect if a callable (possibly wrapped) is an async function.\"\"\"\n+        func = unwrap_callable(func)\n+\n+        if not callable(func):\n+            return False\n+\n+        # Direct async function\n+        if inspect.iscoroutinefunction(func):\n+            return True\n+\n+        # Callable object with async __call__\n+        if not inspect.isfunction(func):\n+            call = type(func).__call__  # Bandit-safe\n+            with suppress(Exception):\n+                call = inspect.unwrap(call)\n+            if inspect.iscoroutinefunction(call):\n+                return True\n+\n+        return False\n+\n+    class _AsyncExecutionCallableRunner(Generic[P, R]):\n+        @staticmethod\n+        async def run(*args: P.args, **kwargs: P.kwargs) -> R: ...  # type: ignore[empty-body]\n+\n+    class AsyncExecutionCallableRunner(Protocol):\n+        def __call__(\n+            self,\n+            func: Callable[P, R],\n+            outlet_events: OutletEventAccessorsProtocol,\n+            *,\n+            logger: logging.Logger | Logger,\n+        ) -> _AsyncExecutionCallableRunner[P, R]: ...\n+\n+    def create_async_executable_runner(\n+        func: Callable[P, Awaitable[R] | AsyncIterator],\n+        outlet_events: OutletEventAccessorsProtocol,\n+        *,\n+        logger: logging.Logger | Logger,\n+    ) -> _AsyncExecutionCallableRunner[P, R]:\n+        \"\"\"\n+        Run an async execution callable against a task context and given arguments.\n+\n+        If the callable is a simple function, this simply calls it with the supplied\n+        arguments (including the context). If the callable is a generator function,\n+        the generator is exhausted here, with the yielded values getting fed back\n+        into the task context automatically for execution.\n+\n+        This convoluted implementation of inner class with closure is so *all*\n+        arguments passed to ``run()`` can be forwarded to the wrapped function. This\n+        is particularly important for the argument \"self\", which some use cases\n+        need to receive. This is not possible if this is implemented as a normal\n+        class, where \"self\" needs to point to the runner object, not the object\n+        bounded to the inner callable.\n+\n+        :meta private:\n+        \"\"\"\n+\n+        class _AsyncExecutionCallableRunnerImpl(_AsyncExecutionCallableRunner):\n+            @staticmethod\n+            async def run(*args: P.args, **kwargs: P.kwargs) -> R:\n+                if not inspect.isasyncgenfunction(func):\n+                    result = cast(\"Awaitable[R]\", func(*args, **kwargs))\n+                    return await result\n+\n+                results: list[Any] = []\n+\n+                async for result in func(*args, **kwargs):\n+                    if isinstance(result, Metadata):\n+                        outlet_events[result.asset].extra.update(result.extra)\n+                        if result.alias:\n+                            outlet_events[result.alias].add(result.asset, extra=result.extra)\n+\n+                    results.append(result)\n+\n+                return cast(\"R\", results)\n+\n+        return cast(\"_AsyncExecutionCallableRunner[P, R]\", _AsyncExecutionCallableRunnerImpl)\n+\n+    class BaseAsyncOperator(BaseOperator):\n+        \"\"\"\n+        Base class for async-capable operators.\n+\n+        As opposed to deferred operators which are executed on the triggerer, async operators are executed\n+        on the worker.\n+        \"\"\"\n+\n+        @property\n+        def is_async(self) -> bool:\n+            return True\n+\n+        if not AIRFLOW_V_3_1_PLUS:\n+\n+            @property\n+            def xcom_push(self) -> bool:\n+                return self.do_xcom_push\n+\n+            @xcom_push.setter\n+            def xcom_push(self, value: bool):\n+                self.do_xcom_push = value\n+\n+        async def aexecute(self, context):\n+            \"\"\"Async version of execute(). Subclasses should implement this.\"\"\"\n+            raise NotImplementedError()\n+\n+        def execute(self, context):\n+            \"\"\"Run `aexecute()` inside an event loop.\"\"\"\n+            with event_loop() as loop:\n+                if self.execution_timeout:\n+                    return loop.run_until_complete(\n+                        asyncio.wait_for(\n+                            self.aexecute(context),\n+                            timeout=self.execution_timeout.total_seconds(),\n+                        )\n+                    )",
      "comment": "Indeed good catch by @kaxil, already created new [PR](https://github.com/apache/airflow/pull/60268) which fixes all this.",
      "comment_id": 2675105232,
      "user": "dabla",
      "created_at": "2026-01-09T07:12:53Z",
      "url": "https://github.com/apache/airflow/pull/59087#discussion_r2675105232"
    },
    {
      "repo": "apache/airflow",
      "pr_number": 59372,
      "file_path": "providers/cncf/kubernetes/src/airflow/providers/cncf/kubernetes/utils/pod_manager.py",
      "line": 490,
      "side": "RIGHT",
      "diff_hunk": "@@ -487,12 +487,15 @@ def consume_logs(*, since_time: DateTime | None = None) -> tuple[DateTime | None\n                                 message_timestamp = line_timestamp\n                                 progress_callback_lines.append(line)\n                             else:  # previous log line is complete\n-                                for line in progress_callback_lines:\n+                                if message_to_log is not None:",
      "comment": "This line is not needed because line 485 above and 489 already ensured there's message to log or am I missing something? \r\n\r\n",
      "comment_id": 2627389156,
      "user": "ephraimbuddy",
      "created_at": "2025-12-17T14:54:37Z",
      "url": "https://github.com/apache/airflow/pull/59372#discussion_r2627389156"
    },
    {
      "repo": "apache/airflow",
      "pr_number": 59372,
      "file_path": "providers/cncf/kubernetes/src/airflow/providers/cncf/kubernetes/callbacks.py",
      "line": 199,
      "side": "RIGHT",
      "diff_hunk": "@@ -189,12 +191,22 @@ def on_operator_resuming(\n         pass\n \n     @staticmethod\n-    def progress_callback(*, line: str, client: client_type, mode: str, **kwargs) -> None:\n+    def progress_callback(\n+        *,\n+        line: str,\n+        client: client_type,\n+        mode: str,\n+        container_name: str,",
      "comment": "```suggestion\r\n        container_name: str|None = None,\r\n```",
      "comment_id": 2627390882,
      "user": "ephraimbuddy",
      "created_at": "2025-12-17T14:55:07Z",
      "url": "https://github.com/apache/airflow/pull/59372#discussion_r2627390882"
    },
    {
      "repo": "apache/airflow",
      "pr_number": 59372,
      "file_path": "providers/cncf/kubernetes/src/airflow/providers/cncf/kubernetes/utils/pod_manager.py",
      "line": 490,
      "side": "LEFT",
      "diff_hunk": "@@ -487,12 +487,15 @@ def consume_logs(*, since_time: DateTime | None = None) -> tuple[DateTime | None\n                                 message_timestamp = line_timestamp\n                                 progress_callback_lines.append(line)\n                             else:  # previous log line is complete\n-                                for line in progress_callback_lines:",
      "comment": "Here progress_callback_lines contains lines of logs. \r\nCan you share the full logs you were getting. ",
      "comment_id": 2627393479,
      "user": "ephraimbuddy",
      "created_at": "2025-12-17T14:55:45Z",
      "url": "https://github.com/apache/airflow/pull/59372#discussion_r2627393479"
    },
    {
      "repo": "apache/airflow",
      "pr_number": 59372,
      "file_path": "providers/cncf/kubernetes/src/airflow/providers/cncf/kubernetes/callbacks.py",
      "line": 199,
      "side": "RIGHT",
      "diff_hunk": "@@ -189,12 +191,22 @@ def on_operator_resuming(\n         pass\n \n     @staticmethod\n-    def progress_callback(*, line: str, client: client_type, mode: str, **kwargs) -> None:\n+    def progress_callback(\n+        *,\n+        line: str,\n+        client: client_type,\n+        mode: str,\n+        container_name: str,",
      "comment": "The method that calls this function doesn't have this as an optional parameter, so it shouldn't be optional in the signature.  The signature does have a **kwargs param, so if an implementer doesn't include it then it will just end up in there.",
      "comment_id": 2642669750,
      "user": "johnhoran",
      "created_at": "2025-12-23T10:10:24Z",
      "url": "https://github.com/apache/airflow/pull/59372#discussion_r2642669750"
    },
    {
      "repo": "apache/airflow",
      "pr_number": 59372,
      "file_path": "providers/cncf/kubernetes/src/airflow/providers/cncf/kubernetes/utils/pod_manager.py",
      "line": 488,
      "side": "RIGHT",
      "diff_hunk": "@@ -487,18 +487,21 @@ def consume_logs(*, since_time: DateTime | None = None) -> tuple[DateTime | None\n                                 message_timestamp = line_timestamp\n                                 progress_callback_lines.append(line)",
      "comment": "progress_callback_lines variable appears to be dead code now that the callback uses message_to_log directly. ",
      "comment_id": 2655043650,
      "user": "vatsrahul1001",
      "created_at": "2025-12-31T08:58:07Z",
      "url": "https://github.com/apache/airflow/pull/59372#discussion_r2655043650"
    },
    {
      "repo": "apache/airflow",
      "pr_number": 59372,
      "file_path": "providers/cncf/kubernetes/src/airflow/providers/cncf/kubernetes/utils/pod_manager.py",
      "line": 490,
      "side": "LEFT",
      "diff_hunk": "@@ -487,12 +487,15 @@ def consume_logs(*, since_time: DateTime | None = None) -> tuple[DateTime | None\n                                 message_timestamp = line_timestamp\n                                 progress_callback_lines.append(line)\n                             else:  # previous log line is complete\n-                                for line in progress_callback_lines:",
      "comment": "@ephraimbuddy If there aren't any objections, I'm going to resolve this tomorrow. ",
      "comment_id": 2664395743,
      "user": "johnhoran",
      "created_at": "2026-01-06T10:13:07Z",
      "url": "https://github.com/apache/airflow/pull/59372#discussion_r2664395743"
    },
    {
      "repo": "apache/airflow",
      "pr_number": 59372,
      "file_path": "providers/cncf/kubernetes/src/airflow/providers/cncf/kubernetes/utils/pod_manager.py",
      "line": 490,
      "side": "LEFT",
      "diff_hunk": "@@ -487,12 +487,15 @@ def consume_logs(*, since_time: DateTime | None = None) -> tuple[DateTime | None\n                                 message_timestamp = line_timestamp\n                                 progress_callback_lines.append(line)\n                             else:  # previous log line is complete\n-                                for line in progress_callback_lines:",
      "comment": "Thanks @ephraimbuddy, but I'd prefer to get a review of the open PR.  I specifically have a use for the modification to the callback args, and I think its justified to modify them as prior to this looking from when the callbacks were first added, the implementation has never worked, so it should be non breaking.",
      "comment_id": 2671845584,
      "user": "johnhoran",
      "created_at": "2026-01-08T10:44:09Z",
      "url": "https://github.com/apache/airflow/pull/59372#discussion_r2671845584"
    },
    {
      "repo": "apache/airflow",
      "pr_number": 59372,
      "file_path": "providers/cncf/kubernetes/src/airflow/providers/cncf/kubernetes/utils/pod_manager.py",
      "line": 490,
      "side": "LEFT",
      "diff_hunk": "@@ -487,12 +487,15 @@ def consume_logs(*, since_time: DateTime | None = None) -> tuple[DateTime | None\n                                 message_timestamp = line_timestamp\n                                 progress_callback_lines.append(line)\n                             else:  # previous log line is complete\n-                                for line in progress_callback_lines:",
      "comment": "> Thanks @ephraimbuddy, but I'd prefer to get a review of the open PR. I specifically have a use for the modification to the callback args, and I think its justified to modify them as prior to this looking from when the callbacks were first added, the implementation has never worked, so it should be non breaking.\r\n\r\nI'm not confident in the approach you took, however, I don't have a strong opinion against it. Pinging @jedcunningham for review.",
      "comment_id": 2672422398,
      "user": "ephraimbuddy",
      "created_at": "2026-01-08T13:45:37Z",
      "url": "https://github.com/apache/airflow/pull/59372#discussion_r2672422398"
    },
    {
      "repo": "apache/airflow",
      "pr_number": 59372,
      "file_path": "providers/cncf/kubernetes/src/airflow/providers/cncf/kubernetes/utils/pod_manager.py",
      "line": 490,
      "side": "LEFT",
      "diff_hunk": "@@ -487,12 +487,15 @@ def consume_logs(*, since_time: DateTime | None = None) -> tuple[DateTime | None\n                                 message_timestamp = line_timestamp\n                                 progress_callback_lines.append(line)\n                             else:  # previous log line is complete\n-                                for line in progress_callback_lines:",
      "comment": "> Thanks @ephraimbuddy, but I'd prefer to get a review of the open PR. I specifically have a use for the modification to the callback args, and I think its justified to modify them as prior to this looking from when the callbacks were first added, the implementation has never worked, so it should be non breaking.\r\n\r\nUsually, if you have a different issue other than the lines repeating, it's better to open a separate PR for that issue",
      "comment_id": 2672424714,
      "user": "ephraimbuddy",
      "created_at": "2026-01-08T13:46:20Z",
      "url": "https://github.com/apache/airflow/pull/59372#discussion_r2672424714"
    },
    {
      "repo": "apache/airflow",
      "pr_number": 60284,
      "file_path": "dev/breeze/src/airflow_breeze/commands/release_command.py",
      "line": 46,
      "side": "RIGHT",
      "diff_hunk": "@@ -27,19 +29,41 @@\n from airflow_breeze.utils.console import console_print\n from airflow_breeze.utils.path_utils import AIRFLOW_ROOT_PATH\n from airflow_breeze.utils.run_utils import run_command\n+from airflow_breeze.utils.shared_options import get_dry_run\n \n # Pattern to match Airflow release versions (e.g., \"3.0.5\")\n RELEASE_PATTERN = re.compile(r\"^(?P<major>\\d+)\\.(?P<minor>\\d+)\\.(?P<patch>\\d+)$\")\n \n \n-def clone_asf_repo(working_dir):\n+SVN_NUM_TRIES = 3\n+\n+\n+def clone_asf_repo(working_dir, num_tries=SVN_NUM_TRIES):\n     if confirm_action(\"Clone ASF repo?\"):\n         run_command([\"rm\", \"-rf\", f\"{working_dir}/asf-dist\"], check=True)\n-        run_command(\n-            [\"svn\", \"checkout\", \"--depth=immediates\", \"https://dist.apache.org/repos/dist\", \"asf-dist\"],\n-            check=True,\n-            dry_run_override=False,\n-        )\n+\n+        # SVN checkout with retries\n+        while True:",
      "comment": "It could be safer to loop through the finite number you have defined above rather `True`.",
      "comment_id": 2673523713,
      "user": "bugraoz93",
      "created_at": "2026-01-08T19:02:21Z",
      "url": "https://github.com/apache/airflow/pull/60284#discussion_r2673523713"
    },
    {
      "repo": "apache/airflow",
      "pr_number": 58921,
      "file_path": "airflow-core/src/airflow/api_fastapi/core_api/routes/public/xcom.py",
      "line": 344,
      "side": "RIGHT",
      "diff_hunk": "@@ -338,3 +338,44 @@ def update_xcom_entry(\n     xcom_entry.value = XComModel.serialize_value(xcom_new_value)\n \n     return XComResponseNative.model_validate(xcom_entry)\n+\n+\n+@xcom_router.delete(\n+    \"/{xcom_key}\",",
      "comment": "https://github.com/apache/airflow/pull/58344 will probably be merged, earlier.\n\nYou'll need to do:\n\n```suggestion\n    \"/{xcom_key:path}\",\n```",
      "comment_id": 2589386270,
      "user": "pierrejeambrun",
      "created_at": "2025-12-04T14:49:50Z",
      "url": "https://github.com/apache/airflow/pull/58921#discussion_r2589386270"
    },
    {
      "repo": "apache/airflow",
      "pr_number": 58921,
      "file_path": "airflow-core/src/airflow/api_fastapi/core_api/routes/public/xcom.py",
      "line": 344,
      "side": "RIGHT",
      "diff_hunk": "@@ -338,3 +338,44 @@ def update_xcom_entry(\n     xcom_entry.value = XComModel.serialize_value(xcom_new_value)\n \n     return XComResponseNative.model_validate(xcom_entry)\n+\n+\n+@xcom_router.delete(\n+    \"/{xcom_key}\",",
      "comment": "@pierrejeambrun Looks like the other one still needs some tests to be fixed. If it gets merged before this one I will rebase and fix with your suggestion. \r\nSo far do these current set of changes look good to you?",
      "comment_id": 2591407585,
      "user": "dheerajturaga",
      "created_at": "2025-12-05T05:00:29Z",
      "url": "https://github.com/apache/airflow/pull/58921#discussion_r2591407585"
    },
    {
      "repo": "apache/airflow",
      "pr_number": 58921,
      "file_path": "airflow-core/src/airflow/api_fastapi/core_api/routes/public/xcom.py",
      "line": 344,
      "side": "RIGHT",
      "diff_hunk": "@@ -336,6 +335,47 @@ def update_xcom_entry(\n         )\n \n     # Update XCom entry\n-    xcom_entry.value = json.dumps(xcom_new_value)\n+    xcom_entry.value = json.dumps(patch_body.value)\n \n     return XComResponseNative.model_validate(xcom_entry)\n+\n+\n+@xcom_router.delete(\n+    \"/{xcom_key}\",",
      "comment": "The related PR has been merged, we need to update that to be a `path`. #58344",
      "comment_id": 2610979902,
      "user": "pierrejeambrun",
      "created_at": "2025-12-11T15:13:48Z",
      "url": "https://github.com/apache/airflow/pull/58921#discussion_r2610979902"
    },
    {
      "repo": "apache/airflow",
      "pr_number": 58921,
      "file_path": "airflow-core/src/airflow/api_fastapi/core_api/routes/public/xcom.py",
      "line": 377,
      "side": "RIGHT",
      "diff_hunk": "@@ -336,6 +335,47 @@ def update_xcom_entry(\n         )\n \n     # Update XCom entry\n-    xcom_entry.value = json.dumps(xcom_new_value)\n+    xcom_entry.value = json.dumps(patch_body.value)\n \n     return XComResponseNative.model_validate(xcom_entry)\n+\n+\n+@xcom_router.delete(\n+    \"/{xcom_key:path}\",\n+    status_code=status.HTTP_204_NO_CONTENT,\n+    responses=create_openapi_http_exception_doc(\n+        [\n+            status.HTTP_400_BAD_REQUEST,\n+            status.HTTP_404_NOT_FOUND,\n+        ]\n+    ),\n+    dependencies=[\n+        Depends(action_logging()),\n+        Depends(requires_access_dag(method=\"DELETE\", access_entity=DagAccessEntity.XCOM)),\n+    ],\n+)\n+def delete_xcom_entry(\n+    dag_id: str,\n+    task_id: str,\n+    dag_run_id: str,\n+    xcom_key: str,\n+    session: SessionDep,\n+    map_index: Annotated[int, Query(ge=-1)] = -1,\n+):\n+    \"\"\"Delete an XCom entry.\"\"\"\n+    # Delete XCom entry\n+    result = session.execute(\n+        delete(XComModel).where(\n+            XComModel.dag_id == dag_id,\n+            XComModel.task_id == task_id,\n+            XComModel.run_id == dag_run_id,\n+            XComModel.key == xcom_key,\n+            XComModel.map_index == map_index,\n+        )\n+    )\n+\n+    if result.rowcount == 0:",
      "comment": "It seems we need `rowcount` for SQLAlchemy 2 to make MyPy happy if I not remember wrong.\n```suggestion\n    if getattr(result, \"rowcount\", 0)\n```",
      "comment_id": 2613579076,
      "user": "jason810496",
      "created_at": "2025-12-12T09:42:09Z",
      "url": "https://github.com/apache/airflow/pull/58921#discussion_r2613579076"
    },
    {
      "repo": "apache/airflow",
      "pr_number": 58921,
      "file_path": "airflow-core/src/airflow/api_fastapi/core_api/routes/public/xcom.py",
      "line": 377,
      "side": "RIGHT",
      "diff_hunk": "@@ -336,6 +335,47 @@ def update_xcom_entry(\n         )\n \n     # Update XCom entry\n-    xcom_entry.value = json.dumps(xcom_new_value)\n+    xcom_entry.value = json.dumps(patch_body.value)\n \n     return XComResponseNative.model_validate(xcom_entry)\n+\n+\n+@xcom_router.delete(\n+    \"/{xcom_key:path}\",\n+    status_code=status.HTTP_204_NO_CONTENT,\n+    responses=create_openapi_http_exception_doc(\n+        [\n+            status.HTTP_400_BAD_REQUEST,\n+            status.HTTP_404_NOT_FOUND,\n+        ]\n+    ),\n+    dependencies=[\n+        Depends(action_logging()),\n+        Depends(requires_access_dag(method=\"DELETE\", access_entity=DagAccessEntity.XCOM)),\n+    ],\n+)\n+def delete_xcom_entry(\n+    dag_id: str,\n+    task_id: str,\n+    dag_run_id: str,\n+    xcom_key: str,\n+    session: SessionDep,\n+    map_index: Annotated[int, Query(ge=-1)] = -1,\n+):\n+    \"\"\"Delete an XCom entry.\"\"\"\n+    # Delete XCom entry\n+    result = session.execute(\n+        delete(XComModel).where(\n+            XComModel.dag_id == dag_id,\n+            XComModel.task_id == task_id,\n+            XComModel.run_id == dag_run_id,\n+            XComModel.key == xcom_key,\n+            XComModel.map_index == map_index,\n+        )\n+    )\n+\n+    if result.rowcount == 0:",
      "comment": "Thanks for the review and approval! \r\nregarding this change, I dont think we should do this. The proposed change inverts the logic (it would raise 404 when rows ARE deleted instead of when they aren't) and result.rowcount is a standard SQLAlchemy pattern used throughout the codebase without defensive getattr.",
      "comment_id": 2616079949,
      "user": "dheerajturaga",
      "created_at": "2025-12-13T05:11:52Z",
      "url": "https://github.com/apache/airflow/pull/58921#discussion_r2616079949"
    },
    {
      "repo": "apache/airflow",
      "pr_number": 58921,
      "file_path": "airflow-core/src/airflow/api_fastapi/core_api/routes/public/xcom.py",
      "line": 377,
      "side": "RIGHT",
      "diff_hunk": "@@ -336,6 +335,47 @@ def update_xcom_entry(\n         )\n \n     # Update XCom entry\n-    xcom_entry.value = json.dumps(xcom_new_value)\n+    xcom_entry.value = json.dumps(patch_body.value)\n \n     return XComResponseNative.model_validate(xcom_entry)\n+\n+\n+@xcom_router.delete(\n+    \"/{xcom_key:path}\",\n+    status_code=status.HTTP_204_NO_CONTENT,\n+    responses=create_openapi_http_exception_doc(\n+        [\n+            status.HTTP_400_BAD_REQUEST,\n+            status.HTTP_404_NOT_FOUND,\n+        ]\n+    ),\n+    dependencies=[\n+        Depends(action_logging()),\n+        Depends(requires_access_dag(method=\"DELETE\", access_entity=DagAccessEntity.XCOM)),\n+    ],\n+)\n+def delete_xcom_entry(\n+    dag_id: str,\n+    task_id: str,\n+    dag_run_id: str,\n+    xcom_key: str,\n+    session: SessionDep,\n+    map_index: Annotated[int, Query(ge=-1)] = -1,\n+):\n+    \"\"\"Delete an XCom entry.\"\"\"\n+    # Delete XCom entry\n+    result = session.execute(\n+        delete(XComModel).where(\n+            XComModel.dag_id == dag_id,\n+            XComModel.task_id == task_id,\n+            XComModel.run_id == dag_run_id,\n+            XComModel.key == xcom_key,\n+            XComModel.map_index == map_index,\n+        )\n+    )\n+\n+    if result.rowcount == 0:",
      "comment": "As we are migrating to SQLA 2, it seems the `getattr` is still required to avoid the MyPy error if we bump the SQLA version.\r\n\r\nhttps://github.com/apache/airflow/pull/57277/changes#diff-072241d81275cd4b4b867f51025e9dca800610069305cffeb4b77ad45e135557R2320-R2321\r\n\r\nhttps://github.com/apache/airflow/pull/58905/changes#diff-a293f2e3bfda39f00a5b8a11254d49c9fed90b0ec6a35ee6269be2d95511f34fR67-R69",
      "comment_id": 2616133337,
      "user": "jason810496",
      "created_at": "2025-12-13T06:46:07Z",
      "url": "https://github.com/apache/airflow/pull/58921#discussion_r2616133337"
    },
    {
      "repo": "apache/airflow",
      "pr_number": 59883,
      "file_path": "shared/listeners/tests/listeners/test_listener_manager.py",
      "line": 24,
      "side": "RIGHT",
      "diff_hunk": "@@ -0,0 +1,133 @@\n+#\n+# Licensed to the Apache Software Foundation (ASF) under one\n+# or more contributor license agreements.  See the NOTICE file\n+# distributed with this work for additional information\n+# regarding copyright ownership.  The ASF licenses this file\n+# to you under the Apache License, Version 2.0 (the\n+# \"License\"); you may not use this file except in compliance\n+# with the License.  You may obtain a copy of the License at\n+#\n+#   http://www.apache.org/licenses/LICENSE-2.0\n+#\n+# Unless required by applicable law or agreed to in writing,\n+# software distributed under the License is distributed on an\n+# \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+# KIND, either express or implied.  See the License for the\n+# specific language governing permissions and limitations\n+# under the License.\n+from __future__ import annotations\n+\n+from airflow_shared.listeners import hookimpl\n+from airflow_shared.listeners.listener import ListenerManager\n+\n+\n+class TestListenerManager:",
      "comment": "Was able to add some basic tests using cursor's help. It tests basics of a listeners manager like initialisation, adding hooks, calling hooks, etc",
      "comment_id": 2650906013,
      "user": "amoghrajesh",
      "created_at": "2025-12-29T12:50:43Z",
      "url": "https://github.com/apache/airflow/pull/59883#discussion_r2650906013"
    },
    {
      "repo": "apache/airflow",
      "pr_number": 59883,
      "file_path": "task-sdk/src/airflow/sdk/listeners/listener.py",
      "line": 32,
      "side": "RIGHT",
      "diff_hunk": "@@ -0,0 +1,36 @@\n+#\n+# Licensed to the Apache Software Foundation (ASF) under one\n+# or more contributor license agreements.  See the NOTICE file\n+# distributed with this work for additional information\n+# regarding copyright ownership.  The ASF licenses this file\n+# to you under the Apache License, Version 2.0 (the\n+# \"License\"); you may not use this file except in compliance\n+# with the License.  You may obtain a copy of the License at\n+#\n+#   http://www.apache.org/licenses/LICENSE-2.0\n+#\n+# Unless required by applicable law or agreed to in writing,\n+# software distributed under the License is distributed on an\n+# \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+# KIND, either express or implied.  See the License for the\n+# specific language governing permissions and limitations\n+# under the License.\n+from __future__ import annotations\n+\n+from functools import cache\n+\n+from airflow.plugins_manager import integrate_listener_plugins\n+from airflow.sdk._shared.listeners.listener import ListenerManager\n+\n+\n+@cache\n+def get_listener_manager() -> ListenerManager:\n+    \"\"\"Get singleton listener manager.\"\"\"\n+    _listener_manager = ListenerManager()\n+    # TODO: For the time being, task sdk will use airflow's plugin mechanism to discover listeners and load them.\n+    # We need to work out a better way to do this in the future.\n+    integrate_listener_plugins(_listener_manager)  # type: ignore[arg-type]",
      "comment": "I don't love this. I can think of a way through entrypoints, wondering what others think.",
      "comment_id": 2652743386,
      "user": "amoghrajesh",
      "created_at": "2025-12-30T10:53:04Z",
      "url": "https://github.com/apache/airflow/pull/59883#discussion_r2652743386"
    },
    {
      "repo": "apache/airflow",
      "pr_number": 59883,
      "file_path": "providers/openlineage/src/airflow/providers/openlineage/plugins/listener.py",
      "line": 32,
      "side": "RIGHT",
      "diff_hunk": "@@ -28,9 +28,8 @@\n from openlineage.client.serde import Serde\n \n from airflow import settings\n-from airflow.listeners import hookimpl\n from airflow.models import DagRun, TaskInstance\n-from airflow.providers.common.compat.sdk import Stats, timeout, timezone\n+from airflow.providers.common.compat.sdk import Stats, hookimpl, timeout, timezone",
      "comment": "You need to bump the version required (via an indicator which will be used by Providers's release manager) otherwise this will break OL:\n\nhttps://github.com/apache/airflow/blob/cf80ae19840f1d03e16323e7bca819550633db97/contributing-docs/13_airflow_dependencies_and_extras.rst?plain=1#L216-L223",
      "comment_id": 2653089623,
      "user": "kaxil",
      "created_at": "2025-12-30T14:10:08Z",
      "url": "https://github.com/apache/airflow/pull/59883#discussion_r2653089623"
    },
    {
      "repo": "apache/airflow",
      "pr_number": 59883,
      "file_path": "shared/listeners/src/airflow_shared/listeners/listener.py",
      "line": 28,
      "side": "RIGHT",
      "diff_hunk": "@@ -0,0 +1,77 @@\n+#\n+# Licensed to the Apache Software Foundation (ASF) under one\n+# or more contributor license agreements.  See the NOTICE file\n+# distributed with this work for additional information\n+# regarding copyright ownership.  The ASF licenses this file\n+# to you under the Apache License, Version 2.0 (the\n+# \"License\"); you may not use this file except in compliance\n+# with the License.  You may obtain a copy of the License at\n+#\n+#   http://www.apache.org/licenses/LICENSE-2.0\n+#\n+# Unless required by applicable law or agreed to in writing,\n+# software distributed under the License is distributed on an\n+# \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+# KIND, either express or implied.  See the License for the\n+# specific language governing permissions and limitations\n+# under the License.\n+from __future__ import annotations\n+\n+import logging\n+from typing import TYPE_CHECKING\n+\n+import pluggy\n+\n+if TYPE_CHECKING:\n+    from pluggy._hooks import _HookRelay\n+\n+log = logging.getLogger(__name__)",
      "comment": "Do we want to use this chance to switch to structlog here?",
      "comment_id": 2660949996,
      "user": "uranusjr",
      "created_at": "2026-01-05T10:04:38Z",
      "url": "https://github.com/apache/airflow/pull/59883#discussion_r2660949996"
    },
    {
      "repo": "apache/airflow",
      "pr_number": 59883,
      "file_path": "task-sdk/src/airflow/sdk/listeners/__init__.py",
      "line": 22,
      "side": "RIGHT",
      "diff_hunk": "@@ -0,0 +1,22 @@\n+#\n+# Licensed to the Apache Software Foundation (ASF) under one\n+# or more contributor license agreements.  See the NOTICE file\n+# distributed with this work for additional information\n+# regarding copyright ownership.  The ASF licenses this file\n+# to you under the Apache License, Version 2.0 (the\n+# \"License\"); you may not use this file except in compliance\n+# with the License.  You may obtain a copy of the License at\n+#\n+#   http://www.apache.org/licenses/LICENSE-2.0\n+#\n+# Unless required by applicable law or agreed to in writing,\n+# software distributed under the License is distributed on an\n+# \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+# KIND, either express or implied.  See the License for the\n+# specific language governing permissions and limitations\n+# under the License.\n+from __future__ import annotations\n+\n+from airflow.sdk._shared.listeners import hookimpl\n+\n+__all__ = [\"hookimpl\"]",
      "comment": "Do we need this? You can probably argue Core does for compatibility, but SDK can just import directly from the canonical location, can it not?\n\nI also kind of wonder if we should do some additional logic here to avoid having two `hookimpl` objects when both Core and SDK are available. Would it cause issues?",
      "comment_id": 2660959708,
      "user": "uranusjr",
      "created_at": "2026-01-05T10:08:07Z",
      "url": "https://github.com/apache/airflow/pull/59883#discussion_r2660959708"
    },
    {
      "repo": "apache/airflow",
      "pr_number": 59883,
      "file_path": "providers/openlineage/src/airflow/providers/openlineage/plugins/listener.py",
      "line": 32,
      "side": "RIGHT",
      "diff_hunk": "@@ -28,9 +28,8 @@\n from openlineage.client.serde import Serde\n \n from airflow import settings\n-from airflow.listeners import hookimpl\n from airflow.models import DagRun, TaskInstance\n-from airflow.providers.common.compat.sdk import Stats, timeout, timezone\n+from airflow.providers.common.compat.sdk import Stats, hookimpl, timeout, timezone",
      "comment": "Thanks kaxil, OL already has it present: https://github.com/apache/airflow/blob/main/providers/openlineage/pyproject.toml#L63, was added few days ago for some other PR",
      "comment_id": 2664112356,
      "user": "amoghrajesh",
      "created_at": "2026-01-06T08:36:08Z",
      "url": "https://github.com/apache/airflow/pull/59883#discussion_r2664112356"
    },
    {
      "repo": "apache/airflow",
      "pr_number": 59883,
      "file_path": "shared/listeners/src/airflow_shared/listeners/listener.py",
      "line": 28,
      "side": "RIGHT",
      "diff_hunk": "@@ -0,0 +1,77 @@\n+#\n+# Licensed to the Apache Software Foundation (ASF) under one\n+# or more contributor license agreements.  See the NOTICE file\n+# distributed with this work for additional information\n+# regarding copyright ownership.  The ASF licenses this file\n+# to you under the Apache License, Version 2.0 (the\n+# \"License\"); you may not use this file except in compliance\n+# with the License.  You may obtain a copy of the License at\n+#\n+#   http://www.apache.org/licenses/LICENSE-2.0\n+#\n+# Unless required by applicable law or agreed to in writing,\n+# software distributed under the License is distributed on an\n+# \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+# KIND, either express or implied.  See the License for the\n+# specific language governing permissions and limitations\n+# under the License.\n+from __future__ import annotations\n+\n+import logging\n+from typing import TYPE_CHECKING\n+\n+import pluggy\n+\n+if TYPE_CHECKING:\n+    from pluggy._hooks import _HookRelay\n+\n+log = logging.getLogger(__name__)",
      "comment": "Good call, let's do it. We would normally not do it otherwise.",
      "comment_id": 2664149543,
      "user": "amoghrajesh",
      "created_at": "2026-01-06T08:50:19Z",
      "url": "https://github.com/apache/airflow/pull/59883#discussion_r2664149543"
    },
    {
      "repo": "apache/airflow",
      "pr_number": 59883,
      "file_path": "task-sdk/src/airflow/sdk/listeners/__init__.py",
      "line": 22,
      "side": "RIGHT",
      "diff_hunk": "@@ -0,0 +1,22 @@\n+#\n+# Licensed to the Apache Software Foundation (ASF) under one\n+# or more contributor license agreements.  See the NOTICE file\n+# distributed with this work for additional information\n+# regarding copyright ownership.  The ASF licenses this file\n+# to you under the Apache License, Version 2.0 (the\n+# \"License\"); you may not use this file except in compliance\n+# with the License.  You may obtain a copy of the License at\n+#\n+#   http://www.apache.org/licenses/LICENSE-2.0\n+#\n+# Unless required by applicable law or agreed to in writing,\n+# software distributed under the License is distributed on an\n+# \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+# KIND, either express or implied.  See the License for the\n+# specific language governing permissions and limitations\n+# under the License.\n+from __future__ import annotations\n+\n+from airflow.sdk._shared.listeners import hookimpl\n+\n+__all__ = [\"hookimpl\"]",
      "comment": "Good call again, it is needed for core, but sdk doesn't _need_ it, in that process I also realised that we can just have a listeners.py instead of a module in sdk",
      "comment_id": 2664170611,
      "user": "amoghrajesh",
      "created_at": "2026-01-06T08:57:50Z",
      "url": "https://github.com/apache/airflow/pull/59883#discussion_r2664170611"
    },
    {
      "repo": "apache/airflow",
      "pr_number": 59883,
      "file_path": "task-sdk/src/airflow/sdk/listeners/__init__.py",
      "line": 22,
      "side": "RIGHT",
      "diff_hunk": "@@ -0,0 +1,22 @@\n+#\n+# Licensed to the Apache Software Foundation (ASF) under one\n+# or more contributor license agreements.  See the NOTICE file\n+# distributed with this work for additional information\n+# regarding copyright ownership.  The ASF licenses this file\n+# to you under the Apache License, Version 2.0 (the\n+# \"License\"); you may not use this file except in compliance\n+# with the License.  You may obtain a copy of the License at\n+#\n+#   http://www.apache.org/licenses/LICENSE-2.0\n+#\n+# Unless required by applicable law or agreed to in writing,\n+# software distributed under the License is distributed on an\n+# \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+# KIND, either express or implied.  See the License for the\n+# specific language governing permissions and limitations\n+# under the License.\n+from __future__ import annotations\n+\n+from airflow.sdk._shared.listeners import hookimpl\n+\n+__all__ = [\"hookimpl\"]",
      "comment": "> I also kind of wonder if we should do some additional logic here to avoid having two hookimpl objects when both Core and SDK are available. Would it cause issues?\r\n\r\nWe would need sdk and core objects to co-exist I think in cases when listener needs to run on server as well as workers?",
      "comment_id": 2664198426,
      "user": "amoghrajesh",
      "created_at": "2026-01-06T09:07:03Z",
      "url": "https://github.com/apache/airflow/pull/59883#discussion_r2664198426"
    },
    {
      "repo": "apache/airflow",
      "pr_number": 59883,
      "file_path": "providers/common/compat/src/airflow/providers/common/compat/sdk.py",
      "line": 264,
      "side": "RIGHT",
      "diff_hunk": "@@ -257,6 +259,10 @@\n         \"airflow.utils.log.secrets_masker\",\n     ),\n     # ============================================================================\n+    # Listeners\n+    # ============================================================================\n+    \"hookimpl\": (\"airflow.sdk.listeners\", \"airflow.listeners\"),",
      "comment": "After @uranusjr's feedback, it looks like this was changed from listeners/ (module) to listener.py (file), but this wasn't updated",
      "comment_id": 2664998198,
      "user": "kaxil",
      "created_at": "2026-01-06T13:52:00Z",
      "url": "https://github.com/apache/airflow/pull/59883#discussion_r2664998198"
    },
    {
      "repo": "apache/airflow",
      "pr_number": 59883,
      "file_path": "providers/common/compat/src/airflow/providers/common/compat/sdk.py",
      "line": 265,
      "side": "RIGHT",
      "diff_hunk": "@@ -257,6 +259,10 @@\n         \"airflow.utils.log.secrets_masker\",\n     ),\n     # ============================================================================\n+    # Listeners\n+    # ============================================================================\n+    \"hookimpl\": (\"airflow.sdk.listeners\", \"airflow.listeners\"),\n+    \"get_listener_manager\": (\"airflow.sdk.listeners.listener\", \"airflow.listeners.listener\"),",
      "comment": "Should these 2 be?\n\n```py\n    \"hookimpl\": (\"airflow.sdk._shared.listeners\", \"airflow.listeners\"),\n    \"get_listener_manager\": (\"airflow.sdk.listener\", \"airflow.listeners.listener\"),\n}\n```",
      "comment_id": 2665002201,
      "user": "kaxil",
      "created_at": "2026-01-06T13:53:20Z",
      "url": "https://github.com/apache/airflow/pull/59883#discussion_r2665002201"
    },
    {
      "repo": "apache/airflow",
      "pr_number": 59883,
      "file_path": "providers/common/compat/src/airflow/providers/common/compat/sdk.py",
      "line": 96,
      "side": "RIGHT",
      "diff_hunk": "@@ -92,6 +92,8 @@\n         TaskDeferred as TaskDeferred,\n         XComNotFound as XComNotFound,\n     )\n+    from airflow.sdk.listeners import hookimpl as hookimpl\n+    from airflow.sdk.listeners.listener import get_listener_manager as get_listener_manager",
      "comment": "```py\nfrom airflow.sdk._shared.listeners import hookimpl as hookimpl\nfrom airflow.sdk.listener import get_listener_manager as get_listener_manager\n```",
      "comment_id": 2665004311,
      "user": "kaxil",
      "created_at": "2026-01-06T13:54:06Z",
      "url": "https://github.com/apache/airflow/pull/59883#discussion_r2665004311"
    },
    {
      "repo": "apache/airflow",
      "pr_number": 59883,
      "file_path": "providers/openlineage/src/airflow/providers/openlineage/plugins/listener.py",
      "line": 32,
      "side": "RIGHT",
      "diff_hunk": "@@ -28,9 +28,8 @@\n from openlineage.client.serde import Serde\n \n from airflow import settings\n-from airflow.listeners import hookimpl\n from airflow.models import DagRun, TaskInstance\n-from airflow.providers.common.compat.sdk import Stats, timeout, timezone\n+from airflow.providers.common.compat.sdk import Stats, hookimpl, timeout, timezone",
      "comment": "yup got added after the comment :) \r\n\r\nhttps://github.com/apache/airflow/commit/a09ed06a2b59057d1e397b8e28821b26038ea2ab",
      "comment_id": 2665019758,
      "user": "kaxil",
      "created_at": "2026-01-06T13:59:17Z",
      "url": "https://github.com/apache/airflow/pull/59883#discussion_r2665019758"
    },
    {
      "repo": "apache/airflow",
      "pr_number": 59883,
      "file_path": "airflow-core/tests/unit/listeners/test_listeners.py",
      "line": 165,
      "side": "RIGHT",
      "diff_hunk": "@@ -159,27 +151,25 @@ def test_listener_captures_longrunning_taskinstances(create_task_instance_of_ope\n \n \n @provide_session\n-def test_class_based_listener(create_task_instance, session):\n-    lm = get_listener_manager()\n+def test_class_based_listener(create_task_instance, session, listener_manager):\n     listener = class_listener.ClassBasedListener()\n-    lm.add_listener(listener)\n+    listener_manager(listener)\n \n     ti = create_task_instance(session=session, state=TaskInstanceState.QUEUED)\n     ti.run()\n \n     assert listener.state == [TaskInstanceState.RUNNING, TaskInstanceState.SUCCESS, DagRunState.SUCCESS]\n \n \n-def test_listener_logs_call(caplog, create_task_instance, session):\n-    caplog.set_level(logging.DEBUG, logger=\"airflow.listeners.listener\")\n-    lm = get_listener_manager()\n-    lm.add_listener(full_listener)\n+def test_listener_logs_call(caplog, create_task_instance, session, listener_manager):\n+    caplog.set_level(logging.DEBUG, logger=\"airflow.sdk._shared.listeners.listener\")",
      "comment": "Should it be `airflow._shared.listeners.listener` ?",
      "comment_id": 2665920756,
      "user": "potiuk",
      "created_at": "2026-01-06T18:42:56Z",
      "url": "https://github.com/apache/airflow/pull/59883#discussion_r2665920756"
    },
    {
      "repo": "apache/airflow",
      "pr_number": 59883,
      "file_path": "airflow-core/tests/unit/listeners/test_listeners.py",
      "line": 165,
      "side": "RIGHT",
      "diff_hunk": "@@ -159,27 +151,25 @@ def test_listener_captures_longrunning_taskinstances(create_task_instance_of_ope\n \n \n @provide_session\n-def test_class_based_listener(create_task_instance, session):\n-    lm = get_listener_manager()\n+def test_class_based_listener(create_task_instance, session, listener_manager):\n     listener = class_listener.ClassBasedListener()\n-    lm.add_listener(listener)\n+    listener_manager(listener)\n \n     ti = create_task_instance(session=session, state=TaskInstanceState.QUEUED)\n     ti.run()\n \n     assert listener.state == [TaskInstanceState.RUNNING, TaskInstanceState.SUCCESS, DagRunState.SUCCESS]\n \n \n-def test_listener_logs_call(caplog, create_task_instance, session):\n-    caplog.set_level(logging.DEBUG, logger=\"airflow.listeners.listener\")\n-    lm = get_listener_manager()\n-    lm.add_listener(full_listener)\n+def test_listener_logs_call(caplog, create_task_instance, session, listener_manager):\n+    caplog.set_level(logging.DEBUG, logger=\"airflow.sdk._shared.listeners.listener\")",
      "comment": "Unfortunately this is intentional because we use `DagMaker` in `create_task_instance` fixture. That uses task sdk to make dags and hence the sdk path is needed here.",
      "comment_id": 2667587980,
      "user": "amoghrajesh",
      "created_at": "2026-01-07T08:58:19Z",
      "url": "https://github.com/apache/airflow/pull/59883#discussion_r2667587980"
    },
    {
      "repo": "apache/airflow",
      "pr_number": 59883,
      "file_path": "airflow-core/tests/unit/listeners/test_listeners.py",
      "line": 165,
      "side": "RIGHT",
      "diff_hunk": "@@ -159,27 +151,25 @@ def test_listener_captures_longrunning_taskinstances(create_task_instance_of_ope\n \n \n @provide_session\n-def test_class_based_listener(create_task_instance, session):\n-    lm = get_listener_manager()\n+def test_class_based_listener(create_task_instance, session, listener_manager):\n     listener = class_listener.ClassBasedListener()\n-    lm.add_listener(listener)\n+    listener_manager(listener)\n \n     ti = create_task_instance(session=session, state=TaskInstanceState.QUEUED)\n     ti.run()\n \n     assert listener.state == [TaskInstanceState.RUNNING, TaskInstanceState.SUCCESS, DagRunState.SUCCESS]\n \n \n-def test_listener_logs_call(caplog, create_task_instance, session):\n-    caplog.set_level(logging.DEBUG, logger=\"airflow.listeners.listener\")\n-    lm = get_listener_manager()\n-    lm.add_listener(full_listener)\n+def test_listener_logs_call(caplog, create_task_instance, session, listener_manager):\n+    caplog.set_level(logging.DEBUG, logger=\"airflow.sdk._shared.listeners.listener\")",
      "comment": "Hmm. I think this should be fixed and we should separate those somehow - because if we do it this way, we will never be able to run tests on airflow-core without task-sdk being installed - which should be the mai guardrail for us to not accidentally depend on task-sdk. \r\n\r\nBut - we can deal with it later.",
      "comment_id": 2668019399,
      "user": "potiuk",
      "created_at": "2026-01-07T11:11:19Z",
      "url": "https://github.com/apache/airflow/pull/59883#discussion_r2668019399"
    },
    {
      "repo": "apache/airflow",
      "pr_number": 59883,
      "file_path": "airflow-core/tests/unit/listeners/test_listeners.py",
      "line": 165,
      "side": "RIGHT",
      "diff_hunk": "@@ -159,27 +151,25 @@ def test_listener_captures_longrunning_taskinstances(create_task_instance_of_ope\n \n \n @provide_session\n-def test_class_based_listener(create_task_instance, session):\n-    lm = get_listener_manager()\n+def test_class_based_listener(create_task_instance, session, listener_manager):\n     listener = class_listener.ClassBasedListener()\n-    lm.add_listener(listener)\n+    listener_manager(listener)\n \n     ti = create_task_instance(session=session, state=TaskInstanceState.QUEUED)\n     ti.run()\n \n     assert listener.state == [TaskInstanceState.RUNNING, TaskInstanceState.SUCCESS, DagRunState.SUCCESS]\n \n \n-def test_listener_logs_call(caplog, create_task_instance, session):\n-    caplog.set_level(logging.DEBUG, logger=\"airflow.listeners.listener\")\n-    lm = get_listener_manager()\n-    lm.add_listener(full_listener)\n+def test_listener_logs_call(caplog, create_task_instance, session, listener_manager):\n+    caplog.set_level(logging.DEBUG, logger=\"airflow.sdk._shared.listeners.listener\")",
      "comment": "Umm yeah I guess, but since its tests, is there something you worry about?",
      "comment_id": 2668039256,
      "user": "amoghrajesh",
      "created_at": "2026-01-07T11:18:26Z",
      "url": "https://github.com/apache/airflow/pull/59883#discussion_r2668039256"
    },
    {
      "repo": "apache/airflow",
      "pr_number": 59883,
      "file_path": "shared/listeners/tests/conftest.py",
      "line": 22,
      "side": "RIGHT",
      "diff_hunk": "@@ -0,0 +1,22 @@\n+#\n+# Licensed to the Apache Software Foundation (ASF) under one\n+# or more contributor license agreements.  See the NOTICE file\n+# distributed with this work for additional information\n+# regarding copyright ownership.  The ASF licenses this file\n+# to you under the Apache License, Version 2.0 (the\n+# \"License\"); you may not use this file except in compliance\n+# with the License.  You may obtain a copy of the License at\n+#\n+#   http://www.apache.org/licenses/LICENSE-2.0\n+#\n+# Unless required by applicable law or agreed to in writing,\n+# software distributed under the License is distributed on an\n+# \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+# KIND, either express or implied.  See the License for the\n+# specific language governing permissions and limitations\n+# under the License.\n+from __future__ import annotations\n+\n+import os\n+\n+os.environ[\"_AIRFLOW__AS_LIBRARY\"] = \"true\"",
      "comment": "Not a fan with this global side effect on import, especially since this leaks out of the tests (if you run multiple directories together)",
      "comment_id": 2671243273,
      "user": "uranusjr",
      "created_at": "2026-01-08T07:41:05Z",
      "url": "https://github.com/apache/airflow/pull/59883#discussion_r2671243273"
    },
    {
      "repo": "apache/airflow",
      "pr_number": 59883,
      "file_path": "shared/listeners/tests/conftest.py",
      "line": 22,
      "side": "RIGHT",
      "diff_hunk": "@@ -0,0 +1,22 @@\n+#\n+# Licensed to the Apache Software Foundation (ASF) under one\n+# or more contributor license agreements.  See the NOTICE file\n+# distributed with this work for additional information\n+# regarding copyright ownership.  The ASF licenses this file\n+# to you under the Apache License, Version 2.0 (the\n+# \"License\"); you may not use this file except in compliance\n+# with the License.  You may obtain a copy of the License at\n+#\n+#   http://www.apache.org/licenses/LICENSE-2.0\n+#\n+# Unless required by applicable law or agreed to in writing,\n+# software distributed under the License is distributed on an\n+# \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+# KIND, either express or implied.  See the License for the\n+# specific language governing permissions and limitations\n+# under the License.\n+from __future__ import annotations\n+\n+import os\n+\n+os.environ[\"_AIRFLOW__AS_LIBRARY\"] = \"true\"",
      "comment": "These are used only for shared library tests and those are run separately per library. So do you think this still is an issue?",
      "comment_id": 2671309493,
      "user": "amoghrajesh",
      "created_at": "2026-01-08T08:00:00Z",
      "url": "https://github.com/apache/airflow/pull/59883#discussion_r2671309493"
    },
    {
      "repo": "apache/airflow",
      "pr_number": 59883,
      "file_path": "shared/listeners/tests/conftest.py",
      "line": 22,
      "side": "RIGHT",
      "diff_hunk": "@@ -0,0 +1,22 @@\n+#\n+# Licensed to the Apache Software Foundation (ASF) under one\n+# or more contributor license agreements.  See the NOTICE file\n+# distributed with this work for additional information\n+# regarding copyright ownership.  The ASF licenses this file\n+# to you under the Apache License, Version 2.0 (the\n+# \"License\"); you may not use this file except in compliance\n+# with the License.  You may obtain a copy of the License at\n+#\n+#   http://www.apache.org/licenses/LICENSE-2.0\n+#\n+# Unless required by applicable law or agreed to in writing,\n+# software distributed under the License is distributed on an\n+# \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+# KIND, either express or implied.  See the License for the\n+# specific language governing permissions and limitations\n+# under the License.\n+from __future__ import annotations\n+\n+import os\n+\n+os.environ[\"_AIRFLOW__AS_LIBRARY\"] = \"true\"",
      "comment": "The thing I don\u2019t like is if you run the shared lib and core tests in the same process (say locally in breeze) it would mysteriously fail. I wonder if this would work in a module-scoped fixture instead.",
      "comment_id": 2671339443,
      "user": "uranusjr",
      "created_at": "2026-01-08T08:08:51Z",
      "url": "https://github.com/apache/airflow/pull/59883#discussion_r2671339443"
    },
    {
      "repo": "apache/airflow",
      "pr_number": 59883,
      "file_path": "shared/listeners/tests/conftest.py",
      "line": 22,
      "side": "RIGHT",
      "diff_hunk": "@@ -0,0 +1,22 @@\n+#\n+# Licensed to the Apache Software Foundation (ASF) under one\n+# or more contributor license agreements.  See the NOTICE file\n+# distributed with this work for additional information\n+# regarding copyright ownership.  The ASF licenses this file\n+# to you under the Apache License, Version 2.0 (the\n+# \"License\"); you may not use this file except in compliance\n+# with the License.  You may obtain a copy of the License at\n+#\n+#   http://www.apache.org/licenses/LICENSE-2.0\n+#\n+# Unless required by applicable law or agreed to in writing,\n+# software distributed under the License is distributed on an\n+# \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+# KIND, either express or implied.  See the License for the\n+# specific language governing permissions and limitations\n+# under the License.\n+from __future__ import annotations\n+\n+import os\n+\n+os.environ[\"_AIRFLOW__AS_LIBRARY\"] = \"true\"",
      "comment": "Or maybe use hook functions to set/unset this on load/unload? https://docs.pytest.org/en/7.1.x/how-to/writing_hook_functions.html",
      "comment_id": 2671341853,
      "user": "uranusjr",
      "created_at": "2026-01-08T08:09:35Z",
      "url": "https://github.com/apache/airflow/pull/59883#discussion_r2671341853"
    },
    {
      "repo": "apache/airflow",
      "pr_number": 59883,
      "file_path": "shared/listeners/tests/conftest.py",
      "line": 22,
      "side": "RIGHT",
      "diff_hunk": "@@ -0,0 +1,22 @@\n+#\n+# Licensed to the Apache Software Foundation (ASF) under one\n+# or more contributor license agreements.  See the NOTICE file\n+# distributed with this work for additional information\n+# regarding copyright ownership.  The ASF licenses this file\n+# to you under the Apache License, Version 2.0 (the\n+# \"License\"); you may not use this file except in compliance\n+# with the License.  You may obtain a copy of the License at\n+#\n+#   http://www.apache.org/licenses/LICENSE-2.0\n+#\n+# Unless required by applicable law or agreed to in writing,\n+# software distributed under the License is distributed on an\n+# \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+# KIND, either express or implied.  See the License for the\n+# specific language governing permissions and limitations\n+# under the License.\n+from __future__ import annotations\n+\n+import os\n+\n+os.environ[\"_AIRFLOW__AS_LIBRARY\"] = \"true\"",
      "comment": "Let me just do it after this in a follow up: https://github.com/apache/airflow/issues/60253",
      "comment_id": 2671413856,
      "user": "amoghrajesh",
      "created_at": "2026-01-08T08:34:06Z",
      "url": "https://github.com/apache/airflow/pull/59883#discussion_r2671413856"
    },
    {
      "repo": "apache/airflow",
      "pr_number": 59883,
      "file_path": "shared/listeners/tests/conftest.py",
      "line": 22,
      "side": "RIGHT",
      "diff_hunk": "@@ -0,0 +1,22 @@\n+#\n+# Licensed to the Apache Software Foundation (ASF) under one\n+# or more contributor license agreements.  See the NOTICE file\n+# distributed with this work for additional information\n+# regarding copyright ownership.  The ASF licenses this file\n+# to you under the Apache License, Version 2.0 (the\n+# \"License\"); you may not use this file except in compliance\n+# with the License.  You may obtain a copy of the License at\n+#\n+#   http://www.apache.org/licenses/LICENSE-2.0\n+#\n+# Unless required by applicable law or agreed to in writing,\n+# software distributed under the License is distributed on an\n+# \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+# KIND, either express or implied.  See the License for the\n+# specific language governing permissions and limitations\n+# under the License.\n+from __future__ import annotations\n+\n+import os\n+\n+os.environ[\"_AIRFLOW__AS_LIBRARY\"] = \"true\"",
      "comment": "This will require getting rid of all the import side effects though",
      "comment_id": 2672081389,
      "user": "potiuk",
      "created_at": "2026-01-08T12:01:29Z",
      "url": "https://github.com/apache/airflow/pull/59883#discussion_r2672081389"
    },
    {
      "repo": "apache/airflow",
      "pr_number": 59883,
      "file_path": "task-sdk/src/airflow/sdk/listeners/__init__.py",
      "line": 22,
      "side": "RIGHT",
      "diff_hunk": "@@ -0,0 +1,22 @@\n+#\n+# Licensed to the Apache Software Foundation (ASF) under one\n+# or more contributor license agreements.  See the NOTICE file\n+# distributed with this work for additional information\n+# regarding copyright ownership.  The ASF licenses this file\n+# to you under the Apache License, Version 2.0 (the\n+# \"License\"); you may not use this file except in compliance\n+# with the License.  You may obtain a copy of the License at\n+#\n+#   http://www.apache.org/licenses/LICENSE-2.0\n+#\n+# Unless required by applicable law or agreed to in writing,\n+# software distributed under the License is distributed on an\n+# \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+# KIND, either express or implied.  See the License for the\n+# specific language governing permissions and limitations\n+# under the License.\n+from __future__ import annotations\n+\n+from airflow.sdk._shared.listeners import hookimpl\n+\n+__all__ = [\"hookimpl\"]",
      "comment": "Done in a different way now, so this comment is not valid",
      "comment_id": 2672495383,
      "user": "amoghrajesh",
      "created_at": "2026-01-08T14:05:39Z",
      "url": "https://github.com/apache/airflow/pull/59883#discussion_r2672495383"
    },
    {
      "repo": "apache/airflow",
      "pr_number": 60006,
      "file_path": "airflow-core/src/airflow/jobs/scheduler_job_runner.py",
      "line": 1863,
      "side": "RIGHT",
      "diff_hunk": "@@ -1847,13 +1846,8 @@ def _create_dag_runs(self, dag_models: Collection[DagModel], session: Session) -\n                     #  https://github.com/apache/airflow/issues/59120\n                     continue\n \n-            self._update_next_dagrun_fields(\n-                serdag=serdag,\n-                dag_model=dag_model,\n-                session=session,\n-                active_non_backfill_runs=active_runs_of_dags[serdag.dag_id],\n-                data_interval=data_interval,\n-            )\n+            self._check_exceeds_max_active_runs(dag_model=dag_model, session=session)\n+            dag_model.calculate_dagrun_date_fields(dag=serdag, last_automated_dag_run=data_interval)",
      "comment": "since we have separated the \"exceeds max\" check from \"next dagrun\", we can now call them both unconditionally when creating a new run",
      "comment_id": 2656288150,
      "user": "dstandish",
      "created_at": "2026-01-01T11:27:27Z",
      "url": "https://github.com/apache/airflow/pull/60006#discussion_r2656288150"
    },
    {
      "repo": "apache/airflow",
      "pr_number": 60006,
      "file_path": "airflow-core/src/airflow/jobs/scheduler_job_runner.py",
      "line": 2150,
      "side": "RIGHT",
      "diff_hunk": "@@ -2135,17 +2129,12 @@ def _schedule_dag_run(\n                 session.flush()\n                 self.log.info(\"Run %s of %s has timed-out\", dag_run.run_id, dag_run.dag_id)\n \n-                # TODO: questionable that this logic does what it is trying to do\n-                #  I think its intent is, in part, to do this when it's the latest scheduled run\n-                #  but it does not know that it is the latest. I think it could probably check that\n-                #  logical date is equal to or greater than DagModel.next_dagrun, or something\n-                if dag_run.state in State.finished_dr_states and dag_run.run_type == DagRunType.SCHEDULED:\n-                    self._update_next_dagrun_fields(\n-                        serdag=dag,\n-                        dag_model=dag_model,\n-                        session=session,\n-                        data_interval=get_run_data_interval(dag.timetable, dag_run),\n-                    )\n+                if dag_run.state in State.finished_dr_states and dag_run.run_type in (\n+                    DagRunType.SCHEDULED,\n+                    DagRunType.MANUAL,\n+                    DagRunType.ASSET_TRIGGERED,\n+                ):\n+                    self._check_exceeds_max_active_runs(dag_model=dag_model, session=session)",
      "comment": "we should not need to call `calculate_dagrun_date_fields` here anymore, since it's not getting set to null to signal \"exceeds max\". since we're not adding any new runs here, we shouldn't need to change the next run.\n\nnote that we can now evaluate max active runs with more dag run types, since we've decoupled that from the dates.",
      "comment_id": 2656291641,
      "user": "dstandish",
      "created_at": "2026-01-01T11:30:28Z",
      "url": "https://github.com/apache/airflow/pull/60006#discussion_r2656291641"
    },
    {
      "repo": "apache/airflow",
      "pr_number": 60006,
      "file_path": "airflow-core/src/airflow/migrations/versions/0097_3_2_0_add_exceeds_max_runs_flag_to_dag_model.py",
      "line": 43,
      "side": "RIGHT",
      "diff_hunk": "@@ -0,0 +1,49 @@\n+#\n+# Licensed to the Apache Software Foundation (ASF) under one\n+# or more contributor license agreements.  See the NOTICE file\n+# distributed with this work for additional information\n+# regarding copyright ownership.  The ASF licenses this file\n+# to you under the Apache License, Version 2.0 (the\n+# \"License\"); you may not use this file except in compliance\n+# with the License.  You may obtain a copy of the License at\n+#\n+#   http://www.apache.org/licenses/LICENSE-2.0\n+#\n+# Unless required by applicable law or agreed to in writing,\n+# software distributed under the License is distributed on an\n+# \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+# KIND, either express or implied.  See the License for the\n+# specific language governing permissions and limitations\n+# under the License.\n+\n+\"\"\"\n+Add exceeds max runs flag to dag model.\n+\n+Revision ID: 0b112f49112d\n+Revises: c47f2e1ab9d4\n+Create Date: 2025-12-31 13:40:50.550261\n+\n+\"\"\"\n+\n+from __future__ import annotations\n+\n+import sqlalchemy as sa\n+from alembic import op\n+\n+revision = \"0b112f49112d\"\n+down_revision = \"c47f2e1ab9d4\"\n+branch_labels = None\n+depends_on = None\n+airflow_version = \"3.2.0\"\n+\n+\n+def upgrade():\n+    \"\"\"Apply Add exceeds max runs flag to dag model.\"\"\"\n+    with op.batch_alter_table(\"dag\", schema=None) as batch_op:\n+        batch_op.add_column(sa.Column(\"exceeds_max_non_backfill\", sa.Boolean(), nullable=False))",
      "comment": "```suggestion\r\n        batch_op.add_column(sa.Column(\"exceeds_max_non_backfill\", sa.Boolean(), server_default=\"0\", nullable=False))\r\n```",
      "comment_id": 2660642991,
      "user": "ephraimbuddy",
      "created_at": "2026-01-05T08:18:25Z",
      "url": "https://github.com/apache/airflow/pull/60006#discussion_r2660642991"
    },
    {
      "repo": "apache/airflow",
      "pr_number": 60006,
      "file_path": "airflow-core/src/airflow/jobs/scheduler_job_runner.py",
      "line": 1793,
      "side": "RIGHT",
      "diff_hunk": "@@ -1790,6 +1789,14 @@ def _create_dag_runs(self, dag_models: Collection[DagModel], session: Session) -\n         )\n \n         for dag_model in dag_models:\n+            if dag_model.exceeds_max_non_backfill:\n+                self.log.error(",
      "comment": "Should it be a warning instead? Since max active runs is set by users, it's kinda expected?",
      "comment_id": 2667380936,
      "user": "Lee-W",
      "created_at": "2026-01-07T07:41:11Z",
      "url": "https://github.com/apache/airflow/pull/60006#discussion_r2667380936"
    },
    {
      "repo": "apache/airflow",
      "pr_number": 60006,
      "file_path": "airflow-core/src/airflow/jobs/scheduler_job_runner.py",
      "line": 2978,
      "side": "RIGHT",
      "diff_hunk": "@@ -3020,7 +2975,7 @@ def _try_to_load_executor(self, ti: TaskInstance, session, team_name=NOTSET) ->\n \n         return executor\n \n-    def _exceeds_max_active_runs(\n+    def _check_exceeds_max_active_runs(",
      "comment": "```suggestion\n    def _set_exceeds_max_active_runs(\n```\n\nset... might make more sense here? We're not actually checking . We just set the value here",
      "comment_id": 2667386640,
      "user": "Lee-W",
      "created_at": "2026-01-07T07:43:41Z",
      "url": "https://github.com/apache/airflow/pull/60006#discussion_r2667386640"
    },
    {
      "repo": "apache/airflow",
      "pr_number": 60006,
      "file_path": "airflow-core/src/airflow/jobs/scheduler_job_runner.py",
      "line": 2978,
      "side": "RIGHT",
      "diff_hunk": "@@ -3020,7 +2975,7 @@ def _try_to_load_executor(self, ti: TaskInstance, session, team_name=NOTSET) ->\n \n         return executor\n \n-    def _exceeds_max_active_runs(\n+    def _check_exceeds_max_active_runs(",
      "comment": "i think check actually makes sense because, we are checking whether it is exceeded; and if it is exceeded, then we set it to the right value.  you can't set without that \"check\" part first.\r\n\r\nTo me, `set` sort of implies we already know, and we are setting it to `exceeds=True`. \r\n\r\nI think `evaluate` might be an even better word, but it's so long i kindof think check is better. wdyt?",
      "comment_id": 2669219575,
      "user": "dstandish",
      "created_at": "2026-01-07T16:48:59Z",
      "url": "https://github.com/apache/airflow/pull/60006#discussion_r2669219575"
    },
    {
      "repo": "apache/airflow",
      "pr_number": 60006,
      "file_path": "airflow-core/src/airflow/jobs/scheduler_job_runner.py",
      "line": 2978,
      "side": "RIGHT",
      "diff_hunk": "@@ -3020,7 +2975,7 @@ def _try_to_load_executor(self, ti: TaskInstance, session, team_name=NOTSET) ->\n \n         return executor\n \n-    def _exceeds_max_active_runs(\n+    def _check_exceeds_max_active_runs(",
      "comment": "But i guess set makes it clear we're writing, so, that's good too. i'll just change it to set.",
      "comment_id": 2669221985,
      "user": "dstandish",
      "created_at": "2026-01-07T16:49:44Z",
      "url": "https://github.com/apache/airflow/pull/60006#discussion_r2669221985"
    },
    {
      "repo": "apache/airflow",
      "pr_number": 57753,
      "file_path": "providers/amazon/src/airflow/providers/amazon/aws/operators/ssm.py",
      "line": 162,
      "side": "RIGHT",
      "diff_hunk": "@@ -132,14 +143,36 @@ def execute(self, context: Context):\n \n             instance_ids = response[\"Command\"][\"InstanceIds\"]\n             for instance_id in instance_ids:\n-                waiter.wait(\n-                    CommandId=command_id,\n-                    InstanceId=instance_id,\n-                    WaiterConfig={\n-                        \"Delay\": self.waiter_delay,\n-                        \"MaxAttempts\": self.waiter_max_attempts,\n-                    },\n-                )\n+                try:\n+                    waiter.wait(\n+                        CommandId=command_id,\n+                        InstanceId=instance_id,\n+                        WaiterConfig={\n+                            \"Delay\": self.waiter_delay,\n+                            \"MaxAttempts\": self.waiter_max_attempts,\n+                        },\n+                    )\n+                except WaiterError:\n+                    if not self.fail_on_nonzero_exit:\n+                        # Enhanced mode: distinguish between AWS-level and command-level failures\n+                        invocation = self.hook.get_command_invocation(command_id, instance_id)\n+                        status = invocation.get(\"Status\", \"\")\n+\n+                        # AWS-level failures should always raise\n+                        if status in (\"Cancelled\", \"TimedOut\"):",
      "comment": "Are these the only \"aws-level\" failures? Always cautious of static lists like this.",
      "comment_id": 2492390911,
      "user": "o-nikolas",
      "created_at": "2025-11-05T00:18:09Z",
      "url": "https://github.com/apache/airflow/pull/57753#discussion_r2492390911"
    },
    {
      "repo": "apache/airflow",
      "pr_number": 57753,
      "file_path": "providers/amazon/src/airflow/providers/amazon/aws/operators/ssm.py",
      "line": 163,
      "side": "RIGHT",
      "diff_hunk": "@@ -132,14 +143,36 @@ def execute(self, context: Context):\n \n             instance_ids = response[\"Command\"][\"InstanceIds\"]\n             for instance_id in instance_ids:\n-                waiter.wait(\n-                    CommandId=command_id,\n-                    InstanceId=instance_id,\n-                    WaiterConfig={\n-                        \"Delay\": self.waiter_delay,\n-                        \"MaxAttempts\": self.waiter_max_attempts,\n-                    },\n-                )\n+                try:\n+                    waiter.wait(\n+                        CommandId=command_id,\n+                        InstanceId=instance_id,\n+                        WaiterConfig={\n+                            \"Delay\": self.waiter_delay,\n+                            \"MaxAttempts\": self.waiter_max_attempts,\n+                        },\n+                    )\n+                except WaiterError:\n+                    if not self.fail_on_nonzero_exit:\n+                        # Enhanced mode: distinguish between AWS-level and command-level failures\n+                        invocation = self.hook.get_command_invocation(command_id, instance_id)\n+                        status = invocation.get(\"Status\", \"\")\n+\n+                        # AWS-level failures should always raise\n+                        if status in (\"Cancelled\", \"TimedOut\"):\n+                            self.log.error(\"Command failed with AWS-level error: %s\", status)",
      "comment": "We probably don't need this? It fails today without a log when these situations happen.",
      "comment_id": 2492391766,
      "user": "o-nikolas",
      "created_at": "2025-11-05T00:18:46Z",
      "url": "https://github.com/apache/airflow/pull/57753#discussion_r2492391766"
    },
    {
      "repo": "apache/airflow",
      "pr_number": 57753,
      "file_path": "providers/amazon/src/airflow/providers/amazon/aws/triggers/ssm.py",
      "line": 107,
      "side": "RIGHT",
      "diff_hunk": "@@ -89,14 +94,47 @@ async def run(self) -> AsyncIterator[TriggerEvent]:\n \n             for instance_id in instance_ids:\n                 self.waiter_args[\"InstanceId\"] = instance_id\n-                await async_wait(\n-                    waiter,\n-                    self.waiter_delay,\n-                    self.attempts,\n-                    self.waiter_args,\n-                    self.failure_message,\n-                    self.status_message,\n-                    self.status_queries,\n-                )\n+                try:\n+                    await async_wait(\n+                        waiter,\n+                        self.waiter_delay,\n+                        self.attempts,\n+                        self.waiter_args,\n+                        self.failure_message,\n+                        self.status_message,\n+                        self.status_queries,\n+                    )\n+                except Exception:",
      "comment": "It looks like you do this pattern three separate times with lots of duplicated log strings, state sets/tuples, etc. Can this logic be extracted out into a helper method that's defined once and used three times?",
      "comment_id": 2492396406,
      "user": "o-nikolas",
      "created_at": "2025-11-05T00:22:08Z",
      "url": "https://github.com/apache/airflow/pull/57753#discussion_r2492396406"
    },
    {
      "repo": "apache/airflow",
      "pr_number": 57753,
      "file_path": "providers/amazon/src/airflow/providers/amazon/aws/operators/ssm.py",
      "line": 162,
      "side": "RIGHT",
      "diff_hunk": "@@ -132,14 +143,36 @@ def execute(self, context: Context):\n \n             instance_ids = response[\"Command\"][\"InstanceIds\"]\n             for instance_id in instance_ids:\n-                waiter.wait(\n-                    CommandId=command_id,\n-                    InstanceId=instance_id,\n-                    WaiterConfig={\n-                        \"Delay\": self.waiter_delay,\n-                        \"MaxAttempts\": self.waiter_max_attempts,\n-                    },\n-                )\n+                try:\n+                    waiter.wait(\n+                        CommandId=command_id,\n+                        InstanceId=instance_id,\n+                        WaiterConfig={\n+                            \"Delay\": self.waiter_delay,\n+                            \"MaxAttempts\": self.waiter_max_attempts,\n+                        },\n+                    )\n+                except WaiterError:\n+                    if not self.fail_on_nonzero_exit:\n+                        # Enhanced mode: distinguish between AWS-level and command-level failures\n+                        invocation = self.hook.get_command_invocation(command_id, instance_id)\n+                        status = invocation.get(\"Status\", \"\")\n+\n+                        # AWS-level failures should always raise\n+                        if status in (\"Cancelled\", \"TimedOut\"):",
      "comment": "Yes. I have double checked the documentation. However, to make things easier, I've added `SsmHook.is_aws_level_failure()` helper method with the statuses list.",
      "comment_id": 2599037219,
      "user": "ksharlandjiev",
      "created_at": "2025-12-08T15:21:39Z",
      "url": "https://github.com/apache/airflow/pull/57753#discussion_r2599037219"
    },
    {
      "repo": "apache/airflow",
      "pr_number": 57753,
      "file_path": "providers/amazon/src/airflow/providers/amazon/aws/triggers/ssm.py",
      "line": 107,
      "side": "RIGHT",
      "diff_hunk": "@@ -89,14 +94,47 @@ async def run(self) -> AsyncIterator[TriggerEvent]:\n \n             for instance_id in instance_ids:\n                 self.waiter_args[\"InstanceId\"] = instance_id\n-                await async_wait(\n-                    waiter,\n-                    self.waiter_delay,\n-                    self.attempts,\n-                    self.waiter_args,\n-                    self.failure_message,\n-                    self.status_message,\n-                    self.status_queries,\n-                )\n+                try:\n+                    await async_wait(\n+                        waiter,\n+                        self.waiter_delay,\n+                        self.attempts,\n+                        self.waiter_args,\n+                        self.failure_message,\n+                        self.status_message,\n+                        self.status_queries,\n+                    )\n+                except Exception:",
      "comment": "done. I've removed the code duplication across operator, sensor, and trigger",
      "comment_id": 2599040923,
      "user": "ksharlandjiev",
      "created_at": "2025-12-08T15:22:32Z",
      "url": "https://github.com/apache/airflow/pull/57753#discussion_r2599040923"
    },
    {
      "repo": "apache/airflow",
      "pr_number": 60065,
      "file_path": "airflow-core/src/airflow/serialization/serialized_objects.py",
      "line": 1125,
      "side": "RIGHT",
      "diff_hunk": "@@ -1121,7 +1121,10 @@ def _serialize_node(cls, op: SdkOperator) -> dict[str, Any]:\n                     )\n                 value = getattr(op, template_field, None)\n                 if not cls._is_excluded(value, template_field, op):\n-                    serialize_op[template_field] = serialize_template_field(value, template_field)\n+                    if callable(value):\n+                        serialize_op[template_field] = cls.serialize(value)",
      "comment": "This is good however, secrets won't be redacted. Can you check if you can work on serialize_template_field to handle this case? That way any secret here would be redacted",
      "comment_id": 2661270754,
      "user": "ephraimbuddy",
      "created_at": "2026-01-05T12:02:17Z",
      "url": "https://github.com/apache/airflow/pull/60065#discussion_r2661270754"
    },
    {
      "repo": "apache/airflow",
      "pr_number": 60065,
      "file_path": "airflow-core/src/airflow/serialization/serialized_objects.py",
      "line": 1125,
      "side": "RIGHT",
      "diff_hunk": "@@ -1121,7 +1121,10 @@ def _serialize_node(cls, op: SdkOperator) -> dict[str, Any]:\n                     )\n                 value = getattr(op, template_field, None)\n                 if not cls._is_excluded(value, template_field, op):\n-                    serialize_op[template_field] = serialize_template_field(value, template_field)\n+                    if callable(value):\n+                        serialize_op[template_field] = cls.serialize(value)",
      "comment": "actually went with a different approach based on MD5 hash of the callable source code. Got the idea from this [comment](https://github.com/apache/airflow/discussions/59595#discussioncomment-15373896).",
      "comment_id": 2663152160,
      "user": "m8719-github",
      "created_at": "2026-01-06T00:09:48Z",
      "url": "https://github.com/apache/airflow/pull/60065#discussion_r2663152160"
    },
    {
      "repo": "apache/airflow",
      "pr_number": 60065,
      "file_path": "airflow-core/src/airflow/utils/code_utils.py",
      "line": 57,
      "side": "RIGHT",
      "diff_hunk": "@@ -50,6 +51,12 @@ def get_python_source(x: Any) -> str | None:\n     return source_code\n \n \n+def get_python_source_md5(x: Any) -> str:\n+    \"\"\"Get Python source MD5 hash/fingerprint.\"\"\"\n+    source_code = str(get_python_source(x))\n+    return hashlib.md5(source_code.encode()).hexdigest()",
      "comment": "Please use airflow-core/src/airflow/utils/hashlib_wrapper.py -> this one is used whenever we use md5 from core, this makes it works even in FIPS-enabled environment that disable weak algorithms when used for security.",
      "comment_id": 2664700544,
      "user": "potiuk",
      "created_at": "2026-01-06T12:01:38Z",
      "url": "https://github.com/apache/airflow/pull/60065#discussion_r2664700544"
    },
    {
      "repo": "apache/airflow",
      "pr_number": 60065,
      "file_path": "airflow-core/src/airflow/serialization/helpers.py",
      "line": 79,
      "side": "RIGHT",
      "diff_hunk": "@@ -71,7 +75,11 @@ def sort_dict_recursively(obj: Any) -> Any:\n         try:\n             serialized = template_field.serialize()\n         except AttributeError:\n-            serialized = str(template_field)\n+            if callable(template_field):\n+                fingerprint = get_python_source_md5(template_field)",
      "comment": "I wonder if we should instead just use the name, like we do for python_callable in PythonOperator.",
      "comment_id": 2665363715,
      "user": "jedcunningham",
      "created_at": "2026-01-06T15:43:12Z",
      "url": "https://github.com/apache/airflow/pull/60065#discussion_r2665363715"
    },
    {
      "repo": "apache/airflow",
      "pr_number": 60065,
      "file_path": "airflow-core/src/airflow/serialization/helpers.py",
      "line": 79,
      "side": "RIGHT",
      "diff_hunk": "@@ -71,7 +75,11 @@ def sort_dict_recursively(obj: Any) -> Any:\n         try:\n             serialized = template_field.serialize()\n         except AttributeError:\n-            serialized = str(template_field)\n+            if callable(template_field):\n+                fingerprint = get_python_source_md5(template_field)",
      "comment": "Like [this](https://github.com/apache/airflow/blob/0e23eed3493796ddac2bbb6c8614eb2f14d69e86/airflow-core/src/airflow/serialization/serialized_objects.py#L1061) I mean.",
      "comment_id": 2665373738,
      "user": "jedcunningham",
      "created_at": "2026-01-06T15:45:18Z",
      "url": "https://github.com/apache/airflow/pull/60065#discussion_r2665373738"
    },
    {
      "repo": "apache/airflow",
      "pr_number": 60065,
      "file_path": "airflow-core/src/airflow/serialization/helpers.py",
      "line": 79,
      "side": "RIGHT",
      "diff_hunk": "@@ -71,7 +75,11 @@ def sort_dict_recursively(obj: Any) -> Any:\n         try:\n             serialized = template_field.serialize()\n         except AttributeError:\n-            serialized = str(template_field)\n+            if callable(template_field):\n+                fingerprint = get_python_source_md5(template_field)",
      "comment": "Yeah. Crossed my mind that we are not interested in the \"internals\" of the method? I understand that this is just \"Serialzed Dag\" version - we would sill get a new bundle version if the code changes? ",
      "comment_id": 2665489937,
      "user": "potiuk",
      "created_at": "2026-01-06T16:22:33Z",
      "url": "https://github.com/apache/airflow/pull/60065#discussion_r2665489937"
    },
    {
      "repo": "apache/airflow",
      "pr_number": 60065,
      "file_path": "airflow-core/src/airflow/serialization/helpers.py",
      "line": 79,
      "side": "RIGHT",
      "diff_hunk": "@@ -71,7 +75,11 @@ def sort_dict_recursively(obj: Any) -> Any:\n         try:\n             serialized = template_field.serialize()\n         except AttributeError:\n-            serialized = str(template_field)\n+            if callable(template_field):\n+                fingerprint = get_python_source_md5(template_field)",
      "comment": "It depends if the callable is in the bundle - it may not be.",
      "comment_id": 2665566732,
      "user": "jedcunningham",
      "created_at": "2026-01-06T16:45:44Z",
      "url": "https://github.com/apache/airflow/pull/60065#discussion_r2665566732"
    },
    {
      "repo": "apache/airflow",
      "pr_number": 60065,
      "file_path": "airflow-core/src/airflow/serialization/helpers.py",
      "line": 79,
      "side": "RIGHT",
      "diff_hunk": "@@ -71,7 +75,11 @@ def sort_dict_recursively(obj: Any) -> Any:\n         try:\n             serialized = template_field.serialize()\n         except AttributeError:\n-            serialized = str(template_field)\n+            if callable(template_field):\n+                fingerprint = get_python_source_md5(template_field)",
      "comment": "I am for this as well, using only the name. It has a better user experience IMHO; i.e: the DAG version won't increment unless there is a visible DAG code change and it's actually visible in the UI (if I understand the logic correctly)\r\nOur use case that triggered this bug is this: we are populating KPO labels/annotations via callables and they are imported from a common module, part of the bundle. The current MD5 fingerprint implementation will increment version for all our DAGs with KPOs if source code of these callables changes but code visible in the UI will stay the same so a user/operator will be left scratching their head wondering why the version incremented unless they go digging through the common module changes.",
      "comment_id": 2665703400,
      "user": "m8719-github",
      "created_at": "2026-01-06T17:33:37Z",
      "url": "https://github.com/apache/airflow/pull/60065#discussion_r2665703400"
    },
    {
      "repo": "apache/airflow",
      "pr_number": 60065,
      "file_path": "airflow-core/src/airflow/serialization/helpers.py",
      "line": 79,
      "side": "RIGHT",
      "diff_hunk": "@@ -71,7 +75,11 @@ def sort_dict_recursively(obj: Any) -> Any:\n         try:\n             serialized = template_field.serialize()\n         except AttributeError:\n-            serialized = str(template_field)\n+            if callable(template_field):\n+                fingerprint = get_python_source_md5(template_field)",
      "comment": "done.\r\n\r\nalso added logic for one level of indirection: template var callable supplied by another function call.",
      "comment_id": 2666184171,
      "user": "m8719-github",
      "created_at": "2026-01-06T20:22:30Z",
      "url": "https://github.com/apache/airflow/pull/60065#discussion_r2666184171"
    },
    {
      "repo": "apache/airflow",
      "pr_number": 60065,
      "file_path": "airflow-core/src/airflow/serialization/helpers.py",
      "line": 80,
      "side": "RIGHT",
      "diff_hunk": "@@ -71,7 +75,11 @@ def sort_dict_recursively(obj: Any) -> Any:\n         try:\n             serialized = template_field.serialize()\n         except AttributeError:\n-            serialized = str(template_field)\n+            if callable(template_field):\n+                full_qualified_name = qualname(template_field, True)\n+                serialized = f\"<function {full_qualified_name}>\"",
      "comment": "```suggestion\n                serialized = f\"<callable {full_qualified_name}>\"\n```",
      "comment_id": 2667317642,
      "user": "potiuk",
      "created_at": "2026-01-07T07:12:26Z",
      "url": "https://github.com/apache/airflow/pull/60065#discussion_r2667317642"
    },
    {
      "repo": "apache/airflow",
      "pr_number": 60065,
      "file_path": "airflow-core/tests/unit/serialization/test_dag_serialization.py",
      "line": 1660,
      "side": "RIGHT",
      "diff_hunk": "@@ -1639,6 +1639,31 @@ def test_task_resources(self):\n         assert deserialized_task.resources == task.resources\n         assert isinstance(deserialized_task.resources, Resources)\n \n+    def test_template_field_via_callable_serialization(self):\n+        \"\"\"\n+        Test operator template fields serialization when provided as a callable.\n+        \"\"\"\n+\n+        def fn_template_field_callable(context, jinja_env):\n+            pass\n+\n+        def fn_returns_callable():\n+            def get_arg(context, jinja_env):\n+                pass\n+\n+            return get_arg\n+\n+        task = MockOperator(task_id=\"task1\", arg1=fn_template_field_callable, arg2=fn_returns_callable())\n+        serialized_task = OperatorSerialization.serialize_operator(task)\n+        assert (\n+            serialized_task.get(\"arg1\")\n+            == \"<function unit.serialization.test_dag_serialization.TestStringifiedDAGs.test_template_field_via_callable_serialization.<locals>.fn_template_field_callable>\"",
      "comment": "```suggestion\n            == \"<callable unit.serialization.test_dag_serialization.TestStringifiedDAGs.test_template_field_via_callable_serialization.<locals>.fn_template_field_callable>\"\n```",
      "comment_id": 2667318209,
      "user": "potiuk",
      "created_at": "2026-01-07T07:12:42Z",
      "url": "https://github.com/apache/airflow/pull/60065#discussion_r2667318209"
    },
    {
      "repo": "apache/airflow",
      "pr_number": 60065,
      "file_path": "airflow-core/tests/unit/serialization/test_dag_serialization.py",
      "line": 1664,
      "side": "RIGHT",
      "diff_hunk": "@@ -1639,6 +1639,31 @@ def test_task_resources(self):\n         assert deserialized_task.resources == task.resources\n         assert isinstance(deserialized_task.resources, Resources)\n \n+    def test_template_field_via_callable_serialization(self):\n+        \"\"\"\n+        Test operator template fields serialization when provided as a callable.\n+        \"\"\"\n+\n+        def fn_template_field_callable(context, jinja_env):\n+            pass\n+\n+        def fn_returns_callable():\n+            def get_arg(context, jinja_env):\n+                pass\n+\n+            return get_arg\n+\n+        task = MockOperator(task_id=\"task1\", arg1=fn_template_field_callable, arg2=fn_returns_callable())\n+        serialized_task = OperatorSerialization.serialize_operator(task)\n+        assert (\n+            serialized_task.get(\"arg1\")\n+            == \"<function unit.serialization.test_dag_serialization.TestStringifiedDAGs.test_template_field_via_callable_serialization.<locals>.fn_template_field_callable>\"\n+        )\n+        assert (\n+            serialized_task.get(\"arg2\")\n+            == \"<function unit.serialization.test_dag_serialization.TestStringifiedDAGs.test_template_field_via_callable_serialization.<locals>.fn_returns_callable.<locals>.get_arg>\"",
      "comment": "```suggestion\n            == \"<callable unit.serialization.test_dag_serialization.TestStringifiedDAGs.test_template_field_via_callable_serialization.<locals>.fn_returns_callable.<locals>.get_arg>\"\n```",
      "comment_id": 2667318554,
      "user": "potiuk",
      "created_at": "2026-01-07T07:12:51Z",
      "url": "https://github.com/apache/airflow/pull/60065#discussion_r2667318554"
    },
    {
      "repo": "apache/airflow",
      "pr_number": 60065,
      "file_path": "airflow-core/src/airflow/serialization/helpers.py",
      "line": 38,
      "side": "RIGHT",
      "diff_hunk": "@@ -33,6 +34,9 @@ def serialize_template_field(template_field: Any, name: str) -> str | dict | lis\n     \"\"\"\n     Return a serializable representation of the templated field.\n \n+    If ``templated_field`` is provided via a callable, compute MD5 hash of source\n+    and return following serialized value: ``<function fingerprint(MD5) hash_value``",
      "comment": "```suggestion\n    and return following serialized value: ``<callable fingerprint(MD5) hash_value``\n```",
      "comment_id": 2667319103,
      "user": "potiuk",
      "created_at": "2026-01-07T07:13:08Z",
      "url": "https://github.com/apache/airflow/pull/60065#discussion_r2667319103"
    },
    {
      "repo": "apache/airflow",
      "pr_number": 60065,
      "file_path": "shared/module_loading/src/airflow_shared/module_loading/__init__.py",
      "line": 67,
      "side": "RIGHT",
      "diff_hunk": "@@ -63,10 +63,13 @@ def import_string(dotted_path: str):\n         raise ImportError(f'Module \"{module_path}\" does not define a \"{class_name}\" attribute/class')\n \n \n-def qualname(o: object | Callable) -> str:\n+def qualname(o: object | Callable, use_qualname: bool = False) -> str:\n     \"\"\"Convert an attribute/class/function to a string importable by ``import_string``.\"\"\"",
      "comment": "```suggestion\n    \"\"\"Convert an attribute/class/callable to a string importable by ``import_string``.\"\"\"\n```",
      "comment_id": 2667320016,
      "user": "potiuk",
      "created_at": "2026-01-07T07:13:36Z",
      "url": "https://github.com/apache/airflow/pull/60065#discussion_r2667320016"
    },
    {
      "repo": "apache/airflow",
      "pr_number": 60065,
      "file_path": "shared/module_loading/src/airflow_shared/module_loading/__init__.py",
      "line": 72,
      "side": "RIGHT",
      "diff_hunk": "@@ -63,10 +63,13 @@ def import_string(dotted_path: str):\n         raise ImportError(f'Module \"{module_path}\" does not define a \"{class_name}\" attribute/class')\n \n \n-def qualname(o: object | Callable) -> str:\n-    \"\"\"Convert an attribute/class/function to a string importable by ``import_string``.\"\"\"\n-    if callable(o) and hasattr(o, \"__module__\") and hasattr(o, \"__name__\"):\n-        return f\"{o.__module__}.{o.__name__}\"\n+def qualname(o: object | Callable, use_qualname: bool = False) -> str:\n+    \"\"\"Convert an attribute/class/callable to a string importable by ``import_string``.\"\"\"\n+    if callable(o) and hasattr(o, \"__module__\"):\n+        if use_qualname and hasattr(o, \"__qualname__\"):\n+            return f\"{o.__module__}.{o.__qualname__}\"\n+        if hasattr(o, \"__name__\"):\n+            return f\"{o.__module__}.{o.__name__}\"",
      "comment": "Let\u2019s just always use qualname. In cases where this matters (when the string is loaded back by `import_string`), `__name__` would not work anyway.",
      "comment_id": 2667841596,
      "user": "uranusjr",
      "created_at": "2026-01-07T10:14:27Z",
      "url": "https://github.com/apache/airflow/pull/60065#discussion_r2667841596"
    },
    {
      "repo": "apache/airflow",
      "pr_number": 60065,
      "file_path": "shared/module_loading/src/airflow_shared/module_loading/__init__.py",
      "line": 72,
      "side": "RIGHT",
      "diff_hunk": "@@ -63,10 +63,13 @@ def import_string(dotted_path: str):\n         raise ImportError(f'Module \"{module_path}\" does not define a \"{class_name}\" attribute/class')\n \n \n-def qualname(o: object | Callable) -> str:\n-    \"\"\"Convert an attribute/class/function to a string importable by ``import_string``.\"\"\"\n-    if callable(o) and hasattr(o, \"__module__\") and hasattr(o, \"__name__\"):\n-        return f\"{o.__module__}.{o.__name__}\"\n+def qualname(o: object | Callable, use_qualname: bool = False) -> str:\n+    \"\"\"Convert an attribute/class/callable to a string importable by ``import_string``.\"\"\"\n+    if callable(o) and hasattr(o, \"__module__\"):\n+        if use_qualname and hasattr(o, \"__qualname__\"):\n+            return f\"{o.__module__}.{o.__qualname__}\"\n+        if hasattr(o, \"__name__\"):\n+            return f\"{o.__module__}.{o.__name__}\"",
      "comment": "I guess - we can change it separately ? This one is already overloaded?",
      "comment_id": 2668787163,
      "user": "potiuk",
      "created_at": "2026-01-07T14:54:37Z",
      "url": "https://github.com/apache/airflow/pull/60065#discussion_r2668787163"
    },
    {
      "repo": "apache/airflow",
      "pr_number": 59973,
      "file_path": "airflow-core/tests/unit/models/test_log.py",
      "line": 35,
      "side": "RIGHT",
      "diff_hunk": "@@ -0,0 +1,90 @@\n+#\n+# Licensed to the Apache Software Foundation (ASF) under one\n+# or more contributor license agreements.  See the NOTICE file\n+# distributed with this work for additional information\n+# regarding copyright ownership.  The ASF licenses this file\n+# to you under the Apache License, Version 2.0 (the\n+# \"License\"); you may not use this file except in compliance\n+# with the License.  You may obtain a copy of the License at\n+#\n+#   http://www.apache.org/licenses/LICENSE-2.0\n+#\n+# Unless required by applicable law or agreed to in writing,\n+# software distributed under the License is distributed on an\n+# \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+# KIND, either express or implied.  See the License for the\n+# specific language governing permissions and limitations\n+# under the License.\n+\n+import pytest\n+from airflow.models.log import Log\n+from airflow.operators.empty import EmptyOperator\n+from airflow.utils.state import TaskInstanceState\n+\n+\n+pytestmark = pytest.mark.db_test\n+\n+\n+class TestLogTaskInstanceJoin:\n+    \"\"\"Test that Log.task_instance relationship uses correct join condition.\"\"\"\n+\n+    def test_log_task_instance_join_with_same_task_id_different_dags(self, dag_maker, session):\n+        \"\"\"Test that the join condition correctly handles same task_id in different DAGs.\"\"\"\n+        # Create dag_1 with a task\n+        with dag_maker(\"dag_1\", session=session):\n+            task1 = EmptyOperator(task_id=\"common_task_id\")",
      "comment": "Since `task1` isn't used, we can just call the operator directly without assigning it.",
      "comment_id": 2656801120,
      "user": "henry3260",
      "created_at": "2026-01-02T04:07:37Z",
      "url": "https://github.com/apache/airflow/pull/59973#discussion_r2656801120"
    },
    {
      "repo": "apache/airflow",
      "pr_number": 59973,
      "file_path": "airflow-core/tests/unit/models/test_log.py",
      "line": 42,
      "side": "RIGHT",
      "diff_hunk": "@@ -0,0 +1,66 @@\n+from __future__ import annotations\n+\n+import pytest\n+\n+from airflow.models.log import Log\n+from airflow.operators.empty import EmptyOperator\n+from airflow.utils.state import TaskInstanceState\n+\n+pytestmark = pytest.mark.db_test\n+\n+class TestLogTaskInstanceReproduction:\n+    def test_log_task_instance_join_correctness(self, dag_maker, session):\n+        # Create dag_1 with a task\n+        with dag_maker(\"dag_1\", session=session):\n+            EmptyOperator(task_id=\"common_task_id\")\n+\n+        dr1 = dag_maker.create_dagrun()\n+        ti1 = dr1.get_task_instance(\"common_task_id\")\n+        ti1.state = TaskInstanceState.SUCCESS\n+        session.merge(ti1)\n+        session.commit()\n+\n+        # Create dag_2 with the SAME task_id\n+        with dag_maker(\"dag_2\", session=session):\n+            EmptyOperator(task_id=\"common_task_id\")\n+\n+        dr2 = dag_maker.create_dagrun()\n+        ti2 = dr2.get_task_instance(\"common_task_id\")\n+        ti2.state = TaskInstanceState.FAILED\n+        session.merge(ti2)\n+        session.commit()\n+\n+        # Create a log entry specifically for dag_1's task instance\n+        log = Log(\n+            event=\"test_event\",\n+            task_instance=ti1,\n+        )\n+        session.add(log)\n+        session.commit()\n+\n+        # Query with joinedload to trigger the relationship join\n+        from sqlalchemy import select",
      "comment": "Why do we need to import them here? Should we move them to the top?",
      "comment_id": 2660867164,
      "user": "Lee-W",
      "created_at": "2026-01-05T09:38:37Z",
      "url": "https://github.com/apache/airflow/pull/59973#discussion_r2660867164"
    },
    {
      "repo": "apache/airflow",
      "pr_number": 59973,
      "file_path": "airflow-core/src/airflow/models/log.py",
      "line": 23,
      "side": "RIGHT",
      "diff_hunk": "@@ -20,14 +20,15 @@\n from datetime import datetime\n from typing import TYPE_CHECKING\n \n-from sqlalchemy import Index, Integer, String, Text\n+from sqlalchemy import Index, Integer, String, Text, and_  # noqa: F401",
      "comment": "```suggestion\nfrom sqlalchemy import Index, Integer, String, Text\n```",
      "comment_id": 2666972628,
      "user": "jason810496",
      "created_at": "2026-01-07T03:48:14Z",
      "url": "https://github.com/apache/airflow/pull/59973#discussion_r2666972628"
    },
    {
      "repo": "apache/airflow",
      "pr_number": 59712,
      "file_path": "airflow-core/src/airflow/api_fastapi/execution_api/routes/task_instances.py",
      "line": 886,
      "side": "RIGHT",
      "diff_hunk": "@@ -876,6 +877,61 @@ def get_task_instance_count(\n     return count or 0\n \n \n+@router.get(\"/previous/{dag_id}/{task_id}\", status_code=status.HTTP_200_OK)\n+def get_previous_task_instance(\n+    dag_id: str,\n+    task_id: str,\n+    session: SessionDep,\n+    logical_date: Annotated[UtcDateTime | None, Query()] = None,\n+    run_id: Annotated[str | None, Query()] = None,",
      "comment": "A general critique to this feature (which is carried over from Airflow 2) rather than the PR\u2026 why is a `run_id` filter useful? If you know the run ID, why not just get that particular task instance directly?",
      "comment_id": 2641941836,
      "user": "uranusjr",
      "created_at": "2025-12-23T05:05:55Z",
      "url": "https://github.com/apache/airflow/pull/59712#discussion_r2641941836"
    },
    {
      "repo": "apache/airflow",
      "pr_number": 59712,
      "file_path": "airflow-core/src/airflow/api_fastapi/execution_api/routes/task_instances.py",
      "line": 900,
      "side": "RIGHT",
      "diff_hunk": "@@ -876,6 +877,61 @@ def get_task_instance_count(\n     return count or 0\n \n \n+@router.get(\"/previous/{dag_id}/{task_id}\", status_code=status.HTTP_200_OK)\n+def get_previous_task_instance(\n+    dag_id: str,\n+    task_id: str,\n+    session: SessionDep,\n+    logical_date: Annotated[UtcDateTime | None, Query()] = None,\n+    run_id: Annotated[str | None, Query()] = None,\n+    state: Annotated[TaskInstanceState | None, Query()] = None,\n+) -> PreviousTIResponse | None:\n+    \"\"\"\n+    Get the previous task instance matching the given criteria.\n+\n+    :param dag_id: DAG ID (from path)\n+    :param task_id: Task ID (from path)\n+    :param logical_date: If provided, finds TI with logical_date < this value (before filter)\n+    :param run_id: If provided, filters by run_id\n+    :param state: If provided, filters by TaskInstance state\n+    \"\"\"\n+    query = (\n+        select(TI)\n+        .join(DR, (TI.dag_id == DR.dag_id) & (TI.run_id == DR.run_id))\n+        .options(joinedload(TI.dag_run))\n+        .where(TI.dag_id == dag_id, TI.task_id == task_id)\n+        .order_by(DR.logical_date.desc())\n+    )",
      "comment": "This wouldn\u2019t work very well with dynamic task mapping. I wonder if this API should return multiple tis instead.",
      "comment_id": 2641943847,
      "user": "uranusjr",
      "created_at": "2025-12-23T05:07:32Z",
      "url": "https://github.com/apache/airflow/pull/59712#discussion_r2641943847"
    },
    {
      "repo": "apache/airflow",
      "pr_number": 59712,
      "file_path": "airflow-core/src/airflow/api_fastapi/execution_api/routes/task_instances.py",
      "line": 900,
      "side": "RIGHT",
      "diff_hunk": "@@ -876,6 +877,61 @@ def get_task_instance_count(\n     return count or 0\n \n \n+@router.get(\"/previous/{dag_id}/{task_id}\", status_code=status.HTTP_200_OK)\n+def get_previous_task_instance(\n+    dag_id: str,\n+    task_id: str,\n+    session: SessionDep,\n+    logical_date: Annotated[UtcDateTime | None, Query()] = None,\n+    run_id: Annotated[str | None, Query()] = None,\n+    state: Annotated[TaskInstanceState | None, Query()] = None,\n+) -> PreviousTIResponse | None:\n+    \"\"\"\n+    Get the previous task instance matching the given criteria.\n+\n+    :param dag_id: DAG ID (from path)\n+    :param task_id: Task ID (from path)\n+    :param logical_date: If provided, finds TI with logical_date < this value (before filter)\n+    :param run_id: If provided, filters by run_id\n+    :param state: If provided, filters by TaskInstance state\n+    \"\"\"\n+    query = (\n+        select(TI)\n+        .join(DR, (TI.dag_id == DR.dag_id) & (TI.run_id == DR.run_id))\n+        .options(joinedload(TI.dag_run))\n+        .where(TI.dag_id == dag_id, TI.task_id == task_id)\n+        .order_by(DR.logical_date.desc())\n+    )",
      "comment": "Good point, didn't consider mapped task. Will update",
      "comment_id": 2643190580,
      "user": "kaxil",
      "created_at": "2025-12-23T13:28:19Z",
      "url": "https://github.com/apache/airflow/pull/59712#discussion_r2643190580"
    },
    {
      "repo": "apache/airflow",
      "pr_number": 59712,
      "file_path": "airflow-core/src/airflow/api_fastapi/execution_api/routes/task_instances.py",
      "line": 900,
      "side": "RIGHT",
      "diff_hunk": "@@ -876,6 +877,61 @@ def get_task_instance_count(\n     return count or 0\n \n \n+@router.get(\"/previous/{dag_id}/{task_id}\", status_code=status.HTTP_200_OK)\n+def get_previous_task_instance(\n+    dag_id: str,\n+    task_id: str,\n+    session: SessionDep,\n+    logical_date: Annotated[UtcDateTime | None, Query()] = None,\n+    run_id: Annotated[str | None, Query()] = None,\n+    state: Annotated[TaskInstanceState | None, Query()] = None,\n+) -> PreviousTIResponse | None:\n+    \"\"\"\n+    Get the previous task instance matching the given criteria.\n+\n+    :param dag_id: DAG ID (from path)\n+    :param task_id: Task ID (from path)\n+    :param logical_date: If provided, finds TI with logical_date < this value (before filter)\n+    :param run_id: If provided, filters by run_id\n+    :param state: If provided, filters by TaskInstance state\n+    \"\"\"\n+    query = (\n+        select(TI)\n+        .join(DR, (TI.dag_id == DR.dag_id) & (TI.run_id == DR.run_id))\n+        .options(joinedload(TI.dag_run))\n+        .where(TI.dag_id == dag_id, TI.task_id == task_id)\n+        .order_by(DR.logical_date.desc())\n+    )",
      "comment": "Updated in https://github.com/apache/airflow/pull/59712/commits/c8b5258c972730071486eb76590bec3d1448d3ea",
      "comment_id": 2643204438,
      "user": "kaxil",
      "created_at": "2025-12-23T13:33:52Z",
      "url": "https://github.com/apache/airflow/pull/59712#discussion_r2643204438"
    },
    {
      "repo": "apache/airflow",
      "pr_number": 59712,
      "file_path": "airflow-core/src/airflow/api_fastapi/execution_api/routes/task_instances.py",
      "line": 886,
      "side": "RIGHT",
      "diff_hunk": "@@ -876,6 +877,61 @@ def get_task_instance_count(\n     return count or 0\n \n \n+@router.get(\"/previous/{dag_id}/{task_id}\", status_code=status.HTTP_200_OK)\n+def get_previous_task_instance(\n+    dag_id: str,\n+    task_id: str,\n+    session: SessionDep,\n+    logical_date: Annotated[UtcDateTime | None, Query()] = None,\n+    run_id: Annotated[str | None, Query()] = None,",
      "comment": "Updated in https://github.com/apache/airflow/pull/59712/commits/c8b5258c972730071486eb76590bec3d1448d3ea",
      "comment_id": 2643204584,
      "user": "kaxil",
      "created_at": "2025-12-23T13:33:57Z",
      "url": "https://github.com/apache/airflow/pull/59712#discussion_r2643204584"
    },
    {
      "repo": "apache/airflow",
      "pr_number": 60062,
      "file_path": "providers/apache/impala/src/airflow/providers/apache/impala/hooks/impala.py",
      "line": 30,
      "side": "RIGHT",
      "diff_hunk": "@@ -19,14 +19,26 @@\n from typing import TYPE_CHECKING\n \n from impala.dbapi import connect\n-from sqlalchemy.engine import URL\n \n+from airflow.exceptions import AirflowOptionalProviderFeatureException\n from airflow.providers.common.sql.hooks.sql import DbApiHook\n \n if TYPE_CHECKING:\n     from impala.interface import Connection\n \n \n+def _get_sqlalchemy_url_class():",
      "comment": "Type hinting is needed here as well (See the other PRs) ",
      "comment_id": 2659686489,
      "user": "potiuk",
      "created_at": "2026-01-04T13:58:29Z",
      "url": "https://github.com/apache/airflow/pull/60062#discussion_r2659686489"
    },
    {
      "repo": "apache/airflow",
      "pr_number": 60062,
      "file_path": "providers/apache/impala/src/airflow/providers/apache/impala/hooks/impala.py",
      "line": 30,
      "side": "RIGHT",
      "diff_hunk": "@@ -19,14 +19,26 @@\n from typing import TYPE_CHECKING\n \n from impala.dbapi import connect\n-from sqlalchemy.engine import URL\n \n+from airflow.exceptions import AirflowOptionalProviderFeatureException\n from airflow.providers.common.sql.hooks.sql import DbApiHook\n \n if TYPE_CHECKING:\n     from impala.interface import Connection\n \n \n+def _get_sqlalchemy_url_class():",
      "comment": "Thanks for the review! I've added the return type hint `-> Type[\"URL\"]` to `_get_sqlalchemy_url_class` as suggested.",
      "comment_id": 2660059468,
      "user": "hohshho",
      "created_at": "2026-01-05T00:57:07Z",
      "url": "https://github.com/apache/airflow/pull/60062#discussion_r2660059468"
    },
    {
      "repo": "apache/airflow",
      "pr_number": 60062,
      "file_path": "providers/apache/impala/src/airflow/providers/apache/impala/hooks/impala.py",
      "line": 31,
      "side": "RIGHT",
      "diff_hunk": "@@ -16,15 +16,28 @@\n # under the License.\n from __future__ import annotations\n \n-from typing import TYPE_CHECKING\n+from typing import TYPE_CHECKING, Type\n \n from impala.dbapi import connect\n-from sqlalchemy.engine import URL\n \n+from airflow.exceptions import AirflowOptionalProviderFeatureException\n from airflow.providers.common.sql.hooks.sql import DbApiHook\n \n if TYPE_CHECKING:\n     from impala.interface import Connection\n+    from sqlalchemy.engine import URL\n+\n+\n+def _get_sqlalchemy_url_class() -> Type[\"URL\"]:",
      "comment": "One nit: can we inline this function? I think it's a bit excessive to have it as a separate function",
      "comment_id": 2661348820,
      "user": "potiuk",
      "created_at": "2026-01-05T12:33:42Z",
      "url": "https://github.com/apache/airflow/pull/60062#discussion_r2661348820"
    },
    {
      "repo": "apache/airflow",
      "pr_number": 60062,
      "file_path": "providers/apache/impala/src/airflow/providers/apache/impala/hooks/impala.py",
      "line": 31,
      "side": "RIGHT",
      "diff_hunk": "@@ -16,15 +16,28 @@\n # under the License.\n from __future__ import annotations\n \n-from typing import TYPE_CHECKING\n+from typing import TYPE_CHECKING, Type\n \n from impala.dbapi import connect\n-from sqlalchemy.engine import URL\n \n+from airflow.exceptions import AirflowOptionalProviderFeatureException\n from airflow.providers.common.sql.hooks.sql import DbApiHook\n \n if TYPE_CHECKING:\n     from impala.interface import Connection\n+    from sqlalchemy.engine import URL\n+\n+\n+def _get_sqlalchemy_url_class() -> Type[\"URL\"]:",
      "comment": "Thanks!\r\n- Inlined the import logic as suggested.\r\n- Updated `pyproject.toml` to ensure CI tests run correctly.",
      "comment_id": 2664636605,
      "user": "hohshho",
      "created_at": "2026-01-06T11:36:04Z",
      "url": "https://github.com/apache/airflow/pull/60062#discussion_r2664636605"
    },
    {
      "repo": "apache/airflow",
      "pr_number": 59084,
      "file_path": "providers/git/src/airflow/providers/git/bundles/git.py",
      "line": 96,
      "side": "RIGHT",
      "diff_hunk": "@@ -91,7 +91,9 @@ def __init__(\n         try:\n             self.hook = GitHook(git_conn_id=git_conn_id or \"git_default\", repo_url=self.repo_url)\n         except Exception as e:\n-            self._log.warning(\"Could not create GitHook\", conn_id=git_conn_id, exc=e)\n+            self._log.exception(\"Could not create GitHook\", conn_id=git_conn_id, exc=e)\n+            # re raise so exception propagates immediately with clear error message\n+            raise",
      "comment": "do we need to log the exception given that it will raise anyway?  probably not i'd think",
      "comment_id": 2593338620,
      "user": "dstandish",
      "created_at": "2025-12-05T16:54:34Z",
      "url": "https://github.com/apache/airflow/pull/59084#discussion_r2593338620"
    },
    {
      "repo": "apache/airflow",
      "pr_number": 60112,
      "file_path": "airflow-core/src/airflow/api_fastapi/core_api/routes/public/dag_run.py",
      "line": 420,
      "side": "RIGHT",
      "diff_hunk": "@@ -372,45 +372,52 @@\n \n     This endpoint allows specifying `~` as the dag_id to retrieve Dag Runs for all DAGs.\n     \"\"\"\n-    query = select(DagRun).options(*eager_load_dag_run_for_validation())\n+    try:\n+        query = select(DagRun).options(*eager_load_dag_run_for_validation())\n+\n+        if dag_id != \"~\":\n+            get_latest_version_of_dag(dag_bag, dag_id, session)  # Check if the DAG exists.\n+            query = query.filter(DagRun.dag_id == dag_id).options()\n+\n+        # Add join with DagVersion if dag_version filter is active\n+        if dag_version.value:\n+            query = query.join(DagVersion, DagRun.created_dag_version_id == DagVersion.id)\n+\n+        dag_run_select, total_entries = paginated_select(\n+            statement=query,\n+            filters=[\n+                run_after,\n+                logical_date,\n+                start_date_range,\n+                end_date_range,\n+                update_at_range,\n+                duration_range,\n+                conf_contains,\n+                state,\n+                run_type,\n+                dag_version,\n+                readable_dag_runs_filter,\n+                run_id_pattern,\n+                triggering_user_name_pattern,\n+                dag_id_pattern,\n+            ],\n+            order_by=order_by,\n+            offset=offset,\n+            limit=limit,\n+            session=session,\n+        )\n+        dag_runs = session.scalars(dag_run_select)\n \n-    if dag_id != \"~\":\n-        get_latest_version_of_dag(dag_bag, dag_id, session)  # Check if the DAG exists.\n-        query = query.filter(DagRun.dag_id == dag_id).options()\n+        return DAGRunCollectionResponse(\n+            dag_runs=dag_runs,\n+            total_entries=total_entries,\n+        )\n+    except Exception:\n+        import traceback\n \n-    # Add join with DagVersion if dag_version filter is active\n-    if dag_version.value:\n-        query = query.join(DagVersion, DagRun.created_dag_version_id == DagVersion.id)\n+        from fastapi.responses import Response\n \n-    dag_run_select, total_entries = paginated_select(\n-        statement=query,\n-        filters=[\n-            run_after,\n-            logical_date,\n-            start_date_range,\n-            end_date_range,\n-            update_at_range,\n-            duration_range,\n-            conf_contains,\n-            state,\n-            run_type,\n-            dag_version,\n-            readable_dag_runs_filter,\n-            run_id_pattern,\n-            triggering_user_name_pattern,\n-            dag_id_pattern,\n-        ],\n-        order_by=order_by,\n-        offset=offset,\n-        limit=limit,\n-        session=session,\n-    )\n-    dag_runs = session.scalars(dag_run_select)\n-\n-    return DAGRunCollectionResponse(\n-        dag_runs=dag_runs,\n-        total_entries=total_entries,\n-    )\n+        return Response(status_code=500, content=traceback.format_exc())",
      "comment": "## Information exposure through an exception\n\n[Stack trace information](1) flows to this location and may be exposed to an external user.\n\n[Show more details](https://github.com/apache/airflow/security/code-scanning/562)",
      "comment_id": 2663756695,
      "user": "github-advanced-security[bot]",
      "created_at": "2026-01-06T06:10:07Z",
      "url": "https://github.com/apache/airflow/pull/60112#discussion_r2663756695"
    },
    {
      "repo": "apache/airflow",
      "pr_number": 59805,
      "file_path": "airflow-core/src/airflow/cli/cli_parser.py",
      "line": 63,
      "side": "LEFT",
      "diff_hunk": "@@ -60,30 +59,21 @@\n log = logging.getLogger(__name__)\n \n \n-for executor_name in ExecutorLoader.get_executor_names(validate_teams=False):",
      "comment": "I think we need to add a fallback reading of CLIs in old ways - not sure how to do it without impacting performance too much, because we do not want to **always** load executor class. \n\nThis is important for two reasons:\n\n1) someone want to stay with old \"community\" provider version but use newer airflow\n2) someone has their own executor in their 3rd-party provider with CLIs defined\n\nPossibly one way of doing it is simple mapping of the executors -> provider  (for built-in executors we have mapping from the executor to provider package and checking if the provider has \"cli\" defined in provider info? Also likely we should raise an error if provider has an executor defined with cli commands AND cli command defined in provider info.",
      "comment_id": 2649692458,
      "user": "potiuk",
      "created_at": "2025-12-28T13:07:02Z",
      "url": "https://github.com/apache/airflow/pull/59805#discussion_r2649692458"
    },
    {
      "repo": "apache/airflow",
      "pr_number": 59805,
      "file_path": "airflow-core/src/airflow/cli/cli_parser.py",
      "line": 63,
      "side": "LEFT",
      "diff_hunk": "@@ -60,30 +59,21 @@\n log = logging.getLogger(__name__)\n \n \n-for executor_name in ExecutorLoader.get_executor_names(validate_teams=False):",
      "comment": "Good point!\r\n\r\n> Possibly one way of doing it is simple mapping of the executors -> provider (for built-in executors we have mapping from the executor to provider package and checking if the provider has \"cli\" defined in provider info? Also likely we should raise an error if provider has an executor defined with cli commands AND cli command defined in provider info.\r\n\r\nYes, that is the exact same idea for me. It could be done in ProviderManager, and I will add the same validation for AuthManager as well.",
      "comment_id": 2649708589,
      "user": "jason810496",
      "created_at": "2025-12-28T13:38:26Z",
      "url": "https://github.com/apache/airflow/pull/59805#discussion_r2649708589"
    },
    {
      "repo": "apache/airflow",
      "pr_number": 59805,
      "file_path": "providers/amazon/src/airflow/providers/amazon/aws/auth_manager/cli/__init__.py",
      "line": 17,
      "side": "RIGHT",
      "diff_hunk": "@@ -14,3 +14,4 @@\n # KIND, either express or implied.  See the License for the\n # specific language governing permissions and limitations\n # under the License.\n+from __future__ import annotations",
      "comment": "Good catch! It's no need at all, I added them by accident.",
      "comment_id": 2662062732,
      "user": "jason810496",
      "created_at": "2026-01-05T16:19:53Z",
      "url": "https://github.com/apache/airflow/pull/59805#discussion_r2662062732"
    },
    {
      "repo": "apache/airflow",
      "pr_number": 59805,
      "file_path": "providers/keycloak/src/airflow/providers/keycloak/auth_manager/cli/__init__.py",
      "line": 17,
      "side": "RIGHT",
      "diff_hunk": "@@ -14,3 +14,4 @@\n # KIND, either express or implied.  See the License for the\n # specific language governing permissions and limitations\n # under the License.\n+from __future__ import annotations",
      "comment": "I think this is also no needed here?\n```suggestion\n```",
      "comment_id": 2662596384,
      "user": "jscheffl",
      "created_at": "2026-01-05T19:38:09Z",
      "url": "https://github.com/apache/airflow/pull/59805#discussion_r2662596384"
    },
    {
      "repo": "apache/airflow",
      "pr_number": 59062,
      "file_path": "airflow-core/src/airflow/secrets/local_filesystem.py",
      "line": 290,
      "side": "RIGHT",
      "diff_hunk": "@@ -278,6 +278,26 @@ def load_connections_dict(file_path: str) -> dict[str, Any]:\n     return connection_by_conn_id\n \n \n+def load_configs_dict(file_path: str) -> dict[str, str]:\n+    \"\"\"\n+    Load configs from a text file.\n+\n+    ``JSON``, `YAML` and ``.env`` files are supported.\n+\n+    :param file_path: The location of the file that will be processed.\n+    :return: A dictionary where the key contains a config name and the value contains the config value.\n+    \"\"\"\n+    log.debug(\"Loading configs from a text file\")",
      "comment": "nit: logging can be including the filename\n```suggestion\n    log.debug(\"Loading configs from text file %s\", file_path)\n```",
      "comment_id": 2595220368,
      "user": "jscheffl",
      "created_at": "2025-12-06T18:06:06Z",
      "url": "https://github.com/apache/airflow/pull/59062#discussion_r2595220368"
    },
    {
      "repo": "apache/airflow",
      "pr_number": 59062,
      "file_path": "airflow-core/src/airflow/secrets/local_filesystem.py",
      "line": 339,
      "side": "RIGHT",
      "diff_hunk": "@@ -310,10 +336,21 @@ def _local_connections(self) -> dict[str, Connection]:\n             return {}\n         return load_connections_dict(self.connections_file)\n \n+    @property",
      "comment": "As every call might re-load the file, does it maybe make sense making this a `@cached_property`?",
      "comment_id": 2595221051,
      "user": "jscheffl",
      "created_at": "2025-12-06T18:07:31Z",
      "url": "https://github.com/apache/airflow/pull/59062#discussion_r2595221051"
    },
    {
      "repo": "apache/airflow",
      "pr_number": 59062,
      "file_path": "airflow-core/src/airflow/secrets/local_filesystem.py",
      "line": 339,
      "side": "RIGHT",
      "diff_hunk": "@@ -310,10 +336,21 @@ def _local_connections(self) -> dict[str, Connection]:\n             return {}\n         return load_connections_dict(self.connections_file)\n \n+    @property",
      "comment": "I implemented the feature by copying exactly what was already available for connections and variables. So maybe if we add it here, we should also add it there. Since I'm not an expert, let's see what de CODEOWNERS say!",
      "comment_id": 2596195334,
      "user": "ecodina",
      "created_at": "2025-12-07T09:45:20Z",
      "url": "https://github.com/apache/airflow/pull/59062#discussion_r2596195334"
    },
    {
      "repo": "apache/airflow",
      "pr_number": 59062,
      "file_path": "airflow-core/src/airflow/secrets/local_filesystem.py",
      "line": 339,
      "side": "RIGHT",
      "diff_hunk": "@@ -310,10 +336,21 @@ def _local_connections(self) -> dict[str, Connection]:\n             return {}\n         return load_connections_dict(self.connections_file)\n \n+    @property",
      "comment": "Ah, okay, did not see this, then it is OK like it is.",
      "comment_id": 2596435081,
      "user": "jscheffl",
      "created_at": "2025-12-07T16:41:25Z",
      "url": "https://github.com/apache/airflow/pull/59062#discussion_r2596435081"
    },
    {
      "repo": "apache/airflow",
      "pr_number": 59411,
      "file_path": "providers/keycloak/src/airflow/providers/keycloak/auth_manager/keycloak_auth_manager.py",
      "line": 329,
      "side": "RIGHT",
      "diff_hunk": "@@ -310,9 +317,22 @@ def get_cli_commands() -> list[CLICommand]:\n         ]\n \n     @staticmethod\n-    def get_keycloak_client() -> KeycloakOpenID:\n-        client_id = conf.get(CONF_SECTION_NAME, CONF_CLIENT_ID_KEY)\n-        client_secret = conf.get(CONF_SECTION_NAME, CONF_CLIENT_SECRET_KEY)\n+    def get_keycloak_client(client_id: str | None = None, client_secret: str | None = None) -> KeycloakOpenID:\n+        \"\"\"\n+        Get a KeycloakOpenID client instance.\n+\n+        :param client_id: Optional client ID to override config. If provided, client_secret must also be provided.\n+        :param client_secret: Optional client secret to override config. If provided, client_id must also be provided.\n+        \"\"\"\n+        if (client_id is None) != (client_secret is None):\n+            raise ValueError(\n+                \"Both client_id and client_secret must be provided together, or both must be None\"",
      "comment": "```suggestion\r\n                \"Both `client_id` and `client_secret` must be provided together, or both must be None\"\r\n```",
      "comment_id": 2620089188,
      "user": "vincbeck",
      "created_at": "2025-12-15T16:34:18Z",
      "url": "https://github.com/apache/airflow/pull/59411#discussion_r2620089188"
    },
    {
      "repo": "apache/airflow",
      "pr_number": 59411,
      "file_path": "providers/keycloak/src/airflow/providers/keycloak/auth_manager/services/token.py",
      "line": 56,
      "side": "RIGHT",
      "diff_hunk": "@@ -51,3 +51,47 @@ def create_token_for(\n     )\n \n     return get_auth_manager().generate_jwt(user, expiration_time_in_seconds=expiration_time_in_seconds)\n+\n+\n+def create_token_for_client_credentials(",
      "comment": "Reads better (to me)\r\n\r\n```suggestion\r\ndef create_client_credentials_token(\r\n```",
      "comment_id": 2620096303,
      "user": "vincbeck",
      "created_at": "2025-12-15T16:36:09Z",
      "url": "https://github.com/apache/airflow/pull/59411#discussion_r2620096303"
    },
    {
      "repo": "apache/airflow",
      "pr_number": 59411,
      "file_path": "providers/keycloak/src/airflow/providers/keycloak/auth_manager/services/token.py",
      "line": 92,
      "side": "RIGHT",
      "diff_hunk": "@@ -51,3 +51,47 @@ def create_token_for(\n     )\n \n     return get_auth_manager().generate_jwt(user, expiration_time_in_seconds=expiration_time_in_seconds)\n+\n+\n+def create_token_for_client_credentials(\n+    client_id: str,\n+    client_secret: str,\n+    expiration_time_in_seconds: int = conf.getint(\"api_auth\", \"jwt_expiration_time\"),\n+) -> str:\n+    \"\"\"\n+    Create token using OAuth2 client_credentials grant type.\n+\n+    This authentication flow uses the provided client_id and client_secret\n+    to obtain a token for a service account. The Keycloak client must have:\n+    - Service accounts roles: ON\n+    - Client Authentication: ON (confidential client)\n+\n+    The service account must be configured with the appropriate roles/permissions.\n+    \"\"\"\n+    # Get Keycloak client with service account credentials\n+    client = KeycloakAuthManager.get_keycloak_client(\n+        client_id=client_id,\n+        client_secret=client_secret,\n+    )\n+\n+    try:\n+        tokens = client.token(grant_type=\"client_credentials\")\n+    except KeycloakAuthenticationError:\n+        raise HTTPException(\n+            status_code=status.HTTP_401_UNAUTHORIZED,\n+            detail=\"Client credentials authentication failed\",\n+        )\n+\n+    # For client_credentials, get the service account user info\n+    # The token represents the service account associated with the client\n+    userinfo = client.userinfo(tokens[\"access_token\"])\n+    user = KeycloakAuthManagerUser(\n+        user_id=userinfo[\"sub\"],\n+        name=userinfo.get(\"preferred_username\", userinfo.get(\"clientId\", \"service-account\")),\n+        access_token=tokens[\"access_token\"],\n+        refresh_token=tokens.get(",
      "comment": "Instead of having an empty string, I rather update `KeycloakAuthManagerUser` and update the type of `refresh_token` to be `str | None`. ",
      "comment_id": 2620105726,
      "user": "vincbeck",
      "created_at": "2025-12-15T16:38:19Z",
      "url": "https://github.com/apache/airflow/pull/59411#discussion_r2620105726"
    },
    {
      "repo": "apache/airflow",
      "pr_number": 59411,
      "file_path": "providers/keycloak/src/airflow/providers/keycloak/auth_manager/routes/token.py",
      "line": 51,
      "side": "RIGHT",
      "diff_hunk": "@@ -36,8 +44,16 @@\n     status_code=status.HTTP_201_CREATED,\n     responses=create_openapi_http_exception_doc([status.HTTP_400_BAD_REQUEST, status.HTTP_401_UNAUTHORIZED]),\n )\n-def create_token(body: TokenBody) -> TokenResponse:\n-    token = create_token_for(body.username, body.password)\n+def create_token(\n+    body: TokenBody,\n+) -> TokenResponse:\n+    credentials = body.root\n+    if isinstance(credentials, TokenPasswordBody):",
      "comment": "Wouldn't it be more logical to have the create_token method also exists on the TokenBody class, and the default implementation raising the ValueError?  That way we just have to call that method within the create_token method here, which avoids need for if else statement with instanceof?",
      "comment_id": 2637792435,
      "user": "dabla",
      "created_at": "2025-12-21T12:31:31Z",
      "url": "https://github.com/apache/airflow/pull/59411#discussion_r2637792435"
    },
    {
      "repo": "apache/airflow",
      "pr_number": 59411,
      "file_path": "providers/keycloak/src/airflow/providers/keycloak/auth_manager/routes/token.py",
      "line": 51,
      "side": "RIGHT",
      "diff_hunk": "@@ -36,8 +44,16 @@\n     status_code=status.HTTP_201_CREATED,\n     responses=create_openapi_http_exception_doc([status.HTTP_400_BAD_REQUEST, status.HTTP_401_UNAUTHORIZED]),\n )\n-def create_token(body: TokenBody) -> TokenResponse:\n-    token = create_token_for(body.username, body.password)\n+def create_token(\n+    body: TokenBody,\n+) -> TokenResponse:\n+    credentials = body.root\n+    if isinstance(credentials, TokenPasswordBody):",
      "comment": "Then you could just do something like this:\r\n\r\n```\r\ndef create_token(\r\n    body: TokenBody,\r\n) -> TokenResponse:\r\n    token = body.create_token_for()  # if not supported, the default implementation will raise the ValueError, otherwise we get the token independently of the specialized TokenBody implementation.\r\n    return TokenResponse(access_token=token)\r\n```",
      "comment_id": 2637794325,
      "user": "dabla",
      "created_at": "2025-12-21T12:35:15Z",
      "url": "https://github.com/apache/airflow/pull/59411#discussion_r2637794325"
    },
    {
      "repo": "apache/airflow",
      "pr_number": 59411,
      "file_path": "providers/keycloak/src/airflow/providers/keycloak/auth_manager/datamodels/token.py",
      "line": 38,
      "side": "RIGHT",
      "diff_hunk": "@@ -28,8 +34,47 @@ class TokenResponse(BaseModel):\n     access_token: str\n \n \n-class TokenBody(StrictBaseModel):\n-    \"\"\"Token serializer for post bodies.\"\"\"\n+class TokenPasswordBody(StrictBaseModel):\n+    \"\"\"Password Grant Token serializer for post bodies.\"\"\"",
      "comment": "```suggestion\r\n    \"\"\"Password grant token serializer for post bodies.\"\"\"\r\n```",
      "comment_id": 2662283650,
      "user": "vincbeck",
      "created_at": "2026-01-05T17:32:55Z",
      "url": "https://github.com/apache/airflow/pull/59411#discussion_r2662283650"
    },
    {
      "repo": "apache/airflow",
      "pr_number": 59411,
      "file_path": "providers/keycloak/src/airflow/providers/keycloak/auth_manager/datamodels/token.py",
      "line": 52,
      "side": "RIGHT",
      "diff_hunk": "@@ -28,8 +34,47 @@ class TokenResponse(BaseModel):\n     access_token: str\n \n \n-class TokenBody(StrictBaseModel):\n-    \"\"\"Token serializer for post bodies.\"\"\"\n+class TokenPasswordBody(StrictBaseModel):\n+    \"\"\"Password Grant Token serializer for post bodies.\"\"\"\n \n+    grant_type: Literal[\"password\"] = \"password\"\n     username: str = Field()\n     password: str = Field()\n+\n+    def create_token(self, expiration_time_in_seconds: int) -> str:\n+        \"\"\"Create token using password grant.\"\"\"\n+        return create_token_for(\n+            self.username, self.password, expiration_time_in_seconds=expiration_time_in_seconds\n+        )\n+\n+\n+class TokenClientCredentialsBody(StrictBaseModel):\n+    \"\"\"Client Credentials Grant Token serializer for post bodies.\"\"\"",
      "comment": "```suggestion\r\n    \"\"\"Client credentials grant token serializer for post bodies.\"\"\"\r\n```",
      "comment_id": 2662285361,
      "user": "vincbeck",
      "created_at": "2026-01-05T17:33:32Z",
      "url": "https://github.com/apache/airflow/pull/59411#discussion_r2662285361"
    },
    {
      "repo": "apache/airflow",
      "pr_number": 59252,
      "file_path": "providers/keycloak/src/airflow/providers/keycloak/auth_manager/keycloak_auth_manager.py",
      "line": 114,
      "side": "RIGHT",
      "diff_hunk": "@@ -90,6 +94,25 @@ class KeycloakAuthManager(BaseAuthManager[KeycloakAuthManagerUser]):\n     Leverages Keycloak to perform authentication and authorization in Airflow.\n     \"\"\"\n \n+    def __init__(self):\n+        super().__init__()\n+        self.session = requests.Session()\n+\n+        pool_size = conf.getint(CONF_SECTION_NAME, CONF_REQUESTS_POOL_SIZE_KEY, fallback=10)\n+        retry_total = conf.getint(CONF_SECTION_NAME, CONF_REQUESTS_RETRIES_KEY, fallback=3)\n+\n+        retry_strategy = Retry(\n+            total=retry_total,\n+            backoff_factor=0.1,\n+            status_forcelist=[500, 502, 503, 504],\n+            allowed_methods=[\"HEAD\", \"GET\", \"OPTIONS\", \"POST\"],\n+        )\n+\n+        adapter = HTTPAdapter(pool_connections=pool_size, pool_maxsize=pool_size, max_retries=retry_strategy)\n+\n+        self.session.mount(\"https://\", adapter)\n+        self.session.mount(\"http://\", adapter)",
      "comment": "Can you do that in `init`? I rather avoid doing expensive operations in `__init__`",
      "comment_id": 2603845512,
      "user": "vincbeck",
      "created_at": "2025-12-09T18:32:12Z",
      "url": "https://github.com/apache/airflow/pull/59252#discussion_r2603845512"
    },
    {
      "repo": "apache/airflow",
      "pr_number": 59119,
      "file_path": "providers/keycloak/src/airflow/providers/keycloak/auth_manager/cli/definition.py",
      "line": 25,
      "side": "RIGHT",
      "diff_hunk": "@@ -22,6 +22,7 @@\n     Arg,\n     lazy_load_command,\n )\n+from airflow.providers.keycloak.version_compat import Password",
      "comment": "Do we really need compat here? \ud83e\udd14 Maybe we can directly import this from `airflow.cli.cli_config` as we assume airflow-core has been installed. This can eliminate the `version_compat` as well",
      "comment_id": 2596484263,
      "user": "bugraoz93",
      "created_at": "2025-12-07T18:03:08Z",
      "url": "https://github.com/apache/airflow/pull/59119#discussion_r2596484263"
    },
    {
      "repo": "apache/airflow",
      "pr_number": 59134,
      "file_path": "providers/keycloak/src/airflow/providers/keycloak/auth_manager/cli/commands.py",
      "line": 137,
      "side": "RIGHT",
      "diff_hunk": "@@ -112,41 +117,97 @@ def _get_client_uuid(args):\n     return matches[0][\"id\"]\n \n \n-def _create_scopes(client: KeycloakAdmin, client_uuid: str):\n+def _get_scopes_to_create() -> list[dict]:\n+    \"\"\"Get the list of scopes to be created.\"\"\"\n     scopes = [{\"name\": method} for method in get_args(ResourceMethod)]\n     scopes.extend([{\"name\": \"MENU\"}, {\"name\": \"LIST\"}])\n+    return scopes\n+\n+\n+def _preview_scopes(client: KeycloakAdmin, client_uuid: str, **kwargs):\n+    \"\"\"Preview scopes that would be created.\"\"\"\n+    scopes = _get_scopes_to_create()\n+    print(\"Scopes to be created:\")\n+    for scope in scopes:\n+        print(f\"  - {scope['name']}\")\n+    print()\n+\n+\n+@dry_run_preview(_preview_scopes)\n+def _create_scopes(client: KeycloakAdmin, client_uuid: str, **kwargs):",
      "comment": "I had it like this so mypy doesn't complain. The decorator \"eats\" the `dry_run` parameter so the function doesn't actually need it in the signature. To improve readability, I'll change it to:\r\n\r\n`def _create_scopes(client: KeycloakAdmin, client_uuid: str, *, _dry_run: bool = False)`",
      "comment_id": 2599703482,
      "user": "ecodina",
      "created_at": "2025-12-08T18:31:20Z",
      "url": "https://github.com/apache/airflow/pull/59134#discussion_r2599703482"
    },
    {
      "repo": "apache/airflow",
      "pr_number": 59134,
      "file_path": "providers/keycloak/src/airflow/providers/keycloak/auth_manager/cli/commands.py",
      "line": 127,
      "side": "RIGHT",
      "diff_hunk": "@@ -112,41 +117,97 @@ def _get_client_uuid(args):\n     return matches[0][\"id\"]\n \n \n-def _create_scopes(client: KeycloakAdmin, client_uuid: str):\n+def _get_scopes_to_create() -> list[dict]:\n+    \"\"\"Get the list of scopes to be created.\"\"\"\n     scopes = [{\"name\": method} for method in get_args(ResourceMethod)]\n     scopes.extend([{\"name\": \"MENU\"}, {\"name\": \"LIST\"}])\n+    return scopes\n+\n+\n+def _preview_scopes(client: KeycloakAdmin, client_uuid: str, **kwargs):",
      "comment": "Not in this case. However, since the method is run from the decorator, all of the `_preview_` methods must have arguments in the signature. I'll update it to \r\n\r\n`def _preview_scopes(*args, **kwargs)`",
      "comment_id": 2599709723,
      "user": "ecodina",
      "created_at": "2025-12-08T18:32:52Z",
      "url": "https://github.com/apache/airflow/pull/59134#discussion_r2599709723"
    },
    {
      "repo": "apache/airflow",
      "pr_number": 59956,
      "file_path": "shared/plugins_manager/src/airflow_shared/plugins_manager/plugins_manager.py",
      "line": 1,
      "side": "RIGHT",
      "diff_hunk": "@@ -0,0 +1,280 @@\n+#",
      "comment": "Maybe do it as I did with modules_loading and move all that to `__init__.py`  -  i found it much nicer as you would not have to repeat `plugins_manager` twice in imports.",
      "comment_id": 2655458265,
      "user": "potiuk",
      "created_at": "2025-12-31T14:11:39Z",
      "url": "https://github.com/apache/airflow/pull/59956#discussion_r2655458265"
    },
    {
      "repo": "apache/airflow",
      "pr_number": 59956,
      "file_path": "shared/plugins_manager/src/airflow_shared/plugins_manager/plugins_manager.py",
      "line": 268,
      "side": "RIGHT",
      "diff_hunk": "@@ -0,0 +1,280 @@\n+#\n+# Licensed to the Apache Software Foundation (ASF) under one\n+# or more contributor license agreements.  See the NOTICE file\n+# distributed with this work for additional information\n+# regarding copyright ownership.  The ASF licenses this file\n+# to you under the Apache License, Version 2.0 (the\n+# \"License\"); you may not use this file except in compliance\n+# with the License.  You may obtain a copy of the License at\n+#\n+#   http://www.apache.org/licenses/LICENSE-2.0\n+#\n+# Unless required by applicable law or agreed to in writing,\n+# software distributed under the License is distributed on an\n+# \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+# KIND, either express or implied.  See the License for the\n+# specific language governing permissions and limitations\n+# under the License.\n+\"\"\"Manages all plugins.\"\"\"\n+\n+from __future__ import annotations\n+\n+import inspect\n+import logging\n+import os\n+import sys\n+import types\n+from pathlib import Path\n+from typing import TYPE_CHECKING, Any\n+\n+# TODO: these should be moved into module_loading i think\n+from airflow.utils.entry_points import entry_points_with_dist\n+from airflow.utils.file import find_path_from_directory\n+\n+if TYPE_CHECKING:\n+    if sys.version_info >= (3, 12):\n+        from importlib import metadata\n+    else:\n+        import importlib_metadata as metadata\n+    from collections.abc import Generator\n+    from types import ModuleType\n+\n+    from airflow.listeners.listener import ListenerManager\n+\n+log = logging.getLogger(__name__)\n+\n+\n+class AirflowPluginSource:\n+    \"\"\"Class used to define an AirflowPluginSource.\"\"\"\n+\n+    def __str__(self):\n+        raise NotImplementedError\n+\n+    def __html__(self):\n+        raise NotImplementedError\n+\n+\n+class PluginsDirectorySource(AirflowPluginSource):\n+    \"\"\"Class used to define Plugins loaded from Plugins Directory.\"\"\"\n+\n+    def __init__(self, path, plugins_folder: str):\n+        self.path = os.path.relpath(path, plugins_folder)\n+\n+    def __str__(self):\n+        return f\"$PLUGINS_FOLDER/{self.path}\"\n+\n+    def __html__(self):\n+        return f\"<em>$PLUGINS_FOLDER/</em>{self.path}\"\n+\n+\n+class EntryPointSource(AirflowPluginSource):\n+    \"\"\"Class used to define Plugins loaded from entrypoint.\"\"\"\n+\n+    def __init__(self, entrypoint: metadata.EntryPoint, dist: metadata.Distribution):\n+        self.dist = dist.metadata[\"Name\"]  # type: ignore[index]\n+        self.version = dist.version\n+        self.entrypoint = str(entrypoint)\n+\n+    def __str__(self):\n+        return f\"{self.dist}=={self.version}: {self.entrypoint}\"\n+\n+    def __html__(self):\n+        return f\"<em>{self.dist}=={self.version}:</em> {self.entrypoint}\"\n+\n+\n+class AirflowPluginException(Exception):\n+    \"\"\"Exception when loading plugin.\"\"\"\n+\n+\n+class AirflowPlugin:\n+    \"\"\"Class used to define AirflowPlugin.\"\"\"\n+\n+    name: str | None = None\n+    source: AirflowPluginSource | None = None\n+    macros: list[Any] = []\n+    admin_views: list[Any] = []\n+    flask_blueprints: list[Any] = []\n+    fastapi_apps: list[Any] = []\n+    fastapi_root_middlewares: list[Any] = []\n+    external_views: list[Any] = []\n+    react_apps: list[Any] = []\n+    menu_links: list[Any] = []\n+    appbuilder_views: list[Any] = []\n+    appbuilder_menu_items: list[Any] = []\n+\n+    # A list of global operator extra links that can redirect users to\n+    # external systems. These extra links will be available on the\n+    # task page in the form of buttons.\n+    #\n+    # Note: the global operator extra link can be overridden at each\n+    # operator level.\n+    global_operator_extra_links: list[Any] = []\n+\n+    # A list of operator extra links to override or add operator links\n+    # to existing Airflow Operators.\n+    # These extra links will be available on the task page in form of\n+    # buttons.\n+    operator_extra_links: list[Any] = []\n+\n+    # A list of timetable classes that can be used for DAG scheduling.\n+    timetables: list[Any] = []\n+\n+    # A list of listeners that can be used for tracking task and DAG states.\n+    listeners: list[ModuleType | object] = []\n+\n+    # A list of hook lineage reader classes that can be used for reading lineage information from a hook.\n+    hook_lineage_readers: list[Any] = []\n+\n+    # A list of priority weight strategy classes that can be used for calculating tasks weight priority.\n+    priority_weight_strategies: list[Any] = []\n+\n+    @classmethod\n+    def validate(cls):\n+        \"\"\"Validate if plugin has a name.\"\"\"\n+        if not cls.name:\n+            raise AirflowPluginException(\"Your plugin needs a name.\")\n+\n+    @classmethod\n+    def on_load(cls, *args, **kwargs):\n+        \"\"\"\n+        Execute when the plugin is loaded; This method is only called once during runtime.\n+\n+        :param args: If future arguments are passed in on call.\n+        :param kwargs: If future arguments are passed in on call.\n+        \"\"\"\n+\n+\n+def is_valid_plugin(plugin_obj) -> bool:\n+    \"\"\"\n+    Check whether a potential object is a subclass of the AirflowPlugin class.\n+\n+    :param plugin_obj: potential subclass of AirflowPlugin\n+    :return: Whether or not the obj is a valid subclass of\n+        AirflowPlugin\n+    \"\"\"\n+    if (\n+        inspect.isclass(plugin_obj)\n+        and issubclass(plugin_obj, AirflowPlugin)\n+        and (plugin_obj is not AirflowPlugin)\n+    ):\n+        plugin_obj.validate()\n+        return True\n+    return False\n+\n+\n+def _load_entrypoint_plugins() -> tuple[list[AirflowPlugin], dict[str, str]]:\n+    \"\"\"\n+    Load and register plugins AirflowPlugin subclasses from the entrypoints.\n+\n+    The entry_point group should be 'airflow.plugins'.\n+    \"\"\"\n+    log.debug(\"Loading plugins from entrypoints\")\n+\n+    plugins: list[AirflowPlugin] = []\n+    import_errors: dict[str, str] = {}\n+    for entry_point, dist in entry_points_with_dist(\"airflow.plugins\"):\n+        log.debug(\"Importing entry_point plugin %s\", entry_point.name)\n+        try:\n+            plugin_class = entry_point.load()\n+            if not is_valid_plugin(plugin_class):\n+                continue\n+\n+            plugin_instance: AirflowPlugin = plugin_class()\n+            plugin_instance.source = EntryPointSource(entry_point, dist)\n+            plugins.append(plugin_instance)\n+        except Exception as e:\n+            log.exception(\"Failed to import plugin %s\", entry_point.name)\n+            import_errors[entry_point.module] = str(e)\n+    return plugins, import_errors\n+\n+\n+def _load_plugins_from_plugin_directory(\n+    plugins_folder: str,\n+    load_examples: bool = False,\n+    example_plugins_module: str | None = None,\n+) -> tuple[list[AirflowPlugin], dict[str, str]]:\n+    \"\"\"Load and register Airflow Plugins from plugins directory.\"\"\"\n+    if not plugins_folder:\n+        raise ValueError(\"Plugins folder is not set\")\n+    log.debug(\"Loading plugins from directory: %s\", plugins_folder)\n+    files = find_path_from_directory(plugins_folder, \".airflowignore\")\n+    plugin_search_locations: list[tuple[str, Generator[str, None, None]]] = [(\"\", files)]\n+\n+    if load_examples:\n+        log.debug(\"Note: Loading plugins from examples as well: %s\", plugins_folder)\n+        import importlib\n+\n+        example_plugins = importlib.import_module(example_plugins_module)\n+        example_plugins_folder = next(iter(example_plugins.__path__))\n+        example_files = find_path_from_directory(example_plugins_folder, \".airflowignore\")\n+        plugin_search_locations.append((example_plugins.__name__, example_files))\n+\n+    plugins: list[AirflowPlugin] = []\n+    import_errors: dict[str, str] = {}\n+    for module_prefix, plugin_files in plugin_search_locations:\n+        for file_path in plugin_files:\n+            path = Path(file_path)\n+            if not path.is_file() or path.suffix != \".py\":\n+                continue\n+            mod_name = f\"{module_prefix}.{path.stem}\" if module_prefix else path.stem\n+\n+            try:\n+                loader = importlib.machinery.SourceFileLoader(mod_name, file_path)\n+                spec = importlib.util.spec_from_loader(mod_name, loader)\n+                if not spec:\n+                    log.error(\"Could not load spec for module %s at %s\", mod_name, file_path)\n+                    continue\n+                mod = importlib.util.module_from_spec(spec)\n+                sys.modules[spec.name] = mod\n+                loader.exec_module(mod)\n+\n+                for mod_attr_value in (m for m in mod.__dict__.values() if is_valid_plugin(m)):\n+                    plugin_instance: AirflowPlugin = mod_attr_value()\n+                    plugin_instance.source = PluginsDirectorySource(file_path, plugins_folder)\n+                    plugins.append(plugin_instance)\n+            except Exception as e:\n+                log.exception(\"Failed to import plugin %s\", file_path)\n+                import_errors[file_path] = str(e)\n+    return plugins, import_errors\n+\n+\n+def make_module(name: str, objects: list[Any]) -> ModuleType | None:\n+    \"\"\"Create new module.\"\"\"\n+    if not objects:\n+        return None\n+    log.debug(\"Creating module %s\", name)\n+    name = name.lower()\n+    module = types.ModuleType(name)\n+    module._name = name.split(\".\")[-1]  # type: ignore\n+    module._objects = objects  # type: ignore\n+    module.__dict__.update((o.__name__, o) for o in objects)\n+    return module\n+\n+\n+def integrate_macros_plugins(\n+    macros_module: ModuleType, macros_module_name_prefix: str, plugins: list[AirflowPlugin]\n+) -> None:\n+    \"\"\"Integrates macro plugins.\"\"\"\n+    log.debug(\"Integrate Macros plugins\")\n+\n+    for plugin in plugins:\n+        if plugin.name is None:\n+            raise AirflowPluginException(\"Invalid plugin name\")\n+\n+        macros_module_instance = make_module(f\"{macros_module_name_prefix}.{plugin.name}\", plugin.macros)\n+\n+        if macros_module_instance:\n+            sys.modules[macros_module_instance.__name__] = macros_module_instance\n+            # Register the newly created module on airflow.macros such that it",
      "comment": "This comment is not valid -> the macros module is now injected from outside.",
      "comment_id": 2655460701,
      "user": "potiuk",
      "created_at": "2025-12-31T14:13:46Z",
      "url": "https://github.com/apache/airflow/pull/59956#discussion_r2655460701"
    },
    {
      "repo": "apache/airflow",
      "pr_number": 59956,
      "file_path": "shared/plugins_manager/src/airflow_shared/plugins_manager/plugins_manager.py",
      "line": 255,
      "side": "RIGHT",
      "diff_hunk": "@@ -0,0 +1,280 @@\n+#\n+# Licensed to the Apache Software Foundation (ASF) under one\n+# or more contributor license agreements.  See the NOTICE file\n+# distributed with this work for additional information\n+# regarding copyright ownership.  The ASF licenses this file\n+# to you under the Apache License, Version 2.0 (the\n+# \"License\"); you may not use this file except in compliance\n+# with the License.  You may obtain a copy of the License at\n+#\n+#   http://www.apache.org/licenses/LICENSE-2.0\n+#\n+# Unless required by applicable law or agreed to in writing,\n+# software distributed under the License is distributed on an\n+# \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+# KIND, either express or implied.  See the License for the\n+# specific language governing permissions and limitations\n+# under the License.\n+\"\"\"Manages all plugins.\"\"\"\n+\n+from __future__ import annotations\n+\n+import inspect\n+import logging\n+import os\n+import sys\n+import types\n+from pathlib import Path\n+from typing import TYPE_CHECKING, Any\n+\n+# TODO: these should be moved into module_loading i think\n+from airflow.utils.entry_points import entry_points_with_dist\n+from airflow.utils.file import find_path_from_directory\n+\n+if TYPE_CHECKING:\n+    if sys.version_info >= (3, 12):\n+        from importlib import metadata\n+    else:\n+        import importlib_metadata as metadata\n+    from collections.abc import Generator\n+    from types import ModuleType\n+\n+    from airflow.listeners.listener import ListenerManager\n+\n+log = logging.getLogger(__name__)\n+\n+\n+class AirflowPluginSource:\n+    \"\"\"Class used to define an AirflowPluginSource.\"\"\"\n+\n+    def __str__(self):\n+        raise NotImplementedError\n+\n+    def __html__(self):\n+        raise NotImplementedError\n+\n+\n+class PluginsDirectorySource(AirflowPluginSource):\n+    \"\"\"Class used to define Plugins loaded from Plugins Directory.\"\"\"\n+\n+    def __init__(self, path, plugins_folder: str):\n+        self.path = os.path.relpath(path, plugins_folder)\n+\n+    def __str__(self):\n+        return f\"$PLUGINS_FOLDER/{self.path}\"\n+\n+    def __html__(self):\n+        return f\"<em>$PLUGINS_FOLDER/</em>{self.path}\"\n+\n+\n+class EntryPointSource(AirflowPluginSource):\n+    \"\"\"Class used to define Plugins loaded from entrypoint.\"\"\"\n+\n+    def __init__(self, entrypoint: metadata.EntryPoint, dist: metadata.Distribution):\n+        self.dist = dist.metadata[\"Name\"]  # type: ignore[index]\n+        self.version = dist.version\n+        self.entrypoint = str(entrypoint)\n+\n+    def __str__(self):\n+        return f\"{self.dist}=={self.version}: {self.entrypoint}\"\n+\n+    def __html__(self):\n+        return f\"<em>{self.dist}=={self.version}:</em> {self.entrypoint}\"\n+\n+\n+class AirflowPluginException(Exception):\n+    \"\"\"Exception when loading plugin.\"\"\"\n+\n+\n+class AirflowPlugin:\n+    \"\"\"Class used to define AirflowPlugin.\"\"\"\n+\n+    name: str | None = None\n+    source: AirflowPluginSource | None = None\n+    macros: list[Any] = []\n+    admin_views: list[Any] = []\n+    flask_blueprints: list[Any] = []\n+    fastapi_apps: list[Any] = []\n+    fastapi_root_middlewares: list[Any] = []\n+    external_views: list[Any] = []\n+    react_apps: list[Any] = []\n+    menu_links: list[Any] = []\n+    appbuilder_views: list[Any] = []\n+    appbuilder_menu_items: list[Any] = []\n+\n+    # A list of global operator extra links that can redirect users to\n+    # external systems. These extra links will be available on the\n+    # task page in the form of buttons.\n+    #\n+    # Note: the global operator extra link can be overridden at each\n+    # operator level.\n+    global_operator_extra_links: list[Any] = []\n+\n+    # A list of operator extra links to override or add operator links\n+    # to existing Airflow Operators.\n+    # These extra links will be available on the task page in form of\n+    # buttons.\n+    operator_extra_links: list[Any] = []\n+\n+    # A list of timetable classes that can be used for DAG scheduling.\n+    timetables: list[Any] = []\n+\n+    # A list of listeners that can be used for tracking task and DAG states.\n+    listeners: list[ModuleType | object] = []\n+\n+    # A list of hook lineage reader classes that can be used for reading lineage information from a hook.\n+    hook_lineage_readers: list[Any] = []\n+\n+    # A list of priority weight strategy classes that can be used for calculating tasks weight priority.\n+    priority_weight_strategies: list[Any] = []\n+\n+    @classmethod\n+    def validate(cls):\n+        \"\"\"Validate if plugin has a name.\"\"\"\n+        if not cls.name:\n+            raise AirflowPluginException(\"Your plugin needs a name.\")\n+\n+    @classmethod\n+    def on_load(cls, *args, **kwargs):\n+        \"\"\"\n+        Execute when the plugin is loaded; This method is only called once during runtime.\n+\n+        :param args: If future arguments are passed in on call.\n+        :param kwargs: If future arguments are passed in on call.\n+        \"\"\"\n+\n+\n+def is_valid_plugin(plugin_obj) -> bool:\n+    \"\"\"\n+    Check whether a potential object is a subclass of the AirflowPlugin class.\n+\n+    :param plugin_obj: potential subclass of AirflowPlugin\n+    :return: Whether or not the obj is a valid subclass of\n+        AirflowPlugin\n+    \"\"\"\n+    if (\n+        inspect.isclass(plugin_obj)\n+        and issubclass(plugin_obj, AirflowPlugin)\n+        and (plugin_obj is not AirflowPlugin)\n+    ):\n+        plugin_obj.validate()\n+        return True\n+    return False\n+\n+\n+def _load_entrypoint_plugins() -> tuple[list[AirflowPlugin], dict[str, str]]:\n+    \"\"\"\n+    Load and register plugins AirflowPlugin subclasses from the entrypoints.\n+\n+    The entry_point group should be 'airflow.plugins'.\n+    \"\"\"\n+    log.debug(\"Loading plugins from entrypoints\")\n+\n+    plugins: list[AirflowPlugin] = []\n+    import_errors: dict[str, str] = {}\n+    for entry_point, dist in entry_points_with_dist(\"airflow.plugins\"):\n+        log.debug(\"Importing entry_point plugin %s\", entry_point.name)\n+        try:\n+            plugin_class = entry_point.load()\n+            if not is_valid_plugin(plugin_class):\n+                continue\n+\n+            plugin_instance: AirflowPlugin = plugin_class()\n+            plugin_instance.source = EntryPointSource(entry_point, dist)\n+            plugins.append(plugin_instance)\n+        except Exception as e:\n+            log.exception(\"Failed to import plugin %s\", entry_point.name)\n+            import_errors[entry_point.module] = str(e)\n+    return plugins, import_errors\n+\n+\n+def _load_plugins_from_plugin_directory(\n+    plugins_folder: str,\n+    load_examples: bool = False,\n+    example_plugins_module: str | None = None,\n+) -> tuple[list[AirflowPlugin], dict[str, str]]:\n+    \"\"\"Load and register Airflow Plugins from plugins directory.\"\"\"\n+    if not plugins_folder:\n+        raise ValueError(\"Plugins folder is not set\")\n+    log.debug(\"Loading plugins from directory: %s\", plugins_folder)\n+    files = find_path_from_directory(plugins_folder, \".airflowignore\")\n+    plugin_search_locations: list[tuple[str, Generator[str, None, None]]] = [(\"\", files)]\n+\n+    if load_examples:\n+        log.debug(\"Note: Loading plugins from examples as well: %s\", plugins_folder)\n+        import importlib\n+\n+        example_plugins = importlib.import_module(example_plugins_module)\n+        example_plugins_folder = next(iter(example_plugins.__path__))\n+        example_files = find_path_from_directory(example_plugins_folder, \".airflowignore\")\n+        plugin_search_locations.append((example_plugins.__name__, example_files))\n+\n+    plugins: list[AirflowPlugin] = []\n+    import_errors: dict[str, str] = {}\n+    for module_prefix, plugin_files in plugin_search_locations:\n+        for file_path in plugin_files:\n+            path = Path(file_path)\n+            if not path.is_file() or path.suffix != \".py\":\n+                continue\n+            mod_name = f\"{module_prefix}.{path.stem}\" if module_prefix else path.stem\n+\n+            try:\n+                loader = importlib.machinery.SourceFileLoader(mod_name, file_path)\n+                spec = importlib.util.spec_from_loader(mod_name, loader)\n+                if not spec:\n+                    log.error(\"Could not load spec for module %s at %s\", mod_name, file_path)\n+                    continue\n+                mod = importlib.util.module_from_spec(spec)\n+                sys.modules[spec.name] = mod\n+                loader.exec_module(mod)\n+\n+                for mod_attr_value in (m for m in mod.__dict__.values() if is_valid_plugin(m)):\n+                    plugin_instance: AirflowPlugin = mod_attr_value()\n+                    plugin_instance.source = PluginsDirectorySource(file_path, plugins_folder)\n+                    plugins.append(plugin_instance)\n+            except Exception as e:\n+                log.exception(\"Failed to import plugin %s\", file_path)\n+                import_errors[file_path] = str(e)\n+    return plugins, import_errors\n+\n+\n+def make_module(name: str, objects: list[Any]) -> ModuleType | None:\n+    \"\"\"Create new module.\"\"\"\n+    if not objects:\n+        return None\n+    log.debug(\"Creating module %s\", name)\n+    name = name.lower()\n+    module = types.ModuleType(name)\n+    module._name = name.split(\".\")[-1]  # type: ignore\n+    module._objects = objects  # type: ignore\n+    module.__dict__.update((o.__name__, o) for o in objects)\n+    return module\n+\n+\n+def integrate_macros_plugins(\n+    macros_module: ModuleType, macros_module_name_prefix: str, plugins: list[AirflowPlugin]",
      "comment": "```suggestion\n    target_macros_module: ModuleType, macros_module_name_prefix: str, plugins: list[AirflowPlugin]\n```",
      "comment_id": 2655461022,
      "user": "potiuk",
      "created_at": "2025-12-31T14:14:02Z",
      "url": "https://github.com/apache/airflow/pull/59956#discussion_r2655461022"
    },
    {
      "repo": "apache/airflow",
      "pr_number": 59956,
      "file_path": "shared/plugins_manager/src/airflow_shared/plugins_manager/plugins_manager.py",
      "line": 255,
      "side": "RIGHT",
      "diff_hunk": "@@ -0,0 +1,280 @@\n+#\n+# Licensed to the Apache Software Foundation (ASF) under one\n+# or more contributor license agreements.  See the NOTICE file\n+# distributed with this work for additional information\n+# regarding copyright ownership.  The ASF licenses this file\n+# to you under the Apache License, Version 2.0 (the\n+# \"License\"); you may not use this file except in compliance\n+# with the License.  You may obtain a copy of the License at\n+#\n+#   http://www.apache.org/licenses/LICENSE-2.0\n+#\n+# Unless required by applicable law or agreed to in writing,\n+# software distributed under the License is distributed on an\n+# \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+# KIND, either express or implied.  See the License for the\n+# specific language governing permissions and limitations\n+# under the License.\n+\"\"\"Manages all plugins.\"\"\"\n+\n+from __future__ import annotations\n+\n+import inspect\n+import logging\n+import os\n+import sys\n+import types\n+from pathlib import Path\n+from typing import TYPE_CHECKING, Any\n+\n+# TODO: these should be moved into module_loading i think\n+from airflow.utils.entry_points import entry_points_with_dist\n+from airflow.utils.file import find_path_from_directory\n+\n+if TYPE_CHECKING:\n+    if sys.version_info >= (3, 12):\n+        from importlib import metadata\n+    else:\n+        import importlib_metadata as metadata\n+    from collections.abc import Generator\n+    from types import ModuleType\n+\n+    from airflow.listeners.listener import ListenerManager\n+\n+log = logging.getLogger(__name__)\n+\n+\n+class AirflowPluginSource:\n+    \"\"\"Class used to define an AirflowPluginSource.\"\"\"\n+\n+    def __str__(self):\n+        raise NotImplementedError\n+\n+    def __html__(self):\n+        raise NotImplementedError\n+\n+\n+class PluginsDirectorySource(AirflowPluginSource):\n+    \"\"\"Class used to define Plugins loaded from Plugins Directory.\"\"\"\n+\n+    def __init__(self, path, plugins_folder: str):\n+        self.path = os.path.relpath(path, plugins_folder)\n+\n+    def __str__(self):\n+        return f\"$PLUGINS_FOLDER/{self.path}\"\n+\n+    def __html__(self):\n+        return f\"<em>$PLUGINS_FOLDER/</em>{self.path}\"\n+\n+\n+class EntryPointSource(AirflowPluginSource):\n+    \"\"\"Class used to define Plugins loaded from entrypoint.\"\"\"\n+\n+    def __init__(self, entrypoint: metadata.EntryPoint, dist: metadata.Distribution):\n+        self.dist = dist.metadata[\"Name\"]  # type: ignore[index]\n+        self.version = dist.version\n+        self.entrypoint = str(entrypoint)\n+\n+    def __str__(self):\n+        return f\"{self.dist}=={self.version}: {self.entrypoint}\"\n+\n+    def __html__(self):\n+        return f\"<em>{self.dist}=={self.version}:</em> {self.entrypoint}\"\n+\n+\n+class AirflowPluginException(Exception):\n+    \"\"\"Exception when loading plugin.\"\"\"\n+\n+\n+class AirflowPlugin:\n+    \"\"\"Class used to define AirflowPlugin.\"\"\"\n+\n+    name: str | None = None\n+    source: AirflowPluginSource | None = None\n+    macros: list[Any] = []\n+    admin_views: list[Any] = []\n+    flask_blueprints: list[Any] = []\n+    fastapi_apps: list[Any] = []\n+    fastapi_root_middlewares: list[Any] = []\n+    external_views: list[Any] = []\n+    react_apps: list[Any] = []\n+    menu_links: list[Any] = []\n+    appbuilder_views: list[Any] = []\n+    appbuilder_menu_items: list[Any] = []\n+\n+    # A list of global operator extra links that can redirect users to\n+    # external systems. These extra links will be available on the\n+    # task page in the form of buttons.\n+    #\n+    # Note: the global operator extra link can be overridden at each\n+    # operator level.\n+    global_operator_extra_links: list[Any] = []\n+\n+    # A list of operator extra links to override or add operator links\n+    # to existing Airflow Operators.\n+    # These extra links will be available on the task page in form of\n+    # buttons.\n+    operator_extra_links: list[Any] = []\n+\n+    # A list of timetable classes that can be used for DAG scheduling.\n+    timetables: list[Any] = []\n+\n+    # A list of listeners that can be used for tracking task and DAG states.\n+    listeners: list[ModuleType | object] = []\n+\n+    # A list of hook lineage reader classes that can be used for reading lineage information from a hook.\n+    hook_lineage_readers: list[Any] = []\n+\n+    # A list of priority weight strategy classes that can be used for calculating tasks weight priority.\n+    priority_weight_strategies: list[Any] = []\n+\n+    @classmethod\n+    def validate(cls):\n+        \"\"\"Validate if plugin has a name.\"\"\"\n+        if not cls.name:\n+            raise AirflowPluginException(\"Your plugin needs a name.\")\n+\n+    @classmethod\n+    def on_load(cls, *args, **kwargs):\n+        \"\"\"\n+        Execute when the plugin is loaded; This method is only called once during runtime.\n+\n+        :param args: If future arguments are passed in on call.\n+        :param kwargs: If future arguments are passed in on call.\n+        \"\"\"\n+\n+\n+def is_valid_plugin(plugin_obj) -> bool:\n+    \"\"\"\n+    Check whether a potential object is a subclass of the AirflowPlugin class.\n+\n+    :param plugin_obj: potential subclass of AirflowPlugin\n+    :return: Whether or not the obj is a valid subclass of\n+        AirflowPlugin\n+    \"\"\"\n+    if (\n+        inspect.isclass(plugin_obj)\n+        and issubclass(plugin_obj, AirflowPlugin)\n+        and (plugin_obj is not AirflowPlugin)\n+    ):\n+        plugin_obj.validate()\n+        return True\n+    return False\n+\n+\n+def _load_entrypoint_plugins() -> tuple[list[AirflowPlugin], dict[str, str]]:\n+    \"\"\"\n+    Load and register plugins AirflowPlugin subclasses from the entrypoints.\n+\n+    The entry_point group should be 'airflow.plugins'.\n+    \"\"\"\n+    log.debug(\"Loading plugins from entrypoints\")\n+\n+    plugins: list[AirflowPlugin] = []\n+    import_errors: dict[str, str] = {}\n+    for entry_point, dist in entry_points_with_dist(\"airflow.plugins\"):\n+        log.debug(\"Importing entry_point plugin %s\", entry_point.name)\n+        try:\n+            plugin_class = entry_point.load()\n+            if not is_valid_plugin(plugin_class):\n+                continue\n+\n+            plugin_instance: AirflowPlugin = plugin_class()\n+            plugin_instance.source = EntryPointSource(entry_point, dist)\n+            plugins.append(plugin_instance)\n+        except Exception as e:\n+            log.exception(\"Failed to import plugin %s\", entry_point.name)\n+            import_errors[entry_point.module] = str(e)\n+    return plugins, import_errors\n+\n+\n+def _load_plugins_from_plugin_directory(\n+    plugins_folder: str,\n+    load_examples: bool = False,\n+    example_plugins_module: str | None = None,\n+) -> tuple[list[AirflowPlugin], dict[str, str]]:\n+    \"\"\"Load and register Airflow Plugins from plugins directory.\"\"\"\n+    if not plugins_folder:\n+        raise ValueError(\"Plugins folder is not set\")\n+    log.debug(\"Loading plugins from directory: %s\", plugins_folder)\n+    files = find_path_from_directory(plugins_folder, \".airflowignore\")\n+    plugin_search_locations: list[tuple[str, Generator[str, None, None]]] = [(\"\", files)]\n+\n+    if load_examples:\n+        log.debug(\"Note: Loading plugins from examples as well: %s\", plugins_folder)\n+        import importlib\n+\n+        example_plugins = importlib.import_module(example_plugins_module)\n+        example_plugins_folder = next(iter(example_plugins.__path__))\n+        example_files = find_path_from_directory(example_plugins_folder, \".airflowignore\")\n+        plugin_search_locations.append((example_plugins.__name__, example_files))\n+\n+    plugins: list[AirflowPlugin] = []\n+    import_errors: dict[str, str] = {}\n+    for module_prefix, plugin_files in plugin_search_locations:\n+        for file_path in plugin_files:\n+            path = Path(file_path)\n+            if not path.is_file() or path.suffix != \".py\":\n+                continue\n+            mod_name = f\"{module_prefix}.{path.stem}\" if module_prefix else path.stem\n+\n+            try:\n+                loader = importlib.machinery.SourceFileLoader(mod_name, file_path)\n+                spec = importlib.util.spec_from_loader(mod_name, loader)\n+                if not spec:\n+                    log.error(\"Could not load spec for module %s at %s\", mod_name, file_path)\n+                    continue\n+                mod = importlib.util.module_from_spec(spec)\n+                sys.modules[spec.name] = mod\n+                loader.exec_module(mod)\n+\n+                for mod_attr_value in (m for m in mod.__dict__.values() if is_valid_plugin(m)):\n+                    plugin_instance: AirflowPlugin = mod_attr_value()\n+                    plugin_instance.source = PluginsDirectorySource(file_path, plugins_folder)\n+                    plugins.append(plugin_instance)\n+            except Exception as e:\n+                log.exception(\"Failed to import plugin %s\", file_path)\n+                import_errors[file_path] = str(e)\n+    return plugins, import_errors\n+\n+\n+def make_module(name: str, objects: list[Any]) -> ModuleType | None:\n+    \"\"\"Create new module.\"\"\"\n+    if not objects:\n+        return None\n+    log.debug(\"Creating module %s\", name)\n+    name = name.lower()\n+    module = types.ModuleType(name)\n+    module._name = name.split(\".\")[-1]  # type: ignore\n+    module._objects = objects  # type: ignore\n+    module.__dict__.update((o.__name__, o) for o in objects)\n+    return module\n+\n+\n+def integrate_macros_plugins(\n+    macros_module: ModuleType, macros_module_name_prefix: str, plugins: list[AirflowPlugin]",
      "comment": "I think also betted docstrings in those methods would be really helpful to understand what they do.",
      "comment_id": 2655461547,
      "user": "potiuk",
      "created_at": "2025-12-31T14:14:32Z",
      "url": "https://github.com/apache/airflow/pull/59956#discussion_r2655461547"
    },
    {
      "repo": "apache/airflow",
      "pr_number": 59956,
      "file_path": "shared/plugins_manager/src/airflow_shared/plugins_manager/plugins_manager.py",
      "line": 1,
      "side": "RIGHT",
      "diff_hunk": "@@ -0,0 +1,280 @@\n+#",
      "comment": "<img width=\"695\" height=\"199\" alt=\"image\" src=\"https://github.com/user-attachments/assets/da03986e-81e5-454d-8d95-f828219d914e\" />\r\n",
      "comment_id": 2655463478,
      "user": "potiuk",
      "created_at": "2025-12-31T14:16:13Z",
      "url": "https://github.com/apache/airflow/pull/59956#discussion_r2655463478"
    },
    {
      "repo": "apache/airflow",
      "pr_number": 59956,
      "file_path": "shared/plugins_manager/src/airflow_shared/plugins_manager/plugins_manager.py",
      "line": 31,
      "side": "RIGHT",
      "diff_hunk": "@@ -0,0 +1,280 @@\n+#\n+# Licensed to the Apache Software Foundation (ASF) under one\n+# or more contributor license agreements.  See the NOTICE file\n+# distributed with this work for additional information\n+# regarding copyright ownership.  The ASF licenses this file\n+# to you under the Apache License, Version 2.0 (the\n+# \"License\"); you may not use this file except in compliance\n+# with the License.  You may obtain a copy of the License at\n+#\n+#   http://www.apache.org/licenses/LICENSE-2.0\n+#\n+# Unless required by applicable law or agreed to in writing,\n+# software distributed under the License is distributed on an\n+# \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+# KIND, either express or implied.  See the License for the\n+# specific language governing permissions and limitations\n+# under the License.\n+\"\"\"Manages all plugins.\"\"\"\n+\n+from __future__ import annotations\n+\n+import inspect\n+import logging\n+import os\n+import sys\n+import types\n+from pathlib import Path\n+from typing import TYPE_CHECKING, Any\n+\n+# TODO: these should be moved into module_loading i think\n+from airflow.utils.entry_points import entry_points_with_dist",
      "comment": "Handled in: https://github.com/apache/airflow/pull/59971",
      "comment_id": 2655488035,
      "user": "amoghrajesh",
      "created_at": "2025-12-31T14:36:36Z",
      "url": "https://github.com/apache/airflow/pull/59956#discussion_r2655488035"
    },
    {
      "repo": "apache/airflow",
      "pr_number": 59956,
      "file_path": "shared/plugins_manager/src/airflow_shared/plugins_manager/plugins_manager.py",
      "line": 101,
      "side": "RIGHT",
      "diff_hunk": "@@ -0,0 +1,280 @@\n+#\n+# Licensed to the Apache Software Foundation (ASF) under one\n+# or more contributor license agreements.  See the NOTICE file\n+# distributed with this work for additional information\n+# regarding copyright ownership.  The ASF licenses this file\n+# to you under the Apache License, Version 2.0 (the\n+# \"License\"); you may not use this file except in compliance\n+# with the License.  You may obtain a copy of the License at\n+#\n+#   http://www.apache.org/licenses/LICENSE-2.0\n+#\n+# Unless required by applicable law or agreed to in writing,\n+# software distributed under the License is distributed on an\n+# \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+# KIND, either express or implied.  See the License for the\n+# specific language governing permissions and limitations\n+# under the License.\n+\"\"\"Manages all plugins.\"\"\"\n+\n+from __future__ import annotations\n+\n+import inspect\n+import logging\n+import os\n+import sys\n+import types\n+from pathlib import Path\n+from typing import TYPE_CHECKING, Any\n+\n+# TODO: these should be moved into module_loading i think\n+from airflow.utils.entry_points import entry_points_with_dist\n+from airflow.utils.file import find_path_from_directory\n+\n+if TYPE_CHECKING:\n+    if sys.version_info >= (3, 12):\n+        from importlib import metadata\n+    else:\n+        import importlib_metadata as metadata\n+    from collections.abc import Generator\n+    from types import ModuleType\n+\n+    from airflow.listeners.listener import ListenerManager\n+\n+log = logging.getLogger(__name__)\n+\n+\n+class AirflowPluginSource:\n+    \"\"\"Class used to define an AirflowPluginSource.\"\"\"\n+\n+    def __str__(self):\n+        raise NotImplementedError\n+\n+    def __html__(self):\n+        raise NotImplementedError\n+\n+\n+class PluginsDirectorySource(AirflowPluginSource):\n+    \"\"\"Class used to define Plugins loaded from Plugins Directory.\"\"\"\n+\n+    def __init__(self, path, plugins_folder: str):\n+        self.path = os.path.relpath(path, plugins_folder)\n+\n+    def __str__(self):\n+        return f\"$PLUGINS_FOLDER/{self.path}\"\n+\n+    def __html__(self):\n+        return f\"<em>$PLUGINS_FOLDER/</em>{self.path}\"\n+\n+\n+class EntryPointSource(AirflowPluginSource):\n+    \"\"\"Class used to define Plugins loaded from entrypoint.\"\"\"\n+\n+    def __init__(self, entrypoint: metadata.EntryPoint, dist: metadata.Distribution):\n+        self.dist = dist.metadata[\"Name\"]  # type: ignore[index]\n+        self.version = dist.version\n+        self.entrypoint = str(entrypoint)\n+\n+    def __str__(self):\n+        return f\"{self.dist}=={self.version}: {self.entrypoint}\"\n+\n+    def __html__(self):\n+        return f\"<em>{self.dist}=={self.version}:</em> {self.entrypoint}\"\n+\n+\n+class AirflowPluginException(Exception):\n+    \"\"\"Exception when loading plugin.\"\"\"\n+\n+\n+class AirflowPlugin:\n+    \"\"\"Class used to define AirflowPlugin.\"\"\"\n+\n+    name: str | None = None\n+    source: AirflowPluginSource | None = None\n+    macros: list[Any] = []\n+    admin_views: list[Any] = []\n+    flask_blueprints: list[Any] = []\n+    fastapi_apps: list[Any] = []\n+    fastapi_root_middlewares: list[Any] = []\n+    external_views: list[Any] = []\n+    react_apps: list[Any] = []\n+    menu_links: list[Any] = []",
      "comment": "For a long time it bothered me that most of the element lists are of type `Any` - as we are moving here, would it be (non breaking interface?) possible to change them to a TypedDict such that elements needed are at least described?",
      "comment_id": 2655662903,
      "user": "jscheffl",
      "created_at": "2025-12-31T17:02:39Z",
      "url": "https://github.com/apache/airflow/pull/59956#discussion_r2655662903"
    },
    {
      "repo": "apache/airflow",
      "pr_number": 59956,
      "file_path": "shared/plugins_manager/src/airflow_shared/plugins_manager/plugins_manager.py",
      "line": 31,
      "side": "RIGHT",
      "diff_hunk": "@@ -0,0 +1,281 @@\n+#\n+# Licensed to the Apache Software Foundation (ASF) under one\n+# or more contributor license agreements.  See the NOTICE file\n+# distributed with this work for additional information\n+# regarding copyright ownership.  The ASF licenses this file\n+# to you under the Apache License, Version 2.0 (the\n+# \"License\"); you may not use this file except in compliance\n+# with the License.  You may obtain a copy of the License at\n+#\n+#   http://www.apache.org/licenses/LICENSE-2.0\n+#\n+# Unless required by applicable law or agreed to in writing,\n+# software distributed under the License is distributed on an\n+# \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+# KIND, either express or implied.  See the License for the\n+# specific language governing permissions and limitations\n+# under the License.\n+\"\"\"Manages all plugins.\"\"\"\n+\n+from __future__ import annotations\n+\n+import inspect\n+import logging\n+import os\n+import sys\n+import types\n+from pathlib import Path\n+from typing import TYPE_CHECKING, Any\n+\n+# TODO: these should be moved into module_loading i think\n+from airflow.utils.file import find_path_from_directory",
      "comment": "Another precursor: https://github.com/apache/airflow/pull/60114",
      "comment_id": 2660464046,
      "user": "amoghrajesh",
      "created_at": "2026-01-05T06:53:45Z",
      "url": "https://github.com/apache/airflow/pull/59956#discussion_r2660464046"
    },
    {
      "repo": "apache/airflow",
      "pr_number": 59956,
      "file_path": "shared/plugins_manager/src/airflow_shared/plugins_manager/plugins_manager.py",
      "line": 1,
      "side": "RIGHT",
      "diff_hunk": "@@ -0,0 +1,280 @@\n+#",
      "comment": "Apologies, forgot to handle this, handled now: d61f3ee7d7",
      "comment_id": 2661430088,
      "user": "amoghrajesh",
      "created_at": "2026-01-05T13:02:28Z",
      "url": "https://github.com/apache/airflow/pull/59956#discussion_r2661430088"
    },
    {
      "repo": "apache/airflow",
      "pr_number": 59956,
      "file_path": "shared/plugins_manager/src/airflow_shared/plugins_manager/plugins_manager.py",
      "line": 101,
      "side": "RIGHT",
      "diff_hunk": "@@ -0,0 +1,280 @@\n+#\n+# Licensed to the Apache Software Foundation (ASF) under one\n+# or more contributor license agreements.  See the NOTICE file\n+# distributed with this work for additional information\n+# regarding copyright ownership.  The ASF licenses this file\n+# to you under the Apache License, Version 2.0 (the\n+# \"License\"); you may not use this file except in compliance\n+# with the License.  You may obtain a copy of the License at\n+#\n+#   http://www.apache.org/licenses/LICENSE-2.0\n+#\n+# Unless required by applicable law or agreed to in writing,\n+# software distributed under the License is distributed on an\n+# \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+# KIND, either express or implied.  See the License for the\n+# specific language governing permissions and limitations\n+# under the License.\n+\"\"\"Manages all plugins.\"\"\"\n+\n+from __future__ import annotations\n+\n+import inspect\n+import logging\n+import os\n+import sys\n+import types\n+from pathlib import Path\n+from typing import TYPE_CHECKING, Any\n+\n+# TODO: these should be moved into module_loading i think\n+from airflow.utils.entry_points import entry_points_with_dist\n+from airflow.utils.file import find_path_from_directory\n+\n+if TYPE_CHECKING:\n+    if sys.version_info >= (3, 12):\n+        from importlib import metadata\n+    else:\n+        import importlib_metadata as metadata\n+    from collections.abc import Generator\n+    from types import ModuleType\n+\n+    from airflow.listeners.listener import ListenerManager\n+\n+log = logging.getLogger(__name__)\n+\n+\n+class AirflowPluginSource:\n+    \"\"\"Class used to define an AirflowPluginSource.\"\"\"\n+\n+    def __str__(self):\n+        raise NotImplementedError\n+\n+    def __html__(self):\n+        raise NotImplementedError\n+\n+\n+class PluginsDirectorySource(AirflowPluginSource):\n+    \"\"\"Class used to define Plugins loaded from Plugins Directory.\"\"\"\n+\n+    def __init__(self, path, plugins_folder: str):\n+        self.path = os.path.relpath(path, plugins_folder)\n+\n+    def __str__(self):\n+        return f\"$PLUGINS_FOLDER/{self.path}\"\n+\n+    def __html__(self):\n+        return f\"<em>$PLUGINS_FOLDER/</em>{self.path}\"\n+\n+\n+class EntryPointSource(AirflowPluginSource):\n+    \"\"\"Class used to define Plugins loaded from entrypoint.\"\"\"\n+\n+    def __init__(self, entrypoint: metadata.EntryPoint, dist: metadata.Distribution):\n+        self.dist = dist.metadata[\"Name\"]  # type: ignore[index]\n+        self.version = dist.version\n+        self.entrypoint = str(entrypoint)\n+\n+    def __str__(self):\n+        return f\"{self.dist}=={self.version}: {self.entrypoint}\"\n+\n+    def __html__(self):\n+        return f\"<em>{self.dist}=={self.version}:</em> {self.entrypoint}\"\n+\n+\n+class AirflowPluginException(Exception):\n+    \"\"\"Exception when loading plugin.\"\"\"\n+\n+\n+class AirflowPlugin:\n+    \"\"\"Class used to define AirflowPlugin.\"\"\"\n+\n+    name: str | None = None\n+    source: AirflowPluginSource | None = None\n+    macros: list[Any] = []\n+    admin_views: list[Any] = []\n+    flask_blueprints: list[Any] = []\n+    fastapi_apps: list[Any] = []\n+    fastapi_root_middlewares: list[Any] = []\n+    external_views: list[Any] = []\n+    react_apps: list[Any] = []\n+    menu_links: list[Any] = []",
      "comment": "Umm, I think its a separate discussion, but good call, would you mind creating an issue for it?",
      "comment_id": 2661451657,
      "user": "amoghrajesh",
      "created_at": "2026-01-05T13:10:55Z",
      "url": "https://github.com/apache/airflow/pull/59956#discussion_r2661451657"
    },
    {
      "repo": "apache/airflow",
      "pr_number": 59873,
      "file_path": "airflow-core/tests/unit/api_fastapi/core_api/routes/ui/test_connections.py",
      "line": 52,
      "side": "RIGHT",
      "diff_hunk": "@@ -37,6 +45,41 @@ def test_hook_meta_data(self, test_client):\n             if hook_data[\"connection_type\"] == \"fs\":\n                 assert hook_data[\"hook_name\"] == \"File (path)\"\n \n+    @pytest.mark.parametrize(\n+        (\"extra_fields\", \"expected_response\"),\n+        [\n+            ({\"secret_key\": \"test-secret_key\"}, {\"secret_key\": \"***\"}),\n+            ({\"extra_fields\": \"test-extra_fields\"}, {\"extra_fields\": \"test-extra_fields\"}),",
      "comment": "Does it mean that redact for `extra_fields` is not working?",
      "comment_id": 2653056688,
      "user": "jason810496",
      "created_at": "2025-12-30T13:52:24Z",
      "url": "https://github.com/apache/airflow/pull/59873#discussion_r2653056688"
    },
    {
      "repo": "apache/airflow",
      "pr_number": 59873,
      "file_path": "airflow-core/src/airflow/api_fastapi/core_api/datamodels/config.py",
      "line": 48,
      "side": "RIGHT",
      "diff_hunk": "@@ -25,6 +31,22 @@ class ConfigOption(StrictBaseModel):\n     key: str\n     value: str | tuple[str, str]\n \n+    @model_validator(mode=\"after\")\n+    def redact_value(self) -> Self:\n+        if self.value is None:\n+            return self\n+        if isinstance(self.value, tuple):\n+            return self\n+        try:\n+            value_dict = json.loads(self.value)\n+            redacted_dict = redact(value_dict, max_depth=1)\n+            self.value = json.dumps(redacted_dict)\n+            return self\n+        except json.JSONDecodeError:\n+            # value is not a serialized string representation of a dict.\n+            self.value = str(redact(self.value, self.key))\n+            return self",
      "comment": "It seems we don't need to handle redact as Variable does.\nSince for value of config, it will be str, int, or bool: https://airflow.apache.org/docs/apache-airflow/stable/configurations-ref.html instead of dict (json).\n\nAdditionally, `redact` can handle `str` and `tuple` well.\nhttps://github.com/apache/airflow/blob/cf80ae19840f1d03e16323e7bca819550633db97/shared/secrets_masker/src/airflow_shared/secrets_masker/secrets_masker.py#L46\n\nSo maybe we could take `redact_password` as example for this case.\n\nhttps://github.com/apache/airflow/blob/main/airflow-core/src/airflow/api_fastapi/core_api/datamodels/connections.py#L46-L51",
      "comment_id": 2653086221,
      "user": "jason810496",
      "created_at": "2025-12-30T14:08:12Z",
      "url": "https://github.com/apache/airflow/pull/59873#discussion_r2653086221"
    },
    {
      "repo": "apache/airflow",
      "pr_number": 59873,
      "file_path": "airflow-core/tests/unit/api_fastapi/core_api/routes/ui/test_connections.py",
      "line": 52,
      "side": "RIGHT",
      "diff_hunk": "@@ -37,6 +45,41 @@ def test_hook_meta_data(self, test_client):\n             if hook_data[\"connection_type\"] == \"fs\":\n                 assert hook_data[\"hook_name\"] == \"File (path)\"\n \n+    @pytest.mark.parametrize(\n+        (\"extra_fields\", \"expected_response\"),\n+        [\n+            ({\"secret_key\": \"test-secret_key\"}, {\"secret_key\": \"***\"}),\n+            ({\"extra_fields\": \"test-extra_fields\"}, {\"extra_fields\": \"test-extra_fields\"}),",
      "comment": "@jason810496, yes, I tested it on UI above and ran pytest without \r\n```@field_validator(\"extra_fields\", mode=\"after\")\r\n    @classmethod\r\n    def redact_extra_fields(cls, v: Mapping | None):\r\n        if v is None:\r\n            return None\r\n\r\n        return redact(v)\r\n```\r\n\r\n* It failed\r\n<img width=\"1632\" height=\"332\" alt=\"image\" src=\"https://github.com/user-attachments/assets/d9958166-559f-4a36-b27d-4c02231d2bde\" />\r\n",
      "comment_id": 2653413419,
      "user": "nhuantho",
      "created_at": "2025-12-30T16:44:36Z",
      "url": "https://github.com/apache/airflow/pull/59873#discussion_r2653413419"
    },
    {
      "repo": "apache/airflow",
      "pr_number": 59873,
      "file_path": "airflow-core/src/airflow/api_fastapi/core_api/datamodels/config.py",
      "line": 48,
      "side": "RIGHT",
      "diff_hunk": "@@ -25,6 +31,22 @@ class ConfigOption(StrictBaseModel):\n     key: str\n     value: str | tuple[str, str]\n \n+    @model_validator(mode=\"after\")\n+    def redact_value(self) -> Self:\n+        if self.value is None:\n+            return self\n+        if isinstance(self.value, tuple):\n+            return self\n+        try:\n+            value_dict = json.loads(self.value)\n+            redacted_dict = redact(value_dict, max_depth=1)\n+            self.value = json.dumps(redacted_dict)\n+            return self\n+        except json.JSONDecodeError:\n+            # value is not a serialized string representation of a dict.\n+            self.value = str(redact(self.value, self.key))\n+            return self",
      "comment": "@jason810496 I tested with `smtp_password` in `airflow-core/tests/unit/api_fastapi/core_api/routes/public/test_config.py`",
      "comment_id": 2653421511,
      "user": "nhuantho",
      "created_at": "2025-12-30T16:47:52Z",
      "url": "https://github.com/apache/airflow/pull/59873#discussion_r2653421511"
    },
    {
      "repo": "apache/airflow",
      "pr_number": 59873,
      "file_path": "airflow-core/tests/unit/api_fastapi/core_api/routes/ui/test_connections.py",
      "line": 52,
      "side": "RIGHT",
      "diff_hunk": "@@ -37,6 +45,41 @@ def test_hook_meta_data(self, test_client):\n             if hook_data[\"connection_type\"] == \"fs\":\n                 assert hook_data[\"hook_name\"] == \"File (path)\"\n \n+    @pytest.mark.parametrize(\n+        (\"extra_fields\", \"expected_response\"),\n+        [\n+            ({\"secret_key\": \"test-secret_key\"}, {\"secret_key\": \"***\"}),\n+            ({\"extra_fields\": \"test-extra_fields\"}, {\"extra_fields\": \"test-extra_fields\"}),",
      "comment": "Even though redact was added for `extra_fields`, it isn\u2019t works here. Since the `expected_response` is `{\"extra_fields\": \"test-extra_fields\"}` instead of `{\"extra_fields\": \"***\"}`.\n\nWe should adjust the implementation so redact masks `extra_fields`, making the `expected_response` as `{\"extra_fields\": \"***\"}` and letting the test pass.\n\nThanks!",
      "comment_id": 2657700430,
      "user": "jason810496",
      "created_at": "2026-01-02T13:15:24Z",
      "url": "https://github.com/apache/airflow/pull/59873#discussion_r2657700430"
    },
    {
      "repo": "apache/airflow",
      "pr_number": 59873,
      "file_path": "airflow-core/src/airflow/api_fastapi/core_api/datamodels/connections.py",
      "line": 132,
      "side": "RIGHT",
      "diff_hunk": "@@ -123,6 +123,14 @@ class ConnectionHookMetaData(BaseModel):\n     standard_fields: StandardHookFields | None\n     extra_fields: Mapping | None\n \n+    @field_validator(\"extra_fields\", mode=\"after\")\n+    @classmethod\n+    def redact_extra_fields(cls, v: Mapping | None):\n+        if v is None:\n+            return None\n+\n+        return redact(v)",
      "comment": "If `extra_fields` is normal data instead of sensitive data. How about let's just remove the redact here?",
      "comment_id": 2658746029,
      "user": "jason810496",
      "created_at": "2026-01-03T05:59:29Z",
      "url": "https://github.com/apache/airflow/pull/59873#discussion_r2658746029"
    },
    {
      "repo": "apache/airflow",
      "pr_number": 59873,
      "file_path": "airflow-core/src/airflow/api_fastapi/core_api/datamodels/connections.py",
      "line": 132,
      "side": "RIGHT",
      "diff_hunk": "@@ -123,6 +123,14 @@ class ConnectionHookMetaData(BaseModel):\n     standard_fields: StandardHookFields | None\n     extra_fields: Mapping | None\n \n+    @field_validator(\"extra_fields\", mode=\"after\")\n+    @classmethod\n+    def redact_extra_fields(cls, v: Mapping | None):\n+        if v is None:\n+            return None\n+\n+        return redact(v)",
      "comment": "@jason810496, extra_fields is a mapping, I think it will include both sensitive fields and normal fields, so I will add a new test with a dict that includes sensitive fields and normal fields:\r\n```\r\n            (\r\n                {\r\n                    \"secret_key\": \"test-secret_key\",\r\n                    \"extra_fields\": \"test-extra_fields\",\r\n                    \"password\": \"test-password\",\r\n                },\r\n                {\"secret_key\": \"***\", \"extra_fields\": \"test-extra_fields\", \"password\": \"***\"},\r\n            )\r\n```",
      "comment_id": 2659214806,
      "user": "nhuantho",
      "created_at": "2026-01-03T23:42:17Z",
      "url": "https://github.com/apache/airflow/pull/59873#discussion_r2659214806"
    },
    {
      "repo": "apache/airflow",
      "pr_number": 59218,
      "file_path": "airflow-core/src/airflow/utils/db.py",
      "line": 1375,
      "side": "RIGHT",
      "diff_hunk": "@@ -1236,7 +1372,7 @@ def _get_fab_migration_version(*, session: Session) -> str | None:\n         return None\n \n \n-def _handle_fab_downgrade(*, session: Session) -> None:\n+def _handle_fab_downgrade(*, session: Session, is_mysql: bool) -> None:",
      "comment": "Are we sure we want to use a boolean here and change the api of the method instead of just having another function Incase of MySQL, and when calling it, have an if statement to decide which method to call",
      "comment_id": 2645197334,
      "user": "Nataneljpwd",
      "created_at": "2025-12-24T09:06:18Z",
      "url": "https://github.com/apache/airflow/pull/59218#discussion_r2645197334"
    },
    {
      "repo": "apache/airflow",
      "pr_number": 59218,
      "file_path": "airflow-core/src/airflow/utils/db.py",
      "line": 1302,
      "side": "RIGHT",
      "diff_hunk": "@@ -1163,17 +1249,52 @@ def resetdb(session: Session = NEW_SESSION, skip_init: bool = False):\n \n     import_all_models()\n \n-    connection = settings.engine.connect()\n+    if get_dialect_name(session) == \"mysql\":",
      "comment": "There is quite a bit of logic here specific for MySQL, maybe it is a good idea to separate it to another method",
      "comment_id": 2645203744,
      "user": "Nataneljpwd",
      "created_at": "2025-12-24T09:09:12Z",
      "url": "https://github.com/apache/airflow/pull/59218#discussion_r2645203744"
    },
    {
      "repo": "apache/airflow",
      "pr_number": 59218,
      "file_path": "airflow-core/src/airflow/utils/db.py",
      "line": 690,
      "side": "RIGHT",
      "diff_hunk": "@@ -685,12 +685,32 @@ def _create_db_from_orm(session):\n \n     log.info(\"Creating Airflow database tables from the ORM\")\n \n-    # Debug setup if requested\n     _setup_debug_logging_if_needed()\n \n-    log.info(\"Creating context\")\n+    if get_dialect_name(session) == \"mysql\":",
      "comment": "Same here, quite a bit of MySQL specific logic, maybe it is better to move it to a different method?",
      "comment_id": 2645209669,
      "user": "Nataneljpwd",
      "created_at": "2025-12-24T09:11:40Z",
      "url": "https://github.com/apache/airflow/pull/59218#discussion_r2645209669"
    },
    {
      "repo": "apache/airflow",
      "pr_number": 59218,
      "file_path": "airflow-core/src/airflow/utils/db.py",
      "line": 1202,
      "side": "RIGHT",
      "diff_hunk": "@@ -1120,36 +1195,47 @@ def upgradedb(\n         exit(1)\n \n     if not _get_current_revision(session=session) and not to_revision:\n-        # Don't load default connections\n         # New DB; initialize and exit\n         initdb(session=session)\n         return\n-    with create_global_lock(session=session, lock=DBLocks.MIGRATIONS):\n-        import sqlalchemy.pool\n \n+    if settings.get_engine().dialect.name == \"mysql\":",
      "comment": "Same here, quite a bit of MySQL specific logic, could be worth it to move it to another method",
      "comment_id": 2645231520,
      "user": "Nataneljpwd",
      "created_at": "2025-12-24T09:20:40Z",
      "url": "https://github.com/apache/airflow/pull/59218#discussion_r2645231520"
    },
    {
      "repo": "apache/airflow",
      "pr_number": 59218,
      "file_path": "airflow-core/src/airflow/utils/db.py",
      "line": 1593,
      "side": "RIGHT",
      "diff_hunk": "@@ -1345,18 +1490,59 @@ def create_global_lock(\n     lock: DBLocks,\n     lock_timeout: int = 1800,\n ) -> Generator[None, None, None]:\n-    \"\"\"Contextmanager that will create and teardown a global db lock.\"\"\"\n-    bind = session.get_bind()\n-    if hasattr(bind, \"connect\"):\n-        conn = bind.connect()\n-    else:\n-        conn = bind\n+    \"\"\"\n+    Contextmanager that will create and teardown a global db lock.\n+\n+    For MySQL, uses a dedicated AUTOCOMMIT connection because:\n+    - GET_LOCK is session-level, not transaction-level\n+    - DDL operations cause implicit commits that would break transaction wrappers\n+\n+    For PostgreSQL, uses transactional advisory locks as before.\n+    \"\"\"\n     dialect_name = get_dialect_name(session)\n-    try:\n-        if dialect_name == \"postgresql\":\n+\n+    if dialect_name == \"mysql\":",
      "comment": "Same here, a lot of MySQL specific code which could be separated to a different method, improving readability ",
      "comment_id": 2645234579,
      "user": "Nataneljpwd",
      "created_at": "2025-12-24T09:22:09Z",
      "url": "https://github.com/apache/airflow/pull/59218#discussion_r2645234579"
    },
    {
      "repo": "apache/airflow",
      "pr_number": 59218,
      "file_path": "airflow-core/src/airflow/utils/db_manager.py",
      "line": 56,
      "side": "RIGHT",
      "diff_hunk": "@@ -48,6 +49,24 @@ def __init__(self, session):\n         super().__init__()\n         self.session = session\n \n+    def _is_mysql(self) -> bool:\n+        \"\"\"Check if the database is MySQL.\"\"\"\n+        return get_dialect_name(self.session) == \"mysql\"\n+\n+    def _release_metadata_locks(self) -> None:",
      "comment": "Maybe it's a good idea to, in the method name, add MySQL if it is MySQL specific",
      "comment_id": 2645237863,
      "user": "Nataneljpwd",
      "created_at": "2025-12-24T09:23:55Z",
      "url": "https://github.com/apache/airflow/pull/59218#discussion_r2645237863"
    },
    {
      "repo": "apache/airflow",
      "pr_number": 59218,
      "file_path": "airflow-core/src/airflow/utils/db.py",
      "line": 1375,
      "side": "RIGHT",
      "diff_hunk": "@@ -1236,7 +1372,7 @@ def _get_fab_migration_version(*, session: Session) -> str | None:\n         return None\n \n \n-def _handle_fab_downgrade(*, session: Session) -> None:\n+def _handle_fab_downgrade(*, session: Session, is_mysql: bool) -> None:",
      "comment": "Fixed locally, changes will be visible on the next rebase.",
      "comment_id": 2645325440,
      "user": "Dev-iL",
      "created_at": "2025-12-24T10:04:47Z",
      "url": "https://github.com/apache/airflow/pull/59218#discussion_r2645325440"
    },
    {
      "repo": "apache/airflow",
      "pr_number": 59218,
      "file_path": "airflow-core/src/airflow/utils/db.py",
      "line": 690,
      "side": "RIGHT",
      "diff_hunk": "@@ -685,12 +685,32 @@ def _create_db_from_orm(session):\n \n     log.info(\"Creating Airflow database tables from the ORM\")\n \n-    # Debug setup if requested\n     _setup_debug_logging_if_needed()\n \n-    log.info(\"Creating context\")\n+    if get_dialect_name(session) == \"mysql\":",
      "comment": "Fixed locally, changes will be visible on the next rebase.",
      "comment_id": 2645325627,
      "user": "Dev-iL",
      "created_at": "2025-12-24T10:04:53Z",
      "url": "https://github.com/apache/airflow/pull/59218#discussion_r2645325627"
    },
    {
      "repo": "apache/airflow",
      "pr_number": 59218,
      "file_path": "airflow-core/src/airflow/utils/db.py",
      "line": 1302,
      "side": "RIGHT",
      "diff_hunk": "@@ -1163,17 +1249,52 @@ def resetdb(session: Session = NEW_SESSION, skip_init: bool = False):\n \n     import_all_models()\n \n-    connection = settings.engine.connect()\n+    if get_dialect_name(session) == \"mysql\":",
      "comment": "Fixed locally, changes will be visible on the next rebase.",
      "comment_id": 2645325965,
      "user": "Dev-iL",
      "created_at": "2025-12-24T10:05:04Z",
      "url": "https://github.com/apache/airflow/pull/59218#discussion_r2645325965"
    },
    {
      "repo": "apache/airflow",
      "pr_number": 59218,
      "file_path": "airflow-core/src/airflow/utils/db.py",
      "line": 1202,
      "side": "RIGHT",
      "diff_hunk": "@@ -1120,36 +1195,47 @@ def upgradedb(\n         exit(1)\n \n     if not _get_current_revision(session=session) and not to_revision:\n-        # Don't load default connections\n         # New DB; initialize and exit\n         initdb(session=session)\n         return\n-    with create_global_lock(session=session, lock=DBLocks.MIGRATIONS):\n-        import sqlalchemy.pool\n \n+    if settings.get_engine().dialect.name == \"mysql\":",
      "comment": "Fixed locally, changes will be visible on the next rebase.",
      "comment_id": 2645326449,
      "user": "Dev-iL",
      "created_at": "2025-12-24T10:05:21Z",
      "url": "https://github.com/apache/airflow/pull/59218#discussion_r2645326449"
    },
    {
      "repo": "apache/airflow",
      "pr_number": 59218,
      "file_path": "airflow-core/src/airflow/utils/db.py",
      "line": 1593,
      "side": "RIGHT",
      "diff_hunk": "@@ -1345,18 +1490,59 @@ def create_global_lock(\n     lock: DBLocks,\n     lock_timeout: int = 1800,\n ) -> Generator[None, None, None]:\n-    \"\"\"Contextmanager that will create and teardown a global db lock.\"\"\"\n-    bind = session.get_bind()\n-    if hasattr(bind, \"connect\"):\n-        conn = bind.connect()\n-    else:\n-        conn = bind\n+    \"\"\"\n+    Contextmanager that will create and teardown a global db lock.\n+\n+    For MySQL, uses a dedicated AUTOCOMMIT connection because:\n+    - GET_LOCK is session-level, not transaction-level\n+    - DDL operations cause implicit commits that would break transaction wrappers\n+\n+    For PostgreSQL, uses transactional advisory locks as before.\n+    \"\"\"\n     dialect_name = get_dialect_name(session)\n-    try:\n-        if dialect_name == \"postgresql\":\n+\n+    if dialect_name == \"mysql\":",
      "comment": "Fixed locally, changes will be visible after the next rebase.",
      "comment_id": 2645326879,
      "user": "Dev-iL",
      "created_at": "2025-12-24T10:05:36Z",
      "url": "https://github.com/apache/airflow/pull/59218#discussion_r2645326879"
    },
    {
      "repo": "apache/airflow",
      "pr_number": 59218,
      "file_path": "airflow-core/src/airflow/utils/db_manager.py",
      "line": 56,
      "side": "RIGHT",
      "diff_hunk": "@@ -48,6 +49,24 @@ def __init__(self, session):\n         super().__init__()\n         self.session = session\n \n+    def _is_mysql(self) -> bool:\n+        \"\"\"Check if the database is MySQL.\"\"\"\n+        return get_dialect_name(self.session) == \"mysql\"\n+\n+    def _release_metadata_locks(self) -> None:",
      "comment": "Fixed locally, changes will be visible after the next rebase.",
      "comment_id": 2645327107,
      "user": "Dev-iL",
      "created_at": "2025-12-24T10:05:44Z",
      "url": "https://github.com/apache/airflow/pull/59218#discussion_r2645327107"
    },
    {
      "repo": "apache/airflow",
      "pr_number": 59218,
      "file_path": "airflow-core/src/airflow/utils/db.py",
      "line": 809,
      "side": "RIGHT",
      "diff_hunk": "@@ -700,39 +721,102 @@ def _create_db_from_orm(session):\n         log.info(\"Getting alembic config\")\n         config = _get_alembic_config()\n \n-        # Use AUTOCOMMIT for DDL to avoid metadata lock issues\n-        with AutocommitEngineForMySQL():  # TODO: enable for sqlite too\n-            from alembic import command\n+        log.info(\"Stamping migration head\")\n+        command.stamp(config, \"head\")\n \n-            log.info(\"Stamping migration head\")\n-            command.stamp(config, \"head\")\n+    log.info(\"Airflow database tables created\")\n+\n+\n+def _create_db_from_orm(session):\n+    \"\"\"Create database tables from ORM models and stamp alembic version.\"\"\"\n+    log.info(\"Creating Airflow database tables from the ORM\")\n+    _setup_debug_logging_if_needed()\n \n-        log.info(\"Airflow database tables created\")\n+    if get_dialect_name(session) == \"mysql\":\n+        _create_db_from_orm_mysql(session)\n+    else:\n+        _create_db_from_orm_default(session)\n \n \n def _setup_debug_logging_if_needed():\n     \"\"\"Set up debug logging and stack trace dumping if SQLALCHEMY_ENGINE_DEBUG is set.\"\"\"\n     if not os.environ.get(\"SQLALCHEMY_ENGINE_DEBUG\"):\n         return\n \n+    import atexit\n     import faulthandler\n-    import threading\n+    from contextlib import suppress\n \n     # Enable SQLA debug logging\n     logging.getLogger(\"sqlalchemy.engine\").setLevel(logging.DEBUG)\n \n-    # Enable Fault Handler\n+    # Enable faulthandler for debugging long-running threads and deadlocks,\n+    # but disable it before interpreter shutdown to avoid segfaults during\n+    # cleanup (especially with SQLAlchemy 2.0 + pytest teardown)\n     faulthandler.enable(file=sys.stderr, all_threads=True)\n \n-    # Print Active Threads and Stack Traces Periodically\n-    def dump_stacks():\n-        while True:\n-            for thread_id, frame in sys._current_frames().items():\n-                log.info(\"\\nThread %s stack:\", thread_id)\n-                traceback.print_stack(frame)\n-            time.sleep(300)\n+    # Cancel any pending traceback dumps and disable faulthandler before exit\n+    # to prevent it from interfering with C extension cleanup\n+    def cleanup_faulthandler():\n+        with suppress(Exception):\n+            faulthandler.cancel_dump_traceback_later()\n+        with suppress(Exception):\n+            faulthandler.disable()\n+\n+    atexit.register(cleanup_faulthandler)\n+\n+    # Set up periodic traceback dumps for debugging hanging tests/threads\n+    faulthandler.dump_traceback_later(timeout=300, repeat=True, file=sys.stderr)\n+\n+\n+@contextlib.contextmanager\n+def _mysql_lock_session_for_migration(original_session: Session) -> Generator[Session, None, None]:\n+    \"\"\"\n+    Create a MySQL-specific lock session for migration operations.\n+\n+    This context manager:\n+    1. Commits the original session to release metadata locks\n+    2. Creates a new session bound to the engine\n+    3. Ensures the session is properly closed on exit\n+\n+    :param original_session: The original session to commit\n+    :return: A new session suitable for use with create_global_lock\n+    \"\"\"\n+    from sqlalchemy.orm import Session as SASession\n+\n+    log.info(\"MySQL: Committing session to release metadata locks\")\n+    original_session.commit()\n+\n+    lock_session = SASession(bind=settings.engine)\n+    try:\n+        yield lock_session\n+    finally:\n+        lock_session.close()\n \n-    threading.Thread(target=dump_stacks, daemon=True).start()\n+\n+@contextlib.contextmanager\n+def _single_connection_pool() -> Generator[None, None, None]:\n+    \"\"\"\n+    Temporarily reconfigure ORM to use exactly one connection.\n+\n+    This is needed for migrations because some database engines hang forever\n+    trying to ALTER TABLEs when multiple connections exist in the pool.\n+\n+    Saves and restores the AIRFLOW__DATABASE__SQL_ALCHEMY_MAX_SIZE environment variable.\n+    \"\"\"\n+    import sqlalchemy.pool\n+\n+    val = os.environ.get(\"AIRFLOW__DATABASE__SQL_ALCHEMY_MAX_SIZE\")",
      "comment": "It is a nit pick, but giving the `val` variable a better name could be nice",
      "comment_id": 2646176955,
      "user": "Nataneljpwd",
      "created_at": "2025-12-24T19:15:33Z",
      "url": "https://github.com/apache/airflow/pull/59218#discussion_r2646176955"
    },
    {
      "repo": "apache/airflow",
      "pr_number": 59218,
      "file_path": "airflow-core/src/airflow/utils/db.py",
      "line": 816,
      "side": "RIGHT",
      "diff_hunk": "@@ -700,39 +721,102 @@ def _create_db_from_orm(session):\n         log.info(\"Getting alembic config\")\n         config = _get_alembic_config()\n \n-        # Use AUTOCOMMIT for DDL to avoid metadata lock issues\n-        with AutocommitEngineForMySQL():  # TODO: enable for sqlite too\n-            from alembic import command\n+        log.info(\"Stamping migration head\")\n+        command.stamp(config, \"head\")\n \n-            log.info(\"Stamping migration head\")\n-            command.stamp(config, \"head\")\n+    log.info(\"Airflow database tables created\")\n+\n+\n+def _create_db_from_orm(session):\n+    \"\"\"Create database tables from ORM models and stamp alembic version.\"\"\"\n+    log.info(\"Creating Airflow database tables from the ORM\")\n+    _setup_debug_logging_if_needed()\n \n-        log.info(\"Airflow database tables created\")\n+    if get_dialect_name(session) == \"mysql\":\n+        _create_db_from_orm_mysql(session)\n+    else:\n+        _create_db_from_orm_default(session)\n \n \n def _setup_debug_logging_if_needed():\n     \"\"\"Set up debug logging and stack trace dumping if SQLALCHEMY_ENGINE_DEBUG is set.\"\"\"\n     if not os.environ.get(\"SQLALCHEMY_ENGINE_DEBUG\"):\n         return\n \n+    import atexit\n     import faulthandler\n-    import threading\n+    from contextlib import suppress\n \n     # Enable SQLA debug logging\n     logging.getLogger(\"sqlalchemy.engine\").setLevel(logging.DEBUG)\n \n-    # Enable Fault Handler\n+    # Enable faulthandler for debugging long-running threads and deadlocks,\n+    # but disable it before interpreter shutdown to avoid segfaults during\n+    # cleanup (especially with SQLAlchemy 2.0 + pytest teardown)\n     faulthandler.enable(file=sys.stderr, all_threads=True)\n \n-    # Print Active Threads and Stack Traces Periodically\n-    def dump_stacks():\n-        while True:\n-            for thread_id, frame in sys._current_frames().items():\n-                log.info(\"\\nThread %s stack:\", thread_id)\n-                traceback.print_stack(frame)\n-            time.sleep(300)\n+    # Cancel any pending traceback dumps and disable faulthandler before exit\n+    # to prevent it from interfering with C extension cleanup\n+    def cleanup_faulthandler():\n+        with suppress(Exception):\n+            faulthandler.cancel_dump_traceback_later()\n+        with suppress(Exception):\n+            faulthandler.disable()\n+\n+    atexit.register(cleanup_faulthandler)\n+\n+    # Set up periodic traceback dumps for debugging hanging tests/threads\n+    faulthandler.dump_traceback_later(timeout=300, repeat=True, file=sys.stderr)\n+\n+\n+@contextlib.contextmanager\n+def _mysql_lock_session_for_migration(original_session: Session) -> Generator[Session, None, None]:\n+    \"\"\"\n+    Create a MySQL-specific lock session for migration operations.\n+\n+    This context manager:\n+    1. Commits the original session to release metadata locks\n+    2. Creates a new session bound to the engine\n+    3. Ensures the session is properly closed on exit\n+\n+    :param original_session: The original session to commit\n+    :return: A new session suitable for use with create_global_lock\n+    \"\"\"\n+    from sqlalchemy.orm import Session as SASession\n+\n+    log.info(\"MySQL: Committing session to release metadata locks\")\n+    original_session.commit()\n+\n+    lock_session = SASession(bind=settings.engine)\n+    try:\n+        yield lock_session\n+    finally:\n+        lock_session.close()\n \n-    threading.Thread(target=dump_stacks, daemon=True).start()\n+\n+@contextlib.contextmanager\n+def _single_connection_pool() -> Generator[None, None, None]:\n+    \"\"\"\n+    Temporarily reconfigure ORM to use exactly one connection.\n+\n+    This is needed for migrations because some database engines hang forever\n+    trying to ALTER TABLEs when multiple connections exist in the pool.\n+\n+    Saves and restores the AIRFLOW__DATABASE__SQL_ALCHEMY_MAX_SIZE environment variable.\n+    \"\"\"\n+    import sqlalchemy.pool\n+\n+    val = os.environ.get(\"AIRFLOW__DATABASE__SQL_ALCHEMY_MAX_SIZE\")\n+    try:\n+        os.environ[\"AIRFLOW__DATABASE__SQL_ALCHEMY_MAX_SIZE\"] = \"1\"\n+        settings.reconfigure_orm(pool_class=sqlalchemy.pool.SingletonThreadPool)\n+        yield\n+    finally:\n+        if val is None:\n+            os.environ.pop(\"AIRFLOW__DATABASE__SQL_ALCHEMY_MAX_SIZE\", None)",
      "comment": "do we have to have this if along with the else? and pop environ? can't we just pop the environ always? I think it can be rewritten as such:\r\n```python\r\nos.environ.pop(\"AIRFLOW__DATABASE__SQL_ALCHEMY_MAX_SIZE\", None)\r\nif val:\r\n    os.environ[\"AIRFLOW__DATABASE__SQL_ALCHEMY_MAX_SIZE\"] = val\r\n\r\nsettings.reconfigure_orm()\r\n```",
      "comment_id": 2646182463,
      "user": "Nataneljpwd",
      "created_at": "2025-12-24T19:22:42Z",
      "url": "https://github.com/apache/airflow/pull/59218#discussion_r2646182463"
    },
    {
      "repo": "apache/airflow",
      "pr_number": 59218,
      "file_path": "airflow-core/src/airflow/utils/db.py",
      "line": 1410,
      "side": "RIGHT",
      "diff_hunk": "@@ -1256,14 +1406,16 @@ def _handle_fab_downgrade(*, session: Session) -> None:\n             fab_version,\n         )\n         return\n-    connection = settings.get_engine().connect()\n-    insp = inspect(connection)\n-    if not fab_version and insp.has_table(\"ab_user\"):\n-        log.info(\n-            \"FAB migration version not found, but FAB tables exist. \"\n-            \"FAB provider is not required for downgrade.\",\n-        )\n-        return\n+\n+    # Use context manager to ensure connection is closed",
      "comment": "do we need this comment? as, to me at least, it seems obvious that if I use a context manager for a connection, it is to ensure it's closed when I finish",
      "comment_id": 2646187195,
      "user": "Nataneljpwd",
      "created_at": "2025-12-24T19:28:42Z",
      "url": "https://github.com/apache/airflow/pull/59218#discussion_r2646187195"
    },
    {
      "repo": "apache/airflow",
      "pr_number": 59218,
      "file_path": "airflow-core/src/airflow/utils/db.py",
      "line": 1510,
      "side": "RIGHT",
      "diff_hunk": "@@ -1340,58 +1498,108 @@ def __str__(self):\n \n \n @contextlib.contextmanager\n-def create_global_lock(\n-    session: Session,\n-    lock: DBLocks,\n-    lock_timeout: int = 1800,\n+def _create_global_lock_mysql(lock: DBLocks, lock_timeout: int) -> Generator[None, None, None]:\n+    \"\"\"\n+    Create a global advisory lock for MySQL.\n+\n+    Uses a dedicated AUTOCOMMIT connection because:\n+    - GET_LOCK is session-level, not transaction-level\n+    - DDL operations cause implicit commits that would break transaction wrappers\n+    \"\"\"\n+    server_version = settings.get_engine().dialect.server_version_info\n+    if not (server_version and server_version >= (5, 6)):",
      "comment": "According to [this](https://airflow.apache.org/docs/apache-airflow/3.1.5/installation/prerequisites.html), airflow 3 does not support versions lower than mysql 8, and even [airflow 2.1.4](https://airflow.apache.org/docs/apache-airflow/2.1.4/installation/prerequisites.html) supported mysql 5.7 and above, so this if can probably be removed",
      "comment_id": 2646189104,
      "user": "Nataneljpwd",
      "created_at": "2025-12-24T19:31:37Z",
      "url": "https://github.com/apache/airflow/pull/59218#discussion_r2646189104"
    },
    {
      "repo": "apache/airflow",
      "pr_number": 59218,
      "file_path": "airflow-core/src/airflow/utils/db_manager.py",
      "line": 61,
      "side": "RIGHT",
      "diff_hunk": "@@ -48,6 +49,21 @@ def __init__(self, session):\n         super().__init__()\n         self.session = session\n \n+    def _release_mysql_metadata_locks(self) -> None:\n+        \"\"\"\n+        Release MySQL metadata locks by committing the session.\n+\n+        MySQL requires metadata locks to be released before DDL operations.\n+        This is done by committing the current transaction.\n+        This method is a no-op for non-MySQL databases.\n+        \"\"\"\n+        if get_dialect_name(self.session) != \"mysql\":\n+            return",
      "comment": "is this really needed? is it ever used **not** for mysql? it does have mysql in it's name, so logically, someone won't use it for pgsql, at least in my opinion it is simpler and more intuitive to check the dialect wherever I use the method rather than do it in the method, as it can cause confusion when first getting into this code.",
      "comment_id": 2646193056,
      "user": "Nataneljpwd",
      "created_at": "2025-12-24T19:36:18Z",
      "url": "https://github.com/apache/airflow/pull/59218#discussion_r2646193056"
    },
    {
      "repo": "apache/airflow",
      "pr_number": 59218,
      "file_path": "airflow-core/src/airflow/utils/db_manager.py",
      "line": 61,
      "side": "RIGHT",
      "diff_hunk": "@@ -48,6 +49,21 @@ def __init__(self, session):\n         super().__init__()\n         self.session = session\n \n+    def _release_mysql_metadata_locks(self) -> None:\n+        \"\"\"\n+        Release MySQL metadata locks by committing the session.\n+\n+        MySQL requires metadata locks to be released before DDL operations.\n+        This is done by committing the current transaction.\n+        This method is a no-op for non-MySQL databases.\n+        \"\"\"\n+        if get_dialect_name(self.session) != \"mysql\":\n+            return",
      "comment": "The method is not MySQL-specific in its usage pattern; it's a utility method that happens to only do work for MySQL today. Removing the check would require adding dialect checks at all 4 call sites (which was removed in response to your previous comment).\r\n\r\nI renamed the method to `_release_metadata_locks_if_needed` so that:\r\n\r\n- Generic name matches the generic usage pattern (called for all dialects)\r\n- `_if_needed` suffix clearly signals conditional behavior\r\n- Docstring already explains it's MySQL-specific internally\r\n- Future-proof - if another DB ever needs similar handling, the name still works\r\n- No cognitive dissonance from calling a \"mysql\" method on another dialect\r\n",
      "comment_id": 2646699200,
      "user": "Dev-iL",
      "created_at": "2025-12-25T07:57:45Z",
      "url": "https://github.com/apache/airflow/pull/59218#discussion_r2646699200"
    },
    {
      "repo": "apache/airflow",
      "pr_number": 59218,
      "file_path": "airflow-core/src/airflow/utils/db.py",
      "line": 793,
      "side": "RIGHT",
      "diff_hunk": "@@ -700,39 +721,101 @@ def _create_db_from_orm(session):\n         log.info(\"Getting alembic config\")\n         config = _get_alembic_config()\n \n-        # Use AUTOCOMMIT for DDL to avoid metadata lock issues\n-        with AutocommitEngineForMySQL():  # TODO: enable for sqlite too\n-            from alembic import command\n+        log.info(\"Stamping migration head\")\n+        command.stamp(config, \"head\")\n \n-            log.info(\"Stamping migration head\")\n-            command.stamp(config, \"head\")\n+    log.info(\"Airflow database tables created\")\n \n-        log.info(\"Airflow database tables created\")\n+\n+def _create_db_from_orm(session):\n+    \"\"\"Create database tables from ORM models and stamp alembic version.\"\"\"\n+    log.info(\"Creating Airflow database tables from the ORM\")\n+    _setup_debug_logging_if_needed()\n+\n+    if get_dialect_name(session) == \"mysql\":\n+        _create_db_from_orm_mysql(session)\n+    else:\n+        _create_db_from_orm_default(session)\n \n \n def _setup_debug_logging_if_needed():\n     \"\"\"Set up debug logging and stack trace dumping if SQLALCHEMY_ENGINE_DEBUG is set.\"\"\"\n     if not os.environ.get(\"SQLALCHEMY_ENGINE_DEBUG\"):\n         return\n \n+    import atexit\n     import faulthandler\n-    import threading\n+    from contextlib import suppress\n \n     # Enable SQLA debug logging\n     logging.getLogger(\"sqlalchemy.engine\").setLevel(logging.DEBUG)\n \n-    # Enable Fault Handler\n+    # Enable faulthandler for debugging long-running threads and deadlocks,\n+    # but disable it before interpreter shutdown to avoid segfaults during\n+    # cleanup (especially with SQLAlchemy 2.0 + pytest teardown)\n     faulthandler.enable(file=sys.stderr, all_threads=True)\n \n-    # Print Active Threads and Stack Traces Periodically\n-    def dump_stacks():\n-        while True:\n-            for thread_id, frame in sys._current_frames().items():\n-                log.info(\"\\nThread %s stack:\", thread_id)\n-                traceback.print_stack(frame)\n-            time.sleep(300)\n+    # Cancel any pending traceback dumps and disable faulthandler before exit\n+    # to prevent it from interfering with C extension cleanup\n+    def cleanup_faulthandler():\n+        with suppress(Exception):\n+            faulthandler.cancel_dump_traceback_later()\n+        with suppress(Exception):\n+            faulthandler.disable()\n+\n+    atexit.register(cleanup_faulthandler)\n+\n+    # Set up periodic traceback dumps for debugging hanging tests/threads\n+    faulthandler.dump_traceback_later(timeout=300, repeat=True, file=sys.stderr)\n+\n \n-    threading.Thread(target=dump_stacks, daemon=True).start()\n+@contextlib.contextmanager\n+def _mysql_lock_session_for_migration(original_session: Session) -> Generator[Session, None, None]:\n+    \"\"\"\n+    Create a MySQL-specific lock session for migration operations.\n+\n+    This context manager:\n+    1. Commits the original session to release metadata locks\n+    2. Creates a new session bound to the engine\n+    3. Ensures the session is properly closed on exit\n+\n+    :param original_session: The original session to commit\n+    :return: A new session suitable for use with create_global_lock\n+    \"\"\"\n+    from sqlalchemy.orm import Session as SASession\n+\n+    log.info(\"MySQL: Committing session to release metadata locks\")\n+    original_session.commit()\n+\n+    lock_session = SASession(bind=settings.engine)",
      "comment": "Inconsistent engine access pattern: Line 790 uses `settings.engine` directly, while most other places in this file use `settings.get_engine()` (e.g., lines 1151, 1255, 1281, 1507). For consistency and better compatibility with SQLAlchemy 2.0's engine management, consider using `settings.get_engine()` here as well.\n```suggestion\n    lock_session = SASession(bind=settings.get_engine())\n```",
      "comment_id": 2648327288,
      "user": "Copilot",
      "created_at": "2025-12-26T14:41:18Z",
      "url": "https://github.com/apache/airflow/pull/59218#discussion_r2648327288"
    },
    {
      "repo": "apache/airflow",
      "pr_number": 59218,
      "file_path": "airflow-core/src/airflow/utils/db.py",
      "line": 1365,
      "side": "RIGHT",
      "diff_hunk": "@@ -1203,18 +1338,32 @@ def downgrade(*, to_revision, from_revision=None, show_sql_only=False, session:\n \n     log.info(\"Attempting downgrade to revision %s\", to_revision)\n     config = _get_alembic_config()\n+\n     # If downgrading to less than 3.0.0, we need to handle the FAB provider\n     if _revision_greater(config, _REVISION_HEADS_MAP[\"2.10.3\"], to_revision):\n         _handle_fab_downgrade(session=session)\n-    with create_global_lock(session=session, lock=DBLocks.MIGRATIONS):\n+\n+    # Determine which session to use for the migration operations\n+    if get_dialect_name(session) == \"mysql\":\n+        # MySQL: Commit session to release metadata locks before Alembic DDL\n+        session_cm: contextlib.AbstractContextManager[Session] = _mysql_lock_session_for_migration(session)\n+    else:\n+        # PostgreSQL / SQLite: Use original session\n+        session_cm = contextlib.nullcontext(session)\n+\n+    with (\n+        session_cm as work_session,\n+        create_global_lock(session=work_session, lock=DBLocks.MIGRATIONS),\n+    ):\n         if show_sql_only:\n             log.warning(\"Generating sql scripts for manual migration.\")\n             if not from_revision:\n-                from_revision = _get_current_revision(session)\n+                from_revision = _get_current_revision(work_session)\n             revision_range = f\"{from_revision}:{to_revision}\"\n             _offline_migration(command.downgrade, config=config, revision=revision_range)\n         else:\n-            log.info(\"Applying downgrade migrations to Airflow database.\")\n+            dialect_label = \" (MySQL)\" if get_dialect_name(session) == \"mysql\" else \"\"",
      "comment": "Inconsistent session usage: Line 1365 calls `get_dialect_name(session)` using the original session parameter, but we're inside a context where `work_session` is the active session being used for operations. For consistency, this should use `get_dialect_name(work_session)` instead. This could be problematic for MySQL where the original session has been committed and a new session created.\n```suggestion\n            dialect_label = \" (MySQL)\" if get_dialect_name(work_session) == \"mysql\" else \"\"\n```",
      "comment_id": 2648327300,
      "user": "Copilot",
      "created_at": "2025-12-26T14:41:19Z",
      "url": "https://github.com/apache/airflow/pull/59218#discussion_r2648327300"
    },
    {
      "repo": "apache/airflow",
      "pr_number": 59218,
      "file_path": "airflow-core/src/airflow/utils/db_manager.py",
      "line": 129,
      "side": "RIGHT",
      "diff_hunk": "@@ -107,6 +124,8 @@ def drop_tables(self, connection):\n     def resetdb(self, skip_init=False):\n         from airflow.utils.db import DBLocks, create_global_lock\n \n+        self._release_metadata_locks_if_needed()\n+\n         connection = settings.engine.connect()",
      "comment": "Inconsistent engine access: Line 129 uses `settings.engine.connect()` directly, while the rest of the codebase predominantly uses `settings.get_engine().connect()`. For consistency with the SQLAlchemy 2.0 upgrade and the patterns used elsewhere in this PR (see db.py lines 1151, 1255, 1281, 1507), this should use `settings.get_engine()` instead of accessing the `engine` attribute directly.\n```suggestion\n        connection = settings.get_engine().connect()\n```",
      "comment_id": 2648327305,
      "user": "Copilot",
      "created_at": "2025-12-26T14:41:19Z",
      "url": "https://github.com/apache/airflow/pull/59218#discussion_r2648327305"
    },
    {
      "repo": "apache/airflow",
      "pr_number": 59218,
      "file_path": "providers/fab/tests/unit/fab/auth_manager/test_fab_auth_manager.py",
      "line": 904,
      "side": "RIGHT",
      "diff_hunk": "@@ -888,20 +888,26 @@ def test_get_db_manager(self, auth_manager):\n @mock.patch(\"airflow.utils.db.drop_airflow_models\")\n @mock.patch(\"airflow.utils.db.drop_airflow_moved_tables\")\n @mock.patch(\"airflow.utils.db.initdb\")\n-@mock.patch(\"airflow.settings.engine.connect\")\n+@mock.patch(\"airflow.settings.engine\")\n def test_resetdb(\n-    mock_connect,\n+    mock_engine,\n     mock_init,\n     mock_drop_moved,\n     mock_drop_airflow,\n     mock_fabdb_manager,\n     skip_init,\n ):\n+    # Mock as non-MySQL to use the simpler PostgreSQL/SQLite path\n+    mock_engine.dialect.name = \"postgresql\"\n+    mock_connect = mock_engine.connect.return_value\n+\n     session_mock = MagicMock()",
      "comment": "Incomplete test setup: The test sets `mock_engine.dialect.name = \"postgresql\"` to test the non-MySQL path, but `get_dialect_name(session)` gets the dialect from `session.get_bind().dialect.name`, not from `settings.engine`. The test should also configure `session_mock.get_bind().dialect.name` to ensure it returns \"postgresql\" so that the code correctly identifies this as the PostgreSQL path. Without this, the test may not actually be testing the intended code path.\n```suggestion\n    session_mock = MagicMock()\n    # Ensure the session's bind also reports a PostgreSQL dialect, matching the non-MySQL path\n    bind_mock = session_mock.get_bind.return_value\n    bind_mock.dialect.name = \"postgresql\"\n```",
      "comment_id": 2648327312,
      "user": "Copilot",
      "created_at": "2025-12-26T14:41:19Z",
      "url": "https://github.com/apache/airflow/pull/59218#discussion_r2648327312"
    },
    {
      "repo": "apache/airflow",
      "pr_number": 59218,
      "file_path": "airflow-core/src/airflow/utils/db.py",
      "line": 1285,
      "side": "RIGHT",
      "diff_hunk": "@@ -1120,38 +1235,56 @@ def upgradedb(\n         exit(1)\n \n     if not _get_current_revision(session=session) and not to_revision:\n-        # Don't load default connections\n         # New DB; initialize and exit\n         initdb(session=session)\n         return\n-    with create_global_lock(session=session, lock=DBLocks.MIGRATIONS):\n-        import sqlalchemy.pool\n \n-        log.info(\"Migrating the Airflow database\")\n-        val = os.environ.get(\"AIRFLOW__DATABASE__SQL_ALCHEMY_MAX_SIZE\")\n-        try:\n-            # Reconfigure the ORM to use _EXACTLY_ one connection, otherwise some db engines hang forever\n-            # trying to ALTER TABLEs\n-            os.environ[\"AIRFLOW__DATABASE__SQL_ALCHEMY_MAX_SIZE\"] = \"1\"\n-            settings.reconfigure_orm(pool_class=sqlalchemy.pool.SingletonThreadPool)\n-            command.upgrade(config, revision=to_revision or \"heads\")\n-            current_revision = _get_current_revision(session=session)\n-            with _configured_alembic_environment() as env:\n-                source_heads = env.script.get_heads()\n-            if current_revision == source_heads[0]:\n-                # Only run external DB upgrade migration if user upgraded to heads\n+    _run_upgradedb(config, to_revision, session)\n+\n+\n+def _resetdb_mysql(session: Session) -> None:\n+    \"\"\"Drop all Airflow tables for MySQL.\"\"\"\n+    from sqlalchemy.orm import Session as SASession\n+\n+    # MySQL: Release metadata locks and use AUTOCOMMIT for DDL\n+    log.info(\"MySQL: Releasing metadata locks before DDL operations\")\n+    session.commit()\n+    session.close()\n+\n+    # Use create_global_lock for migration safety (now handles MySQL with AUTOCOMMIT)\n+    engine = settings.get_engine()\n+    lock_session = SASession(bind=engine)\n+    try:\n+        with (\n+            create_global_lock(session=lock_session, lock=DBLocks.MIGRATIONS),\n+            engine.connect() as connection,\n+        ):\n+            ddl_conn = connection.execution_options(isolation_level=\"AUTOCOMMIT\")\n+\n+            drop_airflow_models(ddl_conn)\n+            drop_airflow_moved_tables(ddl_conn)\n+            log.info(\"Dropped all Airflow tables\")\n+\n+            # Use raw Session to avoid scoped session issues\n+            work_session = SASession(bind=ddl_conn)\n+            try:\n                 external_db_manager = RunDBManager()\n-                external_db_manager.upgradedb(session)\n+                external_db_manager.drop_tables(work_session, ddl_conn)\n+            finally:\n+                work_session.close()\n+    finally:\n+        lock_session.close()\n \n-        finally:\n-            if val is None:\n-                os.environ.pop(\"AIRFLOW__DATABASE__SQL_ALCHEMY_MAX_SIZE\")\n-            else:\n-                os.environ[\"AIRFLOW__DATABASE__SQL_ALCHEMY_MAX_SIZE\"] = val\n-            settings.reconfigure_orm()\n \n-        add_default_pool_if_not_exists(session=session)\n-        synchronize_log_template(session=session)\n+def _resetdb_default(session: Session) -> None:\n+    \"\"\"Drop all Airflow tables for PostgreSQL/SQLite.\"\"\"\n+    connection = settings.get_engine().connect()\n+    with create_global_lock(session=session, lock=DBLocks.MIGRATIONS), connection.begin():",
      "comment": "Connection resource leak: The connection created by `settings.get_engine().connect()` is not properly closed. Unlike the MySQL path which uses a context manager (`with engine.connect() as connection`), this connection is never explicitly closed. In SQLAlchemy 2.0, proper connection management is more critical. This should be wrapped in a context manager to ensure the connection is properly closed.\n```suggestion\n    engine = settings.get_engine()\n    with engine.connect() as connection, create_global_lock(session=session, lock=DBLocks.MIGRATIONS), connection.begin():\n```",
      "comment_id": 2648327318,
      "user": "Copilot",
      "created_at": "2025-12-26T14:41:20Z",
      "url": "https://github.com/apache/airflow/pull/59218#discussion_r2648327318"
    },
    {
      "repo": "apache/airflow",
      "pr_number": 59218,
      "file_path": "airflow-core/src/airflow/utils/db.py",
      "line": 1176,
      "side": "RIGHT",
      "diff_hunk": "@@ -1061,6 +1144,38 @@ def _revisions_above_min_for_offline(config, revisions) -> None:\n             )\n \n \n+def _run_upgradedb(config, to_revision: str | None, session: Session) -> None:\n+    \"\"\"Run database upgrade with appropriate locking for the dialect.\"\"\"\n+    from alembic import command\n+\n+    is_mysql = settings.get_engine().dialect.name == \"mysql\"\n+    dialect_label = \" (MySQL)\" if is_mysql else \"\"\n+    log.info(\"Migrating the Airflow database%s\", dialect_label)\n+\n+    # MySQL needs a separate lock session; others use the original session\n+    session_cm: contextlib.AbstractContextManager[Session] = (\n+        _mysql_lock_session_for_migration(session) if is_mysql else contextlib.nullcontext(session)\n+    )\n+\n+    with (\n+        session_cm as work_session,\n+        create_global_lock(session=work_session, lock=DBLocks.MIGRATIONS),\n+        _single_connection_pool(),\n+    ):\n+        command.upgrade(config, revision=to_revision or \"heads\")\n+\n+        current_revision = _get_current_revision(session=work_session)\n+        with _configured_alembic_environment() as env:\n+            source_heads = env.script.get_heads()\n+\n+        if current_revision == source_heads[0]:\n+            external_db_manager = RunDBManager()\n+            external_db_manager.upgradedb(work_session)\n+\n+    add_default_pool_if_not_exists(session=work_session)\n+    synchronize_log_template(session=work_session)",
      "comment": "Session used after closure: For MySQL, `work_session` is created by `_mysql_lock_session_for_migration` and will be closed when the context manager exits at line 1174. However, lines 1175-1176 attempt to use `work_session` after it has been closed, which will cause errors. These calls should either be moved inside the context manager or use the original `session` parameter instead of `work_session`.\n```suggestion\n        add_default_pool_if_not_exists(session=work_session)\n        synchronize_log_template(session=work_session)\n```",
      "comment_id": 2648327321,
      "user": "Copilot",
      "created_at": "2025-12-26T14:41:20Z",
      "url": "https://github.com/apache/airflow/pull/59218#discussion_r2648327321"
    },
    {
      "repo": "apache/airflow",
      "pr_number": 59218,
      "file_path": "airflow-core/src/airflow/utils/db.py",
      "line": 816,
      "side": "RIGHT",
      "diff_hunk": "@@ -700,39 +721,101 @@ def _create_db_from_orm(session):\n         log.info(\"Getting alembic config\")\n         config = _get_alembic_config()\n \n-        # Use AUTOCOMMIT for DDL to avoid metadata lock issues\n-        with AutocommitEngineForMySQL():  # TODO: enable for sqlite too\n-            from alembic import command\n+        log.info(\"Stamping migration head\")\n+        command.stamp(config, \"head\")\n \n-            log.info(\"Stamping migration head\")\n-            command.stamp(config, \"head\")\n+    log.info(\"Airflow database tables created\")\n \n-        log.info(\"Airflow database tables created\")\n+\n+def _create_db_from_orm(session):\n+    \"\"\"Create database tables from ORM models and stamp alembic version.\"\"\"\n+    log.info(\"Creating Airflow database tables from the ORM\")\n+    _setup_debug_logging_if_needed()\n+\n+    if get_dialect_name(session) == \"mysql\":\n+        _create_db_from_orm_mysql(session)\n+    else:\n+        _create_db_from_orm_default(session)\n \n \n def _setup_debug_logging_if_needed():\n     \"\"\"Set up debug logging and stack trace dumping if SQLALCHEMY_ENGINE_DEBUG is set.\"\"\"\n     if not os.environ.get(\"SQLALCHEMY_ENGINE_DEBUG\"):\n         return\n \n+    import atexit\n     import faulthandler\n-    import threading\n+    from contextlib import suppress\n \n     # Enable SQLA debug logging\n     logging.getLogger(\"sqlalchemy.engine\").setLevel(logging.DEBUG)\n \n-    # Enable Fault Handler\n+    # Enable faulthandler for debugging long-running threads and deadlocks,\n+    # but disable it before interpreter shutdown to avoid segfaults during\n+    # cleanup (especially with SQLAlchemy 2.0 + pytest teardown)\n     faulthandler.enable(file=sys.stderr, all_threads=True)\n \n-    # Print Active Threads and Stack Traces Periodically\n-    def dump_stacks():\n-        while True:\n-            for thread_id, frame in sys._current_frames().items():\n-                log.info(\"\\nThread %s stack:\", thread_id)\n-                traceback.print_stack(frame)\n-            time.sleep(300)\n+    # Cancel any pending traceback dumps and disable faulthandler before exit\n+    # to prevent it from interfering with C extension cleanup\n+    def cleanup_faulthandler():\n+        with suppress(Exception):\n+            faulthandler.cancel_dump_traceback_later()\n+        with suppress(Exception):\n+            faulthandler.disable()\n+\n+    atexit.register(cleanup_faulthandler)\n+\n+    # Set up periodic traceback dumps for debugging hanging tests/threads\n+    faulthandler.dump_traceback_later(timeout=300, repeat=True, file=sys.stderr)\n+\n \n-    threading.Thread(target=dump_stacks, daemon=True).start()\n+@contextlib.contextmanager\n+def _mysql_lock_session_for_migration(original_session: Session) -> Generator[Session, None, None]:\n+    \"\"\"\n+    Create a MySQL-specific lock session for migration operations.\n+\n+    This context manager:\n+    1. Commits the original session to release metadata locks\n+    2. Creates a new session bound to the engine\n+    3. Ensures the session is properly closed on exit\n+\n+    :param original_session: The original session to commit\n+    :return: A new session suitable for use with create_global_lock\n+    \"\"\"\n+    from sqlalchemy.orm import Session as SASession\n+\n+    log.info(\"MySQL: Committing session to release metadata locks\")\n+    original_session.commit()\n+\n+    lock_session = SASession(bind=settings.engine)\n+    try:\n+        yield lock_session\n+    finally:\n+        lock_session.close()\n+\n+\n+@contextlib.contextmanager\n+def _single_connection_pool() -> Generator[None, None, None]:\n+    \"\"\"\n+    Temporarily reconfigure ORM to use exactly one connection.\n+\n+    This is needed for migrations because some database engines hang forever\n+    trying to ALTER TABLEs when multiple connections exist in the pool.\n+\n+    Saves and restores the AIRFLOW__DATABASE__SQL_ALCHEMY_MAX_SIZE environment variable.\n+    \"\"\"\n+    import sqlalchemy.pool\n+\n+    previous_pool_size = os.environ.get(\"AIRFLOW__DATABASE__SQL_ALCHEMY_MAX_SIZE\")\n+    try:\n+        os.environ[\"AIRFLOW__DATABASE__SQL_ALCHEMY_MAX_SIZE\"] = \"1\"\n+        settings.reconfigure_orm(pool_class=sqlalchemy.pool.SingletonThreadPool)\n+        yield\n+    finally:\n+        os.environ.pop(\"AIRFLOW__DATABASE__SQL_ALCHEMY_MAX_SIZE\", None)\n+        if previous_pool_size:",
      "comment": "Potential environment variable restoration issue: Line 815 uses `os.environ.pop()` which could fail if the key doesn't exist (though it shouldn't in this case). More importantly, if `previous_pool_size` was an empty string (which is valid), line 816 will not restore it because empty strings are falsy. Consider using `if previous_pool_size is not None:` instead of `if previous_pool_size:` to properly handle empty string values.\n```suggestion\n        if previous_pool_size is not None:\n```",
      "comment_id": 2648327334,
      "user": "Copilot",
      "created_at": "2025-12-26T14:41:20Z",
      "url": "https://github.com/apache/airflow/pull/59218#discussion_r2648327334"
    },
    {
      "repo": "apache/airflow",
      "pr_number": 59218,
      "file_path": "airflow-core/src/airflow/utils/db.py",
      "line": 1543,
      "side": "RIGHT",
      "diff_hunk": "@@ -1340,58 +1496,102 @@ def __str__(self):\n \n \n @contextlib.contextmanager\n-def create_global_lock(\n-    session: Session,\n-    lock: DBLocks,\n-    lock_timeout: int = 1800,\n+def _create_global_lock_mysql(lock: DBLocks, lock_timeout: int) -> Generator[None, None, None]:\n+    \"\"\"\n+    Create a global advisory lock for MySQL.\n+\n+    Uses a dedicated AUTOCOMMIT connection because:\n+    - GET_LOCK is session-level, not transaction-level\n+    - DDL operations cause implicit commits that would break transaction wrappers\n+    \"\"\"\n+    lock_conn = settings.get_engine().connect()\n+    try:\n+        lock_conn = lock_conn.execution_options(isolation_level=\"AUTOCOMMIT\")\n+\n+        # GET_LOCK returns: 1 = acquired, 0 = timeout, NULL = error\n+        lock_result = lock_conn.execute(\n+            text(\"SELECT GET_LOCK(:lock_name, :timeout)\"),\n+            {\"lock_name\": str(lock), \"timeout\": lock_timeout},\n+        ).scalar()\n+\n+        if lock_result != 1:\n+            raise RuntimeError(\n+                f\"Could not acquire MySQL advisory lock '{lock}'. \"\n+                f\"Result: {lock_result}. Another process may be holding the lock.\"\n+            )\n+\n+        try:\n+            yield\n+        finally:\n+            lock_conn.execute(text(\"SELECT RELEASE_LOCK(:lock_name)\"), {\"lock_name\": str(lock)})\n+    finally:\n+        lock_conn.close()\n+\n+\n+@contextlib.contextmanager\n+def _create_global_lock_postgresql(\n+    session: Session, lock: DBLocks, lock_timeout: int\n ) -> Generator[None, None, None]:\n-    \"\"\"Contextmanager that will create and teardown a global db lock.\"\"\"\n+    \"\"\"Create a global advisory lock for PostgreSQL using transactional advisory locks.\"\"\"\n     bind = session.get_bind()\n     if hasattr(bind, \"connect\"):\n         conn = bind.connect()\n     else:\n         conn = bind",
      "comment": "Potential connection leak in PostgreSQL lock: Lines 1537-1540 create a new connection if `bind` has a `connect` method, but this connection is never explicitly closed in the `finally` block. In SQLAlchemy 2.0, proper connection lifecycle management is critical. If a new connection is created at line 1538, it should be closed in the finally block to prevent resource leaks.",
      "comment_id": 2648327339,
      "user": "Copilot",
      "created_at": "2025-12-26T14:41:20Z",
      "url": "https://github.com/apache/airflow/pull/59218#discussion_r2648327339"
    },
    {
      "repo": "apache/airflow",
      "pr_number": 59218,
      "file_path": "providers/fab/tests/unit/fab/auth_manager/test_fab_auth_manager.py",
      "line": 891,
      "side": "RIGHT",
      "diff_hunk": "@@ -888,20 +888,26 @@ def test_get_db_manager(self, auth_manager):\n @mock.patch(\"airflow.utils.db.drop_airflow_models\")\n @mock.patch(\"airflow.utils.db.drop_airflow_moved_tables\")\n @mock.patch(\"airflow.utils.db.initdb\")\n-@mock.patch(\"airflow.settings.engine.connect\")\n+@mock.patch(\"airflow.settings.engine\")",
      "comment": "Test mocking mismatch: The test mocks `airflow.settings.engine` (line 891), but the actual code in `_resetdb_default` calls `settings.get_engine()` (line 1281 of db.py). While this might work if `get_engine()` returns the `engine` attribute, this creates a fragile dependency. The test should mock `airflow.settings.get_engine` instead to match the actual implementation, or verify that the mocked `engine` is returned by `get_engine()`.",
      "comment_id": 2648327342,
      "user": "Copilot",
      "created_at": "2025-12-26T14:41:21Z",
      "url": "https://github.com/apache/airflow/pull/59218#discussion_r2648327342"
    },
    {
      "repo": "apache/airflow",
      "pr_number": 59218,
      "file_path": "providers/fab/tests/unit/fab/auth_manager/test_fab_auth_manager.py",
      "line": 891,
      "side": "RIGHT",
      "diff_hunk": "@@ -888,20 +888,26 @@ def test_get_db_manager(self, auth_manager):\n @mock.patch(\"airflow.utils.db.drop_airflow_models\")\n @mock.patch(\"airflow.utils.db.drop_airflow_moved_tables\")\n @mock.patch(\"airflow.utils.db.initdb\")\n-@mock.patch(\"airflow.settings.engine.connect\")\n+@mock.patch(\"airflow.settings.engine\")",
      "comment": "The current approach works correctly because `mock.patch(\"airflow.settings.engine\")` patches the module attribute that `get_engine()` returns. The more critical issue (missing session bind dialect mock) was already addressed in the context of a previous comment.",
      "comment_id": 2648630938,
      "user": "Dev-iL",
      "created_at": "2025-12-26T20:15:40Z",
      "url": "https://github.com/apache/airflow/pull/59218#discussion_r2648630938"
    },
    {
      "repo": "apache/airflow",
      "pr_number": 59218,
      "file_path": "airflow-core/src/airflow/utils/db.py",
      "line": 793,
      "side": "RIGHT",
      "diff_hunk": "@@ -700,39 +721,101 @@ def _create_db_from_orm(session):\n         log.info(\"Getting alembic config\")\n         config = _get_alembic_config()\n \n-        # Use AUTOCOMMIT for DDL to avoid metadata lock issues\n-        with AutocommitEngineForMySQL():  # TODO: enable for sqlite too\n-            from alembic import command\n+        log.info(\"Stamping migration head\")\n+        command.stamp(config, \"head\")\n \n-            log.info(\"Stamping migration head\")\n-            command.stamp(config, \"head\")\n+    log.info(\"Airflow database tables created\")\n \n-        log.info(\"Airflow database tables created\")\n+\n+def _create_db_from_orm(session):\n+    \"\"\"Create database tables from ORM models and stamp alembic version.\"\"\"\n+    log.info(\"Creating Airflow database tables from the ORM\")\n+    _setup_debug_logging_if_needed()\n+\n+    if get_dialect_name(session) == \"mysql\":\n+        _create_db_from_orm_mysql(session)\n+    else:\n+        _create_db_from_orm_default(session)\n \n \n def _setup_debug_logging_if_needed():\n     \"\"\"Set up debug logging and stack trace dumping if SQLALCHEMY_ENGINE_DEBUG is set.\"\"\"\n     if not os.environ.get(\"SQLALCHEMY_ENGINE_DEBUG\"):\n         return\n \n+    import atexit\n     import faulthandler\n-    import threading\n+    from contextlib import suppress\n \n     # Enable SQLA debug logging\n     logging.getLogger(\"sqlalchemy.engine\").setLevel(logging.DEBUG)\n \n-    # Enable Fault Handler\n+    # Enable faulthandler for debugging long-running threads and deadlocks,\n+    # but disable it before interpreter shutdown to avoid segfaults during\n+    # cleanup (especially with SQLAlchemy 2.0 + pytest teardown)\n     faulthandler.enable(file=sys.stderr, all_threads=True)\n \n-    # Print Active Threads and Stack Traces Periodically\n-    def dump_stacks():\n-        while True:\n-            for thread_id, frame in sys._current_frames().items():\n-                log.info(\"\\nThread %s stack:\", thread_id)\n-                traceback.print_stack(frame)\n-            time.sleep(300)\n+    # Cancel any pending traceback dumps and disable faulthandler before exit\n+    # to prevent it from interfering with C extension cleanup\n+    def cleanup_faulthandler():\n+        with suppress(Exception):\n+            faulthandler.cancel_dump_traceback_later()\n+        with suppress(Exception):\n+            faulthandler.disable()\n+\n+    atexit.register(cleanup_faulthandler)\n+\n+    # Set up periodic traceback dumps for debugging hanging tests/threads\n+    faulthandler.dump_traceback_later(timeout=300, repeat=True, file=sys.stderr)\n+\n \n-    threading.Thread(target=dump_stacks, daemon=True).start()\n+@contextlib.contextmanager\n+def _mysql_lock_session_for_migration(original_session: Session) -> Generator[Session, None, None]:\n+    \"\"\"\n+    Create a MySQL-specific lock session for migration operations.\n+\n+    This context manager:\n+    1. Commits the original session to release metadata locks\n+    2. Creates a new session bound to the engine\n+    3. Ensures the session is properly closed on exit\n+\n+    :param original_session: The original session to commit\n+    :return: A new session suitable for use with create_global_lock\n+    \"\"\"\n+    from sqlalchemy.orm import Session as SASession\n+\n+    log.info(\"MySQL: Committing session to release metadata locks\")\n+    original_session.commit()\n+\n+    lock_session = SASession(bind=settings.engine)",
      "comment": "Couldn't get this one working, ended up reverting it. The code behaves differently on 2.x and 3.x - might need to add a compat shim or try/except.",
      "comment_id": 2650249171,
      "user": "Dev-iL",
      "created_at": "2025-12-29T06:01:16Z",
      "url": "https://github.com/apache/airflow/pull/59218#discussion_r2650249171"
    },
    {
      "repo": "apache/airflow",
      "pr_number": 59218,
      "file_path": "airflow-core/src/airflow/utils/db.py",
      "line": 793,
      "side": "RIGHT",
      "diff_hunk": "@@ -700,39 +721,101 @@ def _create_db_from_orm(session):\n         log.info(\"Getting alembic config\")\n         config = _get_alembic_config()\n \n-        # Use AUTOCOMMIT for DDL to avoid metadata lock issues\n-        with AutocommitEngineForMySQL():  # TODO: enable for sqlite too\n-            from alembic import command\n+        log.info(\"Stamping migration head\")\n+        command.stamp(config, \"head\")\n \n-            log.info(\"Stamping migration head\")\n-            command.stamp(config, \"head\")\n+    log.info(\"Airflow database tables created\")\n \n-        log.info(\"Airflow database tables created\")\n+\n+def _create_db_from_orm(session):\n+    \"\"\"Create database tables from ORM models and stamp alembic version.\"\"\"\n+    log.info(\"Creating Airflow database tables from the ORM\")\n+    _setup_debug_logging_if_needed()\n+\n+    if get_dialect_name(session) == \"mysql\":\n+        _create_db_from_orm_mysql(session)\n+    else:\n+        _create_db_from_orm_default(session)\n \n \n def _setup_debug_logging_if_needed():\n     \"\"\"Set up debug logging and stack trace dumping if SQLALCHEMY_ENGINE_DEBUG is set.\"\"\"\n     if not os.environ.get(\"SQLALCHEMY_ENGINE_DEBUG\"):\n         return\n \n+    import atexit\n     import faulthandler\n-    import threading\n+    from contextlib import suppress\n \n     # Enable SQLA debug logging\n     logging.getLogger(\"sqlalchemy.engine\").setLevel(logging.DEBUG)\n \n-    # Enable Fault Handler\n+    # Enable faulthandler for debugging long-running threads and deadlocks,\n+    # but disable it before interpreter shutdown to avoid segfaults during\n+    # cleanup (especially with SQLAlchemy 2.0 + pytest teardown)\n     faulthandler.enable(file=sys.stderr, all_threads=True)\n \n-    # Print Active Threads and Stack Traces Periodically\n-    def dump_stacks():\n-        while True:\n-            for thread_id, frame in sys._current_frames().items():\n-                log.info(\"\\nThread %s stack:\", thread_id)\n-                traceback.print_stack(frame)\n-            time.sleep(300)\n+    # Cancel any pending traceback dumps and disable faulthandler before exit\n+    # to prevent it from interfering with C extension cleanup\n+    def cleanup_faulthandler():\n+        with suppress(Exception):\n+            faulthandler.cancel_dump_traceback_later()\n+        with suppress(Exception):\n+            faulthandler.disable()\n+\n+    atexit.register(cleanup_faulthandler)\n+\n+    # Set up periodic traceback dumps for debugging hanging tests/threads\n+    faulthandler.dump_traceback_later(timeout=300, repeat=True, file=sys.stderr)\n+\n \n-    threading.Thread(target=dump_stacks, daemon=True).start()\n+@contextlib.contextmanager\n+def _mysql_lock_session_for_migration(original_session: Session) -> Generator[Session, None, None]:\n+    \"\"\"\n+    Create a MySQL-specific lock session for migration operations.\n+\n+    This context manager:\n+    1. Commits the original session to release metadata locks\n+    2. Creates a new session bound to the engine\n+    3. Ensures the session is properly closed on exit\n+\n+    :param original_session: The original session to commit\n+    :return: A new session suitable for use with create_global_lock\n+    \"\"\"\n+    from sqlalchemy.orm import Session as SASession\n+\n+    log.info(\"MySQL: Committing session to release metadata locks\")\n+    original_session.commit()\n+\n+    lock_session = SASession(bind=settings.engine)",
      "comment": "it seems that copilot may have made a mistake here, the engine and get_engine are not sqlalchemy settings, and is just an airflow module, they do behave differently, as get_engine has an additional check, rather than direct access to a variable",
      "comment_id": 2651184386,
      "user": "Nataneljpwd",
      "created_at": "2025-12-29T15:13:25Z",
      "url": "https://github.com/apache/airflow/pull/59218#discussion_r2651184386"
    },
    {
      "repo": "apache/airflow",
      "pr_number": 59239,
      "file_path": "airflow-core/src/airflow/models/trigger.py",
      "line": 101,
      "side": "RIGHT",
      "diff_hunk": "@@ -97,6 +98,7 @@ class Trigger(Base):\n     encrypted_kwargs: Mapped[str] = mapped_column(\"kwargs\", Text, nullable=False)\n     created_date: Mapped[datetime.datetime] = mapped_column(UtcDateTime, nullable=False)\n     triggerer_id: Mapped[int | None] = mapped_column(Integer, nullable=True)\n+    trigger_queue: Mapped[str] = mapped_column(String(128), nullable=True)",
      "comment": "I would expect `alembic` to have detected this change, but whenever I follow this contributor doc [section](https://github.com/apache/airflow/blob/main/contributing-docs/14_metadata_database_updates.rst#metadata-database-updates), I get the following issue:\r\n\r\n<img width=\"1076\" height=\"95\" alt=\"Screenshot 2025-12-09 at 9 36 01\u202fAM\" src=\"https://github.com/user-attachments/assets/8bbb0b88-26b0-4518-9af0-8e67309633df\" />\r\n\r\nThis happens despite running `breeze --backend postgres --db-reset` rebased off main latest, so any thoughts on what I might be missing are appreciated!",
      "comment_id": 2602949931,
      "user": "zach-overflow",
      "created_at": "2025-12-09T14:37:43Z",
      "url": "https://github.com/apache/airflow/pull/59239#discussion_r2602949931"
    },
    {
      "repo": "apache/airflow",
      "pr_number": 59239,
      "file_path": "airflow-core/src/airflow/models/trigger.py",
      "line": 101,
      "side": "RIGHT",
      "diff_hunk": "@@ -97,6 +98,7 @@ class Trigger(Base):\n     encrypted_kwargs: Mapped[str] = mapped_column(\"kwargs\", Text, nullable=False)\n     created_date: Mapped[datetime.datetime] = mapped_column(UtcDateTime, nullable=False)\n     triggerer_id: Mapped[int | None] = mapped_column(Integer, nullable=True)\n+    trigger_queue: Mapped[str] = mapped_column(String(128), nullable=True)",
      "comment": "How about rebasing to latest main plus removing the volume of Postgres container?",
      "comment_id": 2607276820,
      "user": "jason810496",
      "created_at": "2025-12-10T16:05:48Z",
      "url": "https://github.com/apache/airflow/pull/59239#discussion_r2607276820"
    },
    {
      "repo": "apache/airflow",
      "pr_number": 59239,
      "file_path": "airflow-core/src/airflow/models/trigger.py",
      "line": 325,
      "side": "RIGHT",
      "diff_hunk": "@@ -311,19 +314,30 @@ def submit_failure(cls, trigger_id, exc=None, session: Session = NEW_SESSION) ->\n \n     @classmethod\n     @provide_session\n-    def ids_for_triggerer(cls, triggerer_id, session: Session = NEW_SESSION) -> list[int]:\n+    def ids_for_triggerer(\n+        cls, triggerer_id, trigger_queues: set[str], session: Session = NEW_SESSION\n+    ) -> list[int]:\n         \"\"\"Retrieve a list of trigger ids.\"\"\"\n-        return list(session.scalars(select(cls.id).where(cls.triggerer_id == triggerer_id)).all())\n+        return list(\n+            session.scalars(\n+                select(cls.id).where(cls.triggerer_id == triggerer_id, cls.trigger_queue.in_(trigger_queues))\n+            ).all()\n+        )",
      "comment": "So that `trigger_queue` can still be pass as `set[str] | None` along the path and only add the `trigger_queue.in_` filter if `consume-trigger-queues` is explicitly provided. ",
      "comment_id": 2616125036,
      "user": "jason810496",
      "created_at": "2025-12-13T06:26:47Z",
      "url": "https://github.com/apache/airflow/pull/59239#discussion_r2616125036"
    },
    {
      "repo": "apache/airflow",
      "pr_number": 59239,
      "file_path": "airflow-core/src/airflow/migrations/versions/0015_2_9_0_update_trigger_kwargs_type.py",
      "line": 85,
      "side": "LEFT",
      "diff_hunk": "@@ -78,16 +67,12 @@ def downgrade():\n         ------------\n         \"\"\")\n         )\n-    else:\n-        session = get_session()\n-        try:\n-            for trigger in session.query(Trigger).options(lazyload(Trigger.task_instance)):\n-                trigger.encrypted_kwargs = json.dumps(BaseSerialization.serialize(trigger.kwargs))",
      "comment": "This was causing downgrade [test failures in CI](https://github.com/apache/airflow/actions/runs/20346147416/job/58459619112?pr=59239) since it referred directly to the ORM `Trigger` class, which still has the `trigger_queue` attribute present, despite the column's removal in my new migration script's `downgrade` function. Not sure if there is a better workaround for this, but let me know. I'm not an alembic expert, but my understanding is that it generally is not recommended to directly reference ORM classes within alembic migration scripts pretty much for this exact described reason.",
      "comment_id": 2637195396,
      "user": "zach-overflow",
      "created_at": "2025-12-20T16:10:29Z",
      "url": "https://github.com/apache/airflow/pull/59239#discussion_r2637195396"
    },
    {
      "repo": "apache/airflow",
      "pr_number": 59239,
      "file_path": "airflow-core/src/airflow/migrations/versions/0015_2_9_0_update_trigger_kwargs_type.py",
      "line": 56,
      "side": "RIGHT",
      "diff_hunk": "@@ -55,16 +51,9 @@ def get_session() -> sa.orm.Session:\n def upgrade():\n     \"\"\"Update trigger kwargs type to string and encrypt.\"\"\"\n     with op.batch_alter_table(\"trigger\") as batch_op:\n-        batch_op.alter_column(\"kwargs\", type_=sa.Text(), existing_nullable=False)\n-\n-    if not context.is_offline_mode():\n-        session = get_session()\n-        try:\n-            for trigger in session.query(Trigger).options(lazyload(Trigger.task_instance)):\n-                trigger.kwargs = trigger.kwargs\n-            session.commit()\n-        finally:\n-            session.close()\n+        batch_op.alter_column(\n+            \"kwargs\", existing_type=ExtendedJSON(), type_=sa.Text(), existing_nullable=False\n+        )",
      "comment": "We might need a second set of eyes on the DB migration workaround to prevent CI failures; otherwise, LGTM.",
      "comment_id": 2644945661,
      "user": "jason810496",
      "created_at": "2025-12-24T06:48:02Z",
      "url": "https://github.com/apache/airflow/pull/59239#discussion_r2644945661"
    },
    {
      "repo": "apache/airflow",
      "pr_number": 59239,
      "file_path": "airflow-core/src/airflow/migrations/versions/0015_2_9_0_update_trigger_kwargs_type.py",
      "line": 56,
      "side": "RIGHT",
      "diff_hunk": "@@ -55,16 +51,9 @@ def get_session() -> sa.orm.Session:\n def upgrade():\n     \"\"\"Update trigger kwargs type to string and encrypt.\"\"\"\n     with op.batch_alter_table(\"trigger\") as batch_op:\n-        batch_op.alter_column(\"kwargs\", type_=sa.Text(), existing_nullable=False)\n-\n-    if not context.is_offline_mode():\n-        session = get_session()\n-        try:\n-            for trigger in session.query(Trigger).options(lazyload(Trigger.task_instance)):\n-                trigger.kwargs = trigger.kwargs\n-            session.commit()\n-        finally:\n-            session.close()\n+        batch_op.alter_column(\n+            \"kwargs\", existing_type=ExtendedJSON(), type_=sa.Text(), existing_nullable=False\n+        )",
      "comment": "I believe old migrations are best left alone unless there's no choice. Rather, what @jscheffl suggested in my PR is to add a migration that affects 3.2.0 which fixes whatever issue is present in the earlier migration. This suggestion worked fine (CI-wise) in my case.",
      "comment_id": 2644976226,
      "user": "Dev-iL",
      "created_at": "2025-12-24T07:07:01Z",
      "url": "https://github.com/apache/airflow/pull/59239#discussion_r2644976226"
    },
    {
      "repo": "apache/airflow",
      "pr_number": 59239,
      "file_path": "airflow-core/src/airflow/api_fastapi/core_api/datamodels/trigger.py",
      "line": 36,
      "side": "RIGHT",
      "diff_hunk": "@@ -33,4 +33,5 @@ class TriggerResponse(BaseModel):\n     classpath: str\n     kwargs: Annotated[str, BeforeValidator(str)]\n     created_date: datetime\n+    trigger_queue: str | None",
      "comment": "Similar here - why not naming it `queue` only such that it is similar like we use it in the normal workers?",
      "comment_id": 2645296534,
      "user": "jscheffl",
      "created_at": "2025-12-24T09:50:40Z",
      "url": "https://github.com/apache/airflow/pull/59239#discussion_r2645296534"
    },
    {
      "repo": "apache/airflow",
      "pr_number": 59239,
      "file_path": "airflow-core/src/airflow/migrations/versions/0015_2_9_0_update_trigger_kwargs_type.py",
      "line": 56,
      "side": "RIGHT",
      "diff_hunk": "@@ -55,16 +51,9 @@ def get_session() -> sa.orm.Session:\n def upgrade():\n     \"\"\"Update trigger kwargs type to string and encrypt.\"\"\"\n     with op.batch_alter_table(\"trigger\") as batch_op:\n-        batch_op.alter_column(\"kwargs\", type_=sa.Text(), existing_nullable=False)\n-\n-    if not context.is_offline_mode():\n-        session = get_session()\n-        try:\n-            for trigger in session.query(Trigger).options(lazyload(Trigger.task_instance)):\n-                trigger.kwargs = trigger.kwargs\n-            session.commit()\n-        finally:\n-            session.close()\n+        batch_op.alter_column(\n+            \"kwargs\", existing_type=ExtendedJSON(), type_=sa.Text(), existing_nullable=False\n+        )",
      "comment": "+1 - Please add a new migration to this. Do not alter previous migrations because in this case if somebody is on 3.1.2 then the migration is already passed and a potential inconsistency is not fixed when upgrading to 3.2.0",
      "comment_id": 2645299894,
      "user": "jscheffl",
      "created_at": "2025-12-24T09:52:24Z",
      "url": "https://github.com/apache/airflow/pull/59239#discussion_r2645299894"
    },
    {
      "repo": "apache/airflow",
      "pr_number": 59239,
      "file_path": "airflow-core/src/airflow/models/trigger.py",
      "line": 323,
      "side": "RIGHT",
      "diff_hunk": "@@ -311,21 +313,33 @@ def submit_failure(cls, trigger_id, exc=None, session: Session = NEW_SESSION) ->\n \n     @classmethod\n     @provide_session\n-    def ids_for_triggerer(cls, triggerer_id, session: Session = NEW_SESSION) -> list[int]:\n+    def ids_for_triggerer(\n+        cls, triggerer_id, consume_trigger_queues: set[str] | None = None, session: Session = NEW_SESSION\n+    ) -> list[int]:\n         \"\"\"Retrieve a list of trigger ids.\"\"\"\n-        return list(session.scalars(select(cls.id).where(cls.triggerer_id == triggerer_id)).all())\n+        query = select(cls.id).where(cls.triggerer_id == triggerer_id)\n+        # By default, there is no trigger queue assignment. Only filter by queue when explicitly set in the triggerer CLI.\n+        if consume_trigger_queues:\n+            query = query.filter(cls.trigger_queue.in_(consume_trigger_queues))",
      "comment": "With this filter only conditionally applied it is inconsistent to the documentation above. If no queue is provided, no filter is applied and a triggerer would pull _all_ items. (Not only the ones which have no queue assigned!)\n\nI assume the docs above are wrong. I think the behavior is OK and one must be aware of that selective triggerers need to be set-up per queue.",
      "comment_id": 2645305654,
      "user": "jscheffl",
      "created_at": "2025-12-24T09:55:10Z",
      "url": "https://github.com/apache/airflow/pull/59239#discussion_r2645305654"
    },
    {
      "repo": "apache/airflow",
      "pr_number": 59239,
      "file_path": "airflow-core/src/airflow/models/trigger.py",
      "line": 432,
      "side": "RIGHT",
      "diff_hunk": "@@ -399,7 +423,15 @@ def get_sorted_triggers(cls, capacity: int, alive_triggerer_ids: list[int] | Sel\n             # picking up too many triggers and starving other triggerers for HA setup.\n             remaining_capacity = min(remaining_capacity, cls.max_trigger_to_select_per_loop)\n \n-            locked_query = with_row_locks(query.limit(remaining_capacity), session, skip_locked=True)\n+            # Filter by trigger_queues if the triggerer explicitly was called with `--consume-trigger-queues`,\n+            # otherwise, filter out Triggers which have an explicit `trigger_queue` value since there may be other\n+            # triggerer hosts explicitly assigned to that queue.\n+            if consume_trigger_queues:\n+                filtered_query = query.filter(cls.trigger_queue.in_(consume_trigger_queues))\n+            else:\n+                filtered_query = query.filter(cls.trigger_queue.is_(None))",
      "comment": "Now I am a bit worried, here the filter is inconsistent to https://github.com/apache/airflow/pull/59239/changes#r2645305654",
      "comment_id": 2645308078,
      "user": "jscheffl",
      "created_at": "2025-12-24T09:56:28Z",
      "url": "https://github.com/apache/airflow/pull/59239#discussion_r2645308078"
    },
    {
      "repo": "apache/airflow",
      "pr_number": 59239,
      "file_path": "airflow-core/src/airflow/migrations/versions/0015_2_9_0_update_trigger_kwargs_type.py",
      "line": 56,
      "side": "RIGHT",
      "diff_hunk": "@@ -55,16 +51,9 @@ def get_session() -> sa.orm.Session:\n def upgrade():\n     \"\"\"Update trigger kwargs type to string and encrypt.\"\"\"\n     with op.batch_alter_table(\"trigger\") as batch_op:\n-        batch_op.alter_column(\"kwargs\", type_=sa.Text(), existing_nullable=False)\n-\n-    if not context.is_offline_mode():\n-        session = get_session()\n-        try:\n-            for trigger in session.query(Trigger).options(lazyload(Trigger.task_instance)):\n-                trigger.kwargs = trigger.kwargs\n-            session.commit()\n-        finally:\n-            session.close()\n+        batch_op.alter_column(\n+            \"kwargs\", existing_type=ExtendedJSON(), type_=sa.Text(), existing_nullable=False\n+        )",
      "comment": "I agree that it is not ideal to be modifying a pre-existing migration script, but I'm not sure about an ambiguity here: I found that prior to this change the downgrade migrations would fail because the `Trigger` ORM was directly referenced, including its `trigger_queue` column, leading to a \"column does not exist\" [failure on the downgrade here](https://github.com/apache/airflow/pull/59239#discussion_r2637195396). I didn't see any other past migration scripts which referenced an ORM class directly, but I can see if the proposed route works even when the `Trigger` class is still present in this old migration script.",
      "comment_id": 2645735300,
      "user": "zach-overflow",
      "created_at": "2025-12-24T13:53:33Z",
      "url": "https://github.com/apache/airflow/pull/59239#discussion_r2645735300"
    },
    {
      "repo": "apache/airflow",
      "pr_number": 59239,
      "file_path": "airflow-core/src/airflow/models/trigger.py",
      "line": 432,
      "side": "RIGHT",
      "diff_hunk": "@@ -399,7 +423,15 @@ def get_sorted_triggers(cls, capacity: int, alive_triggerer_ids: list[int] | Sel\n             # picking up too many triggers and starving other triggerers for HA setup.\n             remaining_capacity = min(remaining_capacity, cls.max_trigger_to_select_per_loop)\n \n-            locked_query = with_row_locks(query.limit(remaining_capacity), session, skip_locked=True)\n+            # Filter by trigger_queues if the triggerer explicitly was called with `--consume-trigger-queues`,\n+            # otherwise, filter out Triggers which have an explicit `trigger_queue` value since there may be other\n+            # triggerer hosts explicitly assigned to that queue.\n+            if consume_trigger_queues:\n+                filtered_query = query.filter(cls.trigger_queue.in_(consume_trigger_queues))\n+            else:\n+                filtered_query = query.filter(cls.trigger_queue.is_(None))",
      "comment": "Ah thank you for spotting this! This logic is the intended behavior, but I had missed changing the logic in `ids_for_triggerer` method. Will adjust accordingly.\r\n\r\nTo clarify, the intended behavior is as described in the documentation update.",
      "comment_id": 2645743768,
      "user": "zach-overflow",
      "created_at": "2025-12-24T13:59:12Z",
      "url": "https://github.com/apache/airflow/pull/59239#discussion_r2645743768"
    },
    {
      "repo": "apache/airflow",
      "pr_number": 59239,
      "file_path": "airflow-core/src/airflow/models/trigger.py",
      "line": 323,
      "side": "RIGHT",
      "diff_hunk": "@@ -311,21 +313,33 @@ def submit_failure(cls, trigger_id, exc=None, session: Session = NEW_SESSION) ->\n \n     @classmethod\n     @provide_session\n-    def ids_for_triggerer(cls, triggerer_id, session: Session = NEW_SESSION) -> list[int]:\n+    def ids_for_triggerer(\n+        cls, triggerer_id, consume_trigger_queues: set[str] | None = None, session: Session = NEW_SESSION\n+    ) -> list[int]:\n         \"\"\"Retrieve a list of trigger ids.\"\"\"\n-        return list(session.scalars(select(cls.id).where(cls.triggerer_id == triggerer_id)).all())\n+        query = select(cls.id).where(cls.triggerer_id == triggerer_id)\n+        # By default, there is no trigger queue assignment. Only filter by queue when explicitly set in the triggerer CLI.\n+        if consume_trigger_queues:\n+            query = query.filter(cls.trigger_queue.in_(consume_trigger_queues))",
      "comment": "Good catch -- you are right this is not in agreement with the docs. I will update this code since this was a change I missed during an early refactor. More info on my other related comment [here](https://github.com/apache/airflow/pull/59239#discussion_r2645743768).",
      "comment_id": 2645745144,
      "user": "zach-overflow",
      "created_at": "2025-12-24T14:00:01Z",
      "url": "https://github.com/apache/airflow/pull/59239#discussion_r2645745144"
    },
    {
      "repo": "apache/airflow",
      "pr_number": 59239,
      "file_path": "airflow-core/src/airflow/models/trigger.py",
      "line": 432,
      "side": "RIGHT",
      "diff_hunk": "@@ -399,7 +423,15 @@ def get_sorted_triggers(cls, capacity: int, alive_triggerer_ids: list[int] | Sel\n             # picking up too many triggers and starving other triggerers for HA setup.\n             remaining_capacity = min(remaining_capacity, cls.max_trigger_to_select_per_loop)\n \n-            locked_query = with_row_locks(query.limit(remaining_capacity), session, skip_locked=True)\n+            # Filter by trigger_queues if the triggerer explicitly was called with `--consume-trigger-queues`,\n+            # otherwise, filter out Triggers which have an explicit `trigger_queue` value since there may be other\n+            # triggerer hosts explicitly assigned to that queue.\n+            if consume_trigger_queues:\n+                filtered_query = query.filter(cls.trigger_queue.in_(consume_trigger_queues))\n+            else:\n+                filtered_query = query.filter(cls.trigger_queue.is_(None))",
      "comment": "Then one safety question: This query is fixed but the triggerer actually does not know if there are other queue specific triggereres. Would mean this has a deployment impact if I just want to have \"one simple triggerer for all\" but I am using different queues in my executors?\r\n\r\n(1) Would we need an option to ignore queues in triggerers and just \"catch all\" for non-team separated setups?\r\n(2) Otherwise if so then we need to add notes to all executors that might use queues to ensure people are aware of this, else they wonder why their triggerers get stuck after upgrading",
      "comment_id": 2645764752,
      "user": "jscheffl",
      "created_at": "2025-12-24T14:13:08Z",
      "url": "https://github.com/apache/airflow/pull/59239#discussion_r2645764752"
    },
    {
      "repo": "apache/airflow",
      "pr_number": 59239,
      "file_path": "airflow-core/src/airflow/models/trigger.py",
      "line": 432,
      "side": "RIGHT",
      "diff_hunk": "@@ -399,7 +423,15 @@ def get_sorted_triggers(cls, capacity: int, alive_triggerer_ids: list[int] | Sel\n             # picking up too many triggers and starving other triggerers for HA setup.\n             remaining_capacity = min(remaining_capacity, cls.max_trigger_to_select_per_loop)\n \n-            locked_query = with_row_locks(query.limit(remaining_capacity), session, skip_locked=True)\n+            # Filter by trigger_queues if the triggerer explicitly was called with `--consume-trigger-queues`,\n+            # otherwise, filter out Triggers which have an explicit `trigger_queue` value since there may be other\n+            # triggerer hosts explicitly assigned to that queue.\n+            if consume_trigger_queues:\n+                filtered_query = query.filter(cls.trigger_queue.in_(consume_trigger_queues))\n+            else:\n+                filtered_query = query.filter(cls.trigger_queue.is_(None))",
      "comment": "So I believe this concern is addressed by what I described [here](https://github.com/apache/airflow/pull/59239#discussion_r2645791823), in that the currently proposed design intentionally does not derive the trigger queue values from the task queues. The safety issues you are describing are partly the motivation for keeping the trigger queue and task queue distinct, rather than tightly coupled.\r\n\r\nIn other words, the intent here is that trigger queue assignment is specific to the BaseTrigger instantiation / operator's `defer` call arguments, effectively making the trigger queue an opt-in feature, which is not derived from the task queue (unless users explicitly define their trigger queues from their tasks' queue values).",
      "comment_id": 2645814905,
      "user": "zach-overflow",
      "created_at": "2025-12-24T14:31:38Z",
      "url": "https://github.com/apache/airflow/pull/59239#discussion_r2645814905"
    },
    {
      "repo": "apache/airflow",
      "pr_number": 59239,
      "file_path": "airflow-core/src/airflow/migrations/versions/0015_2_9_0_update_trigger_kwargs_type.py",
      "line": 56,
      "side": "RIGHT",
      "diff_hunk": "@@ -55,16 +51,9 @@ def get_session() -> sa.orm.Session:\n def upgrade():\n     \"\"\"Update trigger kwargs type to string and encrypt.\"\"\"\n     with op.batch_alter_table(\"trigger\") as batch_op:\n-        batch_op.alter_column(\"kwargs\", type_=sa.Text(), existing_nullable=False)\n-\n-    if not context.is_offline_mode():\n-        session = get_session()\n-        try:\n-            for trigger in session.query(Trigger).options(lazyload(Trigger.task_instance)):\n-                trigger.kwargs = trigger.kwargs\n-            session.commit()\n-        finally:\n-            session.close()\n+        batch_op.alter_column(\n+            \"kwargs\", existing_type=ExtendedJSON(), type_=sa.Text(), existing_nullable=False\n+        )",
      "comment": "I believe this past PR also is describing a similar problem relating to the direct ORM reference in the migration script: https://github.com/apache/airflow/pull/38743",
      "comment_id": 2645896606,
      "user": "zach-overflow",
      "created_at": "2025-12-24T15:04:51Z",
      "url": "https://github.com/apache/airflow/pull/59239#discussion_r2645896606"
    },
    {
      "repo": "apache/airflow",
      "pr_number": 59239,
      "file_path": "airflow-core/src/airflow/models/trigger.py",
      "line": 432,
      "side": "RIGHT",
      "diff_hunk": "@@ -399,7 +423,15 @@ def get_sorted_triggers(cls, capacity: int, alive_triggerer_ids: list[int] | Sel\n             # picking up too many triggers and starving other triggerers for HA setup.\n             remaining_capacity = min(remaining_capacity, cls.max_trigger_to_select_per_loop)\n \n-            locked_query = with_row_locks(query.limit(remaining_capacity), session, skip_locked=True)\n+            # Filter by trigger_queues if the triggerer explicitly was called with `--consume-trigger-queues`,\n+            # otherwise, filter out Triggers which have an explicit `trigger_queue` value since there may be other\n+            # triggerer hosts explicitly assigned to that queue.\n+            if consume_trigger_queues:\n+                filtered_query = query.filter(cls.trigger_queue.in_(consume_trigger_queues))\n+            else:\n+                filtered_query = query.filter(cls.trigger_queue.is_(None))",
      "comment": "Addressed with:\r\n1. The addition of the `triggerer.queues_enabled` config option (default is `False`). \r\n2. New updates for the added doc section in `deferring.rst`, including the new \"Trigger Queue Assignment Caveats\" subsection.",
      "comment_id": 2649163299,
      "user": "zach-overflow",
      "created_at": "2025-12-27T14:28:24Z",
      "url": "https://github.com/apache/airflow/pull/59239#discussion_r2649163299"
    },
    {
      "repo": "apache/airflow",
      "pr_number": 59239,
      "file_path": "airflow-core/src/airflow/migrations/versions/0015_2_9_0_update_trigger_kwargs_type.py",
      "line": 56,
      "side": "RIGHT",
      "diff_hunk": "@@ -55,16 +51,9 @@ def get_session() -> sa.orm.Session:\n def upgrade():\n     \"\"\"Update trigger kwargs type to string and encrypt.\"\"\"\n     with op.batch_alter_table(\"trigger\") as batch_op:\n-        batch_op.alter_column(\"kwargs\", type_=sa.Text(), existing_nullable=False)\n-\n-    if not context.is_offline_mode():\n-        session = get_session()\n-        try:\n-            for trigger in session.query(Trigger).options(lazyload(Trigger.task_instance)):\n-                trigger.kwargs = trigger.kwargs\n-            session.commit()\n-        finally:\n-            session.close()\n+        batch_op.alter_column(\n+            \"kwargs\", existing_type=ExtendedJSON(), type_=sa.Text(), existing_nullable=False\n+        )",
      "comment": "So after some more digging, I don't see a way to avoid modifying this prior migration script since my change already does add a new migration script for the addition of the `queue` column on upgrade / removal of the `queue` column on downgrade. That doesn't mitigate the problematic usage of the ORM class in the old migration script since the `Trigger` class will still have the `queue` column attribute, even after the downgrade successfully runs from `0096_3_2_0_add_queue_column_to_trigger.py`). I believe the reference to the `Trigger` sqlalchemy class in this migration script is the root problem, if I'm understanding [this SO thread](https://stackoverflow.com/questions/13676744/using-the-sqlalchemy-orm-inside-an-alembic-migration-how-do-i#comment64254760_36087108), and a relevant [discussion in this past PR](https://github.com/apache/airflow/pull/38743).\r\n\r\nI definitely agree it is not ideal to modify a prior migration script, but I'm not sure of an alternative. Please let me know if there is something I'm not understanding though!",
      "comment_id": 2649195334,
      "user": "zach-overflow",
      "created_at": "2025-12-27T15:42:39Z",
      "url": "https://github.com/apache/airflow/pull/59239#discussion_r2649195334"
    },
    {
      "repo": "apache/airflow",
      "pr_number": 59239,
      "file_path": "airflow-core/src/airflow/models/trigger.py",
      "line": 101,
      "side": "RIGHT",
      "diff_hunk": "@@ -98,6 +98,7 @@ class Trigger(Base):\n     encrypted_kwargs: Mapped[str] = mapped_column(\"kwargs\", Text, nullable=False)\n     created_date: Mapped[datetime.datetime] = mapped_column(UtcDateTime, nullable=False)\n     triggerer_id: Mapped[int | None] = mapped_column(Integer, nullable=True)\n+    queue: Mapped[str] = mapped_column(String(128), nullable=True)",
      "comment": "in airflow-core/src/airflow/models/taskinstance.py:404 the queue field is defined to be 256, so should be the same in the triggerer\n```suggestion\n    queue: Mapped[str] = mapped_column(String(256), nullable=True)\n```",
      "comment_id": 2649712490,
      "user": "jscheffl",
      "created_at": "2025-12-28T13:45:51Z",
      "url": "https://github.com/apache/airflow/pull/59239#discussion_r2649712490"
    },
    {
      "repo": "apache/airflow",
      "pr_number": 59239,
      "file_path": "airflow-core/src/airflow/migrations/versions/0096_3_2_0_add_queue_column_to_trigger.py",
      "line": 44,
      "side": "RIGHT",
      "diff_hunk": "@@ -0,0 +1,50 @@\n+#\n+# Licensed to the Apache Software Foundation (ASF) under one\n+# or more contributor license agreements.  See the NOTICE file\n+# distributed with this work for additional information\n+# regarding copyright ownership.  The ASF licenses this file\n+# to you under the Apache License, Version 2.0 (the\n+# \"License\"); you may not use this file except in compliance\n+# with the License.  You may obtain a copy of the License at\n+#\n+#   http://www.apache.org/licenses/LICENSE-2.0\n+#\n+# Unless required by applicable law or agreed to in writing,\n+# software distributed under the License is distributed on an\n+# \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+# KIND, either express or implied.  See the License for the\n+# specific language governing permissions and limitations\n+# under the License.\n+\n+\"\"\"\n+Add ``queue`` column to ``trigger`` table.\n+\n+Revision ID: c47f2e1ab9d4\n+Revises: edc4f85a4619\n+Create Date: 2025-12-09 20:30:40.500001\n+\n+\"\"\"\n+\n+from __future__ import annotations\n+\n+import sqlalchemy as sa\n+from alembic import op\n+\n+# revision identifiers, used by Alembic.\n+revision = \"c47f2e1ab9d4\"\n+down_revision = \"edc4f85a4619\"\n+branch_labels = None\n+depends_on = None\n+airflow_version = \"3.2.0\"\n+\n+\n+def upgrade():\n+    \"\"\"Add ``queue`` column in trigger table.\"\"\"\n+    with op.batch_alter_table(\"trigger\") as batch_op:\n+        batch_op.add_column(sa.Column(\"queue\", sa.String(length=128), nullable=True))",
      "comment": "in airflow-core/src/airflow/models/taskinstance.py:404 the queue field is defined to be 256, so should be the same in the triggerer\n```suggestion\n        batch_op.add_column(sa.Column(\"queue\", sa.String(length=256), nullable=True))\n```",
      "comment_id": 2649712704,
      "user": "jscheffl",
      "created_at": "2025-12-28T13:46:28Z",
      "url": "https://github.com/apache/airflow/pull/59239#discussion_r2649712704"
    },
    {
      "repo": "apache/airflow",
      "pr_number": 59239,
      "file_path": "airflow-core/src/airflow/migrations/versions/0015_2_9_0_update_trigger_kwargs_type.py",
      "line": 56,
      "side": "RIGHT",
      "diff_hunk": "@@ -55,16 +51,9 @@ def get_session() -> sa.orm.Session:\n def upgrade():\n     \"\"\"Update trigger kwargs type to string and encrypt.\"\"\"\n     with op.batch_alter_table(\"trigger\") as batch_op:\n-        batch_op.alter_column(\"kwargs\", type_=sa.Text(), existing_nullable=False)\n-\n-    if not context.is_offline_mode():\n-        session = get_session()\n-        try:\n-            for trigger in session.query(Trigger).options(lazyload(Trigger.task_instance)):\n-                trigger.kwargs = trigger.kwargs\n-            session.commit()\n-        finally:\n-            session.close()\n+        batch_op.alter_column(\n+            \"kwargs\", existing_type=ExtendedJSON(), type_=sa.Text(), existing_nullable=False\n+        )",
      "comment": "Okay, now I see the point of technical blocker here. But also still I am not convinced that fixing a previous migration will help because many many people will already have migrated from 2.9 to for example 3.1.5 and then further migrate.\n\nI think having existing triggerers still alive when migration is started might be a general problem.\n\nOne radical thought if no other idea to fix: Can we drop support of migration from <2.10 when we release 3.2? To enforce people need to upgrate to 2.10 or 2.11 before getting to 3.2? Not sure what our backwards migration promise is, in the past we had cut for all <2.7.",
      "comment_id": 2649715123,
      "user": "jscheffl",
      "created_at": "2025-12-28T13:51:12Z",
      "url": "https://github.com/apache/airflow/pull/59239#discussion_r2649715123"
    },
    {
      "repo": "apache/airflow",
      "pr_number": 59239,
      "file_path": "airflow-core/src/airflow/migrations/versions/0015_2_9_0_update_trigger_kwargs_type.py",
      "line": 56,
      "side": "RIGHT",
      "diff_hunk": "@@ -55,16 +51,9 @@ def get_session() -> sa.orm.Session:\n def upgrade():\n     \"\"\"Update trigger kwargs type to string and encrypt.\"\"\"\n     with op.batch_alter_table(\"trigger\") as batch_op:\n-        batch_op.alter_column(\"kwargs\", type_=sa.Text(), existing_nullable=False)\n-\n-    if not context.is_offline_mode():\n-        session = get_session()\n-        try:\n-            for trigger in session.query(Trigger).options(lazyload(Trigger.task_instance)):\n-                trigger.kwargs = trigger.kwargs\n-            session.commit()\n-        finally:\n-            session.close()\n+        batch_op.alter_column(\n+            \"kwargs\", existing_type=ExtendedJSON(), type_=sa.Text(), existing_nullable=False\n+        )",
      "comment": "For future reference, I've created this issue: https://github.com/apache/airflow/issues/59871",
      "comment_id": 2649716735,
      "user": "zach-overflow",
      "created_at": "2025-12-28T13:54:39Z",
      "url": "https://github.com/apache/airflow/pull/59239#discussion_r2649716735"
    },
    {
      "repo": "apache/airflow",
      "pr_number": 59239,
      "file_path": "airflow-core/src/airflow/models/trigger.py",
      "line": 101,
      "side": "RIGHT",
      "diff_hunk": "@@ -98,6 +98,7 @@ class Trigger(Base):\n     encrypted_kwargs: Mapped[str] = mapped_column(\"kwargs\", Text, nullable=False)\n     created_date: Mapped[datetime.datetime] = mapped_column(UtcDateTime, nullable=False)\n     triggerer_id: Mapped[int | None] = mapped_column(Integer, nullable=True)\n+    queue: Mapped[str] = mapped_column(String(128), nullable=True)",
      "comment": "Updated, and added a unit test in `test_trigger.py:: test_queue_column_max_len_matches_ti_column_max_len ` to prevent this from happening in the future.",
      "comment_id": 2651265617,
      "user": "zach-overflow",
      "created_at": "2025-12-29T15:56:08Z",
      "url": "https://github.com/apache/airflow/pull/59239#discussion_r2651265617"
    },
    {
      "repo": "apache/airflow",
      "pr_number": 59239,
      "file_path": "airflow-core/src/airflow/migrations/versions/0096_3_2_0_add_queue_column_to_trigger.py",
      "line": 44,
      "side": "RIGHT",
      "diff_hunk": "@@ -0,0 +1,50 @@\n+#\n+# Licensed to the Apache Software Foundation (ASF) under one\n+# or more contributor license agreements.  See the NOTICE file\n+# distributed with this work for additional information\n+# regarding copyright ownership.  The ASF licenses this file\n+# to you under the Apache License, Version 2.0 (the\n+# \"License\"); you may not use this file except in compliance\n+# with the License.  You may obtain a copy of the License at\n+#\n+#   http://www.apache.org/licenses/LICENSE-2.0\n+#\n+# Unless required by applicable law or agreed to in writing,\n+# software distributed under the License is distributed on an\n+# \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+# KIND, either express or implied.  See the License for the\n+# specific language governing permissions and limitations\n+# under the License.\n+\n+\"\"\"\n+Add ``queue`` column to ``trigger`` table.\n+\n+Revision ID: c47f2e1ab9d4\n+Revises: edc4f85a4619\n+Create Date: 2025-12-09 20:30:40.500001\n+\n+\"\"\"\n+\n+from __future__ import annotations\n+\n+import sqlalchemy as sa\n+from alembic import op\n+\n+# revision identifiers, used by Alembic.\n+revision = \"c47f2e1ab9d4\"\n+down_revision = \"edc4f85a4619\"\n+branch_labels = None\n+depends_on = None\n+airflow_version = \"3.2.0\"\n+\n+\n+def upgrade():\n+    \"\"\"Add ``queue`` column in trigger table.\"\"\"\n+    with op.batch_alter_table(\"trigger\") as batch_op:\n+        batch_op.add_column(sa.Column(\"queue\", sa.String(length=128), nullable=True))",
      "comment": "Updated, and added a unit test in `test_trigger.py:: test_queue_column_max_len_matches_ti_column_max_len ` to prevent this from happening in the future.",
      "comment_id": 2651265929,
      "user": "zach-overflow",
      "created_at": "2025-12-29T15:56:16Z",
      "url": "https://github.com/apache/airflow/pull/59239#discussion_r2651265929"
    },
    {
      "repo": "apache/airflow",
      "pr_number": 59239,
      "file_path": "airflow-core/src/airflow/migrations/versions/0015_2_9_0_update_trigger_kwargs_type.py",
      "line": 56,
      "side": "RIGHT",
      "diff_hunk": "@@ -55,16 +51,9 @@ def get_session() -> sa.orm.Session:\n def upgrade():\n     \"\"\"Update trigger kwargs type to string and encrypt.\"\"\"\n     with op.batch_alter_table(\"trigger\") as batch_op:\n-        batch_op.alter_column(\"kwargs\", type_=sa.Text(), existing_nullable=False)\n-\n-    if not context.is_offline_mode():\n-        session = get_session()\n-        try:\n-            for trigger in session.query(Trigger).options(lazyload(Trigger.task_instance)):\n-                trigger.kwargs = trigger.kwargs\n-            session.commit()\n-        finally:\n-            session.close()\n+        batch_op.alter_column(\n+            \"kwargs\", existing_type=ExtendedJSON(), type_=sa.Text(), existing_nullable=False\n+        )",
      "comment": "Marking this thread as resolved, with [this comment](https://github.com/apache/airflow/pull/59239#issuecomment-3697382607) showing that the resulting SQL commands for both upgrades and downgrades are equivalent between the unmodified migration script and the modified one when run on this branch. Feel free to open up the thread again if there are any additional concerns or anything I may have missed, though.",
      "comment_id": 2651679034,
      "user": "zach-overflow",
      "created_at": "2025-12-29T20:02:35Z",
      "url": "https://github.com/apache/airflow/pull/59239#discussion_r2651679034"
    },
    {
      "repo": "apache/airflow",
      "pr_number": 59922,
      "file_path": "airflow-core/src/airflow/utils/context.py",
      "line": 42,
      "side": "RIGHT",
      "diff_hunk": "@@ -32,51 +32,16 @@\n     VariableAccessor as VariableAccessorSDK,\n )\n from airflow.serialization.definitions.notset import NOTSET, is_arg_set\n-from airflow.utils.deprecation_tools import DeprecatedImportWarning\n+from airflow.utils.deprecation_tools import DeprecatedImportWarning, add_deprecated_classes\n from airflow.utils.session import create_session\n \n-# NOTE: Please keep this in sync with the following:\n-# * Context in task-sdk/src/airflow/sdk/definitions/context.py\n-# * Table in docs/apache-airflow/templates-ref.rst\n-KNOWN_CONTEXT_KEYS: set[str] = {\n-    \"conn\",\n-    \"dag\",\n-    \"dag_run\",\n-    \"data_interval_end\",\n-    \"data_interval_start\",\n-    \"ds\",\n-    \"ds_nodash\",\n-    \"expanded_ti_count\",\n-    \"exception\",\n-    \"inlets\",\n-    \"inlet_events\",\n-    \"logical_date\",\n-    \"macros\",\n-    \"map_index_template\",\n-    \"outlets\",\n-    \"outlet_events\",\n-    \"params\",\n-    \"prev_data_interval_start_success\",\n-    \"prev_data_interval_end_success\",\n-    \"prev_start_date_success\",\n-    \"prev_end_date_success\",\n-    \"reason\",\n-    \"run_id\",\n-    \"start_date\",\n-    \"task\",\n-    \"task_reschedule_count\",\n-    \"task_instance\",\n-    \"task_instance_key_str\",\n-    \"test_mode\",\n-    \"templates_dict\",\n-    \"ti\",\n-    \"triggering_asset_events\",\n-    \"ts\",\n-    \"ts_nodash\",\n-    \"ts_nodash_with_tz\",\n-    \"try_number\",\n-    \"var\",\n-}\n+warnings.warn(\n+    \"Module airflow.utils.context is deprecated and will be removed in the \"\n+    \"future. Use airflow.sdk.execution_time.context if you are using the \"\n+    \"classes inside an Airflow task.\",\n+    DeprecatedImportWarning,",
      "comment": "Out of curiosity: Do we mark deprecated in general or shall we name a version for removal? I have noticed that the \"RemovedInAirflow4\" deprecation warning is not used very often in such cases. (Asking not sure if we agreed on some general rule for removal)",
      "comment_id": 2658860011,
      "user": "jscheffl",
      "created_at": "2026-01-03T10:54:49Z",
      "url": "https://github.com/apache/airflow/pull/59922#discussion_r2658860011"
    },
    {
      "repo": "apache/airflow",
      "pr_number": 59922,
      "file_path": "airflow-core/src/airflow/utils/context.py",
      "line": 42,
      "side": "RIGHT",
      "diff_hunk": "@@ -32,51 +32,16 @@\n     VariableAccessor as VariableAccessorSDK,\n )\n from airflow.serialization.definitions.notset import NOTSET, is_arg_set\n-from airflow.utils.deprecation_tools import DeprecatedImportWarning\n+from airflow.utils.deprecation_tools import DeprecatedImportWarning, add_deprecated_classes\n from airflow.utils.session import create_session\n \n-# NOTE: Please keep this in sync with the following:\n-# * Context in task-sdk/src/airflow/sdk/definitions/context.py\n-# * Table in docs/apache-airflow/templates-ref.rst\n-KNOWN_CONTEXT_KEYS: set[str] = {\n-    \"conn\",\n-    \"dag\",\n-    \"dag_run\",\n-    \"data_interval_end\",\n-    \"data_interval_start\",\n-    \"ds\",\n-    \"ds_nodash\",\n-    \"expanded_ti_count\",\n-    \"exception\",\n-    \"inlets\",\n-    \"inlet_events\",\n-    \"logical_date\",\n-    \"macros\",\n-    \"map_index_template\",\n-    \"outlets\",\n-    \"outlet_events\",\n-    \"params\",\n-    \"prev_data_interval_start_success\",\n-    \"prev_data_interval_end_success\",\n-    \"prev_start_date_success\",\n-    \"prev_end_date_success\",\n-    \"reason\",\n-    \"run_id\",\n-    \"start_date\",\n-    \"task\",\n-    \"task_reschedule_count\",\n-    \"task_instance\",\n-    \"task_instance_key_str\",\n-    \"test_mode\",\n-    \"templates_dict\",\n-    \"ti\",\n-    \"triggering_asset_events\",\n-    \"ts\",\n-    \"ts_nodash\",\n-    \"ts_nodash_with_tz\",\n-    \"try_number\",\n-    \"var\",\n-}\n+warnings.warn(\n+    \"Module airflow.utils.context is deprecated and will be removed in the \"\n+    \"future. Use airflow.sdk.execution_time.context if you are using the \"\n+    \"classes inside an Airflow task.\",\n+    DeprecatedImportWarning,",
      "comment": "I\u2019m not very sure either, this is the class used in other Task SDK-related deprecations. Maybe @kaxil has more context.",
      "comment_id": 2660186198,
      "user": "uranusjr",
      "created_at": "2026-01-05T03:20:01Z",
      "url": "https://github.com/apache/airflow/pull/59922#discussion_r2660186198"
    },
    {
      "repo": "apache/airflow",
      "pr_number": 59922,
      "file_path": "airflow-core/src/airflow/utils/context.py",
      "line": 42,
      "side": "RIGHT",
      "diff_hunk": "@@ -32,51 +32,16 @@\n     VariableAccessor as VariableAccessorSDK,\n )\n from airflow.serialization.definitions.notset import NOTSET, is_arg_set\n-from airflow.utils.deprecation_tools import DeprecatedImportWarning\n+from airflow.utils.deprecation_tools import DeprecatedImportWarning, add_deprecated_classes\n from airflow.utils.session import create_session\n \n-# NOTE: Please keep this in sync with the following:\n-# * Context in task-sdk/src/airflow/sdk/definitions/context.py\n-# * Table in docs/apache-airflow/templates-ref.rst\n-KNOWN_CONTEXT_KEYS: set[str] = {\n-    \"conn\",\n-    \"dag\",\n-    \"dag_run\",\n-    \"data_interval_end\",\n-    \"data_interval_start\",\n-    \"ds\",\n-    \"ds_nodash\",\n-    \"expanded_ti_count\",\n-    \"exception\",\n-    \"inlets\",\n-    \"inlet_events\",\n-    \"logical_date\",\n-    \"macros\",\n-    \"map_index_template\",\n-    \"outlets\",\n-    \"outlet_events\",\n-    \"params\",\n-    \"prev_data_interval_start_success\",\n-    \"prev_data_interval_end_success\",\n-    \"prev_start_date_success\",\n-    \"prev_end_date_success\",\n-    \"reason\",\n-    \"run_id\",\n-    \"start_date\",\n-    \"task\",\n-    \"task_reschedule_count\",\n-    \"task_instance\",\n-    \"task_instance_key_str\",\n-    \"test_mode\",\n-    \"templates_dict\",\n-    \"ti\",\n-    \"triggering_asset_events\",\n-    \"ts\",\n-    \"ts_nodash\",\n-    \"ts_nodash_with_tz\",\n-    \"try_number\",\n-    \"var\",\n-}\n+warnings.warn(\n+    \"Module airflow.utils.context is deprecated and will be removed in the \"\n+    \"future. Use airflow.sdk.execution_time.context if you are using the \"\n+    \"classes inside an Airflow task.\",\n+    DeprecatedImportWarning,",
      "comment": "Not formally but we raise the `DeprecatedImportWarning` warning indicating that we can remove these _rather soon_. Once these warnings are issued, user's shouldn't be surprised if we remove the deprecated items at any point (but most likely it will be Airflow 4)",
      "comment_id": 2660357631,
      "user": "amoghrajesh",
      "created_at": "2026-01-05T05:50:24Z",
      "url": "https://github.com/apache/airflow/pull/59922#discussion_r2660357631"
    },
    {
      "repo": "apache/airflow",
      "pr_number": 59922,
      "file_path": "airflow-core/src/airflow/utils/context.py",
      "line": 42,
      "side": "RIGHT",
      "diff_hunk": "@@ -32,51 +32,16 @@\n     VariableAccessor as VariableAccessorSDK,\n )\n from airflow.serialization.definitions.notset import NOTSET, is_arg_set\n-from airflow.utils.deprecation_tools import DeprecatedImportWarning\n+from airflow.utils.deprecation_tools import DeprecatedImportWarning, add_deprecated_classes\n from airflow.utils.session import create_session\n \n-# NOTE: Please keep this in sync with the following:\n-# * Context in task-sdk/src/airflow/sdk/definitions/context.py\n-# * Table in docs/apache-airflow/templates-ref.rst\n-KNOWN_CONTEXT_KEYS: set[str] = {\n-    \"conn\",\n-    \"dag\",\n-    \"dag_run\",\n-    \"data_interval_end\",\n-    \"data_interval_start\",\n-    \"ds\",\n-    \"ds_nodash\",\n-    \"expanded_ti_count\",\n-    \"exception\",\n-    \"inlets\",\n-    \"inlet_events\",\n-    \"logical_date\",\n-    \"macros\",\n-    \"map_index_template\",\n-    \"outlets\",\n-    \"outlet_events\",\n-    \"params\",\n-    \"prev_data_interval_start_success\",\n-    \"prev_data_interval_end_success\",\n-    \"prev_start_date_success\",\n-    \"prev_end_date_success\",\n-    \"reason\",\n-    \"run_id\",\n-    \"start_date\",\n-    \"task\",\n-    \"task_reschedule_count\",\n-    \"task_instance\",\n-    \"task_instance_key_str\",\n-    \"test_mode\",\n-    \"templates_dict\",\n-    \"ti\",\n-    \"triggering_asset_events\",\n-    \"ts\",\n-    \"ts_nodash\",\n-    \"ts_nodash_with_tz\",\n-    \"try_number\",\n-    \"var\",\n-}\n+warnings.warn(\n+    \"Module airflow.utils.context is deprecated and will be removed in the \"\n+    \"future. Use airflow.sdk.execution_time.context if you are using the \"\n+    \"classes inside an Airflow task.\",\n+    DeprecatedImportWarning,",
      "comment": "Yeah. I am not a big fan of specifying versions in removal. I am ok with Dates (as long as they are followed - see Google Provider deprecation policies), but specifying a version number is not a good idea. We might at some point of time decide to remove it even before Airflow 4. We are not bound here to keep it due to SemVer, we are keeping it because we do not want to make it difficult for users to migrate, and we might at some point of time decide to remove some deprecations if we assess that it brings more cost than benefits. ",
      "comment_id": 2662134118,
      "user": "potiuk",
      "created_at": "2026-01-05T16:42:49Z",
      "url": "https://github.com/apache/airflow/pull/59922#discussion_r2662134118"
    },
    {
      "repo": "apache/airflow",
      "pr_number": 59399,
      "file_path": "airflow-core/src/airflow/api_fastapi/auth/managers/base_auth_manager.py",
      "line": 358,
      "side": "RIGHT",
      "diff_hunk": "@@ -347,6 +348,15 @@ def filter_authorized_menu_items(self, menu_items: list[MenuItem], *, user: T) -\n         :param user: the user\n         \"\"\"\n \n+    @abstractmethod\n+    def is_allowed(self, user_id: str, assigned_users: Sequence[HITLUser]) -> bool:\n+        \"\"\"\n+        Check if a user is allowed to approve/reject a HITL task.\n+\n+        :param user_id: the user id to check\n+        :param assigned_users: list of users assigned to the task\n+        \"\"\"",
      "comment": "Would it be better to rename the method as `is_authorized_hitl_task`? Since `is_allowed` might be too ambiguous for the whole Auth Manger context.",
      "comment_id": 2616898265,
      "user": "jason810496",
      "created_at": "2025-12-14T10:17:32Z",
      "url": "https://github.com/apache/airflow/pull/59399#discussion_r2616898265"
    },
    {
      "repo": "apache/airflow",
      "pr_number": 59399,
      "file_path": "providers/amazon/src/airflow/providers/amazon/aws/auth_manager/aws_auth_manager.py",
      "line": 257,
      "side": "RIGHT",
      "diff_hunk": "@@ -247,6 +248,14 @@ def _has_access_to_menu_item(request: IsAuthorizedRequest):\n \n         return [menu_item for menu_item in menu_items if _has_access_to_menu_item(requests[menu_item.value])]\n \n+    def is_allowed(self, user_id: str, assigned_users: Sequence[HITLUser]) -> bool:\n+        \"\"\"\n+        Check if a user is allowed to approve/reject a HITL task.\n+\n+        User must be in assigned_users list.\n+        \"\"\"\n+        return any(user[\"id\"] == user_id for user in assigned_users)",
      "comment": "How about moving the `any(user[\"id\"] == user_id for user in assigned_users)` condition to `BaseAuthManager`? So that AWS, FAB, KeyCloak manger could reuse it and only SimpleAuthManger need to override the logic.",
      "comment_id": 2616899037,
      "user": "jason810496",
      "created_at": "2025-12-14T10:18:55Z",
      "url": "https://github.com/apache/airflow/pull/59399#discussion_r2616899037"
    },
    {
      "repo": "apache/airflow",
      "pr_number": 59399,
      "file_path": "airflow-core/src/airflow/api_fastapi/auth/managers/base_auth_manager.py",
      "line": 358,
      "side": "RIGHT",
      "diff_hunk": "@@ -347,6 +348,15 @@ def filter_authorized_menu_items(self, menu_items: list[MenuItem], *, user: T) -\n         :param user: the user\n         \"\"\"\n \n+    @abstractmethod\n+    def is_allowed(self, user_id: str, assigned_users: Sequence[HITLUser]) -> bool:\n+        \"\"\"\n+        Check if a user is allowed to approve/reject a HITL task.\n+\n+        :param user_id: the user id to check\n+        :param assigned_users: list of users assigned to the task\n+        \"\"\"",
      "comment": "yeah. I think we need to also wait for @vincbeck to make some decisions on the best API to use. I honestly do not think that leaking \"HITLUser\" to Auth Manager is good choice. Auth Manager should maybe understand HITL as the concept, but imho it should get only the user_ids not on HitlUser objects.\n\n\n",
      "comment_id": 2616941165,
      "user": "potiuk",
      "created_at": "2025-12-14T11:25:55Z",
      "url": "https://github.com/apache/airflow/pull/59399#discussion_r2616941165"
    },
    {
      "repo": "apache/airflow",
      "pr_number": 59399,
      "file_path": "airflow-core/src/airflow/api_fastapi/auth/managers/base_auth_manager.py",
      "line": 358,
      "side": "RIGHT",
      "diff_hunk": "@@ -347,6 +348,15 @@ def filter_authorized_menu_items(self, menu_items: list[MenuItem], *, user: T) -\n         :param user: the user\n         \"\"\"\n \n+    @abstractmethod\n+    def is_allowed(self, user_id: str, assigned_users: Sequence[HITLUser]) -> bool:\n+        \"\"\"\n+        Check if a user is allowed to approve/reject a HITL task.\n+\n+        :param user_id: the user id to check\n+        :param assigned_users: list of users assigned to the task\n+        \"\"\"",
      "comment": "Also that is a new functionality and some thinking on how we communicatee it (newsfragment) and what should be default behaviour for Auth Managers that do not implement it should be.",
      "comment_id": 2616941968,
      "user": "potiuk",
      "created_at": "2025-12-14T11:27:19Z",
      "url": "https://github.com/apache/airflow/pull/59399#discussion_r2616941968"
    },
    {
      "repo": "apache/airflow",
      "pr_number": 59399,
      "file_path": "providers/amazon/src/airflow/providers/amazon/aws/auth_manager/aws_auth_manager.py",
      "line": 257,
      "side": "RIGHT",
      "diff_hunk": "@@ -247,6 +248,14 @@ def _has_access_to_menu_item(request: IsAuthorizedRequest):\n \n         return [menu_item for menu_item in menu_items if _has_access_to_menu_item(requests[menu_item.value])]\n \n+    def is_allowed(self, user_id: str, assigned_users: Sequence[HITLUser]) -> bool:\n+        \"\"\"\n+        Check if a user is allowed to approve/reject a HITL task.\n+\n+        User must be in assigned_users list.\n+        \"\"\"\n+        return any(user[\"id\"] == user_id for user in assigned_users)",
      "comment": "I\u2019ve made the requested changes. Please let me know if anything else needs adjustment.",
      "comment_id": 2617107392,
      "user": "TempestShaw",
      "created_at": "2025-12-14T13:34:08Z",
      "url": "https://github.com/apache/airflow/pull/59399#discussion_r2617107392"
    },
    {
      "repo": "apache/airflow",
      "pr_number": 59399,
      "file_path": "airflow-core/src/airflow/api_fastapi/auth/managers/simple/simple_auth_manager.py",
      "line": 289,
      "side": "RIGHT",
      "diff_hunk": "@@ -283,6 +286,27 @@ def filter_authorized_menu_items(\n     ) -> list[MenuItem]:\n         return menu_items\n \n+    def is_allowed(self, user_id: str, assigned_users: Sequence[HITLUser]) -> bool:",
      "comment": "It seems this one is missing \n\n```suggestion\n    def is_authorized_hitl_task(self, user_id: str, assigned_users: Sequence[HITLUser]) -> bool:\n```",
      "comment_id": 2618057279,
      "user": "jason810496",
      "created_at": "2025-12-15T05:57:37Z",
      "url": "https://github.com/apache/airflow/pull/59399#discussion_r2618057279"
    },
    {
      "repo": "apache/airflow",
      "pr_number": 59399,
      "file_path": "airflow-core/src/airflow/api_fastapi/auth/managers/base_auth_manager.py",
      "line": 351,
      "side": "RIGHT",
      "diff_hunk": "@@ -347,6 +348,18 @@ def filter_authorized_menu_items(self, menu_items: list[MenuItem], *, user: T) -\n         :param user: the user\n         \"\"\"\n \n+    def is_authorized_hitl_task(self, user_id: str, assigned_users: Sequence[HITLUser]) -> bool:",
      "comment": "Let's try to follow the other APIs pattern. Also, I am not a big fan of having `HITLUser` as dependency of the base auth manager. In fact, we only need the user ID.\r\n\r\n```suggestion\r\n    def is_authorized_hitl_task(self, *, assigned_users: set[str], user: T) -> bool:\r\n```",
      "comment_id": 2620030786,
      "user": "vincbeck",
      "created_at": "2025-12-15T16:14:23Z",
      "url": "https://github.com/apache/airflow/pull/59399#discussion_r2620030786"
    },
    {
      "repo": "apache/airflow",
      "pr_number": 59399,
      "file_path": "airflow-core/src/airflow/api_fastapi/auth/managers/simple/simple_auth_manager.py",
      "line": 307,
      "side": "RIGHT",
      "diff_hunk": "@@ -283,6 +286,27 @@ def filter_authorized_menu_items(\n     ) -> list[MenuItem]:\n         return menu_items\n \n+    def is_allowed(self, user_id: str, assigned_users: Sequence[HITLUser]) -> bool:\n+        \"\"\"\n+        Check if a user is allowed to approve/reject a HITL task.\n+\n+        When simple_auth_manager_all_admins=True, all authenticated users are allowed\n+        to approve/reject any task. Otherwise, the user must be in the assigned_users list.\n+        \"\"\"\n+        is_simple_auth_manager_all_admins = conf.getboolean(\"core\", \"simple_auth_manager_all_admins\")\n+\n+        if is_simple_auth_manager_all_admins:\n+            # In all-admin mode, everyone is allowed\n+            return True\n+\n+        # If no assigned_users specified, allow access\n+        if not assigned_users:\n+            return True\n+\n+        # Check if user is in the assigned_users list\n+        allowed = any(user[\"id\"] == user_id for user in assigned_users)",
      "comment": "We should fallback to the default implementation instead of rewriting it? `return super().is_authorized_hitl_task(...)`",
      "comment_id": 2620035568,
      "user": "vincbeck",
      "created_at": "2025-12-15T16:16:01Z",
      "url": "https://github.com/apache/airflow/pull/59399#discussion_r2620035568"
    },
    {
      "repo": "apache/airflow",
      "pr_number": 59399,
      "file_path": "airflow-core/src/airflow/api_fastapi/auth/managers/base_auth_manager.py",
      "line": 358,
      "side": "RIGHT",
      "diff_hunk": "@@ -347,6 +348,15 @@ def filter_authorized_menu_items(self, menu_items: list[MenuItem], *, user: T) -\n         :param user: the user\n         \"\"\"\n \n+    @abstractmethod\n+    def is_allowed(self, user_id: str, assigned_users: Sequence[HITLUser]) -> bool:\n+        \"\"\"\n+        Check if a user is allowed to approve/reject a HITL task.\n+\n+        :param user_id: the user id to check\n+        :param assigned_users: list of users assigned to the task\n+        \"\"\"",
      "comment": "Since there is a default implementation in the base auth manager, do we really need it?",
      "comment_id": 2620040642,
      "user": "vincbeck",
      "created_at": "2025-12-15T16:17:53Z",
      "url": "https://github.com/apache/airflow/pull/59399#discussion_r2620040642"
    },
    {
      "repo": "apache/airflow",
      "pr_number": 59941,
      "file_path": "providers/amazon/src/airflow/providers/amazon/aws/hooks/athena_sql.py",
      "line": 28,
      "side": "RIGHT",
      "diff_hunk": "@@ -21,7 +21,11 @@\n from typing import TYPE_CHECKING, Any\n \n import pyathena\n-from sqlalchemy.engine.url import URL\n+\n+try:\n+    from sqlalchemy.engine.url import URL\n+except ImportError:\n+    URL = None",
      "comment": "@potiuk Please note before approving similar PRs that leaving `URL` untyped (i.e. `URL: Any` before the try block) or unignored (`# type: ignore[assignment,misc]`) leads to mypy violations on SQLA2:\n```none\nproviders/amazon/src/airflow/providers/amazon/aws/hooks/redshift_sql.py:30: error: Cannot assign to a type  [misc]\n        URL = create_engine = None\n        ^~~\nproviders/amazon/src/airflow/providers/amazon/aws/hooks/redshift_sql.py:30: error: Incompatible types in assignment (expression has\ntype \"None\", variable has type \"type[URL]\")  [assignment]\n        URL = create_engine = None\n        ^\nproviders/amazon/src/airflow/providers/amazon/aws/hooks/redshift_sql.py:30: error: Incompatible types in assignment (expression has\ntype \"None\", variable has type overloaded function)  [assignment]\n        URL = create_engine = None\n                              ^~~~\nproviders/amazon/src/airflow/providers/amazon/aws/hooks/athena_sql.py:28: error: Cannot assign to a type  [misc]\n        URL = None\n        ^~~\nproviders/amazon/src/airflow/providers/amazon/aws/hooks/athena_sql.py:28: error: Incompatible types in assignment (expression has type\n\"None\", variable has type \"type[URL]\")  [assignment]\n        URL = None\n              ^~~~\n```",
      "comment_id": 2659530876,
      "user": "Dev-iL",
      "created_at": "2026-01-04T09:26:28Z",
      "url": "https://github.com/apache/airflow/pull/59941#discussion_r2659530876"
    },
    {
      "repo": "apache/airflow",
      "pr_number": 59733,
      "file_path": "airflow-core/tests/unit/api_fastapi/core_api/routes/public/test_pools.py",
      "line": 994,
      "side": "RIGHT",
      "diff_hunk": "@@ -990,7 +991,7 @@ def test_update_mask_preserves_other_fields(self, test_client, session):\n         assert response_data[\"update\"][\"success\"] == [\"pool1\"]\n \n         # Assert: fetch from DB and check only masked field changed\n-        updated_pool = session.query(Pool).filter_by(pool=\"pool1\").one()\n+        updated_pool = session.scalars(select(Pool).where(Pool.pool == \"pool1\")).one()",
      "comment": "what if we use ... \n`updated_pool = session.scalar(select(Pool).where(Pool.pool==\"pool1\"))`",
      "comment_id": 2642021245,
      "user": "Prab-27",
      "created_at": "2025-12-23T05:48:43Z",
      "url": "https://github.com/apache/airflow/pull/59733#discussion_r2642021245"
    },
    {
      "repo": "apache/airflow",
      "pr_number": 59733,
      "file_path": "airflow-core/tests/unit/api_fastapi/core_api/routes/public/test_pools.py",
      "line": 994,
      "side": "RIGHT",
      "diff_hunk": "@@ -990,7 +991,7 @@ def test_update_mask_preserves_other_fields(self, test_client, session):\n         assert response_data[\"update\"][\"success\"] == [\"pool1\"]\n \n         # Assert: fetch from DB and check only masked field changed\n-        updated_pool = session.query(Pool).filter_by(pool=\"pool1\").one()\n+        updated_pool = session.scalars(select(Pool).where(Pool.pool == \"pool1\")).one()",
      "comment": "Good find, made the change in [8cb38d1](https://github.com/apache/airflow/pull/59733/changes/8cb38d121e28d032f1e91e18e2e483b32fb4d6b1)",
      "comment_id": 2644017407,
      "user": "steveahnahn",
      "created_at": "2025-12-23T18:49:43Z",
      "url": "https://github.com/apache/airflow/pull/59733#discussion_r2644017407"
    },
    {
      "repo": "apache/airflow",
      "pr_number": 59733,
      "file_path": "airflow-core/tests/unit/api_fastapi/core_api/routes/public/test_pools.py",
      "line": 994,
      "side": "RIGHT",
      "diff_hunk": "@@ -990,7 +991,7 @@ def test_update_mask_preserves_other_fields(self, test_client, session):\n         assert response_data[\"update\"][\"success\"] == [\"pool1\"]\n \n         # Assert: fetch from DB and check only masked field changed\n-        updated_pool = session.query(Pool).filter_by(pool=\"pool1\").one()\n+        updated_pool = session.execute(select(Pool).where(Pool.pool == \"pool1\")).scalar_one()",
      "comment": "Yes, it works fine, and session.execute().scalar_one() and session.scalars().one() are the same as mentioned [here.](https://docs.sqlalchemy.org/en/14/core/connections.html#sqlalchemy.engine.Result.scalar_one) \n\nSince in the assert conditions we are only checking for a scalar value or None, I thought we could also use session.scalar() as mentioned [here.](https://docs.sqlalchemy.org/en/14/core/connections.html#sqlalchemy.engine.Result.scalar) (It's just my point of view )\n\nwould love to hear your point of view on this.",
      "comment_id": 2644921619,
      "user": "Prab-27",
      "created_at": "2025-12-24T06:32:34Z",
      "url": "https://github.com/apache/airflow/pull/59733#discussion_r2644921619"
    },
    {
      "repo": "apache/airflow",
      "pr_number": 59733,
      "file_path": "airflow-core/tests/unit/api_fastapi/core_api/routes/public/test_pools.py",
      "line": 994,
      "side": "RIGHT",
      "diff_hunk": "@@ -990,7 +991,7 @@ def test_update_mask_preserves_other_fields(self, test_client, session):\n         assert response_data[\"update\"][\"success\"] == [\"pool1\"]\n \n         # Assert: fetch from DB and check only masked field changed\n-        updated_pool = session.query(Pool).filter_by(pool=\"pool1\").one()\n+        updated_pool = session.execute(select(Pool).where(Pool.pool == \"pool1\")).scalar_one()",
      "comment": "We are checking for None value on the fields of updated_pool, however updated_pool itself cannot be None which is why the .one() should be translated to .execute and .scalar_one() whereas .scalar() will allow None to pass through for the updated_pool obj which can cause a false positive error",
      "comment_id": 2649441468,
      "user": "steveahnahn",
      "created_at": "2025-12-28T02:54:35Z",
      "url": "https://github.com/apache/airflow/pull/59733#discussion_r2649441468"
    },
    {
      "repo": "apache/airflow",
      "pr_number": 59733,
      "file_path": "airflow-core/tests/unit/api_fastapi/core_api/routes/public/test_pools.py",
      "line": 994,
      "side": "RIGHT",
      "diff_hunk": "@@ -990,7 +991,7 @@ def test_update_mask_preserves_other_fields(self, test_client, session):\n         assert response_data[\"update\"][\"success\"] == [\"pool1\"]\n \n         # Assert: fetch from DB and check only masked field changed\n-        updated_pool = session.query(Pool).filter_by(pool=\"pool1\").one()\n+        updated_pool = session.execute(select(Pool).where(Pool.pool == \"pool1\")).scalar_one()",
      "comment": "`.scalar()` works, but `.one()` or `scalar_one(`) are stricter for tests here ",
      "comment_id": 2649602827,
      "user": "Prab-27",
      "created_at": "2025-12-28T10:04:40Z",
      "url": "https://github.com/apache/airflow/pull/59733#discussion_r2649602827"
    },
    {
      "repo": "apache/airflow",
      "pr_number": 59971,
      "file_path": "airflow-core/src/airflow/utils/entry_points.py",
      "line": 26,
      "side": "RIGHT",
      "diff_hunk": "@@ -14,48 +14,13 @@\n # KIND, either express or implied.  See the License for the\n # specific language governing permissions and limitations\n # under the License.\n-from __future__ import annotations\n-\n-import functools\n-import logging\n-import sys\n-from collections import defaultdict\n-from collections.abc import Iterator\n-\n-if sys.version_info >= (3, 12):\n-    from importlib import metadata\n-else:\n-    import importlib_metadata as metadata\n-\n-log = logging.getLogger(__name__)\n-\n-EPnD = tuple[metadata.EntryPoint, metadata.Distribution]\n-\n+\"\"\"Re-export entry_points utilities from shared library for backward compatibility.\"\"\"\n \n-@functools.cache\n-def _get_grouped_entry_points() -> dict[str, list[EPnD]]:\n-    mapping: dict[str, list[EPnD]] = defaultdict(list)\n-    for dist in metadata.distributions():\n-        try:\n-            for e in dist.entry_points:\n-                mapping[e.group].append((e, dist))\n-        except Exception as e:\n-            log.warning(\"Error when retrieving package metadata (skipping it): %s, %s\", dist, e)\n-    return mapping\n-\n-\n-def entry_points_with_dist(group: str) -> Iterator[EPnD]:\n-    \"\"\"\n-    Retrieve entry points of the given group.\n-\n-    This is like the ``entry_points()`` function from ``importlib.metadata``,\n-    except it also returns the distribution the entry point was loaded from.\n-\n-    Note that this may return multiple distributions to the same package if they\n-    are loaded from different ``sys.path`` entries. The caller site should\n-    implement appropriate deduplication logic if needed.\n+from __future__ import annotations\n \n-    :param group: Filter results to only this entrypoint group\n-    :return: Generator of (EntryPoint, Distribution) objects for the specified groups\n-    \"\"\"\n-    return iter(_get_grouped_entry_points()[group])\n+from airflow._shared.module_loading.entry_points import (\n+    EPnD as EPnD,\n+    _get_grouped_entry_points as _get_grouped_entry_points,\n+    entry_points_with_dist as entry_points_with_dist,\n+    metadata as metadata,\n+)",
      "comment": "It's rare that someone would use `entry_points_with_dist` directly but its a public method and we cannot break backcompat, so re-exporting these to be sure.",
      "comment_id": 2655489254,
      "user": "amoghrajesh",
      "created_at": "2025-12-31T14:37:30Z",
      "url": "https://github.com/apache/airflow/pull/59971#discussion_r2655489254"
    },
    {
      "repo": "apache/airflow",
      "pr_number": 59971,
      "file_path": "shared/module_loading/src/airflow_shared/module_loading/entry_points.py",
      "line": 1,
      "side": "RIGHT",
      "diff_hunk": "@@ -0,0 +1,62 @@\n+#",
      "comment": "Same as the other methods - I think with such a small shared module, moving everything to `__init__.py` makes more sense. I think if we wanted to separate module, that should be a separate \"shared\" distribution\".",
      "comment_id": 2655543306,
      "user": "potiuk",
      "created_at": "2025-12-31T15:20:58Z",
      "url": "https://github.com/apache/airflow/pull/59971#discussion_r2655543306"
    },
    {
      "repo": "apache/airflow",
      "pr_number": 59971,
      "file_path": "shared/module_loading/src/airflow_shared/module_loading/entry_points.py",
      "line": 1,
      "side": "RIGHT",
      "diff_hunk": "@@ -0,0 +1,62 @@\n+#",
      "comment": "Will move it to init itself, these two functions are related to module_loading itself, so wouldnt want to create a new library for that",
      "comment_id": 2655572155,
      "user": "amoghrajesh",
      "created_at": "2025-12-31T15:45:07Z",
      "url": "https://github.com/apache/airflow/pull/59971#discussion_r2655572155"
    },
    {
      "repo": "apache/airflow",
      "pr_number": 59971,
      "file_path": "airflow-core/src/airflow/utils/entry_points.py",
      "line": 26,
      "side": "RIGHT",
      "diff_hunk": "@@ -14,48 +14,13 @@\n # KIND, either express or implied.  See the License for the\n # specific language governing permissions and limitations\n # under the License.\n-from __future__ import annotations\n-\n-import functools\n-import logging\n-import sys\n-from collections import defaultdict\n-from collections.abc import Iterator\n-\n-if sys.version_info >= (3, 12):\n-    from importlib import metadata\n-else:\n-    import importlib_metadata as metadata\n-\n-log = logging.getLogger(__name__)\n-\n-EPnD = tuple[metadata.EntryPoint, metadata.Distribution]\n-\n+\"\"\"Re-export entry_points utilities from shared library for backward compatibility.\"\"\"\n \n-@functools.cache\n-def _get_grouped_entry_points() -> dict[str, list[EPnD]]:\n-    mapping: dict[str, list[EPnD]] = defaultdict(list)\n-    for dist in metadata.distributions():\n-        try:\n-            for e in dist.entry_points:\n-                mapping[e.group].append((e, dist))\n-        except Exception as e:\n-            log.warning(\"Error when retrieving package metadata (skipping it): %s, %s\", dist, e)\n-    return mapping\n-\n-\n-def entry_points_with_dist(group: str) -> Iterator[EPnD]:\n-    \"\"\"\n-    Retrieve entry points of the given group.\n-\n-    This is like the ``entry_points()`` function from ``importlib.metadata``,\n-    except it also returns the distribution the entry point was loaded from.\n-\n-    Note that this may return multiple distributions to the same package if they\n-    are loaded from different ``sys.path`` entries. The caller site should\n-    implement appropriate deduplication logic if needed.\n+from __future__ import annotations\n \n-    :param group: Filter results to only this entrypoint group\n-    :return: Generator of (EntryPoint, Distribution) objects for the specified groups\n-    \"\"\"\n-    return iter(_get_grouped_entry_points()[group])\n+from airflow._shared.module_loading.entry_points import (\n+    EPnD as EPnD,\n+    _get_grouped_entry_points as _get_grouped_entry_points,\n+    entry_points_with_dist as entry_points_with_dist,\n+    metadata as metadata,\n+)",
      "comment": "Really? I would have not assumed this is public API even though not declared private. Should we mark it deprecated such tat it can be removed in Airflow 4 at least?",
      "comment_id": 2655794532,
      "user": "jscheffl",
      "created_at": "2025-12-31T19:14:58Z",
      "url": "https://github.com/apache/airflow/pull/59971#discussion_r2655794532"
    },
    {
      "repo": "apache/airflow",
      "pr_number": 59971,
      "file_path": "airflow-core/src/airflow/utils/entry_points.py",
      "line": 26,
      "side": "RIGHT",
      "diff_hunk": "@@ -14,48 +14,13 @@\n # KIND, either express or implied.  See the License for the\n # specific language governing permissions and limitations\n # under the License.\n-from __future__ import annotations\n-\n-import functools\n-import logging\n-import sys\n-from collections import defaultdict\n-from collections.abc import Iterator\n-\n-if sys.version_info >= (3, 12):\n-    from importlib import metadata\n-else:\n-    import importlib_metadata as metadata\n-\n-log = logging.getLogger(__name__)\n-\n-EPnD = tuple[metadata.EntryPoint, metadata.Distribution]\n-\n+\"\"\"Re-export entry_points utilities from shared library for backward compatibility.\"\"\"\n \n-@functools.cache\n-def _get_grouped_entry_points() -> dict[str, list[EPnD]]:\n-    mapping: dict[str, list[EPnD]] = defaultdict(list)\n-    for dist in metadata.distributions():\n-        try:\n-            for e in dist.entry_points:\n-                mapping[e.group].append((e, dist))\n-        except Exception as e:\n-            log.warning(\"Error when retrieving package metadata (skipping it): %s, %s\", dist, e)\n-    return mapping\n-\n-\n-def entry_points_with_dist(group: str) -> Iterator[EPnD]:\n-    \"\"\"\n-    Retrieve entry points of the given group.\n-\n-    This is like the ``entry_points()`` function from ``importlib.metadata``,\n-    except it also returns the distribution the entry point was loaded from.\n-\n-    Note that this may return multiple distributions to the same package if they\n-    are loaded from different ``sys.path`` entries. The caller site should\n-    implement appropriate deduplication logic if needed.\n+from __future__ import annotations\n \n-    :param group: Filter results to only this entrypoint group\n-    :return: Generator of (EntryPoint, Distribution) objects for the specified groups\n-    \"\"\"\n-    return iter(_get_grouped_entry_points()[group])\n+from airflow._shared.module_loading.entry_points import (\n+    EPnD as EPnD,\n+    _get_grouped_entry_points as _get_grouped_entry_points,\n+    entry_points_with_dist as entry_points_with_dist,\n+    metadata as metadata,\n+)",
      "comment": "Here you go: https://github.com/apache/airflow/pull/60061",
      "comment_id": 2658219297,
      "user": "amoghrajesh",
      "created_at": "2026-01-02T18:37:52Z",
      "url": "https://github.com/apache/airflow/pull/59971#discussion_r2658219297"
    },
    {
      "repo": "apache/airflow",
      "pr_number": 58659,
      "file_path": "airflow-core/src/airflow/cli/cli_config.py",
      "line": 796,
      "side": "RIGHT",
      "diff_hunk": "@@ -789,6 +789,11 @@ def string_lower_type(val):\n     (\"option\",),\n     help=\"The option name\",\n )\n+ARG_CONFIG_HIDE_SENSITIVE = Arg(\n+    (\"--hide-sensitive\",),\n+    action=\"store_true\",\n+    help=\"Hide sensitive configuration values (passwords, keys, etc.) in the output.\",\n+)",
      "comment": "Should we hide by default and have `--no-mask-sensitive` instead?",
      "comment_id": 2567412187,
      "user": "uranusjr",
      "created_at": "2025-11-27T07:17:34Z",
      "url": "https://github.com/apache/airflow/pull/58659#discussion_r2567412187"
    },
    {
      "repo": "apache/airflow",
      "pr_number": 58659,
      "file_path": "airflow-core/src/airflow/cli/cli_config.py",
      "line": 796,
      "side": "RIGHT",
      "diff_hunk": "@@ -789,6 +789,11 @@ def string_lower_type(val):\n     (\"option\",),\n     help=\"The option name\",\n )\n+ARG_CONFIG_HIDE_SENSITIVE = Arg(\n+    (\"--hide-sensitive\",),\n+    action=\"store_true\",\n+    help=\"Hide sensitive configuration values (passwords, keys, etc.) in the output.\",\n+)",
      "comment": "@uranusjr I think that will be a better option. Thus, the situation will be \r\n- CLI`* list` will not show any values\r\n- flag like `--no-mask-sensitive` will not mask the sensitive values and show all the values.\r\nShould we have another flag to show only the non-sensitive values?",
      "comment_id": 2583730628,
      "user": "arnoldmr01",
      "created_at": "2025-12-03T05:55:33Z",
      "url": "https://github.com/apache/airflow/pull/58659#discussion_r2583730628"
    },
    {
      "repo": "apache/airflow",
      "pr_number": 58659,
      "file_path": "airflow-core/src/airflow/cli/cli_config.py",
      "line": 796,
      "side": "RIGHT",
      "diff_hunk": "@@ -789,6 +789,11 @@ def string_lower_type(val):\n     (\"option\",),\n     help=\"The option name\",\n )\n+ARG_CONFIG_HIDE_SENSITIVE = Arg(\n+    (\"--hide-sensitive\",),\n+    action=\"store_true\",\n+    help=\"Hide sensitive configuration values (passwords, keys, etc.) in the output.\",\n+)",
      "comment": "We agreed on the devlist (and there was a lazy consensus on that) - see https://lists.apache.org/thread/3dhzqvpw4z2x0wfokpmdncsjwws86zcs point 5:\r\n\r\n\r\n> 5) local CLI * list (connections, variables, config) only by default\r\nreturns \"keys\" - and it will only return values when `--show-values`\r\nis passed as command line option (with clear comment in help that this\r\noption **might** show sensitive data, also when we do `* list` command\r\nwithout `--show-values` we emit stderr output explaining that\r\npotentially sensitive data is hidden and you need to specify\r\n`--show-values` to see them\r\n\r\n\r\n",
      "comment_id": 2583961037,
      "user": "potiuk",
      "created_at": "2025-12-03T07:34:03Z",
      "url": "https://github.com/apache/airflow/pull/58659#discussion_r2583961037"
    },
    {
      "repo": "apache/airflow",
      "pr_number": 58659,
      "file_path": "airflow-core/src/airflow/cli/cli_config.py",
      "line": 796,
      "side": "RIGHT",
      "diff_hunk": "@@ -789,6 +789,11 @@ def string_lower_type(val):\n     (\"option\",),\n     help=\"The option name\",\n )\n+ARG_CONFIG_HIDE_SENSITIVE = Arg(\n+    (\"--hide-sensitive\",),\n+    action=\"store_true\",\n+    help=\"Hide sensitive configuration values (passwords, keys, etc.) in the output.\",\n+)",
      "comment": "Let's follow by the letter what we agreed. Thsi is not an opinion any more, this is something what we agreed to on devlist.",
      "comment_id": 2583962711,
      "user": "potiuk",
      "created_at": "2025-12-03T07:34:42Z",
      "url": "https://github.com/apache/airflow/pull/58659#discussion_r2583962711"
    },
    {
      "repo": "apache/airflow",
      "pr_number": 58659,
      "file_path": "airflow-core/src/airflow/cli/cli_config.py",
      "line": 796,
      "side": "RIGHT",
      "diff_hunk": "@@ -789,6 +789,11 @@ def string_lower_type(val):\n     (\"option\",),\n     help=\"The option name\",\n )\n+ARG_CONFIG_HIDE_SENSITIVE = Arg(\n+    (\"--hide-sensitive\",),\n+    action=\"store_true\",\n+    help=\"Hide sensitive configuration values (passwords, keys, etc.) in the output.\",\n+)",
      "comment": "> Should we have another flag to show only the non-sensitive values?\r\n\r\n\r\nI think we can add that one flag.",
      "comment_id": 2584136016,
      "user": "potiuk",
      "created_at": "2025-12-03T08:38:34Z",
      "url": "https://github.com/apache/airflow/pull/58659#discussion_r2584136016"
    },
    {
      "repo": "apache/airflow",
      "pr_number": 58659,
      "file_path": "airflow-core/src/airflow/cli/commands/config_command.py",
      "line": 58,
      "side": "RIGHT",
      "diff_hunk": "@@ -48,6 +55,8 @@ def show_config(args):\n             include_providers=not args.exclude_providers,\n             comment_out_everything=args.comment_out_everything or args.defaults,\n             only_defaults=args.defaults,\n+            non_sensitive=args.non_sensitive,\n+            show_values=args.show_values,",
      "comment": "Will it be an issue if `args.show_values` does not exist? (since you use getattr to check above)",
      "comment_id": 2633978095,
      "user": "Lee-W",
      "created_at": "2025-12-19T07:13:40Z",
      "url": "https://github.com/apache/airflow/pull/58659#discussion_r2633978095"
    },
    {
      "repo": "apache/airflow",
      "pr_number": 58659,
      "file_path": "airflow-core/src/airflow/cli/commands/config_command.py",
      "line": 42,
      "side": "RIGHT",
      "diff_hunk": "@@ -37,6 +38,12 @@\n @providers_configuration_loaded\n def show_config(args):\n     \"\"\"Show current application configuration.\"\"\"\n+    show_values = getattr(args, \"show_values\", False)\n+    if not show_values:",
      "comment": "```suggestion\n    if not (show_values := getattr(args, \"show_values\", False)):\n```",
      "comment_id": 2633978993,
      "user": "Lee-W",
      "created_at": "2025-12-19T07:13:55Z",
      "url": "https://github.com/apache/airflow/pull/58659#discussion_r2633978993"
    },
    {
      "repo": "apache/airflow",
      "pr_number": 58659,
      "file_path": "airflow-core/src/airflow/cli/commands/config_command.py",
      "line": 58,
      "side": "RIGHT",
      "diff_hunk": "@@ -48,6 +55,8 @@ def show_config(args):\n             include_providers=not args.exclude_providers,\n             comment_out_everything=args.comment_out_everything or args.defaults,\n             only_defaults=args.defaults,\n+            non_sensitive=args.non_sensitive,\n+            show_values=args.show_values,",
      "comment": "if not, then we probably don't need the `getattr` check?",
      "comment_id": 2633982164,
      "user": "Lee-W",
      "created_at": "2025-12-19T07:14:41Z",
      "url": "https://github.com/apache/airflow/pull/58659#discussion_r2633982164"
    },
    {
      "repo": "apache/airflow",
      "pr_number": 58659,
      "file_path": "airflow-core/src/airflow/cli/commands/config_command.py",
      "line": 58,
      "side": "RIGHT",
      "diff_hunk": "@@ -48,6 +55,8 @@ def show_config(args):\n             include_providers=not args.exclude_providers,\n             comment_out_everything=args.comment_out_everything or args.defaults,\n             only_defaults=args.defaults,\n+            non_sensitive=args.non_sensitive,\n+            show_values=args.show_values,",
      "comment": "If `args.show_values` does not exit, I think it will cause `AttributeError`.  However \r\n`\r\nARG_CONFIG_SHOW_VALUES = Arg(\r\n    (\"--show-values\",),\r\n    action=\"store_true\",\r\n    help=(\r\n        \"Show configuration values. \"\r\n        \"By default only option names are shown and values (including potentially \"\r\n        \"sensitive ones) are hidden.\"\r\n    ),\r\n)\r\n`\r\nmay ensure that `args.show_values` exit.\r\n\r\nUnder this situation, do you think we can just directly use args.show_values? Or is there any suggesting?",
      "comment_id": 2634572635,
      "user": "arnoldmr01",
      "created_at": "2025-12-19T10:19:25Z",
      "url": "https://github.com/apache/airflow/pull/58659#discussion_r2634572635"
    },
    {
      "repo": "apache/airflow",
      "pr_number": 58659,
      "file_path": "airflow-core/src/airflow/cli/commands/config_command.py",
      "line": 42,
      "side": "RIGHT",
      "diff_hunk": "@@ -37,6 +38,12 @@\n @providers_configuration_loaded\n def show_config(args):\n     \"\"\"Show current application configuration.\"\"\"\n+    show_values = getattr(args, \"show_values\", False)\n+    if not show_values:",
      "comment": "I think it\u2019s enoough to do `if not args.show_values` here",
      "comment_id": 2638994760,
      "user": "uranusjr",
      "created_at": "2025-12-22T07:59:44Z",
      "url": "https://github.com/apache/airflow/pull/58659#discussion_r2638994760"
    },
    {
      "repo": "apache/airflow",
      "pr_number": 58659,
      "file_path": "shared/configuration/src/airflow_shared/configuration/parser.py",
      "line": 1599,
      "side": "RIGHT",
      "diff_hunk": "@@ -1595,29 +1595,39 @@ def _write_value(\n         needs_separation: bool,\n         only_defaults: bool,\n         section_to_write: str,\n+        non_sensitive: bool,\n+        is_sensitive: bool,",
      "comment": "We might need to rename `non_sensitive` parameter under this context, as we also have `is_sensitive` parameter for the same function, so the purpose of `non_sensitive` might be unclear.\n\nMaybe we could name as `hide_sensitive`, `redact_sensitive` or `show_values` etc.",
      "comment_id": 2639144314,
      "user": "jason810496",
      "created_at": "2025-12-22T08:59:45Z",
      "url": "https://github.com/apache/airflow/pull/58659#discussion_r2639144314"
    },
    {
      "repo": "apache/airflow",
      "pr_number": 58659,
      "file_path": "airflow-core/src/airflow/cli/cli_config.py",
      "line": 806,
      "side": "RIGHT",
      "diff_hunk": "@@ -790,6 +790,20 @@ def string_lower_type(val):\n     (\"option\",),\n     help=\"The option name\",\n )\n+ARG_NON_SENSITIVE = Arg(\n+    (\"--non-sensitive\",),\n+    action=\"store_true\",\n+    help=\"When used with --show-values, hide sensitive values (passwords, keys, tokens, etc.) and only show non-sensitive configuration values.\",\n+)\n+ARG_CONFIG_SHOW_VALUES = Arg(\n+    (\"--show-values\",),\n+    action=\"store_true\",\n+    help=(\n+        \"Show configuration values. \"\n+        \"By default only option names are shown and values (including potentially \"\n+        \"sensitive ones) are hidden.\"\n+    ),\n+)",
      "comment": "How about removing `--show-values` flag to remain the behavior as is (showing the value by default without the `--show-values`) to minimize breaking change to user?\n\nThen we might need to change the `--non-sensitive` somehow like `--show-sensitive` and `--show-sensitive` will be default as False.\n",
      "comment_id": 2639169518,
      "user": "jason810496",
      "created_at": "2025-12-22T09:06:43Z",
      "url": "https://github.com/apache/airflow/pull/58659#discussion_r2639169518"
    },
    {
      "repo": "apache/airflow",
      "pr_number": 58659,
      "file_path": "airflow-core/src/airflow/cli/cli_config.py",
      "line": 806,
      "side": "RIGHT",
      "diff_hunk": "@@ -790,6 +790,20 @@ def string_lower_type(val):\n     (\"option\",),\n     help=\"The option name\",\n )\n+ARG_NON_SENSITIVE = Arg(\n+    (\"--non-sensitive\",),\n+    action=\"store_true\",\n+    help=\"When used with --show-values, hide sensitive values (passwords, keys, tokens, etc.) and only show non-sensitive configuration values.\",\n+)\n+ARG_CONFIG_SHOW_VALUES = Arg(\n+    (\"--show-values\",),\n+    action=\"store_true\",\n+    help=(\n+        \"Show configuration values. \"\n+        \"By default only option names are shown and values (including potentially \"\n+        \"sensitive ones) are hidden.\"\n+    ),\n+)",
      "comment": "Thanks for the suggestion. While it does preserve the current behavior, the dev list here (https://lists.apache.org/thread/3dhzqvpw4z2x0wfokpmdncsjwws86zcs\r\n) agreed that * list should return keys only; values should be shown via --show-values.",
      "comment_id": 2646289668,
      "user": "arnoldmr01",
      "created_at": "2025-12-24T21:50:21Z",
      "url": "https://github.com/apache/airflow/pull/58659#discussion_r2646289668"
    },
    {
      "repo": "apache/airflow",
      "pr_number": 58659,
      "file_path": "airflow-core/src/airflow/cli/cli_config.py",
      "line": 806,
      "side": "RIGHT",
      "diff_hunk": "@@ -790,6 +790,20 @@ def string_lower_type(val):\n     (\"option\",),\n     help=\"The option name\",\n )\n+ARG_NON_SENSITIVE = Arg(\n+    (\"--non-sensitive\",),\n+    action=\"store_true\",\n+    help=\"When used with --show-values, hide sensitive values (passwords, keys, tokens, etc.) and only show non-sensitive configuration values.\",\n+)\n+ARG_CONFIG_SHOW_VALUES = Arg(\n+    (\"--show-values\",),\n+    action=\"store_true\",\n+    help=(\n+        \"Show configuration values. \"\n+        \"By default only option names are shown and values (including potentially \"\n+        \"sensitive ones) are hidden.\"\n+    ),\n+)",
      "comment": "Thanks for sharing the context! I see, then we could keep it as is. Thanks!",
      "comment_id": 2646503654,
      "user": "jason810496",
      "created_at": "2025-12-25T03:52:09Z",
      "url": "https://github.com/apache/airflow/pull/58659#discussion_r2646503654"
    },
    {
      "repo": "apache/airflow",
      "pr_number": 58659,
      "file_path": "shared/configuration/src/airflow_shared/configuration/parser.py",
      "line": 1599,
      "side": "RIGHT",
      "diff_hunk": "@@ -1595,29 +1595,39 @@ def _write_value(\n         needs_separation: bool,\n         only_defaults: bool,\n         section_to_write: str,\n+        non_sensitive: bool,\n+        is_sensitive: bool,",
      "comment": "Thanks for your advice. I will modify it with `hide-sensitive`",
      "comment_id": 2647345380,
      "user": "arnoldmr01",
      "created_at": "2025-12-26T00:45:33Z",
      "url": "https://github.com/apache/airflow/pull/58659#discussion_r2647345380"
    },
    {
      "repo": "apache/airflow",
      "pr_number": 58603,
      "file_path": "providers/discord/src/airflow/providers/discord/notifications/discord.py",
      "line": 50,
      "side": "LEFT",
      "diff_hunk": "@@ -39,18 +43,21 @@ class DiscordNotifier(BaseNotifier):\n     :param username: The username to send the message as. Optional\n     :param avatar_url: The URL of the avatar to use for the message. Optional\n     :param tts: Text to speech.\n+    :param embed: Discord embed object. See:\n+           https://discord.com/developers/docs/resources/message#embed-object-embed-author-structure\n     \"\"\"\n \n     # A property that specifies the attributes that can be templated.\n-    template_fields = (\"discord_conn_id\", \"text\", \"username\", \"avatar_url\", \"tts\")\n+    template_fields = (\"discord_conn_id\", \"text\", \"username\", \"avatar_url\", \"tts\", \"embed\")\n \n     def __init__(\n         self,\n         discord_conn_id: str = \"discord_webhook_default\",\n-        text: str = \"This is a default message\",",
      "comment": "Is it by API required to have a mandatory text? Can we rather add a validationor make this property mandatory instead of adding a default? (Or is the change committed by accident?)",
      "comment_id": 2652612739,
      "user": "jscheffl",
      "created_at": "2025-12-30T09:38:47Z",
      "url": "https://github.com/apache/airflow/pull/58603#discussion_r2652612739"
    },
    {
      "repo": "apache/airflow",
      "pr_number": 58603,
      "file_path": "providers/discord/src/airflow/providers/discord/notifications/discord.py",
      "line": 51,
      "side": "RIGHT",
      "diff_hunk": "@@ -39,18 +43,21 @@ class DiscordNotifier(BaseNotifier):\n     :param username: The username to send the message as. Optional\n     :param avatar_url: The URL of the avatar to use for the message. Optional\n     :param tts: Text to speech.\n+    :param embed: Discord embed object. See:\n+           https://discord.com/developers/docs/resources/message#embed-object-embed-author-structure\n     \"\"\"\n \n     # A property that specifies the attributes that can be templated.\n-    template_fields = (\"discord_conn_id\", \"text\", \"username\", \"avatar_url\", \"tts\")\n+    template_fields = (\"discord_conn_id\", \"text\", \"username\", \"avatar_url\", \"tts\", \"embed\")",
      "comment": "If you make this a tempalted field, can the structure of \"TypedDict\" be templated at all? (e.g. read from a JSON?) Or does a customer \"fom_json\" need to be supported and implemented in Embed?",
      "comment_id": 2652615875,
      "user": "jscheffl",
      "created_at": "2025-12-30T09:40:28Z",
      "url": "https://github.com/apache/airflow/pull/58603#discussion_r2652615875"
    },
    {
      "repo": "apache/airflow",
      "pr_number": 58603,
      "file_path": "providers/discord/src/airflow/providers/discord/hooks/discord_webhook.py",
      "line": 121,
      "side": "RIGHT",
      "diff_hunk": "@@ -70,21 +115,28 @@ def build_discord_payload(\n                         (max 2000 characters)\n         :param username: Override the default username of the webhook\n         :param avatar_url: Override the default avatar of the webhook\n+        :param embed: Discord embed object.\n         :return: Discord payload (str) to send\n         \"\"\"\n-        if len(message) > 2000:\n-            raise ValueError(\"Discord message length must be 2000 or fewer characters.\")\n-        payload: dict[str, Any] = {\n+        payload = {",
      "comment": "would like to know why did we remove type annotation?",
      "comment_id": 2652669285,
      "user": "Lee-W",
      "created_at": "2025-12-30T10:08:28Z",
      "url": "https://github.com/apache/airflow/pull/58603#discussion_r2652669285"
    },
    {
      "repo": "apache/airflow",
      "pr_number": 58603,
      "file_path": "providers/discord/src/airflow/providers/discord/hooks/discord_webhook.py",
      "line": 126,
      "side": "RIGHT",
      "diff_hunk": "@@ -70,21 +115,28 @@ def build_discord_payload(\n                         (max 2000 characters)\n         :param username: Override the default username of the webhook\n         :param avatar_url: Override the default avatar of the webhook\n+        :param embed: Discord embed object.\n         :return: Discord payload (str) to send\n         \"\"\"\n-        if len(message) > 2000:\n-            raise ValueError(\"Discord message length must be 2000 or fewer characters.\")\n-        payload: dict[str, Any] = {\n+        payload = {\n             \"content\": message,\n             \"tts\": tts,\n         }\n+        if len(message) > 2000:\n+            raise ValueError(\"Discord message length must be 2000 or fewer characters.\")",
      "comment": "\n\nWhy do we move it here? Originally we put it there as we want it to fail early",
      "comment_id": 2652670595,
      "user": "Lee-W",
      "created_at": "2025-12-30T10:09:17Z",
      "url": "https://github.com/apache/airflow/pull/58603#discussion_r2652670595"
    },
    {
      "repo": "apache/airflow",
      "pr_number": 58603,
      "file_path": "providers/discord/src/airflow/providers/discord/hooks/discord_webhook.py",
      "line": 133,
      "side": "RIGHT",
      "diff_hunk": "@@ -70,21 +115,28 @@ def build_discord_payload(\n                         (max 2000 characters)\n         :param username: Override the default username of the webhook\n         :param avatar_url: Override the default avatar of the webhook\n+        :param embed: Discord embed object.\n         :return: Discord payload (str) to send\n         \"\"\"\n-        if len(message) > 2000:\n-            raise ValueError(\"Discord message length must be 2000 or fewer characters.\")\n-        payload: dict[str, Any] = {\n+        payload = {\n             \"content\": message,\n             \"tts\": tts,\n         }\n+        if len(message) > 2000:\n+            raise ValueError(\"Discord message length must be 2000 or fewer characters.\")\n         if username:\n             payload[\"username\"] = username\n         if avatar_url:\n             payload[\"avatar_url\"] = avatar_url\n+        if embed:\n+            payload[\"embeds\"] = [self.validate_embed(embed=embed)]",
      "comment": "Would be better to move it above for early failing",
      "comment_id": 2652671341,
      "user": "Lee-W",
      "created_at": "2025-12-30T10:09:39Z",
      "url": "https://github.com/apache/airflow/pull/58603#discussion_r2652671341"
    },
    {
      "repo": "apache/airflow",
      "pr_number": 58603,
      "file_path": "providers/discord/src/airflow/providers/discord/notifications/discord.py",
      "line": 51,
      "side": "RIGHT",
      "diff_hunk": "@@ -39,18 +43,21 @@ class DiscordNotifier(BaseNotifier):\n     :param username: The username to send the message as. Optional\n     :param avatar_url: The URL of the avatar to use for the message. Optional\n     :param tts: Text to speech.\n+    :param embed: Discord embed object. See:\n+           https://discord.com/developers/docs/resources/message#embed-object-embed-author-structure\n     \"\"\"\n \n     # A property that specifies the attributes that can be templated.\n-    template_fields = (\"discord_conn_id\", \"text\", \"username\", \"avatar_url\", \"tts\")\n+    template_fields = (\"discord_conn_id\", \"text\", \"username\", \"avatar_url\", \"tts\", \"embed\")",
      "comment": "Yes it can. At runtime a TypedDict behaves the same as standard dicts.",
      "comment_id": 2653965284,
      "user": "dondaum",
      "created_at": "2025-12-30T21:59:14Z",
      "url": "https://github.com/apache/airflow/pull/58603#discussion_r2653965284"
    },
    {
      "repo": "apache/airflow",
      "pr_number": 58603,
      "file_path": "providers/discord/src/airflow/providers/discord/notifications/discord.py",
      "line": 50,
      "side": "LEFT",
      "diff_hunk": "@@ -39,18 +43,21 @@ class DiscordNotifier(BaseNotifier):\n     :param username: The username to send the message as. Optional\n     :param avatar_url: The URL of the avatar to use for the message. Optional\n     :param tts: Text to speech.\n+    :param embed: Discord embed object. See:\n+           https://discord.com/developers/docs/resources/message#embed-object-embed-author-structure\n     \"\"\"\n \n     # A property that specifies the attributes that can be templated.\n-    template_fields = (\"discord_conn_id\", \"text\", \"username\", \"avatar_url\", \"tts\")\n+    template_fields = (\"discord_conn_id\", \"text\", \"username\", \"avatar_url\", \"tts\", \"embed\")\n \n     def __init__(\n         self,\n         discord_conn_id: str = \"discord_webhook_default\",\n-        text: str = \"This is a default message\",",
      "comment": "I think at least one of the following needs to be provided:\r\n- content\r\n- embeds\r\n- sticker_ids\r\n- components\r\n- files[n]\r\n- poll\r\n\r\nHowever content can be an empty string.\r\n\r\nSee Discord API [doc](https://discord.com/developers/docs/resources/message#create-message-jsonform-params)",
      "comment_id": 2654016009,
      "user": "dondaum",
      "created_at": "2025-12-30T22:21:21Z",
      "url": "https://github.com/apache/airflow/pull/58603#discussion_r2654016009"
    },
    {
      "repo": "apache/airflow",
      "pr_number": 58603,
      "file_path": "providers/discord/src/airflow/providers/discord/hooks/discord_webhook.py",
      "line": 133,
      "side": "RIGHT",
      "diff_hunk": "@@ -70,21 +115,28 @@ def build_discord_payload(\n                         (max 2000 characters)\n         :param username: Override the default username of the webhook\n         :param avatar_url: Override the default avatar of the webhook\n+        :param embed: Discord embed object.\n         :return: Discord payload (str) to send\n         \"\"\"\n-        if len(message) > 2000:\n-            raise ValueError(\"Discord message length must be 2000 or fewer characters.\")\n-        payload: dict[str, Any] = {\n+        payload = {\n             \"content\": message,\n             \"tts\": tts,\n         }\n+        if len(message) > 2000:\n+            raise ValueError(\"Discord message length must be 2000 or fewer characters.\")\n         if username:\n             payload[\"username\"] = username\n         if avatar_url:\n             payload[\"avatar_url\"] = avatar_url\n+        if embed:\n+            payload[\"embeds\"] = [self.validate_embed(embed=embed)]",
      "comment": "`validate_embed()` technically validates, returns the `embed `and adds it to the `payload`. Whenever we move it up, we can separate the validation and the `embed `creation, but we would have two if blocks. In my opinion one if block is cleaner, but I'm open to changing it. WDYT?",
      "comment_id": 2654073353,
      "user": "dondaum",
      "created_at": "2025-12-30T22:35:08Z",
      "url": "https://github.com/apache/airflow/pull/58603#discussion_r2654073353"
    },
    {
      "repo": "apache/airflow",
      "pr_number": 59915,
      "file_path": "providers/exasol/src/airflow/providers/exasol/hooks/exasol.py",
      "line": 104,
      "side": "RIGHT",
      "diff_hunk": "@@ -96,6 +100,10 @@ def sqlalchemy_url(self) -> URL:\n \n         :return: the extracted sqlalchemy.engine.URL object.\n         \"\"\"\n+        if URL is None:\n+            raise AirflowOptionalProviderFeatureException(",
      "comment": "```suggestion\n            raise AirflowOptionalProviderFeatureException(\n            \"sqlalchemy is required for SQL filter clause generation. \"\n            \"Install it with: pip install 'apache-airflow-providers-exasol[sqlalchemy]'\"\n        )\n```",
      "comment_id": 2652352587,
      "user": "sunank200",
      "created_at": "2025-12-30T06:52:22Z",
      "url": "https://github.com/apache/airflow/pull/59915#discussion_r2652352587"
    },
    {
      "repo": "apache/airflow",
      "pr_number": 59915,
      "file_path": "providers/exasol/src/airflow/providers/exasol/hooks/exasol.py",
      "line": 104,
      "side": "RIGHT",
      "diff_hunk": "@@ -96,6 +100,10 @@ def sqlalchemy_url(self) -> URL:\n \n         :return: the extracted sqlalchemy.engine.URL object.\n         \"\"\"\n+        if URL is None:\n+            raise AirflowOptionalProviderFeatureException(",
      "comment": "In the case described above you need to add it as optional dependency in pyproject.toml as well.",
      "comment_id": 2652600584,
      "user": "jscheffl",
      "created_at": "2025-12-30T09:31:43Z",
      "url": "https://github.com/apache/airflow/pull/59915#discussion_r2652600584"
    },
    {
      "repo": "apache/airflow",
      "pr_number": 59915,
      "file_path": "providers/exasol/src/airflow/providers/exasol/hooks/exasol.py",
      "line": 104,
      "side": "RIGHT",
      "diff_hunk": "@@ -96,6 +100,10 @@ def sqlalchemy_url(self) -> URL:\n \n         :return: the extracted sqlalchemy.engine.URL object.\n         \"\"\"\n+        if URL is None:\n+            raise AirflowOptionalProviderFeatureException(",
      "comment": "@jscheffl I added a [project.optional-dependencies] section to the pyproject.toml.  I greped around and found an example where this is used, so I think I got the format right. \r\n\r\n@sunank200 Regarding the error message: I went ahead and left the error message as is for now.  Since in this file sqlalchemy is being used to generate a DB connection URI.  Mentioning 'SQL filter clauses' might be a little confusing.",
      "comment_id": 2652945434,
      "user": "Jkhall81",
      "created_at": "2025-12-30T12:50:06Z",
      "url": "https://github.com/apache/airflow/pull/59915#discussion_r2652945434"
    },
    {
      "repo": "apache/airflow",
      "pr_number": 59651,
      "file_path": "providers/standard/tests/unit/standard/sensors/test_time_delta.py",
      "line": 176,
      "side": "LEFT",
      "diff_hunk": "@@ -172,8 +172,9 @@ def setup_method(self):\n     def test_timedelta_sensor(self, mocker, should_defer):\n         defer_mock = mocker.patch(DEFER_PATH)\n         delta = timedelta(hours=1)\n-        with pytest.warns(AirflowProviderDeprecationWarning):\n-            op = TimeDeltaSensorAsync(task_id=\"timedelta_sensor_check\", delta=delta, dag=self.dag)",
      "comment": "we might still want the deprecation warning? And not to fully remove the sensor - the deprecation said next **_major version_**",
      "comment_id": 2636071927,
      "user": "fritz-astronomer",
      "created_at": "2025-12-19T19:30:55Z",
      "url": "https://github.com/apache/airflow/pull/59651#discussion_r2636071927"
    },
    {
      "repo": "apache/airflow",
      "pr_number": 59724,
      "file_path": "airflow-core/src/airflow/jobs/scheduler_job_runner.py",
      "line": 1935,
      "side": "RIGHT",
      "diff_hunk": "@@ -1923,43 +1926,26 @@ def _create_dag_runs_asset_triggered(\n             dag_run.consumed_asset_events.extend(asset_events)\n             session.execute(delete(AssetDagRunQueue).where(AssetDagRunQueue.target_dag_id == dag_run.dag_id))\n \n-    def _should_update_dag_next_dagruns(\n+    def _finished_and_automated(\n         self,\n         dag: SerializedDAG,\n-        dag_model: DagModel,\n         *,\n         last_dag_run: DagRun | None = None,\n-        active_non_backfill_runs: int | None = None,\n-        session: Session,\n     ) -> bool:\n         \"\"\"Check if the dag's next_dagruns_create_after should be updated.\"\"\"",
      "comment": "This docstring should probably be updated to match the func name?",
      "comment_id": 2641900596,
      "user": "uranusjr",
      "created_at": "2025-12-23T04:35:31Z",
      "url": "https://github.com/apache/airflow/pull/59724#discussion_r2641900596"
    },
    {
      "repo": "apache/airflow",
      "pr_number": 59724,
      "file_path": "airflow-core/src/airflow/jobs/scheduler_job_runner.py",
      "line": 1935,
      "side": "RIGHT",
      "diff_hunk": "@@ -1923,43 +1926,26 @@ def _create_dag_runs_asset_triggered(\n             dag_run.consumed_asset_events.extend(asset_events)\n             session.execute(delete(AssetDagRunQueue).where(AssetDagRunQueue.target_dag_id == dag_run.dag_id))\n \n-    def _should_update_dag_next_dagruns(\n+    def _finished_and_automated(\n         self,\n         dag: SerializedDAG,\n-        dag_model: DagModel,\n         *,\n         last_dag_run: DagRun | None = None,\n-        active_non_backfill_runs: int | None = None,\n-        session: Session,\n     ) -> bool:\n         \"\"\"Check if the dag's next_dagruns_create_after should be updated.\"\"\"",
      "comment": "i will just remove that function and inline that small bit of code",
      "comment_id": 2643528908,
      "user": "dstandish",
      "created_at": "2025-12-23T15:18:28Z",
      "url": "https://github.com/apache/airflow/pull/59724#discussion_r2643528908"
    },
    {
      "repo": "apache/airflow",
      "pr_number": 59724,
      "file_path": "airflow-core/src/airflow/jobs/scheduler_job_runner.py",
      "line": 1818,
      "side": "RIGHT",
      "diff_hunk": "@@ -1815,9 +1816,10 @@ def _create_dag_runs(self, dag_models: Collection[DagModel], session: Session) -\n             # we need to set DagModel.next_dagrun_info if the DagRun already exists or if we\n             # create a new one. This is so that in the next scheduling loop we try to create new runs\n             # instead of falling in a loop of IntegrityError.",
      "comment": "Would that cause a bug where a `DagRun` exists but `DagModel.next_dagrun` wasn't updated (the edge case mentioned in the comment), the scheduler will get stuck in an infinite loop attempting to create the same dag run repeatedly?",
      "comment_id": 2644528648,
      "user": "kaxil",
      "created_at": "2025-12-24T00:57:37Z",
      "url": "https://github.com/apache/airflow/pull/59724#discussion_r2644528648"
    },
    {
      "repo": "apache/airflow",
      "pr_number": 59724,
      "file_path": "airflow-core/src/airflow/jobs/scheduler_job_runner.py",
      "line": 2270,
      "side": "RIGHT",
      "diff_hunk": "@@ -2277,6 +2255,43 @@ def _schedule_dag_run(\n \n             return callback_to_run\n \n+    def _update_next_dagrun_fields(\n+        self,\n+        *,\n+        serdag: SerializedDAG,\n+        dag_model: DagModel,\n+        session: Session,\n+        active_non_backfill_runs: int | None = None,\n+        data_interval: DataInterval,\n+    ):\n+        \"\"\"\n+        Conditionally update fields next_dagrun and next_dagrun_create_after on dag table.\n+\n+        The ``dag_run`` param is only to be given when",
      "comment": "that's because in writing the docstring i was like, this is dumb -- we should not do this :) then i went ahead and pulled that param out.\r\n\r\nbasically, you were supposed to _not_ give the dag run when you created the dag run, and you _were_ supposed to give it when you didn't (i.e. when just making scheduling decisions). but that is confusing behavior so i pulled that logic out.",
      "comment_id": 2645704871,
      "user": "dstandish",
      "created_at": "2025-12-24T13:34:16Z",
      "url": "https://github.com/apache/airflow/pull/59724#discussion_r2645704871"
    },
    {
      "repo": "apache/airflow",
      "pr_number": 59724,
      "file_path": "airflow-core/src/airflow/jobs/scheduler_job_runner.py",
      "line": 2270,
      "side": "RIGHT",
      "diff_hunk": "@@ -2277,6 +2255,43 @@ def _schedule_dag_run(\n \n             return callback_to_run\n \n+    def _update_next_dagrun_fields(\n+        self,\n+        *,\n+        serdag: SerializedDAG,\n+        dag_model: DagModel,\n+        session: Session,\n+        active_non_backfill_runs: int | None = None,\n+        data_interval: DataInterval,\n+    ):\n+        \"\"\"\n+        Conditionally update fields next_dagrun and next_dagrun_create_after on dag table.\n+\n+        The ``dag_run`` param is only to be given when",
      "comment": "and the reason you needed to not give it unconditionally is because when you have just createed the run, it's always not in terminated state.  but the \"should update\" logic before would check that the state of the given run must be terminal, else it would not increment next dag run.  so if, in the dag creation context, we were to give it what it asked for (the last dag run) it would have done the wrong thing.  this is why the logic needed to be pulled out so the evaluation happens outside of the function, and the function always does what it says it's going to do.",
      "comment_id": 2645710548,
      "user": "dstandish",
      "created_at": "2025-12-24T13:37:41Z",
      "url": "https://github.com/apache/airflow/pull/59724#discussion_r2645710548"
    },
    {
      "repo": "apache/airflow",
      "pr_number": 59724,
      "file_path": "airflow-core/src/airflow/jobs/scheduler_job_runner.py",
      "line": 1818,
      "side": "RIGHT",
      "diff_hunk": "@@ -1815,9 +1816,10 @@ def _create_dag_runs(self, dag_models: Collection[DagModel], session: Session) -\n             # we need to set DagModel.next_dagrun_info if the DagRun already exists or if we\n             # create a new one. This is so that in the next scheduling loop we try to create new runs\n             # instead of falling in a loop of IntegrityError.",
      "comment": "do you mean because i added the if condition here?\r\n\r\n```\r\n            if created_dag_run:\r\n                self._update_next_dagrun_fields(\r\n                    serdag=serdag,\r\n                    dag_model=dag_model,\r\n                    session=session,\r\n                    active_non_backfill_runs=active_runs_of_dags[serdag.dag_id],\r\n                    data_interval=data_interval,\r\n                )\r\n```\r\n\r\n> Would that cause a bug where a DagRun exists but DagModel.next_dagrun wasn't updated (the edge case mentioned in the comment), the scheduler will get stuck in an infinite loop attempting to create the same dag run repeatedly?\r\n\r\nNo this is not possible because the dag processor, every time it processes a dag, it runs dag_model.calculate_dagrun_date_fields and if it needs to be incremented, it will be.\r\n\r\nBasically, if the scheduler is already trying to create the dagrun that already exists, then something effed up, or something weird happed (like manual trigger of a future logical date).\r\n\r\nThe most common scenario would be, I believe, that the scheduler  _decremented_ next_dagrun.  \r\n\r\nThis can happen in the scheduler because suppose it creates 5 runs for catchup, but then an older one finishes after a later one -- then the scheduler may set the next_dagrun backward because of the way this code works.\r\n\r\n**I think we should add logic so that the scheduler is never setting the next_dagrun backward**. but i am not trying to change that here.\r\n\r\nSo ultimately, I don't think it makes much difference whether we conditionally update based on created or not -- but it doesn't hurt to always update in this context, so I removed the condition.",
      "comment_id": 2645737644,
      "user": "dstandish",
      "created_at": "2025-12-24T13:55:15Z",
      "url": "https://github.com/apache/airflow/pull/59724#discussion_r2645737644"
    },
    {
      "repo": "apache/airflow",
      "pr_number": 59724,
      "file_path": "airflow-core/src/airflow/jobs/scheduler_job_runner.py",
      "line": 2293,
      "side": "RIGHT",
      "diff_hunk": "@@ -2277,6 +2254,47 @@ def _schedule_dag_run(\n \n             return callback_to_run\n \n+    def _update_next_dagrun_fields(\n+        self,\n+        *,\n+        serdag: SerializedDAG,\n+        dag_model: DagModel,\n+        session: Session,\n+        active_non_backfill_runs: int | None = None,\n+        data_interval: DataInterval,\n+    ):\n+        \"\"\"\n+        Conditionally update fields next_dagrun and next_dagrun_create_after on dag table.\n+\n+        If dag exceeds max active runs, don't update.\n+\n+        If dag's timetable not schedulable, don't update.\n+\n+        Otherwise, update.\n+        \"\"\"\n+        exceeds_max, active_runs = self._exceeds_max_active_runs(\n+            dag_model=dag_model,\n+            active_non_backfill_runs=active_non_backfill_runs,\n+            session=session,\n+        )\n+        if exceeds_max:\n+            self.log.info(\n+                \"Dag exceeds max_active_runs; not creating any more runs\",\n+                dag_id=dag_model.dag_id,\n+                active_runs=active_runs,\n+                max_active_runs=dag_model.max_active_runs,\n+            )\n+            # null out next_dagrun_create_after so scheduler will not examine this dag\n+            # this is periodically reconsidered in the scheduler and dag processor.\n+            dag_model.next_dagrun_create_after = None\n+            return\n+\n+        # If the DAG never schedules skip save runtime\n+        if not serdag.timetable.can_be_scheduled:\n+            return",
      "comment": "@kaxil seems that in the \"not schedulable\" case we should set None too \ud83e\udd14",
      "comment_id": 2645747097,
      "user": "dstandish",
      "created_at": "2025-12-24T14:01:21Z",
      "url": "https://github.com/apache/airflow/pull/59724#discussion_r2645747097"
    },
    {
      "repo": "apache/airflow",
      "pr_number": 59724,
      "file_path": "airflow-core/src/airflow/jobs/scheduler_job_runner.py",
      "line": 2293,
      "side": "RIGHT",
      "diff_hunk": "@@ -2277,6 +2254,47 @@ def _schedule_dag_run(\n \n             return callback_to_run\n \n+    def _update_next_dagrun_fields(\n+        self,\n+        *,\n+        serdag: SerializedDAG,\n+        dag_model: DagModel,\n+        session: Session,\n+        active_non_backfill_runs: int | None = None,\n+        data_interval: DataInterval,\n+    ):\n+        \"\"\"\n+        Conditionally update fields next_dagrun and next_dagrun_create_after on dag table.\n+\n+        If dag exceeds max active runs, don't update.\n+\n+        If dag's timetable not schedulable, don't update.\n+\n+        Otherwise, update.\n+        \"\"\"\n+        exceeds_max, active_runs = self._exceeds_max_active_runs(\n+            dag_model=dag_model,\n+            active_non_backfill_runs=active_non_backfill_runs,\n+            session=session,\n+        )\n+        if exceeds_max:\n+            self.log.info(\n+                \"Dag exceeds max_active_runs; not creating any more runs\",\n+                dag_id=dag_model.dag_id,\n+                active_runs=active_runs,\n+                max_active_runs=dag_model.max_active_runs,\n+            )\n+            # null out next_dagrun_create_after so scheduler will not examine this dag\n+            # this is periodically reconsidered in the scheduler and dag processor.\n+            dag_model.next_dagrun_create_after = None\n+            return\n+\n+        # If the DAG never schedules skip save runtime\n+        if not serdag.timetable.can_be_scheduled:\n+            return",
      "comment": "If it can't be scheduled, how did it even get here \ud83e\udd2f",
      "comment_id": 2645748184,
      "user": "dstandish",
      "created_at": "2025-12-24T14:02:02Z",
      "url": "https://github.com/apache/airflow/pull/59724#discussion_r2645748184"
    },
    {
      "repo": "apache/airflow",
      "pr_number": 59724,
      "file_path": "airflow-core/src/airflow/jobs/scheduler_job_runner.py",
      "line": 2293,
      "side": "RIGHT",
      "diff_hunk": "@@ -2277,6 +2253,47 @@ def _schedule_dag_run(\n \n             return callback_to_run\n \n+    def _update_next_dagrun_fields(\n+        self,\n+        *,\n+        serdag: SerializedDAG,\n+        dag_model: DagModel,\n+        session: Session,\n+        active_non_backfill_runs: int | None = None,\n+        data_interval: DataInterval | None,\n+    ):\n+        \"\"\"\n+        Conditionally update fields next_dagrun and next_dagrun_create_after on dag table.\n+\n+        If dag exceeds max active runs, set to None.\n+\n+        If dag's timetable not schedulable, don't update.\n+\n+        Otherwise, update via ``DagModel.calculate_dagrun_date_fields``.\n+        \"\"\"\n+        exceeds_max, active_runs = self._exceeds_max_active_runs(\n+            dag_model=dag_model,\n+            active_non_backfill_runs=active_non_backfill_runs,\n+            session=session,\n+        )\n+        if exceeds_max:\n+            self.log.info(\n+                \"Dag exceeds max_active_runs; not creating any more runs\",\n+                dag_id=dag_model.dag_id,\n+                active_runs=active_runs,\n+                max_active_runs=dag_model.max_active_runs,\n+            )\n+            # null out next_dagrun_create_after so scheduler will not examine this dag\n+            # this is periodically reconsidered in the scheduler and dag processor.\n+            dag_model.next_dagrun_create_after = None\n+            return\n+\n+        # If the DAG never schedules skip save runtime\n+        if not serdag.timetable.can_be_scheduled:\n+            return",
      "comment": "I guess we're moving it here since we believe it's not going to happen. If not so, move it to above and exit early might be better",
      "comment_id": 2650626454,
      "user": "Lee-W",
      "created_at": "2025-12-29T10:08:44Z",
      "url": "https://github.com/apache/airflow/pull/59724#discussion_r2650626454"
    },
    {
      "repo": "apache/airflow",
      "pr_number": 59885,
      "file_path": "dev/breeze/src/airflow_breeze/commands/kubernetes_commands.py",
      "line": 1192,
      "side": "RIGHT",
      "diff_hunk": "@@ -1189,7 +1189,7 @@ def _deploy_helm_chart(\n             \"--kube-context\",\n             kubectl_context,\n             \"--timeout\",\n-            \"10m0s\",\n+            \"20m0s\",",
      "comment": "Perhaps because [m] in isolation means \"meter\" \ud83e\udd37\u200d\u2642\ufe0f",
      "comment_id": 2652572662,
      "user": "Dev-iL",
      "created_at": "2025-12-30T09:16:22Z",
      "url": "https://github.com/apache/airflow/pull/59885#discussion_r2652572662"
    },
    {
      "repo": "apache/airflow",
      "pr_number": 59885,
      "file_path": "dev/breeze/src/airflow_breeze/commands/kubernetes_commands.py",
      "line": 1192,
      "side": "RIGHT",
      "diff_hunk": "@@ -1189,7 +1189,7 @@ def _deploy_helm_chart(\n             \"--kube-context\",\n             kubectl_context,\n             \"--timeout\",\n-            \"10m0s\",\n+            \"20m0s\",",
      "comment": "Seriously - Yeah. I think Go Duration parser would work without it, but all examples have `xm0s` when there is no hour - in all the docs I looked at.\n\nI guess it's a bit of a convention to not confuse it with Month, even if in Go \"M\" is the format for Month.\n\nI saw both \"5m0s\" and \"1h45m\" in docs -> both are obvious, where \"5m\" could be easily understood as 5 months for untrained eye.",
      "comment_id": 2652938098,
      "user": "potiuk",
      "created_at": "2025-12-30T12:45:48Z",
      "url": "https://github.com/apache/airflow/pull/59885#discussion_r2652938098"
    },
    {
      "repo": "apache/airflow",
      "pr_number": 59885,
      "file_path": "dev/breeze/src/airflow_breeze/commands/kubernetes_commands.py",
      "line": 1192,
      "side": "RIGHT",
      "diff_hunk": "@@ -1189,7 +1189,7 @@ def _deploy_helm_chart(\n             \"--kube-context\",\n             kubectl_context,\n             \"--timeout\",\n-            \"10m0s\",\n+            \"20m0s\",",
      "comment": "`--timeout` in months makes more sense than meter!",
      "comment_id": 2654859149,
      "user": "amoghrajesh",
      "created_at": "2025-12-31T06:02:12Z",
      "url": "https://github.com/apache/airflow/pull/59885#discussion_r2654859149"
    },
    {
      "repo": "apache/airflow",
      "pr_number": 59885,
      "file_path": "dev/breeze/src/airflow_breeze/commands/kubernetes_commands.py",
      "line": 1192,
      "side": "RIGHT",
      "diff_hunk": "@@ -1189,7 +1189,7 @@ def _deploy_helm_chart(\n             \"--kube-context\",\n             kubectl_context,\n             \"--timeout\",\n-            \"10m0s\",\n+            \"20m0s\",",
      "comment": "> `--timeout` in months makes more sense than meter!\r\n\r\nA meter of timeout is however long it takes light to travel that distance, so about 3.3ns. I'm sure this is useful in some contexts :P\r\n",
      "comment_id": 2654897794,
      "user": "Dev-iL",
      "created_at": "2025-12-31T06:43:59Z",
      "url": "https://github.com/apache/airflow/pull/59885#discussion_r2654897794"
    },
    {
      "repo": "apache/airflow",
      "pr_number": 59885,
      "file_path": "dev/breeze/src/airflow_breeze/commands/kubernetes_commands.py",
      "line": 1192,
      "side": "RIGHT",
      "diff_hunk": "@@ -1189,7 +1189,7 @@ def _deploy_helm_chart(\n             \"--kube-context\",\n             kubectl_context,\n             \"--timeout\",\n-            \"10m0s\",\n+            \"20m0s\",",
      "comment": "Surely. If we can measure distance in light-years, I am sure we can measure time in light-meters.",
      "comment_id": 2655354264,
      "user": "potiuk",
      "created_at": "2025-12-31T12:46:34Z",
      "url": "https://github.com/apache/airflow/pull/59885#discussion_r2655354264"
    },
    {
      "repo": "apache/airflow",
      "pr_number": 59921,
      "file_path": "providers/openlineage/src/airflow/providers/openlineage/utils/utils.py",
      "line": 541,
      "side": "RIGHT",
      "diff_hunk": "@@ -537,7 +538,13 @@ def is_selective_lineage_enabled(obj: DAG | SerializedDAG | AnyOperator) -> bool\n \n     @provide_session\n     def is_ti_rescheduled_already(ti: TaskInstance, session=NEW_SESSION):\n-        from sqlalchemy import exists, select\n+        try:",
      "comment": "I think that one indicates an issue -> from what I read that method is called in the plugin  in `on_task_instance_running`, which .... will not have the session at all.\n\n```\n| 3.0.0           | ``on_task_instance_running``               | ``session`` argument removed from task instance listeners,                                                                    |\n|                 |                                            | ``task_instance`` object is now an instance of ``RuntimeTaskInstance``                                                        |\n```\n\nSo I'd say this method is not Airflow 3 compatible  ? ",
      "comment_id": 2652892987,
      "user": "potiuk",
      "created_at": "2025-12-30T12:20:56Z",
      "url": "https://github.com/apache/airflow/pull/59921#discussion_r2652892987"
    },
    {
      "repo": "apache/airflow",
      "pr_number": 59921,
      "file_path": "providers/openlineage/src/airflow/providers/openlineage/utils/utils.py",
      "line": 541,
      "side": "RIGHT",
      "diff_hunk": "@@ -537,7 +538,13 @@ def is_selective_lineage_enabled(obj: DAG | SerializedDAG | AnyOperator) -> bool\n \n     @provide_session\n     def is_ti_rescheduled_already(ti: TaskInstance, session=NEW_SESSION):\n-        from sqlalchemy import exists, select\n+        try:",
      "comment": "The `@provide_session` might mask the problem but it still needs to have credentials and connect to the DB of Airflow which should **not** be possible.\n\ncc: @mobuchowski @kacpermuda  ?",
      "comment_id": 2652894297,
      "user": "potiuk",
      "created_at": "2025-12-30T12:21:45Z",
      "url": "https://github.com/apache/airflow/pull/59921#discussion_r2652894297"
    },
    {
      "repo": "apache/airflow",
      "pr_number": 59921,
      "file_path": "providers/openlineage/src/airflow/providers/openlineage/sqlparser.py",
      "line": 503,
      "side": "RIGHT",
      "diff_hunk": "@@ -497,6 +498,14 @@ def get_openlineage_facets_with_sql(\n \n     try:\n         sqlalchemy_engine = hook.get_sqlalchemy_engine()\n+    except ImportError as e:\n+        if \"sqlalchemy\" in str(e).lower() or \"No module named 'sqlalchemy\" in str(e):\n+            raise AirflowOptionalProviderFeatureException(",
      "comment": "I think here we should not raise the exception, but we should raise warning, I think this method should work fine without sqlalchemy - if it can get information from sql_parser (which also does not need sqlalchemy ?) ",
      "comment_id": 2652901240,
      "user": "potiuk",
      "created_at": "2025-12-30T12:25:54Z",
      "url": "https://github.com/apache/airflow/pull/59921#discussion_r2652901240"
    },
    {
      "repo": "apache/airflow",
      "pr_number": 59921,
      "file_path": "providers/openlineage/src/airflow/providers/openlineage/sqlparser.py",
      "line": 503,
      "side": "RIGHT",
      "diff_hunk": "@@ -497,6 +498,14 @@ def get_openlineage_facets_with_sql(\n \n     try:\n         sqlalchemy_engine = hook.get_sqlalchemy_engine()\n+    except ImportError as e:\n+        if \"sqlalchemy\" in str(e).lower() or \"No module named 'sqlalchemy\" in str(e):\n+            raise AirflowOptionalProviderFeatureException(",
      "comment": "Yes, I don't think we need another except here for ImportError, the generic one we have below will do just fine",
      "comment_id": 2652921013,
      "user": "kacpermuda",
      "created_at": "2025-12-30T12:35:36Z",
      "url": "https://github.com/apache/airflow/pull/59921#discussion_r2652921013"
    },
    {
      "repo": "apache/airflow",
      "pr_number": 59921,
      "file_path": "providers/openlineage/src/airflow/providers/openlineage/utils/utils.py",
      "line": 541,
      "side": "RIGHT",
      "diff_hunk": "@@ -537,7 +538,13 @@ def is_selective_lineage_enabled(obj: DAG | SerializedDAG | AnyOperator) -> bool\n \n     @provide_session\n     def is_ti_rescheduled_already(ti: TaskInstance, session=NEW_SESSION):\n-        from sqlalchemy import exists, select\n+        try:",
      "comment": "Just above this snippet, in line 536 you can see that this function is available only for AF2 (hidden behind `if`), so we should be good.",
      "comment_id": 2652921673,
      "user": "kacpermuda",
      "created_at": "2025-12-30T12:35:58Z",
      "url": "https://github.com/apache/airflow/pull/59921#discussion_r2652921673"
    },
    {
      "repo": "apache/airflow",
      "pr_number": 59921,
      "file_path": "providers/openlineage/src/airflow/providers/openlineage/utils/sql.py",
      "line": 177,
      "side": "RIGHT",
      "diff_hunk": "@@ -157,6 +163,18 @@ def create_information_schema_query(\n     sqlalchemy_engine: Engine | None = None,\n ) -> str:\n     \"\"\"Create query for getting table schemas from information schema.\"\"\"\n+    if (\n+        Column is None\n+        or MetaData is None\n+        or Table is None\n+        or and_ is None\n+        or or_ is None\n+        or union_all is None\n+    ):\n+        raise AirflowOptionalProviderFeatureException(\n+            \"sqlalchemy is required for SQL schema query generation. \"\n+            \"Install it with: pip install 'apache-airflow-providers-openlineage[sqlalchemy]'\"\n+        )",
      "comment": "```suggestion\ntry:\n    from sqlalchemy import Column, MetaData, Table, and_, or_, union_all\nexcept ImportError:\n    raise AirflowOptionalProviderFeatureException(\n        \"sqlalchemy is required for SQL schema query generation. \"\n        \"Install it with: pip install 'apache-airflow-providers-openlineage[sqlalchemy]'\"\n    )\n```\nWe need this import in only two places, we can probably go with local imports? Both are fine for me, just nit.",
      "comment_id": 2652928240,
      "user": "kacpermuda",
      "created_at": "2025-12-30T12:39:55Z",
      "url": "https://github.com/apache/airflow/pull/59921#discussion_r2652928240"
    },
    {
      "repo": "apache/airflow",
      "pr_number": 59921,
      "file_path": "providers/openlineage/src/airflow/providers/openlineage/utils/sql.py",
      "line": 242,
      "side": "RIGHT",
      "diff_hunk": "@@ -217,6 +235,11 @@ def create_filter_clauses(\n         therefore it is expected the table has them defined.\n     :param uppercase_names: if True use schema and table names uppercase\n     \"\"\"\n+    if and_ is None or or_ is None:\n+        raise AirflowOptionalProviderFeatureException(\n+            \"sqlalchemy is required for SQL filter clause generation. \"\n+            \"Install it with: pip install 'apache-airflow-providers-openlineage[sqlalchemy]'\"\n+        )",
      "comment": "```suggestion\ntry:\n    from sqlalchemy import and_, or_\nexcept ImportError:\n    raise AirflowOptionalProviderFeatureException(\n        \"sqlalchemy is required for SQL filter clause generation. \"\n        \"Install it with: pip install 'apache-airflow-providers-openlineage[sqlalchemy]'\"\n    )\n```\nSame as above",
      "comment_id": 2652929590,
      "user": "kacpermuda",
      "created_at": "2025-12-30T12:40:39Z",
      "url": "https://github.com/apache/airflow/pull/59921#discussion_r2652929590"
    },
    {
      "repo": "apache/airflow",
      "pr_number": 59921,
      "file_path": "providers/openlineage/src/airflow/providers/openlineage/utils/utils.py",
      "line": 541,
      "side": "RIGHT",
      "diff_hunk": "@@ -537,7 +538,13 @@ def is_selective_lineage_enabled(obj: DAG | SerializedDAG | AnyOperator) -> bool\n \n     @provide_session\n     def is_ti_rescheduled_already(ti: TaskInstance, session=NEW_SESSION):\n-        from sqlalchemy import exists, select\n+        try:",
      "comment": "The function is already guarded by 'if not AIRFLOW_V_3_0_PLUS:' so the inner check for AIRFLOW_V_3_0_PLUS was unreachable dead code. Removed the dead code.",
      "comment_id": 2655422718,
      "user": "sunank200",
      "created_at": "2025-12-31T13:42:45Z",
      "url": "https://github.com/apache/airflow/pull/59921#discussion_r2655422718"
    },
    {
      "repo": "apache/airflow",
      "pr_number": 59958,
      "file_path": "airflow-core/src/airflow/configuration.py",
      "line": 78,
      "side": "RIGHT",
      "diff_hunk": "@@ -74,8 +74,8 @@\n class _SecretKeys:\n     \"\"\"Holds the secret keys used in Airflow during runtime.\"\"\"\n \n-    fernet_key: str | None = None\n-    jwt_secret_key: str | None = None\n+    fernet_key: str = \"\"  # Set only if needed when generating a new file\n+    jwt_secret_key: str = \"\"",
      "comment": "Note this is basically resetting to what has been before in https://github.com/apache/airflow/pull/59819/changes#diff-12a2a29eab84b723e9342e89877c875d3e979220a53884a9103d8c067ffdc286L916-L917",
      "comment_id": 2655190946,
      "user": "jscheffl",
      "created_at": "2025-12-31T10:41:16Z",
      "url": "https://github.com/apache/airflow/pull/59958#discussion_r2655190946"
    },
    {
      "repo": "apache/airflow",
      "pr_number": 59912,
      "file_path": "task-sdk/src/airflow/sdk/definitions/_internal/abstractoperator.py",
      "line": 80,
      "side": "RIGHT",
      "diff_hunk": "@@ -76,7 +76,8 @@\n DEFAULT_TASK_EXECUTION_TIMEOUT: datetime.timedelta | None = conf.gettimedelta(\n     \"core\", \"default_task_execution_timeout\"\n )\n-\n+DEFAULT_EMAIL_ON_FAILURE: bool = conf.getboolean(\"email\", \"default_email_on_failure\", fallback=True)\n+DEFAULT_EMAIL_ON_RETRY: bool = conf.getboolean(\"email\", \"default_email_on_retry\", fallback=True)",
      "comment": "We should have some test coverage for this. The test: `test_default_email_on_actions` only checks for true. Maybe use `conf_vars` to explicitly set to false and assert it.",
      "comment_id": 2652335798,
      "user": "amoghrajesh",
      "created_at": "2025-12-30T06:38:46Z",
      "url": "https://github.com/apache/airflow/pull/59912#discussion_r2652335798"
    },
    {
      "repo": "apache/airflow",
      "pr_number": 59912,
      "file_path": "task-sdk/src/airflow/sdk/definitions/_internal/abstractoperator.py",
      "line": 80,
      "side": "RIGHT",
      "diff_hunk": "@@ -76,7 +76,8 @@\n DEFAULT_TASK_EXECUTION_TIMEOUT: datetime.timedelta | None = conf.gettimedelta(\n     \"core\", \"default_task_execution_timeout\"\n )\n-\n+DEFAULT_EMAIL_ON_FAILURE: bool = conf.getboolean(\"email\", \"default_email_on_failure\", fallback=True)\n+DEFAULT_EMAIL_ON_RETRY: bool = conf.getboolean(\"email\", \"default_email_on_retry\", fallback=True)",
      "comment": "So I've been trying to add some tests using `conf_vars` but I'm running into some issues. The issue (I think) is that  the email defaults are read as module-level constants at import time, so using `conf_vars` requires reloading the modules to pick up config changes. But when I do that, it causes other test files that have already imported operators (which inherit from the original BaseOperator) to fail. Do you know if there are any workarounds for this? ",
      "comment_id": 2653344811,
      "user": "justinpakzad",
      "created_at": "2025-12-30T16:22:30Z",
      "url": "https://github.com/apache/airflow/pull/59912#discussion_r2653344811"
    },
    {
      "repo": "apache/airflow",
      "pr_number": 59912,
      "file_path": "task-sdk/src/airflow/sdk/definitions/_internal/abstractoperator.py",
      "line": 80,
      "side": "RIGHT",
      "diff_hunk": "@@ -76,7 +76,8 @@\n DEFAULT_TASK_EXECUTION_TIMEOUT: datetime.timedelta | None = conf.gettimedelta(\n     \"core\", \"default_task_execution_timeout\"\n )\n-\n+DEFAULT_EMAIL_ON_FAILURE: bool = conf.getboolean(\"email\", \"default_email_on_failure\", fallback=True)\n+DEFAULT_EMAIL_ON_RETRY: bool = conf.getboolean(\"email\", \"default_email_on_retry\", fallback=True)",
      "comment": "Good call, I wouldnt encourage reloading too. If we monkeypatch those vars, it wouldn't validate the intended flow\r\n\r\nI do not have a better proposal as of now, maybe @potiuk does?",
      "comment_id": 2654875088,
      "user": "amoghrajesh",
      "created_at": "2025-12-31T06:20:40Z",
      "url": "https://github.com/apache/airflow/pull/59912#discussion_r2654875088"
    },
    {
      "repo": "apache/airflow",
      "pr_number": 59912,
      "file_path": "task-sdk/src/airflow/sdk/definitions/_internal/abstractoperator.py",
      "line": 80,
      "side": "RIGHT",
      "diff_hunk": "@@ -76,7 +76,8 @@\n DEFAULT_TASK_EXECUTION_TIMEOUT: datetime.timedelta | None = conf.gettimedelta(\n     \"core\", \"default_task_execution_timeout\"\n )\n-\n+DEFAULT_EMAIL_ON_FAILURE: bool = conf.getboolean(\"email\", \"default_email_on_failure\", fallback=True)\n+DEFAULT_EMAIL_ON_RETRY: bool = conf.getboolean(\"email\", \"default_email_on_retry\", fallback=True)",
      "comment": "I think not worth testing it in this case. Those are just default values",
      "comment_id": 2655344965,
      "user": "potiuk",
      "created_at": "2025-12-31T12:38:38Z",
      "url": "https://github.com/apache/airflow/pull/59912#discussion_r2655344965"
    },
    {
      "repo": "apache/airflow",
      "pr_number": 58615,
      "file_path": "task-sdk/src/airflow/sdk/definitions/param.py",
      "line": 58,
      "side": "RIGHT",
      "diff_hunk": "@@ -51,15 +51,27 @@ class Param:\n \n     CLASS_IDENTIFIER = \"__class\"\n \n-    def __init__(self, default: Any = NOTSET, description: str | None = None, **kwargs):\n+    def __init__(\n+        self,\n+        default: Any = NOTSET,\n+        description: str | None = None,\n+        source: Literal[\"Dag\", \"task\", \"Dag run\"] | None = None,",
      "comment": "Not sure if `\"Dag run\"` is intend to be here as I only saw `\"Dag\"` and `\"task\"` above.\n\n```suggestion\n        source: Literal[\"Dag\", \"task\"] | None = None,\n```",
      "comment_id": 2567302130,
      "user": "jason810496",
      "created_at": "2025-11-27T06:19:56Z",
      "url": "https://github.com/apache/airflow/pull/58615#discussion_r2567302130"
    },
    {
      "repo": "apache/airflow",
      "pr_number": 58615,
      "file_path": "providers/standard/src/airflow/providers/standard/operators/hitl.py",
      "line": 89,
      "side": "RIGHT",
      "diff_hunk": "@@ -84,6 +84,9 @@ def __init__(\n         self.multiple = multiple\n \n         self.params: ParamsDict = params if isinstance(params, ParamsDict) else ParamsDict(params or {})\n+        if hasattr(self.params, \"filter_params_by_source\"):\n+            # Params that exist only in Dag level does not make sense to appear in HITLOperator\n+            self.params = ParamsDict.filter_params_by_source(self.params, source=\"task\")",
      "comment": "It _seems_ we don't need to check the attribute as we had already cast the `self.params` as `ParamsDict`, then we could directly call the `filter_params_by_source` method?\n\n```suggestion\n        self.params = ParamsDict.filter_params_by_source(self.params, source=\"task\")\n```",
      "comment_id": 2567316711,
      "user": "jason810496",
      "created_at": "2025-11-27T06:28:07Z",
      "url": "https://github.com/apache/airflow/pull/58615#discussion_r2567316711"
    },
    {
      "repo": "apache/airflow",
      "pr_number": 58615,
      "file_path": "providers/standard/src/airflow/providers/standard/operators/hitl.py",
      "line": 89,
      "side": "RIGHT",
      "diff_hunk": "@@ -84,6 +84,9 @@ def __init__(\n         self.multiple = multiple\n \n         self.params: ParamsDict = params if isinstance(params, ParamsDict) else ParamsDict(params or {})\n+        if hasattr(self.params, \"filter_params_by_source\"):\n+            # Params that exist only in Dag level does not make sense to appear in HITLOperator\n+            self.params = ParamsDict.filter_params_by_source(self.params, source=\"task\")",
      "comment": "It's for backward compatibility, but `hasattr(ParamsDict, \"filter_params_by_source\")` is more explicit.",
      "comment_id": 2567338329,
      "user": "Lee-W",
      "created_at": "2025-11-27T06:40:16Z",
      "url": "https://github.com/apache/airflow/pull/58615#discussion_r2567338329"
    },
    {
      "repo": "apache/airflow",
      "pr_number": 58615,
      "file_path": "airflow-core/src/airflow/api_fastapi/core_api/services/ui/connections.py",
      "line": 71,
      "side": "RIGHT",
      "diff_hunk": "@@ -68,6 +68,7 @@ def __init__(\n             description: str = \"\",\n             default: str | None = None,\n             widget=None,\n+            source: Literal[\"Dag\", \"task\"] | None = None,",
      "comment": "Can we change either to `dag` or `Task`? The mismatched case is very annoying.\n\n(I quickly searched the code base, literal strings tend to be either all-lowercase or ALL-UPPERCASE.)",
      "comment_id": 2567372879,
      "user": "uranusjr",
      "created_at": "2025-11-27T06:58:21Z",
      "url": "https://github.com/apache/airflow/pull/58615#discussion_r2567372879"
    },
    {
      "repo": "apache/airflow",
      "pr_number": 58615,
      "file_path": "airflow-core/src/airflow/api_fastapi/core_api/services/ui/connections.py",
      "line": 71,
      "side": "RIGHT",
      "diff_hunk": "@@ -68,6 +68,7 @@ def __init__(\n             description: str = \"\",\n             default: str | None = None,\n             widget=None,\n+            source: Literal[\"Dag\", \"task\"] | None = None,",
      "comment": "It kinda contradicts the previous consensus, but \"dag\", \"task'` looks better. As our consensus mainly applies to docs, I think it should be fine",
      "comment_id": 2567430037,
      "user": "Lee-W",
      "created_at": "2025-11-27T07:25:54Z",
      "url": "https://github.com/apache/airflow/pull/58615#discussion_r2567430037"
    },
    {
      "repo": "apache/airflow",
      "pr_number": 58615,
      "file_path": "task-sdk/src/airflow/sdk/definitions/param.py",
      "line": 287,
      "side": "RIGHT",
      "diff_hunk": "@@ -253,6 +275,20 @@ def deserialize(data: dict, version: int) -> ParamsDict:\n \n         return ParamsDict(data)\n \n+    def _fill_missing_param_source(\n+        self,\n+        source: Literal[\"dag\", \"task\"] | None = None,\n+    ) -> None:\n+        for key in self.__dict:\n+            if self.__dict[key].source is None:\n+                self.__dict[key].source = source\n+\n+    @staticmethod\n+    def filter_params_by_source(params: ParamsDict, source: Literal[\"Dag\", \"task\"]) -> ParamsDict:",
      "comment": "```suggestion\n    def filter_params_by_source(params: ParamsDict, source: Literal[\"dag\", \"task\"]) -> ParamsDict:\n```",
      "comment_id": 2567503953,
      "user": "jason810496",
      "created_at": "2025-11-27T07:57:28Z",
      "url": "https://github.com/apache/airflow/pull/58615#discussion_r2567503953"
    },
    {
      "repo": "apache/airflow",
      "pr_number": 58615,
      "file_path": "task-sdk/tests/task_sdk/definitions/test_param.py",
      "line": 351,
      "side": "RIGHT",
      "diff_hunk": "@@ -307,3 +311,47 @@ def test_update(self):\n     def test_repr(self):\n         pd = ParamsDict({\"key\": Param(\"value\", type=\"string\")})\n         assert repr(pd) == \"{'key': 'value'}\"\n+\n+    @pytest.mark.parametrize(\"source\", (\"dag\", \"task\"))\n+    def test_fill_missing_param_source(self, source: Literal[\"dag\", \"task\"]):\n+        pd = ParamsDict(\n+            {\n+                \"key\": Param(\"value\", type=\"string\"),\n+                \"key2\": \"value2\",\n+            }\n+        )\n+        pd._fill_missing_param_source(source)\n+        for param in pd.values():\n+            assert param.source == source\n+\n+    def test_fill_missing_param_source_not_overwrite_existing(self):\n+        pd = ParamsDict(\n+            {\n+                \"key\": Param(\"value\", type=\"string\", source=\"dag\"),\n+                \"key2\": \"value2\",\n+                \"key3\": \"value3\",\n+            }\n+        )\n+        pd._fill_missing_param_source(\"task\")\n+        for key, expected_source in (\n+            (\"key\", \"Dag\"),\n+            (\"key2\", \"task\"),\n+            (\"key3\", \"task\"),\n+        ):\n+            assert pd.get_param(key).source == expected_source\n+\n+    def test_filter_params_by_source(self):\n+        pd = ParamsDict(\n+            {\n+                \"key\": Param(\"value\", type=\"string\", source=\"dag\"),\n+                \"key2\": Param(\"value\", source=\"task\"),\n+            }\n+        )\n+        assert ParamsDict.filter_params_by_source(pd, \"Dag\") == ParamsDict(\n+            {\"key\": Param(\"value\", type=\"string\", source=\"Dag\")},",
      "comment": "```suggestion\n        assert ParamsDict.filter_params_by_source(pd, \"dag\") == ParamsDict(\n            {\"key\": Param(\"value\", type=\"string\", source=\"dag\")},\n```",
      "comment_id": 2567505699,
      "user": "jason810496",
      "created_at": "2025-11-27T07:58:08Z",
      "url": "https://github.com/apache/airflow/pull/58615#discussion_r2567505699"
    },
    {
      "repo": "apache/airflow",
      "pr_number": 58615,
      "file_path": "providers/standard/src/airflow/providers/standard/operators/hitl.py",
      "line": 89,
      "side": "RIGHT",
      "diff_hunk": "@@ -84,6 +84,9 @@ def __init__(\n         self.multiple = multiple\n \n         self.params: ParamsDict = params if isinstance(params, ParamsDict) else ParamsDict(params or {})\n+        if hasattr(ParamsDict, \"filter_params_by_source\"):\n+            # Params that exist only in Dag level does not make sense to appear in HITLOperator\n+            self.params = ParamsDict.filter_params_by_source(self.params, source=\"task\")",
      "comment": "Should we add debug log here so when there's no filter_params_by_source, users are told about it:\r\n\r\n```python\r\nelse:\r\n    log.debug(\"ParamsDict.filter_params_by_source not available; HITLOperator will show all params.\")\r\n```",
      "comment_id": 2570766725,
      "user": "ephraimbuddy",
      "created_at": "2025-11-28T08:11:40Z",
      "url": "https://github.com/apache/airflow/pull/58615#discussion_r2570766725"
    }
  ]
}